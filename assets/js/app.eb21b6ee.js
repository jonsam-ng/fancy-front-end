(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,i,s=e[0],l=e[1],c=e[2],d=0,u=[];d<s.length;d++)i=s[d],Object.prototype.hasOwnProperty.call(o,i)&&o[i]&&u.push(o[i][0]),o[i]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(p&&p(e);u.length;)u.shift()();return a.push.apply(a,c||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==o[l]&&(r=!1)}r&&(a.splice(e--,1),n=i(i.s=t[0]))}return n}var r={},o={1:0},a=[];function i(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=o[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=o[n]=[e,r]}));e.push(t[2]=r);var a,s=document.createElement("script");s.charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.src=function(n){return i.p+"assets/js/"+({}[n]||n)+"."+{2:"01e091c2",3:"50570587",4:"54e60667",5:"f620477b",6:"8880bb8c",7:"0c293177",8:"7cbef5ec",9:"2a7e5bdc",10:"ac472f43",11:"c50183f9",12:"71337abb",13:"292db5f6",14:"54d2636a",15:"81d908ff",16:"68d8e787",17:"895175dc",18:"736b781d",19:"504bd141",20:"e526fb51",21:"8375d39e",22:"0e15b626",23:"83bcc15c",24:"3df554ce",25:"6c56da2b",26:"76154857",27:"155dbcb4",28:"7178e96c",29:"f7337396",30:"191545d3",31:"b6a0fe90",32:"18cebeab",33:"146782c3",34:"c08af9cb",35:"ea730de0",36:"11aba0b0",37:"0fd8e20a",38:"2cde6902",39:"07c230cc",40:"e4fcccd0",41:"5f96c201",42:"e5023440",43:"2cfdc8d9",44:"37f32c52",45:"3973ea4b",46:"87541312",47:"04f0011f",48:"1151f311",49:"6830fb0c",50:"84b34574",51:"840f38c4",52:"3dbda6e7",53:"7f0a8896",54:"5d7f6427",55:"86c7b544",56:"49a27b9a",57:"287f9e58",58:"40a49fdb",59:"91487422",60:"8dfd58ee",61:"7b4874b9",62:"d83f3691",63:"1237a900",64:"1f096a25",65:"809d988d",66:"43c1e5f9",67:"24ab137d",68:"7b0346b5",69:"2008c989",70:"e8cf3232",71:"d661943d",72:"e67a47a3",73:"87f1db52",74:"ac67cd0d",75:"e25ebf69",76:"a7222468",77:"ffb71305",78:"72c00bee",79:"66ec368e",80:"8792d3d7",81:"49d3731a",82:"fbe09e61",83:"220a02bb",84:"4b722410",85:"f83d2db9",86:"17b19d53",87:"37568307",88:"d7cc6612",89:"ffb378d0",90:"02c91127",91:"c22d9224",92:"c79d457a",93:"33a03732",94:"c73ddbbc",95:"a5151497",96:"b8f204d2",97:"d7ddaa6f",98:"49dbda5e",99:"d14f43ad",100:"8081075e",101:"943ea683",102:"11c8554c",103:"c2780521",104:"81994794",105:"f987244b",106:"235a578e",107:"94cdbb18",108:"3a80cb29",109:"8884be03",110:"89ab5eb2",111:"355b1782",112:"34671c87",113:"0cca0902",114:"01616168",115:"4915c0b5",116:"ef93855a",117:"e3526ed0",118:"7d52a4ea",119:"a4bb17bb",120:"135aa6ea",121:"86c35c15",122:"1452986d",123:"0181b553",124:"edc508f8",125:"46d932c1",126:"17e05a12",127:"98159dfe",128:"9aaa5bc6",129:"26bed928",130:"9f74c846",131:"d6ef0885",132:"1d9ee075",133:"2b23ed7b",134:"c47e8a23",135:"2aeb3426",136:"0169c47b",137:"70cdfc24",138:"e54160ee",139:"9a6d1932",140:"ddabaeca",141:"35844ecc",142:"4ccdb5e4",143:"37a7f36e",144:"95ff6a63",145:"9899e545",146:"6865658b",147:"2a55d18a",148:"f3aab640",149:"57b565a0",150:"3f7143ae",151:"5981cf9e",152:"a3428a7b",153:"0f0b339d",154:"39f3b522",155:"13c8170a",156:"ccb66614",157:"4b8bce50",158:"6476dd1c",159:"b261a009",160:"e501007d",161:"d3f56d3d",162:"f8590797",163:"91fe4509",164:"6e92f3f4",165:"56868a39",166:"83812a3b",167:"4b528df4",168:"f2b151fb",169:"cb2ee128",170:"63b574e9",171:"ad38a311",172:"b592b97e",173:"302ef08b",174:"d71ad1a3",175:"2617c860",176:"19a67035",177:"75aab37d",178:"b2773712",179:"6a34b45f",180:"d447fc48",181:"d6b96886",182:"42c2bcd5",183:"a6256a82",184:"8a036f5a",185:"811d5831",186:"6436a583",187:"4bcf94a3",188:"33f39bd6",189:"c1b90840"}[n]+".js"}(n);var l=new Error;a=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=o[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+a+")",l.name="ChunkLoadError",l.type=r,l.request=a,t[1](l)}o[n]=void 0}};var c=setTimeout((function(){a({type:"timeout",target:s})}),12e4);s.onerror=s.onload=a,document.head.appendChild(s)}return Promise.all(e)},i.m=n,i.c=r,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)i.d(t,r,function(e){return n[e]}.bind(null,r));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/",i.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var p=l;a.push([116,0]),t()}([function(n,e,t){"use strict";t.d(e,"d",(function(){return b})),t.d(e,"c",(function(){return v})),t.d(e,"b",(function(){return k})),t.d(e,"e",(function(){return w})),t.d(e,"a",(function(){return x})),t.d(e,"f",(function(){return T})),t.d(e,"g",(function(){return C})),t.d(e,"h",(function(){return R}));t(20),t(144);var r=t(1),o={NotFound:()=>Promise.all([t.e(0),t.e(13)]).then(t.bind(null,377)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,375))},a={"v-376508bf":()=>t.e(16).then(t.bind(null,388)),"v-3611955d":()=>t.e(17).then(t.bind(null,389)),"v-0d7bb8be":()=>t.e(18).then(t.bind(null,390)),"v-359e682f":()=>t.e(19).then(t.bind(null,391)),"v-a1dbc2a2":()=>t.e(20).then(t.bind(null,392)),"v-406c3962":()=>t.e(21).then(t.bind(null,393)),"v-4b4b48ab":()=>t.e(22).then(t.bind(null,394)),"v-4d309ab6":()=>t.e(23).then(t.bind(null,395)),"v-1a05c896":()=>t.e(24).then(t.bind(null,396)),"v-27daf196":()=>t.e(25).then(t.bind(null,397)),"v-e4ff14f8":()=>t.e(26).then(t.bind(null,398)),"v-1daf77ea":()=>t.e(27).then(t.bind(null,399)),"v-7050b2a0":()=>t.e(28).then(t.bind(null,400)),"v-41adcea0":()=>t.e(29).then(t.bind(null,401)),"v-a7e4381c":()=>t.e(30).then(t.bind(null,402)),"v-fefa4114":()=>t.e(31).then(t.bind(null,403)),"v-21473796":()=>t.e(32).then(t.bind(null,404)),"v-492f4a82":()=>t.e(33).then(t.bind(null,405)),"v-1d8100c2":()=>t.e(34).then(t.bind(null,406)),"v-fcc2e96a":()=>t.e(35).then(t.bind(null,407)),"v-36e6278b":()=>t.e(36).then(t.bind(null,408)),"v-0fd7e2db":()=>t.e(37).then(t.bind(null,409)),"v-fda4440a":()=>t.e(38).then(t.bind(null,410)),"v-228419df":()=>t.e(39).then(t.bind(null,411)),"v-2778a33b":()=>t.e(40).then(t.bind(null,412)),"v-230de106":()=>t.e(41).then(t.bind(null,413)),"v-1154a3c8":()=>t.e(42).then(t.bind(null,414)),"v-35203ba8":()=>t.e(43).then(t.bind(null,415)),"v-59f008fe":()=>t.e(44).then(t.bind(null,416)),"v-5de90ac4":()=>t.e(45).then(t.bind(null,417)),"v-071d800b":()=>t.e(46).then(t.bind(null,418)),"v-7532101f":()=>t.e(47).then(t.bind(null,419)),"v-05b01242":()=>t.e(48).then(t.bind(null,420)),"v-1e97eeff":()=>t.e(49).then(t.bind(null,421)),"v-5962efbf":()=>t.e(50).then(t.bind(null,422)),"v-d7a41f02":()=>t.e(51).then(t.bind(null,423)),"v-620e1d82":()=>t.e(52).then(t.bind(null,424)),"v-09c3f1ff":()=>t.e(53).then(t.bind(null,425)),"v-448ef2bf":()=>t.e(54).then(t.bind(null,426)),"v-7f59f37f":()=>t.e(55).then(t.bind(null,427)),"v-8bb61782":()=>t.e(56).then(t.bind(null,428)),"v-4079c547":()=>t.e(57).then(t.bind(null,429)),"v-5585c5df":()=>t.e(58).then(t.bind(null,430)),"v-50140a3b":()=>t.e(59).then(t.bind(null,431)),"v-ec07c126":()=>t.e(60).then(t.bind(null,432)),"v-2d7c6c07":()=>t.e(61).then(t.bind(null,433)),"v-49f7f4ca":()=>t.e(62).then(t.bind(null,434)),"v-321a8dff":()=>t.e(63).then(t.bind(null,435)),"v-2e216f3f":()=>t.e(64).then(t.bind(null,436)),"v-1d06307d":()=>t.e(65).then(t.bind(null,437)),"v-cecea10e":()=>t.e(66).then(t.bind(null,438)),"v-620539aa":()=>t.e(67).then(t.bind(null,439)),"v-5d322c1d":()=>t.e(68).then(t.bind(null,440)),"v-dcaaef7a":()=>t.e(69).then(t.bind(null,441)),"v-4d69bd7d":()=>t.e(70).then(t.bind(null,442)),"v-eea5a8ce":()=>t.e(71).then(t.bind(null,443)),"v-7c3809bd":()=>t.e(72).then(t.bind(null,444)),"v-47f301c6":()=>t.e(73).then(t.bind(null,445)),"v-7844a83d":()=>t.e(74).then(t.bind(null,446)),"v-847c1376":()=>t.e(75).then(t.bind(null,447)),"v-36768879":()=>t.e(76).then(t.bind(null,448)),"v-af98cc06":()=>t.e(77).then(t.bind(null,449)),"v-7b4d74fd":()=>t.e(78).then(t.bind(null,450)),"v-50e647d9":()=>t.e(79).then(t.bind(null,451)),"v-26e7ba7d":()=>t.e(80).then(t.bind(null,452)),"v-566737cd":()=>t.e(81).then(t.bind(null,453)),"v-6e8687a2":()=>t.e(82).then(t.bind(null,454)),"v-7373c0fa":()=>t.e(83).then(t.bind(null,455)),"v-55a8d0bf":()=>t.e(84).then(t.bind(null,456)),"v-18766245":()=>t.e(85).then(t.bind(null,457)),"v-53f20ec6":()=>t.e(86).then(t.bind(null,458)),"v-4bc33869":()=>t.e(87).then(t.bind(null,459)),"v-687541db":()=>t.e(88).then(t.bind(null,460)),"v-6414adc6":()=>t.e(89).then(t.bind(null,461)),"v-2985970b":()=>t.e(90).then(t.bind(null,462)),"v-aef55d32":()=>t.e(91).then(t.bind(null,463)),"v-25439586":()=>t.e(92).then(t.bind(null,464)),"v-27eebe53":()=>t.e(93).then(t.bind(null,465)),"v-2080504b":()=>t.e(94).then(t.bind(null,466)),"v-057781cb":()=>t.e(95).then(t.bind(null,467)),"v-2af34dca":()=>t.e(96).then(t.bind(null,468)),"v-f790ca6e":()=>t.e(97).then(t.bind(null,469)),"v-1061317b":()=>t.e(98).then(t.bind(null,470)),"v-1ba4b31b":()=>t.e(99).then(t.bind(null,471)),"v-6b7f390c":()=>t.e(100).then(t.bind(null,472)),"v-3bded94c":()=>t.e(101).then(t.bind(null,473)),"v-0b29f556":()=>t.e(102).then(t.bind(null,474)),"v-70bd8ed4":()=>t.e(103).then(t.bind(null,475)),"v-5cc090d4":()=>t.e(104).then(t.bind(null,476)),"v-4dfd12d8":()=>t.e(105).then(t.bind(null,477)),"v-3336f808":()=>t.e(106).then(t.bind(null,478)),"v-3bd3e459":()=>t.e(107).then(t.bind(null,479)),"v-3bb59422":()=>t.e(108).then(t.bind(null,480)),"v-44bace4f":()=>t.e(109).then(t.bind(null,481)),"v-73517018":()=>t.e(110).then(t.bind(null,482)),"v-db70af54":()=>t.e(111).then(t.bind(null,483)),"v-e148fee0":()=>t.e(112).then(t.bind(null,484)),"v-6644dbd4":()=>t.e(113).then(t.bind(null,485)),"v-1bd41a5b":()=>t.e(114).then(t.bind(null,486)),"v-82122182":()=>t.e(116).then(t.bind(null,487)),"v-1401de91":()=>t.e(115).then(t.bind(null,488)),"v-1ff4e09f":()=>t.e(117).then(t.bind(null,489)),"v-f54ae5ba":()=>t.e(118).then(t.bind(null,490)),"v-52bd35e5":()=>t.e(119).then(t.bind(null,491)),"v-7c668ae7":()=>t.e(120).then(t.bind(null,492)),"v-6e596402":()=>t.e(121).then(t.bind(null,493)),"v-263cdfff":()=>t.e(125).then(t.bind(null,494)),"v-6646936e":()=>t.e(122).then(t.bind(null,495)),"v-4956ba5f":()=>t.e(126).then(t.bind(null,496)),"v-a0fcd902":()=>t.e(127).then(t.bind(null,497)),"v-b7416126":()=>t.e(128).then(t.bind(null,498)),"v-353fcddf":()=>t.e(129).then(t.bind(null,499)),"v-33490a39":()=>t.e(130).then(t.bind(null,500)),"v-51af4a72":()=>t.e(131).then(t.bind(null,501)),"v-07fff7d7":()=>t.e(132).then(t.bind(null,502)),"v-725a2703":()=>t.e(133).then(t.bind(null,503)),"v-ca971886":()=>t.e(134).then(t.bind(null,504)),"v-6892877d":()=>t.e(135).then(t.bind(null,505)),"v-d23fd306":()=>t.e(136).then(t.bind(null,506)),"v-210aaa1d":()=>t.e(137).then(t.bind(null,507)),"v-377700fe":()=>t.e(138).then(t.bind(null,508)),"v-405fbd6a":()=>t.e(139).then(t.bind(null,509)),"v-761f238a":()=>t.e(140).then(t.bind(null,510)),"v-c3847a42":()=>t.e(141).then(t.bind(null,511)),"v-87d0754a":()=>t.e(142).then(t.bind(null,512)),"v-2da3183a":()=>t.e(143).then(t.bind(null,513)),"v-53a11582":()=>t.e(144).then(t.bind(null,514)),"v-4c8845fc":()=>t.e(145).then(t.bind(null,515)),"v-df747cda":()=>t.e(146).then(t.bind(null,516)),"v-c36c87c2":()=>t.e(147).then(t.bind(null,517)),"v-397f75f5":()=>t.e(148).then(t.bind(null,518)),"v-b6310e56":()=>t.e(149).then(t.bind(null,519)),"v-0d9c3a15":()=>t.e(150).then(t.bind(null,520)),"v-8da47476":()=>t.e(151).then(t.bind(null,521)),"v-4bc1c689":()=>t.e(152).then(t.bind(null,522)),"v-7b75117d":()=>t.e(153).then(t.bind(null,523)),"v-10d9c13d":()=>t.e(154).then(t.bind(null,524)),"v-778f237d":()=>t.e(155).then(t.bind(null,525)),"v-5b6dcd7d":()=>t.e(156).then(t.bind(null,526)),"v-42d8aff9":()=>t.e(157).then(t.bind(null,527)),"v-7c8f5906":()=>t.e(158).then(t.bind(null,528)),"v-55778605":()=>t.e(159).then(t.bind(null,529)),"v-51bac5f7":()=>t.e(160).then(t.bind(null,530)),"v-f55aa90e":()=>t.e(161).then(t.bind(null,531)),"v-ea939fc6":()=>t.e(162).then(t.bind(null,532)),"v-498b6e86":()=>t.e(164).then(t.bind(null,533)),"v-c9eede46":()=>t.e(163).then(t.bind(null,534)),"v-3fcd21c9":()=>t.e(165).then(t.bind(null,535)),"v-3552c17d":()=>t.e(166).then(t.bind(null,536)),"v-dca0dbea":()=>t.e(167).then(t.bind(null,537)),"v-73c1945d":()=>t.e(168).then(t.bind(null,538)),"v-074761b1":()=>t.e(169).then(t.bind(null,539)),"v-82075c46":()=>t.e(170).then(t.bind(null,540)),"v-cf050632":()=>t.e(171).then(t.bind(null,541)),"v-bebe86c6":()=>t.e(172).then(t.bind(null,542)),"v-4fe65767":()=>t.e(173).then(t.bind(null,543)),"v-6fba7546":()=>t.e(174).then(t.bind(null,544)),"v-0790c155":()=>t.e(176).then(t.bind(null,545)),"v-97306cda":()=>t.e(175).then(t.bind(null,546)),"v-6cc4c933":()=>t.e(177).then(t.bind(null,547)),"v-d744eac6":()=>t.e(178).then(t.bind(null,548)),"v-2bac39fd":()=>t.e(179).then(t.bind(null,549)),"v-39df881d":()=>t.e(180).then(t.bind(null,550)),"v-75a63fbd":()=>t.e(181).then(t.bind(null,551)),"v-2af0da94":()=>t.e(182).then(t.bind(null,552)),"v-7d3a31b9":()=>t.e(184).then(t.bind(null,378)),"v-d2407716":()=>t.e(183).then(t.bind(null,553)),"v-6196523d":()=>t.e(124).then(t.bind(null,554)),"v-5d5e22bf":()=>t.e(123).then(t.bind(null,555))};function i(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const s=/-(\w)/g,l=i(n=>n.replace(s,(n,e)=>e?e.toUpperCase():"")),c=/\B([A-Z])/g,p=i(n=>n.replace(c,"-$1").toLowerCase()),d=i(n=>n.charAt(0).toUpperCase()+n.slice(1));function u(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(d(l(e))):n(d(e))||n(p(e))}const m=Object.assign({},o,a),h=n=>m[n],f=n=>a[n],g=n=>o[n],y=n=>r.default.component(n);function b(n){return u(f,n)}function v(n){return u(g,n)}function k(n){return u(h,n)}function w(n){return u(y,n)}function x(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!w(n)&&k(n)){const e=await k(n)();r.default.component(n,e.default)}}))}function T(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}function C(n,e){const{$localePath:t}=n;return"object"==typeof e&&e[t]?e[t]:e}function R(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}},function(n,e,t){"use strict";t.r(e),function(n){t.d(e,"EffectScope",(function(){return we})),t.d(e,"computed",(function(){return pe})),t.d(e,"customRef",(function(){return ee})),t.d(e,"default",(function(){return no})),t.d(e,"defineAsyncComponent",(function(){return Ot})),t.d(e,"defineComponent",(function(){return Jt})),t.d(e,"del",(function(){return $n})),t.d(e,"effectScope",(function(){return xe})),t.d(e,"getCurrentInstance",(function(){return un})),t.d(e,"getCurrentScope",(function(){return Te})),t.d(e,"h",(function(){return ft})),t.d(e,"inject",(function(){return Se})),t.d(e,"isProxy",(function(){return Fn})),t.d(e,"isReactive",(function(){return In})),t.d(e,"isReadonly",(function(){return On})),t.d(e,"isRef",(function(){return Kn})),t.d(e,"isShallow",(function(){return jn})),t.d(e,"markRaw",(function(){return Mn})),t.d(e,"mergeDefaults",(function(){return pt})),t.d(e,"nextTick",(function(){return _t})),t.d(e,"onActivated",(function(){return Ut})),t.d(e,"onBeforeMount",(function(){return At})),t.d(e,"onBeforeUnmount",(function(){return qt})),t.d(e,"onBeforeUpdate",(function(){return Dt})),t.d(e,"onDeactivated",(function(){return Nt})),t.d(e,"onErrorCaptured",(function(){return Vt})),t.d(e,"onMounted",(function(){return Mt})),t.d(e,"onRenderTracked",(function(){return Wt})),t.d(e,"onRenderTriggered",(function(){return Bt})),t.d(e,"onScopeDispose",(function(){return Ce})),t.d(e,"onServerPrefetch",(function(){return Ht})),t.d(e,"onUnmounted",(function(){return Lt})),t.d(e,"onUpdated",(function(){return zt})),t.d(e,"provide",(function(){return Re})),t.d(e,"proxyRefs",(function(){return Yn})),t.d(e,"reactive",(function(){return Sn})),t.d(e,"readonly",(function(){return ie})),t.d(e,"ref",(function(){return Jn})),t.d(e,"set",(function(){return Bn})),t.d(e,"shallowReactive",(function(){return Pn})),t.d(e,"shallowReadonly",(function(){return ce})),t.d(e,"shallowRef",(function(){return Gn})),t.d(e,"toRaw",(function(){return An})),t.d(e,"toRef",(function(){return re})),t.d(e,"toRefs",(function(){return te})),t.d(e,"triggerRef",(function(){return Xn})),t.d(e,"unref",(function(){return Zn})),t.d(e,"useAttrs",(function(){return st})),t.d(e,"useCssModule",(function(){return It})),t.d(e,"useCssVars",(function(){return jt})),t.d(e,"useListeners",(function(){return lt})),t.d(e,"useSlots",(function(){return it})),t.d(e,"version",(function(){return Kt})),t.d(e,"watch",(function(){return ve})),t.d(e,"watchEffect",(function(){return he})),t.d(e,"watchPostEffect",(function(){return fe})),t.d(e,"watchSyncEffect",(function(){return ge}));
/*!
 * Vue.js v2.7.13
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),o=Array.isArray;function a(n){return null==n}function i(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function p(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function u(n){return"[object Object]"===d.call(n)}function m(n){return"[object RegExp]"===d.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return i(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||u(n)&&n.toString===d?JSON.stringify(n,null,2):String(n)}function y(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),r=n.split(","),o=0;o<r.length;o++)t[r[o]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var v=b("key,ref,slot,slot-scope,is");function k(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var r=n.indexOf(e);if(r>-1)return n.splice(r,1)}}var w=Object.prototype.hasOwnProperty;function x(n,e){return w.call(n,e)}function T(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var C=/-(\w)/g,R=T((function(n){return n.replace(C,(function(n,e){return e?e.toUpperCase():""}))})),E=T((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),S=/\B([A-Z])/g,P=T((function(n){return n.replace(S,"-$1").toLowerCase()}));var _=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function I(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function j(n,e){for(var t in e)n[t]=e[t];return n}function O(n){for(var e={},t=0;t<n.length;t++)n[t]&&j(e,n[t]);return e}function F(n,e,t){}var A=function(n,e,t){return!1},M=function(n){return n};function D(n,e){if(n===e)return!0;var t=p(n),r=p(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var o=Array.isArray(n),a=Array.isArray(e);if(o&&a)return n.length===e.length&&n.every((function(n,t){return D(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(o||a)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return D(n[t],e[t])}))}catch(n){return!1}}function z(n,e){for(var t=0;t<n.length;t++)if(D(n[t],e))return t;return-1}function q(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function L(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var U=["component","directive","filter"],N=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],H={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:A,isReservedAttr:A,isUnknownElement:A,getTagNamespace:F,parsePlatformTagName:M,mustUseProp:A,async:!0,_lifecycleHooks:N},W=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function B(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function $(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var V=new RegExp("[^".concat(W.source,".$_\\d]"));var K="__proto__"in{},J="undefined"!=typeof window,G=J&&window.navigator.userAgent.toLowerCase(),Q=G&&/msie|trident/.test(G),X=G&&G.indexOf("msie 9.0")>0,Z=G&&G.indexOf("edge/")>0;G&&G.indexOf("android");var Y=G&&/iphone|ipad|ipod|ios/.test(G);G&&/chrome\/\d+/.test(G),G&&/phantomjs/.test(G);var nn,en=G&&G.match(/firefox\/(\d+)/),tn={}.watch,rn=!1;if(J)try{var on={};Object.defineProperty(on,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,on)}catch(n){}var an=function(){return void 0===nn&&(nn=!J&&void 0!==n&&(n.process&&"server"===n.process.env.VUE_ENV)),nn},sn=J&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,pn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var dn=null;function un(){return dn&&{proxy:dn}}function mn(n){void 0===n&&(n=null),n||dn&&dn._scope.off(),dn=n,n&&n._scope.on()}var hn=function(){function n(n,e,t,r,o,a,i,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=o,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),fn=function(n){void 0===n&&(n="");var e=new hn;return e.text=n,e.isComment=!0,e};function gn(n){return new hn(void 0,void 0,void 0,String(n))}function yn(n){var e=new hn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var bn=0,vn=[],kn=function(){function n(){this._pending=!1,this.id=bn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,vn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,r=e.length;t<r;t++){0,e[t].update()}},n}();kn.target=null;var wn=[];function xn(n){wn.push(n),kn.target=n}function Tn(){wn.pop(),kn.target=wn[wn.length-1]}var Cn=Array.prototype,Rn=Object.create(Cn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=Cn[n];$(Rn,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var o,a=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":o=t;break;case"splice":o=t.slice(2)}return o&&i.observeArray(o),i.dep.notify(),a}))}));var En=new WeakMap;function Sn(n){return _n(n,!1),n}function Pn(n){return _n(n,!0),$(n,"__v_isShallow",!0),n}function _n(n,e){if(!On(n)){Hn(n,e,an());0}}function In(n){return On(n)?In(n.__v_raw):!(!n||!n.__ob__)}function jn(n){return!(!n||!n.__v_isShallow)}function On(n){return!(!n||!n.__v_isReadonly)}function Fn(n){return In(n)||On(n)}function An(n){var e=n&&n.__v_raw;return e?An(e):n}function Mn(n){return p(n)&&En.set(n,!0),n}var Dn=Object.getOwnPropertyNames(Rn),zn={},qn=!0;function Ln(n){qn=n}var Un={notify:F,depend:F,addSub:F,removeSub:F},Nn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?Un:new kn,this.vmCount=0,$(n,"__ob__",this),o(n)){if(!t)if(K)n.__proto__=Rn;else for(var r=0,a=Dn.length;r<a;r++){$(n,s=Dn[r],Rn[s])}e||this.observeArray(n)}else{var i=Object.keys(n);for(r=0;r<i.length;r++){var s;Wn(n,s=i[r],zn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Hn(n[e],!1,this.mock)},n}();function Hn(n,e,t){return n&&x(n,"__ob__")&&n.__ob__ instanceof Nn?n.__ob__:!qn||!t&&an()||!o(n)&&!u(n)||!Object.isExtensible(n)||n.__v_skip||En.has(n)||Kn(n)||n instanceof hn?void 0:new Nn(n,e,t)}function Wn(n,e,t,r,a,i){var s=new kn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,p=l&&l.set;c&&!p||t!==zn&&2!==arguments.length||(t=n[e]);var d=!a&&Hn(t,!1,i);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return kn.target&&(s.depend(),d&&(d.dep.depend(),o(e)&&Vn(e))),Kn(e)&&!a?e.value:e},set:function(e){var r=c?c.call(n):t;if(L(r,e)){if(p)p.call(n,e);else{if(c)return;if(!a&&Kn(r)&&!Kn(e))return void(r.value=e);t=e}d=!a&&Hn(e,!1,i),s.notify()}}}),s}}function Bn(n,e,t){if(!On(n)){var r=n.__ob__;return o(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&Hn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(Wn(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function $n(n,e){if(o(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||On(n)||x(n,e)&&(delete n[e],t&&t.dep.notify())}}function Vn(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),o(e)&&Vn(e)}function Kn(n){return!(!n||!0!==n.__v_isRef)}function Jn(n){return Qn(n,!1)}function Gn(n){return Qn(n,!0)}function Qn(n,e){if(Kn(n))return n;var t={};return $(t,"__v_isRef",!0),$(t,"__v_isShallow",e),$(t,"dep",Wn(t,"value",n,null,e,an())),t}function Xn(n){n.dep&&n.dep.notify()}function Zn(n){return Kn(n)?n.value:n}function Yn(n){if(In(n))return n;for(var e={},t=Object.keys(n),r=0;r<t.length;r++)ne(e,n,t[r]);return e}function ne(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Kn(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];Kn(r)&&!Kn(n)?r.value=n:e[t]=n}})}function ee(n){var e=new kn,t=n((function(){e.depend()}),(function(){e.notify()})),r=t.get,o=t.set,a={get value(){return r()},set value(n){o(n)}};return $(a,"__v_isRef",!0),a}function te(n){var e=o(n)?new Array(n.length):{};for(var t in n)e[t]=re(n,t);return e}function re(n,e,t){var r=n[e];if(Kn(r))return r;var o={get value(){var r=n[e];return void 0===r?t:r},set value(t){n[e]=t}};return $(o,"__v_isRef",!0),o}var oe=new WeakMap,ae=new WeakMap;function ie(n){return se(n,!1)}function se(n,e){if(!u(n))return n;if(On(n))return n;var t=e?ae:oe,r=t.get(n);if(r)return r;var o=Object.create(Object.getPrototypeOf(n));t.set(n,o),$(o,"__v_isReadonly",!0),$(o,"__v_raw",n),Kn(n)&&$(o,"__v_isRef",!0),(e||jn(n))&&$(o,"__v_isShallow",!0);for(var a=Object.keys(n),i=0;i<a.length;i++)le(o,n,a[i],e);return o}function le(n,e,t,r){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];return r||!u(n)?n:ie(n)},set:function(){}})}function ce(n){return se(n,!0)}function pe(n,e){var t,r,o=c(n);o?(t=n,r=F):(t=n.get,r=n.set);var a=an()?null:new Yt(dn,t,F,{lazy:!0});var i={effect:a,get value(){return a?(a.dirty&&a.evaluate(),kn.target&&a.depend(),a.value):t()},set value(n){r(n)}};return $(i,"__v_isRef",!0),$(i,"__v_isReadonly",o),i}var de="".concat("watcher"," callback"),ue="".concat("watcher"," getter"),me="".concat("watcher"," cleanup");function he(n,e){return ke(n,null,e)}function fe(n,e){return ke(n,null,{flush:"post"})}function ge(n,e){return ke(n,null,{flush:"sync"})}var ye,be={};function ve(n,e,t){return ke(n,e,t)}function ke(n,e,t){var a=void 0===t?r:t,i=a.immediate,s=a.deep,l=a.flush,p=void 0===l?"pre":l;a.onTrack,a.onTrigger;var d,u,m=dn,h=function(n,e,t){return void 0===t&&(t=null),yt(n,null,t,m,e)},f=!1,g=!1;if(Kn(n)?(d=function(){return n.value},f=jn(n)):In(n)?(d=function(){return n.__ob__.dep.depend(),n},s=!0):o(n)?(g=!0,f=n.some((function(n){return In(n)||jn(n)})),d=function(){return n.map((function(n){return Kn(n)?n.value:In(n)?Qt(n):c(n)?h(n,ue):void 0}))}):d=c(n)?e?function(){return h(n,ue)}:function(){if(!m||!m._isDestroyed)return u&&u(),h(n,"watcher",[b])}:F,e&&s){var y=d;d=function(){return Qt(y())}}var b=function(n){u=v.onStop=function(){h(n,me)}};if(an())return b=F,e?i&&h(e,de,[d(),g?[]:void 0,b]):d(),F;var v=new Yt(dn,d,F,{lazy:!0});v.noRecurse=!e;var k=g?[]:be;return v.run=function(){if(v.active)if(e){var n=v.get();(s||f||(g?n.some((function(n,e){return L(n,k[e])})):L(n,k)))&&(u&&u(),h(e,de,[n,k===be?void 0:k,b]),k=n)}else v.get()},"sync"===p?v.update=v.run:"post"===p?(v.post=!0,v.update=function(){return kr(v)}):v.update=function(){if(m&&m===dn&&!m._isMounted){var n=m._preWatchers||(m._preWatchers=[]);n.indexOf(v)<0&&n.push(v)}else kr(v)},e?i?v.run():k=v.get():"post"===p&&m?m.$once("hook:mounted",(function(){return v.get()})):v.get(),function(){v.teardown()}}var we=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=ye,!n&&ye&&(this.index=(ye.scopes||(ye.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=ye;try{return ye=this,n()}finally{ye=e}}else 0},n.prototype.on=function(){ye=this},n.prototype.off=function(){ye=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},n}();function xe(n){return new we(n)}function Te(){return ye}function Ce(n){ye&&ye.cleanups.push(n)}function Re(n,e){dn&&(Ee(dn)[n]=e)}function Ee(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}function Se(n,e,t){void 0===t&&(t=!1);var r=dn;if(r){var o=r.$parent&&r.$parent._provided;if(o&&n in o)return o[n];if(arguments.length>1)return t&&c(e)?e.call(r):e}else 0}var Pe=T((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function _e(n,e){function t(){var n=t.fns;if(!o(n))return yt(n,null,arguments,e,"v-on handler");for(var r=n.slice(),a=0;a<r.length;a++)yt(r[a],null,arguments,e,"v-on handler")}return t.fns=n,t}function Ie(n,e,t,r,o,i){var l,c,p,d;for(l in n)c=n[l],p=e[l],d=Pe(l),a(c)||(a(p)?(a(c.fns)&&(c=n[l]=_e(c,i)),s(d.once)&&(c=n[l]=o(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==p&&(p.fns=c,n[l]=p));for(l in e)a(n[l])&&r((d=Pe(l)).name,e[l],d.capture)}function je(n,e,t){var r;n instanceof hn&&(n=n.data.hook||(n.data.hook={}));var o=n[e];function l(){t.apply(this,arguments),k(r.fns,l)}a(o)?r=_e([l]):i(o.fns)&&s(o.merged)?(r=o).fns.push(l):r=_e([o,l]),r.merged=!0,n[e]=r}function Oe(n,e,t,r,o){if(i(e)){if(x(e,t))return n[t]=e[t],o||delete e[t],!0;if(x(e,r))return n[t]=e[r],o||delete e[r],!0}return!1}function Fe(n){return l(n)?[gn(n)]:o(n)?function n(e,t){var r,c,p,d,u=[];for(r=0;r<e.length;r++)a(c=e[r])||"boolean"==typeof c||(p=u.length-1,d=u[p],o(c)?c.length>0&&(Ae((c=n(c,"".concat(t||"","_").concat(r)))[0])&&Ae(d)&&(u[p]=gn(d.text+c[0].text),c.shift()),u.push.apply(u,c)):l(c)?Ae(d)?u[p]=gn(d.text+c):""!==c&&u.push(gn(c)):Ae(c)&&Ae(d)?u[p]=gn(d.text+c.text):(s(e._isVList)&&i(c.tag)&&a(c.key)&&i(t)&&(c.key="__vlist".concat(t,"_").concat(r,"__")),u.push(c)));return u}(n):void 0}function Ae(n){return i(n)&&i(n.text)&&!1===n.isComment}function Me(n,e){var t,r,a,s,l=null;if(o(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(p(n))if(pn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),d=c.next();!d.done;)l.push(e(d.value,l.length)),d=c.next()}else for(a=Object.keys(n),l=new Array(a.length),t=0,r=a.length;t<r;t++)s=a[t],l[t]=e(n[s],s,t);return i(l)||(l=[]),l._isVList=!0,l}function De(n,e,t,r){var o,a=this.$scopedSlots[n];a?(t=t||{},r&&(t=j(j({},r),t)),o=a(t)||(c(e)?e():e)):o=this.$slots[n]||(c(e)?e():e);var i=t&&t.slot;return i?this.$createElement("template",{slot:i},o):o}function ze(n){return qr(this.$options,"filters",n,!0)||M}function qe(n,e){return o(n)?-1===n.indexOf(e):n!==e}function Le(n,e,t,r,o){var a=H.keyCodes[e]||t;return o&&r&&!H.keyCodes[e]?qe(o,r):a?qe(a,n):r?P(r)!==e:void 0===n}function Ue(n,e,t,r,a){if(t)if(p(t)){o(t)&&(t=O(t));var i=void 0,s=function(o){if("class"===o||"style"===o||v(o))i=n;else{var s=n.attrs&&n.attrs.type;i=r||H.mustUseProp(e,s,o)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=R(o),c=P(o);l in i||c in i||(i[o]=t[o],a&&((n.on||(n.on={}))["update:".concat(o)]=function(n){t[o]=n}))};for(var l in t)s(l)}else;return n}function Ne(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||We(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function He(n,e,t){return We(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function We(n,e,t){if(o(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&Be(n[r],"".concat(e,"_").concat(r),t);else Be(n,e,t)}function Be(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function $e(n,e){if(e)if(u(e)){var t=n.on=n.on?j({},n.on):{};for(var r in e){var o=t[r],a=e[r];t[r]=o?[].concat(o,a):a}}else;return n}function Ve(n,e,t,r){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var i=n[a];o(i)?Ve(i,e,t):i&&(i.proxy&&(i.fn.proxy=!0),e[i.key]=i.fn)}return r&&(e.$key=r),e}function Ke(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function Je(n,e){return"string"==typeof n?e+n:n}function Ge(n){n._o=He,n._n=y,n._s=g,n._l=Me,n._t=De,n._q=D,n._i=z,n._m=Ne,n._f=ze,n._k=Le,n._b=Ue,n._v=gn,n._e=fn,n._u=Ve,n._g=$e,n._d=Ke,n._p=Je}function Qe(n,e){if(!n||!n.length)return{};for(var t={},r=0,o=n.length;r<o;r++){var a=n[r],i=a.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,a.context!==e&&a.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(a);else{var s=i.slot,l=t[s]||(t[s]=[]);"template"===a.tag?l.push.apply(l,a.children||[]):l.push(a)}}for(var c in t)t[c].every(Xe)&&delete t[c];return t}function Xe(n){return n.isComment&&!n.asyncFactory||" "===n.text}function Ze(n){return n.isComment&&n.asyncFactory}function Ye(n,e,t,o){var a,i=Object.keys(t).length>0,s=e?!!e.$stable:!i,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&o&&o!==r&&l===o.$key&&!i&&!o.$hasNormal)return o;for(var c in a={},e)e[c]&&"$"!==c[0]&&(a[c]=nt(n,t,c,e[c]))}else a={};for(var p in t)p in a||(a[p]=et(t,p));return e&&Object.isExtensible(e)&&(e._normalized=a),$(a,"$stable",s),$(a,"$key",l),$(a,"$hasNormal",i),a}function nt(n,e,t,r){var a=function(){var e=dn;mn(n);var t=arguments.length?r.apply(null,arguments):r({}),a=(t=t&&"object"==typeof t&&!o(t)?[t]:Fe(t))&&t[0];return mn(e),t&&(!a||1===t.length&&a.isComment&&!Ze(a))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:a,enumerable:!0,configurable:!0}),a}function et(n,e){return function(){return n[e]}}function tt(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};$(e,"_v_attr_proxy",!0),rt(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||rt(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||at(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:_(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return ne(n,e,t)}))}}}function rt(n,e,t,r,o){var a=!1;for(var i in e)i in n?e[i]!==t[i]&&(a=!0):(a=!0,ot(n,i,r,o));for(var i in n)i in e||(a=!0,delete n[i]);return a}function ot(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function at(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}function it(){return ct().slots}function st(){return ct().attrs}function lt(){return ct().listeners}function ct(){var n=dn;return n._setupContext||(n._setupContext=tt(n))}function pt(n,e){var t=o(n)?n.reduce((function(n,e){return n[e]={},n}),{}):n;for(var r in e){var a=t[r];a?o(a)||c(a)?t[r]={type:a,default:e[r]}:a.default=e[r]:null===a&&(t[r]={default:e[r]})}return t}var dt=null;function ut(n,e){return(n.__esModule||pn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),p(n)?e.extend(n):n}function mt(n){if(o(n))for(var e=0;e<n.length;e++){var t=n[e];if(i(t)&&(i(t.componentOptions)||Ze(t)))return t}}function ht(n,e,t,r,d,u){return(o(t)||l(t))&&(d=r,r=t,t=void 0),s(u)&&(d=2),function(n,e,t,r,l){if(i(t)&&i(t.__ob__))return fn();i(t)&&i(t.is)&&(e=t.is);if(!e)return fn();0;o(r)&&c(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=Fe(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(o(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var d,u;if("string"==typeof e){var m=void 0;u=n.$vnode&&n.$vnode.ns||H.getTagNamespace(e),d=H.isReservedTag(e)?new hn(H.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!i(m=qr(n.$options,"components",e))?new hn(e,t,r,void 0,void 0,n):Pr(m,t,n,r,e)}else d=Pr(e,t,n,r);return o(d)?d:i(d)?(i(u)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(i(e.children))for(var o=0,l=e.children.length;o<l;o++){var c=e.children[o];i(c.tag)&&(a(c.ns)||s(r)&&"svg"!==c.tag)&&n(c,t,r)}}(d,u),i(t)&&function(n){p(n.style)&&Qt(n.style);p(n.class)&&Qt(n.class)}(t),d):fn()}(n,e,t,r,d)}function ft(n,e,t){return ht(dn,n,e,t,2,!0)}function gt(n,e,t){xn();try{if(e)for(var r=e;r=r.$parent;){var o=r.$options.errorCaptured;if(o)for(var a=0;a<o.length;a++)try{if(!1===o[a].call(r,n,e,t))return}catch(n){bt(n,r,"errorCaptured hook")}}bt(n,e,t)}finally{Tn()}}function yt(n,e,t,r,o){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&f(a)&&!a._handled&&(a.catch((function(n){return gt(n,r,o+" (Promise/async)")})),a._handled=!0)}catch(n){gt(n,r,o)}return a}function bt(n,e,t){if(H.errorHandler)try{return H.errorHandler.call(null,n,e,t)}catch(e){e!==n&&vt(e,null,"config.errorHandler")}vt(n,e,t)}function vt(n,e,t){if(!J||"undefined"==typeof console)throw n;console.error(n)}var kt,wt=!1,xt=[],Tt=!1;function Ct(){Tt=!1;var n=xt.slice(0);xt.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var Rt=Promise.resolve();kt=function(){Rt.then(Ct),Y&&setTimeout(F)},wt=!0}else if(Q||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())kt="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Ct)}:function(){setTimeout(Ct,0)};else{var Et=1,St=new MutationObserver(Ct),Pt=document.createTextNode(String(Et));St.observe(Pt,{characterData:!0}),kt=function(){Et=(Et+1)%2,Pt.data=String(Et)},wt=!0}function _t(n,e){var t;if(xt.push((function(){if(n)try{n.call(e)}catch(n){gt(n,e,"nextTick")}else t&&t(e)})),Tt||(Tt=!0,kt()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function It(n){if(void 0===n&&(n="$style"),!dn)return r;var e=dn[n];return e||r}function jt(n){if(J){var e=dn;e&&fe((function(){var t=e.$el,r=n(e,e._setupProxy);if(t&&1===t.nodeType){var o=t.style;for(var a in r)o.setProperty("--".concat(a),r[a])}}))}}function Ot(n){c(n)&&(n={loader:n});var e=n.loader,t=n.loadingComponent,r=n.errorComponent,o=n.delay,a=void 0===o?200:o,i=n.timeout,s=(n.suspensible,n.onError);var l=null,p=0,d=function(){var n;return l||(n=l=e().catch((function(n){if(n=n instanceof Error?n:new Error(String(n)),s)return new Promise((function(e,t){s(n,(function(){return e((p++,l=null,d()))}),(function(){return t(n)}),p+1)}));throw n})).then((function(e){return n!==l&&l?l:(e&&(e.__esModule||"Module"===e[Symbol.toStringTag])&&(e=e.default),e)})))};return function(){return{component:d(),delay:a,timeout:i,error:r,loading:t}}}function Ft(n){return function(e,t){if(void 0===t&&(t=dn),t)return function(n,e,t){var r=n.$options;r[e]=Ar(r[e],t)}(t,n,e)}}var At=Ft("beforeMount"),Mt=Ft("mounted"),Dt=Ft("beforeUpdate"),zt=Ft("updated"),qt=Ft("beforeDestroy"),Lt=Ft("destroyed"),Ut=Ft("activated"),Nt=Ft("deactivated"),Ht=Ft("serverPrefetch"),Wt=Ft("renderTracked"),Bt=Ft("renderTriggered"),$t=Ft("errorCaptured");function Vt(n,e){void 0===e&&(e=dn),$t(n,e)}var Kt="2.7.13";function Jt(n){return n}var Gt=new cn;function Qt(n){return function n(e,t){var r,a,i=o(e);if(!i&&!p(e)||e.__v_skip||Object.isFrozen(e)||e instanceof hn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(i)for(r=e.length;r--;)n(e[r],t);else if(Kn(e))n(e.value,t);else for(a=Object.keys(e),r=a.length;r--;)n(e[a[r]],t)}(n,Gt),Gt.clear(),n}var Xt,Zt=0,Yt=function(){function n(n,e,t,r,o){var a,i;a=this,void 0===(i=ye&&!ye._vm?ye:n?n._scope:void 0)&&(i=ye),i&&i.active&&i.effects.push(a),(this.vm=n)&&o&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Zt,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!V.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=F)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;xn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;gt(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Qt(n),Tn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():kr(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||p(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');yt(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&k(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function nr(n,e){Xt.$on(n,e)}function er(n,e){Xt.$off(n,e)}function tr(n,e){var t=Xt;return function r(){var o=e.apply(null,arguments);null!==o&&t.$off(n,r)}}function rr(n,e,t){Xt=n,Ie(e,t||{},nr,er,tr,n),Xt=void 0}var or=null;function ar(n){var e=or;return or=n,function(){or=e}}function ir(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function sr(n,e){if(e){if(n._directInactive=!1,ir(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)sr(n.$children[t]);lr(n,"activated")}}function lr(n,e,t,r){void 0===r&&(r=!0),xn();var o=dn;r&&mn(n);var a=n.$options[e],i="".concat(e," hook");if(a)for(var s=0,l=a.length;s<l;s++)yt(a[s],n,t||null,n,i);n._hasHookEvent&&n.$emit("hook:"+e),r&&mn(o),Tn()}var cr=[],pr=[],dr={},ur=!1,mr=!1,hr=0;var fr=0,gr=Date.now;if(J&&!Q){var yr=window.performance;yr&&"function"==typeof yr.now&&gr()>document.createEvent("Event").timeStamp&&(gr=function(){return yr.now()})}var br=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function vr(){var n,e;for(fr=gr(),mr=!0,cr.sort(br),hr=0;hr<cr.length;hr++)(n=cr[hr]).before&&n.before(),e=n.id,dr[e]=null,n.run();var t=pr.slice(),r=cr.slice();hr=cr.length=pr.length=0,dr={},ur=mr=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,sr(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&lr(r,"updated")}}(r),function(){for(var n=0;n<vn.length;n++){var e=vn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}vn.length=0}(),sn&&H.devtools&&sn.emit("flush")}function kr(n){var e=n.id;if(null==dr[e]&&(n!==kn.target||!n.noRecurse)){if(dr[e]=!0,mr){for(var t=cr.length-1;t>hr&&cr[t].id>n.id;)t--;cr.splice(t+1,0,n)}else cr.push(n);ur||(ur=!0,_t(vr))}}function wr(n,e){if(n){for(var t=Object.create(null),r=pn?Reflect.ownKeys(n):Object.keys(n),o=0;o<r.length;o++){var a=r[o];if("__ob__"!==a){var i=n[a].from;if(i in e._provided)t[a]=e._provided[i];else if("default"in n[a]){var s=n[a].default;t[a]=c(s)?s.call(e):s}else 0}}return t}}function xr(n,e,t,a,i){var l,c=this,p=i.options;x(a,"_uid")?(l=Object.create(a))._original=a:(l=a,a=a._original);var d=s(p._compiled),u=!d;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||r,this.injections=wr(p.inject,a),this.slots=function(){return c.$slots||Ye(a,n.scopedSlots,c.$slots=Qe(t,a)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return Ye(a,n.scopedSlots,this.slots())}}),d&&(this.$options=p,this.$slots=this.slots(),this.$scopedSlots=Ye(a,n.scopedSlots,this.$slots)),p._scopeId?this._c=function(n,e,t,r){var i=ht(l,n,e,t,r,u);return i&&!o(i)&&(i.fnScopeId=p._scopeId,i.fnContext=a),i}:this._c=function(n,e,t,r){return ht(l,n,e,t,r,u)}}function Tr(n,e,t,r,o){var a=yn(n);return a.fnContext=t,a.fnOptions=r,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function Cr(n,e){for(var t in e)n[R(t)]=e[t]}function Rr(n){return n.name||n.__name||n._componentTag}Ge(xr.prototype);var Er={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Er.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;i(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,or)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,o,a){var i=o.data.scopedSlots,s=n.$scopedSlots,l=!!(i&&!i.$stable||s!==r&&!s.$stable||i&&n.$scopedSlots.$key!==i.$key||!i&&n.$scopedSlots.$key),c=!!(a||n.$options._renderChildren||l),p=n.$vnode;n.$options._parentVnode=o,n.$vnode=o,n._vnode&&(n._vnode.parent=o),n.$options._renderChildren=a;var d=o.data.attrs||r;n._attrsProxy&&rt(n._attrsProxy,d,p.data&&p.data.attrs||r,n,"$attrs")&&(c=!0),n.$attrs=d,t=t||r;var u=n.$options._parentListeners;if(n._listenersProxy&&rt(n._listenersProxy,t,u||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,rr(n,t,u),e&&n.$options.props){Ln(!1);for(var m=n._props,h=n.$options._propKeys||[],f=0;f<h.length;f++){var g=h[f],y=n.$options.props;m[g]=Lr(g,y,e,n)}Ln(!0),n.$options.propsData=e}c&&(n.$slots=Qe(a,o.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,lr(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,pr.push(e)):sr(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,ir(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);lr(e,"deactivated")}}(e,!0):e.$destroy())}},Sr=Object.keys(Er);function Pr(n,e,t,l,c){if(!a(n)){var d=t.$options._base;if(p(n)&&(n=d.extend(n)),"function"==typeof n){var u;if(a(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&i(n.errorComp))return n.errorComp;if(i(n.resolved))return n.resolved;var t=dt;if(t&&i(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&i(n.loadingComp))return n.loadingComp;if(t&&!i(n.owners)){var r=n.owners=[t],o=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return k(r,t)}));var d=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},u=q((function(t){n.resolved=ut(t,e),o?r.length=0:d(!0)})),m=q((function(e){i(n.errorComp)&&(n.error=!0,d(!0))})),h=n(u,m);return p(h)&&(f(h)?a(n.resolved)&&h.then(u,m):f(h.component)&&(h.component.then(u,m),i(h.error)&&(n.errorComp=ut(h.error,e)),i(h.loading)&&(n.loadingComp=ut(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,d(!1))}),h.delay||200)),i(h.timeout)&&(c=setTimeout((function(){c=null,a(n.resolved)&&m(null)}),h.timeout)))),o=!1,n.loading?n.loadingComp:n.resolved}}(u=n,d)))return function(n,e,t,r,o){var a=fn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:r,tag:o},a}(u,e,t,l,c);e=e||{},Yr(n),i(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),s=a[r],l=e.model.callback;i(s)?(o(s)?-1===s.indexOf(l):s!==l)&&(a[r]=[l].concat(s)):a[r]=l}(n.options,e);var m=function(n,e,t){var r=e.options.props;if(!a(r)){var o={},s=n.attrs,l=n.props;if(i(s)||i(l))for(var c in r){var p=P(c);Oe(o,l,c,p,!0)||Oe(o,s,c,p,!1)}return o}}(e,n);if(s(n.options.functional))return function(n,e,t,a,s){var l=n.options,c={},p=l.props;if(i(p))for(var d in p)c[d]=Lr(d,p,e||r);else i(t.attrs)&&Cr(c,t.attrs),i(t.props)&&Cr(c,t.props);var u=new xr(t,c,s,a,n),m=l.render.call(null,u._c,u);if(m instanceof hn)return Tr(m,t,u.parent,l,u);if(o(m)){for(var h=Fe(m)||[],f=new Array(h.length),g=0;g<h.length;g++)f[g]=Tr(h[g],t,u.parent,l,u);return f}}(n,m,e,t,l);var h=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Sr.length;t++){var r=Sr[t],o=e[r],a=Er[r];o===a||o&&o._merged||(e[r]=o?_r(a,o):a)}}(e);var y=Rr(n.options)||c;return new hn("vue-component-".concat(n.cid).concat(y?"-".concat(y):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:c,children:l},u)}}}function _r(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var Ir=F,jr=H.optionMergeStrategies;function Or(n,e){if(!e)return n;for(var t,r,o,a=pn?Reflect.ownKeys(e):Object.keys(e),i=0;i<a.length;i++)"__ob__"!==(t=a[i])&&(r=n[t],o=e[t],x(n,t)?r!==o&&u(r)&&u(o)&&Or(r,o):Bn(n,t,o));return n}function Fr(n,e,t){return t?function(){var r=c(e)?e.call(t,t):e,o=c(n)?n.call(t,t):n;return r?Or(r,o):o}:e?n?function(){return Or(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function Ar(n,e){var t=e?n?n.concat(e):o(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Mr(n,e,t,r){var o=Object.create(n||null);return e?j(o,e):o}jr.data=function(n,e,t){return t?Fr(n,e,t):e&&"function"!=typeof e?n:Fr(n,e)},N.forEach((function(n){jr[n]=Ar})),U.forEach((function(n){jr[n+"s"]=Mr})),jr.watch=function(n,e,t,r){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var i in j(a,n),e){var s=a[i],l=e[i];s&&!o(s)&&(s=[s]),a[i]=s?s.concat(l):o(l)?l:[l]}return a},jr.props=jr.methods=jr.inject=jr.computed=function(n,e,t,r){if(!n)return e;var o=Object.create(null);return j(o,n),e&&j(o,e),o},jr.provide=Fr;var Dr=function(n,e){return void 0===e?n:e};function zr(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,a,i={};if(o(t))for(r=t.length;r--;)"string"==typeof(a=t[r])&&(i[R(a)]={type:null});else if(u(t))for(var s in t)a=t[s],i[R(s)]=u(a)?a:{type:a};else 0;n.props=i}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(o(t))for(var a=0;a<t.length;a++)r[t[a]]={from:t[a]};else if(u(t))for(var i in t){var s=t[i];r[i]=u(s)?j({from:i},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];c(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=zr(n,e.extends,t)),e.mixins))for(var r=0,a=e.mixins.length;r<a;r++)n=zr(n,e.mixins[r],t);var i,s={};for(i in n)l(i);for(i in e)x(n,i)||l(i);function l(r){var o=jr[r]||Dr;s[r]=o(n[r],e[r],t,r)}return s}function qr(n,e,t,r){if("string"==typeof t){var o=n[e];if(x(o,t))return o[t];var a=R(t);if(x(o,a))return o[a];var i=E(a);return x(o,i)?o[i]:o[t]||o[a]||o[i]}}function Lr(n,e,t,r){var o=e[n],a=!x(t,n),i=t[n],s=Wr(Boolean,o.type);if(s>-1)if(a&&!x(o,"default"))i=!1;else if(""===i||i===P(n)){var l=Wr(String,o.type);(l<0||s<l)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!x(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(r)&&"Function"!==Nr(e.type)?r.call(n):r}(r,o,n);var p=qn;Ln(!0),Hn(i),Ln(p)}return i}var Ur=/^\s*function (\w+)/;function Nr(n){var e=n&&n.toString().match(Ur);return e?e[1]:""}function Hr(n,e){return Nr(n)===Nr(e)}function Wr(n,e){if(!o(e))return Hr(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Hr(e[t],n))return t;return-1}var Br={enumerable:!0,configurable:!0,get:F,set:F};function $r(n,e,t){Br.get=function(){return this[e][t]},Br.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Br)}function Vr(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=Pn({}),o=n.$options._propKeys=[];n.$parent&&Ln(!1);var a=function(a){o.push(a);var i=Lr(a,e,t,n);Wn(r,a,i),a in n||$r(n,"_props",a)};for(var i in e)a(i);Ln(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=tt(n);mn(n),xn();var o=yt(t,null,[n._props||Pn({}),r],n,"setup");if(Tn(),mn(),c(o))e.render=o;else if(p(o))if(n._setupState=o,o.__sfc){var a=n._setupProxy={};for(var i in o)"__sfc"!==i&&ne(a,o,i)}else for(var i in o)B(i)||ne(n,o,i);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?F:_(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;u(e=n._data=c(e)?function(n,e){xn();try{return n.call(e,e)}catch(n){return gt(n,e,"data()"),{}}finally{Tn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,o=(n.$options.methods,t.length);for(;o--;){var a=t[o];0,r&&x(r,a)||B(a)||$r(n,"_data",a)}var i=Hn(e);i&&i.vmCount++}(n);else{var t=Hn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=an();for(var o in e){var a=e[o],i=c(a)?a:a.get;0,r||(t[o]=new Yt(n,i||F,F,Kr)),o in n||Jr(n,o,a)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var r=e[t];if(o(r))for(var a=0;a<r.length;a++)Xr(n,t,r[a]);else Xr(n,t,r)}}(n,e.watch)}var Kr={lazy:!0};function Jr(n,e,t){var r=!an();c(t)?(Br.get=r?Gr(e):Qr(t),Br.set=F):(Br.get=t.get?r&&!1!==t.cache?Gr(e):Qr(t.get):F,Br.set=t.set||F),Object.defineProperty(n,e,Br)}function Gr(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),kn.target&&e.depend(),e.value}}function Qr(n){return function(){return n.call(this,this)}}function Xr(n,e,t,r){return u(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Zr=0;function Yr(n){var e=n.options;if(n.super){var t=Yr(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var o in t)t[o]!==r[o]&&(e||(e={}),e[o]=t[o]);return e}(n);r&&j(n.extendOptions,r),(e=n.options=zr(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function no(n){this._init(n)}function eo(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,o=n._Ctor||(n._Ctor={});if(o[r])return o[r];var a=Rr(n)||Rr(t.options);var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=zr(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)$r(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)Jr(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,U.forEach((function(n){i[n]=t[n]})),a&&(i.options.components[a]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=j({},i.options),o[r]=i,i}}function to(n){return n&&(Rr(n.Ctor.options)||n.tag)}function ro(n,e){return o(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function oo(n,e){var t=n.cache,r=n.keys,o=n._vnode;for(var a in t){var i=t[a];if(i){var s=i.name;s&&!e(s)&&ao(t,a,r,o)}}}function ao(n,e,t,r){var o=n[e];!o||r&&o.tag===r.tag||o.componentInstance.$destroy(),n[e]=null,k(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Zr++,e._isVue=!0,e.__v_skip=!0,e._scope=new we(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var o=r.componentOptions;t.propsData=o.propsData,t._parentListeners=o.listeners,t._renderChildren=o.children,t._componentTag=o.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=zr(Yr(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&rr(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,o=t&&t.context;n.$slots=Qe(e._renderChildren,o),n.$scopedSlots=t?Ye(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,o){return ht(n,e,t,r,o,!1)},n.$createElement=function(e,t,r,o){return ht(n,e,t,r,o,!0)};var a=t&&t.data;Wn(n,"$attrs",a&&a.attrs||r,null,!0),Wn(n,"$listeners",e._parentListeners||r,null,!0)}(e),lr(e,"beforeCreate",void 0,!1),function(n){var e=wr(n.$options.inject,n);e&&(Ln(!1),Object.keys(e).forEach((function(t){Wn(n,t,e[t])})),Ln(!0))}(e),Vr(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!p(t))return;for(var r=Ee(n),o=pn?Reflect.ownKeys(t):Object.keys(t),a=0;a<o.length;a++){var i=o[a];Object.defineProperty(r,i,Object.getOwnPropertyDescriptor(t,i))}}}(e),lr(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(no),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Bn,n.prototype.$delete=$n,n.prototype.$watch=function(n,e,t){if(u(e))return Xr(this,n,e,t);(t=t||{}).user=!0;var r=new Yt(this,n,e,t);if(t.immediate){var o='callback for immediate watcher "'.concat(r.expression,'"');xn(),yt(e,this,[r.value],this,o),Tn()}return function(){r.teardown()}}}(no),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(o(n))for(var a=0,i=n.length;a<i;a++)r.$on(n[a],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(o(n)){for(var r=0,a=n.length;r<a;r++)t.$off(n[r],e);return t}var i,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((i=s[l])===e||i.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?I(t):t;for(var r=I(arguments,1),o='event handler for "'.concat(n,'"'),a=0,i=t.length;a<i;a++)yt(t[a],e,r,e,o)}return e}}(no),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,o=t._vnode,a=ar(t);t._vnode=n,t.$el=o?t.__patch__(o,n):t.__patch__(t.$el,n,e,!1),a(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var i=t;i&&i.$vnode&&i.$parent&&i.$vnode===i.$parent._vnode;)i.$parent.$el=i.$el,i=i.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){lr(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||k(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),lr(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(no),function(n){Ge(n.prototype),n.prototype.$nextTick=function(n){return _t(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,a=t._parentVnode;a&&e._isMounted&&(e.$scopedSlots=Ye(e.$parent,a.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&at(e._slotsProxy,e.$scopedSlots)),e.$vnode=a;try{mn(e),dt=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){gt(t,e,"render"),n=e._vnode}finally{dt=null,mn()}return o(n)&&1===n.length&&(n=n[0]),n instanceof hn||(n=fn()),n.parent=a,n}}(no);var io=[String,RegExp,Array],so={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:io,exclude:io,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var o=t.tag,a=t.componentInstance,i=t.componentOptions;n[r]={name:to(i),tag:o,componentInstance:a},e.push(r),this.max&&e.length>parseInt(this.max)&&ao(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)ao(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){oo(n,(function(n){return ro(e,n)}))})),this.$watch("exclude",(function(e){oo(n,(function(n){return!ro(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=mt(n),t=e&&e.componentOptions;if(t){var r=to(t),o=this.include,a=this.exclude;if(o&&(!r||!ro(o,r))||a&&r&&ro(a,r))return e;var i=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;i[l]?(e.componentInstance=i[l].componentInstance,k(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return H}};Object.defineProperty(n,"config",e),n.util={warn:Ir,extend:j,mergeOptions:zr,defineReactive:Wn},n.set=Bn,n.delete=$n,n.nextTick=_t,n.observable=function(n){return Hn(n),n},n.options=Object.create(null),U.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,j(n.options.components,so),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=I(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=zr(this.options,n),this}}(n),eo(n),function(n){U.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&u(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(no),Object.defineProperty(no.prototype,"$isServer",{get:an}),Object.defineProperty(no.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(no,"FunctionalRenderContext",{value:xr}),no.version=Kt;var lo=b("style,class"),co=b("input,textarea,option,select,progress"),po=b("contenteditable,draggable,spellcheck"),uo=b("events,caret,typing,plaintext-only"),mo=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ho="http://www.w3.org/1999/xlink",fo=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},go=function(n){return fo(n)?n.slice(6,n.length):""},yo=function(n){return null==n||!1===n};function bo(n){for(var e=n.data,t=n,r=n;i(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=vo(r.data,e));for(;i(t=t.parent);)t&&t.data&&(e=vo(e,t.data));return function(n,e){if(i(n)||i(e))return ko(n,wo(e));return""}(e.staticClass,e.class)}function vo(n,e){return{staticClass:ko(n.staticClass,e.staticClass),class:i(n.class)?[n.class,e.class]:e.class}}function ko(n,e){return n?e?n+" "+e:n:e||""}function wo(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,o=n.length;r<o;r++)i(e=wo(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):p(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var xo={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},To=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Co=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Ro=function(n){return To(n)||Co(n)};var Eo=Object.create(null);var So=b("text,number,password,search,email,tel,url");var Po=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(xo[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),_o={create:function(n,e){Io(e)},update:function(n,e){n.data.ref!==e.data.ref&&(Io(n,!0),Io(e))},destroy:function(n){Io(n,!0)}};function Io(n,e){var t=n.data.ref;if(i(t)){var r=n.context,a=n.componentInstance||n.elm,s=e?null:a,l=e?void 0:a;if(c(t))yt(t,r,[s],r,"template ref function");else{var p=n.data.refInFor,d="string"==typeof t||"number"==typeof t,u=Kn(t),m=r.$refs;if(d||u)if(p){var h=d?m[t]:t.value;e?o(h)&&k(h,a):o(h)?h.includes(a)||h.push(a):d?(m[t]=[a],jo(r,t,m[t])):t.value=[a]}else if(d){if(e&&m[t]!==a)return;m[t]=l,jo(r,t,s)}else if(u){if(e&&t.value!==a)return;t.value=s}else 0}}}function jo(n,e,t){var r=n._setupState;r&&x(r,e)&&(Kn(r[e])?r[e].value=t:r[e]=t)}var Oo=new hn("",{},[]),Fo=["create","activate","update","remove","destroy"];function Ao(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&i(n.data)===i(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=i(t=n.data)&&i(t=t.attrs)&&t.type,o=i(t=e.data)&&i(t=t.attrs)&&t.type;return r===o||So(r)&&So(o)}(n,e)||s(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function Mo(n,e,t){var r,o,a={};for(r=e;r<=t;++r)i(o=n[r].key)&&(a[o]=r);return a}var Do={create:zo,update:zo,destroy:function(n){zo(n,Oo)}};function zo(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,o,a=n===Oo,i=e===Oo,s=Lo(n.data.directives,n.context),l=Lo(e.data.directives,e.context),c=[],p=[];for(t in l)r=s[t],o=l[t],r?(o.oldValue=r.value,o.oldArg=r.arg,No(o,"update",e,n),o.def&&o.def.componentUpdated&&p.push(o)):(No(o,"bind",e,n),o.def&&o.def.inserted&&c.push(o));if(c.length){var d=function(){for(var t=0;t<c.length;t++)No(c[t],"inserted",e,n)};a?je(e,"insert",d):d()}p.length&&je(e,"postpatch",(function(){for(var t=0;t<p.length;t++)No(p[t],"componentUpdated",e,n)}));if(!a)for(t in s)l[t]||No(s[t],"unbind",n,n,i)}(n,e)}var qo=Object.create(null);function Lo(n,e){var t,r,o=Object.create(null);if(!n)return o;for(t=0;t<n.length;t++){if((r=n[t]).modifiers||(r.modifiers=qo),o[Uo(r)]=r,e._setupState&&e._setupState.__sfc){var a=r.def||qr(e,"_setupState","v-"+r.name);r.def="function"==typeof a?{bind:a,update:a}:a}r.def=r.def||qr(e.$options,"directives",r.name)}return o}function Uo(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function No(n,e,t,r,o){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,r,o)}catch(r){gt(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Ho=[_o,Do];function Wo(n,e){var t=e.componentOptions;if(!(i(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var r,o,l=e.elm,c=n.data.attrs||{},p=e.data.attrs||{};for(r in(i(p.__ob__)||s(p._v_attr_proxy))&&(p=e.data.attrs=j({},p)),p)o=p[r],c[r]!==o&&Bo(l,r,o,e.data.pre);for(r in(Q||Z)&&p.value!==c.value&&Bo(l,"value",p.value),c)a(p[r])&&(fo(r)?l.removeAttributeNS(ho,go(r)):po(r)||l.removeAttribute(r))}}function Bo(n,e,t,r){r||n.tagName.indexOf("-")>-1?$o(n,e,t):mo(e)?yo(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):po(e)?n.setAttribute(e,function(n,e){return yo(e)||"false"===e?"false":"contenteditable"===n&&uo(e)?e:"true"}(e,t)):fo(e)?yo(t)?n.removeAttributeNS(ho,go(e)):n.setAttributeNS(ho,e,t):$o(n,e,t)}function $o(n,e,t){if(yo(t))n.removeAttribute(e);else{if(Q&&!X&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Vo={create:Wo,update:Wo};function Ko(n,e){var t=e.elm,r=e.data,o=n.data;if(!(a(r.staticClass)&&a(r.class)&&(a(o)||a(o.staticClass)&&a(o.class)))){var s=bo(e),l=t._transitionClasses;i(l)&&(s=ko(s,wo(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Jo,Go={create:Ko,update:Ko};function Qo(n,e,t){var r=Jo;return function o(){var a=e.apply(null,arguments);null!==a&&Yo(n,o,t,r)}}var Xo=wt&&!(en&&Number(en[1])<=53);function Zo(n,e,t,r){if(Xo){var o=fr,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=o||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}Jo.addEventListener(n,e,rn?{capture:t,passive:r}:t)}function Yo(n,e,t,r){(r||Jo).removeEventListener(n,e._wrapper||e,t)}function na(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Jo=e.elm||n.elm,function(n){if(i(n.__r)){var e=Q?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}i(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Ie(t,r,Zo,Yo,Qo,e.context),Jo=void 0}}var ea,ta={create:na,update:na,destroy:function(n){return na(n,Oo)}};function ra(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,r,o=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(i(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=j({},c)),l)t in c||(o[t]="");for(t in c){if(r=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===t&&"PROGRESS"!==o.tagName){o._value=r;var p=a(r)?"":String(r);oa(o,p)&&(o.value=p)}else if("innerHTML"===t&&Co(o.tagName)&&a(o.innerHTML)){(ea=ea||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var d=ea.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;d.firstChild;)o.appendChild(d.firstChild)}else if(r!==l[t])try{o[t]=r}catch(n){}}}}function oa(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(i(r)){if(r.number)return y(t)!==y(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var aa={create:ra,update:ra},ia=T((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function sa(n){var e=la(n.style);return n.staticStyle?j(n.staticStyle,e):e}function la(n){return Array.isArray(n)?O(n):"string"==typeof n?ia(n):n}var ca,pa=/^--/,da=/\s*!important$/,ua=function(n,e,t){if(pa.test(e))n.style.setProperty(e,t);else if(da.test(t))n.style.setProperty(P(e),t.replace(da,""),"important");else{var r=ha(e);if(Array.isArray(t))for(var o=0,a=t.length;o<a;o++)n.style[r]=t[o];else n.style[r]=t}},ma=["Webkit","Moz","ms"],ha=T((function(n){if(ca=ca||document.createElement("div").style,"filter"!==(n=R(n))&&n in ca)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ma.length;t++){var r=ma[t]+e;if(r in ca)return r}}));function fa(n,e){var t=e.data,r=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(r.staticStyle)&&a(r.style))){var o,s,l=e.elm,c=r.staticStyle,p=r.normalizedStyle||r.style||{},d=c||p,u=la(e.data.style)||{};e.data.normalizedStyle=i(u.__ob__)?j({},u):u;var m=function(n,e){var t,r={};if(e)for(var o=n;o.componentInstance;)(o=o.componentInstance._vnode)&&o.data&&(t=sa(o.data))&&j(r,t);(t=sa(n.data))&&j(r,t);for(var a=n;a=a.parent;)a.data&&(t=sa(a.data))&&j(r,t);return r}(e,!0);for(s in d)a(m[s])&&ua(l,s,"");for(s in m)(o=m[s])!==d[s]&&ua(l,s,null==o?"":o)}}var ga={create:fa,update:fa},ya=/\s+/;function ba(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ya).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function va(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ya).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ka(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&j(e,wa(n.name||"v")),j(e,n),e}return"string"==typeof n?wa(n):void 0}}var wa=T((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),xa=J&&!X,Ta="transition",Ca="transitionend",Ra="animation",Ea="animationend";xa&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Ta="WebkitTransition",Ca="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Ra="WebkitAnimation",Ea="webkitAnimationEnd"));var Sa=J?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Pa(n){Sa((function(){Sa(n)}))}function _a(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),ba(n,e))}function Ia(n,e){n._transitionClasses&&k(n._transitionClasses,e),va(n,e)}function ja(n,e,t){var r=Fa(n,e),o=r.type,a=r.timeout,i=r.propCount;if(!o)return t();var s="transition"===o?Ca:Ea,l=0,c=function(){n.removeEventListener(s,p),t()},p=function(e){e.target===n&&++l>=i&&c()};setTimeout((function(){l<i&&c()}),a+1),n.addEventListener(s,p)}var Oa=/\b(transform|all)(,|$)/;function Fa(n,e){var t,r=window.getComputedStyle(n),o=(r[Ta+"Delay"]||"").split(", "),a=(r[Ta+"Duration"]||"").split(", "),i=Aa(o,a),s=(r[Ra+"Delay"]||"").split(", "),l=(r[Ra+"Duration"]||"").split(", "),c=Aa(s,l),p=0,d=0;return"transition"===e?i>0&&(t="transition",p=i,d=a.length):"animation"===e?c>0&&(t="animation",p=c,d=l.length):d=(t=(p=Math.max(i,c))>0?i>c?"transition":"animation":null)?"transition"===t?a.length:l.length:0,{type:t,timeout:p,propCount:d,hasTransform:"transition"===t&&Oa.test(r[Ta+"Property"])}}function Aa(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Ma(e)+Ma(n[t])})))}function Ma(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Da(n,e){var t=n.elm;i(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=ka(n.data.transition);if(!a(r)&&!i(t._enterCb)&&1===t.nodeType){for(var o=r.css,s=r.type,l=r.enterClass,d=r.enterToClass,u=r.enterActiveClass,m=r.appearClass,h=r.appearToClass,f=r.appearActiveClass,g=r.beforeEnter,b=r.enter,v=r.afterEnter,k=r.enterCancelled,w=r.beforeAppear,x=r.appear,T=r.afterAppear,C=r.appearCancelled,R=r.duration,E=or,S=or.$vnode;S&&S.parent;)E=S.context,S=S.parent;var P=!E._isMounted||!n.isRootInsert;if(!P||x||""===x){var _=P&&m?m:l,I=P&&f?f:u,j=P&&h?h:d,O=P&&w||g,F=P&&c(x)?x:b,A=P&&T||v,M=P&&C||k,D=y(p(R)?R.enter:R);0;var z=!1!==o&&!X,L=La(F),U=t._enterCb=q((function(){z&&(Ia(t,j),Ia(t,I)),U.cancelled?(z&&Ia(t,_),M&&M(t)):A&&A(t),t._enterCb=null}));n.data.show||je(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),F&&F(t,U)})),O&&O(t),z&&(_a(t,_),_a(t,I),Pa((function(){Ia(t,_),U.cancelled||(_a(t,j),L||(qa(D)?setTimeout(U,D):ja(t,s,U)))}))),n.data.show&&(e&&e(),F&&F(t,U)),z||L||U()}}}function za(n,e){var t=n.elm;i(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=ka(n.data.transition);if(a(r)||1!==t.nodeType)return e();if(!i(t._leaveCb)){var o=r.css,s=r.type,l=r.leaveClass,c=r.leaveToClass,d=r.leaveActiveClass,u=r.beforeLeave,m=r.leave,h=r.afterLeave,f=r.leaveCancelled,g=r.delayLeave,b=r.duration,v=!1!==o&&!X,k=La(m),w=y(p(b)?b.leave:b);0;var x=t._leaveCb=q((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),v&&(Ia(t,c),Ia(t,d)),x.cancelled?(v&&Ia(t,l),f&&f(t)):(e(),h&&h(t)),t._leaveCb=null}));g?g(T):T()}function T(){x.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),u&&u(t),v&&(_a(t,l),_a(t,d),Pa((function(){Ia(t,l),x.cancelled||(_a(t,c),k||(qa(w)?setTimeout(x,w):ja(t,s,x)))}))),m&&m(t,x),v||k||x())}}function qa(n){return"number"==typeof n&&!isNaN(n)}function La(n){if(a(n))return!1;var e=n.fns;return i(e)?La(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Ua(n,e){!0!==e.data.show&&Da(e)}var Na=function(n){var e,t,r={},c=n.modules,p=n.nodeOps;for(e=0;e<Fo.length;++e)for(r[Fo[e]]=[],t=0;t<c.length;++t)i(c[t][Fo[e]])&&r[Fo[e]].push(c[t][Fo[e]]);function d(n){var e=p.parentNode(n);i(e)&&p.removeChild(e,n)}function u(n,e,t,o,a,l,c){if(i(n.elm)&&i(l)&&(n=l[c]=yn(n)),n.isRootInsert=!a,!function(n,e,t,o){var a=n.data;if(i(a)){var l=i(n.componentInstance)&&a.keepAlive;if(i(a=a.hook)&&i(a=a.init)&&a(n,!1),i(n.componentInstance))return m(n,e),h(t,n.elm,o),s(l)&&function(n,e,t,o){var a,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,i(a=s.data)&&i(a=a.transition)){for(a=0;a<r.activate.length;++a)r.activate[a](Oo,s);e.push(s);break}h(t,n.elm,o)}(n,e,t,o),!0}}(n,e,t,o)){var d=n.data,u=n.children,g=n.tag;i(g)?(n.elm=n.ns?p.createElementNS(n.ns,g):p.createElement(g,n),v(n),f(n,u,e),i(d)&&y(n,e),h(t,n.elm,o)):s(n.isComment)?(n.elm=p.createComment(n.text),h(t,n.elm,o)):(n.elm=p.createTextNode(n.text),h(t,n.elm,o))}}function m(n,e){i(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(y(n,e),v(n)):(Io(n),e.push(n))}function h(n,e,t){i(n)&&(i(t)?p.parentNode(t)===n&&p.insertBefore(n,e,t):p.appendChild(n,e))}function f(n,e,t){if(o(e)){0;for(var r=0;r<e.length;++r)u(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&p.appendChild(n.elm,p.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return i(n.tag)}function y(n,t){for(var o=0;o<r.create.length;++o)r.create[o](Oo,n);i(e=n.data.hook)&&(i(e.create)&&e.create(Oo,n),i(e.insert)&&t.push(n))}function v(n){var e;if(i(e=n.fnScopeId))p.setStyleScope(n.elm,e);else for(var t=n;t;)i(e=t.context)&&i(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e),t=t.parent;i(e=or)&&e!==n.context&&e!==n.fnContext&&i(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e)}function k(n,e,t,r,o,a){for(;r<=o;++r)u(t[r],a,n,e,!1,t,r)}function w(n){var e,t,o=n.data;if(i(o))for(i(e=o.hook)&&i(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(i(e=n.children))for(t=0;t<n.children.length;++t)w(n.children[t])}function x(n,e,t){for(;e<=t;++e){var r=n[e];i(r)&&(i(r.tag)?(T(r),w(r)):d(r.elm))}}function T(n,e){if(i(e)||i(n.data)){var t,o=r.remove.length+1;for(i(e)?e.listeners+=o:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,o),i(t=n.componentInstance)&&i(t=t._vnode)&&i(t.data)&&T(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);i(t=n.data.hook)&&i(t=t.remove)?t(n,e):e()}else d(n.elm)}function C(n,e,t,r){for(var o=t;o<r;o++){var a=e[o];if(i(a)&&Ao(n,a))return o}}function R(n,e,t,o,l,c){if(n!==e){i(e.elm)&&i(o)&&(e=o[l]=yn(e));var d=e.elm=n.elm;if(s(n.isAsyncPlaceholder))i(e.asyncFactory.resolved)?P(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;i(h)&&i(m=h.hook)&&i(m=m.prepatch)&&m(n,e);var f=n.children,y=e.children;if(i(h)&&g(e)){for(m=0;m<r.update.length;++m)r.update[m](n,e);i(m=h.hook)&&i(m=m.update)&&m(n,e)}a(e.text)?i(f)&&i(y)?f!==y&&function(n,e,t,r,o){var s,l,c,d=0,m=0,h=e.length-1,f=e[0],g=e[h],y=t.length-1,b=t[0],v=t[y],w=!o;for(0;d<=h&&m<=y;)a(f)?f=e[++d]:a(g)?g=e[--h]:Ao(f,b)?(R(f,b,r,t,m),f=e[++d],b=t[++m]):Ao(g,v)?(R(g,v,r,t,y),g=e[--h],v=t[--y]):Ao(f,v)?(R(f,v,r,t,y),w&&p.insertBefore(n,f.elm,p.nextSibling(g.elm)),f=e[++d],v=t[--y]):Ao(g,b)?(R(g,b,r,t,m),w&&p.insertBefore(n,g.elm,f.elm),g=e[--h],b=t[++m]):(a(s)&&(s=Mo(e,d,h)),a(l=i(b.key)?s[b.key]:C(b,e,d,h))?u(b,r,n,f.elm,!1,t,m):Ao(c=e[l],b)?(R(c,b,r,t,m),e[l]=void 0,w&&p.insertBefore(n,c.elm,f.elm)):u(b,r,n,f.elm,!1,t,m),b=t[++m]);d>h?k(n,a(t[y+1])?null:t[y+1].elm,t,m,y,r):m>y&&x(e,d,h)}(d,f,y,t,c):i(y)?(i(n.text)&&p.setTextContent(d,""),k(d,null,y,0,y.length-1,t)):i(f)?x(f,0,f.length-1):i(n.text)&&p.setTextContent(d,""):n.text!==e.text&&p.setTextContent(d,e.text),i(h)&&i(m=h.hook)&&i(m=m.postpatch)&&m(n,e)}}}function E(n,e,t){if(s(t)&&i(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var S=b("attrs,class,staticClass,staticStyle,key");function P(n,e,t,r){var o,a=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&i(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(i(l)&&(i(o=l.hook)&&i(o=o.init)&&o(e,!0),i(o=e.componentInstance)))return m(e,t),!0;if(i(a)){if(i(c))if(n.hasChildNodes())if(i(o=l)&&i(o=o.domProps)&&i(o=o.innerHTML)){if(o!==n.innerHTML)return!1}else{for(var p=!0,d=n.firstChild,u=0;u<c.length;u++){if(!d||!P(d,c[u],t,r)){p=!1;break}d=d.nextSibling}if(!p||d)return!1}else f(e,c,t);if(i(l)){var h=!1;for(var g in l)if(!S(g)){h=!0,y(e,t);break}!h&&l.class&&Qt(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,o){if(!a(e)){var l,c=!1,d=[];if(a(n))c=!0,u(e,d);else{var m=i(n.nodeType);if(!m&&Ao(n,e))R(n,e,d,null,null,o);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&P(n,e,d))return E(e,d,!0),n;l=n,n=new hn(p.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,f=p.parentNode(h);if(u(e,d,h._leaveCb?null:f,p.nextSibling(h)),i(e.parent))for(var y=e.parent,b=g(e);y;){for(var v=0;v<r.destroy.length;++v)r.destroy[v](y);if(y.elm=e.elm,b){for(var k=0;k<r.create.length;++k)r.create[k](Oo,y);var T=y.data.hook.insert;if(T.merged)for(var C=1;C<T.fns.length;C++)T.fns[C]()}else Io(y);y=y.parent}i(f)?x([n],0,0):i(n.tag)&&w(n)}}return E(e,d,c),e.elm}i(n)&&w(n)}}({nodeOps:Po,modules:[Vo,Go,ta,aa,ga,J?{create:Ua,activate:Ua,remove:function(n,e){!0!==n.data.show?za(n,e):e()}}:{}].concat(Ho)});X&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Ga(n,"input")}));var Ha={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?je(t,"postpatch",(function(){Ha.componentUpdated(n,e,t)})):Wa(n,e,t.context),n._vOptions=[].map.call(n.options,Va)):("textarea"===t.tag||So(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Ka),n.addEventListener("compositionend",Ja),n.addEventListener("change",Ja),X&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Wa(n,e,t.context);var r=n._vOptions,o=n._vOptions=[].map.call(n.options,Va);if(o.some((function(n,e){return!D(n,r[e])})))(n.multiple?e.value.some((function(n){return $a(n,o)})):e.value!==e.oldValue&&$a(e.value,o))&&Ga(n,"change")}}};function Wa(n,e,t){Ba(n,e,t),(Q||Z)&&setTimeout((function(){Ba(n,e,t)}),0)}function Ba(n,e,t){var r=e.value,o=n.multiple;if(!o||Array.isArray(r)){for(var a,i,s=0,l=n.options.length;s<l;s++)if(i=n.options[s],o)a=z(r,Va(i))>-1,i.selected!==a&&(i.selected=a);else if(D(Va(i),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));o||(n.selectedIndex=-1)}}function $a(n,e){return e.every((function(e){return!D(e,n)}))}function Va(n){return"_value"in n?n._value:n.value}function Ka(n){n.target.composing=!0}function Ja(n){n.target.composing&&(n.target.composing=!1,Ga(n.target,"input"))}function Ga(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Qa(n){return!n.componentInstance||n.data&&n.data.transition?n:Qa(n.componentInstance._vnode)}var Xa={model:Ha,show:{bind:function(n,e,t){var r=e.value,o=(t=Qa(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&o?(t.data.show=!0,Da(t,(function(){n.style.display=a}))):n.style.display=r?a:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=Qa(t)).data&&t.data.transition?(t.data.show=!0,r?Da(t,(function(){n.style.display=n.__vOriginalDisplay})):za(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,o){o||(n.style.display=n.__vOriginalDisplay)}}},Za={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ya(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Ya(mt(e.children)):n}function ni(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var o=t._parentListeners;for(var r in o)e[R(r)]=o[r];return e}function ei(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var ti=function(n){return n.tag||Ze(n)},ri=function(n){return"show"===n.name},oi={name:"transition",props:Za,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(ti)).length){0;var r=this.mode;0;var o=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return o;var a=Ya(o);if(!a)return o;if(this._leaving)return ei(n,o);var i="__transition-".concat(this._uid,"-");a.key=null==a.key?a.isComment?i+"comment":i+a.tag:l(a.key)?0===String(a.key).indexOf(i)?a.key:i+a.key:a.key;var s=(a.data||(a.data={})).transition=ni(this),c=this._vnode,p=Ya(c);if(a.data.directives&&a.data.directives.some(ri)&&(a.data.show=!0),p&&p.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,p)&&!Ze(p)&&(!p.componentInstance||!p.componentInstance._vnode.isComment)){var d=p.data.transition=j({},s);if("out-in"===r)return this._leaving=!0,je(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),ei(n,o);if("in-out"===r){if(Ze(a))return c;var u,m=function(){u()};je(s,"afterEnter",m),je(s,"enterCancelled",m),je(d,"delayLeave",(function(n){u=n}))}}return o}}},ai=j({tag:String,moveClass:String},Za);function ii(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function si(n){n.data.newPos=n.elm.getBoundingClientRect()}function li(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,o=e.top-t.top;if(r||o){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate(".concat(r,"px,").concat(o,"px)"),a.transitionDuration="0s"}}delete ai.mode;var ci={Transition:oi,TransitionGroup:{props:ai,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var o=ar(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,o(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,o=this.$slots.default||[],a=this.children=[],i=ni(this),s=0;s<o.length;s++){if((p=o[s]).tag)if(null!=p.key&&0!==String(p.key).indexOf("__vlist"))a.push(p),t[p.key]=p,(p.data||(p.data={})).transition=i;else;}if(r){var l=[],c=[];for(s=0;s<r.length;s++){var p;(p=r[s]).data.transition=i,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?l.push(p):c.push(p)}this.kept=n(e,null,l),this.removed=c}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(ii),n.forEach(si),n.forEach(li),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;_a(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(Ca,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(Ca,n),t._moveCb=null,Ia(t,e))})}})))},methods:{hasMove:function(n,e){if(!xa)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){va(t,n)})),ba(t,e),t.style.display="none",this.$el.appendChild(t);var r=Fa(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};no.config.mustUseProp=function(n,e,t){return"value"===t&&co(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},no.config.isReservedTag=Ro,no.config.isReservedAttr=lo,no.config.getTagNamespace=function(n){return Co(n)?"svg":"math"===n?"math":void 0},no.config.isUnknownElement=function(n){if(!J)return!0;if(Ro(n))return!1;if(n=n.toLowerCase(),null!=Eo[n])return Eo[n];var e=document.createElement(n);return n.indexOf("-")>-1?Eo[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Eo[n]=/HTMLUnknownElement/.test(e.toString())},j(no.options.directives,Xa),j(no.options.components,ci),no.prototype.__patch__=J?Na:F,no.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=fn),lr(n,"beforeMount"),r=function(){n._update(n._render(),t)},new Yt(n,r,F,{before:function(){n._isMounted&&!n._isDestroyed&&lr(n,"beforeUpdate")}},!0),t=!1;var o=n._preWatchers;if(o)for(var a=0;a<o.length;a++)o[a].run();return null==n.$vnode&&(n._isMounted=!0,lr(n,"mounted")),n}(this,n=n&&J?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},J&&setTimeout((function(){H.devtools&&sn&&sn.emit("init",no)}),0)}.call(this,t(21))},function(n,e,t){"use strict";function r(n,e,t,r,o,a,i,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),a&&(c._scopeId="data-v-"+a),i?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),o&&o.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},c._ssrRegister=l):o&&(l=s?function(){o.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:o),l)if(c.functional){c._injectStyles=l;var p=c.render;c.render=function(n,e){return l.call(e),p(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(63),o=r.all;n.exports=r.IS_HTMLDDA?function(n){return"function"==typeof n||n===o}:function(n){return"function"==typeof n}},function(n,e,t){(function(e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof e&&e)||function(){return this}()||Function("return this")()}).call(this,t(21))},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var r=t(5);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(18),o=t(59);n.exports=function(n){if("Function"===r(n))return o(n)}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(7),o=t(36),a=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(o(n),e)}},function(n,e,t){var r=t(77),o="object"==typeof self&&self&&self.Object===Object&&self,a=r||o||Function("return this")();n.exports=a},function(n,e,t){var r=t(3),o=t(63),a=o.all;n.exports=o.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:r(n)||n===a}:function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(175),o=t(178);n.exports=function(n,e){var t=o(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return a})),t.d(e,"j",(function(){return i})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return p})),t.d(e,"c",(function(){return d})),t.d(e,"f",(function(){return u})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return y})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return k}));t(20);const r=/#.*$/,o=/\.(md|html)$/,a=/\/$/,i=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(o,"")}function l(n){return i.test(n)}function c(n){return/^mailto:/.test(n)}function p(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;if(!n)return"404";const e=n.match(r),t=e?e[0]:"",o=s(n);return a.test(o)?n:o+".html"+t}function u(n,e){const t=n.hash,o=function(n){const e=n&&n.match(r);if(e)return e[0]}(e);if(o&&t!==o)return!1;return s(n.path)===s(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;const o=e.split("/");t&&o[o.length-1]||o.pop();const a=n.replace(/^\//,"").split("/");for(let n=0;n<a.length;n++){const e=a[n];".."===e?o.pop():"."!==e&&o.push(e)}""!==o[0]&&o.unshift("");return o.join("/")}(e,t));const r=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===r)return Object.assign({},n[e],{type:"page",path:d(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,r){const{pages:o,themeConfig:a}=t,i=r&&a.locales&&a.locales[r]||a;if("auto"===(n.frontmatter.sidebar||i.sidebar||a.sidebar))return f(n);const s=i.sidebar||a.sidebar;if(s){const{base:t,config:r}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const r in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:e[r]};var t;return{}}(e,s);return"auto"===r?f(n):r?r.map(n=>function n(e,t,r,o=1){if("string"==typeof e)return m(t,e,r);if(Array.isArray(e))return Object.assign(m(t,e[0],r),{title:e[1]});{o>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const a=e.children||[];return 0===a.length&&e.path?Object.assign(m(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:a.map(e=>n(e,t,r,o+1)),collapsable:!1!==e.collapsable}}}(n,o,t)):[]}return[]}function f(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function y(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function v(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function k(n,e){return v(e)-v(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";var r=t(1);e.a=new r.default},function(n,e,t){var r=t(6),o=t(72),a=t(111),i=t(33),s=t(62),l=TypeError,c=Object.defineProperty,p=Object.getOwnPropertyDescriptor;e.f=r?a?function(n,e,t){if(i(n),e=s(e),i(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=p(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(i(n),e=s(e),i(t),o)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(19),o=t(160),a=t(161),i=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?o(n):a(n)}},function(n,e,t){var r=t(59),o=r({}.toString),a=r("".slice);n.exports=function(n){return a(o(n),8,-1)}},function(n,e,t){var r=t(10).Symbol;n.exports=r},function(n,e,t){"use strict";var r=t(22),o=t(36),a=t(37),i=t(141),s=t(143),l=t(5)((function(){return 4294967297!==[].push.call({length:4294967296},1)})),c=!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}();r({target:"Array",proto:!0,arity:1,forced:l||c},{push:function(n){var e=o(this),t=a(e),r=arguments.length;s(t+r);for(var l=0;l<r;l++)e[t]=arguments[l],t++;return i(e,t),t}})},function(n,e){var t;t=function(){return this}();try{t=t||new Function("return this")()}catch(n){"object"==typeof window&&(t=window)}n.exports=t},function(n,e,t){var r=t(4),o=t(58).f,a=t(25),i=t(124),s=t(41),l=t(73),c=t(137);n.exports=function(n,e){var t,p,d,u,m,h=n.target,f=n.global,g=n.stat;if(t=f?r:g?r[h]||s(h,{}):(r[h]||{}).prototype)for(p in e){if(u=e[p],d=n.dontCallGetSet?(m=o(t,p))&&m.value:t[p],!c(f?p:h+(g?".":"#")+p,n.forced)&&void 0!==d){if(typeof u==typeof d)continue;l(u,d)}(n.sham||d&&d.sham)&&a(u,"sham",!0),i(t,p,u,n)}}},function(n,e,t){var r=t(4),o=t(3),a=function(n){return o(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(r[n]):r[n]&&r[n][e]}},function(n,e,t){var r=t(4),o=t(69),a=t(9),i=t(71),s=t(67),l=t(66),c=o("wks"),p=r.Symbol,d=p&&p.for,u=l?p:p&&p.withoutSetter||i;n.exports=function(n){if(!a(c,n)||!s&&"string"!=typeof c[n]){var e="Symbol."+n;s&&a(p,n)?c[n]=p[n]:c[n]=l&&d?d(e):u(e)}return c[n]}},function(n,e,t){var r=t(6),o=t(16),a=t(39);n.exports=r?function(n,e,t){return o.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(165),o=t(166),a=t(167),i=t(168),s=t(169);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(79);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(12)(Object,"create");n.exports=r},function(n,e,t){var r=t(187);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(49);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,o;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(o="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function o(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=o(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),p=r.speed,d=r.easing;return l.offsetWidth,i((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var o;return(o="translate3d"===r.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,o}(n,p,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+p+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),p)}),p)):setTimeout(e,p)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*o(Math.random()*e,.1,.95)),e=o(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var o,i=e.querySelector(r.barSelector),l=n?"-100":a(t.status||0),p=document.querySelector(r.parent);return s(i,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(o=e.querySelector(r.spinnerSelector))&&u(o),p!=document.body&&c(p,"nprogress-custom-parent"),p.appendChild(e),e},t.remove=function(){p(document.documentElement,"nprogress-busy"),p(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&u(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,o=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);o--;)if((r=n[o]+a)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,o,a=arguments;if(2==a.length)for(t in e)void 0!==(o=e[t])&&e.hasOwnProperty(t)&&r(n,t,o);else r(n,a[1],a[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function p(n,e){var t,r=d(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function u(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=o)},function(n){n.exports=JSON.parse('{"name":"vuepress-plugin-comment","version":"0.7.3","description":"Comment plugin in vuepress, such as Gitalk, Valine...","main":"index.js","scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"author":"dongyuanxin","license":"MIT","bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"}}')},function(n,e,t){var r=t(11),o=String,a=TypeError;n.exports=function(n){if(r(n))return n;throw a(o(n)+" is not an object")}},function(n,e,t){var r=t(5);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var r=t(53),o=t(60);n.exports=function(n){return r(o(n))}},function(n,e,t){var r=t(60),o=Object;n.exports=function(n){return o(r(n))}},function(n,e,t){var r=t(135);n.exports=function(n){return r(n.length)}},function(n,e,t){var r=t(34),o=Function.prototype.call;n.exports=r?o.bind(o):function(){return o.apply(o,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(4),o=t(41),a=r["__core-js_shared__"]||o("__core-js_shared__",{});n.exports=a},function(n,e,t){var r=t(4),o=Object.defineProperty;n.exports=function(n,e){try{o(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(159),o=t(14),a=Object.prototype,i=a.hasOwnProperty,s=a.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return o(n)&&i.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(12)(t(10),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(179),o=t(186),a=t(188),i=t(189),s=t(190);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(8),o=t(49),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!o(n))||(i.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(17),o=t(14);n.exports=function(n){return"symbol"==typeof n||o(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";t.r(e);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}class o{constructor(){r(this,"TABEL","fZodR9XQDSUm21yCkr6zBqiveYah8bt4xsWpHnJE7jL5VG3guMTKNPAwcF"),r(this,"TR",{}),r(this,"S",[11,10,3,8,4,6]),r(this,"XOR",177451812),r(this,"ADD",8728348608),this.init()}init(){const n=this.TABEL.length;for(let e=0;e<n;e++)this.TR[this.TABEL[e]]=e}av2bv(n){const e=(n^this.XOR)+this.ADD,t=["B","V","1",,,"4",,"1",,"7"];for(let n=0;n<6;n++)t[this.S[n]]=this.TABEL[Math.floor(e/58**n)%58];return t.join("")}bv2av(n){let e=0;for(let t=0;t<6;t++)e+=this.TR[n[this.S[t]]]*58**t;return"av"+String(e-this.ADD^this.XOR)}}var a={name:"Bilibili",data(){return{afs:!![!0,"true","allowfullscreen"].includes(this.allowfullscreen)}},props:{id:{type:String,required:!0},danmaku:{type:Boolean,default:!1,required:!1},page:{type:Number,default:1,required:!1},sandbox:{type:String,default:"allow-top-navigation allow-same-origin allow-forms allow-scripts allow-popups",required:!1},allowfullscreen:{type:[String,Boolean],required:!1,default:"allowfullscreen"},width:{type:String,required:!1,default:"100%"},height:{type:Array,required:!1,default:()=>[9/16,70]}},computed:{bvid(){if(!this.id||this.id.toLowerCase().startsWith("bv"))return this.id;const n=this.id.toLowerCase().startsWith("av")?this.id.slice(2):this.id;return o.av2bv(n)},avid(){return o.bv2av(this.bvid)},src(){return`//player.bilibili.com/player.html?bvid=${this.bvid}&page=${this.page}&danmaku=${this.danmaku}`}},mounted(){this.$nextTick(()=>{let n=this.$refs.sbplayer;n&&(n.style.height=n.scrollWidth*this.height[0]+this.height[1]+"px")})}},i=(t(254),t(2)),s=Object(i.a)(a,(function(){var n=this._self._c;return n("div",{staticClass:"biliPlayer"},[n("iframe",{ref:"sbplayer",staticClass:"player",style:{width:this.width},attrs:{src:this.src,allowfullscreen:this.afs,scrolling:"no",frameborder:"0",sandbox:this.sandbox}})])}),[],!1,null,"f246d424",null);e.default=s.exports},function(n,e,t){"use strict";t.r(e);var r={name:"LastReadingPopup",data:()=>({lastReading:null,show:!1}),computed:{popupConfig(){const n={"/":{message:"",sureButtonText:"",cancelButtonText:""},"/zh/":{message:"",sureButtonText:"",cancelButtonText:""}};return n[`/${this.$lang.split("-")[0]}/`]||n[this.$localePath]||n},message(){const n=this.popupConfig;return n&&n.message||n["/"].message},sureButtonText(){const n=this.popupConfig;return n&&n.sureButtonText||n["/"].sureButtonText},cancelButtonText(){const n=this.popupConfig;return n&&n.cancelButtonText||n["/"].cancelButtonText}},mounted(){window.ActiveXObject||"ActiveXObject"in window?setTimeout(()=>{window.addEventListener("load",this.init())},1e3):setTimeout(()=>{window.addEventListener("load",this.init)},1e3)},methods:{init(){this.lastReading=JSON.parse(localStorage.getItem("lastReading")),this.lastReading&&(this.$route.path===this.lastReading.path?this.goto():(this.show=!0,setTimeout(this.clean,1e4)))},goto(){this.$route.path!==this.lastReading.path?this.$router.replace(this.lastReading.path).then(()=>{document.documentElement.scrollTop=this.lastReading.scrollTop,this.clean()}):this.$nextTick(()=>{document.documentElement.scrollTop=this.lastReading.scrollTop})},dontgoto(){this.clean()},clean(){this.show=!1,localStorage.removeItem("lastReading")}}},o=(t(253),t(2)),a=Object(o.a)(r,(function(){var n=this,e=n._self._c;return e("transition",{attrs:{name:"sw-update-popup"}},[n.show?e("div",{staticClass:"sw-update-popup"},[n._v("\n    "+n._s(n.message)+"\n\n    "),e("br"),n._v(" "),e("button",{on:{click:n.goto}},[n._v("\n      "+n._s(n.sureButtonText)+"\n    ")]),n._v(" "),e("button",{on:{click:n.dontgoto}},[n._v("\n      "+n._s(n.cancelButtonText)+"\n    ")])]):n._e()])}),[],!1,null,"181714f2",null);e.default=a.exports},function(n,e,t){var r=t(7),o=t(5),a=t(18),i=Object,s=r("".split);n.exports=o((function(){return!i("z").propertyIsEnumerable(0)}))?function(n){return"String"==a(n)?s(n,""):i(n)}:i},function(n,e,t){var r=t(3),o=t(122),a=TypeError;n.exports=function(n){if(r(n))return n;throw a(o(n)+" is not a function")}},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){(function(e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,o=/^0b[01]+$/i,a=/^0o[0-7]+$/i,i=parseInt,s="object"==typeof e&&e&&e.Object===Object&&e,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),p=Object.prototype.toString,d=Math.max,u=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==p.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=o.test(n);return s||a.test(n)?i(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,o,a,i,s,l,c=0,p=!1,g=!1,y=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=r,a=o;return r=o=void 0,c=e,i=n.apply(a,t)}function v(n){return c=n,s=setTimeout(w,e),p?b(n):i}function k(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=a}function w(){var n=m();if(k(n))return x(n);s=setTimeout(w,function(n){var t=e-(n-l);return g?u(t,a-(n-c)):t}(n))}function x(n){return s=void 0,y&&r?b(n):(r=o=void 0,i)}function T(){var n=m(),t=k(n);if(r=arguments,o=this,l=n,t){if(void 0===s)return v(l);if(g)return s=setTimeout(w,e),b(l)}return void 0===s&&(s=setTimeout(w,e)),i}return e=f(e)||0,h(t)&&(p=!!t.leading,a=(g="maxWait"in t)?d(f(t.maxWait)||0,e):a,y="trailing"in t?!!t.trailing:y),T.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=o=s=void 0},T.flush=function(){return void 0===s?i:x(m())},T}}).call(this,t(21))},function(n,e,t){var r=t(6),o=t(38),a=t(118),i=t(39),s=t(35),l=t(62),c=t(9),p=t(72),d=Object.getOwnPropertyDescriptor;e.f=r?d:function(n,e){if(n=s(n),e=l(e),p)try{return d(n,e)}catch(n){}if(c(n,e))return i(!o(a.f,n,e),n[e])}},function(n,e,t){var r=t(34),o=Function.prototype,a=o.call,i=r&&o.bind.bind(a,a);n.exports=r?i:function(n){return function(){return a.apply(n,arguments)}}},function(n,e,t){var r=t(61),o=TypeError;n.exports=function(n){if(r(n))throw o("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var r=t(119),o=t(64);n.exports=function(n){var e=r(n,"string");return o(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,r=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:r}},function(n,e,t){var r=t(23),o=t(3),a=t(65),i=t(66),s=Object;n.exports=i?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return o(e)&&a(e.prototype,s(n))}},function(n,e,t){var r=t(7);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r=t(67);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(68),o=t(5);n.exports=!!Object.getOwnPropertySymbols&&!o((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,o,a=t(4),i=t(120),s=a.process,l=a.Deno,c=s&&s.versions||l&&l.version,p=c&&c.v8;p&&(o=(r=p.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!o&&i&&(!(r=i.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=i.match(/Chrome\/(\d+)/))&&(o=+r[1]),n.exports=o},function(n,e,t){var r=t(70),o=t(40);(n.exports=function(n,e){return o[n]||(o[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.26.0",mode:r?"pure":"global",copyright:" 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.26.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var r=t(7),o=0,a=Math.random(),i=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+i(++o+a,36)}},function(n,e,t){var r=t(6),o=t(5),a=t(110);n.exports=!r&&!o((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(9),o=t(130),a=t(58),i=t(16);n.exports=function(n,e,t){for(var s=o(e),l=i.f,c=a.f,p=0;p<s.length;p++){var d=s[p];r(n,d)||t&&r(t,d)||l(n,d,c(e,d))}}},function(n,e,t){var r=t(134);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){var r=t(7),o=t(33),a=t(147);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return o(t),a(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,o=n.length;++t<r;)n[o+t]=e[t];return n}},function(n,e,t){(function(e){var t="object"==typeof e&&e&&e.Object===Object&&e;n.exports=t}).call(this,t(21))},function(n,e,t){var r=t(26),o=t(170),a=t(171),i=t(172),s=t(173),l=t(174);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=o,c.prototype.delete=a,c.prototype.get=i,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(17),o=t(44);n.exports=function(n){if(!o(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(191),o=t(14);n.exports=function n(e,t,a,i,s){return e===t||(null==e||null==t||!o(e)&&!o(t)?e!=e&&t!=t:r(e,t,a,i,n,s))}},function(n,e,t){var r=t(84),o=t(194),a=t(85);n.exports=function(n,e,t,i,s,l){var c=1&t,p=n.length,d=e.length;if(p!=d&&!(c&&d>p))return!1;var u=l.get(n),m=l.get(e);if(u&&m)return u==e&&m==n;var h=-1,f=!0,g=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++h<p;){var y=n[h],b=e[h];if(i)var v=c?i(b,y,h,e,n,l):i(y,b,h,n,e,l);if(void 0!==v){if(v)continue;f=!1;break}if(g){if(!o(e,(function(n,e){if(!a(g,e)&&(y===n||s(y,n,t,i,l)))return g.push(e)}))){f=!1;break}}else if(y!==b&&!s(y,b,t,i,l)){f=!1;break}}return l.delete(n),l.delete(e),f}},function(n,e,t){var r=t(45),o=t(192),a=t(193);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=o,i.prototype.has=a,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(204),o=t(210),a=t(90);n.exports=function(n){return a(n)?r(n):o(n)}},function(n,e,t){(function(n){var r=t(10),o=t(206),a=e&&!e.nodeType&&e,i=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=i&&i.exports===a?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||o;n.exports=l}).call(this,t(56)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(207),o=t(208),a=t(209),i=a&&a.isTypedArray,s=i?o(i):r;n.exports=s},function(n,e,t){var r=t(80),o=t(47);n.exports=function(n){return null!=n&&o(n.length)&&!r(n)}},function(n,e,t){var r=t(12)(t(10),"Set");n.exports=r},function(n,e,t){var r=t(44);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(95),o=t(30);n.exports=function(n,e){for(var t=0,a=(e=r(e,n)).length;null!=n&&t<a;)n=n[o(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var r=t(8),o=t(48),a=t(221),i=t(224);n.exports=function(n,e){return r(n)?n:o(n,e)?[n]:a(i(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(157),o=t(162),a=t(233),i=t(241),s=t(250),l=t(114),c=a((function(n){var e=l(n);return s(e)&&(e=void 0),i(r(n,1,s,!0),o(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,o=r.exec(t);if(!o)return t;var a="",i=0,s=0;for(i=o.index;i<t.length;i++){switch(t.charCodeAt(i)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==i&&(a+=t.substring(s,i)),s=i+1,a+=e}return s!==i?a+t.substring(s,i):a}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var r=t(262),o=t(263),a=t(264),i=!1,s=t(265).version,l=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=l.concat("cache"),p=/^\uFEFF/;function d(n,t){var o,a,i=t.views,s=/^[A-Za-z]+:\\|^\//.exec(n);if(s&&s.length)o=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(a=e.resolveInclude(n,t.filename),r.existsSync(a)&&(o=a)),o||Array.isArray(i)&&i.some((function(t){return a=e.resolveInclude(n,t,!0),r.existsSync(a)}))&&(o=a),!o)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return o}function u(n,t){var r,o=n.filename,a=arguments.length>1;if(n.cache){if(!o)throw new Error("cache option requires a filename");if(r=e.cache.get(o))return r;a||(t=h(o).toString().replace(p,""))}else if(!a){if(!o)throw new Error("Internal EJS error: no file name or template provided");t=h(o).toString().replace(p,"")}return r=e.compile(t,n),n.cache&&e.cache.set(o,r),r}function m(n,t,r){var o;if(!r){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,r){try{e(o=u(n)(t))}catch(n){r(n)}}));throw new Error("Please provide a callback function")}try{o=u(n)(t)}catch(n){return r(n)}r(null,o)}function h(n){return e.fileLoader(n)}function f(n,e,t,r,o){var a=e.split("\n"),i=Math.max(r-3,0),s=Math.min(a.length,r+3),l=o(t),c=a.slice(i,s).map((function(n,e){var t=e+i+1;return(t==r?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=l,n.message=(l||"ejs")+":"+r+"\n"+c+"\n\n"+n.message,n}function g(n){return n.replace(/;(\s*$)/,"$1")}function y(n,t){t=t||{};var r={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],r.client=t.client||!1,r.escapeFunction=t.escape||t.escapeFunction||a.escapeXML,r.compileDebug=!1!==t.compileDebug,r.debug=!!t.debug,r.filename=t.filename,r.openDelimiter=t.openDelimiter||e.openDelimiter||"<",r.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",r.delimiter=t.delimiter||e.delimiter||"%",r.strict=t.strict||!1,r.context=t.context,r.cache=t.cache||!1,r.rmWhitespace=t.rmWhitespace,r.root=t.root,r.outputFunctionName=t.outputFunctionName,r.localsName=t.localsName||e.localsName||"locals",r.views=t.views,r.async=t.async,r.destructuredLocals=t.destructuredLocals,r.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,r.strict?r._with=!1:r._with=void 0===t._with||t._with,this.opts=r,this.regex=this.createRegex()}e.cache=a.cache,e.fileLoader=r.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var r=o.dirname,a=o.extname,i=(0,o.resolve)(t?e:r(e),n);return a(n)||(i+=".ejs"),i},e.compile=function(n,e){return e&&e.scope&&(i||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),i=!0),e.context||(e.context=e.scope),delete e.scope),new y(n,e).compile()},e.render=function(n,e,t){var r=e||{},o=t||{};return 2==arguments.length&&a.shallowCopyFromList(o,r,l),u(o,n)(r)},e.renderFile=function(){var n,e,t,r=Array.prototype.slice.call(arguments),o=r.shift(),i={filename:o};return"function"==typeof arguments[arguments.length-1]&&(n=r.pop()),r.length?(e=r.shift(),r.length?a.shallowCopy(i,r.pop()):(e.settings&&(e.settings.views&&(i.views=e.settings.views),e.settings["view cache"]&&(i.cache=!0),(t=e.settings["view options"])&&a.shallowCopy(i,t)),a.shallowCopyFromList(i,e,c)),i.filename=o):e={},m(i,e,n)},e.Template=y,e.clearCache=function(){e.cache.reset()},y.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},y.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=a.escapeRegExpChars(this.opts.delimiter),t=a.escapeRegExpChars(this.opts.openDelimiter),r=a.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,r),new RegExp(n)},compile:function(){var n,e,t,r=this.opts,i="",s="",l=r.escapeFunction;if(!this.source){if(this.generateSource(),i+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',r.outputFunctionName&&(i+="  var "+r.outputFunctionName+" = __append;\n"),r.destructuredLocals&&r.destructuredLocals.length){for(var c="  var __locals = ("+r.localsName+" || {}),\n",p=0;p<r.destructuredLocals.length;p++){var m=r.destructuredLocals[p];p>0&&(c+=",\n  "),c+=m+" = __locals."+m}i+=c+";\n"}!1!==r._with&&(i+="  with ("+r.localsName+" || {}) {\n",s+="  }\n"),s+="  return __output;\n",this.source=i+this.source+s}n=r.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(r.filename?JSON.stringify(r.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,r.client&&(n="escapeFn = escapeFn || "+l.toString()+";\n"+n,r.compileDebug&&(n="rethrow = rethrow || "+f.toString()+";\n"+n)),r.strict&&(n='"use strict";\n'+n),r.debug&&console.log(n),r.compileDebug&&r.filename&&(n=n+"\n//# sourceURL="+r.filename+"\n");try{if(r.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(r.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(r.filename&&(n.message+=" in "+r.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",r.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var h=r.client?e:function(n){return e.apply(r.context,[n||{},l,function(e,t){var o=a.shallowCopy({},n);return t&&(o=a.shallowCopy(o,t)),function(n,e){var t=a.shallowCopy({},e);return t.filename=d(n,t),u(t)}(e,r)(o)},f])};if(h.dependencies=this.dependencies,r.filename&&"function"==typeof Object.defineProperty){var g=r.filename,y=o.basename(g,o.extname(g));try{Object.defineProperty(h,"name",{value:y,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return h},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,r=this.parseTemplateText(),o=this.opts.delimiter,i=this.opts.openDelimiter,s=this.opts.closeDelimiter;r&&r.length&&r.forEach((function(l,c){var u,m,f,g,b,v;if(0===l.indexOf(i+o)&&0!==l.indexOf(i+o+o)&&(m=r[c+2])!=o+s&&m!="-"+o+s&&m!="_"+o+s)throw new Error('Could not find matching close tag for "'+l+'".');if(n.legacyInclude&&(f=l.match(/^\s*include\s+(\S+)/))&&(u=r[c-1])&&(u==i+o||u==i+o+"-"||u==i+o+"_"))return g=a.shallowCopy({},t.opts),b=function(n,e){var t,r,o=a.shallowCopy({},e);r=h(t=d(n,o)).toString().replace(p,""),o.filename=t;var i=new y(r,o);return i.generateSource(),{source:i.source,filename:t,template:r}}(f[1],g),v=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(b.template)+"\n      , __filename = "+JSON.stringify(b.filename)+";\n      try {\n"+b.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+b.source+"    ; }).call(this)\n",t.source+=v,void t.dependencies.push(e.resolveInclude(f[1],g.filename));t.scanLine(l)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,r=t.exec(e),o=[];r;)0!==(n=r.index)&&(o.push(e.substring(0,n)),e=e.slice(n)),o.push(r[0]),e=e.slice(r[0].length),r=t.exec(e);return e&&o.push(e),o},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,r=this.opts.openDelimiter,o=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case r+t:case r+t+"_":this.mode=y.modes.EVAL;break;case r+t+"=":this.mode=y.modes.ESCAPED;break;case r+t+"-":this.mode=y.modes.RAW;break;case r+t+"#":this.mode=y.modes.COMMENT;break;case r+t+t:this.mode=y.modes.LITERAL,this.source+='    ; __append("'+n.replace(r+t+t,r+t)+'")\n';break;case t+t+o:this.mode=y.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+o,t+o)+'")\n';break;case t+o:case"-"+t+o:case"_"+t+o:this.mode==y.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case y.modes.EVAL:case y.modes.ESCAPED:case y.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case y.modes.EVAL:this.source+="    ; "+n+"\n";break;case y.modes.ESCAPED:this.source+="    ; __append(escapeFn("+g(n)+"))\n";break;case y.modes.RAW:this.source+="    ; __append("+g(n)+")\n";break;case y.modes.COMMENT:break;case y.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=a.escapeXML,e.__express=e.renderFile,e.VERSION=s,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var r=1,o=2,a=4,i=8;function s(n){this.mode=a,this.data=n}s.prototype={getLength:function(n){return this.data.length},write:function(n){for(var e=0;e<this.data.length;e++)n.put(this.data.charCodeAt(e),8)}};var l=s,c={L:1,M:0,Q:3,H:2};function p(n,e){this.totalCount=n,this.dataCount=e}p.RS_BLOCK_TABLE=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]],p.getRSBlocks=function(n,e){var t=p.getRsBlockTable(n,e);if(null==t)throw new Error("bad rs block @ typeNumber:"+n+"/errorCorrectLevel:"+e);for(var r=t.length/3,o=new Array,a=0;a<r;a++)for(var i=t[3*a+0],s=t[3*a+1],l=t[3*a+2],c=0;c<i;c++)o.push(new p(s,l));return o},p.getRsBlockTable=function(n,e){switch(e){case c.L:return p.RS_BLOCK_TABLE[4*(n-1)+0];case c.M:return p.RS_BLOCK_TABLE[4*(n-1)+1];case c.Q:return p.RS_BLOCK_TABLE[4*(n-1)+2];case c.H:return p.RS_BLOCK_TABLE[4*(n-1)+3];default:return}};var d=p;function u(){this.buffer=new Array,this.length=0}u.prototype={get:function(n){var e=Math.floor(n/8);return 1==(this.buffer[e]>>>7-n%8&1)},put:function(n,e){for(var t=0;t<e;t++)this.putBit(1==(n>>>e-t-1&1))},getLengthInBits:function(){return this.length},putBit:function(n){var e=Math.floor(this.length/8);this.buffer.length<=e&&this.buffer.push(0),n&&(this.buffer[e]|=128>>>this.length%8),this.length++}};for(var m=u,h={glog:function(n){if(n<1)throw new Error("glog("+n+")");return h.LOG_TABLE[n]},gexp:function(n){for(;n<0;)n+=255;for(;n>=256;)n-=255;return h.EXP_TABLE[n]},EXP_TABLE:new Array(256),LOG_TABLE:new Array(256)},f=0;f<8;f++)h.EXP_TABLE[f]=1<<f;for(f=8;f<256;f++)h.EXP_TABLE[f]=h.EXP_TABLE[f-4]^h.EXP_TABLE[f-5]^h.EXP_TABLE[f-6]^h.EXP_TABLE[f-8];for(f=0;f<255;f++)h.LOG_TABLE[h.EXP_TABLE[f]]=f;var g=h;function y(n,e){if(null==n.length)throw new Error(n.length+"/"+e);for(var t=0;t<n.length&&0==n[t];)t++;this.num=new Array(n.length-t+e);for(var r=0;r<n.length-t;r++)this.num[r]=n[r+t]}y.prototype={get:function(n){return this.num[n]},getLength:function(){return this.num.length},multiply:function(n){for(var e=new Array(this.getLength()+n.getLength()-1),t=0;t<this.getLength();t++)for(var r=0;r<n.getLength();r++)e[t+r]^=g.gexp(g.glog(this.get(t))+g.glog(n.get(r)));return new y(e,0)},mod:function(n){if(this.getLength()-n.getLength()<0)return this;for(var e=g.glog(this.get(0))-g.glog(n.get(0)),t=new Array(this.getLength()),r=0;r<this.getLength();r++)t[r]=this.get(r);for(r=0;r<n.getLength();r++)t[r]^=g.gexp(g.glog(n.get(r))+e);return new y(t,0).mod(n)}};var b=y,v=0,k=1,w=2,x=3,T=4,C=5,R=6,E=7,S={PATTERN_POSITION_TABLE:[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],G15:1335,G18:7973,G15_MASK:21522,getBCHTypeInfo:function(n){for(var e=n<<10;S.getBCHDigit(e)-S.getBCHDigit(S.G15)>=0;)e^=S.G15<<S.getBCHDigit(e)-S.getBCHDigit(S.G15);return(n<<10|e)^S.G15_MASK},getBCHTypeNumber:function(n){for(var e=n<<12;S.getBCHDigit(e)-S.getBCHDigit(S.G18)>=0;)e^=S.G18<<S.getBCHDigit(e)-S.getBCHDigit(S.G18);return n<<12|e},getBCHDigit:function(n){for(var e=0;0!=n;)e++,n>>>=1;return e},getPatternPosition:function(n){return S.PATTERN_POSITION_TABLE[n-1]},getMask:function(n,e,t){switch(n){case v:return(e+t)%2==0;case k:return e%2==0;case w:return t%3==0;case x:return(e+t)%3==0;case T:return(Math.floor(e/2)+Math.floor(t/3))%2==0;case C:return e*t%2+e*t%3==0;case R:return(e*t%2+e*t%3)%2==0;case E:return(e*t%3+(e+t)%2)%2==0;default:throw new Error("bad maskPattern:"+n)}},getErrorCorrectPolynomial:function(n){for(var e=new b([1],0),t=0;t<n;t++)e=e.multiply(new b([1,g.gexp(t)],0));return e},getLengthInBits:function(n,e){if(1<=e&&e<10)switch(n){case r:return 10;case o:return 9;case a:case i:return 8;default:throw new Error("mode:"+n)}else if(e<27)switch(n){case r:return 12;case o:return 11;case a:return 16;case i:return 10;default:throw new Error("mode:"+n)}else{if(!(e<41))throw new Error("type:"+e);switch(n){case r:return 14;case o:return 13;case a:return 16;case i:return 12;default:throw new Error("mode:"+n)}}},getLostPoint:function(n){for(var e=n.getModuleCount(),t=0,r=0;r<e;r++)for(var o=0;o<e;o++){for(var a=0,i=n.isDark(r,o),s=-1;s<=1;s++)if(!(r+s<0||e<=r+s))for(var l=-1;l<=1;l++)o+l<0||e<=o+l||0==s&&0==l||i==n.isDark(r+s,o+l)&&a++;a>5&&(t+=3+a-5)}for(r=0;r<e-1;r++)for(o=0;o<e-1;o++){var c=0;n.isDark(r,o)&&c++,n.isDark(r+1,o)&&c++,n.isDark(r,o+1)&&c++,n.isDark(r+1,o+1)&&c++,0!=c&&4!=c||(t+=3)}for(r=0;r<e;r++)for(o=0;o<e-6;o++)n.isDark(r,o)&&!n.isDark(r,o+1)&&n.isDark(r,o+2)&&n.isDark(r,o+3)&&n.isDark(r,o+4)&&!n.isDark(r,o+5)&&n.isDark(r,o+6)&&(t+=40);for(o=0;o<e;o++)for(r=0;r<e-6;r++)n.isDark(r,o)&&!n.isDark(r+1,o)&&n.isDark(r+2,o)&&n.isDark(r+3,o)&&n.isDark(r+4,o)&&!n.isDark(r+5,o)&&n.isDark(r+6,o)&&(t+=40);var p=0;for(o=0;o<e;o++)for(r=0;r<e;r++)n.isDark(r,o)&&p++;return t+=10*(Math.abs(100*p/e/e-50)/5)}},P=S;function _(n,e){this.typeNumber=n,this.errorCorrectLevel=e,this.modules=null,this.moduleCount=0,this.dataCache=null,this.dataList=[]}var I=_.prototype;I.addData=function(n){var e=new l(n);this.dataList.push(e),this.dataCache=null},I.isDark=function(n,e){if(n<0||this.moduleCount<=n||e<0||this.moduleCount<=e)throw new Error(n+","+e);return this.modules[n][e]},I.getModuleCount=function(){return this.moduleCount},I.make=function(){if(this.typeNumber<1){var n=1;for(n=1;n<40;n++){for(var e=d.getRSBlocks(n,this.errorCorrectLevel),t=new m,r=0,o=0;o<e.length;o++)r+=e[o].dataCount;for(o=0;o<this.dataList.length;o++){var a=this.dataList[o];t.put(a.mode,4),t.put(a.getLength(),P.getLengthInBits(a.mode,n)),a.write(t)}if(t.getLengthInBits()<=8*r)break}this.typeNumber=n}this.makeImpl(!1,this.getBestMaskPattern())},I.makeImpl=function(n,e){this.moduleCount=4*this.typeNumber+17,this.modules=new Array(this.moduleCount);for(var t=0;t<this.moduleCount;t++){this.modules[t]=new Array(this.moduleCount);for(var r=0;r<this.moduleCount;r++)this.modules[t][r]=null}this.setupPositionProbePattern(0,0),this.setupPositionProbePattern(this.moduleCount-7,0),this.setupPositionProbePattern(0,this.moduleCount-7),this.setupPositionAdjustPattern(),this.setupTimingPattern(),this.setupTypeInfo(n,e),this.typeNumber>=7&&this.setupTypeNumber(n),null==this.dataCache&&(this.dataCache=_.createData(this.typeNumber,this.errorCorrectLevel,this.dataList)),this.mapData(this.dataCache,e)},I.setupPositionProbePattern=function(n,e){for(var t=-1;t<=7;t++)if(!(n+t<=-1||this.moduleCount<=n+t))for(var r=-1;r<=7;r++)e+r<=-1||this.moduleCount<=e+r||(this.modules[n+t][e+r]=0<=t&&t<=6&&(0==r||6==r)||0<=r&&r<=6&&(0==t||6==t)||2<=t&&t<=4&&2<=r&&r<=4)},I.getBestMaskPattern=function(){for(var n=0,e=0,t=0;t<8;t++){this.makeImpl(!0,t);var r=P.getLostPoint(this);(0==t||n>r)&&(n=r,e=t)}return e},I.createMovieClip=function(n,e,t){var r=n.createEmptyMovieClip(e,t);this.make();for(var o=0;o<this.modules.length;o++)for(var a=1*o,i=0;i<this.modules[o].length;i++){var s=1*i;this.modules[o][i]&&(r.beginFill(0,100),r.moveTo(s,a),r.lineTo(s+1,a),r.lineTo(s+1,a+1),r.lineTo(s,a+1),r.endFill())}return r},I.setupTimingPattern=function(){for(var n=8;n<this.moduleCount-8;n++)null==this.modules[n][6]&&(this.modules[n][6]=n%2==0);for(var e=8;e<this.moduleCount-8;e++)null==this.modules[6][e]&&(this.modules[6][e]=e%2==0)},I.setupPositionAdjustPattern=function(){for(var n=P.getPatternPosition(this.typeNumber),e=0;e<n.length;e++)for(var t=0;t<n.length;t++){var r=n[e],o=n[t];if(null==this.modules[r][o])for(var a=-2;a<=2;a++)for(var i=-2;i<=2;i++)this.modules[r+a][o+i]=-2==a||2==a||-2==i||2==i||0==a&&0==i}},I.setupTypeNumber=function(n){for(var e=P.getBCHTypeNumber(this.typeNumber),t=0;t<18;t++){var r=!n&&1==(e>>t&1);this.modules[Math.floor(t/3)][t%3+this.moduleCount-8-3]=r}for(t=0;t<18;t++){r=!n&&1==(e>>t&1);this.modules[t%3+this.moduleCount-8-3][Math.floor(t/3)]=r}},I.setupTypeInfo=function(n,e){for(var t=this.errorCorrectLevel<<3|e,r=P.getBCHTypeInfo(t),o=0;o<15;o++){var a=!n&&1==(r>>o&1);o<6?this.modules[o][8]=a:o<8?this.modules[o+1][8]=a:this.modules[this.moduleCount-15+o][8]=a}for(o=0;o<15;o++){a=!n&&1==(r>>o&1);o<8?this.modules[8][this.moduleCount-o-1]=a:o<9?this.modules[8][15-o-1+1]=a:this.modules[8][15-o-1]=a}this.modules[this.moduleCount-8][8]=!n},I.mapData=function(n,e){for(var t=-1,r=this.moduleCount-1,o=7,a=0,i=this.moduleCount-1;i>0;i-=2)for(6==i&&i--;;){for(var s=0;s<2;s++)if(null==this.modules[r][i-s]){var l=!1;a<n.length&&(l=1==(n[a]>>>o&1)),P.getMask(e,r,i-s)&&(l=!l),this.modules[r][i-s]=l,-1==--o&&(a++,o=7)}if((r+=t)<0||this.moduleCount<=r){r-=t,t=-t;break}}},_.PAD0=236,_.PAD1=17,_.createData=function(n,e,t){for(var r=d.getRSBlocks(n,e),o=new m,a=0;a<t.length;a++){var i=t[a];o.put(i.mode,4),o.put(i.getLength(),P.getLengthInBits(i.mode,n)),i.write(o)}var s=0;for(a=0;a<r.length;a++)s+=r[a].dataCount;if(o.getLengthInBits()>8*s)throw new Error("code length overflow. ("+o.getLengthInBits()+">"+8*s+")");for(o.getLengthInBits()+4<=8*s&&o.put(0,4);o.getLengthInBits()%8!=0;)o.putBit(!1);for(;!(o.getLengthInBits()>=8*s||(o.put(_.PAD0,8),o.getLengthInBits()>=8*s));)o.put(_.PAD1,8);return _.createBytes(o,r)},_.createBytes=function(n,e){for(var t=0,r=0,o=0,a=new Array(e.length),i=new Array(e.length),s=0;s<e.length;s++){var l=e[s].dataCount,c=e[s].totalCount-l;r=Math.max(r,l),o=Math.max(o,c),a[s]=new Array(l);for(var p=0;p<a[s].length;p++)a[s][p]=255&n.buffer[p+t];t+=l;var d=P.getErrorCorrectPolynomial(c),u=new b(a[s],d.getLength()-1).mod(d);i[s]=new Array(d.getLength()-1);for(p=0;p<i[s].length;p++){var m=p+u.getLength()-i[s].length;i[s][p]=m>=0?u.get(m):0}}var h=0;for(p=0;p<e.length;p++)h+=e[p].totalCount;var f=new Array(h),g=0;for(p=0;p<r;p++)for(s=0;s<e.length;s++)p<a[s].length&&(f[g++]=a[s][p]);for(p=0;p<o;p++)for(s=0;s<e.length;s++)p<i[s].length&&(f[g++]=i[s][p]);return f};var j=_;var O={components:{QrcodeVue:{props:{value:{type:String,required:!0,default:""},className:{type:String,default:""},size:{type:[Number,String],default:100,validator:function(n){return!0!==isNaN(Number(n))}},level:{type:String,default:"L",validator:function(n){return["L","Q","M","H"].indexOf(n)>-1}},background:{type:String,default:"#fff"},foreground:{type:String,default:"#000"},renderAs:{type:String,required:!1,default:"canvas",validator:function(n){return["canvas","svg"].indexOf(n)>-1}}},data:function(){return{numCells:0,fgPath:""}},updated:function(){this.render()},mounted:function(){this.render()},methods:{render:function(){var n=this.value,e=this.size,t=this.level,r=this.background,o=this.foreground,a=this.renderAs,i=e>>>0,s=new j(-1,c[t]);s.addData(function(n){for(var e="",t=0;t<n.length;t++){var r=n.charCodeAt(t);r<128?e+=String.fromCharCode(r):r<2048?(e+=String.fromCharCode(192|r>>6),e+=String.fromCharCode(128|63&r)):r<55296||r>=57344?(e+=String.fromCharCode(224|r>>12),e+=String.fromCharCode(128|r>>6&63),e+=String.fromCharCode(128|63&r)):(t++,r=65536+((1023&r)<<10|1023&n.charCodeAt(t)),e+=String.fromCharCode(240|r>>18),e+=String.fromCharCode(128|r>>12&63),e+=String.fromCharCode(128|r>>6&63),e+=String.fromCharCode(128|63&r))}return e}(n)),s.make();var l=s.modules,p=i/l.length,d=i/l.length,u=window.devicePixelRatio||1;if("svg"===a)this.numCells=l.length,this.fgPath=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=[];return n.forEach((function(n,r){var o=null;n.forEach((function(a,i){if(!a&&null!==o)return t.push("M".concat(o+e," ").concat(r+e,"h").concat(i-o,"v1H").concat(o+e,"z")),void(o=null);if(i!==n.length-1)a&&null===o&&(o=i);else{if(!a)return;null===o?t.push("M".concat(i+e,",").concat(r+e," h1v1H").concat(i+e,"z")):t.push("M".concat(o+e,",").concat(r+e," h").concat(i+1-o,"v1H").concat(o+e,"z"))}}))})),t.join("")}(l);else{var m=this.$refs["qrcode-vue"],h=m.getContext("2d");m.height=m.width=i*u,h.scale(u,u),l.forEach((function(n,e){n.forEach((function(n,t){h.fillStyle=n?o:r;var a=Math.ceil((t+1)*p)-Math.floor(t*p),i=Math.ceil((e+1)*d)-Math.floor(e*d);h.fillRect(Math.round(t*p),Math.round(e*d),a,i)}))}))}}},render:function(n){var e=this.className,t=this.value,r=this.level,o=this.background,a=this.foreground,i=this.size,s=this.renderAs,l=this.numCells,c=this.fgPath;return n("div",{class:this.class||e,attrs:{value:t,level:r,background:o,foreground:a}},["svg"===s?n("svg",{attrs:{height:i,width:i,shapeRendering:"crispEdges",viewBox:"0 0 ".concat(l," ").concat(l)},style:{width:i+"px",height:i+"px"}},[n("path",{attrs:{fill:o,d:"M0,0 h".concat(l,"v").concat(l,"H0z")}}),n("path",{attrs:{fill:a,d:c}})]):n("canvas",{attrs:{height:i,width:i},style:{width:i+"px",height:i+"px"},ref:"qrcode-vue"},[])])}}},data:()=>({show:!1,qrcodeText:"",qrSize:100,channelQR:""}),props:{size:{type:[String,Number],default:"small"},channel:{type:Boolean,default:!1}},mounted(){let n=this.size,e="";switch(n){case"small":e=100;break;case"medium":e=150;break;case"big":e=200;break;default:if(null==(t=n)||""===t.toString().replace(/\s/g,"")||""==typeof t||isNaN(t))e=100;else{const t=Math.min(window.innerHeight,window.innerWidth);n=~~n,e=n<10?10:n>t?t:n}}var t;this.qrSize=e,this.channel&&(this.channelQR=location.href.indexOf("?")>-1?"&channel=qrcode":"?channel=qrcode"),document.documentElement.addEventListener("mousedown",()=>{this.show=!1})},methods:{showQrCode(){this.show=!this.show,this.show&&this.$nextTick(()=>{this.qrcodeText=location.href+this.channelQR})}}},F=(t(255),t(2)),A=Object(F.a)(O,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"qrcodeBtn",attrs:{title:""},on:{mousedown:function(e){return e.stopPropagation(),n.showQrCode.apply(null,arguments)}}},[e("svg",{attrs:{t:"1652063987836",viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg","p-id":"2096",width:"16",height:"16"}},[e("path",{attrs:{d:"M891.01653333 648.53333333V530.0224h-180.224v60.07466667h120.14933334V648.53333333z m-59.52853333 59.52853334v-58.9824h-60.6208v60.07466666h60.07466667v120.69546667h-57.89013334V771.41333333h-62.2592V649.6256h-60.07466666v60.07466667H591.18933333v-59.52853334h-60.6208v60.07466667h60.07466667v59.52853333h-60.07466667v120.14933334h60.07466667v-120.14933334h60.07466667v119.6032h60.07466666V831.488h61.71306667v58.43626667h118.51093333V708.06186667z m-180.77013333-58.9824V530.56853333l-120.14933334-0.54613333v60.07466667h60.07466667v58.9824zM132.98346667 133.5296v361.54026667h360.448V133.5296h-360.448z m226.64533333 226.64533333h-92.84266667v-92.84266666h92.84266667v92.84266666z m-226.64533333 169.84746667v359.90186667h360.448V530.0224h-360.448z m226.64533333 226.0992h-92.84266667v-92.84266667h92.84266667v92.84266667z m170.93973333-622.592v360.448h360.448v-360.448h-360.448z m229.92213334 226.64533333h-92.84266667v-92.84266666h92.84266667v92.84266666z",fill:"#2C2C2C","p-id":"2097"}})]),n._v(" "),n.show?e("qrcode-vue",{ref:"qrcodeContainer",attrs:{id:"qrcodeContainer",value:n.qrcodeText,size:n.qrSize,level:"H"}}):n._e()],1)}),[],!1,null,null,null);e.default=A.exports},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},o=(t(256),t(2)),a=Object(o.a)(r,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"1e7dd946",null);e.default=a.exports},function(n,e,t){"use strict";t.r(e);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},o=(t(257),t(2)),a=Object(o.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"9a3094b0",null);e.default=a.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(4),o=t(11),a=r.document,i=o(a)&&o(a.createElement);n.exports=function(n){return i?a.createElement(n):{}}},function(n,e,t){var r=t(6),o=t(5);n.exports=r&&o((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(69),o=t(71),a=r("keys");n.exports=function(n){return a[n]||(a[n]=o(n))}},function(n,e,t){var r=t(7),o=t(9),a=t(35),i=t(132).indexOf,s=t(55),l=r([].push);n.exports=function(n,e){var t,r=a(n),c=0,p=[];for(t in r)!o(s,t)&&o(r,t)&&l(p,t);for(;e.length>c;)o(r,t=e[c++])&&(~i(p,t)||l(p,t));return p}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e){var t,r,o=n.exports={};function a(){throw new Error("setTimeout has not been defined")}function i(){throw new Error("clearTimeout has not been defined")}function s(n){if(t===setTimeout)return setTimeout(n,0);if((t===a||!t)&&setTimeout)return t=setTimeout,setTimeout(n,0);try{return t(n,0)}catch(e){try{return t.call(null,n,0)}catch(e){return t.call(this,n,0)}}}!function(){try{t="function"==typeof setTimeout?setTimeout:a}catch(n){t=a}try{r="function"==typeof clearTimeout?clearTimeout:i}catch(n){r=i}}();var l,c=[],p=!1,d=-1;function u(){p&&l&&(p=!1,l.length?c=l.concat(c):d=-1,c.length&&m())}function m(){if(!p){var n=s(u);p=!0;for(var e=c.length;e;){for(l=c,c=[];++d<e;)l&&l[d].run();d=-1,e=c.length}l=null,p=!1,function(n){if(r===clearTimeout)return clearTimeout(n);if((r===i||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(n);try{r(n)}catch(e){try{return r.call(null,n)}catch(e){return r.call(this,n)}}}(n)}}function h(n,e){this.fun=n,this.array=e}function f(){}o.nextTick=function(n){var e=new Array(arguments.length-1);if(arguments.length>1)for(var t=1;t<arguments.length;t++)e[t-1]=arguments[t];c.push(new h(n,e)),1!==c.length||p||s(m)},h.prototype.run=function(){this.fun.apply(null,this.array)},o.title="browser",o.browser=!0,o.env={},o.argv=[],o.version="",o.versions={},o.on=f,o.addListener=f,o.once=f,o.off=f,o.removeListener=f,o.removeAllListeners=f,o.emit=f,o.prependListener=f,o.prependOnceListener=f,o.listeners=function(n){return[]},o.binding=function(n){throw new Error("process.binding is not supported")},o.cwd=function(){return"/"},o.chdir=function(n){throw new Error("process.chdir is not supported")},o.umask=function(){return 0}},function(n,e,t){n.exports=t(270)},function(n,e,t){"use strict";var r=t(22),o=t(138).left,a=t(139),i=t(68),s=t(140);r({target:"Array",proto:!0,forced:!a("reduce")||!s&&i>79&&i<83},{reduce:function(n){var e=arguments.length;return o(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,o=Object.getOwnPropertyDescriptor,a=o&&!r.call({1:2},1);e.f=a?function(n){var e=o(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(38),o=t(11),a=t(64),i=t(121),s=t(123),l=t(24),c=TypeError,p=l("toPrimitive");n.exports=function(n,e){if(!o(n)||a(n))return n;var t,l=i(n,p);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!o(t)||a(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){var r=t(23);n.exports=r("navigator","userAgent")||""},function(n,e,t){var r=t(54),o=t(61);n.exports=function(n,e){var t=n[e];return o(t)?void 0:r(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var r=t(38),o=t(3),a=t(11),i=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&o(t=n.toString)&&!a(s=r(t,n)))return s;if(o(t=n.valueOf)&&!a(s=r(t,n)))return s;if("string"!==e&&o(t=n.toString)&&!a(s=r(t,n)))return s;throw i("Can't convert object to primitive value")}},function(n,e,t){var r=t(3),o=t(16),a=t(125),i=t(41);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(r(t)&&a(t,c,s),s.global)l?n[e]=t:i(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:o.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var r=t(5),o=t(3),a=t(9),i=t(6),s=t(126).CONFIGURABLE,l=t(127),c=t(128),p=c.enforce,d=c.get,u=Object.defineProperty,m=i&&!r((function(){return 8!==u((function(){}),"length",{value:8}).length})),h=String(String).split("String"),f=n.exports=function(n,e,t){"Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!a(n,"name")||s&&n.name!==e)&&(i?u(n,"name",{value:e,configurable:!0}):n.name=e),m&&t&&a(t,"arity")&&n.length!==t.arity&&u(n,"length",{value:t.arity});try{t&&a(t,"constructor")&&t.constructor?i&&u(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=p(n);return a(r,"source")||(r.source=h.join("string"==typeof e?e:"")),n};Function.prototype.toString=f((function(){return o(this)&&d(this).source||l(this)}),"toString")},function(n,e,t){var r=t(6),o=t(9),a=Function.prototype,i=r&&Object.getOwnPropertyDescriptor,s=o(a,"name"),l=s&&"something"===function(){}.name,c=s&&(!r||r&&i(a,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var r=t(7),o=t(3),a=t(40),i=r(Function.toString);o(a.inspectSource)||(a.inspectSource=function(n){return i(n)}),n.exports=a.inspectSource},function(n,e,t){var r,o,a,i=t(129),s=t(4),l=t(11),c=t(25),p=t(9),d=t(40),u=t(112),m=t(55),h=s.TypeError,f=s.WeakMap;if(i||d.state){var g=d.state||(d.state=new f);g.get=g.get,g.has=g.has,g.set=g.set,r=function(n,e){if(g.has(n))throw h("Object already initialized");return e.facade=n,g.set(n,e),e},o=function(n){return g.get(n)||{}},a=function(n){return g.has(n)}}else{var y=u("state");m[y]=!0,r=function(n,e){if(p(n,y))throw h("Object already initialized");return e.facade=n,c(n,y,e),e},o=function(n){return p(n,y)?n[y]:{}},a=function(n){return p(n,y)}}n.exports={set:r,get:o,has:a,enforce:function(n){return a(n)?o(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=o(e)).type!==n)throw h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(4),o=t(3),a=r.WeakMap;n.exports=o(a)&&/native code/.test(String(a))},function(n,e,t){var r=t(23),o=t(7),a=t(131),i=t(136),s=t(33),l=o([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=a.f(s(n)),t=i.f;return t?l(e,t(n)):e}},function(n,e,t){var r=t(113),o=t(109).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,o)}},function(n,e,t){var r=t(35),o=t(133),a=t(37),i=function(n){return function(e,t,i){var s,l=r(e),c=a(l),p=o(i,c);if(n&&t!=t){for(;c>p;)if((s=l[p++])!=s)return!0}else for(;c>p;p++)if((n||p in l)&&l[p]===t)return n||p||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e,t){var r=t(74),o=Math.max,a=Math.min;n.exports=function(n,e){var t=r(n);return t<0?o(t+e,0):a(t,e)}},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:t)(e)}},function(n,e,t){var r=t(74),o=Math.min;n.exports=function(n){return n>0?o(r(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(5),o=t(3),a=/#|\.prototype\./,i=function(n,e){var t=l[s(n)];return t==p||t!=c&&(o(e)?r(e):!!e)},s=i.normalize=function(n){return String(n).replace(a,".").toLowerCase()},l=i.data={},c=i.NATIVE="N",p=i.POLYFILL="P";n.exports=i},function(n,e,t){var r=t(54),o=t(36),a=t(53),i=t(37),s=TypeError,l=function(n){return function(e,t,l,c){r(t);var p=o(e),d=a(p),u=i(p),m=n?u-1:0,h=n?-1:1;if(l<2)for(;;){if(m in d){c=d[m],m+=h;break}if(m+=h,n?m<0:u<=m)throw s("Reduce of empty array with no initial value")}for(;n?m>=0:u>m;m+=h)m in d&&(c=t(c,d[m],m,p));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var r=t(5);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(18),o=t(4);n.exports="process"==r(o.process)},function(n,e,t){"use strict";var r=t(6),o=t(142),a=TypeError,i=Object.getOwnPropertyDescriptor,s=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(o(n)&&!i(n,"length").writable)throw a("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var r=t(18);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var r=t(22),o=t(4),a=t(145),i=t(146),s=o.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=i(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},p=function(n,e){if(s&&s[n]){var t={};t[n]=i("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return a(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),c("URIError",(function(n){return function(e){return a(n,this,arguments)}})),p("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),p("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),p("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){var r=t(34),o=Function.prototype,a=o.apply,i=o.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?i.bind(a):function(){return i.apply(a,arguments)})},function(n,e,t){"use strict";var r=t(23),o=t(9),a=t(25),i=t(65),s=t(75),l=t(73),c=t(148),p=t(149),d=t(150),u=t(154),m=t(155),h=t(156),f=t(6),g=t(70);n.exports=function(n,e,t,y){var b=y?2:1,v=n.split("."),k=v[v.length-1],w=r.apply(null,v);if(w){var x=w.prototype;if(!g&&o(x,"cause")&&delete x.cause,!t)return w;var T=r("Error"),C=e((function(n,e){var t=d(y?e:n,void 0),r=y?new w(n):new w;return void 0!==t&&a(r,"message",t),h&&a(r,"stack",m(r.stack,2)),this&&i(x,this)&&p(r,this,C),arguments.length>b&&u(r,arguments[b]),r}));if(C.prototype=x,"Error"!==k?s?s(C,T):l(C,T,{name:!0}):f&&"stackTraceLimit"in w&&(c(C,w,"stackTraceLimit"),c(C,w,"prepareStackTrace")),l(C,w),!g)try{x.name!==k&&a(x,"name",k),x.constructor=C}catch(n){}return C}}},function(n,e,t){var r=t(3),o=String,a=TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw a("Can't set "+o(n)+" as a prototype")}},function(n,e,t){var r=t(16).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var r=t(3),o=t(11),a=t(75);n.exports=function(n,e,t){var i,s;return a&&r(i=e.constructor)&&i!==t&&o(s=i.prototype)&&s!==t.prototype&&a(n,s),n}},function(n,e,t){var r=t(151);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){var r=t(152),o=String;n.exports=function(n){if("Symbol"===r(n))throw TypeError("Cannot convert a Symbol value to a string");return o(n)}},function(n,e,t){var r=t(153),o=t(3),a=t(18),i=t(24)("toStringTag"),s=Object,l="Arguments"==a(function(){return arguments}());n.exports=r?a:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),i))?t:l?a(e):"Object"==(r=a(e))&&o(e.callee)?"Arguments":r}},function(n,e,t){var r={};r[t(24)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(11),o=t(25);n.exports=function(n,e){r(e)&&"cause"in e&&o(n,"cause",e.cause)}},function(n,e,t){var r=t(7),o=Error,a=r("".replace),i=String(o("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(i);n.exports=function(n,e){if(l&&"string"==typeof n&&!o.prepareStackTrace)for(;e--;)n=a(n,s,"");return n}},function(n,e,t){var r=t(5),o=t(39);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",o(1,7)),7!==n.stack)}))},function(n,e,t){var r=t(76),o=t(158);n.exports=function n(e,t,a,i,s){var l=-1,c=e.length;for(a||(a=o),s||(s=[]);++l<c;){var p=e[l];t>0&&a(p)?t>1?n(p,t-1,a,i,s):r(s,p):i||(s[s.length]=p)}return s}},function(n,e,t){var r=t(19),o=t(42),a=t(8),i=r?r.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||o(n)||!!(i&&n&&n[i])}},function(n,e,t){var r=t(17),o=t(14);n.exports=function(n){return o(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(19),o=Object.prototype,a=o.hasOwnProperty,i=o.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=a.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var o=i.call(n);return r&&(e?n[s]=t:delete n[s]),o}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(163),o=t(219),a=t(50),i=t(8),s=t(230);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?i(n)?o(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(164),o=t(218),a=t(93);n.exports=function(n){var e=o(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(78),o=t(82);n.exports=function(n,e,t,a){var i=t.length,s=i,l=!a;if(null==n)return!s;for(n=Object(n);i--;){var c=t[i];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++i<s;){var p=(c=t[i])[0],d=n[p],u=c[1];if(l&&c[2]){if(void 0===d&&!(p in n))return!1}else{var m=new r;if(a)var h=a(d,u,p,n,e,m);if(!(void 0===h?o(u,d,3,a,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(27),o=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():o.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(27);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(27);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(27);n.exports=function(n,e){var t=this.__data__,o=r(t,n);return o<0?(++this.size,t.push([n,e])):t[o][1]=e,this}},function(n,e,t){var r=t(26);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(26),o=t(43),a=t(45);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var i=t.__data__;if(!o||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(80),o=t(176),a=t(44),i=t(81),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,p=l.toString,d=c.hasOwnProperty,u=RegExp("^"+p.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||o(n))&&(r(n)?u:s).test(i(n))}},function(n,e,t){var r,o=t(177),a=(r=/[^.]+$/.exec(o&&o.keys&&o.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var r=t(10)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(180),o=t(26),a=t(43);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(a||o),string:new r}}},function(n,e,t){var r=t(181),o=t(182),a=t(183),i=t(184),s=t(185);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(28);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(28),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return o.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(28),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:o.call(e,n)}},function(n,e,t){var r=t(28);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(29);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(29);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(29);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(29);n.exports=function(n,e){var t=r(this,n),o=t.size;return t.set(n,e),this.size+=t.size==o?0:1,this}},function(n,e,t){var r=t(78),o=t(83),a=t(195),i=t(198),s=t(214),l=t(8),c=t(87),p=t(89),d="[object Object]",u=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,f){var g=l(n),y=l(e),b=g?"[object Array]":s(n),v=y?"[object Array]":s(e),k=(b="[object Arguments]"==b?d:b)==d,w=(v="[object Arguments]"==v?d:v)==d,x=b==v;if(x&&c(n)){if(!c(e))return!1;g=!0,k=!1}if(x&&!k)return f||(f=new r),g||p(n)?o(n,e,t,m,h,f):a(n,e,b,t,m,h,f);if(!(1&t)){var T=k&&u.call(n,"__wrapped__"),C=w&&u.call(e,"__wrapped__");if(T||C){var R=T?n.value():n,E=C?e.value():e;return f||(f=new r),h(R,E,t,m,f)}}return!!x&&(f||(f=new r),i(n,e,t,m,h,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(19),o=t(196),a=t(79),i=t(83),s=t(197),l=t(46),c=r?r.prototype:void 0,p=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,d,u){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new o(n),new o(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var h=1&r;if(m||(m=l),n.size!=e.size&&!h)return!1;var f=u.get(n);if(f)return f==e;r|=2,u.set(n,e);var g=i(m(n),m(e),r,c,d,u);return u.delete(n),g;case"[object Symbol]":if(p)return p.call(n)==p.call(e)}return!1}},function(n,e,t){var r=t(10).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(199),o=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,i,s){var l=1&t,c=r(n),p=c.length;if(p!=r(e).length&&!l)return!1;for(var d=p;d--;){var u=c[d];if(!(l?u in e:o.call(e,u)))return!1}var m=s.get(n),h=s.get(e);if(m&&h)return m==e&&h==n;var f=!0;s.set(n,e),s.set(e,n);for(var g=l;++d<p;){var y=n[u=c[d]],b=e[u];if(a)var v=l?a(b,y,u,e,n,s):a(y,b,u,n,e,s);if(!(void 0===v?y===b||i(y,b,t,a,s):v)){f=!1;break}g||(g="constructor"==u)}if(f&&!g){var k=n.constructor,w=e.constructor;k==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof k&&k instanceof k&&"function"==typeof w&&w instanceof w||(f=!1)}return s.delete(n),s.delete(e),f}},function(n,e,t){var r=t(200),o=t(201),a=t(86);n.exports=function(n){return r(n,a,o)}},function(n,e,t){var r=t(76),o=t(8);n.exports=function(n,e,t){var a=e(n);return o(n)?a:r(a,t(n))}},function(n,e,t){var r=t(202),o=t(203),a=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,s=i?function(n){return null==n?[]:(n=Object(n),r(i(n),(function(e){return a.call(n,e)})))}:o;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,o=0,a=[];++t<r;){var i=n[t];e(i,t,n)&&(a[o++]=i)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(205),o=t(42),a=t(8),i=t(87),s=t(88),l=t(89),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),p=!t&&o(n),d=!t&&!p&&i(n),u=!t&&!p&&!d&&l(n),m=t||p||d||u,h=m?r(n.length,String):[],f=h.length;for(var g in n)!e&&!c.call(n,g)||m&&("length"==g||d&&("offset"==g||"parent"==g)||u&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||s(g,f))||h.push(g);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(17),o=t(47),a=t(14),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&o(n.length)&&!!i[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(77),o=e&&!e.nodeType&&e,a=o&&"object"==typeof n&&n&&!n.nodeType&&n,i=a&&a.exports===o&&r.process,s=function(){try{var n=a&&a.require&&a.require("util").types;return n||i&&i.binding&&i.binding("util")}catch(n){}}();n.exports=s}).call(this,t(56)(n))},function(n,e,t){var r=t(211),o=t(212),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return o(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(213)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(215),o=t(43),a=t(216),i=t(91),s=t(217),l=t(17),c=t(81),p=c(r),d=c(o),u=c(a),m=c(i),h=c(s),f=l;(r&&"[object DataView]"!=f(new r(new ArrayBuffer(1)))||o&&"[object Map]"!=f(new o)||a&&"[object Promise]"!=f(a.resolve())||i&&"[object Set]"!=f(new i)||s&&"[object WeakMap]"!=f(new s))&&(f=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case p:return"[object DataView]";case d:return"[object Map]";case u:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=f},function(n,e,t){var r=t(12)(t(10),"DataView");n.exports=r},function(n,e,t){var r=t(12)(t(10),"Promise");n.exports=r},function(n,e,t){var r=t(12)(t(10),"WeakMap");n.exports=r},function(n,e,t){var r=t(92),o=t(86);n.exports=function(n){for(var e=o(n),t=e.length;t--;){var a=e[t],i=n[a];e[t]=[a,i,r(i)]}return e}},function(n,e,t){var r=t(82),o=t(220),a=t(227),i=t(48),s=t(92),l=t(93),c=t(30);n.exports=function(n,e){return i(n)&&s(e)?l(c(n),e):function(t){var i=o(t,n);return void 0===i&&i===e?a(t,n):r(e,i,3)}}},function(n,e,t){var r=t(94);n.exports=function(n,e,t){var o=null==n?void 0:r(n,e);return void 0===o?t:o}},function(n,e,t){var r=t(222),o=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,i=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(o,(function(n,t,r,o){e.push(r?o.replace(a,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var r=t(223);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(45);function o(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,o=e?e.apply(this,r):r[0],a=t.cache;if(a.has(o))return a.get(o);var i=n.apply(this,r);return t.cache=a.set(o,i)||a,i};return t.cache=new(o.Cache||r),t}o.Cache=r,n.exports=o},function(n,e,t){var r=t(225);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(19),o=t(226),a=t(8),i=t(49),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return o(e,n)+"";if(i(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,o=Array(r);++t<r;)o[t]=e(n[t],t,n);return o}},function(n,e,t){var r=t(228),o=t(229);n.exports=function(n,e){return null!=n&&o(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(95),o=t(42),a=t(8),i=t(88),s=t(47),l=t(30);n.exports=function(n,e,t){for(var c=-1,p=(e=r(e,n)).length,d=!1;++c<p;){var u=l(e[c]);if(!(d=null!=n&&t(n,u)))break;n=n[u]}return d||++c!=p?d:!!(p=null==n?0:n.length)&&s(p)&&i(u,p)&&(a(n)||o(n))}},function(n,e,t){var r=t(231),o=t(232),a=t(48),i=t(30);n.exports=function(n){return a(n)?r(i(n)):o(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(94);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(50),o=t(234),a=t(236);n.exports=function(n,e){return a(o(n,e,r),n+"")}},function(n,e,t){var r=t(235),o=Math.max;n.exports=function(n,e,t){return e=o(void 0===e?n.length-1:e,0),function(){for(var a=arguments,i=-1,s=o(a.length-e,0),l=Array(s);++i<s;)l[i]=a[e+i];i=-1;for(var c=Array(e+1);++i<e;)c[i]=a[i];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(237),o=t(240)(r);n.exports=o},function(n,e,t){var r=t(238),o=t(239),a=t(50),i=o?function(n,e){return o(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:a;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(12),o=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=o},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var o=t(),a=16-(o-r);if(r=o,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(84),o=t(242),a=t(247),i=t(85),s=t(248),l=t(46);n.exports=function(n,e,t){var c=-1,p=o,d=n.length,u=!0,m=[],h=m;if(t)u=!1,p=a;else if(d>=200){var f=e?null:s(n);if(f)return l(f);u=!1,p=i,h=new r}else h=e?[]:m;n:for(;++c<d;){var g=n[c],y=e?e(g):g;if(g=t||0!==g?g:0,u&&y==y){for(var b=h.length;b--;)if(h[b]===y)continue n;e&&h.push(y),m.push(g)}else p(h,y,t)||(h!==m&&h.push(y),m.push(g))}return m}},function(n,e,t){var r=t(243);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(244),o=t(245),a=t(246);n.exports=function(n,e,t){return e==e?a(n,e,t):r(n,o,t)}},function(n,e){n.exports=function(n,e,t,r){for(var o=n.length,a=t+(r?1:-1);r?a--:++a<o;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,o=n.length;++r<o;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,o=null==n?0:n.length;++r<o;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(91),o=t(249),a=t(46),i=r&&1/a(new r([,-0]))[1]==1/0?function(n){return new r(n)}:o;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(90),o=t(14);n.exports=function(n){return o(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(96)},function(n,e,t){"use strict";t(97)},function(n,e,t){"use strict";t(98)},function(n,e,t){"use strict";t(99)},function(n,e,t){"use strict";t(100)},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(22),o=t(4),a=t(261);r({global:!0},{Reflect:{}}),a(o.Reflect,"Reflect",!0)},function(n,e,t){var r=t(16).f,o=t(9),a=t(24)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!o(n,a)&&r(n,a,{configurable:!0,value:e})}},function(n,e){},function(n,e,t){(function(n){function t(n,e){for(var t=0,r=n.length-1;r>=0;r--){var o=n[r];"."===o?n.splice(r,1):".."===o?(n.splice(r,1),t++):t&&(n.splice(r,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function r(n,e){if(n.filter)return n.filter(e);for(var t=[],r=0;r<n.length;r++)e(n[r],r,n)&&t.push(n[r]);return t}e.resolve=function(){for(var e="",o=!1,a=arguments.length-1;a>=-1&&!o;a--){var i=a>=0?arguments[a]:n.cwd();if("string"!=typeof i)throw new TypeError("Arguments to path.resolve must be strings");i&&(e=i+"/"+e,o="/"===i.charAt(0))}return(o?"/":"")+(e=t(r(e.split("/"),(function(n){return!!n})),!o).join("/"))||"."},e.normalize=function(n){var a=e.isAbsolute(n),i="/"===o(n,-1);return(n=t(r(n.split("/"),(function(n){return!!n})),!a).join("/"))||a||(n="."),n&&i&&(n+="/"),(a?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(r(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function r(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var o=r(n.split("/")),a=r(t.split("/")),i=Math.min(o.length,a.length),s=i,l=0;l<i;l++)if(o[l]!==a[l]){s=l;break}var c=[];for(l=s;l<o.length;l++)c.push("..");return(c=c.concat(a.slice(s))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,r=-1,o=!0,a=n.length-1;a>=1;--a)if(47===(e=n.charCodeAt(a))){if(!o){r=a;break}}else o=!1;return-1===r?t?"/":".":t&&1===r?"/":n.slice(0,r)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,r=-1,o=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!o){t=e+1;break}}else-1===r&&(o=!1,r=e+1);return-1===r?"":n.slice(t,r)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,r=-1,o=!0,a=0,i=n.length-1;i>=0;--i){var s=n.charCodeAt(i);if(47!==s)-1===r&&(o=!1,r=i+1),46===s?-1===e?e=i:1!==a&&(a=1):-1!==e&&(a=-1);else if(!o){t=i+1;break}}return-1===e||-1===r||0===a||1===a&&e===r-1&&e===t+1?"":n.slice(e,r)};var o="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}}).call(this,t(115))},function(n,e,t){"use strict";var r=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(r,"\\$&"):""};var o={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},a=/[&<>'"]/g;function i(n){return o[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(a,i)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var r=0;r<t.length;r++){var o=t[r];void 0!==e[o]&&(n[o]=e[o])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"name":"ejs","description":"Embedded JavaScript templates","keywords":["template","engine","ejs"],"version":"2.7.4","author":"Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)","license":"Apache-2.0","main":"./lib/ejs.js","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"bugs":"https://github.com/mde/ejs/issues","homepage":"https://github.com/mde/ejs","dependencies":{},"devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"scripts":{"test":"mocha","postinstall":"node ./postinstall.js"}}')},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(101)},function(n,e,t){"use strict";t(102)},function(n,e,t){"use strict";t.r(e);var r=t(1);
/*!
  * vue-router v3.6.5
  * (c) 2022 Evan You
  * @license MIT
  */function o(n,e){for(var t in e)n[t]=e[t];return n}var a=/[!'()*]/g,i=function(n){return"%"+n.charCodeAt(0).toString(16)},s=/%2C/g,l=function(n){return encodeURIComponent(n).replace(a,i).replace(s,",")};function c(n){try{return decodeURIComponent(n)}catch(n){0}return n}var p=function(n){return null==n||"object"==typeof n?n:String(n)};function d(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=c(t.shift()),o=t.length>0?c(t.join("=")):null;void 0===e[r]?e[r]=o:Array.isArray(e[r])?e[r].push(o):e[r]=[e[r],o]})),e):e}function u(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return l(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(l(e)):r.push(l(e)+"="+l(n)))})),r.join("&")}return l(e)+"="+l(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var m=/\/?$/;function h(n,e,t,r){var o=r&&r.options.stringifyQuery,a=e.query||{};try{a=f(a)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:b(e,o),matched:n?y(n):[]};return t&&(i.redirectedFrom=b(t,o)),Object.freeze(i)}function f(n){if(Array.isArray(n))return n.map(f);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=f(n[t]);return e}return n}var g=h(null,{path:"/"});function y(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function b(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var o=n.hash;return void 0===o&&(o=""),(t||"/")+(e||u)(r)+o}function v(n,e,t){return e===g?n===e:!!e&&(n.path&&e.path?n.path.replace(m,"")===e.path.replace(m,"")&&(t||n.hash===e.hash&&k(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&k(n.query,e.query)&&k(n.params,e.params))))}function k(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,o){var a=n[t];if(r[o]!==t)return!1;var i=e[t];return null==a||null==i?a===i:"object"==typeof a&&"object"==typeof i?k(a,i):String(a)===String(i)}))}function w(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var o=t.instances[r],a=t.enteredCbs[r];if(o&&a){delete t.enteredCbs[r];for(var i=0;i<a.length;i++)o._isBeingDestroyed||a[i](o)}}}}var x={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,a=e.parent,i=e.data;i.routerView=!0;for(var s=a.$createElement,l=t.name,c=a.$route,p=a._routerViewCache||(a._routerViewCache={}),d=0,u=!1;a&&a._routerRoot!==a;){var m=a.$vnode?a.$vnode.data:{};m.routerView&&d++,m.keepAlive&&a._directInactive&&a._inactive&&(u=!0),a=a.$parent}if(i.routerViewDepth=d,u){var h=p[l],f=h&&h.component;return f?(h.configProps&&T(f,i,h.route,h.configProps),s(f,i,r)):s()}var g=c.matched[d],y=g&&g.components[l];if(!g||!y)return p[l]=null,s();p[l]={component:y},i.registerRouteInstance=function(n,e){var t=g.instances[l];(e&&t!==n||!e&&t===n)&&(g.instances[l]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){g.instances[l]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==g.instances[l]&&(g.instances[l]=n.componentInstance),w(c)};var b=g.props&&g.props[l];return b&&(o(p[l],{route:c,configProps:b}),T(y,i,c,b)),s(y,i,r)}};function T(n,e,t,r){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(a){a=e.props=o({},a);var i=e.attrs=e.attrs||{};for(var s in a)n.props&&s in n.props||(i[s]=a[s],delete a[s])}}function C(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var o=e.split("/");t&&o[o.length-1]||o.pop();for(var a=n.replace(/^\//,"").split("/"),i=0;i<a.length;i++){var s=a[i];".."===s?o.pop():"."!==s&&o.push(s)}return""!==o[0]&&o.unshift(""),o.join("/")}function R(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var E=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},S=N,P=F,_=function(n,e){return M(F(n,e),e)},I=M,j=U,O=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function F(n,e){for(var t,r=[],o=0,a=0,i="",s=e&&e.delimiter||"/";null!=(t=O.exec(n));){var l=t[0],c=t[1],p=t.index;if(i+=n.slice(a,p),a=p+l.length,c)i+=c[1];else{var d=n[a],u=t[2],m=t[3],h=t[4],f=t[5],g=t[6],y=t[7];i&&(r.push(i),i="");var b=null!=u&&null!=d&&d!==u,v="+"===g||"*"===g,k="?"===g||"*"===g,w=t[2]||s,x=h||f;r.push({name:m||o++,prefix:u||"",delimiter:w,optional:k,repeat:v,partial:b,asterisk:!!y,pattern:x?z(x):y?".*":"[^"+D(w)+"]+?"})}}return a<n.length&&(i+=n.substr(a)),i&&r.push(i),r}function A(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function M(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",L(e)));return function(e,r){for(var o="",a=e||{},i=(r||{}).pretty?A:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,p=a[l.name];if(null==p){if(l.optional){l.partial&&(o+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(E(p)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(p)+"`");if(0===p.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<p.length;d++){if(c=i(p[d]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");o+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(p).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(p),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');o+=l.prefix+c}}else o+=l}return o}}function D(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function z(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function q(n,e){return n.keys=e,n}function L(n){return n&&n.sensitive?"":"i"}function U(n,e,t){E(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,o=!1!==t.end,a="",i=0;i<n.length;i++){var s=n[i];if("string"==typeof s)a+=D(s);else{var l=D(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),a+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var p=D(t.delimiter||"/"),d=a.slice(-p.length)===p;return r||(a=(d?a.slice(0,-p.length):a)+"(?:"+p+"(?=$))?"),a+=o?"$":r&&d?"":"(?="+p+"|$)",q(new RegExp("^"+a,L(t)),e)}function N(n,e,t){return E(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return q(n,e)}(n,e):E(n)?function(n,e,t){for(var r=[],o=0;o<n.length;o++)r.push(N(n[o],e,t).source);return q(new RegExp("(?:"+r.join("|")+")",L(t)),e)}(n,e,t):function(n,e,t){return U(F(n,t),e,t)}(n,e,t)}S.parse=P,S.compile=_,S.tokensToFunction=I,S.tokensToRegExp=j;var H=Object.create(null);function W(n,e,t){e=e||{};try{var r=H[n]||(H[n]=S.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function B(n,e,t,r){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var i=(a=o({},n)).params;return i&&"object"==typeof i&&(a.params=o({},i)),a}if(!a.path&&a.params&&e){(a=o({},a))._normalized=!0;var s=o(o({},e.params),a.params);if(e.name)a.name=e.name,a.params=s;else if(e.matched.length){var l=e.matched[e.matched.length-1].path;a.path=W(l,s,e.path)}else 0;return a}var c=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var o=n.indexOf("?");return o>=0&&(t=n.slice(o+1),n=n.slice(0,o)),{path:n,query:t,hash:e}}(a.path||""),u=e&&e.path||"/",m=c.path?C(c.path,u,t||a.append):u,h=function(n,e,t){void 0===e&&(e={});var r,o=t||d;try{r=o(n||"")}catch(n){r={}}for(var a in e){var i=e[a];r[a]=Array.isArray(i)?i.map(p):p(i)}return r}(c.query,a.query,r&&r.options.parseQuery),f=a.hash||c.hash;return f&&"#"!==f.charAt(0)&&(f="#"+f),{_normalized:!0,path:m,query:h,hash:f}}var $,V=function(){},K={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,a=t.resolve(this.to,r,this.append),i=a.location,s=a.route,l=a.href,c={},p=t.options.linkActiveClass,d=t.options.linkExactActiveClass,u=null==p?"router-link-active":p,f=null==d?"router-link-exact-active":d,g=null==this.activeClass?u:this.activeClass,y=null==this.exactActiveClass?f:this.exactActiveClass,b=s.redirectedFrom?h(null,B(s.redirectedFrom),null,t):s;c[y]=v(r,b,this.exactPath),c[g]=this.exact||this.exactPath?c[y]:function(n,e){return 0===n.path.replace(m,"/").indexOf(e.path.replace(m,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,b);var k=c[y]?this.ariaCurrentValue:null,w=function(n){J(n)&&(e.replace?t.replace(i,V):t.push(i,V))},x={click:J};Array.isArray(this.event)?this.event.forEach((function(n){x[n]=w})):x[this.event]=w;var T={class:c},C=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:l,route:s,navigate:w,isActive:c[g],isExactActive:c[y]});if(C){if(1===C.length)return C[0];if(C.length>1||!C.length)return 0===C.length?n():n("span",{},C)}if("a"===this.tag)T.on=x,T.attrs={href:l,"aria-current":k};else{var R=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(R){R.isStatic=!1;var E=R.data=o({},R.data);for(var S in E.on=E.on||{},E.on){var P=E.on[S];S in x&&(E.on[S]=Array.isArray(P)?P:[P])}for(var _ in x)_ in E.on?E.on[_].push(x[_]):E.on[_]=w;var I=R.data.attrs=o({},R.data.attrs);I.href=l,I["aria-current"]=k}else T.on=x}return n(this.tag,T,this.$slots.default)}};function J(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var G="undefined"!=typeof window;function Q(n,e,t,r,o){var a=e||[],i=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,o,a,i){var s=o.path,l=o.name;0;var c=o.pathToRegexpOptions||{},p=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return R(e.path+"/"+n)}(s,a,c.strict);"boolean"==typeof o.caseSensitive&&(c.sensitive=o.caseSensitive);var d={path:p,regex:X(p,c),components:o.components||{default:o.component},alias:o.alias?"string"==typeof o.alias?[o.alias]:o.alias:[],instances:{},enteredCbs:{},name:l,parent:a,matchAs:i,redirect:o.redirect,beforeEnter:o.beforeEnter,meta:o.meta||{},props:null==o.props?{}:o.components?o.props:{default:o.props}};o.children&&o.children.forEach((function(o){var a=i?R(i+"/"+o.path):void 0;n(e,t,r,o,d,a)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==o.alias)for(var u=Array.isArray(o.alias)?o.alias:[o.alias],m=0;m<u.length;++m){0;var h={path:u[m],children:o.children};n(e,t,r,h,a,d.path||"/")}l&&(r[l]||(r[l]=d))}(a,i,s,n,o)}));for(var l=0,c=a.length;l<c;l++)"*"===a[l]&&(a.push(a.splice(l,1)[0]),c--,l--);return{pathList:a,pathMap:i,nameMap:s}}function X(n,e){return S(n,[],e)}function Z(n,e){var t=Q(n),r=t.pathList,o=t.pathMap,a=t.nameMap;function i(n,t,i){var s=B(n,t,!1,e),c=s.name;if(c){var p=a[c];if(!p)return l(null,s);var d=p.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var u in t.params)!(u in s.params)&&d.indexOf(u)>-1&&(s.params[u]=t.params[u]);return s.path=W(p.path,s.params),l(p,s,i)}if(s.path){s.params={};for(var m=0;m<r.length;m++){var h=r[m],f=o[h];if(Y(f.regex,s.path,s.params))return l(f,s,i)}}return l(null,s)}function s(n,t){var r=n.redirect,o="function"==typeof r?r(h(n,t,null,e)):r;if("string"==typeof o&&(o={path:o}),!o||"object"!=typeof o)return l(null,t);var s=o,c=s.name,p=s.path,d=t.query,u=t.hash,m=t.params;if(d=s.hasOwnProperty("query")?s.query:d,u=s.hasOwnProperty("hash")?s.hash:u,m=s.hasOwnProperty("params")?s.params:m,c){a[c];return i({_normalized:!0,name:c,query:d,hash:u,params:m},void 0,t)}if(p){var f=function(n,e){return C(n,e.parent?e.parent.path:"/",!0)}(p,n);return i({_normalized:!0,path:W(f,m),query:d,hash:u},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=i({_normalized:!0,path:W(t,e.params)});if(r){var o=r.matched,a=o[o.length-1];return e.params=r.params,l(a,e)}return l(null,e)}(0,t,n.matchAs):h(n,t,r,e)}return{match:i,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;Q([e||n],r,o,a,t),t&&t.alias.length&&Q(t.alias.map((function(n){return{path:n,children:[e]}})),r,o,a,t)},getRoutes:function(){return r.map((function(n){return o[n]}))},addRoutes:function(n){Q(n,r,o,a)}}}function Y(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var o=1,a=r.length;o<a;++o){var i=n.keys[o-1];i&&(t[i.name||"pathMatch"]="string"==typeof r[o]?c(r[o]):r[o])}return!0}var nn=G&&window.performance&&window.performance.now?window.performance:Date;function en(){return nn.now().toFixed(3)}var tn=en();function rn(){return tn}function on(n){return tn=n}var an=Object.create(null);function sn(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=o({},window.history.state);return t.key=rn(),window.history.replaceState(t,"",e),window.addEventListener("popstate",pn),function(){window.removeEventListener("popstate",pn)}}function ln(n,e,t,r){if(n.app){var o=n.options.scrollBehavior;o&&n.app.$nextTick((function(){var a=function(){var n=rn();if(n)return an[n]}(),i=o.call(n,e,t,r?a:null);i&&("function"==typeof i.then?i.then((function(n){fn(n,a)})).catch((function(n){0})):fn(i,a))}))}}function cn(){var n=rn();n&&(an[n]={x:window.pageXOffset,y:window.pageYOffset})}function pn(n){cn(),n.state&&n.state.key&&on(n.state.key)}function dn(n){return mn(n.x)||mn(n.y)}function un(n){return{x:mn(n.x)?n.x:window.pageXOffset,y:mn(n.y)?n.y:window.pageYOffset}}function mn(n){return"number"==typeof n}var hn=/^#\d/;function fn(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var o=hn.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(o){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(o,a={x:mn((t=a).x)?t.x:0,y:mn(t.y)?t.y:0})}else dn(n)&&(e=un(n))}else r&&dn(n)&&(e=un(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var gn,yn=G&&((-1===(gn=window.navigator.userAgent).indexOf("Android 2.")&&-1===gn.indexOf("Android 4.0")||-1===gn.indexOf("Mobile Safari")||-1!==gn.indexOf("Chrome")||-1!==gn.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function bn(n,e){cn();var t=window.history;try{if(e){var r=o({},t.state);r.key=rn(),t.replaceState(r,"",n)}else t.pushState({key:on(en())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function vn(n){bn(n,!0)}var kn={redirected:2,aborted:4,cancelled:8,duplicated:16};function wn(n,e){return Tn(n,e,kn.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return Cn.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function xn(n,e){return Tn(n,e,kn.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Tn(n,e,t,r){var o=new Error(r);return o._isRouter=!0,o.from=n,o.to=e,o.type=t,o}var Cn=["params","query","hash"];function Rn(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function En(n,e){return Rn(n)&&n._isRouter&&(null==e||n.type===e)}function Sn(n,e,t){var r=function(o){o>=n.length?t():n[o]?e(n[o],(function(){r(o+1)})):r(o+1)};r(0)}function Pn(n){return function(e,t,r){var o=!1,a=0,i=null;_n(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){o=!0,a++;var l,c=On((function(e){var o;((o=e).__esModule||jn&&"Module"===o[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:$.extend(e),t.components[s]=e,--a<=0&&r()})),p=On((function(n){var e="Failed to resolve async component "+s+": "+n;i||(i=Rn(n)?n:new Error(e),r(i))}));try{l=n(c,p)}catch(n){p(n)}if(l)if("function"==typeof l.then)l.then(c,p);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,p)}}})),o||r()}}function _n(n,e){return In(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function In(n){return Array.prototype.concat.apply([],n)}var jn="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function On(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var Fn=function(n,e){this.router=n,this.base=function(n){if(!n)if(G){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=g,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function An(n,e,t,r){var o=_n(n,(function(n,r,o,a){var i=function(n,e){"function"!=typeof n&&(n=$.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,r,o,a)})):t(i,r,o,a)}));return In(r?o.reverse():o)}function Mn(n,e){if(e)return function(){return n.apply(e,arguments)}}Fn.prototype.listen=function(n){this.cb=n},Fn.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Fn.prototype.onError=function(n){this.errorCbs.push(n)},Fn.prototype.transitionTo=function(n,e,t){var r,o=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(r,(function(){o.updateRoute(r),e&&e(r),o.ensureURL(),o.router.afterHooks.forEach((function(n){n&&n(r,a)})),o.ready||(o.ready=!0,o.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!o.ready&&(En(n,kn.redirected)&&a===g||(o.ready=!0,o.readyErrorCbs.forEach((function(e){e(n)}))))}))},Fn.prototype.confirmTransition=function(n,e,t){var r=this,o=this.current;this.pending=n;var a,i,s=function(n){!En(n)&&Rn(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=o.matched.length-1;if(v(n,o)&&l===c&&n.matched[l]===o.matched[c])return this.ensureURL(),n.hash&&ln(this.router,o,n,!1),s(((i=Tn(a=o,n,kn.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",i));var p=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=p.updated,u=p.deactivated,m=p.activated,h=[].concat(function(n){return An(n,"beforeRouteLeave",Mn,!0)}(u),this.router.beforeHooks,function(n){return An(n,"beforeRouteUpdate",Mn)}(d),m.map((function(n){return n.beforeEnter})),Pn(m)),f=function(e,t){if(r.pending!==n)return s(xn(o,n));try{e(n,o,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return Tn(n,e,kn.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(o,n))):Rn(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(wn(o,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};Sn(h,f,(function(){Sn(function(n){return An(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,o,a){return n(r,o,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,r)}))}(m).concat(r.router.resolveHooks),f,(function(){if(r.pending!==n)return s(xn(o,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){w(n)}))}))}))},Fn.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Fn.prototype.setupListeners=function(){},Fn.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=g,this.pending=null};var Dn=function(n){function e(e,t){n.call(this,e,t),this._startLocation=zn(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=yn&&t;r&&this.listeners.push(sn());var o=function(){var t=n.current,o=zn(n.base);n.current===g&&o===n._startLocation||n.transitionTo(o,(function(n){r&&ln(e,n,t,!0)}))};window.addEventListener("popstate",o),this.listeners.push((function(){window.removeEventListener("popstate",o)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){bn(R(r.base+n.fullPath)),ln(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){vn(R(r.base+n.fullPath)),ln(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(zn(this.base)!==this.current.fullPath){var e=R(this.base+this.current.fullPath);n?bn(e):vn(e)}},e.prototype.getCurrentLocation=function(){return zn(this.base)},e}(Fn);function zn(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(R(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var qn=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=zn(n);if(!/^\/#/.test(e))return window.location.replace(R(n+"/#"+e)),!0}(this.base)||Ln()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=yn&&e;t&&this.listeners.push(sn());var r=function(){var e=n.current;Ln()&&n.transitionTo(Un(),(function(r){t&&ln(n.router,r,e,!0),yn||Wn(r.fullPath)}))},o=yn?"popstate":"hashchange";window.addEventListener(o,r),this.listeners.push((function(){window.removeEventListener(o,r)}))}},e.prototype.push=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){Hn(n.fullPath),ln(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){Wn(n.fullPath),ln(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Un()!==e&&(n?Hn(e):Wn(e))},e.prototype.getCurrentLocation=function(){return Un()},e}(Fn);function Ln(){var n=Un();return"/"===n.charAt(0)||(Wn("/"+n),!1)}function Un(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Nn(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Hn(n){yn?bn(Nn(n)):window.location.hash=n}function Wn(n){yn?vn(Nn(n)):window.location.replace(Nn(n))}var Bn=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){En(n,kn.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Fn),$n=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Z(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!yn&&!1!==n.fallback,this.fallback&&(e="hash"),G||(e="abstract"),this.mode=e,e){case"history":this.history=new Dn(this,n.base);break;case"hash":this.history=new qn(this,n.base,this.fallback);break;case"abstract":this.history=new Bn(this,n.base);break;default:0}},Vn={currentRoute:{configurable:!0}};$n.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Vn.currentRoute.get=function(){return this.history&&this.history.current},$n.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Dn||t instanceof qn){var r=function(n){t.setupListeners(),function(n){var r=t.current,o=e.options.scrollBehavior;yn&&o&&"fullPath"in n&&ln(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},$n.prototype.beforeEach=function(n){return Jn(this.beforeHooks,n)},$n.prototype.beforeResolve=function(n){return Jn(this.resolveHooks,n)},$n.prototype.afterEach=function(n){return Jn(this.afterHooks,n)},$n.prototype.onReady=function(n,e){this.history.onReady(n,e)},$n.prototype.onError=function(n){this.history.onError(n)},$n.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},$n.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},$n.prototype.go=function(n){this.history.go(n)},$n.prototype.back=function(){this.go(-1)},$n.prototype.forward=function(){this.go(1)},$n.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},$n.prototype.resolve=function(n,e,t){var r=B(n,e=e||this.history.current,t,this),o=this.match(r,e),a=o.redirectedFrom||o.fullPath;return{location:r,route:o,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?R(n+"/"+r):r}(this.history.base,a,this.mode),normalizedTo:r,resolved:o}},$n.prototype.getRoutes=function(){return this.matcher.getRoutes()},$n.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==g&&this.history.transitionTo(this.history.getCurrentLocation())},$n.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==g&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties($n.prototype,Vn);var Kn=$n;function Jn(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}$n.install=function n(e){if(!n.installed||$!==e){n.installed=!0,$=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",x),e.component("RouterLink",K);var o=e.config.optionMergeStrategies;o.beforeRouteEnter=o.beforeRouteLeave=o.beforeRouteUpdate=o.created}},$n.version="3.6.5",$n.isNavigationFailure=En,$n.NavigationFailureType=kn,$n.START_LOCATION=g,G&&window.Vue&&window.Vue.use($n);t(117);var Gn=t(0),Qn=t(103),Xn=t.n(Qn),Zn=t(104),Yn=t.n(Zn),ne={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${Yn()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=te(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=re(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return Xn()([{name:"description",content:this.$description}],n,this.siteMeta,oe)},updateCanonicalLink(){ee(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",te(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){re(null,this.currentMetaTags),ee()}};function ee(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function te(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function re(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function oe(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var ae=t(57),ie={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ae)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),o=window.innerHeight+t;for(let n=0;n<e.length;n++){const a=e[n],i=e[n+1],s=0===n&&0===t||t>=a.parentElement.offsetTop+10&&(!i||t<i.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(a.hash)){const t=a;if(o===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},se=t(31),le=t.n(se),ce={mounted(){le.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||r.default.component(n.name)||le.a.start(),t()}),this.$router.afterEach(()=>{le.a.done(),this.isSidebarOpen=!1})}};t(251),t(252);class pe{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var de={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new pe).show({text:"",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],o=document.createElement("style");o.type="text/css","top"===t&&r.firstChild?r.insertBefore(o,r.firstChild):r.appendChild(o),o.styleSheet?o.styleSheet.cssText=n:o.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var ue={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},me={},he=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},fe=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:ue[n]},ge=function n(e,t,r){var o=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))o[n]=t[n];else{var e=n.replace("data","");o.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,a=e.children;o.appendChild(n(t,r,a))})),o},ye=function(n,e,t){var r,o=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==o.length||t?o:o[0]},be=function(n,e){var t,r,o=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<template>([\s\S]+)<\/template>/),i=n.match(/<script>([\s\S]+)<\/script>/),s={css:o&&o[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=he(s.html),s.jsTpl=(t=s.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),o=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,a=[eval][0](o);return a.template=e,a}(s.js,s.html);var l=fe("vue");return s.jsLib.unshift(l),s},ve=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),o=n.match(/<html>([\s\S]+)<\/html>/),a=n.match(/<script>([\s\S]+)<\/script>/),i={css:r&&r[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return i.htmlTpl=i.html,i.jsTpl=i.js,i.script=(t=i.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),i},ke=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function we(){var n=ye(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=ye(n,"vuepress-plugin-demo-block__code"),t=ye(n,"vuepress-plugin-demo-block__display"),r=ye(n,"vuepress-plugin-demo-block__footer"),o=ye(t,"vuepress-plugin-demo-block__app"),a=decodeURIComponent(n.dataset.code),i=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);i=i?JSON.parse(i):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),o=new Function("return ".concat(r))(),a={js:o,css:o.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:ke(n),htmlTpl:he("")},i=fe("react"),s=fe("reactDOM");return a.jsLib.unshift(i,s),a}(a,i):"vanilla"===s?ve(a,i):be(a,i),p=ge("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(p),p.addEventListener("click",xe.bind(null,p,l,e,r)),fe("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,o=n.jsLib,a=n.cssLib,i=o.concat(a).concat(fe("cssLib")).concat(fe("jsLib")).join(",");return ge("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:i}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),fe("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,o=n.jsLib,a=n.cssLib,i=JSON.stringify({css:e,html:t,js:r,js_external:o.concat(fe("jsLib")).join(";"),css_external:a.concat(fe("cssLib")).join(";"),layout:fe("codepenLayout"),js_pre_processor:fe("codepenJsProcessor"),editors:fe("codepenEditors")});return ge("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:i}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==i.horizontal?i.horizontal:fe("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var d=e.firstChild.cloneNode(!0);d.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(d)}if(c.css&&function(n){if(!me[n]){var e=ge("style",{innerHTML:n});document.body.appendChild(e),me[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),o);else if("vue"===s){var u=(new(Vue.extend(c.script))).$mount();o.appendChild(u.$el)}else"vanilla"===s&&(o.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){we()}),300)}function xe(n,e,t,r){var o="1"!==n.dataset.isExpand;t.style.height=o?"".concat(e,"px"):0,o?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=o?"1":"0"}var Te={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},we()},updated:function(){we()}},Ce="auto",Re="zoom-in",Ee="zoom-out",Se="grab",Pe="move";function _e(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o={passive:!1};r?n.addEventListener(e,t,o):n.removeEventListener(e,t,o)}function Ie(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function je(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Oe(n,e,t){!function(n){var e=Fe,t=Ae;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var o=n.transform;delete n.transform,n[t]=o}}(e);var r=n.style,o={};for(var a in e)t&&(o[a]=r[a]||""),r[a]=e[a];return o}var Fe="transition",Ae="transform",Me="transform",De="transitionend";var ze=function(){},qe={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:ze,onClose:ze,onGrab:ze,onMove:ze,onRelease:ze,onBeforeOpen:ze,onBeforeClose:ze,onBeforeGrab:ze,onBeforeRelease:ze,onImageLoading:ze,onImageLoaded:ze},Le={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),Ne(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,o=this.lastScrollPosition.y-t,a=this.options.scrollThreshold;(Math.abs(o)>=a||Math.abs(r)>=a)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(Ue(n)&&!Ne(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){Ue(n)&&!Ne(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function Ue(n){return 0===n.button}function Ne(n){return n.metaKey||n.ctrlKey}var He={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Oe(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),_e(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Oe(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},We="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Be=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),$e=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},Ve={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=je(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,o=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Se:Ee,transition:Me+"\n        "+r+"s\n        "+o,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Oe(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Oe(this.el,{transform:"none"})},grab:function(n,e,t){var r=Ke(),o=r.x-n,a=r.y-e;Oe(this.el,{cursor:Pe,transform:"translate3d(\n        "+(this.translate.x+o)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=Ke(),o=r.x-n,a=r.y-e;Oe(this.el,{transition:Me,transform:"translate3d(\n        "+(this.translate.x+o)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Oe(this.el,this.styleClose)},restoreOpenStyle:function(){Oe(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Ke(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,o=r.customSize,a=r.scaleBase;if(!o&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(o&&"object"===(void 0===o?"undefined":We(o)))return{x:o.width/this.rect.width,y:o.height/this.rect.height};var i=this.rect.width/2,s=this.rect.height/2,l=Ke(),c={x:l.x-i,y:l.y-s},p=c.x/i,d=c.y/s,u=a+Math.min(p,d);if(o&&"string"==typeof o){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,f=parseFloat(o)*m/(100*this.rect.width),g=parseFloat(o)*h/(100*this.rect.height);if(u>f||u>g)return{x:f,y:g}}return{x:u,y:u}}};function Ke(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Je(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){_e(n,r,e[r],t)}))}var Ge=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Ve),this.overlay=Object.create(He),this.handler=Object.create(Le),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=$e({},qe,e),this.overlay.init(this),this.handler.init(this)}return Be(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Re,_e(n,"click",this.handler.click),this.options.preloadImage&&Ie(je(n)));return this}},{key:"config",value:function(n){return n?($e(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var o=this.target.srcOriginal;null!=o&&(this.options.onImageLoading(r),Ie(o,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),_e(document,"scroll",this.handler.scroll),_e(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&_e(window,"resize",this.handler.resizeWindow);var a=function n(){_e(r,De,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Je(document,e.handler,!0),t(r)};return _e(r,De,a),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Ce,this.overlay.fadeOut(),this.target.zoomOut(),_e(document,"scroll",this.handler.scroll,!1),_e(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&_e(window,"resize",this.handler.resizeWindow,!1);var r=function r(){_e(t,De,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Je(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return _e(t,De,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var o=this.target.el;this.options.onBeforeGrab(o),this.released=!1,this.target.grab(n,e,t);var a=function n(){_e(o,De,n,!1),r(o)};return _e(o,De,a),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Pe,this.target.move(n,e,t);var o=this.target.el,a=function n(){_e(o,De,n,!1),r(o)};return _e(o,De,a),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Ce,this.target.restoreOpenStyle();var r=function r(){_e(t,De,r,!1),n.lock=!1,n.released=!0,e(t)};return _e(t,De,r),this}}}]),n}();const Qe=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),Xe=Number("500");class Ze{constructor(){this.instance=new Ge(Qe)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=Xe){setTimeout(()=>this.update(n),e)}}var Ye=[ne,ie,ce,de,Te,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new Ze,this.$vuepress.zooming.updateDelay()}}],nt={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return Object(Gn.h)("layout",n),r.default.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},et=t(2),tt=Object(et.a)(nt,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;Object(Gn.f)(tt,"mixins",Ye);const rt=[{name:"v-376508bf",path:"/react/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-376508bf").then(t)}},{path:"/react/index/index.html",redirect:"/react/index/"},{path:"/10.react/0.index.html",redirect:"/react/index/"},{name:"v-3611955d",path:"/react/plan/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3611955d").then(t)}},{path:"/react/plan/index.html",redirect:"/react/plan/"},{path:"/10.react/1.plan.html",redirect:"/react/plan/"},{name:"v-0d7bb8be",path:"/react/basic/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0d7bb8be").then(t)}},{path:"/react/basic/index.html",redirect:"/react/basic/"},{path:"/10.react/10./0.index.html",redirect:"/react/basic/"},{name:"v-359e682f",path:"/react/basic/chapter/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-359e682f").then(t)}},{path:"/react/basic/chapter/index.html",redirect:"/react/basic/chapter/"},{path:"/10.react/10./10.chapter.html",redirect:"/react/basic/chapter/"},{name:"v-a1dbc2a2",path:"/react/basic/faq/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-a1dbc2a2").then(t)}},{path:"/react/basic/faq/index.html",redirect:"/react/basic/faq/"},{path:"/10.react/10./20.faq.html",redirect:"/react/basic/faq/"},{name:"v-406c3962",path:"/react/basic/children/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-406c3962").then(t)}},{path:"/react/basic/children/index.html",redirect:"/react/basic/children/"},{path:"/10.react/10./30.ReactChildren.html",redirect:"/react/basic/children/"},{name:"v-4b4b48ab",path:"/react/basic/element/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4b4b48ab").then(t)}},{path:"/react/basic/element/index.html",redirect:"/react/basic/element/"},{path:"/10.react/10./40.ReactElement.html",redirect:"/react/basic/element/"},{name:"v-4d309ab6",path:"/react/reconciliation/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4d309ab6").then(t)}},{path:"/react/reconciliation/index/index.html",redirect:"/react/reconciliation/index/"},{path:"/10.react/20.Reconciliation/0.index.html",redirect:"/react/reconciliation/index/"},{name:"v-1a05c896",path:"/react/reconciliation/fiber/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1a05c896").then(t)}},{path:"/react/reconciliation/fiber/index.html",redirect:"/react/reconciliation/fiber/"},{path:"/10.react/20.Reconciliation/10.fiber.html",redirect:"/react/reconciliation/fiber/"},{name:"v-27daf196",path:"/react/reconciliation/reactChildFiber/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-27daf196").then(t)}},{path:"/react/reconciliation/reactChildFiber/index.html",redirect:"/react/reconciliation/reactChildFiber/"},{path:"/10.react/20.Reconciliation/20.reactChildFiber.html",redirect:"/react/reconciliation/reactChildFiber/"},{name:"v-e4ff14f8",path:"/react/reconciliation/expirationTime/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-e4ff14f8").then(t)}},{path:"/react/reconciliation/expirationTime/index.html",redirect:"/react/reconciliation/expirationTime/"},{path:"/10.react/20.Reconciliation/30.expirationTime.html",redirect:"/react/reconciliation/expirationTime/"},{name:"v-1daf77ea",path:"/react/reconciliation/scheduleWork/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1daf77ea").then(t)}},{path:"/react/reconciliation/scheduleWork/index.html",redirect:"/react/reconciliation/scheduleWork/"},{path:"/10.react/20.Reconciliation/40.scheduleWork.html",redirect:"/react/reconciliation/scheduleWork/"},{name:"v-7050b2a0",path:"/react/reconciliation/lane/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7050b2a0").then(t)}},{path:"/react/reconciliation/lane/index.html",redirect:"/react/reconciliation/lane/"},{path:"/10.react/20.Reconciliation/50.lane.html",redirect:"/react/reconciliation/lane/"},{name:"v-41adcea0",path:"/react/scheduler/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-41adcea0").then(t)}},{path:"/react/scheduler/index/index.html",redirect:"/react/scheduler/index/"},{path:"/10.react/30.Scheduler/0.index.html",redirect:"/react/scheduler/index/"},{name:"v-a7e4381c",path:"/react/scheduler/scheduleCallback/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-a7e4381c").then(t)}},{path:"/react/scheduler/scheduleCallback/index.html",redirect:"/react/scheduler/scheduleCallback/"},{path:"/10.react/30.Scheduler/10.scheduleCallback.html",redirect:"/react/scheduler/scheduleCallback/"},{name:"v-fefa4114",path:"/react/scheduler/schedulerHostConfig/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-fefa4114").then(t)}},{path:"/react/scheduler/schedulerHostConfig/index.html",redirect:"/react/scheduler/schedulerHostConfig/"},{path:"/10.react/30.Scheduler/20.schedulerHostConfig.html",redirect:"/react/scheduler/schedulerHostConfig/"},{name:"v-21473796",path:"/react/scheduler/scheduler/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-21473796").then(t)}},{path:"/react/scheduler/scheduler/index.html",redirect:"/react/scheduler/scheduler/"},{path:"/10.react/30.Scheduler/30.scheduler.html",redirect:"/react/scheduler/scheduler/"},{name:"v-492f4a82",path:"/react/updater/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-492f4a82").then(t)}},{path:"/react/updater/index/index.html",redirect:"/react/updater/index/"},{path:"/10.react/40.Updater/0.index.html",redirect:"/react/updater/index/"},{name:"v-1d8100c2",path:"/react/updater/workloop/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1d8100c2").then(t)}},{path:"/react/updater/workloop/index.html",redirect:"/react/updater/workloop/"},{path:"/10.react/40.Updater/10.workloop.html",redirect:"/react/updater/workloop/"},{name:"v-fcc2e96a",path:"/react/render/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-fcc2e96a").then(t)}},{path:"/react/render/index/index.html",redirect:"/react/render/index/"},{path:"/10.react/50.Render/0.index.html",redirect:"/react/render/index/"},{name:"v-36e6278b",path:"/react/render/render/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-36e6278b").then(t)}},{path:"/react/render/render/index.html",redirect:"/react/render/render/"},{path:"/10.react/50.Render/10.ReactDOM.html",redirect:"/react/render/render/"},{name:"v-0fd7e2db",path:"/react/hooks/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0fd7e2db").then(t)}},{path:"/react/hooks/index/index.html",redirect:"/react/hooks/index/"},{path:"/10.react/70.hooks/0.index.html",redirect:"/react/hooks/index/"},{name:"v-fda4440a",path:"/react/hooks/useState/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-fda4440a").then(t)}},{path:"/react/hooks/useState/index.html",redirect:"/react/hooks/useState/"},{path:"/10.react/70.hooks/10.useState.html",redirect:"/react/hooks/useState/"},{name:"v-228419df",path:"/react/hooks/useEffect/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-228419df").then(t)}},{path:"/react/hooks/useEffect/index.html",redirect:"/react/hooks/useEffect/"},{path:"/10.react/70.hooks/20.useEffect.html",redirect:"/react/hooks/useEffect/"},{name:"v-2778a33b",path:"/react/hooks/useRef/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2778a33b").then(t)}},{path:"/react/hooks/useRef/index.html",redirect:"/react/hooks/useRef/"},{path:"/10.react/70.hooks/30.useRef.html",redirect:"/react/hooks/useRef/"},{name:"v-230de106",path:"/react/summary/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-230de106").then(t)}},{path:"/react/summary/index/index.html",redirect:"/react/summary/index/"},{path:"/10.react/80./0.index.html",redirect:"/react/summary/index/"},{name:"v-1154a3c8",path:"/react/summary/bitOperation/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1154a3c8").then(t)}},{path:"/react/summary/bitOperation/index.html",redirect:"/react/summary/bitOperation/"},{path:"/10.react/80./10.bitOperation.html",redirect:"/react/summary/bitOperation/"},{name:"v-35203ba8",path:"/react/summary/first-render/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-35203ba8").then(t)}},{path:"/react/summary/first-render/index.html",redirect:"/react/summary/first-render/"},{path:"/10.react/80./20.first-render.html",redirect:"/react/summary/first-render/"},{name:"v-59f008fe",path:"/react/summary/event-listener/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-59f008fe").then(t)}},{path:"/react/summary/event-listener/index.html",redirect:"/react/summary/event-listener/"},{path:"/10.react/80./30.event-listener.html",redirect:"/react/summary/event-listener/"},{name:"v-5de90ac4",path:"/react/summary/10-min-react/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5de90ac4").then(t)}},{path:"/react/summary/10-min-react/index.html",redirect:"/react/summary/10-min-react/"},{path:"/10.react/80./40.10-min-react.html",redirect:"/react/summary/10-min-react/"},{name:"v-071d800b",path:"/react/tour/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-071d800b").then(t)}},{path:"/react/tour/index/index.html",redirect:"/react/tour/index/"},{path:"/10.react/90.React/0.index.html",redirect:"/react/tour/index/"},{name:"v-7532101f",path:"/react/tour/plan/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7532101f").then(t)}},{path:"/react/tour/plan/index.html",redirect:"/react/tour/plan/"},{path:"/10.react/90.React/1.Plan.html",redirect:"/react/tour/plan/"},{name:"v-05b01242",path:"/react/tour/react-basic-element/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-05b01242").then(t)}},{path:"/react/tour/react-basic-element/index.html",redirect:"/react/tour/react-basic-element/"},{path:"/10.react/90.React/10.react-basic-element.html",redirect:"/react/tour/react-basic-element/"},{name:"v-1e97eeff",path:"/react/tour/react-reconciliation-2/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1e97eeff").then(t)}},{path:"/react/tour/react-reconciliation-2/index.html",redirect:"/react/tour/react-reconciliation-2/"},{path:"/10.react/90.React/100.react-reconciliation-2.html",redirect:"/react/tour/react-reconciliation-2/"},{name:"v-5962efbf",path:"/react/tour/react-reconciliation-3/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5962efbf").then(t)}},{path:"/react/tour/react-reconciliation-3/index.html",redirect:"/react/tour/react-reconciliation-3/"},{path:"/10.react/90.React/110.react-reconciliation-3.html",redirect:"/react/tour/react-reconciliation-3/"},{name:"v-d7a41f02",path:"/react/tour/react-reconciliation-4/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-d7a41f02").then(t)}},{path:"/react/tour/react-reconciliation-4/index.html",redirect:"/react/tour/react-reconciliation-4/"},{path:"/10.react/90.React/120.react-reconciliation-4.html",redirect:"/react/tour/react-reconciliation-4/"},{name:"v-620e1d82",path:"/react/tour/react-reconciliation-5/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-620e1d82").then(t)}},{path:"/react/tour/react-reconciliation-5/index.html",redirect:"/react/tour/react-reconciliation-5/"},{path:"/10.react/90.React/130.react-reconciliation-5.html",redirect:"/react/tour/react-reconciliation-5/"},{name:"v-09c3f1ff",path:"/react/tour/react-reconciliation-6/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-09c3f1ff").then(t)}},{path:"/react/tour/react-reconciliation-6/index.html",redirect:"/react/tour/react-reconciliation-6/"},{path:"/10.react/90.React/140.react-reconciliation-6.html",redirect:"/react/tour/react-reconciliation-6/"},{name:"v-448ef2bf",path:"/react/tour/react-reconciliation-7/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-448ef2bf").then(t)}},{path:"/react/tour/react-reconciliation-7/index.html",redirect:"/react/tour/react-reconciliation-7/"},{path:"/10.react/90.React/150.react-reconciliation-7.html",redirect:"/react/tour/react-reconciliation-7/"},{name:"v-7f59f37f",path:"/react/tour/react-reconciliation-8/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7f59f37f").then(t)}},{path:"/react/tour/react-reconciliation-8/index.html",redirect:"/react/tour/react-reconciliation-8/"},{path:"/10.react/90.React/160.react-reconciliation-8.html",redirect:"/react/tour/react-reconciliation-8/"},{name:"v-8bb61782",path:"/react/tour/react-reconciliation-9/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-8bb61782").then(t)}},{path:"/react/tour/react-reconciliation-9/index.html",redirect:"/react/tour/react-reconciliation-9/"},{path:"/10.react/90.React/170.react-reconciliation-9.html",redirect:"/react/tour/react-reconciliation-9/"},{name:"v-4079c547",path:"/react/tour/react-reconciliation-10/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4079c547").then(t)}},{path:"/react/tour/react-reconciliation-10/index.html",redirect:"/react/tour/react-reconciliation-10/"},{path:"/10.react/90.React/180.react-reconciliation-10.html",redirect:"/react/tour/react-reconciliation-10/"},{name:"v-5585c5df",path:"/react/tour/talk/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5585c5df").then(t)}},{path:"/react/tour/talk/index.html",redirect:"/react/tour/talk/"},{path:"/10.react/90.React/2.talk.html",redirect:"/react/tour/talk/"},{name:"v-50140a3b",path:"/react/tour/react-basic-children/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-50140a3b").then(t)}},{path:"/react/tour/react-basic-children/index.html",redirect:"/react/tour/react-basic-children/"},{path:"/10.react/90.React/20.react-basic-children.html",redirect:"/react/tour/react-basic-children/"},{name:"v-ec07c126",path:"/react/tour/react-basic-glimpse/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-ec07c126").then(t)}},{path:"/react/tour/react-basic-glimpse/index.html",redirect:"/react/tour/react-basic-glimpse/"},{path:"/10.react/90.React/30.react-basic-view.html",redirect:"/react/tour/react-basic-glimpse/"},{name:"v-2d7c6c07",path:"/react/tour/react-scheduler-1/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2d7c6c07").then(t)}},{path:"/react/tour/react-scheduler-1/index.html",redirect:"/react/tour/react-scheduler-1/"},{path:"/10.react/90.React/300.react-scheduler-1.html",redirect:"/react/tour/react-scheduler-1/"},{name:"v-49f7f4ca",path:"/react/tour/react-reconciliation-1/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-49f7f4ca").then(t)}},{path:"/react/tour/react-reconciliation-1/index.html",redirect:"/react/tour/react-reconciliation-1/"},{path:"/10.react/90.React/90.react-reconciliation-1.html",redirect:"/react/tour/react-reconciliation-1/"},{name:"v-321a8dff",path:"/react/tour/dr-1/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-321a8dff").then(t)}},{path:"/react/tour/dr-1/index.html",redirect:"/react/tour/dr-1/"},{path:"/10.react/90.React/900.react-docs-reading-1.html",redirect:"/react/tour/dr-1/"},{name:"v-2e216f3f",path:"/react/tour/dr-2/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2e216f3f").then(t)}},{path:"/react/tour/dr-2/index.html",redirect:"/react/tour/dr-2/"},{path:"/10.react/90.React/910.react-docs-reading-2.html",redirect:"/react/tour/dr-2/"},{name:"v-1d06307d",path:"/vue3/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1d06307d").then(t)}},{path:"/vue3/index/index.html",redirect:"/vue3/index/"},{path:"/20.vue3/0.index.html",redirect:"/vue3/index/"},{name:"v-cecea10e",path:"/vue3/plan/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-cecea10e").then(t)}},{path:"/vue3/plan/index.html",redirect:"/vue3/plan/"},{path:"/20.vue3/1.plan.html",redirect:"/vue3/plan/"},{name:"v-620539aa",path:"/vue3/basic/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-620539aa").then(t)}},{path:"/vue3/basic/index/index.html",redirect:"/vue3/basic/index/"},{path:"/20.vue3/10./0.index.html",redirect:"/vue3/basic/index/"},{name:"v-5d322c1d",path:"/vue3/reactivity/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5d322c1d").then(t)}},{path:"/vue3/reactivity/index/index.html",redirect:"/vue3/reactivity/index/"},{path:"/20.vue3/20.reactivity/0.index.html",redirect:"/vue3/reactivity/index/"},{name:"v-dcaaef7a",path:"/vue3/reactivity/ref/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-dcaaef7a").then(t)}},{path:"/vue3/reactivity/ref/index.html",redirect:"/vue3/reactivity/ref/"},{path:"/20.vue3/20.reactivity/10.ref.html",redirect:"/vue3/reactivity/ref/"},{name:"v-4d69bd7d",path:"/vue3/basic/reactive/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4d69bd7d").then(t)}},{path:"/vue3/basic/reactive/index.html",redirect:"/vue3/basic/reactive/"},{path:"/20.vue3/20.reactivity/20.reactive.html",redirect:"/vue3/basic/reactive/"},{name:"v-eea5a8ce",path:"/vue3/basic/handler/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-eea5a8ce").then(t)}},{path:"/vue3/basic/handler/index.html",redirect:"/vue3/basic/handler/"},{path:"/20.vue3/20.reactivity/30.handler.html",redirect:"/vue3/basic/handler/"},{name:"v-7c3809bd",path:"/vue3/basic/effect/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7c3809bd").then(t)}},{path:"/vue3/basic/effect/index.html",redirect:"/vue3/basic/effect/"},{path:"/20.vue3/20.reactivity/40.effect.html",redirect:"/vue3/basic/effect/"},{name:"v-47f301c6",path:"/vue3/basic/computed/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-47f301c6").then(t)}},{path:"/vue3/basic/computed/index.html",redirect:"/vue3/basic/computed/"},{path:"/20.vue3/20.reactivity/50.computed.html",redirect:"/vue3/basic/computed/"},{name:"v-7844a83d",path:"/vue3/runtime-core/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7844a83d").then(t)}},{path:"/vue3/runtime-core/index/index.html",redirect:"/vue3/runtime-core/index/"},{path:"/20.vue3/30.runtime-core/0.index.html",redirect:"/vue3/runtime-core/index/"},{name:"v-847c1376",path:"/vue3/runtime-dom/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-847c1376").then(t)}},{path:"/vue3/runtime-dom/index/index.html",redirect:"/vue3/runtime-dom/index/"},{path:"/20.vue3/40.runtime-dom/0.index.html",redirect:"/vue3/runtime-dom/index/"},{name:"v-36768879",path:"/vue3/runtime-dom/apiCreateApp/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-36768879").then(t)}},{path:"/vue3/runtime-dom/apiCreateApp/index.html",redirect:"/vue3/runtime-dom/apiCreateApp/"},{path:"/20.vue3/40.runtime-dom/10.apiCreateApp.html",redirect:"/vue3/runtime-dom/apiCreateApp/"},{name:"v-af98cc06",path:"/vue3/runtime-dom/apiDefineComponent/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-af98cc06").then(t)}},{path:"/vue3/runtime-dom/apiDefineComponent/index.html",redirect:"/vue3/runtime-dom/apiDefineComponent/"},{path:"/20.vue3/40.runtime-dom/20.apiDefineComponent.html",redirect:"/vue3/runtime-dom/apiDefineComponent/"},{name:"v-7b4d74fd",path:"/pages/286896/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7b4d74fd").then(t)}},{path:"/pages/286896/index.html",redirect:"/pages/286896/"},{path:"/20.vue3/40.runtime-dom/90.scheduler.html",redirect:"/pages/286896/"},{name:"v-50e647d9",path:"/web/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-50e647d9").then(t)}},{path:"/web/index/index.html",redirect:"/web/index/"},{path:"/30.web/0.index.html",redirect:"/web/index/"},{name:"v-26e7ba7d",path:"/web/plan/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-26e7ba7d").then(t)}},{path:"/web/plan/index.html",redirect:"/web/plan/"},{path:"/30.web/1.plan.html",redirect:"/web/plan/"},{name:"v-566737cd",path:"/vite/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-566737cd").then(t)}},{path:"/vite/index/index.html",redirect:"/vite/index/"},{path:"/30.web/10.vite/0.index.html",redirect:"/vite/index/"},{name:"v-6e8687a2",path:"/vite/basic/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6e8687a2").then(t)}},{path:"/vite/basic/index/index.html",redirect:"/vite/basic/index/"},{path:"/30.web/10.vite/10./0.index.html",redirect:"/vite/basic/index/"},{name:"v-7373c0fa",path:"/vite/core/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7373c0fa").then(t)}},{path:"/vite/core/index/index.html",redirect:"/vite/core/index/"},{path:"/30.web/10.vite/20.vite/0.index.html",redirect:"/vite/core/index/"},{name:"v-55a8d0bf",path:"/vite/core/cli/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-55a8d0bf").then(t)}},{path:"/vite/core/cli/index.html",redirect:"/vite/core/cli/"},{path:"/30.web/10.vite/20.vite/10.cli.html",redirect:"/vite/core/cli/"},{name:"v-18766245",path:"/vite/core/server/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-18766245").then(t)}},{path:"/vite/core/server/index.html",redirect:"/vite/core/server/"},{path:"/30.web/10.vite/20.vite/20.server.html",redirect:"/vite/core/server/"},{name:"v-53f20ec6",path:"/express/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-53f20ec6").then(t)}},{path:"/express/index/index.html",redirect:"/express/index/"},{path:"/30.web/160.express/0.index.html",redirect:"/express/index/"},{name:"v-4bc33869",path:"/acorn/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4bc33869").then(t)}},{path:"/acorn/index/index.html",redirect:"/acorn/index/"},{path:"/30.web/170.acorn/0.index.html",redirect:"/acorn/index/"},{name:"v-687541db",path:"/immutable/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-687541db").then(t)}},{path:"/immutable/index/index.html",redirect:"/immutable/index/"},{path:"/30.web/180.immutable.js/0.index.html",redirect:"/immutable/index/"},{name:"v-6414adc6",path:"/ts/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6414adc6").then(t)}},{path:"/ts/index/index.html",redirect:"/ts/index/"},{path:"/30.web/4.typescript-utility/0.index.html",redirect:"/ts/index/"},{name:"v-2985970b",path:"/ts/basic/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2985970b").then(t)}},{path:"/ts/basic/index/index.html",redirect:"/ts/basic/index/"},{path:"/30.web/4.typescript-utility/10./0.index.html",redirect:"/ts/basic/index/"},{name:"v-aef55d32",path:"/ts/basic/basic-types/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-aef55d32").then(t)}},{path:"/ts/basic/basic-types/index.html",redirect:"/ts/basic/basic-types/"},{path:"/30.web/4.typescript-utility/10./10.basic-types.html",redirect:"/ts/basic/basic-types/"},{name:"v-25439586",path:"/ts/basic/type-manipulation/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-25439586").then(t)}},{path:"/ts/basic/type-manipulation/index.html",redirect:"/ts/basic/type-manipulation/"},{path:"/30.web/4.typescript-utility/10./20.type-manipulation.html",redirect:"/ts/basic/type-manipulation/"},{name:"v-27eebe53",path:"/ts/basic/classes/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-27eebe53").then(t)}},{path:"/ts/basic/classes/index.html",redirect:"/ts/basic/classes/"},{path:"/30.web/4.typescript-utility/10./30.classes.html",redirect:"/ts/basic/classes/"},{name:"v-2080504b",path:"/ts/basic/reference/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2080504b").then(t)}},{path:"/ts/basic/reference/index.html",redirect:"/ts/basic/reference/"},{path:"/30.web/4.typescript-utility/10./40.reference.html",redirect:"/ts/basic/reference/"},{name:"v-057781cb",path:"/ts/basic/type-zoo/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-057781cb").then(t)}},{path:"/ts/basic/type-zoo/index.html",redirect:"/ts/basic/type-zoo/"},{path:"/30.web/4.typescript-utility/10./50.type-zoo.html",redirect:"/ts/basic/type-zoo/"},{name:"v-2af34dca",path:"/ts/utility/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2af34dca").then(t)}},{path:"/ts/utility/index/index.html",redirect:"/ts/utility/index/"},{path:"/30.web/4.typescript-utility/20./0.index.html",redirect:"/ts/utility/index/"},{name:"v-f790ca6e",path:"/ts/utility/basic/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-f790ca6e").then(t)}},{path:"/ts/utility/basic/index.html",redirect:"/ts/utility/basic/"},{path:"/30.web/4.typescript-utility/20./10.basic.html",redirect:"/ts/utility/basic/"},{name:"v-1061317b",path:"/ts/utility/mapped/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1061317b").then(t)}},{path:"/ts/utility/mapped/index.html",redirect:"/ts/utility/mapped/"},{path:"/30.web/4.typescript-utility/20./20.mapped-types.html",redirect:"/ts/utility/mapped/"},{name:"v-1ba4b31b",path:"/single-spa/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1ba4b31b").then(t)}},{path:"/single-spa/index/index.html",redirect:"/single-spa/index/"},{path:"/30.web/5.single-spa/0.index.html",redirect:"/single-spa/index/"},{name:"v-6b7f390c",path:"/single-spa/app/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6b7f390c").then(t)}},{path:"/single-spa/app/index/index.html",redirect:"/single-spa/app/index/"},{path:"/30.web/5.single-spa/10.app/0.index.html",redirect:"/single-spa/app/index/"},{name:"v-3bded94c",path:"/single-spa/app/apps/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3bded94c").then(t)}},{path:"/single-spa/app/apps/index.html",redirect:"/single-spa/app/apps/"},{path:"/30.web/5.single-spa/10.app/10.apps.html",redirect:"/single-spa/app/apps/"},{name:"v-0b29f556",path:"/single-spa/lifecycle/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0b29f556").then(t)}},{path:"/single-spa/lifecycle/index/index.html",redirect:"/single-spa/lifecycle/index/"},{path:"/30.web/5.single-spa/20.lifecycles/0.index.html",redirect:"/single-spa/lifecycle/index/"},{name:"v-70bd8ed4",path:"/single-spa/lifecycle/load/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-70bd8ed4").then(t)}},{path:"/single-spa/lifecycle/load/index.html",redirect:"/single-spa/lifecycle/load/"},{path:"/30.web/5.single-spa/20.lifecycles/10.load.html",redirect:"/single-spa/lifecycle/load/"},{name:"v-5cc090d4",path:"/single-spa/lifecycle/bootstrap/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5cc090d4").then(t)}},{path:"/single-spa/lifecycle/bootstrap/index.html",redirect:"/single-spa/lifecycle/bootstrap/"},{path:"/30.web/5.single-spa/20.lifecycles/20.bootstrap.html",redirect:"/single-spa/lifecycle/bootstrap/"},{name:"v-4dfd12d8",path:"/single-spa/lifecycle/mount/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4dfd12d8").then(t)}},{path:"/single-spa/lifecycle/mount/index.html",redirect:"/single-spa/lifecycle/mount/"},{path:"/30.web/5.single-spa/20.lifecycles/30.mount.html",redirect:"/single-spa/lifecycle/mount/"},{name:"v-3336f808",path:"/single-spa/lifecycle/update/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3336f808").then(t)}},{path:"/single-spa/lifecycle/update/index.html",redirect:"/single-spa/lifecycle/update/"},{path:"/30.web/5.single-spa/20.lifecycles/40.update.html",redirect:"/single-spa/lifecycle/update/"},{name:"v-3bd3e459",path:"/single-spa/nav/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3bd3e459").then(t)}},{path:"/single-spa/nav/index/index.html",redirect:"/single-spa/nav/index/"},{path:"/30.web/5.single-spa/30.navigation/0.index.html",redirect:"/single-spa/nav/index/"},{name:"v-3bb59422",path:"/single-spa/nav/events/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3bb59422").then(t)}},{path:"/single-spa/nav/events/index.html",redirect:"/single-spa/nav/events/"},{path:"/30.web/5.single-spa/30.navigation/10.navigation-events.html",redirect:"/single-spa/nav/events/"},{name:"v-44bace4f",path:"/single-spa/nav/reroute/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-44bace4f").then(t)}},{path:"/single-spa/nav/reroute/index.html",redirect:"/single-spa/nav/reroute/"},{path:"/30.web/5.single-spa/30.navigation/20.reroute.html",redirect:"/single-spa/nav/reroute/"},{name:"v-73517018",path:"/single-spa/nav/parcel/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-73517018").then(t)}},{path:"/single-spa/nav/parcel/index.html",redirect:"/single-spa/nav/parcel/"},{path:"/30.web/5.single-spa/40.parcel/0.index.html",redirect:"/single-spa/nav/parcel/"},{name:"v-db70af54",path:"/single-spa/other/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-db70af54").then(t)}},{path:"/single-spa/other/index/index.html",redirect:"/single-spa/other/index/"},{path:"/30.web/5.single-spa/50./0.index.html",redirect:"/single-spa/other/index/"},{name:"v-e148fee0",path:"/single-spa/other/customEvent/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-e148fee0").then(t)}},{path:"/single-spa/other/customEvent/index.html",redirect:"/single-spa/other/customEvent/"},{path:"/30.web/5.single-spa/50./10.customEvent.html",redirect:"/single-spa/other/customEvent/"},{name:"v-6644dbd4",path:"/single-spa/other/error/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6644dbd4").then(t)}},{path:"/single-spa/other/error/index.html",redirect:"/single-spa/other/error/"},{path:"/30.web/5.single-spa/50./20.error.html",redirect:"/single-spa/other/error/"},{name:"v-1bd41a5b",path:"/single-spa/spa-react/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1bd41a5b").then(t)}},{path:"/single-spa/spa-react/index/index.html",redirect:"/single-spa/spa-react/index/"},{path:"/30.web/5.single-spa/60.single-spa-react/0.index.html",redirect:"/single-spa/spa-react/index/"},{name:"v-82122182",path:"/jquery/jq-book/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-82122182").then(t)}},{path:"/jquery/jq-book/index.html",redirect:"/jquery/jq-book/"},{path:"/30.web/50.jquery/10.jq-book.html",redirect:"/jquery/jq-book/"},{name:"v-1401de91",path:"/jquery/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1401de91").then(t)}},{path:"/jquery/index/index.html",redirect:"/jquery/index/"},{path:"/30.web/50.jquery/0.index.html",redirect:"/jquery/index/"},{name:"v-1ff4e09f",path:"/jquery/jq-source/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1ff4e09f").then(t)}},{path:"/jquery/jq-source/index.html",redirect:"/jquery/jq-source/"},{path:"/30.web/50.jquery/20.jq-source.html",redirect:"/jquery/jq-source/"},{name:"v-f54ae5ba",path:"/jquery/extend/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-f54ae5ba").then(t)}},{path:"/jquery/extend/index.html",redirect:"/jquery/extend/"},{path:"/30.web/50.jquery/30.extend.html",redirect:"/jquery/extend/"},{name:"v-52bd35e5",path:"/qiankun/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-52bd35e5").then(t)}},{path:"/qiankun/index/index.html",redirect:"/qiankun/index/"},{path:"/30.web/6.qiankun/0.index.html",redirect:"/qiankun/index/"},{name:"v-7c668ae7",path:"/qiankun/core/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7c668ae7").then(t)}},{path:"/qiankun/core/index/index.html",redirect:"/qiankun/core/index/"},{path:"/30.web/6.qiankun/10.core/0.index.html",redirect:"/qiankun/core/index/"},{name:"v-6e596402",path:"/qiankun/core/apis/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6e596402").then(t)}},{path:"/qiankun/core/apis/index.html",redirect:"/qiankun/core/apis/"},{path:"/30.web/6.qiankun/10.core/10.apis.html",redirect:"/qiankun/core/apis/"},{name:"v-263cdfff",path:"/qiankun/core/globalState/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-263cdfff").then(t)}},{path:"/qiankun/core/globalState/index.html",redirect:"/qiankun/core/globalState/"},{path:"/30.web/6.qiankun/10.core/50.globalState.html",redirect:"/qiankun/core/globalState/"},{name:"v-6646936e",path:"/qiankun/core/loader/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6646936e").then(t)}},{path:"/qiankun/core/loader/index.html",redirect:"/qiankun/core/loader/"},{path:"/30.web/6.qiankun/10.core/20.loader.html",redirect:"/qiankun/core/loader/"},{name:"v-4956ba5f",path:"/qiankun/core/addon/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4956ba5f").then(t)}},{path:"/qiankun/core/addon/index.html",redirect:"/qiankun/core/addon/"},{path:"/30.web/6.qiankun/10.core/60.addon.html",redirect:"/qiankun/core/addon/"},{name:"v-a0fcd902",path:"/qiankun/sandbox/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-a0fcd902").then(t)}},{path:"/qiankun/sandbox/index/index.html",redirect:"/qiankun/sandbox/index/"},{path:"/30.web/6.qiankun/20.sandbox/0.index.html",redirect:"/qiankun/sandbox/index/"},{name:"v-b7416126",path:"/qiankun/sandbox/sandbox/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-b7416126").then(t)}},{path:"/qiankun/sandbox/sandbox/index.html",redirect:"/qiankun/sandbox/sandbox/"},{path:"/30.web/6.qiankun/20.sandbox/10.sandbox.html",redirect:"/qiankun/sandbox/sandbox/"},{name:"v-353fcddf",path:"/qiankun/sandbox/proxySandbox/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-353fcddf").then(t)}},{path:"/qiankun/sandbox/proxySandbox/index.html",redirect:"/qiankun/sandbox/proxySandbox/"},{path:"/30.web/6.qiankun/20.sandbox/20.proxySandbox.html",redirect:"/qiankun/sandbox/proxySandbox/"},{name:"v-33490a39",path:"/qiankun/sandbox/snapshotSandbox/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-33490a39").then(t)}},{path:"/qiankun/sandbox/snapshotSandbox/index.html",redirect:"/qiankun/sandbox/snapshotSandbox/"},{path:"/30.web/6.qiankun/20.sandbox/30.snapshotSandbox.html",redirect:"/qiankun/sandbox/snapshotSandbox/"},{name:"v-51af4a72",path:"/qiankun/import-html-entry/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-51af4a72").then(t)}},{path:"/qiankun/import-html-entry/index.html",redirect:"/qiankun/import-html-entry/"},{path:"/30.web/6.qiankun/999.import-html-entry.html",redirect:"/qiankun/import-html-entry/"},{name:"v-07fff7d7",path:"/pages/ba82e2/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-07fff7d7").then(t)}},{path:"/pages/ba82e2/index.html",redirect:"/pages/ba82e2/"},{path:"/30.web/60.snabbdom/0.index.html",redirect:"/pages/ba82e2/"},{name:"v-725a2703",path:"/pages/cf8075/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-725a2703").then(t)}},{path:"/pages/cf8075/index.html",redirect:"/pages/cf8075/"},{path:"/30.web/60.snabbdom/10.core/10.init.html",redirect:"/pages/cf8075/"},{name:"v-ca971886",path:"/pages/69bbdd/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-ca971886").then(t)}},{path:"/pages/69bbdd/index.html",redirect:"/pages/69bbdd/"},{path:"/30.web/60.snabbdom/10.core/20.h.html",redirect:"/pages/69bbdd/"},{name:"v-6892877d",path:"/pages/fa7d5d/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6892877d").then(t)}},{path:"/pages/fa7d5d/index.html",redirect:"/pages/fa7d5d/"},{path:"/30.web/60.snabbdom/10.core/30.jsx.html",redirect:"/pages/fa7d5d/"},{name:"v-d23fd306",path:"/pages/3f1101/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-d23fd306").then(t)}},{path:"/pages/3f1101/index.html",redirect:"/pages/3f1101/"},{path:"/30.web/60.snabbdom/10.core/40.vnode.html",redirect:"/pages/3f1101/"},{name:"v-210aaa1d",path:"/pages/d02874/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-210aaa1d").then(t)}},{path:"/pages/d02874/index.html",redirect:"/pages/d02874/"},{path:"/30.web/60.snabbdom/10.core/50.thunk.html",redirect:"/pages/d02874/"},{name:"v-377700fe",path:"/pages/903ddd/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-377700fe").then(t)}},{path:"/pages/903ddd/index.html",redirect:"/pages/903ddd/"},{path:"/30.web/60.snabbdom/30.helper/10.attachto.html",redirect:"/pages/903ddd/"},{name:"v-405fbd6a",path:"/webpack/init/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-405fbd6a").then(t)}},{path:"/webpack/init/index.html",redirect:"/webpack/init/"},{path:"/30.web/7.webpack/0.index.html",redirect:"/webpack/init/"},{name:"v-761f238a",path:"/webpack/tapable/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-761f238a").then(t)}},{path:"/webpack/tapable/index/index.html",redirect:"/webpack/tapable/index/"},{path:"/30.web/7.webpack/10.tapable/0.index.html",redirect:"/webpack/tapable/index/"},{name:"v-c3847a42",path:"/webpack/tapable/api/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-c3847a42").then(t)}},{path:"/webpack/tapable/api/index.html",redirect:"/webpack/tapable/api/"},{path:"/30.web/7.webpack/10.tapable/10.api.html",redirect:"/webpack/tapable/api/"},{name:"v-87d0754a",path:"/webpack/tapable/hook/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-87d0754a").then(t)}},{path:"/webpack/tapable/hook/index.html",redirect:"/webpack/tapable/hook/"},{path:"/30.web/7.webpack/10.tapable/20.Hook.html",redirect:"/webpack/tapable/hook/"},{name:"v-2da3183a",path:"/webpack/tapable/factory/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2da3183a").then(t)}},{path:"/webpack/tapable/factory/index.html",redirect:"/webpack/tapable/factory/"},{path:"/30.web/7.webpack/10.tapable/30.HookCodeFactory.html",redirect:"/webpack/tapable/factory/"},{name:"v-53a11582",path:"/webpack/summary/dp/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-53a11582").then(t)}},{path:"/webpack/summary/dp/index.html",redirect:"/webpack/summary/dp/"},{path:"/30.web/7.webpack/100./10.dp.html",redirect:"/webpack/summary/dp/"},{name:"v-4c8845fc",path:"/webpack/summary/ds/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4c8845fc").then(t)}},{path:"/webpack/summary/ds/index.html",redirect:"/webpack/summary/ds/"},{path:"/30.web/7.webpack/100./20.ds.html",redirect:"/webpack/summary/ds/"},{name:"v-df747cda",path:"/webpack/init/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-df747cda").then(t)}},{path:"/webpack/init/index/index.html",redirect:"/webpack/init/index/"},{path:"/30.web/7.webpack/20.init/0.index.html",redirect:"/webpack/init/index/"},{name:"v-c36c87c2",path:"/webpack/init/compiler/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-c36c87c2").then(t)}},{path:"/webpack/init/compiler/index.html",redirect:"/webpack/init/compiler/"},{path:"/30.web/7.webpack/20.init/10.compiler.html",redirect:"/webpack/init/compiler/"},{name:"v-397f75f5",path:"/webpack/init/options/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-397f75f5").then(t)}},{path:"/webpack/init/options/index.html",redirect:"/webpack/init/options/"},{path:"/30.web/7.webpack/20.init/20.options.html",redirect:"/webpack/init/options/"},{name:"v-b6310e56",path:"/webpack/make/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-b6310e56").then(t)}},{path:"/webpack/make/index/index.html",redirect:"/webpack/make/index/"},{path:"/30.web/7.webpack/30.make/0.index.html",redirect:"/webpack/make/index/"},{name:"v-0d9c3a15",path:"/webpack/make/compilation/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0d9c3a15").then(t)}},{path:"/webpack/make/compilation/index.html",redirect:"/webpack/make/compilation/"},{path:"/30.web/7.webpack/30.make/10.compilation.html",redirect:"/webpack/make/compilation/"},{name:"v-8da47476",path:"/webpack/make/module/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-8da47476").then(t)}},{path:"/webpack/make/module/index.html",redirect:"/webpack/make/module/"},{path:"/30.web/7.webpack/30.make/20.module.html",redirect:"/webpack/make/module/"},{name:"v-4bc1c689",path:"/webpack/make/walk/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4bc1c689").then(t)}},{path:"/webpack/make/walk/index.html",redirect:"/webpack/make/walk/"},{path:"/30.web/7.webpack/30.make/30.walk.html",redirect:"/webpack/make/walk/"},{name:"v-7b75117d",path:"/pages/08c8a2/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7b75117d").then(t)}},{path:"/pages/08c8a2/index.html",redirect:"/pages/08c8a2/"},{path:"/30.web/70.am-editor/0.index.html",redirect:"/pages/08c8a2/"},{name:"v-10d9c13d",path:"/pages/da29c0/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-10d9c13d").then(t)}},{path:"/pages/da29c0/index.html",redirect:"/pages/da29c0/"},{path:"/30.web/70.am-editor/10.engine/0.index.html",redirect:"/pages/da29c0/"},{name:"v-778f237d",path:"/pages/33f539/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-778f237d").then(t)}},{path:"/pages/33f539/index.html",redirect:"/pages/33f539/"},{path:"/30.web/70.am-editor/10.engine/10.engine-basic.html",redirect:"/pages/33f539/"},{name:"v-5b6dcd7d",path:"/pages/518dfe/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5b6dcd7d").then(t)}},{path:"/pages/518dfe/index.html",redirect:"/pages/518dfe/"},{path:"/30.web/70.am-editor/10.engine/20.engine.html",redirect:"/pages/518dfe/"},{name:"v-42d8aff9",path:"/pages/a35554/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-42d8aff9").then(t)}},{path:"/pages/a35554/index.html",redirect:"/pages/a35554/"},{path:"/30.web/70.am-editor/10.engine/30.container.html",redirect:"/pages/a35554/"},{name:"v-7c8f5906",path:"/pages/53c865/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7c8f5906").then(t)}},{path:"/pages/53c865/index.html",redirect:"/pages/53c865/"},{path:"/30.web/70.am-editor/10.engine/40.change.html",redirect:"/pages/53c865/"},{name:"v-55778605",path:"/pages/7f2a93/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-55778605").then(t)}},{path:"/pages/7f2a93/index.html",redirect:"/pages/7f2a93/"},{path:"/30.web/70.am-editor/10.engine/50.range.html",redirect:"/pages/7f2a93/"},{name:"v-51bac5f7",path:"/axios/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-51bac5f7").then(t)}},{path:"/axios/index/index.html",redirect:"/axios/index/"},{path:"/30.web/8.axios/0.index.html",redirect:"/axios/index/"},{name:"v-f55aa90e",path:"/axios/core/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-f55aa90e").then(t)}},{path:"/axios/core/index/index.html",redirect:"/axios/core/index/"},{path:"/30.web/8.axios/10.core/0.index.html",redirect:"/axios/core/index/"},{name:"v-ea939fc6",path:"/axios/core/instance/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-ea939fc6").then(t)}},{path:"/axios/core/instance/index.html",redirect:"/axios/core/instance/"},{path:"/30.web/8.axios/10.core/10.axios.html",redirect:"/axios/core/instance/"},{name:"v-498b6e86",path:"/axios/core/interceptor/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-498b6e86").then(t)}},{path:"/axios/core/interceptor/index.html",redirect:"/axios/core/interceptor/"},{path:"/30.web/8.axios/10.core/30.interceptor.html",redirect:"/axios/core/interceptor/"},{name:"v-c9eede46",path:"/axios/core/adapter/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-c9eede46").then(t)}},{path:"/axios/core/adapter/index.html",redirect:"/axios/core/adapter/"},{path:"/30.web/8.axios/10.core/20.adapter.html",redirect:"/axios/core/adapter/"},{name:"v-3fcd21c9",path:"/axios/core/cancel/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3fcd21c9").then(t)}},{path:"/axios/core/cancel/index.html",redirect:"/axios/core/cancel/"},{path:"/30.web/8.axios/10.core/40.cancel.html",redirect:"/axios/core/cancel/"},{name:"v-3552c17d",path:"/pages/b58110/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3552c17d").then(t)}},{path:"/pages/b58110/index.html",redirect:"/pages/b58110/"},{path:"/30.web/80.html2canvas/0.index.html",redirect:"/pages/b58110/"},{name:"v-dca0dbea",path:"/solid/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-dca0dbea").then(t)}},{path:"/solid/index/index.html",redirect:"/solid/index/"},{path:"/30.web/9.solid/0.index.html",redirect:"/solid/index/"},{name:"v-73c1945d",path:"/solid/plan/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-73c1945d").then(t)}},{path:"/solid/plan/index.html",redirect:"/solid/plan/"},{path:"/30.web/9.solid/1.plan.html",redirect:"/solid/plan/"},{name:"v-074761b1",path:"/solid/render/render-by-jsx/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-074761b1").then(t)}},{path:"/solid/render/render-by-jsx/index.html",redirect:"/solid/render/render-by-jsx/"},{path:"/30.web/9.solid/10./10.render-jsx.html",redirect:"/solid/render/render-by-jsx/"},{name:"v-82075c46",path:"/node/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-82075c46").then(t)}},{path:"/node/index/index.html",redirect:"/node/index/"},{path:"/40.node/0.index.html",redirect:"/node/index/"},{name:"v-cf050632",path:"/node/plan/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-cf050632").then(t)}},{path:"/node/plan/index.html",redirect:"/node/plan/"},{path:"/40.node/1.plan.html",redirect:"/node/plan/"},{name:"v-bebe86c6",path:"/node/roadmap/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-bebe86c6").then(t)}},{path:"/node/roadmap/index.html",redirect:"/node/roadmap/"},{path:"/40.node/2.roadmap.html",redirect:"/node/roadmap/"},{name:"v-4fe65767",path:"/topic/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4fe65767").then(t)}},{path:"/topic/index/index.html",redirect:"/topic/index/"},{path:"/50.topic/0.index.html",redirect:"/topic/index/"},{name:"v-6fba7546",path:"/topic/js2ts/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6fba7546").then(t)}},{path:"/topic/js2ts/index/index.html",redirect:"/topic/js2ts/index/"},{path:"/50.topic/10.fromTs2Js/0.index.html",redirect:"/topic/js2ts/index/"},{name:"v-0790c155",path:"/node/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0790c155").then(t)}},{path:"/node/index.html",redirect:"/node/"},{path:"/999./20.node.html",redirect:"/node/"},{name:"v-97306cda",path:"/web/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-97306cda").then(t)}},{path:"/web/index.html",redirect:"/web/"},{path:"/999./10.web.html",redirect:"/web/"},{name:"v-6cc4c933",path:"/topic/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6cc4c933").then(t)}},{path:"/topic/index.html",redirect:"/topic/"},{path:"/999./30.topic.html",redirect:"/topic/"},{name:"v-d744eac6",path:"/archives/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-d744eac6").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-2bac39fd",path:"/categories/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2bac39fd").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-39df881d",path:"/tags/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-39df881d").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-75a63fbd",path:"/qa/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-75a63fbd").then(t)}},{path:"/qa/index.html",redirect:"/qa/"},{path:"/Q&A.html",redirect:"/qa/"},{name:"v-2af0da94",path:"/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2af0da94").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-7d3a31b9",path:"/nav/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7d3a31b9").then(t)}},{path:"/nav/index.html",redirect:"/nav/"},{path:"/.html",redirect:"/nav/"},{name:"v-d2407716",path:"/about/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-d2407716").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/.html",redirect:"/about/"},{name:"v-6196523d",path:"/qiankun/core/prefetch/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6196523d").then(t)}},{path:"/qiankun/core/prefetch/index.html",redirect:"/qiankun/core/prefetch/"},{path:"/30.web/6.qiankun/10.core/40.prefetch.html",redirect:"/qiankun/core/prefetch/"},{name:"v-5d5e22bf",path:"/qiankun/core/effects/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5d5e22bf").then(t)}},{path:"/qiankun/core/effects/index.html",redirect:"/qiankun/core/effects/"},{path:"/30.web/6.qiankun/10.core/30.effects.html",redirect:"/qiankun/core/effects/"},{path:"*",component:tt}],ot={title:"",description:"",base:"/",headTags:[["link",{rel:"icon",href:"/assets/img/favicon.ico"}],["meta",{name:"referrer",content:"no-referrer-when-downgrade"}],["meta",{name:"apple-mobile-web-app-capable",content:"yes"}],["meta",{name:"apple-mobile-web-app-status-bar-style",content:"black"}],["meta",{name:"keywords",content:",React,Vue,Vu3,Webpack"}],["meta",{name:"theme-color",content:"#3CB982"}],["link",{rel:"stylesheet",href:"//at.alicdn.com/t/font_3314748_9xij1pv3h4i.css"}]],pages:[{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/react/index/",categories:["react"],tags:[null]},regularPath:"/10.react/0.index.html",relativePath:"10.react/0.index.md",key:"v-376508bf",path:"/react/index/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:154},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:524},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:698}],readingTime:{text:"1 min read",minutes:.495,time:29700,words:99},headersStr:"  ",content:"react \n\n\n# \n\n\n\n          \nReact     v16.8.617.0.3\nIDE         VScode\n       VuePress\n Repo     https://github.com/jonsam-ng/ReactSourceCodeAnalyze.git\n Repo   https://github.com/jonsam-ng/fe-source-reading\n        https://source.jonsam.site\n        React diff hooks \n        \n\n\n# \n\n 1.  React \n\ngit clone https://github.com/jonsam-ng/ReactSourceCodeAnalyze.git \ncd source-code-demo\nyarn \nyarn start\n\n\n1\n2\n3\n4\n\n 2. \n\n\n# \n\n * React \n * React Fiber  -- \n * 7kms/react-illustration-series\n * React \n * React \n * React ",normalizedContent:"react \n\n\n# \n\n\n\n          \nreact     v16.8.617.0.3\nide         vscode\n       vuepress\n repo     https://github.com/jonsam-ng/reactsourcecodeanalyze.git\n repo   https://github.com/jonsam-ng/fe-source-reading\n        https://source.jonsam.site\n        react diff hooks \n        \n\n\n# \n\n 1.  react \n\ngit clone https://github.com/jonsam-ng/reactsourcecodeanalyze.git \ncd source-code-demo\nyarn \nyarn start\n\n\n1\n2\n3\n4\n\n 2. \n\n\n# \n\n * react \n * react fiber  -- \n * 7kms/react-illustration-series\n * react \n * react \n * react ",charsets:{cjk:!0},lastUpdated:"2022/04/16, 15:48:02",lastUpdatedTimestamp:1650095282e3},{title:"plan ",frontmatter:{title:"plan ",date:"2022-04-16T15:39:58.000Z",permalink:"/react/plan/",categories:["react"],tags:[null]},regularPath:"/10.react/1.plan.html",relativePath:"10.react/1.plan.md",key:"v-3611955d",path:"/react/plan/",headers:[{level:2,title:"Plan ",slug:"plan-",normalizedTitle:"plan ",charIndex:2},{level:3,title:"Basic",slug:"basic",normalizedTitle:"basic",charIndex:14},{level:3,title:"Reconciliation",slug:"reconciliation",normalizedTitle:"reconciliation",charIndex:66},{level:3,title:"Scheduler",slug:"scheduler",normalizedTitle:"scheduler",charIndex:183},{level:3,title:"Updater",slug:"updater",normalizedTitle:"updater",charIndex:263},{level:3,title:"Render",slug:"render",normalizedTitle:"render",charIndex:275},{level:3,title:"Hooks",slug:"hooks",normalizedTitle:"hooks",charIndex:331},{level:3,title:"Summary",slug:"summary",normalizedTitle:"summary",charIndex:435}],readingTime:{text:"1 min read",minutes:.405,time:24300,words:81},headersStr:"Plan  Basic Reconciliation Scheduler Updater Render Hooks Summary",content:"# Plan \n\n\n# Basic\n\n * [X]React Element\n * [X]React Children\n\n\n# Reconciliation\n\n * [x] fiber  reconciliation\n * [x] ReactChildFiber \n * [x] expirationTime \n * [] \n\n\n# Scheduler\n\n * [] \n * [x] scheduleWork \n * [] UpdateQueue\n\n\n# Updater\n\n\n# Render\n\n * [] \n * [] \n * [] \n * [] \n\n\n# Hooks\n\n * [x]useState\n * [x]useEffect\n * [x]useReducer\n * [x]useRef\n * []useContext\n * FC  hook \n\n\n# Summary\n\n * [x] React \n * [] React \n * []  lanes \n * [] \n * [x] \n * []  React ",normalizedContent:"# plan \n\n\n# basic\n\n * [x]react element\n * [x]react children\n\n\n# reconciliation\n\n * [x] fiber  reconciliation\n * [x] reactchildfiber \n * [x] expirationtime \n * [] \n\n\n# scheduler\n\n * [] \n * [x] schedulework \n * [] updatequeue\n\n\n# updater\n\n\n# render\n\n * [] \n * [] \n * [] \n * [] \n\n\n# hooks\n\n * [x]usestate\n * [x]useeffect\n * [x]usereducer\n * [x]useref\n * []usecontext\n * fc  hook \n\n\n# summary\n\n * [x] react \n * [] react \n * []  lanes \n * [] \n * [x] \n * []  react ",charsets:{cjk:!0},lastUpdated:"2022/04/16, 15:48:02",lastUpdatedTimestamp:1650095282e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/react/basic/",categories:["react","basic"],tags:[null]},regularPath:"/10.react/10.%E5%9F%BA%E7%A1%80/0.index.html",relativePath:"10.react/10./0.index.md",key:"v-0d7bb8be",path:"/react/basic/",readingTime:{text:"1 min read",minutes:.76,time:45600,words:152},headersStr:null,content:" react  React.js  React  React  API \n\nconst React = {\n  // ReactChildren this.props.children \n  Children: { // ReactChildrenReactChildren\n    map,\n    forEach,\n    count,\n    toArray,\n    only,\n  },\n  // ReactComponent\n  // ComponentPureComponent unstable_AsyncComponent 16.2.0\n  createRef, // ref\n  Component, // \n  // The difference between them is that React.Component doesnt implement shouldComponentUpdate(), but React.PureComponent implements it with a shallow prop and state comparison.\n  PureComponent, \n\n  createContext, //  context  useContext \n  forwardRef, // ref\n  lazy, // \n  memo, // \n\n  // Hook API\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useDebugValue,\n  useLayoutEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n\n  Fragment: REACT_FRAGMENT_TYPE,\n  Profiler: REACT_PROFILER_TYPE,\n  StrictMode: REACT_STRICT_MODE_TYPE, // \n  Suspense: REACT_SUSPENSE_TYPE, // lazyfeedback\n  unstable_SuspenseList: REACT_SUSPENSE_LIST_TYPE,\n  // \n  // ! createElement/cloneElement\n  createElement: __DEV__ ? createElementWithValidation : createElement,\n  cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement,\n  createFactory: __DEV__ ? createFactoryWithValidation : createFactory,\n  isValidElement: isValidElement,\n\n  version: ReactVersion,\n\n  unstable_withSuspenseConfig: withSuspenseConfig,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n\n * ChildrencreateElementcloneElement\n * ComponentPureComponentcreateRefFragmentforwardRef\n * hooks api: useCallback,useContext,useEffect,useImperativeHandle,useDebugValue,useLayoutEffect,useMemo,useReducer,useRef,useState\n * lazymemoSuspense\n * createContext",normalizedContent:" react  react.js  react  react  api \n\nconst react = {\n  // reactchildren this.props.children \n  children: { // reactchildrenreactchildren\n    map,\n    foreach,\n    count,\n    toarray,\n    only,\n  },\n  // reactcomponent\n  // componentpurecomponent unstable_asynccomponent 16.2.0\n  createref, // ref\n  component, // \n  // the difference between them is that react.component doesnt implement shouldcomponentupdate(), but react.purecomponent implements it with a shallow prop and state comparison.\n  purecomponent, \n\n  createcontext, //  context  usecontext \n  forwardref, // ref\n  lazy, // \n  memo, // \n\n  // hook api\n  usecallback,\n  usecontext,\n  useeffect,\n  useimperativehandle,\n  usedebugvalue,\n  uselayouteffect,\n  usememo,\n  usereducer,\n  useref,\n  usestate,\n\n  fragment: react_fragment_type,\n  profiler: react_profiler_type,\n  strictmode: react_strict_mode_type, // \n  suspense: react_suspense_type, // lazyfeedback\n  unstable_suspenselist: react_suspense_list_type,\n  // \n  // ! createelement/cloneelement\n  createelement: __dev__ ? createelementwithvalidation : createelement,\n  cloneelement: __dev__ ? cloneelementwithvalidation : cloneelement,\n  createfactory: __dev__ ? createfactorywithvalidation : createfactory,\n  isvalidelement: isvalidelement,\n\n  version: reactversion,\n\n  unstable_withsuspenseconfig: withsuspenseconfig,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n\n * childrencreateelementcloneelement\n * componentpurecomponentcreatereffragmentforwardref\n * hooks api: usecallback,usecontext,useeffect,useimperativehandle,usedebugvalue,uselayouteffect,usememo,usereducer,useref,usestate\n * lazymemosuspense\n * createcontext",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/react/basic/chapter/",categories:["react","basic"],tags:[null]},regularPath:"/10.react/10.%E5%9F%BA%E7%A1%80/10.chapter.html",relativePath:"10.react/10./10.chapter.md",key:"v-359e682f",path:"/react/basic/chapter/",headers:[{level:2,title:"React ",slug:"react-",normalizedTitle:"react ",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:114},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:154},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:161},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:274},{level:2,title:"Reconciliation",slug:"-reconciliation",normalizedTitle:"reconciliation",charIndex:429},{level:3,title:"",slug:"-2",normalizedTitle:"",charIndex:161},{level:3,title:"",slug:"-2",normalizedTitle:"",charIndex:274},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:41},{level:2,title:"Scheduler",slug:"-scheduler",normalizedTitle:"scheduler",charIndex:645},{level:3,title:"",slug:"-3",normalizedTitle:"",charIndex:161},{level:3,title:"",slug:"-3",normalizedTitle:"",charIndex:274},{level:3,title:"",slug:"-2",normalizedTitle:"",charIndex:41},{level:2,title:"Updater",slug:"-updater",normalizedTitle:"updater",charIndex:838},{level:3,title:"",slug:"-4",normalizedTitle:"",charIndex:161},{level:3,title:"",slug:"-4",normalizedTitle:"",charIndex:274},{level:3,title:"",slug:"-3",normalizedTitle:"",charIndex:41},{level:2,title:"Render",slug:"-render",normalizedTitle:"render",charIndex:955},{level:3,title:"",slug:"-5",normalizedTitle:"",charIndex:161},{level:3,title:"",slug:"-5",normalizedTitle:"",charIndex:274},{level:3,title:"",slug:"-4",normalizedTitle:"",charIndex:41},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:1147},{level:3,title:"",slug:"-6",normalizedTitle:"",charIndex:161},{level:3,title:"",slug:"-6",normalizedTitle:"",charIndex:274},{level:3,title:"",slug:"-5",normalizedTitle:"",charIndex:41},{level:2,title:"hooks ",slug:"hooks-",normalizedTitle:"hooks ",charIndex:1301},{level:3,title:"",slug:"-7",normalizedTitle:"",charIndex:161},{level:3,title:"",slug:"-7",normalizedTitle:"",charIndex:274},{level:3,title:"",slug:"-6",normalizedTitle:"",charIndex:41},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:1458}],readingTime:{text:"1 min read",minutes:.95,time:57e3,words:190},headersStr:"React      Reconciliation    Scheduler    Updater    Render        hooks     ",content:"# React \n\n react \n\nReact \n\n\n# \n\n\n\n\n# \n\n\n# \n\n *  react \n *  react \n *  react \n\n\n# \n\n * ReactElementreact  jsx  react  ReactElement  API\n * ReactChildren ReactElement  ReactChildren  API \n\n\n# Reconciliation\n\n\n# \n\n * \n *  Fiber \n\n\n# \n\n * fiber  ReconciliationFiber  Fiber \n\n\n# \n\n * \n *  react-reconciler \n\n\n# Scheduler\n\n\n# \n\n * \n\n\n# \n\n * scheduleWork \n\n\n# \n\n * \n *  react-reconciler  scheduler \n\n\n# Updater\n\n\n# \n\n * \n\n\n# \n\n\n# \n\n * \n *  react-reconciler \n\n\n# Render\n\n\n# \n\n *  FiberTree  DomTree \n *  react  diff \n\n\n# \n\n * ReactDOM.render render \n\n\n# \n\n * \n *  react-dom \n\n\n# \n\n\n# \n\n *  react \n\n\n# \n\n\n# \n\n * \n *  react-reconcilerreact-dom \n\n\n# hooks \n\n\n# \n\n *  hooks Api \n\n\n# \n\n * useStateuseState \n * useEffectuseEffect \n\n\n# \n\n *  react \n\n\n# \n\n * ",normalizedContent:"# react \n\n react \n\nreact \n\n\n# \n\n\n\n\n# \n\n\n# \n\n *  react \n *  react \n *  react \n\n\n# \n\n * reactelementreact  jsx  react  reactelement  api\n * reactchildren reactelement  reactchildren  api \n\n\n# reconciliation\n\n\n# \n\n * \n *  fiber \n\n\n# \n\n * fiber  reconciliationfiber  fiber \n\n\n# \n\n * \n *  react-reconciler \n\n\n# scheduler\n\n\n# \n\n * \n\n\n# \n\n * schedulework \n\n\n# \n\n * \n *  react-reconciler  scheduler \n\n\n# updater\n\n\n# \n\n * \n\n\n# \n\n\n# \n\n * \n *  react-reconciler \n\n\n# render\n\n\n# \n\n *  fibertree  domtree \n *  react  diff \n\n\n# \n\n * reactdom.render render \n\n\n# \n\n * \n *  react-dom \n\n\n# \n\n\n# \n\n *  react \n\n\n# \n\n\n# \n\n * \n *  react-reconcilerreact-dom \n\n\n# hooks \n\n\n# \n\n *  hooks api \n\n\n# \n\n * usestateusestate \n * useeffectuseeffect \n\n\n# \n\n *  react \n\n\n# \n\n * ",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"F&Q",frontmatter:{title:"F&Q",date:"2022-04-14T22:02:21.000Z",permalink:"/react/basic/faq/",categories:["react","basic"],tags:[null]},regularPath:"/10.react/10.%E5%9F%BA%E7%A1%80/20.faq.html",relativePath:"10.react/10./20.faq.md",key:"v-a1dbc2a2",path:"/react/basic/faq/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:" React ",slug:"-react-",normalizedTitle:" react ",charIndex:17}],readingTime:{text:"1 min read",minutes:.14,time:8400,words:28},headersStr:"  React ",content:"# \n\n\n\n * \n *  React \n\n\n\n\n#  React \n\n vscode \n\nfiles to include: src/react/packages/\nfiles to exclude: *test*.js,*.coffee,*test.ts,*.d.ts,*.md,*.snap,*.old.js,*.min.js,*.umd.js,*.development.js,__tests__\n\n\n1\n2\n\n\n",normalizedContent:"# \n\n\n\n * \n *  react \n\n\n\n\n#  react \n\n vscode \n\nfiles to include: src/react/packages/\nfiles to exclude: *test*.js,*.coffee,*test.ts,*.d.ts,*.md,*.snap,*.old.js,*.min.js,*.umd.js,*.development.js,__tests__\n\n\n1\n2\n\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"ReactChildren",frontmatter:{title:"ReactChildren",date:"2022-04-14T22:02:21.000Z",permalink:"/react/basic/children/",categories:["react","basic"],tags:[null]},regularPath:"/10.react/10.%E5%9F%BA%E7%A1%80/30.ReactChildren.html",relativePath:"10.react/10./30.ReactChildren.md",key:"v-406c3962",path:"/react/basic/children/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"map",slug:"map",normalizedTitle:"map",charIndex:17},{level:3,title:"traverseContext",slug:"traversecontext",normalizedTitle:"traversecontext",charIndex:26},{level:3,title:"traverseAllChildren",slug:"traverseallchildren",normalizedTitle:"traverseallchildren",charIndex:47},{level:4,title:"mapSingleChildIntoContext",slug:"mapsinglechildintocontext",normalizedTitle:"mapsinglechildintocontext",charIndex:1018},{level:3,title:"ChildrenKey ",slug:"childrenkey-",normalizedTitle:"childrenkey ",charIndex:72},{level:2,title:"forEach",slug:"foreach",normalizedTitle:"foreach",charIndex:91},{level:2,title:"count",slug:"count",normalizedTitle:"count",charIndex:102},{level:2,title:"toArray",slug:"toarray",normalizedTitle:"toarray",charIndex:111},{level:2,title:"only",slug:"only",normalizedTitle:"only",charIndex:122}],readingTime:{text:"6 min read",minutes:5.075,time:304500,words:1015},headersStr:" map traverseContext traverseAllChildren mapSingleChildIntoContext ChildrenKey  forEach count toArray only",content:"# \n\n\n\n * \n * map\n   * traverseContext\n   * traverseAllChildren\n   * ChildrenKey \n * forEach\n * count\n * toArray\n * only\n\n\n\nReact Children \n\n// ReactChildrenReactChildren\n{ \n  map,\n  forEach,\n  count,\n  toArray,\n  only,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# map\n\nmap  mapChildren \n\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n  const result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n mapIntoWithKeyPrefixInternal \n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  let escapedPrefix = '';\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n  //  traverseContext traverseContextPool\n  const traverseContext = getPooledTraverseContext(\n    array,\n    escapedPrefix,\n    func,\n    context,\n  );\n  //  children  mapResult\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  // traverseContext\n  releaseTraverseContext(traverseContext);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n *  traverseContext \n * traverseAllChildren  mapSingleChildIntoContext \n * traverseContextPool  traverseContext releaseTraverseContext \n\n\n# traverseContext\n\n context\n\n// \nconst POOL_SIZE = 10;\nconst traverseContextPool = [];\nfunction getPooledTraverseContext(\n  mapResult, // \n  keyPrefix, // traverseContext  key\n  mapFunction, // \n  mapContext, //  context\n) {\n  // \n  if (traverseContextPool.length) {\n    // traverseContext\n    const traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    //  traverseContext\n    return traverseContext;\n  } else {\n    //  traverseContext 10 \n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0,\n    };\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n context \n\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n *  POOL_SIZE  POOL_SIZE  context \n\n\n# traverseAllChildren\n\ntraverseAllChildren  traverseAllChildrenImpl  children callback children  key \n\n// \nfunction traverseAllChildrenImpl(\n  children, // \n  nameSoFar,\n  callback, // mapSingleChildIntoContext \n  traverseContext,\n) {\n  const type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  //  true  callback(null,string,number,Element,Portal)\n  //  callback \n  let invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n    }\n  }\n\n  if (invokeCallback) {\n    callback(\n      traverseContext,\n      children,\n      // If it's the only child, treat the name as if it was wrapped in an array\n      // so that it's consistent if the number of children grows.\n      // nameSoFar children  key \n      nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar,\n    );\n    return 1;\n  }\n\n  let child;\n  let nextName;\n  let subtreeCount = 0; // Count of children found in the current subtree.\n  // .j:\n  const nextNamePrefix =\n    nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(\n        child,\n        nextName,\n        callback,\n        traverseContext,\n      );\n    }\n  } else {\n    //  children\n    const iteratorFn = getIteratorFn(children);\n    if (typeof iteratorFn === 'function') {\n      const iterator = iteratorFn.call(children);\n      let step;\n      let ii = 0;\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getComponentKey(child, ii++);\n        subtreeCount += traverseAllChildrenImpl(\n          child,\n          nextName,\n          callback,\n          traverseContext,\n        );\n      }\n    } else if (type === 'object') {\n      //  children \n      let addendum = '';\n      if (__DEV__) {\n        addendum =\n          ' If you meant to render a collection of children, use an array ' +\n          'instead.' +\n          ReactDebugCurrentFrame.getStackAddendum();\n      }\n      const childrenString = '' + children;\n      invariant(\n        false,\n        'Objects are not valid as a React child (found: %s).%s',\n        childrenString === '[object Object]'\n          ? 'object with keys {' + Object.keys(children).join(', ') + '}'\n          : childrenString,\n        addendum,\n      );\n    }\n  }\n\n  return subtreeCount;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n\n * traverseAllChildrenImpl  children  children  callback traverseAllChildrenImpl  children \n\n# mapSingleChildIntoContext\n\nmap  contextMap  mapSingleChildIntoContext\n\nfunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\n  const {result, keyPrefix, func, context} = bookKeeping;\n\n  // \n  let mappedChild = func.call(context, child, bookKeeping.count++);\n  if (Array.isArray(mappedChild)) {\n    //  map\n    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c => c);\n  } else if (mappedChild != null) {\n    //  ReactElement\n    if (isValidElement(mappedChild)) {\n      // mappedChild key \n      mappedChild = cloneAndReplaceKey(\n        mappedChild,\n        // Keep both the (mapped) and old keys if they differ, just as\n        // traverseAllChildren used to do for objects as children\n        keyPrefix +\n          (mappedChild.key && (!child || child.key !== mappedChild.key)\n            ? escapeUserProvidedKey(mappedChild.key) + '/'\n            : '') +\n          childKey,\n      );\n    }\n    // result\n    result.push(mappedChild);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n *  map   ReactElement  result result  map \n\n\n# ChildrenKey \n\nkey \n\nconst SEPARATOR = '.';\nconst SUBSEPARATOR = ':';\n\n\n1\n2\n\n\n key \n\nfunction getComponentKey(component, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  //  key \n  if (\n    typeof component === 'object' &&\n    component !== null &&\n    component.key != null\n  ) {\n    // Explicit key\n    return escape(component.key);\n  }\n  // Implicit key determined by the index in the set\n  //  36  0-9-a-z(35).toString(36) === 'z'\n  return index.toString(36);\n}\n\nfunction escape(key) {\n  const escapeRegex = /[=:]/g;\n  const escaperLookup = {\n    '=': '=0',\n    ':': '=2',\n  };\n  const escapedString = ('' + key).replace(escapeRegex, function(match) {\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n *  key  key  escape  $ \n\nkey \n\n.key => .key:key1 => .key:key1:key2 ...\n\n\n1\n\n\n\n# forEach\n\nforEach  forEachChildren \n\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  if (children == null) {\n    return children;\n  }\n  const traverseContext = getPooledTraverseContext(\n    null,\n    null,\n    forEachFunc,\n    forEachContext,\n  );\n  traverseAllChildren(children, forEachSingleChild, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n * forEach  mapIntoWithKeyPrefixInternal contextMap  forEachSingleChild \n * forEach  map forEach \n\nforEachSingleChild \n\nfunction forEachSingleChild(bookKeeping, child, name) {\n  const {func, context} = bookKeeping;\n  func.call(context, child, bookKeeping.count++);\n}\n\n\n1\n2\n3\n4\n\n\n\n# count\n\ncount  countChildren  children \n\nfunction countChildren(children) {\n  return traverseAllChildren(children, () => null, null);\n}\n\n\n1\n2\n3\n\n\n\n# toArray\n\ntoArray  children  contextMap  null\n\nfunction toArray(children) {\n  const result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, child => child);\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# only\n\nonly  onlyChild only  children \n\nfunction onlyChild(children) {\n  invariant(\n    isValidElement(children),\n    'React.Children.only expected to receive a single React element child.',\n  );\n  return children;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n",normalizedContent:"# \n\n\n\n * \n * map\n   * traversecontext\n   * traverseallchildren\n   * childrenkey \n * foreach\n * count\n * toarray\n * only\n\n\n\nreact children \n\n// reactchildrenreactchildren\n{ \n  map,\n  foreach,\n  count,\n  toarray,\n  only,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# map\n\nmap  mapchildren \n\nfunction mapchildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n  const result = [];\n  mapintowithkeyprefixinternal(children, result, null, func, context);\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n mapintowithkeyprefixinternal \n\nfunction mapintowithkeyprefixinternal(children, array, prefix, func, context) {\n  let escapedprefix = '';\n  if (prefix != null) {\n    escapedprefix = escapeuserprovidedkey(prefix) + '/';\n  }\n  //  traversecontext traversecontextpool\n  const traversecontext = getpooledtraversecontext(\n    array,\n    escapedprefix,\n    func,\n    context,\n  );\n  //  children  mapresult\n  traverseallchildren(children, mapsinglechildintocontext, traversecontext);\n  // traversecontext\n  releasetraversecontext(traversecontext);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n *  traversecontext \n * traverseallchildren  mapsinglechildintocontext \n * traversecontextpool  traversecontext releasetraversecontext \n\n\n# traversecontext\n\n context\n\n// \nconst pool_size = 10;\nconst traversecontextpool = [];\nfunction getpooledtraversecontext(\n  mapresult, // \n  keyprefix, // traversecontext  key\n  mapfunction, // \n  mapcontext, //  context\n) {\n  // \n  if (traversecontextpool.length) {\n    // traversecontext\n    const traversecontext = traversecontextpool.pop();\n    traversecontext.result = mapresult;\n    traversecontext.keyprefix = keyprefix;\n    traversecontext.func = mapfunction;\n    traversecontext.context = mapcontext;\n    traversecontext.count = 0;\n    //  traversecontext\n    return traversecontext;\n  } else {\n    //  traversecontext 10 \n    return {\n      result: mapresult,\n      keyprefix: keyprefix,\n      func: mapfunction,\n      context: mapcontext,\n      count: 0,\n    };\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n context \n\nfunction releasetraversecontext(traversecontext) {\n  traversecontext.result = null;\n  traversecontext.keyprefix = null;\n  traversecontext.func = null;\n  traversecontext.context = null;\n  traversecontext.count = 0;\n  if (traversecontextpool.length < pool_size) {\n    traversecontextpool.push(traversecontext);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n *  pool_size  pool_size  context \n\n\n# traverseallchildren\n\ntraverseallchildren  traverseallchildrenimpl  children callback children  key \n\n// \nfunction traverseallchildrenimpl(\n  children, // \n  namesofar,\n  callback, // mapsinglechildintocontext \n  traversecontext,\n) {\n  const type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // all of the above are perceived as null.\n    children = null;\n  }\n\n  //  true  callback(null,string,number,element,portal)\n  //  callback \n  let invokecallback = false;\n\n  if (children === null) {\n    invokecallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokecallback = true;\n        break;\n      case 'object':\n        switch (children.$$typeof) {\n          case react_element_type:\n          case react_portal_type:\n            invokecallback = true;\n        }\n    }\n  }\n\n  if (invokecallback) {\n    callback(\n      traversecontext,\n      children,\n      // if it's the only child, treat the name as if it was wrapped in an array\n      // so that it's consistent if the number of children grows.\n      // namesofar children  key \n      namesofar === '' ? separator + getcomponentkey(children, 0) : namesofar,\n    );\n    return 1;\n  }\n\n  let child;\n  let nextname;\n  let subtreecount = 0; // count of children found in the current subtree.\n  // .j:\n  const nextnameprefix =\n    namesofar === '' ? separator : namesofar + subseparator;\n\n  if (array.isarray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      child = children[i];\n      nextname = nextnameprefix + getcomponentkey(child, i);\n      subtreecount += traverseallchildrenimpl(\n        child,\n        nextname,\n        callback,\n        traversecontext,\n      );\n    }\n  } else {\n    //  children\n    const iteratorfn = getiteratorfn(children);\n    if (typeof iteratorfn === 'function') {\n      const iterator = iteratorfn.call(children);\n      let step;\n      let ii = 0;\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextname = nextnameprefix + getcomponentkey(child, ii++);\n        subtreecount += traverseallchildrenimpl(\n          child,\n          nextname,\n          callback,\n          traversecontext,\n        );\n      }\n    } else if (type === 'object') {\n      //  children \n      let addendum = '';\n      if (__dev__) {\n        addendum =\n          ' if you meant to render a collection of children, use an array ' +\n          'instead.' +\n          reactdebugcurrentframe.getstackaddendum();\n      }\n      const childrenstring = '' + children;\n      invariant(\n        false,\n        'objects are not valid as a react child (found: %s).%s',\n        childrenstring === '[object object]'\n          ? 'object with keys {' + object.keys(children).join(', ') + '}'\n          : childrenstring,\n        addendum,\n      );\n    }\n  }\n\n  return subtreecount;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n\n * traverseallchildrenimpl  children  children  callback traverseallchildrenimpl  children \n\n# mapsinglechildintocontext\n\nmap  contextmap  mapsinglechildintocontext\n\nfunction mapsinglechildintocontext(bookkeeping, child, childkey) {\n  const {result, keyprefix, func, context} = bookkeeping;\n\n  // \n  let mappedchild = func.call(context, child, bookkeeping.count++);\n  if (array.isarray(mappedchild)) {\n    //  map\n    mapintowithkeyprefixinternal(mappedchild, result, childkey, c => c);\n  } else if (mappedchild != null) {\n    //  reactelement\n    if (isvalidelement(mappedchild)) {\n      // mappedchild key \n      mappedchild = cloneandreplacekey(\n        mappedchild,\n        // keep both the (mapped) and old keys if they differ, just as\n        // traverseallchildren used to do for objects as children\n        keyprefix +\n          (mappedchild.key && (!child || child.key !== mappedchild.key)\n            ? escapeuserprovidedkey(mappedchild.key) + '/'\n            : '') +\n          childkey,\n      );\n    }\n    // result\n    result.push(mappedchild);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n *  map   reactelement  result result  map \n\n\n# childrenkey \n\nkey \n\nconst separator = '.';\nconst subseparator = ':';\n\n\n1\n2\n\n\n key \n\nfunction getcomponentkey(component, index) {\n  // do some typechecking here since we call this blindly. we want to ensure\n  // that we don't block potential future es apis.\n  //  key \n  if (\n    typeof component === 'object' &&\n    component !== null &&\n    component.key != null\n  ) {\n    // explicit key\n    return escape(component.key);\n  }\n  // implicit key determined by the index in the set\n  //  36  0-9-a-z(35).tostring(36) === 'z'\n  return index.tostring(36);\n}\n\nfunction escape(key) {\n  const escaperegex = /[=:]/g;\n  const escaperlookup = {\n    '=': '=0',\n    ':': '=2',\n  };\n  const escapedstring = ('' + key).replace(escaperegex, function(match) {\n    return escaperlookup[match];\n  });\n\n  return '$' + escapedstring;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n *  key  key  escape  $ \n\nkey \n\n.key => .key:key1 => .key:key1:key2 ...\n\n\n1\n\n\n\n# foreach\n\nforeach  foreachchildren \n\nfunction foreachchildren(children, foreachfunc, foreachcontext) {\n  if (children == null) {\n    return children;\n  }\n  const traversecontext = getpooledtraversecontext(\n    null,\n    null,\n    foreachfunc,\n    foreachcontext,\n  );\n  traverseallchildren(children, foreachsinglechild, traversecontext);\n  releasetraversecontext(traversecontext);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n * foreach  mapintowithkeyprefixinternal contextmap  foreachsinglechild \n * foreach  map foreach \n\nforeachsinglechild \n\nfunction foreachsinglechild(bookkeeping, child, name) {\n  const {func, context} = bookkeeping;\n  func.call(context, child, bookkeeping.count++);\n}\n\n\n1\n2\n3\n4\n\n\n\n# count\n\ncount  countchildren  children \n\nfunction countchildren(children) {\n  return traverseallchildren(children, () => null, null);\n}\n\n\n1\n2\n3\n\n\n\n# toarray\n\ntoarray  children  contextmap  null\n\nfunction toarray(children) {\n  const result = [];\n  mapintowithkeyprefixinternal(children, result, null, child => child);\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# only\n\nonly  onlychild only  children \n\nfunction onlychild(children) {\n  invariant(\n    isvalidelement(children),\n    'react.children.only expected to receive a single react element child.',\n  );\n  return children;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"ReactElement",frontmatter:{title:"ReactElement",date:"2022-04-14T22:02:21.000Z",permalink:"/react/basic/element/",categories:["react","basic"],tags:[null]},regularPath:"/10.react/10.%E5%9F%BA%E7%A1%80/40.ReactElement.html",relativePath:"10.react/10./40.ReactElement.md",key:"v-4b4b48ab",path:"/react/basic/element/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"JSX",slug:"jsx",normalizedTitle:"jsx",charIndex:17},{level:2,title:"ReactElement",slug:"reactelement",normalizedTitle:"reactelement",charIndex:24},{level:3,title:"createElement",slug:"createelement",normalizedTitle:"createelement",charIndex:42},{level:3,title:"isValidElement",slug:"isvalidelement",normalizedTitle:"isvalidelement",charIndex:61},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:81}],readingTime:{text:"3 min read",minutes:2.995,time:179700.00000000003,words:599},headersStr:" JSX ReactElement createElement isValidElement ",content:'# \n\n\n\n * \n * JSX\n * ReactElement\n   * createElement\n   * isValidElement\n   * \n\n\n\n\n# JSX\n\n * JSX  JS  HTML  babel \n * JSX  @babel/plugin-transform-react-jsx-source \n\n\n\nconst Con = () => {\n\treturn (\n    <div style={{color: \'#ffffff\'}}>\n      <p class="title">react</p>\n      <span class="detail">reading</span>\n    </div>\n    )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\nconst Con = () => {\n  return /*#__PURE__*/React.createElement("div", {\n    style: {\n      color: \'#ffffff\'\n    }\n  }, /*#__PURE__*/React.createElement("p", {\n    class: "title"\n  }, "react"), /*#__PURE__*/React.createElement("span", {\n    class: "detail"\n  }, "reading"));\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n\n * babel  jsx js html  React.createElement \n *  /*#__PURE__*/ \n *  rest \n\n\n# ReactElement\n\n react  ReactElement   createElementcloneElementcreateFactoryisValidElement  ELement  API\n\n\n# createElement\n\n babel  jsx \n\nReact.createElement("div", {\n    class: "class_name",\n    id: "id_name",\n    key: "key_name",\n    ref: "ref_name"\n}, React.createElement("span", null, "Tom"), React.createElement("span", null, "Jerry"));\n\n\n1\n2\n3\n4\n5\n6\n\n\n createElement \n\n{\n    $$typeof: REACT_ELEMENT_TYPE,\n    type\'div\'\n    key: \'key_name\',\n    ref: "ref_name",\n    props: {\n        class: "class_name",\n        id: "id_name",\n        children: [\n            React.createElement("span", null, "Tom"),\n            React.createElement("span", null, "Jerry")\n        ]\n    }\n     _owner: ReactCurrentOwner.current,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n_owner  react  fiber createElement \n\n//  type config  children  react \nexport function createElement(type, config, children) {\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n\n  if (config != null) {\n    //  ref \n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    //  key \n    if (hasValidKey(config)) {\n      key = \'\' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    // \n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    // \n    // children  props  props  children \n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  // \n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  return ReactElement(\n    // \n    type,\n    // \n    key,\n    ref,\n    self,\n    source,\n    ReactCurrentOwner.current,\n    // \n    props,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n ReactElement \n\nconst ReactElement = function (type, key, ref, self, source, owner, props) {\n  // ReactElement\n  const element = {\n    // This tag allows us to uniquely identify this as a React Element\n    // ReactElement \n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // \n    // Record the component responsible for creating this element.\n    _owner: owner,\n  };\n\n  return element;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * $$typeof :  react react  react  $$typeof  REACT_ELEMENT_TYPE   ReactDOM.createPortals(child, container)  portal  ReactDOM.createPortals(child, container) \n * typeDOM  \'div\'\n * key\n * ref\n * props children\n * _owner fiber fiber \n\n\n# isValidElement\n\n// .$$typeof\nexport function isValidElement(object) {\n  return (\n    typeof object === \'object\' &&\n    object !== null &&\n    // $$typeofSymbol,ReactElementSymbol\n    // REACT_ELEMENT_TYPESymbol(react.element)\n    object.$$typeof === REACT_ELEMENT_TYPE // $$typeof: Symbol(react.element)\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n ReactElement \n\n *  \'object\' null;\n * $$typeof  REACT_ELEMENT_TYPE \n\n\n# \n\n * createElement  ReactElement  $$typeof typekeyrefprops_owner  $$typeof  ReactElement type  props ( children)  VNode  DOMkey  ref _owner  fiber \n * cloneElement  ReactElement  ReactElement\n * isValidElement  ReactElement',normalizedContent:'# \n\n\n\n * \n * jsx\n * reactelement\n   * createelement\n   * isvalidelement\n   * \n\n\n\n\n# jsx\n\n * jsx  js  html  babel \n * jsx  @babel/plugin-transform-react-jsx-source \n\n\n\nconst con = () => {\n\treturn (\n    <div style={{color: \'#ffffff\'}}>\n      <p class="title">react</p>\n      <span class="detail">reading</span>\n    </div>\n    )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\nconst con = () => {\n  return /*#__pure__*/react.createelement("div", {\n    style: {\n      color: \'#ffffff\'\n    }\n  }, /*#__pure__*/react.createelement("p", {\n    class: "title"\n  }, "react"), /*#__pure__*/react.createelement("span", {\n    class: "detail"\n  }, "reading"));\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n\n * babel  jsx js html  react.createelement \n *  /*#__pure__*/ \n *  rest \n\n\n# reactelement\n\n react  reactelement   createelementcloneelementcreatefactoryisvalidelement  element  api\n\n\n# createelement\n\n babel  jsx \n\nreact.createelement("div", {\n    class: "class_name",\n    id: "id_name",\n    key: "key_name",\n    ref: "ref_name"\n}, react.createelement("span", null, "tom"), react.createelement("span", null, "jerry"));\n\n\n1\n2\n3\n4\n5\n6\n\n\n createelement \n\n{\n    $$typeof: react_element_type,\n    type\'div\'\n    key: \'key_name\',\n    ref: "ref_name",\n    props: {\n        class: "class_name",\n        id: "id_name",\n        children: [\n            react.createelement("span", null, "tom"),\n            react.createelement("span", null, "jerry")\n        ]\n    }\n     _owner: reactcurrentowner.current,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n_owner  react  fiber createelement \n\n//  type config  children  react \nexport function createelement(type, config, children) {\n  let propname;\n\n  // reserved names are extracted\n  const props = {};\n\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n\n  if (config != null) {\n    //  ref \n    if (hasvalidref(config)) {\n      ref = config.ref;\n    }\n    //  key \n    if (hasvalidkey(config)) {\n      key = \'\' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // remaining properties are added to a new props object\n    // \n    for (propname in config) {\n      if (\n        hasownproperty.call(config, propname) &&\n        !reserved_props.hasownproperty(propname)\n      ) {\n        props[propname] = config[propname];\n      }\n    }\n  }\n\n  // children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenlength = arguments.length - 2;\n  if (childrenlength === 1) {\n    // \n    // children  props  props  children \n    props.children = children;\n  } else if (childrenlength > 1) {\n    const childarray = array(childrenlength);\n    for (let i = 0; i < childrenlength; i++) {\n      childarray[i] = arguments[i + 2];\n    }\n    props.children = childarray;\n  }\n\n  // resolve default props\n  // \n  if (type && type.defaultprops) {\n    const defaultprops = type.defaultprops;\n    for (propname in defaultprops) {\n      if (props[propname] === undefined) {\n        props[propname] = defaultprops[propname];\n      }\n    }\n  }\n  return reactelement(\n    // \n    type,\n    // \n    key,\n    ref,\n    self,\n    source,\n    reactcurrentowner.current,\n    // \n    props,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n reactelement \n\nconst reactelement = function (type, key, ref, self, source, owner, props) {\n  // reactelement\n  const element = {\n    // this tag allows us to uniquely identify this as a react element\n    // reactelement \n    $$typeof: react_element_type,\n\n    // built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // \n    // record the component responsible for creating this element.\n    _owner: owner,\n  };\n\n  return element;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * $$typeof :  react react  react  $$typeof  react_element_type   reactdom.createportals(child, container)  portal  reactdom.createportals(child, container) \n * typedom  \'div\'\n * key\n * ref\n * props children\n * _owner fiber fiber \n\n\n# isvalidelement\n\n// .$$typeof\nexport function isvalidelement(object) {\n  return (\n    typeof object === \'object\' &&\n    object !== null &&\n    // $$typeofsymbol,reactelementsymbol\n    // react_element_typesymbol(react.element)\n    object.$$typeof === react_element_type // $$typeof: symbol(react.element)\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n reactelement \n\n *  \'object\' null;\n * $$typeof  react_element_type \n\n\n# \n\n * createelement  reactelement  $$typeof typekeyrefprops_owner  $$typeof  reactelement type  props ( children)  vnode  domkey  ref _owner  fiber \n * cloneelement  reactelement  reactelement\n * isvalidelement  reactelement',charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/react/reconciliation/index/",categories:["react","reconciliation"],tags:[null]},regularPath:"/10.react/20.%E8%B0%83%E5%92%8C%EF%BC%88Reconciliation%EF%BC%89/0.index.html",relativePath:"10.react/20.Reconciliation/0.index.md",key:"v-4d309ab6",path:"/react/reconciliation/index/",headers:[{level:2,title:"reconciler  4 ",slug:"reconciler--4-",normalizedTitle:"reconciler  4 ",charIndex:2}],readingTime:{text:"1 min read",minutes:.115,time:6900,words:23},headersStr:"reconciler  4 ",content:"# reconciler  4 \n\nreconciler \n\n 1. \n 2. \n 3.  FiberTree \n 4. ",normalizedContent:"# reconciler  4 \n\nreconciler \n\n 1. \n 2. \n 3.  fibertree \n 4. ",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"Fiber  Reconciliation",frontmatter:{title:"Fiber  Reconciliation",date:"2022-04-14T22:02:21.000Z",permalink:"/react/reconciliation/fiber/",categories:["react","reconciliation"],tags:[null]},regularPath:"/10.react/20.%E8%B0%83%E5%92%8C%EF%BC%88Reconciliation%EF%BC%89/10.fiber.html",relativePath:"10.react/20.Reconciliation/10.fiber.md",key:"v-1a05c896",path:"/react/reconciliation/fiber/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"Fiber Reconciliation",slug:"fiber-reconciliation",normalizedTitle:"fiber reconciliation",charIndex:17},{level:3,title:"Reconciliation",slug:"-reconciliation-",normalizedTitle:"reconciliation",charIndex:43},{level:3,title:"fiber ",slug:"fiber-",normalizedTitle:"fiber ",charIndex:70},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:85},{level:3,title:"fiberFiber ",slug:"fiberfiber-",normalizedTitle:"fiberfiber ",charIndex:103},{level:2,title:"Fiber ",slug:"fiber-",normalizedTitle:"fiber ",charIndex:125},{level:3,title:"Fiber ",slug:"fiber-",normalizedTitle:"fiber ",charIndex:139},{level:3,title:"fiber ",slug:"fiber-",normalizedTitle:"fiber ",charIndex:154},{level:3,title:"fiber ",slug:"fiber-",normalizedTitle:"fiber ",charIndex:169},{level:2,title:"FiberRoot",slug:"fiberroot",normalizedTitle:"fiberroot",charIndex:182},{level:3,title:"FiberRoot ",slug:"fiberroot-",normalizedTitle:"fiberroot ",charIndex:197},{level:3,title:" FiberRoot",slug:"-fiberroot",normalizedTitle:" fiberroot",charIndex:216},{level:2,title:"HostFiberRoot",slug:"hostfiberroot",normalizedTitle:"hostfiberroot",charIndex:232},{level:2,title:"ReactChildFiber",slug:"reactchildfiber",normalizedTitle:"reactchildfiber",charIndex:249}],readingTime:{text:"12 min read",minutes:11.015,time:660900.0000000001,words:2203},headersStr:" Fiber Reconciliation Reconciliation fiber   fiberFiber  Fiber  Fiber  fiber  fiber  FiberRoot FiberRoot   FiberRoot HostFiberRoot ReactChildFiber",content:"# \n\n\n\n * \n * Fiber Reconciliation\n   * Reconciliation\n   * fiber \n   * \n   * fiberFiber \n * Fiber \n   * Fiber \n   * fiber \n   * fiber \n * FiberRoot\n   * FiberRoot \n   *  FiberRoot\n * HostFiberRoot\n * ReactChildFiber\n\n\n\n react-reconciler \n\n\n# Fiber Reconciliation\n\n\n# Reconciliation\n\n Reconciliation  render \n\nReact 15.X  Stack Reconciler \n\nFiber Reconciliation  React16 \n\n\n# fiber \n\nfiber fiber  Fiber Tree\n\nfiber \n\n * \n * \n * \n * render \n * \n\n\n# \n\n Api\n\nrequestIdleCallback: \nrequestAnimationFrame: \n\n\n1\n2\n\n * requestIdleCallback  idle callback  deadline UI \n * requestAnimationFrame \n\n Api  js \n\n\n# fiberFiber \n\n * fiber Fiber Tree Fiber Root \n * Fiber fiber \n\n\n# Fiber \n\n\n# Fiber \n\n react-reconciler   Fiber dev \n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\n// Fiber  Fiber\nexport type Fiber = {|\n  // These first fields are conceptually members of an Instance. This used to\n  // be split into a separate type and intersected with the other Fiber fields,\n  // but until Flow fixes its intersection bugs, we've merged them into a\n  // single type.\n\n  // An Instance is shared between all versions of a component. We can easily\n  // break this out into a separate object to avoid copying so much to the\n  // alternate versions of the tree. We put this on a single object for now to\n  // minimize the number of objects created during the initial render.\n  //  Fiber \n\n  // Tag identifying the type of fiber.\n  //  Fiber :0-21\n  tag: WorkTag,\n\n  // Unique identifier of this child.\n  // fiber  key \n  key: null | string,\n\n  // The value of element.type which is used to preserve the identity during\n  // reconciliation of this child.\n  //  element.type\n  elementType: any,\n\n  // The resolved function/class/ associated with this fiber.\n  // fiberfunction/class/module.\n  type: any,\n\n  // The local state associated with this fiber.\n  // fiberFiberRoot\n  stateNode: any,\n\n  // Conceptual aliases\n  // parent : Instance -> return The parent happens to be the same as the\n  // return fiber since we've merged the fiber and instance.\n\n  // Remaining fields belong to Fiber\n\n  // The Fiber to return to after finishing processing this one.\n  // This is effectively the parent, but there can be multiple parents (two)\n  // so this is only the parent of the thing we're currently processing.\n  // It is conceptually the same as the return address of a stack frame.\n  //  fiber  fiber fiber\n  return: Fiber | null,\n\n  // Singly Linked List Tree Structure.\n  //  fiber  fiber\n  child: Fiber | null,\n  sibling: Fiber | null,\n  index: number,\n\n  // The ref last used to attach this node.\n  // I'll avoid adding an owner field for prod and model that as functions.\n  ref: null | (((handle: mixed) => void) & {_stringRef: ?string}) | RefObject,\n\n  // Input is the data coming into process this fiber. Arguments. Props.\n  //  work-i-progress  props\n  pendingProps: any, // This type will be more specific once we overload the tag.\n  //  props\n  memoizedProps: any, // The props used to create the output.\n\n  // A queue of state updates and callbacks.\n  // \n  updateQueue: UpdateQueue<any> | null,\n\n  // The state used to create the output\n  memoizedState: any,\n\n  // Dependencies (contexts, events) for this fiber, if it has any\n  // fiber \n  dependencies: Dependencies | null,\n\n  // Bitfield that describes properties about the fiber and its subtree. E.g.\n  // the ConcurrentMode flag indicates whether the subtree should be async-by-\n  // default. When a fiber is created, it inherits the mode of its\n  // parent. Additional flags can be set at creation time, but after that the\n  // value should remain unchanged throughout the fiber's lifetime, particularly\n  // before its child fibers are created.\n  //  fiber  fiber tree  NoModeStrictMode\n  mode: TypeOfMode,\n\n  // Effect\n  // effect \n  effectTag: SideEffectTag,\n\n  // Singly linked list fast path to the next fiber with side-effects.\n  //  effect\n  nextEffect: Fiber | null,\n\n  // The first and last fiber with side-effect within this subtree. This allows\n  // us to reuse a slice of the linked list when we reuse the work done within\n  // this fiber.\n  //  pending effect   effect.\n  firstEffect: Fiber | null,\n  lastEffect: Fiber | null,\n\n  // Represents a time in the future by which this work should be completed.\n  // Does not include work found in its subtree.\n  // expirationTime \n  expirationTime: ExpirationTime,\n\n  // This is used to quickly determine if a subtree has no pending changes.\n  //  expirationTime \n  childExpirationTime: ExpirationTime,\n\n  // This is a pooled version of a Fiber. Every fiber that gets updated will\n  // eventually have a pair. There are cases when we can clean up pairs to save\n  // memory if we need to.\n  // Fiber  fiber  alternate fiber\n  alternate: Fiber | null,\n\n  // Time spent rendering this Fiber and its descendants for the current update.\n  // This tells us how well the tree makes use of sCU for memoization.\n  // It is reset to 0 each time we render and only updated when we don't bailout.\n  // This field is only set when the enableProfilerTimer flag is enabled.\n  actualDuration?: number,\n\n  // If the Fiber is currently active in the \"render\" phase,\n  // This marks the time at which the work began.\n  // This field is only set when the enableProfilerTimer flag is enabled.\n  actualStartTime?: number,\n\n  // Duration of the most recent render time for this Fiber.\n  // This value is not updated when we bailout for memoization purposes.\n  // This field is only set when the enableProfilerTimer flag is enabled.\n  selfBaseDuration?: number,\n\n  // Sum of base times for all descendants of this Fiber.\n  // This value bubbles up during the \"complete\" phase.\n  // This field is only set when the enableProfilerTimer flag is enabled.\n  treeBaseDuration?: number,\n|};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n\n\n\n\n * stateNode  fiberRoot \n * return  parent fiber\n * updateQueue  schedule fiber  reconciliation  schedule  update\n * expirationTime fiber  stack reconciliation \n * alternate  fiber  fiber fiber \n\n\n# fiber \n\nfiber  21 \n\nexport const FunctionComponent = 0; // \nexport const ClassComponent = 1; // \nexport const IndeterminateComponent = 2; // Before we know whether it is function or class\nexport const HostRoot = 3; // Root of a host tree. Could be nested inside another node.\nexport const HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\nexport const HostComponent = 5;\nexport const HostText = 6;\nexport const Fragment = 7;\nexport const Mode = 8;\nexport const ContextConsumer = 9;\nexport const ContextProvider = 10;\nexport const ForwardRef = 11;\nexport const Profiler = 12;\nexport const SuspenseComponent = 13;\nexport const MemoComponent = 14;\nexport const SimpleMemoComponent = 15;\nexport const LazyComponent = 16;\nexport const IncompleteClassComponent = 17;\nexport const DehydratedFragment = 18;\nexport const SuspenseListComponent = 19;\nexport const FundamentalComponent = 20;\nexport const ScopeComponent = 21;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# fiber \n\nfiber  createFiber \n\nconst createFiber = function(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n): Fiber {\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\nfunction FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n) {\n  // Instancefiber \n  this.tag = tag;\n  this.key = key;\n  this.elementType = null;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiberfiber \n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n\n  this.mode = mode;\n\n  // Effectseffect \n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n  this.childExpirationTime = NoWork;\n\n  this.alternate = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n alternate fiber:\n\nfunction createWorkInProgress(\n  current: Fiber, //  fiber\n  pendingProps: any, //  props\n  expirationTime: ExpirationTime, // \n): Fiber {\n  let workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    //  alternate fiber  fiber,  alternate fiber\n    workInProgress = createFiber(\n      current.tag,\n      pendingProps,\n      current.key,\n      current.mode,\n    );\n    workInProgress.elementType = current.elementType;\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    // double buffering pooling technique \n    workInProgress.alternate = current;\n    // workInProgresscurrent.alternate\n    current.alternate = workInProgress;\n  } else {\n    //   alternate fiber   alternate fiber\n    // \n    workInProgress.pendingProps = pendingProps;\n\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n  }\n\n  workInProgress.childExpirationTime = current.childExpirationTime;\n  workInProgress.expirationTime = current.expirationTime;\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n\n  // Clone the dependencies object. This is mutated during the render phase, so\n  // it cannot be shared with the current fiber.\n  const currentDependencies = current.dependencies;\n  workInProgress.dependencies =\n    currentDependencies === null\n      ? null\n      : {\n          expirationTime: currentDependencies.expirationTime,\n          firstContext: currentDependencies.firstContext,\n          responders: currentDependencies.responders,\n        };\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  return workInProgress;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n *  fiber  alternate  alternate alternate fiber\n * workInProgress  current  alternate  fiber alternate  fiber \n * workInProgress  fiber  stable versioncurrent  fiber  beta version workInProgress schedule  rendercurrent  workInProgress\n\n fiber   FiberRoot\n\n\n# FiberRoot\n\n\n# FiberRoot \n\n react-reconciler  ReactFiberRoot.js  FiberRoot \n\nexport type FiberRoot = {\n  ...BaseFiberRootProperties,\n  ...ProfilingOnlyFiberRootProperties,\n  ...SuspenseCallbackOnlyFiberRootProperties,\n};\n\n\n1\n2\n3\n4\n5\n\n\n BaseFiberRootProperties\n\ntype BaseFiberRootProperties = {|\n  // The type of root (legacy, batched, concurrent, etc.)\n  // fiberRoot \n  // export type RootTag = 0 | 1 | 2;\n  // export const LegacyRoot = 0;\n  // export const BatchedRoot = 1;\n  // export const ConcurrentRoot = 2;\n  tag: RootTag,\n\n  // Any additional information from the host associated with this root.\n  // \n  containerInfo: any,\n  // Used only by persistent updates.\n  pendingChildren: any,\n  // The currently active root fiber. This is the mutable root of the tree.\n  //  Fiber \n  current: Fiber,\n\n  pingCache:\n    | WeakMap<Thenable, Set<ExpirationTime>>\n    | Map<Thenable, Set<ExpirationTime>>\n    | null,\n  //  commit  fiber \n  finishedExpirationTime: ExpirationTime,\n  // A finished work-in-progress HostRoot that's ready to be committed.\n  //  commit  FiberHostRoot\n  finishedWork: Fiber | null,\n  // Timeout handle returned by setTimeout. Used to cancel a pending timeout, if\n  // it's superseded by a new one.\n  timeoutHandle: TimeoutHandle | NoTimeout,\n  // Top context object, used by renderSubtreeIntoContainer\n  //  context \n  context: Object | null,\n  pendingContext: Object | null,\n  // Determines if we should attempt to hydrate on the initial mount\n  // hydrate\n  +hydrate: boolean,\n  // List of top-level batches. This list indicates whether a commit should be\n  // deferred. Also contains completion callbacks.\n  // TODO: Lift this into the renderer\n  firstBatch: Batch | null,\n  // Node returned by Scheduler.scheduleCallback\n  callbackNode: *,\n  // Expiration of the callback associated with this root\n  // callback \n  callbackExpirationTime: ExpirationTime,\n  // Priority of the callback associated with this root\n  callbackPriority: ReactPriorityLevel,\n  // The earliest pending expiration time that exists in the tree\n  firstPendingTime: ExpirationTime,\n  // The earliest suspended expiration time that exists in the tree\n  firstSuspendedTime: ExpirationTime,\n  // The latest suspended expiration time that exists in the tree\n  lastSuspendedTime: ExpirationTime,\n  // The next known expiration time after the suspended range\n  nextKnownPendingLevel: ExpirationTime,\n  // The latest time at which a suspended component pinged the root to\n  // render again\n  lastPingedTime: ExpirationTime,\n  lastExpiredTime: ExpirationTime,\n|};\n\n// FiberRootNode \nfunction FiberRootNode(containerInfo, tag, hydrate) {\n  this.tag = tag;\n  this.current = null;\n  this.containerInfo = containerInfo;\n  this.pendingChildren = null;\n  this.pingCache = null;\n  this.finishedExpirationTime = NoWork;\n  this.finishedWork = null;\n  this.timeoutHandle = noTimeout;\n  this.context = null;\n  this.pendingContext = null;\n  this.hydrate = hydrate;\n  this.firstBatch = null;\n  this.callbackNode = null;\n  this.callbackPriority = NoPriority;\n  this.firstPendingTime = NoWork;\n  this.firstSuspendedTime = NoWork;\n  this.lastSuspendedTime = NoWork;\n  this.nextKnownPendingLevel = NoWork;\n  this.lastPingedTime = NoWork;\n  this.lastExpiredTime = NoWork;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n\n#  FiberRoot\n\nFiberRoot  createFiberRoot \n\nfunction createFiberRoot(\n  // \n  containerInfo: any,\n  // FiberRoot \n  tag: RootTag,\n  hydrate: boolean,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n): FiberRoot {\n  const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any);\n  //  HostFiberRoot HostFiberRoot   FiberRoot.current \n  const uninitializedFiber = createHostRootFiber(tag);\n  root.current = uninitializedFiber;\n  //  FiberRoot  HostFiberRoot.stateNode \n  uninitializedFiber.stateNode = root;\n\n  return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n\n * double buffering pooling technique FiberRoot  HostFiberRoot  Fiber  HostFiberRoot  FiberRoot  HostFiberRoot  FiberRoot \n * FiberRoot  FiberTree  Commit  HostFiberRoot HostFiberRoot  FiberTree \n\n\n# HostFiberRoot\n\nHostFiberRoot  Fiber FiberTree \n\n HostFiberRoot \n\nfunction createHostRootFiber(tag: RootTag): Fiber {\n  let mode;\n  if (tag === ConcurrentRoot) {\n    mode = ConcurrentMode | BatchedMode | StrictMode;\n  } else if (tag === BatchedRoot) {\n    mode = BatchedMode | StrictMode;\n  } else {\n    mode = NoMode;\n  }\n\n  return createFiber(HostRoot, null, null, mode);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n *  createFiber  HostFiberRoot HostFiberRoot  Fiber Fiber  HostRoot\n\n\n# ReactChildFiber\n\n FiberRoot  HostFiberRoot  fiber react-reconciler  ReactChildFiber.js \n\n//  ReactChildFiber\nexport const reconcileChildFibers = ChildReconciler(true);\n//  ReactChildFiber\nexport const mountChildFibers = ChildReconciler(false);\n\n\n1\n2\n3\n4\n\n\n",normalizedContent:"# \n\n\n\n * \n * fiber reconciliation\n   * reconciliation\n   * fiber \n   * \n   * fiberfiber \n * fiber \n   * fiber \n   * fiber \n   * fiber \n * fiberroot\n   * fiberroot \n   *  fiberroot\n * hostfiberroot\n * reactchildfiber\n\n\n\n react-reconciler \n\n\n# fiber reconciliation\n\n\n# reconciliation\n\n reconciliation  render \n\nreact 15.x  stack reconciler \n\nfiber reconciliation  react16 \n\n\n# fiber \n\nfiber fiber  fiber tree\n\nfiber \n\n * \n * \n * \n * render \n * \n\n\n# \n\n api\n\nrequestidlecallback: \nrequestanimationframe: \n\n\n1\n2\n\n * requestidlecallback  idle callback  deadline ui \n * requestanimationframe \n\n api  js \n\n\n# fiberfiber \n\n * fiber fiber tree fiber root \n * fiber fiber \n\n\n# fiber \n\n\n# fiber \n\n react-reconciler   fiber dev \n\n// a fiber is work on a component that needs to be done or was done. there can\n// be more than one per component.\n// fiber  fiber\nexport type fiber = {|\n  // these first fields are conceptually members of an instance. this used to\n  // be split into a separate type and intersected with the other fiber fields,\n  // but until flow fixes its intersection bugs, we've merged them into a\n  // single type.\n\n  // an instance is shared between all versions of a component. we can easily\n  // break this out into a separate object to avoid copying so much to the\n  // alternate versions of the tree. we put this on a single object for now to\n  // minimize the number of objects created during the initial render.\n  //  fiber \n\n  // tag identifying the type of fiber.\n  //  fiber :0-21\n  tag: worktag,\n\n  // unique identifier of this child.\n  // fiber  key \n  key: null | string,\n\n  // the value of element.type which is used to preserve the identity during\n  // reconciliation of this child.\n  //  element.type\n  elementtype: any,\n\n  // the resolved function/class/ associated with this fiber.\n  // fiberfunction/class/module.\n  type: any,\n\n  // the local state associated with this fiber.\n  // fiberfiberroot\n  statenode: any,\n\n  // conceptual aliases\n  // parent : instance -> return the parent happens to be the same as the\n  // return fiber since we've merged the fiber and instance.\n\n  // remaining fields belong to fiber\n\n  // the fiber to return to after finishing processing this one.\n  // this is effectively the parent, but there can be multiple parents (two)\n  // so this is only the parent of the thing we're currently processing.\n  // it is conceptually the same as the return address of a stack frame.\n  //  fiber  fiber fiber\n  return: fiber | null,\n\n  // singly linked list tree structure.\n  //  fiber  fiber\n  child: fiber | null,\n  sibling: fiber | null,\n  index: number,\n\n  // the ref last used to attach this node.\n  // i'll avoid adding an owner field for prod and model that as functions.\n  ref: null | (((handle: mixed) => void) & {_stringref: ?string}) | refobject,\n\n  // input is the data coming into process this fiber. arguments. props.\n  //  work-i-progress  props\n  pendingprops: any, // this type will be more specific once we overload the tag.\n  //  props\n  memoizedprops: any, // the props used to create the output.\n\n  // a queue of state updates and callbacks.\n  // \n  updatequeue: updatequeue<any> | null,\n\n  // the state used to create the output\n  memoizedstate: any,\n\n  // dependencies (contexts, events) for this fiber, if it has any\n  // fiber \n  dependencies: dependencies | null,\n\n  // bitfield that describes properties about the fiber and its subtree. e.g.\n  // the concurrentmode flag indicates whether the subtree should be async-by-\n  // default. when a fiber is created, it inherits the mode of its\n  // parent. additional flags can be set at creation time, but after that the\n  // value should remain unchanged throughout the fiber's lifetime, particularly\n  // before its child fibers are created.\n  //  fiber  fiber tree  nomodestrictmode\n  mode: typeofmode,\n\n  // effect\n  // effect \n  effecttag: sideeffecttag,\n\n  // singly linked list fast path to the next fiber with side-effects.\n  //  effect\n  nexteffect: fiber | null,\n\n  // the first and last fiber with side-effect within this subtree. this allows\n  // us to reuse a slice of the linked list when we reuse the work done within\n  // this fiber.\n  //  pending effect   effect.\n  firsteffect: fiber | null,\n  lasteffect: fiber | null,\n\n  // represents a time in the future by which this work should be completed.\n  // does not include work found in its subtree.\n  // expirationtime \n  expirationtime: expirationtime,\n\n  // this is used to quickly determine if a subtree has no pending changes.\n  //  expirationtime \n  childexpirationtime: expirationtime,\n\n  // this is a pooled version of a fiber. every fiber that gets updated will\n  // eventually have a pair. there are cases when we can clean up pairs to save\n  // memory if we need to.\n  // fiber  fiber  alternate fiber\n  alternate: fiber | null,\n\n  // time spent rendering this fiber and its descendants for the current update.\n  // this tells us how well the tree makes use of scu for memoization.\n  // it is reset to 0 each time we render and only updated when we don't bailout.\n  // this field is only set when the enableprofilertimer flag is enabled.\n  actualduration?: number,\n\n  // if the fiber is currently active in the \"render\" phase,\n  // this marks the time at which the work began.\n  // this field is only set when the enableprofilertimer flag is enabled.\n  actualstarttime?: number,\n\n  // duration of the most recent render time for this fiber.\n  // this value is not updated when we bailout for memoization purposes.\n  // this field is only set when the enableprofilertimer flag is enabled.\n  selfbaseduration?: number,\n\n  // sum of base times for all descendants of this fiber.\n  // this value bubbles up during the \"complete\" phase.\n  // this field is only set when the enableprofilertimer flag is enabled.\n  treebaseduration?: number,\n|};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n\n\n\n\n * statenode  fiberroot \n * return  parent fiber\n * updatequeue  schedule fiber  reconciliation  schedule  update\n * expirationtime fiber  stack reconciliation \n * alternate  fiber  fiber fiber \n\n\n# fiber \n\nfiber  21 \n\nexport const functioncomponent = 0; // \nexport const classcomponent = 1; // \nexport const indeterminatecomponent = 2; // before we know whether it is function or class\nexport const hostroot = 3; // root of a host tree. could be nested inside another node.\nexport const hostportal = 4; // a subtree. could be an entry point to a different renderer.\nexport const hostcomponent = 5;\nexport const hosttext = 6;\nexport const fragment = 7;\nexport const mode = 8;\nexport const contextconsumer = 9;\nexport const contextprovider = 10;\nexport const forwardref = 11;\nexport const profiler = 12;\nexport const suspensecomponent = 13;\nexport const memocomponent = 14;\nexport const simplememocomponent = 15;\nexport const lazycomponent = 16;\nexport const incompleteclasscomponent = 17;\nexport const dehydratedfragment = 18;\nexport const suspenselistcomponent = 19;\nexport const fundamentalcomponent = 20;\nexport const scopecomponent = 21;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# fiber \n\nfiber  createfiber \n\nconst createfiber = function(\n  tag: worktag,\n  pendingprops: mixed,\n  key: null | string,\n  mode: typeofmode,\n): fiber {\n  return new fibernode(tag, pendingprops, key, mode);\n};\n\nfunction fibernode(\n  tag: worktag,\n  pendingprops: mixed,\n  key: null | string,\n  mode: typeofmode,\n) {\n  // instancefiber \n  this.tag = tag;\n  this.key = key;\n  this.elementtype = null;\n  this.type = null;\n  this.statenode = null;\n\n  // fiberfiber \n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingprops = pendingprops;\n  this.memoizedprops = null;\n  this.updatequeue = null;\n  this.memoizedstate = null;\n  this.dependencies = null;\n\n  this.mode = mode;\n\n  // effectseffect \n  this.effecttag = noeffect;\n  this.nexteffect = null;\n\n  this.firsteffect = null;\n  this.lasteffect = null;\n\n  this.expirationtime = nowork;\n  this.childexpirationtime = nowork;\n\n  this.alternate = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n alternate fiber:\n\nfunction createworkinprogress(\n  current: fiber, //  fiber\n  pendingprops: any, //  props\n  expirationtime: expirationtime, // \n): fiber {\n  let workinprogress = current.alternate;\n  if (workinprogress === null) {\n    // we use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. we pool the \"other\" unused\n    // node that we're free to reuse. this is lazily created to avoid allocating\n    // extra objects for things that are never updated. it also allow us to\n    // reclaim the extra memory if needed.\n    //  alternate fiber  fiber,  alternate fiber\n    workinprogress = createfiber(\n      current.tag,\n      pendingprops,\n      current.key,\n      current.mode,\n    );\n    workinprogress.elementtype = current.elementtype;\n    workinprogress.type = current.type;\n    workinprogress.statenode = current.statenode;\n\n    // double buffering pooling technique \n    workinprogress.alternate = current;\n    // workinprogresscurrent.alternate\n    current.alternate = workinprogress;\n  } else {\n    //   alternate fiber   alternate fiber\n    // \n    workinprogress.pendingprops = pendingprops;\n\n    // we already have an alternate.\n    // reset the effect tag.\n    workinprogress.effecttag = noeffect;\n\n    // the effect list is no longer valid.\n    workinprogress.nexteffect = null;\n    workinprogress.firsteffect = null;\n    workinprogress.lasteffect = null;\n  }\n\n  workinprogress.childexpirationtime = current.childexpirationtime;\n  workinprogress.expirationtime = current.expirationtime;\n\n  workinprogress.child = current.child;\n  workinprogress.memoizedprops = current.memoizedprops;\n  workinprogress.memoizedstate = current.memoizedstate;\n  workinprogress.updatequeue = current.updatequeue;\n\n  // clone the dependencies object. this is mutated during the render phase, so\n  // it cannot be shared with the current fiber.\n  const currentdependencies = current.dependencies;\n  workinprogress.dependencies =\n    currentdependencies === null\n      ? null\n      : {\n          expirationtime: currentdependencies.expirationtime,\n          firstcontext: currentdependencies.firstcontext,\n          responders: currentdependencies.responders,\n        };\n\n  // these will be overridden during the parent's reconciliation\n  workinprogress.sibling = current.sibling;\n  workinprogress.index = current.index;\n  workinprogress.ref = current.ref;\n\n  return workinprogress;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n *  fiber  alternate  alternate alternate fiber\n * workinprogress  current  alternate  fiber alternate  fiber \n * workinprogress  fiber  stable versioncurrent  fiber  beta version workinprogress schedule  rendercurrent  workinprogress\n\n fiber   fiberroot\n\n\n# fiberroot\n\n\n# fiberroot \n\n react-reconciler  reactfiberroot.js  fiberroot \n\nexport type fiberroot = {\n  ...basefiberrootproperties,\n  ...profilingonlyfiberrootproperties,\n  ...suspensecallbackonlyfiberrootproperties,\n};\n\n\n1\n2\n3\n4\n5\n\n\n basefiberrootproperties\n\ntype basefiberrootproperties = {|\n  // the type of root (legacy, batched, concurrent, etc.)\n  // fiberroot \n  // export type roottag = 0 | 1 | 2;\n  // export const legacyroot = 0;\n  // export const batchedroot = 1;\n  // export const concurrentroot = 2;\n  tag: roottag,\n\n  // any additional information from the host associated with this root.\n  // \n  containerinfo: any,\n  // used only by persistent updates.\n  pendingchildren: any,\n  // the currently active root fiber. this is the mutable root of the tree.\n  //  fiber \n  current: fiber,\n\n  pingcache:\n    | weakmap<thenable, set<expirationtime>>\n    | map<thenable, set<expirationtime>>\n    | null,\n  //  commit  fiber \n  finishedexpirationtime: expirationtime,\n  // a finished work-in-progress hostroot that's ready to be committed.\n  //  commit  fiberhostroot\n  finishedwork: fiber | null,\n  // timeout handle returned by settimeout. used to cancel a pending timeout, if\n  // it's superseded by a new one.\n  timeouthandle: timeouthandle | notimeout,\n  // top context object, used by rendersubtreeintocontainer\n  //  context \n  context: object | null,\n  pendingcontext: object | null,\n  // determines if we should attempt to hydrate on the initial mount\n  // hydrate\n  +hydrate: boolean,\n  // list of top-level batches. this list indicates whether a commit should be\n  // deferred. also contains completion callbacks.\n  // todo: lift this into the renderer\n  firstbatch: batch | null,\n  // node returned by scheduler.schedulecallback\n  callbacknode: *,\n  // expiration of the callback associated with this root\n  // callback \n  callbackexpirationtime: expirationtime,\n  // priority of the callback associated with this root\n  callbackpriority: reactprioritylevel,\n  // the earliest pending expiration time that exists in the tree\n  firstpendingtime: expirationtime,\n  // the earliest suspended expiration time that exists in the tree\n  firstsuspendedtime: expirationtime,\n  // the latest suspended expiration time that exists in the tree\n  lastsuspendedtime: expirationtime,\n  // the next known expiration time after the suspended range\n  nextknownpendinglevel: expirationtime,\n  // the latest time at which a suspended component pinged the root to\n  // render again\n  lastpingedtime: expirationtime,\n  lastexpiredtime: expirationtime,\n|};\n\n// fiberrootnode \nfunction fiberrootnode(containerinfo, tag, hydrate) {\n  this.tag = tag;\n  this.current = null;\n  this.containerinfo = containerinfo;\n  this.pendingchildren = null;\n  this.pingcache = null;\n  this.finishedexpirationtime = nowork;\n  this.finishedwork = null;\n  this.timeouthandle = notimeout;\n  this.context = null;\n  this.pendingcontext = null;\n  this.hydrate = hydrate;\n  this.firstbatch = null;\n  this.callbacknode = null;\n  this.callbackpriority = nopriority;\n  this.firstpendingtime = nowork;\n  this.firstsuspendedtime = nowork;\n  this.lastsuspendedtime = nowork;\n  this.nextknownpendinglevel = nowork;\n  this.lastpingedtime = nowork;\n  this.lastexpiredtime = nowork;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n\n#  fiberroot\n\nfiberroot  createfiberroot \n\nfunction createfiberroot(\n  // \n  containerinfo: any,\n  // fiberroot \n  tag: roottag,\n  hydrate: boolean,\n  hydrationcallbacks: null | suspensehydrationcallbacks,\n): fiberroot {\n  const root: fiberroot = (new fiberrootnode(containerinfo, tag, hydrate): any);\n  //  hostfiberroot hostfiberroot   fiberroot.current \n  const uninitializedfiber = createhostrootfiber(tag);\n  root.current = uninitializedfiber;\n  //  fiberroot  hostfiberroot.statenode \n  uninitializedfiber.statenode = root;\n\n  return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n\n * double buffering pooling technique fiberroot  hostfiberroot  fiber  hostfiberroot  fiberroot  hostfiberroot  fiberroot \n * fiberroot  fibertree  commit  hostfiberroot hostfiberroot  fibertree \n\n\n# hostfiberroot\n\nhostfiberroot  fiber fibertree \n\n hostfiberroot \n\nfunction createhostrootfiber(tag: roottag): fiber {\n  let mode;\n  if (tag === concurrentroot) {\n    mode = concurrentmode | batchedmode | strictmode;\n  } else if (tag === batchedroot) {\n    mode = batchedmode | strictmode;\n  } else {\n    mode = nomode;\n  }\n\n  return createfiber(hostroot, null, null, mode);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n *  createfiber  hostfiberroot hostfiberroot  fiber fiber  hostroot\n\n\n# reactchildfiber\n\n fiberroot  hostfiberroot  fiber react-reconciler  reactchildfiber.js \n\n//  reactchildfiber\nexport const reconcilechildfibers = childreconciler(true);\n//  reactchildfiber\nexport const mountchildfibers = childreconciler(false);\n\n\n1\n2\n3\n4\n\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"ReactChildFiber ",frontmatter:{title:"ReactChildFiber ",date:"2022-04-14T22:02:21.000Z",permalink:"/react/reconciliation/reactChildFiber/",categories:["react","reconciliation"],tags:[null]},regularPath:"/10.react/20.%E8%B0%83%E5%92%8C%EF%BC%88Reconciliation%EF%BC%89/20.reactChildFiber.html",relativePath:"10.react/20.Reconciliation/20.reactChildFiber.md",key:"v-27daf196",path:"/react/reconciliation/reactChildFiber/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"reconcileChildFibers",slug:"reconcilechildfibers",normalizedTitle:"reconcilechildfibers",charIndex:17},{level:2,title:"reconcileSingleElement",slug:"reconcilesingleelement",normalizedTitle:"reconcilesingleelement",charIndex:41},{level:2,title:"reconcileSinglePortal",slug:"reconcilesingleportal",normalizedTitle:"reconcilesingleportal",charIndex:67},{level:2,title:"reconcileSingleTextNode",slug:"reconcilesingletextnode",normalizedTitle:"reconcilesingletextnode",charIndex:92},{level:2,title:"reconcileChildrenArray",slug:"reconcilechildrenarray",normalizedTitle:"reconcilechildrenarray",charIndex:119},{level:3,title:"updateSlot",slug:"updateslot",normalizedTitle:"updateslot",charIndex:147},{level:3,title:"placeChild",slug:"placechild",normalizedTitle:"placechild",charIndex:163},{level:3,title:"updateFromMap",slug:"updatefrommap",normalizedTitle:"updatefrommap",charIndex:179},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:196}],readingTime:{text:"13 min read",minutes:12.85,time:771e3,words:2570},headersStr:" reconcileChildFibers reconcileSingleElement reconcileSinglePortal reconcileSingleTextNode reconcileChildrenArray updateSlot placeChild updateFromMap ",content:"# \n\n\n\n * \n * reconcileChildFibers\n * reconcileSingleElement\n * reconcileSinglePortal\n * reconcileSingleTextNode\n * reconcileChildrenArray\n   * updateSlot\n   * placeChild\n   * updateFromMap\n * \n\n\n\nReactChildFiber  ChildReconciler \n\nexport const reconcileChildFibers = ChildReconciler(true);\nexport const mountChildFibers = ChildReconciler(false);\n\n\n1\n2\n\n\n\n# reconcileChildFibers\n\nChildReconciler(shouldTrackSideEffects)\n\nChildReconciler  reconcileChildFibers shouldTrackSideEffects  reconcileChildFibers  fiber\n\n * mount shouldTrackSideEffects  false\n * render shouldTrackSideEffects  true\n *  shouldTrackSideEffects  mount  render \n\n reconcileChildFibers \n\nfunction reconcileChildFibers(\n  returnFiber: Fiber, //  fiber\n  currentFirstChild: Fiber | null, //  child\n  newChild: any, //  Child\n  expirationTime: ExpirationTime,\n): Fiber | null {\n  // This function is not recursive.\n  // If the top level item is an array, we treat it as a set of children,\n  // not as a fragment. Nested arrays on the other hand will be treated as\n  // fragment nodes. Recursion happens at the normal flow.\n\n  // Handle top level unkeyed fragments as if they were arrays.\n  // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n  // We treat the ambiguous cases above the same.\n  const isUnkeyedTopLevelFragment =\n    typeof newChild === 'object' &&\n    newChild !== null &&\n    newChild.type === REACT_FRAGMENT_TYPE &&\n    newChild.key === null;\n  //  key  fragment  children Children \n  //  <></> \n  if (isUnkeyedTopLevelFragment) {\n    newChild = newChild.props.children;\n  }\n\n  // Handle object types\n  const isObject = typeof newChild === 'object' && newChild !== null;\n  // newChild  ReactElement\n  if (isObject) {\n    switch (newChild.$$typeof) {\n      //  ReactElement fragment\n      case REACT_ELEMENT_TYPE:\n        return placeSingleChild(\n          reconcileSingleElement(\n            returnFiber,\n            currentFirstChild,\n            newChild,\n            expirationTime,\n          ),\n        );\n      // Portal ReactElement\n      case REACT_PORTAL_TYPE:\n        return placeSingleChild(\n          reconcileSinglePortal(\n            returnFiber,\n            currentFirstChild,\n            newChild,\n            expirationTime,\n          ),\n        );\n    }\n  }\n  // newChild \n  if (typeof newChild === 'string' || typeof newChild === 'number') {\n    return placeSingleChild(\n      reconcileSingleTextNode(\n        returnFiber,\n        currentFirstChild,\n        '' + newChild,\n        expirationTime,\n      ),\n    );\n  }\n\n  // children \n  if (isArray(newChild)) {\n    return reconcileChildrenArray(\n      returnFiber,\n      currentFirstChild,\n      newChild,\n      expirationTime,\n    );\n  }\n\n  // newChild \n  if (getIteratorFn(newChild)) {\n    return reconcileChildrenIterator(\n      returnFiber,\n      currentFirstChild,\n      newChild,\n      expirationTime,\n    );\n  }\n\n  if (isObject) {\n    throwOnInvalidObjectType(returnFiber, newChild);\n  }\n\n  if (__DEV__) {\n    if (typeof newChild === 'function') {\n      warnOnFunctionType();\n    }\n  }\n  // newChild  undefined  key  fragment \n  if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {\n    // If the new child is undefined, and the return fiber is a composite\n    // component, throw an error. If Fiber return types are disabled,\n    // we already threw above.\n    switch (returnFiber.tag) {\n      // \n      case ClassComponent: {\n        if (__DEV__) {\n          const instance = returnFiber.stateNode;\n          if (instance.render._isMockFunction) {\n            // We allow auto-mocks to proceed as if they're returning null.\n            break;\n          }\n        }\n      }\n      // Intentionally fall through to the next case, which handles both\n      // functions and classes\n      // eslint-disable-next-lined no-fallthrough\n      // \n      case FunctionComponent: {\n        const Component = returnFiber.type;\n        invariant(\n          false,\n          '%s(...): Nothing was returned from render. This usually means a ' +\n            'return statement is missing. Or, to render nothing, ' +\n            'return null.',\n          Component.displayName || Component.name || 'Component',\n        );\n      }\n    }\n  }\n  //  currentFirstChild  null\n  // Remaining cases are all treated as empty.\n  return deleteRemainingChildren(returnFiber, currentFirstChild);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n\n\n fiberreturnFiber fibercurrentFirstChild ReactElement (newChild) fiber\n\n\n\n * isUnkeyedTopLevelFragment  NewChild  FRAGMENT  newChild.props.children   <></> \n *  newChild  ReactElement SingleElement  SinglePortal  reconcileSingleElement  reconcileSinglePortal \n *  newChild  string  number  reconcileSingleTextNode \n *  newChild  reconcileChildrenArray \n *  newChild  reconcileChildrenIterator \n * \n * placeSingleChild  newFiber  shouldTrackSideEffects  true  \"Placement\"  effectTag \n\n\n# reconcileSingleElement\n\n\n\nfunction reconcileSingleElement(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  element: ReactElement,\n  expirationTime: ExpirationTime,\n): Fiber {\n  const key = element.key;\n  let child = currentFirstChild;\n  while (child !== null) {\n    // TODO: If key === null and child.key === null, then this only applies to\n    // the first item in the list.\n    if (child.key === key) {\n      // element key  fiber\n      if (\n        child.tag === Fragment\n          ? element.type === REACT_FRAGMENT_TYPE\n          : child.elementType === element.type ||\n            // Keep this check inline so it only runs on the false path:\n            (__DEV__\n              ? isCompatibleFamilyForHotReloading(child, element)\n              : false)\n      ) {\n        // \n        // \n        deleteRemainingChildren(returnFiber, child.sibling);\n        // merge props\n        const existing = useFiber(\n          child,\n          element.type === REACT_FRAGMENT_TYPE\n            ? element.props.children\n            : element.props,\n          expirationTime,\n        );\n        existing.ref = coerceRef(returnFiber, child, element);\n        existing.return = returnFiber;\n        if (__DEV__) {\n          existing._debugSource = element._source;\n          existing._debugOwner = element._owner;\n        }\n        //   key  return\n        return existing;\n      } else {\n        // \n        deleteRemainingChildren(returnFiber, child);\n        break;\n      }\n    } else {\n      //  element  key  fiber\n      deleteChild(returnFiber, child);\n    }\n    child = child.sibling;\n  }\n // child  null key \n //  merge props  fiber, fiber\n  if (element.type === REACT_FRAGMENT_TYPE) {\n    //  fragment  fiber\n    const created = createFiberFromFragment(\n      element.props.children,\n      returnFiber.mode,\n      expirationTime,\n      element.key,\n    );\n    created.return = returnFiber;\n    return created;\n  } else {\n    const created = createFiberFromElement(\n      element,\n      returnFiber.mode,\n      expirationTime,\n    );\n    created.ref = coerceRef(returnFiber, currentFirstChild, element);\n    created.return = returnFiber;\n    return created;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n *  while  child  newChild  key  fiber child  fragment fiber  fiber key  fiber \n *  fiber  fiber  useFiber  createWorkInProgress  fiber  workInProgress  fiber  pendingProps \n\nfunction useFiber(\n  fiber: Fiber,\n  pendingProps: mixed,\n  expirationTime: ExpirationTime,\n): Fiber {\n  // merge fiber props   fiber\n  // We currently set sibling to null and index to 0 here because it is easy\n  // to forget to do before returning it. E.g. for the single child case.\n  //  work-in-progress  fiber element  props\n  const clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n  clone.index = 0;\n  clone.sibling = null;\n  return clone;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# reconcileSinglePortal\n\n portal  reconcileSingleElement \n\n\n# reconcileSingleTextNode\n\n key  fiber \n\nfunction reconcileSingleTextNode(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  textContent: string,\n  expirationTime: ExpirationTime,\n): Fiber {\n  // There's no need to check for keys on text nodes since we don't have a\n  // way to define them.\n  //  key child  HostText fiber\n  // \n  if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n    // We already have an existing node so let's just update it and delete\n    // the rest.\n    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n    const existing = useFiber(currentFirstChild, textContent, expirationTime);\n    existing.return = returnFiber;\n    return existing;\n  }\n  // The existing first child is not a text node so we need to create one\n  // and delete the existing ones.\n  //  text  fiber\n  deleteRemainingChildren(returnFiber, currentFirstChild);\n  const created = createFiberFromText(\n    textContent,\n    returnFiber.mode,\n    expirationTime,\n  );\n  created.return = returnFiber;\n  return created;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n\n *  currentFirstChild.tag === HostText  fiber  useFiber \n *  createFiberFromText \n\n\n# reconcileChildrenArray\n\n ReactElement stringNumbertextNode \n\n reconcileChildrenArray oldFiber  newChildrenoldFiber  fiber oldFiber.sibling  fiber  fiber newChildren  ReactElement  ReactElement \n\n oldFiber  old children old childnewChildren  old children new child\n\n reconcileChildrenArray \n\n function reconcileChildrenArray(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  newChildren: Array<*>, // newChildren  ReactElement \n  expirationTime: ExpirationTime,\n): Fiber | null {\n\n  if (__DEV__) {\n    // First, validate keys.\n    // dev  key \n    let knownKeys = null;\n    for (let i = 0; i < newChildren.length; i++) {\n      const child = newChildren[i];\n      knownKeys = warnOnInvalidKey(child, knownKeys);\n    }\n  }\n\n  let resultingFirstChild: Fiber | null = null;\n  let previousNewFiber: Fiber | null = null;\n\n  let oldFiber = currentFirstChild;\n  let lastPlacedIndex = 0;\n  let newIdx = 0;\n  let nextOldFiber = null;\n  //  new children \n  for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n    //  old child  new child \n    if (oldFiber.index > newIdx) {\n      nextOldFiber = oldFiber;\n      //  oldFiber null updateSlot \n      //  oldFiber \n      oldFiber = null;\n    } else {\n      //  old children\n      //  oldFiber.index <= newIdxnewIdx  0 oldFiber.index <=0\n      //  oldFiber.index === 0index \n      nextOldFiber = oldFiber.sibling;\n    }\n    //  key  fiber  null\n    const newFiber = updateSlot(\n      returnFiber,\n      oldFiber,\n      newChildren[newIdx],\n      expirationTime,\n    );\n    //  key \n    if (newFiber === null) {\n      // TODO: This breaks on empty slots like null children. That's\n      // unfortunate because it triggers the slow path all the time. We need\n      // a better way to communicate whether this was a miss or null,\n      // boolean, undefined, etc.\n      if (oldFiber === null) {\n        oldFiber = nextOldFiber;\n      }\n      // \n      break;\n    }\n    // old child \n    //  old child  nextOldFiber \n    if (shouldTrackSideEffects) {\n      if (oldFiber && newFiber.alternate === null) {\n        // We matched the slot, but we didn't reuse the existing fiber, so we\n        // need to delete the existing child.\n        deleteChild(returnFiber, oldFiber);\n      }\n    }\n    // \n    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n    // resultingFirstChild  new children \n    if (previousNewFiber === null) {\n      // TODO: Move out of the loop. This only happens for the first run.\n      resultingFirstChild = newFiber;\n    } else {\n      // TODO: Defer siblings if we're not at the right index for this slot.\n      // I.e. if we had null values before, then we want to defer this\n      // for each null value. However, we also don't want to call updateSlot\n      // with the previous one.\n      previousNewFiber.sibling = newFiber;\n    }\n    previousNewFiber = newFiber;\n    //  old child\n    oldFiber = nextOldFiber;\n  }\n  //  new children  old children 2old children new children \n  // \n  //  new children  old children \n  if (newIdx === newChildren.length) {\n    // We've reached the end of the new children. We can delete the rest.\n    deleteRemainingChildren(returnFiber, oldFiber);\n    return resultingFirstChild;\n  }\n  //  old children  new children \n  if (oldFiber === null) {\n    // If we don't have any more existing children we can choose a fast path\n    // since the rest will all be insertions.\n    // new children\n    for (; newIdx < newChildren.length; newIdx++) {\n      //  fiber \n      const newFiber = createChild(\n        returnFiber,\n        newChildren[newIdx],\n        expirationTime,\n      );\n      // \n      if (newFiber === null) {\n        continue;\n      }\n      // \n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      //  resultingFirstChild \n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n    }\n    //  new children \n    return resultingFirstChild;\n  }\n  //  return  3 \n  // \n  //  old children  key  key  fiber \n  // Add all children to a key map for quick lookups.\n  const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n  // Keep scanning and use the map to restore deleted items as moves.\n  //  key  ne children\n  for (; newIdx < newChildren.length; newIdx++) {\n    //  map  key  old child \n    // updateFromMap  Fiber\n    const newFiber = updateFromMap(\n      existingChildren,\n      returnFiber,\n      newIdx,\n      newChildren[newIdx],\n      expirationTime,\n    );\n    // resultingFirstChild \n    if (newFiber !== null) {\n      if (shouldTrackSideEffects) {\n        if (newFiber.alternate !== null) {\n          // The new fiber is a work in progress, but if there exists a\n          // current, that means that we reused the fiber. We need to delete\n          // it from the child list so that we don't add it to the deletion\n          // list.\n          //  map \n          existingChildren.delete(\n            newFiber.key === null ? newIdx : newFiber.key,\n          );\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        resultingFirstChild = newFiber;\n      } else {\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n    }\n  }\n\n  if (shouldTrackSideEffects) {\n    // Any existing children that weren't consumed above were deleted. We need\n    // to add them to the deletion list.\n    //  old children \n    existingChildren.forEach(child => deleteChild(returnFiber, child));\n  }\n\n  return resultingFirstChild;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n\n\nreact  childFiberArray \n\n * \n *  old children  new children  index  key updateSlot \n *  old children  Map<key, fiber>  new children map  key updateFromMap \n *  old children  new children \n *  old children  old children \n *  new children  new children \n *  new fibers resultingFirstChild\n\n reconcileChildrenArray  reconcileChildrenArray  key  key \n\n>  key  fiber  key  key \n\n createFiber  key  fiber  fiber  key  createFiber  key \n\nconst List = () => {\n  const arr = new Array(20).fill(0);\n  return arr.map(a => <p key={Math.random()}>{a}</p>)\n}\n\n\n1\n2\n3\n4\n\n\n\n\n key \n\n----------------------------------------\n\n\n\n\n# updateSlot\n\n old children  new children  key  null\n\nfunction updateSlot(\n  returnFiber: Fiber,\n  oldFiber: Fiber | null,\n  newChild: any,\n  expirationTime: ExpirationTime,\n): Fiber | null {\n  // Update the fiber if the keys match, otherwise return null.\n\n  const key = oldFiber !== null ? oldFiber.key : null;\n\n  if (typeof newChild === 'string' || typeof newChild === 'number') {\n    // Text nodes don't have keys. If the previous node is implicitly keyed\n    // we can continue to replace it without aborting even if it is not a text\n    // node.\n    if (key !== null) {\n      return null;\n    }\n    return updateTextNode(\n      returnFiber,\n      oldFiber,\n      '' + newChild,\n      expirationTime,\n    );\n  }\n\n  if (typeof newChild === 'object' && newChild !== null) {\n    switch (newChild.$$typeof) {\n      case REACT_ELEMENT_TYPE: {\n        if (newChild.key === key) {\n          if (newChild.type === REACT_FRAGMENT_TYPE) {\n            return updateFragment(\n              returnFiber,\n              oldFiber,\n              newChild.props.children,\n              expirationTime,\n              key,\n            );\n          }\n          return updateElement(\n            returnFiber,\n            oldFiber,\n            newChild,\n            expirationTime,\n          );\n        } else {\n          return null;\n        }\n      }\n      case REACT_PORTAL_TYPE: {\n        if (newChild.key === key) {\n          return updatePortal(\n            returnFiber,\n            oldFiber,\n            newChild,\n            expirationTime,\n          );\n        } else {\n          return null;\n        }\n      }\n    }\n\n    if (isArray(newChild) || getIteratorFn(newChild)) {\n      if (key !== null) {\n        return null;\n      }\n\n      return updateFragment(\n        returnFiber,\n        oldFiber,\n        newChild,\n        expirationTime,\n        null,\n      );\n    }\n\n    throwOnInvalidObjectType(returnFiber, newChild);\n  }\n\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n updateXXX  fiber  fiber  ReactElementPortalElement \n\n\n# placeChild\n\n fiber  'Placement'  move  insertion \n\nfunction placeChild(\n  newFiber: Fiber,\n  lastPlacedIndex: number,\n  newIndex: number,\n): number {\n  newFiber.index = newIndex;\n  if (!shouldTrackSideEffects) {\n    // Noop.\n    return lastPlacedIndex;\n  }\n  const current = newFiber.alternate;\n  if (current !== null) {\n    const oldIndex = current.index;\n    //  index   index \n    if (oldIndex < lastPlacedIndex) {\n      // This is a move.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    } else {\n      // index \n      // This item can stay in place.\n      return oldIndex;\n    }\n  } else {\n    //  index \n    // This is an insertion.\n    newFiber.effectTag = Placement;\n    return lastPlacedIndex;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n\n *  new children  placeChild   'move'  'insertion'  'Placement'  neFibers  DomTree  'Placement'  fiber.index  Fiber  index\n\n\n# updateFromMap\n\n old children  fiber fiber\n\n function updateFromMap(\n  existingChildren: Map<string | number, Fiber>,\n  returnFiber: Fiber,\n  newIdx: number,\n  newChild: any,\n  expirationTime: ExpirationTime,\n): Fiber | null {\n  if (typeof newChild === 'string' || typeof newChild === 'number') {\n    // Text nodes don't have keys, so we neither have to check the old nor\n    // new node for the key. If both are text nodes, they match.\n    const matchedFiber = existingChildren.get(newIdx) || null;\n    return updateTextNode(\n      returnFiber,\n      matchedFiber,\n      '' + newChild,\n      expirationTime,\n    );\n  }\n\n  if (typeof newChild === 'object' && newChild !== null) {\n    switch (newChild.$$typeof) {\n      case REACT_ELEMENT_TYPE: {\n        const matchedFiber =\n          existingChildren.get(\n            newChild.key === null ? newIdx : newChild.key,\n          ) || null;\n        if (newChild.type === REACT_FRAGMENT_TYPE) {\n          return updateFragment(\n            returnFiber,\n            matchedFiber,\n            newChild.props.children,\n            expirationTime,\n            newChild.key,\n          );\n        }\n        return updateElement(\n          returnFiber,\n          matchedFiber,\n          newChild,\n          expirationTime,\n        );\n      }\n      case REACT_PORTAL_TYPE: {\n        const matchedFiber =\n          existingChildren.get(\n            newChild.key === null ? newIdx : newChild.key,\n          ) || null;\n        return updatePortal(\n          returnFiber,\n          matchedFiber,\n          newChild,\n          expirationTime,\n        );\n      }\n    }\n\n    if (isArray(newChild) || getIteratorFn(newChild)) {\n      const matchedFiber = existingChildren.get(newIdx) || null;\n      return updateFragment(\n        returnFiber,\n        matchedFiber,\n        newChild,\n        expirationTime,\n        null,\n      );\n    }\n\n    throwOnInvalidObjectType(returnFiber, newChild);\n  }\n\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n *  existingChildren  matchedFiber \n *  fiber\n\n reconcileChildFibers  mount  render \n\n * mount  fiber\n * render  fiber \n\n\n# \n\n ReactChildFiber  SingleChild  ChildArray  ReactElement  Fiber  VNode Tree  FiberTree ",normalizedContent:"# \n\n\n\n * \n * reconcilechildfibers\n * reconcilesingleelement\n * reconcilesingleportal\n * reconcilesingletextnode\n * reconcilechildrenarray\n   * updateslot\n   * placechild\n   * updatefrommap\n * \n\n\n\nreactchildfiber  childreconciler \n\nexport const reconcilechildfibers = childreconciler(true);\nexport const mountchildfibers = childreconciler(false);\n\n\n1\n2\n\n\n\n# reconcilechildfibers\n\nchildreconciler(shouldtracksideeffects)\n\nchildreconciler  reconcilechildfibers shouldtracksideeffects  reconcilechildfibers  fiber\n\n * mount shouldtracksideeffects  false\n * render shouldtracksideeffects  true\n *  shouldtracksideeffects  mount  render \n\n reconcilechildfibers \n\nfunction reconcilechildfibers(\n  returnfiber: fiber, //  fiber\n  currentfirstchild: fiber | null, //  child\n  newchild: any, //  child\n  expirationtime: expirationtime,\n): fiber | null {\n  // this function is not recursive.\n  // if the top level item is an array, we treat it as a set of children,\n  // not as a fragment. nested arrays on the other hand will be treated as\n  // fragment nodes. recursion happens at the normal flow.\n\n  // handle top level unkeyed fragments as if they were arrays.\n  // this leads to an ambiguity between <>{[...]}</> and <>...</>.\n  // we treat the ambiguous cases above the same.\n  const isunkeyedtoplevelfragment =\n    typeof newchild === 'object' &&\n    newchild !== null &&\n    newchild.type === react_fragment_type &&\n    newchild.key === null;\n  //  key  fragment  children children \n  //  <></> \n  if (isunkeyedtoplevelfragment) {\n    newchild = newchild.props.children;\n  }\n\n  // handle object types\n  const isobject = typeof newchild === 'object' && newchild !== null;\n  // newchild  reactelement\n  if (isobject) {\n    switch (newchild.$$typeof) {\n      //  reactelement fragment\n      case react_element_type:\n        return placesinglechild(\n          reconcilesingleelement(\n            returnfiber,\n            currentfirstchild,\n            newchild,\n            expirationtime,\n          ),\n        );\n      // portal reactelement\n      case react_portal_type:\n        return placesinglechild(\n          reconcilesingleportal(\n            returnfiber,\n            currentfirstchild,\n            newchild,\n            expirationtime,\n          ),\n        );\n    }\n  }\n  // newchild \n  if (typeof newchild === 'string' || typeof newchild === 'number') {\n    return placesinglechild(\n      reconcilesingletextnode(\n        returnfiber,\n        currentfirstchild,\n        '' + newchild,\n        expirationtime,\n      ),\n    );\n  }\n\n  // children \n  if (isarray(newchild)) {\n    return reconcilechildrenarray(\n      returnfiber,\n      currentfirstchild,\n      newchild,\n      expirationtime,\n    );\n  }\n\n  // newchild \n  if (getiteratorfn(newchild)) {\n    return reconcilechildreniterator(\n      returnfiber,\n      currentfirstchild,\n      newchild,\n      expirationtime,\n    );\n  }\n\n  if (isobject) {\n    throwoninvalidobjecttype(returnfiber, newchild);\n  }\n\n  if (__dev__) {\n    if (typeof newchild === 'function') {\n      warnonfunctiontype();\n    }\n  }\n  // newchild  undefined  key  fragment \n  if (typeof newchild === 'undefined' && !isunkeyedtoplevelfragment) {\n    // if the new child is undefined, and the return fiber is a composite\n    // component, throw an error. if fiber return types are disabled,\n    // we already threw above.\n    switch (returnfiber.tag) {\n      // \n      case classcomponent: {\n        if (__dev__) {\n          const instance = returnfiber.statenode;\n          if (instance.render._ismockfunction) {\n            // we allow auto-mocks to proceed as if they're returning null.\n            break;\n          }\n        }\n      }\n      // intentionally fall through to the next case, which handles both\n      // functions and classes\n      // eslint-disable-next-lined no-fallthrough\n      // \n      case functioncomponent: {\n        const component = returnfiber.type;\n        invariant(\n          false,\n          '%s(...): nothing was returned from render. this usually means a ' +\n            'return statement is missing. or, to render nothing, ' +\n            'return null.',\n          component.displayname || component.name || 'component',\n        );\n      }\n    }\n  }\n  //  currentfirstchild  null\n  // remaining cases are all treated as empty.\n  return deleteremainingchildren(returnfiber, currentfirstchild);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n\n\n fiberreturnfiber fibercurrentfirstchild reactelement (newchild) fiber\n\n\n\n * isunkeyedtoplevelfragment  newchild  fragment  newchild.props.children   <></> \n *  newchild  reactelement singleelement  singleportal  reconcilesingleelement  reconcilesingleportal \n *  newchild  string  number  reconcilesingletextnode \n *  newchild  reconcilechildrenarray \n *  newchild  reconcilechildreniterator \n * \n * placesinglechild  newfiber  shouldtracksideeffects  true  \"placement\"  effecttag \n\n\n# reconcilesingleelement\n\n\n\nfunction reconcilesingleelement(\n  returnfiber: fiber,\n  currentfirstchild: fiber | null,\n  element: reactelement,\n  expirationtime: expirationtime,\n): fiber {\n  const key = element.key;\n  let child = currentfirstchild;\n  while (child !== null) {\n    // todo: if key === null and child.key === null, then this only applies to\n    // the first item in the list.\n    if (child.key === key) {\n      // element key  fiber\n      if (\n        child.tag === fragment\n          ? element.type === react_fragment_type\n          : child.elementtype === element.type ||\n            // keep this check inline so it only runs on the false path:\n            (__dev__\n              ? iscompatiblefamilyforhotreloading(child, element)\n              : false)\n      ) {\n        // \n        // \n        deleteremainingchildren(returnfiber, child.sibling);\n        // merge props\n        const existing = usefiber(\n          child,\n          element.type === react_fragment_type\n            ? element.props.children\n            : element.props,\n          expirationtime,\n        );\n        existing.ref = coerceref(returnfiber, child, element);\n        existing.return = returnfiber;\n        if (__dev__) {\n          existing._debugsource = element._source;\n          existing._debugowner = element._owner;\n        }\n        //   key  return\n        return existing;\n      } else {\n        // \n        deleteremainingchildren(returnfiber, child);\n        break;\n      }\n    } else {\n      //  element  key  fiber\n      deletechild(returnfiber, child);\n    }\n    child = child.sibling;\n  }\n // child  null key \n //  merge props  fiber, fiber\n  if (element.type === react_fragment_type) {\n    //  fragment  fiber\n    const created = createfiberfromfragment(\n      element.props.children,\n      returnfiber.mode,\n      expirationtime,\n      element.key,\n    );\n    created.return = returnfiber;\n    return created;\n  } else {\n    const created = createfiberfromelement(\n      element,\n      returnfiber.mode,\n      expirationtime,\n    );\n    created.ref = coerceref(returnfiber, currentfirstchild, element);\n    created.return = returnfiber;\n    return created;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n *  while  child  newchild  key  fiber child  fragment fiber  fiber key  fiber \n *  fiber  fiber  usefiber  createworkinprogress  fiber  workinprogress  fiber  pendingprops \n\nfunction usefiber(\n  fiber: fiber,\n  pendingprops: mixed,\n  expirationtime: expirationtime,\n): fiber {\n  // merge fiber props   fiber\n  // we currently set sibling to null and index to 0 here because it is easy\n  // to forget to do before returning it. e.g. for the single child case.\n  //  work-in-progress  fiber element  props\n  const clone = createworkinprogress(fiber, pendingprops, expirationtime);\n  clone.index = 0;\n  clone.sibling = null;\n  return clone;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# reconcilesingleportal\n\n portal  reconcilesingleelement \n\n\n# reconcilesingletextnode\n\n key  fiber \n\nfunction reconcilesingletextnode(\n  returnfiber: fiber,\n  currentfirstchild: fiber | null,\n  textcontent: string,\n  expirationtime: expirationtime,\n): fiber {\n  // there's no need to check for keys on text nodes since we don't have a\n  // way to define them.\n  //  key child  hosttext fiber\n  // \n  if (currentfirstchild !== null && currentfirstchild.tag === hosttext) {\n    // we already have an existing node so let's just update it and delete\n    // the rest.\n    deleteremainingchildren(returnfiber, currentfirstchild.sibling);\n    const existing = usefiber(currentfirstchild, textcontent, expirationtime);\n    existing.return = returnfiber;\n    return existing;\n  }\n  // the existing first child is not a text node so we need to create one\n  // and delete the existing ones.\n  //  text  fiber\n  deleteremainingchildren(returnfiber, currentfirstchild);\n  const created = createfiberfromtext(\n    textcontent,\n    returnfiber.mode,\n    expirationtime,\n  );\n  created.return = returnfiber;\n  return created;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n\n *  currentfirstchild.tag === hosttext  fiber  usefiber \n *  createfiberfromtext \n\n\n# reconcilechildrenarray\n\n reactelement stringnumbertextnode \n\n reconcilechildrenarray oldfiber  newchildrenoldfiber  fiber oldfiber.sibling  fiber  fiber newchildren  reactelement  reactelement \n\n oldfiber  old children old childnewchildren  old children new child\n\n reconcilechildrenarray \n\n function reconcilechildrenarray(\n  returnfiber: fiber,\n  currentfirstchild: fiber | null,\n  newchildren: array<*>, // newchildren  reactelement \n  expirationtime: expirationtime,\n): fiber | null {\n\n  if (__dev__) {\n    // first, validate keys.\n    // dev  key \n    let knownkeys = null;\n    for (let i = 0; i < newchildren.length; i++) {\n      const child = newchildren[i];\n      knownkeys = warnoninvalidkey(child, knownkeys);\n    }\n  }\n\n  let resultingfirstchild: fiber | null = null;\n  let previousnewfiber: fiber | null = null;\n\n  let oldfiber = currentfirstchild;\n  let lastplacedindex = 0;\n  let newidx = 0;\n  let nextoldfiber = null;\n  //  new children \n  for (; oldfiber !== null && newidx < newchildren.length; newidx++) {\n    //  old child  new child \n    if (oldfiber.index > newidx) {\n      nextoldfiber = oldfiber;\n      //  oldfiber null updateslot \n      //  oldfiber \n      oldfiber = null;\n    } else {\n      //  old children\n      //  oldfiber.index <= newidxnewidx  0 oldfiber.index <=0\n      //  oldfiber.index === 0index \n      nextoldfiber = oldfiber.sibling;\n    }\n    //  key  fiber  null\n    const newfiber = updateslot(\n      returnfiber,\n      oldfiber,\n      newchildren[newidx],\n      expirationtime,\n    );\n    //  key \n    if (newfiber === null) {\n      // todo: this breaks on empty slots like null children. that's\n      // unfortunate because it triggers the slow path all the time. we need\n      // a better way to communicate whether this was a miss or null,\n      // boolean, undefined, etc.\n      if (oldfiber === null) {\n        oldfiber = nextoldfiber;\n      }\n      // \n      break;\n    }\n    // old child \n    //  old child  nextoldfiber \n    if (shouldtracksideeffects) {\n      if (oldfiber && newfiber.alternate === null) {\n        // we matched the slot, but we didn't reuse the existing fiber, so we\n        // need to delete the existing child.\n        deletechild(returnfiber, oldfiber);\n      }\n    }\n    // \n    lastplacedindex = placechild(newfiber, lastplacedindex, newidx);\n    // resultingfirstchild  new children \n    if (previousnewfiber === null) {\n      // todo: move out of the loop. this only happens for the first run.\n      resultingfirstchild = newfiber;\n    } else {\n      // todo: defer siblings if we're not at the right index for this slot.\n      // i.e. if we had null values before, then we want to defer this\n      // for each null value. however, we also don't want to call updateslot\n      // with the previous one.\n      previousnewfiber.sibling = newfiber;\n    }\n    previousnewfiber = newfiber;\n    //  old child\n    oldfiber = nextoldfiber;\n  }\n  //  new children  old children 2old children new children \n  // \n  //  new children  old children \n  if (newidx === newchildren.length) {\n    // we've reached the end of the new children. we can delete the rest.\n    deleteremainingchildren(returnfiber, oldfiber);\n    return resultingfirstchild;\n  }\n  //  old children  new children \n  if (oldfiber === null) {\n    // if we don't have any more existing children we can choose a fast path\n    // since the rest will all be insertions.\n    // new children\n    for (; newidx < newchildren.length; newidx++) {\n      //  fiber \n      const newfiber = createchild(\n        returnfiber,\n        newchildren[newidx],\n        expirationtime,\n      );\n      // \n      if (newfiber === null) {\n        continue;\n      }\n      // \n      lastplacedindex = placechild(newfiber, lastplacedindex, newidx);\n      //  resultingfirstchild \n      if (previousnewfiber === null) {\n        // todo: move out of the loop. this only happens for the first run.\n        resultingfirstchild = newfiber;\n      } else {\n        previousnewfiber.sibling = newfiber;\n      }\n      previousnewfiber = newfiber;\n    }\n    //  new children \n    return resultingfirstchild;\n  }\n  //  return  3 \n  // \n  //  old children  key  key  fiber \n  // add all children to a key map for quick lookups.\n  const existingchildren = mapremainingchildren(returnfiber, oldfiber);\n\n  // keep scanning and use the map to restore deleted items as moves.\n  //  key  ne children\n  for (; newidx < newchildren.length; newidx++) {\n    //  map  key  old child \n    // updatefrommap  fiber\n    const newfiber = updatefrommap(\n      existingchildren,\n      returnfiber,\n      newidx,\n      newchildren[newidx],\n      expirationtime,\n    );\n    // resultingfirstchild \n    if (newfiber !== null) {\n      if (shouldtracksideeffects) {\n        if (newfiber.alternate !== null) {\n          // the new fiber is a work in progress, but if there exists a\n          // current, that means that we reused the fiber. we need to delete\n          // it from the child list so that we don't add it to the deletion\n          // list.\n          //  map \n          existingchildren.delete(\n            newfiber.key === null ? newidx : newfiber.key,\n          );\n        }\n      }\n      lastplacedindex = placechild(newfiber, lastplacedindex, newidx);\n      if (previousnewfiber === null) {\n        resultingfirstchild = newfiber;\n      } else {\n        previousnewfiber.sibling = newfiber;\n      }\n      previousnewfiber = newfiber;\n    }\n  }\n\n  if (shouldtracksideeffects) {\n    // any existing children that weren't consumed above were deleted. we need\n    // to add them to the deletion list.\n    //  old children \n    existingchildren.foreach(child => deletechild(returnfiber, child));\n  }\n\n  return resultingfirstchild;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n\n\nreact  childfiberarray \n\n * \n *  old children  new children  index  key updateslot \n *  old children  map<key, fiber>  new children map  key updatefrommap \n *  old children  new children \n *  old children  old children \n *  new children  new children \n *  new fibers resultingfirstchild\n\n reconcilechildrenarray  reconcilechildrenarray  key  key \n\n>  key  fiber  key  key \n\n createfiber  key  fiber  fiber  key  createfiber  key \n\nconst list = () => {\n  const arr = new array(20).fill(0);\n  return arr.map(a => <p key={math.random()}>{a}</p>)\n}\n\n\n1\n2\n3\n4\n\n\n\n\n key \n\n----------------------------------------\n\n\n\n\n# updateslot\n\n old children  new children  key  null\n\nfunction updateslot(\n  returnfiber: fiber,\n  oldfiber: fiber | null,\n  newchild: any,\n  expirationtime: expirationtime,\n): fiber | null {\n  // update the fiber if the keys match, otherwise return null.\n\n  const key = oldfiber !== null ? oldfiber.key : null;\n\n  if (typeof newchild === 'string' || typeof newchild === 'number') {\n    // text nodes don't have keys. if the previous node is implicitly keyed\n    // we can continue to replace it without aborting even if it is not a text\n    // node.\n    if (key !== null) {\n      return null;\n    }\n    return updatetextnode(\n      returnfiber,\n      oldfiber,\n      '' + newchild,\n      expirationtime,\n    );\n  }\n\n  if (typeof newchild === 'object' && newchild !== null) {\n    switch (newchild.$$typeof) {\n      case react_element_type: {\n        if (newchild.key === key) {\n          if (newchild.type === react_fragment_type) {\n            return updatefragment(\n              returnfiber,\n              oldfiber,\n              newchild.props.children,\n              expirationtime,\n              key,\n            );\n          }\n          return updateelement(\n            returnfiber,\n            oldfiber,\n            newchild,\n            expirationtime,\n          );\n        } else {\n          return null;\n        }\n      }\n      case react_portal_type: {\n        if (newchild.key === key) {\n          return updateportal(\n            returnfiber,\n            oldfiber,\n            newchild,\n            expirationtime,\n          );\n        } else {\n          return null;\n        }\n      }\n    }\n\n    if (isarray(newchild) || getiteratorfn(newchild)) {\n      if (key !== null) {\n        return null;\n      }\n\n      return updatefragment(\n        returnfiber,\n        oldfiber,\n        newchild,\n        expirationtime,\n        null,\n      );\n    }\n\n    throwoninvalidobjecttype(returnfiber, newchild);\n  }\n\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n updatexxx  fiber  fiber  reactelementportalelement \n\n\n# placechild\n\n fiber  'placement'  move  insertion \n\nfunction placechild(\n  newfiber: fiber,\n  lastplacedindex: number,\n  newindex: number,\n): number {\n  newfiber.index = newindex;\n  if (!shouldtracksideeffects) {\n    // noop.\n    return lastplacedindex;\n  }\n  const current = newfiber.alternate;\n  if (current !== null) {\n    const oldindex = current.index;\n    //  index   index \n    if (oldindex < lastplacedindex) {\n      // this is a move.\n      newfiber.effecttag = placement;\n      return lastplacedindex;\n    } else {\n      // index \n      // this item can stay in place.\n      return oldindex;\n    }\n  } else {\n    //  index \n    // this is an insertion.\n    newfiber.effecttag = placement;\n    return lastplacedindex;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n\n *  new children  placechild   'move'  'insertion'  'placement'  nefibers  domtree  'placement'  fiber.index  fiber  index\n\n\n# updatefrommap\n\n old children  fiber fiber\n\n function updatefrommap(\n  existingchildren: map<string | number, fiber>,\n  returnfiber: fiber,\n  newidx: number,\n  newchild: any,\n  expirationtime: expirationtime,\n): fiber | null {\n  if (typeof newchild === 'string' || typeof newchild === 'number') {\n    // text nodes don't have keys, so we neither have to check the old nor\n    // new node for the key. if both are text nodes, they match.\n    const matchedfiber = existingchildren.get(newidx) || null;\n    return updatetextnode(\n      returnfiber,\n      matchedfiber,\n      '' + newchild,\n      expirationtime,\n    );\n  }\n\n  if (typeof newchild === 'object' && newchild !== null) {\n    switch (newchild.$$typeof) {\n      case react_element_type: {\n        const matchedfiber =\n          existingchildren.get(\n            newchild.key === null ? newidx : newchild.key,\n          ) || null;\n        if (newchild.type === react_fragment_type) {\n          return updatefragment(\n            returnfiber,\n            matchedfiber,\n            newchild.props.children,\n            expirationtime,\n            newchild.key,\n          );\n        }\n        return updateelement(\n          returnfiber,\n          matchedfiber,\n          newchild,\n          expirationtime,\n        );\n      }\n      case react_portal_type: {\n        const matchedfiber =\n          existingchildren.get(\n            newchild.key === null ? newidx : newchild.key,\n          ) || null;\n        return updateportal(\n          returnfiber,\n          matchedfiber,\n          newchild,\n          expirationtime,\n        );\n      }\n    }\n\n    if (isarray(newchild) || getiteratorfn(newchild)) {\n      const matchedfiber = existingchildren.get(newidx) || null;\n      return updatefragment(\n        returnfiber,\n        matchedfiber,\n        newchild,\n        expirationtime,\n        null,\n      );\n    }\n\n    throwoninvalidobjecttype(returnfiber, newchild);\n  }\n\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n *  existingchildren  matchedfiber \n *  fiber\n\n reconcilechildfibers  mount  render \n\n * mount  fiber\n * render  fiber \n\n\n# \n\n reactchildfiber  singlechild  childarray  reactelement  fiber  vnode tree  fibertree ",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"expirationTime",frontmatter:{title:"expirationTime",date:"2022-04-14T22:02:21.000Z",permalink:"/react/reconciliation/expirationTime/",categories:["react","reconciliation"],tags:[null]},regularPath:"/10.react/20.%E8%B0%83%E5%92%8C%EF%BC%88Reconciliation%EF%BC%89/30.expirationTime.html",relativePath:"10.react/20.Reconciliation/30.expirationTime.md",key:"v-e4ff14f8",path:"/react/reconciliation/expirationTime/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:2,title:"priorityLevel",slug:"prioritylevel",normalizedTitle:"prioritylevel",charIndex:26},{level:2,title:"expirationTime",slug:"expirationtime",normalizedTitle:"expirationtime",charIndex:43},{level:3,title:"computeExpirationForFiber",slug:"computeexpirationforfiber",normalizedTitle:"computeexpirationforfiber",charIndex:63},{level:3,title:"computeExpirationBucket",slug:"computeexpirationbucket",normalizedTitle:"computeexpirationbucket",charIndex:94},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:121}],readingTime:{text:"5 min read",minutes:4.885,time:293099.99999999994,words:977},headersStr:"  priorityLevel expirationTime computeExpirationForFiber computeExpirationBucket ",content:"# \n\n\n\n * \n * \n * priorityLevel\n * expirationTime\n   * computeExpirationForFiber\n   * computeExpirationBucket\n * \n\n\n\n\n# \n\nreact :\n\n\nReactupdateupdate.lane\nReact\nSchedulerReact\n\n\n1\n2\n3\n4\n\n\nReact \n\n js  requestIdleCallback  requestAnimationFrame \n\nreact  fiber  fiber  fiber \n\n\n# priorityLevel\n\n expirationTime  react \n\n// \nexport const NoWork = 0;\n// TODO: Think of a better name for Never. The key difference with Idle is that\n// Never work can be committed in an inconsistent state without tearing the UI.\nexport const Never = 1;\n// Idle is slightly higher priority than Never. It must completely finish in order to be consistent.\nexport const Idle = 2;\nexport const Batched = Sync - 1;\nexport const Sync = MAX_SIGNED_31_BIT_INT; // Max int32: Math.pow(2, 31) - 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * NoWork: \n * Never Idle UI \n * Idle UI \n * Sync\n\n inferPriorityFromExpirationTime \n\nexport const HIGH_PRIORITY_EXPIRATION = 150;\nexport const HIGH_PRIORITY_BATCH_SIZE = 100;\nexport function inferPriorityFromExpirationTime(\n  currentTime: ExpirationTime,\n  expirationTime: ExpirationTime,\n): ReactPriorityLevel {\n  if (expirationTime === Sync) {\n    return ImmediatePriority;\n  }\n  if (expirationTime === Never || expirationTime === Idle) {\n    return IdlePriority;\n  }\n  const msUntil =\n    expirationTimeToMs(expirationTime) - expirationTimeToMs(currentTime);\n  if (msUntil <= 0) {\n    return ImmediatePriority;\n  }\n  if (msUntil <= HIGH_PRIORITY_EXPIRATION + HIGH_PRIORITY_BATCH_SIZE) {\n    return UserBlockingPriority;\n  }\n  if (msUntil <= LOW_PRIORITY_EXPIRATION + LOW_PRIORITY_BATCH_SIZE) {\n    return NormalPriority;\n  }\n\n  // TODO: Handle LowPriority\n\n  // Assume anything lower has idle priority\n  return IdlePriority;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n\nImmediatePriority, // \nUserBlockingPriority, //  UI \nNormalPriority, // \nIdlePriority, // \n\n\n1\n2\n3\n4\n\n\n priorityLevel  expirationTime \n\n\n# expirationTime\n\nreact  expirationTime  lanes expirationTime    \n\n expirationTime  react-reconciler  ReactFiberExpirationTime.js \n\nexport type ExpirationTime = number;\n\n\n1\n\n\nexpirationTime  number  expirationTime  currentTime  expirationTime \n\n expirationTime ms\n\nexport const Sync = MAX_SIGNED_31_BIT_INT;\nexport const Batched = Sync - 1;\nconst UNIT_SIZE = 10;\nconst MAGIC_NUMBER_OFFSET = Batched - 1;\n\nexport function msToExpirationTime(ms: number): ExpirationTime {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  //  MAGIC_NUMBER_OFFSET  noWork\n  return MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | 0);\n}\n\nexport function expirationTimeToMs(expirationTime: ExpirationTime): number {\n  return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n expirationTime \n\n * |0  2.3|0=2  '333.4'|0=333  'e333'|0=0 \n * \n   * msToExpirationTime1073741821-((ms/10)|0) ms expirationTime \n   * msUntil((currentTime/10)|0)-((expirationTime/10)|0) msUntil msUntil \n   * expirationTimeToMs(1073741821-expirationTime)*10\n\n fiber  expirationTime \n\n\n# computeExpirationForFiber\n\n fiber  expirationTime expirationTime\n\nfunction computeExpirationForFiber(\n  currentTime: ExpirationTime,\n  fiber: Fiber,\n  suspenseConfig: null | SuspenseConfig,\n): ExpirationTime {\n  const mode = fiber.mode;\n  if ((mode & BatchedMode) === NoMode) {\n    //  mode  BatchedMode \n    return Sync; // 1073741823 MAX_SIGNED_31_BIT_INT\n  }\n  // \n  const priorityLevel = getCurrentPriorityLevel();\n  if ((mode & ConcurrentMode) === NoMode) {\n    //  ConcurrentMode \n    return priorityLevel === ImmediatePriority ? Sync : Batched;\n  }\n\n  if ((executionContext & RenderContext) !== NoContext) {\n    // executionContext  RenderContext\n    // Use whatever time we're already rendering\n    // TODO: Should there be a way to opt out, like with `runWithPriority`?\n    return renderExpirationTime; // NoWork 0\n  }\n\n  let expirationTime;\n  if (suspenseConfig !== null) {\n    // Compute an expiration time based on the Suspense timeout.\n    expirationTime = computeSuspenseExpiration(\n      currentTime,\n      suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION,\n    );\n  } else {\n    // Compute an expiration time based on the Scheduler priority.\n    switch (priorityLevel) {\n      case ImmediatePriority:\n        expirationTime = Sync;\n        break;\n      case UserBlockingPriority:\n        // TODO: Rename this to computeUserBlockingExpiration\n        expirationTime = computeInteractiveExpiration(currentTime);\n        break;\n      case NormalPriority:\n      case LowPriority: // TODO: Handle LowPriority\n        // TODO: Rename this to... something better.\n        expirationTime = computeAsyncExpiration(currentTime);\n        break;\n      case IdlePriority:\n        expirationTime = Idle;\n        break;\n      default:\n        invariant(false, 'Expected a valid priority level');\n    }\n  }\n\n  // If we're in the middle of rendering a tree, do not update at the same\n  // expiration time that is already rendering.\n  // TODO: We shouldn't have to do this if the update is on a different root.\n  // Refactor computeExpirationForFiber + scheduleUpdate so we have access to\n  // the root when we check for this condition.\n  //  FiberTree  1  batch\n  if (workInProgressRoot !== null && expirationTime === renderExpirationTime) {\n    // This is a trick to move this update into a separate batch\n    expirationTime -= 1;\n  }\n\n  return expirationTime;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n 1. UserBlockingPriorityNormalPriority  LowPriority  computeInteractiveExpiration  computeAsyncExpiration  expirationTime\n 2. computeInteractiveExpiration  computeAsyncExpiration \n 3. react fiber  mode:\n\nexport const NoMode = 0b0000; // 0\nexport const StrictMode = 0b0001; // 1\nexport const BatchedMode = 0b0010; // 2\nexport const ConcurrentMode = 0b0100; // 4\nexport const ProfileMode = 0b1000; // 8\n\n\n1\n2\n3\n4\n5\n\n * StrictMode  APIReact16-17 \n * BatchedMode React15-16 \n * ConcurrentMode React17 \n * ProfileMode React16-17 \n\n 4. fiber mode \n\n 2  n  0 0 (x&x)===x(x&y)===0 \n\n\n# computeExpirationBucket\n\nexport const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;\nexport const HIGH_PRIORITY_BATCH_SIZE = 100;\nfunction computeInteractiveExpiration(currentTime: ExpirationTime) {\n  return computeExpirationBucket(\n    currentTime,\n    HIGH_PRIORITY_EXPIRATION,\n    HIGH_PRIORITY_BATCH_SIZE,\n  );\n}\n\nexport const LOW_PRIORITY_EXPIRATION = 5000;\nexport const LOW_PRIORITY_BATCH_SIZE = 250;\nexport function computeAsyncExpiration(\n  currentTime: ExpirationTime,\n): ExpirationTime {\n  return computeExpirationBucket(\n    currentTime,\n    LOW_PRIORITY_EXPIRATION,\n    LOW_PRIORITY_BATCH_SIZE,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n computeExpirationBucket  computeExpirationBucket \n\nconst UNIT_SIZE = 10;\nconst MAGIC_NUMBER_OFFSET = 2;\n\nfunction ceiling(num: number, precision: number): number {\n  return (((num / precision) | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(\n  currentTime,\n  expirationInMs,\n  bucketSizeMs,\n): ExpirationTime {\n  return (\n    MAGIC_NUMBER_OFFSET +\n    ceiling(\n      currentTime - MAGIC_NUMBER_OFFSET + expirationInMs / UNIT_SIZE,\n      bucketSizeMs / UNIT_SIZE,\n    )\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n((((currentTime - 2 + 5000 / 10) / 25) | 0) + 1) * 25\n\n((((26 - 2 + 5000 / 10) / 25) | 0) + 1) * 25   525\n((((27 - 2 + 5000 / 10) / 25) | 0) + 1) * 25   550\n((((51 - 2 + 5000 / 10) / 25) | 0) + 1) * 25   550\n((((52 - 2 + 5000 / 10) / 25) | 0) + 1) * 25   575\n\n\n1\n2\n3\n4\n\n\n 27-51  currentTime  expirationTime  550 expirationTime  react \n\n 25msUserBlockingPriority 10msNormalPriorityLowPriority\n\n react  react \n\n\n# \n\n fiber expiration  fiber  expiration ",normalizedContent:"# \n\n\n\n * \n * \n * prioritylevel\n * expirationtime\n   * computeexpirationforfiber\n   * computeexpirationbucket\n * \n\n\n\n\n# \n\nreact :\n\n\nreactupdateupdate.lane\nreact\nschedulerreact\n\n\n1\n2\n3\n4\n\n\nreact \n\n js  requestidlecallback  requestanimationframe \n\nreact  fiber  fiber  fiber \n\n\n# prioritylevel\n\n expirationtime  react \n\n// \nexport const nowork = 0;\n// todo: think of a better name for never. the key difference with idle is that\n// never work can be committed in an inconsistent state without tearing the ui.\nexport const never = 1;\n// idle is slightly higher priority than never. it must completely finish in order to be consistent.\nexport const idle = 2;\nexport const batched = sync - 1;\nexport const sync = max_signed_31_bit_int; // max int32: math.pow(2, 31) - 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * nowork: \n * never idle ui \n * idle ui \n * sync\n\n inferpriorityfromexpirationtime \n\nexport const high_priority_expiration = 150;\nexport const high_priority_batch_size = 100;\nexport function inferpriorityfromexpirationtime(\n  currenttime: expirationtime,\n  expirationtime: expirationtime,\n): reactprioritylevel {\n  if (expirationtime === sync) {\n    return immediatepriority;\n  }\n  if (expirationtime === never || expirationtime === idle) {\n    return idlepriority;\n  }\n  const msuntil =\n    expirationtimetoms(expirationtime) - expirationtimetoms(currenttime);\n  if (msuntil <= 0) {\n    return immediatepriority;\n  }\n  if (msuntil <= high_priority_expiration + high_priority_batch_size) {\n    return userblockingpriority;\n  }\n  if (msuntil <= low_priority_expiration + low_priority_batch_size) {\n    return normalpriority;\n  }\n\n  // todo: handle lowpriority\n\n  // assume anything lower has idle priority\n  return idlepriority;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n\nimmediatepriority, // \nuserblockingpriority, //  ui \nnormalpriority, // \nidlepriority, // \n\n\n1\n2\n3\n4\n\n\n prioritylevel  expirationtime \n\n\n# expirationtime\n\nreact  expirationtime  lanes expirationtime    \n\n expirationtime  react-reconciler  reactfiberexpirationtime.js \n\nexport type expirationtime = number;\n\n\n1\n\n\nexpirationtime  number  expirationtime  currenttime  expirationtime \n\n expirationtime ms\n\nexport const sync = max_signed_31_bit_int;\nexport const batched = sync - 1;\nconst unit_size = 10;\nconst magic_number_offset = batched - 1;\n\nexport function mstoexpirationtime(ms: number): expirationtime {\n  // always add an offset so that we don't clash with the magic number for nowork.\n  //  magic_number_offset  nowork\n  return magic_number_offset - ((ms / unit_size) | 0);\n}\n\nexport function expirationtimetoms(expirationtime: expirationtime): number {\n  return (magic_number_offset - expirationtime) * unit_size;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n expirationtime \n\n * |0  2.3|0=2  '333.4'|0=333  'e333'|0=0 \n * \n   * mstoexpirationtime1073741821-((ms/10)|0) ms expirationtime \n   * msuntil((currenttime/10)|0)-((expirationtime/10)|0) msuntil msuntil \n   * expirationtimetoms(1073741821-expirationtime)*10\n\n fiber  expirationtime \n\n\n# computeexpirationforfiber\n\n fiber  expirationtime expirationtime\n\nfunction computeexpirationforfiber(\n  currenttime: expirationtime,\n  fiber: fiber,\n  suspenseconfig: null | suspenseconfig,\n): expirationtime {\n  const mode = fiber.mode;\n  if ((mode & batchedmode) === nomode) {\n    //  mode  batchedmode \n    return sync; // 1073741823 max_signed_31_bit_int\n  }\n  // \n  const prioritylevel = getcurrentprioritylevel();\n  if ((mode & concurrentmode) === nomode) {\n    //  concurrentmode \n    return prioritylevel === immediatepriority ? sync : batched;\n  }\n\n  if ((executioncontext & rendercontext) !== nocontext) {\n    // executioncontext  rendercontext\n    // use whatever time we're already rendering\n    // todo: should there be a way to opt out, like with `runwithpriority`?\n    return renderexpirationtime; // nowork 0\n  }\n\n  let expirationtime;\n  if (suspenseconfig !== null) {\n    // compute an expiration time based on the suspense timeout.\n    expirationtime = computesuspenseexpiration(\n      currenttime,\n      suspenseconfig.timeoutms | 0 || low_priority_expiration,\n    );\n  } else {\n    // compute an expiration time based on the scheduler priority.\n    switch (prioritylevel) {\n      case immediatepriority:\n        expirationtime = sync;\n        break;\n      case userblockingpriority:\n        // todo: rename this to computeuserblockingexpiration\n        expirationtime = computeinteractiveexpiration(currenttime);\n        break;\n      case normalpriority:\n      case lowpriority: // todo: handle lowpriority\n        // todo: rename this to... something better.\n        expirationtime = computeasyncexpiration(currenttime);\n        break;\n      case idlepriority:\n        expirationtime = idle;\n        break;\n      default:\n        invariant(false, 'expected a valid priority level');\n    }\n  }\n\n  // if we're in the middle of rendering a tree, do not update at the same\n  // expiration time that is already rendering.\n  // todo: we shouldn't have to do this if the update is on a different root.\n  // refactor computeexpirationforfiber + scheduleupdate so we have access to\n  // the root when we check for this condition.\n  //  fibertree  1  batch\n  if (workinprogressroot !== null && expirationtime === renderexpirationtime) {\n    // this is a trick to move this update into a separate batch\n    expirationtime -= 1;\n  }\n\n  return expirationtime;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n 1. userblockingprioritynormalpriority  lowpriority  computeinteractiveexpiration  computeasyncexpiration  expirationtime\n 2. computeinteractiveexpiration  computeasyncexpiration \n 3. react fiber  mode:\n\nexport const nomode = 0b0000; // 0\nexport const strictmode = 0b0001; // 1\nexport const batchedmode = 0b0010; // 2\nexport const concurrentmode = 0b0100; // 4\nexport const profilemode = 0b1000; // 8\n\n\n1\n2\n3\n4\n5\n\n * strictmode  apireact16-17 \n * batchedmode react15-16 \n * concurrentmode react17 \n * profilemode react16-17 \n\n 4. fiber mode \n\n 2  n  0 0 (x&x)===x(x&y)===0 \n\n\n# computeexpirationbucket\n\nexport const high_priority_expiration = __dev__ ? 500 : 150;\nexport const high_priority_batch_size = 100;\nfunction computeinteractiveexpiration(currenttime: expirationtime) {\n  return computeexpirationbucket(\n    currenttime,\n    high_priority_expiration,\n    high_priority_batch_size,\n  );\n}\n\nexport const low_priority_expiration = 5000;\nexport const low_priority_batch_size = 250;\nexport function computeasyncexpiration(\n  currenttime: expirationtime,\n): expirationtime {\n  return computeexpirationbucket(\n    currenttime,\n    low_priority_expiration,\n    low_priority_batch_size,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n computeexpirationbucket  computeexpirationbucket \n\nconst unit_size = 10;\nconst magic_number_offset = 2;\n\nfunction ceiling(num: number, precision: number): number {\n  return (((num / precision) | 0) + 1) * precision;\n}\n\nfunction computeexpirationbucket(\n  currenttime,\n  expirationinms,\n  bucketsizems,\n): expirationtime {\n  return (\n    magic_number_offset +\n    ceiling(\n      currenttime - magic_number_offset + expirationinms / unit_size,\n      bucketsizems / unit_size,\n    )\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n((((currenttime - 2 + 5000 / 10) / 25) | 0) + 1) * 25\n\n((((26 - 2 + 5000 / 10) / 25) | 0) + 1) * 25   525\n((((27 - 2 + 5000 / 10) / 25) | 0) + 1) * 25   550\n((((51 - 2 + 5000 / 10) / 25) | 0) + 1) * 25   550\n((((52 - 2 + 5000 / 10) / 25) | 0) + 1) * 25   575\n\n\n1\n2\n3\n4\n\n\n 27-51  currenttime  expirationtime  550 expirationtime  react \n\n 25msuserblockingpriority 10msnormalprioritylowpriority\n\n react  react \n\n\n# \n\n fiber expiration  fiber  expiration ",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"scheduleWork",frontmatter:{title:"scheduleWork",date:"2022-04-14T22:02:21.000Z",permalink:"/react/reconciliation/scheduleWork/",categories:["react","reconciliation"],tags:[null]},regularPath:"/10.react/20.%E8%B0%83%E5%92%8C%EF%BC%88Reconciliation%EF%BC%89/40.scheduleWork.html",relativePath:"10.react/20.Reconciliation/40.scheduleWork.md",key:"v-1daf77ea",path:"/react/reconciliation/scheduleWork/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"scheduleWork Fiber ",slug:"schedulework--fiber-",normalizedTitle:"schedulework fiber ",charIndex:17},{level:3,title:"markUpdateTimeFromFiberToRoot Fiber Tree  expirationTime",slug:"markupdatetimefromfibertoroot--fiber-tree--expirationtime",normalizedTitle:"markupdatetimefromfibertoroot fiber tree  expirationtime",charIndex:48},{level:3,title:"checkForNestedUpdates: ",slug:"checkfornestedupdates-",normalizedTitle:"checkfornestedupdates: ",charIndex:114},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:149},{level:3,title:"checkForInterruption",slug:"checkforinterruption",normalizedTitle:"checkforinterruption",charIndex:170},{level:3,title:"recordScheduleUpdate",slug:"recordscheduleupdate-",normalizedTitle:"recordscheduleupdate",charIndex:196},{level:2,title:"ensureRootIsScheduled Root ",slug:"ensurerootisscheduled--root-",normalizedTitle:"ensurerootisscheduled root ",charIndex:230},{level:2,title:"scheduleSyncCallback",slug:"schedulesynccallback-",normalizedTitle:"schedulesynccallback",charIndex:267},{level:2,title:"scheduleCallback",slug:"schedulecallback-",normalizedTitle:"schedulecallback",charIndex:299},{level:2,title:"schedulePendingInteractions ",slug:"schedulependinginteractions--",normalizedTitle:"schedulependinginteractions ",charIndex:327},{level:2,title:"performSyncWorkOnRoot",slug:"performsyncworkonroot-",normalizedTitle:"performsyncworkonroot",charIndex:368},{level:2,title:"performConcurrentWorkOnRoot",slug:"performconcurrentworkonroot-",normalizedTitle:"performconcurrentworkonroot",charIndex:402},{level:2,title:"flushSyncCallbackQueue",slug:"flushsynccallbackqueue",normalizedTitle:"flushsynccallbackqueue",charIndex:442},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:468}],readingTime:{text:"11 min read",minutes:10.31,time:618600,words:2062},headersStr:" scheduleWork Fiber  markUpdateTimeFromFiberToRoot Fiber Tree  expirationTime checkForNestedUpdates:   checkForInterruption recordScheduleUpdate ensureRootIsScheduled Root  scheduleSyncCallback scheduleCallback schedulePendingInteractions  performSyncWorkOnRoot performConcurrentWorkOnRoot flushSyncCallbackQueue ",content:"# \n\n\n\n * \n * scheduleWork Fiber \n   * markUpdateTimeFromFiberToRoot Fiber Tree  expirationTime\n   * checkForNestedUpdates: \n   * \n   * checkForInterruption\n   * recordScheduleUpdate\n * ensureRootIsScheduled Root \n * scheduleSyncCallback\n * scheduleCallback\n * schedulePendingInteractions \n * performSyncWorkOnRoot\n * performConcurrentWorkOnRoot\n * flushSyncCallbackQueue\n * \n\n\n\nscheduleWork  react  scheduleWork(fiber, expirationTime)  fiber  expirationTime fiber  expirationTime \n\n react-reconciler/src/ReactFiberWorkLoop.js  scheduleUpdateOnFiber  scheduleWork\n\n ReactFiberWorkLoop  react-reconciler  fiber  HostFiberRootFiber  HostFiberRoot  expirationTime  FirstRender  commit  render \n\n\n\n\n# scheduleWork Fiber \n\nscheduleUpdateOnFiber \n\n/**\n * scheduleWork\n * @param {*} fiber \n * @param {*} expirationTime \n */\nexport function scheduleUpdateOnFiber(\n    fiber: Fiber,\n    expirationTime: ExpirationTime,\n) {\n    //   \n    checkForNestedUpdates();\n    warnAboutInvalidUpdatesOnClassComponentsInDEV(fiber);\n    //  fiber  root  expirationTime root \n    const root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);\n    console.log(\"root\", root);\n    // \n    // root FiberRootNode {tag: 0, current: FiberNode, containerInfo: div#root, pendingChildren: null, pingCache: null, }\n    //  root \n    if (root === null) {\n        warnAboutUpdateOnUnmountedFiberInDEV(fiber);\n        return;\n    }\n    // \n    checkForInterruption(fiber, expirationTime);\n    // \n    recordScheduleUpdate();\n\n    // TODO: computeExpirationForFiber also reads the priority. Pass the\n    // priority as an argument to that function and this one.\n    // \n    const priorityLevel = getCurrentPriorityLevel();\n\n    // \n    if (expirationTime === Sync) {\n        if (\n            //  unbatchedUpdates  rendering  commit \n            // Check if we're inside unbatchedUpdates\n            //  executionContext  LegacyUnbatchedContext executionContext  RenderContext  CommitContext \n            (executionContext & LegacyUnbatchedContext) !== NoContext &&\n            // Check if we're not already rendering\n            //  RenderContext  CommitContext render  commit \n            //  render  commit \n            (executionContext & (RenderContext | CommitContext)) === NoContext\n        ) {\n            // Register pending interactions on the root to avoid losing traced interaction data.\n            // \n            schedulePendingInteractions(root, expirationTime);\n\n            // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\n            // root inside of batchedUpdates should be synchronous, but layout updates\n            // should be deferred until the end of the batch.\n            //  root ReactDOM  FiberTree \n            performSyncWorkOnRoot(root);\n        } else {\n\t\t\t      // root\n            ensureRootIsScheduled(root);\n            // \n            schedulePendingInteractions(root, expirationTime);\n            // \n            if (executionContext === NoContext) {\n                // Flush the synchronous work now, unless we're already working or inside\n                // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n                // scheduleCallbackForFiber to preserve the ability to schedule a callback\n                // without immediately flushing it. We only do this for user-initiated\n                // updates, to preserve historical behavior of sync mode.\n                // \n                flushSyncCallbackQueue();\n            }\n        }\n    } else {\n        // \n        ensureRootIsScheduled(root);\n        schedulePendingInteractions(root, expirationTime);\n    }\n\n   //  rootsWithPendingDiscreteUpdates \n    if (\n    (executionContext & DiscreteEventContext) !== NoContext &&\n    // Only updates at user-blocking priority or greater are considered\n    // discrete, even inside a discrete event.\n    (priorityLevel === UserBlockingPriority ||\n      priorityLevel === ImmediatePriority)\n      // DiscreteEventContext UserBlockingPriority  ImmediatePriority\n      //  click\n  ) {\n    // This is the result of a discrete event. Track the lowest priority\n    // discrete update per root so we can flush them early, if needed.\n    if (rootsWithPendingDiscreteUpdates === null) {\n      // \n      rootsWithPendingDiscreteUpdates = new Map([[root, expirationTime]]);\n    } else {\n      //  HostFiberRoot \n      const lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);\n      //  HostFiberRoot  HostFiberRoot \n      if (lastDiscreteTime === undefined || lastDiscreteTime > expirationTime) {\n        rootsWithPendingDiscreteUpdates.set(root, expirationTime);\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n\n\n\n# markUpdateTimeFromFiberToRoot Fiber Tree  expirationTime\n\n FiberRoot  expirationTime Fiber tree  expirationTimeReact  Fiber \n\n// rootroot\nfunction markUpdateTimeFromFiberToRoot(fiber, expirationTime) {\n  // Update the source fiber's expiration time\n  //  fiber  fiber.alternate  expirationTime\n  //  fiber  expirationTime  expirationTime  fiber  fiber \n  // \n  if (fiber.expirationTime < expirationTime) {\n    fiber.expirationTime = expirationTime;\n  }\n  let alternate = fiber.alternate;\n  if (alternate !== null && alternate.expirationTime < expirationTime) {\n    alternate.expirationTime = expirationTime;\n  }\n  // Walk the parent path to the root and update the child expiration time.\n  //  root  fiber \n  let node = fiber.return;\n  let root = null;\n  //  fiber  HostRoot  fiber  FiberRoot\n  if (node === null && fiber.tag === HostRoot) {\n    // fiber.return  root \n    root = fiber.stateNode;\n  } else {\n    //  FiberRoot\n    while (node !== null) {\n      //  node  alternate \n      alternate = node.alternate;\n      if (node.childExpirationTime < expirationTime) {\n        // childExpirationTime\n        node.childExpirationTime = expirationTime;\n        if (\n          alternate !== null &&\n          alternate.childExpirationTime < expirationTime\n        ) {\n          alternate.childExpirationTime = expirationTime;\n        }\n      } else if (\n        alternate !== null &&\n        alternate.childExpirationTime < expirationTime\n      ) {\n        alternate.childExpirationTime = expirationTime;\n      }\n      //  root \n      if (node.return === null && node.tag === HostRoot) {\n        root = node.stateNode;\n        break;\n      }\n      node = node.return;\n    }\n  }\n\n  if (root !== null) {\n    // root \n    if (workInProgressRoot === root) {\n      // Received an update to a tree that's in the middle of rendering. Mark\n      // that's unprocessed work on this root.\n      // workInProgressRootNextUnprocessedUpdateTime \n      markUnprocessedUpdateTime(expirationTime);\n\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // \n        // \n        // \n        // \n        // TODO: This happens to work when receiving an update during the render\n        // phase, because of the trick inside computeExpirationForFiber to\n        // subtract 1 from `renderExpirationTime` to move it into a\n        // separate bucket. But we should probably model it with an exception,\n        // using the same mechanism we use to force hydration of a subtree.\n        // TODO: This does not account for low pri updates that were already\n        // scheduled before the root started rendering. Need to track the next\n        // pending expiration time (perhaps by backtracking the return path) and\n        // then trigger a restart in the `renderDidSuspendDelayIfPossible` path.\n        markRootSuspendedAtTime(root, renderExpirationTime);\n      }\n    }\n    // Mark that the root has a pending update.\n    //  root \n    markRootUpdatedAtTime(root, expirationTime);\n  }\n\n  return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n *  expirationTime root \n * node.return === null && node.tag === HostRoot  root \n\n\n# checkForNestedUpdates: \n\n nestedUpdateCount > NESTED_UPDATE_LIMIT  Maximum update depth exceeded  NESTED_UPDATE_LIMIT  50 render  setState \n\n\n# \n\nlet nestedUpdateCount: number = 0;\nlet rootWithNestedUpdates: FiberRoot | null = null;\n\n\n1\n2\n\n\n commitRootImpl()  nestedUpdateCount \n\nif (remainingExpirationTime === Sync) {\n  // Count the number of times the root synchronously re-renders without\n  // finishing. If there are too many, it indicates an infinite update loop.\n  if (root === rootWithNestedUpdates) {\n\t  nestedUpdateCount++;\n  } else {\n\t  nestedUpdateCount = 0;\n\t  rootWithNestedUpdates = root;\n  }\n} else {\n  nestedUpdateCount = 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# checkForInterruption\n\ncheckForInterruption  fiber fiber  interruptedBy \n\nfunction checkForInterruption(\n    fiberThatReceivedUpdate: Fiber,\n    updateExpirationTime: ExpirationTime,\n) {\n    if (\n        enableUserTimingAPI &&\n        workInProgressRoot !== null &&\n        updateExpirationTime > renderExpirationTime\n        //  fiber\n    ) {\n        interruptedBy = fiberThatReceivedUpdate;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n fiber  fiber \n\n\n# recordScheduleUpdate\n\nrecordScheduleUpdate  commit  render  hasScheduledUpdateInCurrentCommit  hasScheduledUpdateInCurrentPhase \n\nexport function recordScheduleUpdate(): void {\n    if (enableUserTimingAPI) {\n        // isCommitting  commit \n        if (isCommitting) {\n            //  commit \n            hasScheduledUpdateInCurrentCommit = true;\n        }\n        if (\n            // currentPhase  \n            currentPhase !== null &&\n            currentPhase !== 'componentWillMount' &&\n            currentPhase !== 'componentWillReceiveProps'\n        ) {\n            // \n            hasScheduledUpdateInCurrentPhase = true;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n ensureRootIsScheduled  schedulePendingInteractions \n\n ensureRootIsScheduled  schedulePendingInteractions \n\n\n# ensureRootIsScheduled Root \n\n// Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the\n// expiration time of the existing task is the same as the expiration time of\n// the next level that the root has work on. This function is called on every\n// update, and right before exiting a task.\n//  root  root  root \n// \nfunction ensureRootIsScheduled(root: FiberRoot) {\n  //lastExpiredTime  noWorkmarkRootExpiredAtTime\n  const lastExpiredTime = root.lastExpiredTime;\n  //  lastExpiredTime  noWork root \n  if (lastExpiredTime !== NoWork) {\n    // \n    // root\n    root.callbackExpirationTime = Sync;\n    root.callbackPriority = ImmediatePriority;\n    root.callbackNode = scheduleSyncCallback(\n      performSyncWorkOnRoot.bind(null, root),\n    );\n    return;\n  }\n\n  const expirationTime = getNextRootExpirationTimeToWorkOn(root);\n  const existingCallbackNode = root.callbackNode;\n  // \n  if (expirationTime === NoWork) {\n    // There's nothing to work on.\n    if (existingCallbackNode !== null) {\n      root.callbackNode = null;\n      root.callbackExpirationTime = NoWork;\n      root.callbackPriority = NoPriority;\n    }\n    return;\n  }\n\n  // TODO: If this is an update, we already read the current time. Pass the\n  // time as an argument.\n  // \n  const currentTime = requestCurrentTime();\n  const priorityLevel = inferPriorityFromExpirationTime(\n    currentTime,\n    expirationTime,\n  );\n\n  // If there's an existing render task, confirm it has the correct priority and\n  // expiration time. Otherwise, we'll cancel it and schedule a new one.\n  //  \n  //  ROOT \n  if (existingCallbackNode !== null) {\n    const existingCallbackPriority = root.callbackPriority;\n    const existingCallbackExpirationTime = root.callbackExpirationTime;\n    if ( // \n      // Callback must have the exact same expiration time.\n      existingCallbackExpirationTime === expirationTime &&\n      // Callback must have greater or equal priority.\n      existingCallbackPriority >= priorityLevel\n      // \n    ) {\n      // Existing callback is sufficient.\n      return;\n    }\n    // Need to schedule a new task.\n    // TODO: Instead of scheduling a new task, we should be able to change the\n    // priority of the existing one.\n    // \n    cancelCallback(existingCallbackNode);\n  }\n\n  root.callbackExpirationTime = expirationTime;\n  root.callbackPriority = priorityLevel;\n\n  let callbackNode;\n  // \n  if (expirationTime === Sync) {\n    // Sync React callbacks are scheduled on a special internal queue\n    //  FirstRender\n    callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n  } else if (disableSchedulerTimeoutBasedOnReactExpirationTime) {\n    callbackNode = scheduleCallback(\n      priorityLevel,\n      performConcurrentWorkOnRoot.bind(null, root),\n    );\n  } else {\n    // \n    callbackNode = scheduleCallback(\n      priorityLevel,\n      performConcurrentWorkOnRoot.bind(null, root),\n      // Compute a task timeout based on the expiration time. This also affects\n      // ordering because tasks are processed in timeout order.\n      {timeout: expirationTimeToMs(expirationTime) - now()},\n    );\n  }\n\n  root.callbackNode = callbackNode;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n\n *  scheduleSyncCallback  scheduleCallback \n\n\n# scheduleSyncCallback\n\nfunction scheduleSyncCallback(callback: SchedulerCallback) {\n    // Push this callback into an internal queue. We'll flush these either in\n    // the next tick, or earlier if something calls `flushSyncCallbackQueue`.\n    if (syncQueue === null) {\n        // \n        syncQueue = [callback];\n        // Flush the queue in the next tick, at the earliest.\n        // \n        immediateQueueCallbackNode = Scheduler_scheduleCallback(\n            Scheduler_ImmediatePriority,\n            flushSyncCallbackQueueImpl,\n        );\n    } else {\n        // Push onto existing queue. Don't need to schedule a callback because\n        // we already scheduled one when we created the queue.\n        // syncQueue\n        syncQueue.push(callback);\n    }\n    return fakeCallbackNode;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n *  syncQueue \n *  Scheduler_scheduleCallback  tick  flushSyncCallbackQueue \n * fakeCallbackNode  callback  {}\n\n\n# scheduleCallback\n\nscheduleCallback  Scheduler_scheduleCallback  callback\n\nexport function scheduleCallback(\n  reactPriorityLevel: ReactPriorityLevel,\n  callback: SchedulerCallback,\n  options: SchedulerCallbackOptions | void | null,\n) {\n  const priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);\n  return Scheduler_scheduleCallback(priorityLevel, callback, options);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * Scheduler_scheduleCallback\n\n\n# schedulePendingInteractions \n\n scheduleInteractions  pendingInteractionMap  Map(<expirationTime>, <Interactions Set>) interactions \n\nfunction scheduleInteractions(root, expirationTime, interactions) {\n  // enableSchedulerTracing\n  if (!enableSchedulerTracing) {\n    return;\n  }\n  // interactions  __interactionsRef.current \n  // pushInteractions  popInteractions  interactions \n  if (interactions.size > 0) {\n    const pendingInteractionMap = root.pendingInteractionMap;\n    const pendingInteractions = pendingInteractionMap.get(expirationTime);\n    //  pending \n    if (pendingInteractions != null) {\n      interactions.forEach(interaction => {\n        if (!pendingInteractions.has(interaction)) {\n          // Update the pending async work count for previously unscheduled interaction.\n          //  pending \n          interaction.__count++;\n        }\n        //  interaction  pendingInteractions\n        pendingInteractions.add(interaction);\n      });\n    } else {\n      //  pending interactionspendingInteractionMap\n      // pendingInteractionMap  Map(<expirationTime>, <Interactions Set>)\n      pendingInteractionMap.set(expirationTime, new Set(interactions));\n\n      // Update the pending async work count for the current interactions.\n      //  pending \n      interactions.forEach(interaction => {\n        interaction.__count++;\n      });\n    }\n    // \n    const subscriber = __subscriberRef.current;\n    if (subscriber !== null) {\n      //  id\n      const threadID = computeThreadID(root, expirationTime);\n      //  onWorkScheduled \n      subscriber.onWorkScheduled(interactions, threadID);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n pushInteractions \n\nfunction pushInteractions(root) {\n  if (enableSchedulerTracing) {\n    const prevInteractions: Set<Interaction> | null = __interactionsRef.current;\n    __interactionsRef.current = root.memoizedInteractions;\n    return prevInteractions;\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n interactions  root.memoizedInteractions pushInteractions  interactions\n\n FirstRender  FirstRender  FirstRender  FirstRender   \n\n\n# performSyncWorkOnRoot\n\n\n# performConcurrentWorkOnRoot\n\n\n# flushSyncCallbackQueue\n\n\n# \n\n 1. scheduleUpdateOnFiber \n\nscheduleUpdateOnFiber  ensureRootIsScheduled  react \n\n /        \n               performSyncWorkOnRoot \n              scheduleSyncCallback  callback \n          -        scheduleCallback  callback \n\n\n\n *  callback \n *  scheduleSyncCallback  scheduleCallback  unstable_scheduleCallback  unstable_scheduleCallback \n\n 2. react \n\n * react  FiberRoot FiberRoot  HostRoot  Fiber \n *  expirationTime \n *  Fiber  Fiber  markUpdateTimeFromFiberToRoot  fiber  expirationTime  fiber  fiberRoot childExpirationTime \n *  schedulePendingInteractions \n\n 3. \n\n react-reconciler  SchedulerWithReactIntegration.js \n\n\n\nconst {\n  unstable_runWithPriority: Scheduler_runWithPriority,\n  unstable_scheduleCallback: Scheduler_scheduleCallback,\n  unstable_cancelCallback: Scheduler_cancelCallback,\n  unstable_shouldYield: Scheduler_shouldYield,\n  unstable_requestPaint: Scheduler_requestPaint,\n  unstable_now: Scheduler_now,\n  unstable_getCurrentPriorityLevel: Scheduler_getCurrentPriorityLevel,\n  unstable_ImmediatePriority: Scheduler_ImmediatePriority,\n  unstable_UserBlockingPriority: Scheduler_UserBlockingPriority,\n  unstable_NormalPriority: Scheduler_NormalPriority,\n  unstable_LowPriority: Scheduler_LowPriority,\n  unstable_IdlePriority: Scheduler_IdlePriority,\n} = Scheduler;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n SchedulerWithReactIntegration \n\n * getCurrentPriorityLevel : \n * scheduleSyncCallback :  syncQueue\n * cancelCallback : \n * flushSyncCallbackQueue :  syncQueue ",normalizedContent:"# \n\n\n\n * \n * schedulework fiber \n   * markupdatetimefromfibertoroot fiber tree  expirationtime\n   * checkfornestedupdates: \n   * \n   * checkforinterruption\n   * recordscheduleupdate\n * ensurerootisscheduled root \n * schedulesynccallback\n * schedulecallback\n * schedulependinginteractions \n * performsyncworkonroot\n * performconcurrentworkonroot\n * flushsynccallbackqueue\n * \n\n\n\nschedulework  react  schedulework(fiber, expirationtime)  fiber  expirationtime fiber  expirationtime \n\n react-reconciler/src/reactfiberworkloop.js  scheduleupdateonfiber  schedulework\n\n reactfiberworkloop  react-reconciler  fiber  hostfiberrootfiber  hostfiberroot  expirationtime  firstrender  commit  render \n\n\n\n\n# schedulework fiber \n\nscheduleupdateonfiber \n\n/**\n * schedulework\n * @param {*} fiber \n * @param {*} expirationtime \n */\nexport function scheduleupdateonfiber(\n    fiber: fiber,\n    expirationtime: expirationtime,\n) {\n    //   \n    checkfornestedupdates();\n    warnaboutinvalidupdatesonclasscomponentsindev(fiber);\n    //  fiber  root  expirationtime root \n    const root = markupdatetimefromfibertoroot(fiber, expirationtime);\n    console.log(\"root\", root);\n    // \n    // root fiberrootnode {tag: 0, current: fibernode, containerinfo: div#root, pendingchildren: null, pingcache: null, }\n    //  root \n    if (root === null) {\n        warnaboutupdateonunmountedfiberindev(fiber);\n        return;\n    }\n    // \n    checkforinterruption(fiber, expirationtime);\n    // \n    recordscheduleupdate();\n\n    // todo: computeexpirationforfiber also reads the priority. pass the\n    // priority as an argument to that function and this one.\n    // \n    const prioritylevel = getcurrentprioritylevel();\n\n    // \n    if (expirationtime === sync) {\n        if (\n            //  unbatchedupdates  rendering  commit \n            // check if we're inside unbatchedupdates\n            //  executioncontext  legacyunbatchedcontext executioncontext  rendercontext  commitcontext \n            (executioncontext & legacyunbatchedcontext) !== nocontext &&\n            // check if we're not already rendering\n            //  rendercontext  commitcontext render  commit \n            //  render  commit \n            (executioncontext & (rendercontext | commitcontext)) === nocontext\n        ) {\n            // register pending interactions on the root to avoid losing traced interaction data.\n            // \n            schedulependinginteractions(root, expirationtime);\n\n            // this is a legacy edge case. the initial mount of a reactdom.render-ed\n            // root inside of batchedupdates should be synchronous, but layout updates\n            // should be deferred until the end of the batch.\n            //  root reactdom  fibertree \n            performsyncworkonroot(root);\n        } else {\n\t\t\t      // root\n            ensurerootisscheduled(root);\n            // \n            schedulependinginteractions(root, expirationtime);\n            // \n            if (executioncontext === nocontext) {\n                // flush the synchronous work now, unless we're already working or inside\n                // a batch. this is intentionally inside scheduleupdateonfiber instead of\n                // schedulecallbackforfiber to preserve the ability to schedule a callback\n                // without immediately flushing it. we only do this for user-initiated\n                // updates, to preserve historical behavior of sync mode.\n                // \n                flushsynccallbackqueue();\n            }\n        }\n    } else {\n        // \n        ensurerootisscheduled(root);\n        schedulependinginteractions(root, expirationtime);\n    }\n\n   //  rootswithpendingdiscreteupdates \n    if (\n    (executioncontext & discreteeventcontext) !== nocontext &&\n    // only updates at user-blocking priority or greater are considered\n    // discrete, even inside a discrete event.\n    (prioritylevel === userblockingpriority ||\n      prioritylevel === immediatepriority)\n      // discreteeventcontext userblockingpriority  immediatepriority\n      //  click\n  ) {\n    // this is the result of a discrete event. track the lowest priority\n    // discrete update per root so we can flush them early, if needed.\n    if (rootswithpendingdiscreteupdates === null) {\n      // \n      rootswithpendingdiscreteupdates = new map([[root, expirationtime]]);\n    } else {\n      //  hostfiberroot \n      const lastdiscretetime = rootswithpendingdiscreteupdates.get(root);\n      //  hostfiberroot  hostfiberroot \n      if (lastdiscretetime === undefined || lastdiscretetime > expirationtime) {\n        rootswithpendingdiscreteupdates.set(root, expirationtime);\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n\n\n\n# markupdatetimefromfibertoroot fiber tree  expirationtime\n\n fiberroot  expirationtime fiber tree  expirationtimereact  fiber \n\n// rootroot\nfunction markupdatetimefromfibertoroot(fiber, expirationtime) {\n  // update the source fiber's expiration time\n  //  fiber  fiber.alternate  expirationtime\n  //  fiber  expirationtime  expirationtime  fiber  fiber \n  // \n  if (fiber.expirationtime < expirationtime) {\n    fiber.expirationtime = expirationtime;\n  }\n  let alternate = fiber.alternate;\n  if (alternate !== null && alternate.expirationtime < expirationtime) {\n    alternate.expirationtime = expirationtime;\n  }\n  // walk the parent path to the root and update the child expiration time.\n  //  root  fiber \n  let node = fiber.return;\n  let root = null;\n  //  fiber  hostroot  fiber  fiberroot\n  if (node === null && fiber.tag === hostroot) {\n    // fiber.return  root \n    root = fiber.statenode;\n  } else {\n    //  fiberroot\n    while (node !== null) {\n      //  node  alternate \n      alternate = node.alternate;\n      if (node.childexpirationtime < expirationtime) {\n        // childexpirationtime\n        node.childexpirationtime = expirationtime;\n        if (\n          alternate !== null &&\n          alternate.childexpirationtime < expirationtime\n        ) {\n          alternate.childexpirationtime = expirationtime;\n        }\n      } else if (\n        alternate !== null &&\n        alternate.childexpirationtime < expirationtime\n      ) {\n        alternate.childexpirationtime = expirationtime;\n      }\n      //  root \n      if (node.return === null && node.tag === hostroot) {\n        root = node.statenode;\n        break;\n      }\n      node = node.return;\n    }\n  }\n\n  if (root !== null) {\n    // root \n    if (workinprogressroot === root) {\n      // received an update to a tree that's in the middle of rendering. mark\n      // that's unprocessed work on this root.\n      // workinprogressrootnextunprocessedupdatetime \n      markunprocessedupdatetime(expirationtime);\n\n      if (workinprogressrootexitstatus === rootsuspendedwithdelay) {\n        // the root already suspended with a delay, which means this render\n        // definitely won't finish. since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. this has the\n        // effect of interrupting the current render and switching to the update.\n        // \n        // \n        // \n        // \n        // todo: this happens to work when receiving an update during the render\n        // phase, because of the trick inside computeexpirationforfiber to\n        // subtract 1 from `renderexpirationtime` to move it into a\n        // separate bucket. but we should probably model it with an exception,\n        // using the same mechanism we use to force hydration of a subtree.\n        // todo: this does not account for low pri updates that were already\n        // scheduled before the root started rendering. need to track the next\n        // pending expiration time (perhaps by backtracking the return path) and\n        // then trigger a restart in the `renderdidsuspenddelayifpossible` path.\n        markrootsuspendedattime(root, renderexpirationtime);\n      }\n    }\n    // mark that the root has a pending update.\n    //  root \n    markrootupdatedattime(root, expirationtime);\n  }\n\n  return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n *  expirationtime root \n * node.return === null && node.tag === hostroot  root \n\n\n# checkfornestedupdates: \n\n nestedupdatecount > nested_update_limit  maximum update depth exceeded  nested_update_limit  50 render  setstate \n\n\n# \n\nlet nestedupdatecount: number = 0;\nlet rootwithnestedupdates: fiberroot | null = null;\n\n\n1\n2\n\n\n commitrootimpl()  nestedupdatecount \n\nif (remainingexpirationtime === sync) {\n  // count the number of times the root synchronously re-renders without\n  // finishing. if there are too many, it indicates an infinite update loop.\n  if (root === rootwithnestedupdates) {\n\t  nestedupdatecount++;\n  } else {\n\t  nestedupdatecount = 0;\n\t  rootwithnestedupdates = root;\n  }\n} else {\n  nestedupdatecount = 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# checkforinterruption\n\ncheckforinterruption  fiber fiber  interruptedby \n\nfunction checkforinterruption(\n    fiberthatreceivedupdate: fiber,\n    updateexpirationtime: expirationtime,\n) {\n    if (\n        enableusertimingapi &&\n        workinprogressroot !== null &&\n        updateexpirationtime > renderexpirationtime\n        //  fiber\n    ) {\n        interruptedby = fiberthatreceivedupdate;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n fiber  fiber \n\n\n# recordscheduleupdate\n\nrecordscheduleupdate  commit  render  hasscheduledupdateincurrentcommit  hasscheduledupdateincurrentphase \n\nexport function recordscheduleupdate(): void {\n    if (enableusertimingapi) {\n        // iscommitting  commit \n        if (iscommitting) {\n            //  commit \n            hasscheduledupdateincurrentcommit = true;\n        }\n        if (\n            // currentphase  \n            currentphase !== null &&\n            currentphase !== 'componentwillmount' &&\n            currentphase !== 'componentwillreceiveprops'\n        ) {\n            // \n            hasscheduledupdateincurrentphase = true;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n ensurerootisscheduled  schedulependinginteractions \n\n ensurerootisscheduled  schedulependinginteractions \n\n\n# ensurerootisscheduled root \n\n// use this function to schedule a task for a root. there's only one task per\n// root; if a task was already scheduled, we'll check to make sure the\n// expiration time of the existing task is the same as the expiration time of\n// the next level that the root has work on. this function is called on every\n// update, and right before exiting a task.\n//  root  root  root \n// \nfunction ensurerootisscheduled(root: fiberroot) {\n  //lastexpiredtime  noworkmarkrootexpiredattime\n  const lastexpiredtime = root.lastexpiredtime;\n  //  lastexpiredtime  nowork root \n  if (lastexpiredtime !== nowork) {\n    // \n    // root\n    root.callbackexpirationtime = sync;\n    root.callbackpriority = immediatepriority;\n    root.callbacknode = schedulesynccallback(\n      performsyncworkonroot.bind(null, root),\n    );\n    return;\n  }\n\n  const expirationtime = getnextrootexpirationtimetoworkon(root);\n  const existingcallbacknode = root.callbacknode;\n  // \n  if (expirationtime === nowork) {\n    // there's nothing to work on.\n    if (existingcallbacknode !== null) {\n      root.callbacknode = null;\n      root.callbackexpirationtime = nowork;\n      root.callbackpriority = nopriority;\n    }\n    return;\n  }\n\n  // todo: if this is an update, we already read the current time. pass the\n  // time as an argument.\n  // \n  const currenttime = requestcurrenttime();\n  const prioritylevel = inferpriorityfromexpirationtime(\n    currenttime,\n    expirationtime,\n  );\n\n  // if there's an existing render task, confirm it has the correct priority and\n  // expiration time. otherwise, we'll cancel it and schedule a new one.\n  //  \n  //  root \n  if (existingcallbacknode !== null) {\n    const existingcallbackpriority = root.callbackpriority;\n    const existingcallbackexpirationtime = root.callbackexpirationtime;\n    if ( // \n      // callback must have the exact same expiration time.\n      existingcallbackexpirationtime === expirationtime &&\n      // callback must have greater or equal priority.\n      existingcallbackpriority >= prioritylevel\n      // \n    ) {\n      // existing callback is sufficient.\n      return;\n    }\n    // need to schedule a new task.\n    // todo: instead of scheduling a new task, we should be able to change the\n    // priority of the existing one.\n    // \n    cancelcallback(existingcallbacknode);\n  }\n\n  root.callbackexpirationtime = expirationtime;\n  root.callbackpriority = prioritylevel;\n\n  let callbacknode;\n  // \n  if (expirationtime === sync) {\n    // sync react callbacks are scheduled on a special internal queue\n    //  firstrender\n    callbacknode = schedulesynccallback(performsyncworkonroot.bind(null, root));\n  } else if (disableschedulertimeoutbasedonreactexpirationtime) {\n    callbacknode = schedulecallback(\n      prioritylevel,\n      performconcurrentworkonroot.bind(null, root),\n    );\n  } else {\n    // \n    callbacknode = schedulecallback(\n      prioritylevel,\n      performconcurrentworkonroot.bind(null, root),\n      // compute a task timeout based on the expiration time. this also affects\n      // ordering because tasks are processed in timeout order.\n      {timeout: expirationtimetoms(expirationtime) - now()},\n    );\n  }\n\n  root.callbacknode = callbacknode;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n\n *  schedulesynccallback  schedulecallback \n\n\n# schedulesynccallback\n\nfunction schedulesynccallback(callback: schedulercallback) {\n    // push this callback into an internal queue. we'll flush these either in\n    // the next tick, or earlier if something calls `flushsynccallbackqueue`.\n    if (syncqueue === null) {\n        // \n        syncqueue = [callback];\n        // flush the queue in the next tick, at the earliest.\n        // \n        immediatequeuecallbacknode = scheduler_schedulecallback(\n            scheduler_immediatepriority,\n            flushsynccallbackqueueimpl,\n        );\n    } else {\n        // push onto existing queue. don't need to schedule a callback because\n        // we already scheduled one when we created the queue.\n        // syncqueue\n        syncqueue.push(callback);\n    }\n    return fakecallbacknode;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n *  syncqueue \n *  scheduler_schedulecallback  tick  flushsynccallbackqueue \n * fakecallbacknode  callback  {}\n\n\n# schedulecallback\n\nschedulecallback  scheduler_schedulecallback  callback\n\nexport function schedulecallback(\n  reactprioritylevel: reactprioritylevel,\n  callback: schedulercallback,\n  options: schedulercallbackoptions | void | null,\n) {\n  const prioritylevel = reactprioritytoschedulerpriority(reactprioritylevel);\n  return scheduler_schedulecallback(prioritylevel, callback, options);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * scheduler_schedulecallback\n\n\n# schedulependinginteractions \n\n scheduleinteractions  pendinginteractionmap  map(<expirationtime>, <interactions set>) interactions \n\nfunction scheduleinteractions(root, expirationtime, interactions) {\n  // enableschedulertracing\n  if (!enableschedulertracing) {\n    return;\n  }\n  // interactions  __interactionsref.current \n  // pushinteractions  popinteractions  interactions \n  if (interactions.size > 0) {\n    const pendinginteractionmap = root.pendinginteractionmap;\n    const pendinginteractions = pendinginteractionmap.get(expirationtime);\n    //  pending \n    if (pendinginteractions != null) {\n      interactions.foreach(interaction => {\n        if (!pendinginteractions.has(interaction)) {\n          // update the pending async work count for previously unscheduled interaction.\n          //  pending \n          interaction.__count++;\n        }\n        //  interaction  pendinginteractions\n        pendinginteractions.add(interaction);\n      });\n    } else {\n      //  pending interactionspendinginteractionmap\n      // pendinginteractionmap  map(<expirationtime>, <interactions set>)\n      pendinginteractionmap.set(expirationtime, new set(interactions));\n\n      // update the pending async work count for the current interactions.\n      //  pending \n      interactions.foreach(interaction => {\n        interaction.__count++;\n      });\n    }\n    // \n    const subscriber = __subscriberref.current;\n    if (subscriber !== null) {\n      //  id\n      const threadid = computethreadid(root, expirationtime);\n      //  onworkscheduled \n      subscriber.onworkscheduled(interactions, threadid);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n pushinteractions \n\nfunction pushinteractions(root) {\n  if (enableschedulertracing) {\n    const previnteractions: set<interaction> | null = __interactionsref.current;\n    __interactionsref.current = root.memoizedinteractions;\n    return previnteractions;\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n interactions  root.memoizedinteractions pushinteractions  interactions\n\n firstrender  firstrender  firstrender  firstrender   \n\n\n# performsyncworkonroot\n\n\n# performconcurrentworkonroot\n\n\n# flushsynccallbackqueue\n\n\n# \n\n 1. scheduleupdateonfiber \n\nscheduleupdateonfiber  ensurerootisscheduled  react \n\n /        \n               performsyncworkonroot \n              schedulesynccallback  callback \n          -        schedulecallback  callback \n\n\n\n *  callback \n *  schedulesynccallback  schedulecallback  unstable_schedulecallback  unstable_schedulecallback \n\n 2. react \n\n * react  fiberroot fiberroot  hostroot  fiber \n *  expirationtime \n *  fiber  fiber  markupdatetimefromfibertoroot  fiber  expirationtime  fiber  fiberroot childexpirationtime \n *  schedulependinginteractions \n\n 3. \n\n react-reconciler  schedulerwithreactintegration.js \n\n\n\nconst {\n  unstable_runwithpriority: scheduler_runwithpriority,\n  unstable_schedulecallback: scheduler_schedulecallback,\n  unstable_cancelcallback: scheduler_cancelcallback,\n  unstable_shouldyield: scheduler_shouldyield,\n  unstable_requestpaint: scheduler_requestpaint,\n  unstable_now: scheduler_now,\n  unstable_getcurrentprioritylevel: scheduler_getcurrentprioritylevel,\n  unstable_immediatepriority: scheduler_immediatepriority,\n  unstable_userblockingpriority: scheduler_userblockingpriority,\n  unstable_normalpriority: scheduler_normalpriority,\n  unstable_lowpriority: scheduler_lowpriority,\n  unstable_idlepriority: scheduler_idlepriority,\n} = scheduler;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n schedulerwithreactintegration \n\n * getcurrentprioritylevel : \n * schedulesynccallback :  syncqueue\n * cancelcallback : \n * flushsynccallbackqueue :  syncqueue ",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"Lane ",frontmatter:{title:"Lane ",date:"2022-04-14T22:02:21.000Z",permalink:"/react/reconciliation/lane/",categories:["react","reconciliation"],tags:[null]},regularPath:"/10.react/20.%E8%B0%83%E5%92%8C%EF%BC%88Reconciliation%EF%BC%89/50.lane.html",relativePath:"10.react/20.Reconciliation/50.lane.md",key:"v-7050b2a0",path:"/react/reconciliation/lane/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/react/scheduler/index/",categories:["react","scheduler"],tags:[null]},regularPath:"/10.react/30.%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%88Scheduler%EF%BC%89/0.index.html",relativePath:"10.react/30.Scheduler/0.index.md",key:"v-41adcea0",path:"/react/scheduler/index/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:1409}],readingTime:{text:"1 min read",minutes:.41,time:24599.999999999996,words:82},headersStr:"",content:" fiber expirationTime  react  react  react  react \n\n FiberTree \n\n\n\n scheduler  Scheduler.js  scheduler \n\nexport {\n  // \n  ImmediatePriority as unstable_ImmediatePriority,\n  UserBlockingPriority as unstable_UserBlockingPriority,\n  NormalPriority as unstable_NormalPriority,\n  IdlePriority as unstable_IdlePriority,\n  LowPriority as unstable_LowPriority,\n  // \n  unstable_runWithPriority,\n  unstable_next,\n  // \n  unstable_scheduleCallback,\n  // \n  unstable_cancelCallback,\n  unstable_wrapCallback,\n  // \n  unstable_getCurrentPriorityLevel,\n  unstable_shouldYield,\n  unstable_requestPaint,\n  unstable_continueExecution,\n  unstable_pauseExecution,\n  unstable_getFirstCallbackNode,\n  getCurrentTime as unstable_now,\n  forceFrameRate as unstable_forceFrameRate,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# \n\n *  React \n *  16ms ",normalizedContent:" fiber expirationtime  react  react  react  react \n\n fibertree \n\n\n\n scheduler  scheduler.js  scheduler \n\nexport {\n  // \n  immediatepriority as unstable_immediatepriority,\n  userblockingpriority as unstable_userblockingpriority,\n  normalpriority as unstable_normalpriority,\n  idlepriority as unstable_idlepriority,\n  lowpriority as unstable_lowpriority,\n  // \n  unstable_runwithpriority,\n  unstable_next,\n  // \n  unstable_schedulecallback,\n  // \n  unstable_cancelcallback,\n  unstable_wrapcallback,\n  // \n  unstable_getcurrentprioritylevel,\n  unstable_shouldyield,\n  unstable_requestpaint,\n  unstable_continueexecution,\n  unstable_pauseexecution,\n  unstable_getfirstcallbacknode,\n  getcurrenttime as unstable_now,\n  forceframerate as unstable_forceframerate,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# \n\n *  react \n *  16ms ",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"scheduleCallback",frontmatter:{title:"scheduleCallback",date:"2022-04-14T22:02:21.000Z",permalink:"/react/scheduler/scheduleCallback/",categories:["react","scheduler"],tags:[null]},regularPath:"/10.react/30.%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%88Scheduler%EF%BC%89/10.scheduleCallback.html",relativePath:"10.react/30.Scheduler/10.scheduleCallback.md",key:"v-a7e4381c",path:"/react/scheduler/scheduleCallback/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"unstable_scheduleCallback",slug:"unstable-schedulecallback",normalizedTitle:"unstable_schedulecallback",charIndex:17},{level:2,title:"flushWork  workLoop",slug:"flushwork--workloop",normalizedTitle:"flushwork  workloop",charIndex:46},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:72},{level:3,title:"flushWork",slug:"flushwork",normalizedTitle:"flushwork",charIndex:46},{level:3,title:"advanceTimers",slug:"advancetimers",normalizedTitle:"advancetimers",charIndex:113},{level:3,title:"workLoop",slug:"workloop",normalizedTitle:"workloop",charIndex:58},{level:2,title:"handleTimeout",slug:"handletimeout",normalizedTitle:"handletimeout",charIndex:144},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:161}],readingTime:{text:"6 min read",minutes:5.855,time:351300,words:1171},headersStr:" unstable_scheduleCallback flushWork  workLoop  flushWork advanceTimers workLoop handleTimeout ",content:"# \n\n\n\n * \n * unstable_scheduleCallback\n * flushWork  workLoop\n   * \n   * flushWork\n   * advanceTimers\n   * workLoop\n * handleTimeout\n * \n\n\n\n\n# unstable_scheduleCallback\n\n scheduleSyncCallback  scheduleCallback  unstable_scheduleCllback unstable_scheduleCallback  scheduler/Scheduler.js \n\nunstable_scheduleCallback \n\nfunction unstable_scheduleCallback(priorityLevel, callback, options) {\n    // \n    var currentTime = getCurrentTime();\n\n    // startTime  timeout\n    var startTime;\n    var timeout;\n    if (typeof options === 'object' && options !== null) {\n        var delay = options.delay;\n        if (typeof delay === 'number' && delay > 0) {\n            startTime = currentTime + delay;\n        } else {\n            startTime = currentTime;\n        }\n        timeout =\n            typeof options.timeout === 'number' ?\n            options.timeout :\n            timeoutForPriorityLevel(priorityLevel);\n    } else {\n        timeout = timeoutForPriorityLevel(priorityLevel);\n        startTime = currentTime;\n    }\n    //  expirationTime\n    var expirationTime = startTime + timeout;\n    //  task\n    var newTask = {\n        //  id \n        id: taskIdCounter++,\n        // \n        callback,\n        // \n        priorityLevel,\n        // \n        startTime,\n        // \n        expirationTime,\n        // \n        sortIndex: -1,\n    };\n    if (enableProfiling) {\n        newTask.isQueued = false;\n    }\n\n    if (startTime > currentTime) {\n        // This is a delayed task.\n        // startTime  currentTime  task  delay\n        // \n        //  startTime \n        newTask.sortIndex = startTime;\n        //  task  \n        //  timerQueue \n        push(timerQueue, newTask);\n        //  newTask \n        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n            // All tasks are delayed, and this is the task with the earliest delay.\n            if (isHostTimeoutScheduled) {\n                // Cancel an existing timeout.\n                // \n                cancelHostTimeout();\n            } else {\n              // \n                isHostTimeoutScheduled = true;\n            }\n            // Schedule a timeout.\n            //  \n            requestHostTimeout(handleTimeout, startTime - currentTime);\n        }\n    } else {\n        //  expirationTime \n        newTask.sortIndex = expirationTime;\n        //  taskQueue\n        //  taskQueue \n        push(taskQueue, newTask);\n        if (enableProfiling) {\n            markTaskStart(newTask, currentTime);\n            newTask.isQueued = true;\n        }\n        // Schedule a host callback, if needed. If we're already performing work,\n        // wait until the next time we yield.\n        //\n        if (!isHostCallbackScheduled && !isPerformingWork) {\n            // \n            isHostCallbackScheduled = true;\n            // \n            requestHostCallback(flushWork);\n        }\n    }\n\n    return newTask;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n\n\n\n\n * \n *  taskQueue  timerQueue \n * \n\n 1.  startTime  expirationTime\n\n *  options  delay startTime = currentTime + delay  startTime = currentTime \n *  options  timeout timeout  options.timeout   timeout timeout = timeoutForPriorityLevel(priorityLevel) \n * expirationTime = startTime + timeout  currentTime + delay + timeout \n\n 2. \n\n startTime  currentTime  startTime > currentTime \n\n currentTime  options  delay  0 \n\n 3. callback \n\ncallback  newTask newTask  unstable_scheduleCallback \n\n 4. \n\n * \n\n taskQueue  requestHostCallback \n\n * \n\n timerQueue  requestHostTimeout \n\n 5. taskQueue  timerQueue \n\n// Tasks are stored on a min heap\nvar taskQueue = [];\nvar timerQueue = [];\n\n\n1\n2\n3\n\n *  [] \n * taskQueue  timerQueue  taskQueue \n\n 6. \n\n *  expirationTime expirationTime \n *  startTime startTime startTime = currentTime + delay\n\n 7. \n\n\n\n * # JS \n * #  9Top K\n\n 8.  SchedulerHostConfig  requestAnimationFrame  requestIdleCallback  API requestIdleCallbackreact  requestAnimationFrame  setTimeout  requestIdleCallback SchedulerHostConfig \n\n * requestHostTimeout\n * cancelHostTimeout\n * requestHostCallback\n\n\n# flushWork  workLoop\n\n unstable_scheduleCallback  callback delay requestHostTimeout  requestHostCallback \n\n\n# \n\npush(taskQueue, newTask);\nif (!isHostCallbackScheduled && !isPerformingWork) {\n  isHostCallbackScheduled = true;\n  //  \n  requestHostCallback(flushWork);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n unstable_scheduleCallback \n\n\n# flushWork\n\n// performWorkUntilDeadline hasTimeRemaining=trueinitialTime=currentTime\nfunction flushWork(hasTimeRemaining, initialTime) {\n  if (enableProfiling) {\n    markSchedulerUnsuspended(initialTime);\n  }\n\n  // We'll need a host callback the next time work is scheduled.\n  //  isPerformingWork \n  isHostCallbackScheduled = false;\n  if (isHostTimeoutScheduled) {\n    // We scheduled a timeout but it's no longer needed. Cancel it.\n    // \n    //  handleTimeout  workLoop \n    // \n    isHostTimeoutScheduled = false;\n    cancelHostTimeout();\n  }\n\n  // isPerformingWork \n  isPerformingWork = true;\n  const previousPriorityLevel = currentPriorityLevel;\n  try {\n    if (enableProfiling) {\n      try {\n        //  workLoop\n        return workLoop(hasTimeRemaining, initialTime);\n      } catch (error) {\n        if (currentTask !== null) {\n          const currentTime = getCurrentTime();\n          markTaskErrored(currentTask, currentTime);\n          currentTask.isQueued = false;\n        }\n        throw error;\n      }\n    } else {\n      // No catch in prod codepath.\n      return workLoop(hasTimeRemaining, initialTime);\n    }\n  } finally {\n    // \n    currentTask = null;\n    currentPriorityLevel = previousPriorityLevel;\n    isPerformingWork = false;\n    if (enableProfiling) {\n      const currentTime = getCurrentTime();\n      markSchedulerSuspended(currentTime);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n workLoop  workLoop \n\n\n# advanceTimers\n\n workLoop  advanceTimers  advanceTimers \n\nadvanceTimers \n\nfunction advanceTimers(currentTime) {\n  // Check for tasks that are no longer delayed and add them to the queue.\n  // \n  let timer = peek(timerQueue);\n  while (timer !== null) {\n    // callback  null\n    if (timer.callback === null) {\n      // Timer was cancelled.\n      pop(timerQueue);\n    } else if (timer.startTime <= currentTime) {\n      // Timer fired. Transfer to the task queue.\n      // startTime \n      // \n      pop(timerQueue);\n      timer.sortIndex = timer.expirationTime;\n      push(taskQueue, timer);\n      if (enableProfiling) {\n        markTaskStart(timer, currentTime);\n        timer.isQueued = true;\n      }\n    } else {\n      // Remaining timers are pending.\n      // \n      return;\n    }\n    // \n    timer = peek(timerQueue);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\nadvanceTimers \n\n\n# workLoop\n\n\n\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  // \n  advanceTimers(currentTime);\n  // \n  currentTask = peek(taskQueue);\n  while (\n    currentTask !== null &&\n    // isSchedulerPaused \n    !(enableSchedulerDebugging && isSchedulerPaused)\n  ) {\n    if (\n      currentTask.expirationTime > currentTime &&\n      (!hasTimeRemaining || shouldYieldToHost())\n    ) {\n      // \n      // \n      // This currentTask hasn't expired, and we've reached the deadline.\n      break;\n    }\n    // \n    const callback = currentTask.callback;\n    // \n    if (callback !== null) {\n      //  callback \n      currentTask.callback = null;\n      currentPriorityLevel = currentTask.priorityLevel;\n      // didUserCallbackTimeout  true\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      markTaskRun(currentTask, currentTime);\n      // \n      // \n      const continuationCallback = callback(didUserCallbackTimeout);\n      currentTime = getCurrentTime();\n      // \n      if (typeof continuationCallback === 'function') {\n        // callback callback \n        currentTask.callback = continuationCallback;\n        markTaskYield(currentTask, currentTime);\n      } else {\n        if (enableProfiling) {\n          markTaskCompleted(currentTask, currentTime);\n          currentTask.isQueued = false;\n        }\n        // \n        if (currentTask === peek(taskQueue)) {\n          pop(taskQueue);\n        }\n      }\n      // \n      advanceTimers(currentTime);\n    } else {\n      // \n      pop(taskQueue);\n    }\n    // \n    currentTask = peek(taskQueue);\n  }\n  // Return whether there's additional work\n  if (currentTask !== null) {\n    //  true\n    // \n    //  performWorkUntilDeadline  port.postMessage  \n    return true;\n  } else {\n    // \n    let firstTimer = peek(timerQueue);\n    if (firstTimer !== null) {\n      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n    }\n    //  false \n    return false;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n *  expiration = start + time  timeout  expirationhasTimeRemaining  shouldYieldToHost () \n\n\n\n 1. \n\n\n\n\n\n * \n *  \n\n\n\n workLoop  true\n\n 2. \n\n\n\n * \n * \n\n\n\nworkLoop  callback  callback  'function'  workLoop  callback  null workLoop \n\n 1. \n\n\n\n 4. \n\n performWorkUntilDeadline  true  false \n\n:\n\n\n# handleTimeout\n\n advanceTimers \n\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = false;\n  // \n  advanceTimers(currentTime);\n  // \n  if (!isHostCallbackScheduled) {\n    // \n    if (peek(taskQueue) !== null) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    } else {\n      //  timeout \n      const firstTimer = peek(timerQueue);\n      if (firstTimer !== null) {\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n\n * handleTimeout \n *  workLoop \n * \n\n\n# \n\n",normalizedContent:"# \n\n\n\n * \n * unstable_schedulecallback\n * flushwork  workloop\n   * \n   * flushwork\n   * advancetimers\n   * workloop\n * handletimeout\n * \n\n\n\n\n# unstable_schedulecallback\n\n schedulesynccallback  schedulecallback  unstable_schedulecllback unstable_schedulecallback  scheduler/scheduler.js \n\nunstable_schedulecallback \n\nfunction unstable_schedulecallback(prioritylevel, callback, options) {\n    // \n    var currenttime = getcurrenttime();\n\n    // starttime  timeout\n    var starttime;\n    var timeout;\n    if (typeof options === 'object' && options !== null) {\n        var delay = options.delay;\n        if (typeof delay === 'number' && delay > 0) {\n            starttime = currenttime + delay;\n        } else {\n            starttime = currenttime;\n        }\n        timeout =\n            typeof options.timeout === 'number' ?\n            options.timeout :\n            timeoutforprioritylevel(prioritylevel);\n    } else {\n        timeout = timeoutforprioritylevel(prioritylevel);\n        starttime = currenttime;\n    }\n    //  expirationtime\n    var expirationtime = starttime + timeout;\n    //  task\n    var newtask = {\n        //  id \n        id: taskidcounter++,\n        // \n        callback,\n        // \n        prioritylevel,\n        // \n        starttime,\n        // \n        expirationtime,\n        // \n        sortindex: -1,\n    };\n    if (enableprofiling) {\n        newtask.isqueued = false;\n    }\n\n    if (starttime > currenttime) {\n        // this is a delayed task.\n        // starttime  currenttime  task  delay\n        // \n        //  starttime \n        newtask.sortindex = starttime;\n        //  task  \n        //  timerqueue \n        push(timerqueue, newtask);\n        //  newtask \n        if (peek(taskqueue) === null && newtask === peek(timerqueue)) {\n            // all tasks are delayed, and this is the task with the earliest delay.\n            if (ishosttimeoutscheduled) {\n                // cancel an existing timeout.\n                // \n                cancelhosttimeout();\n            } else {\n              // \n                ishosttimeoutscheduled = true;\n            }\n            // schedule a timeout.\n            //  \n            requesthosttimeout(handletimeout, starttime - currenttime);\n        }\n    } else {\n        //  expirationtime \n        newtask.sortindex = expirationtime;\n        //  taskqueue\n        //  taskqueue \n        push(taskqueue, newtask);\n        if (enableprofiling) {\n            marktaskstart(newtask, currenttime);\n            newtask.isqueued = true;\n        }\n        // schedule a host callback, if needed. if we're already performing work,\n        // wait until the next time we yield.\n        //\n        if (!ishostcallbackscheduled && !isperformingwork) {\n            // \n            ishostcallbackscheduled = true;\n            // \n            requesthostcallback(flushwork);\n        }\n    }\n\n    return newtask;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n\n\n\n\n * \n *  taskqueue  timerqueue \n * \n\n 1.  starttime  expirationtime\n\n *  options  delay starttime = currenttime + delay  starttime = currenttime \n *  options  timeout timeout  options.timeout   timeout timeout = timeoutforprioritylevel(prioritylevel) \n * expirationtime = starttime + timeout  currenttime + delay + timeout \n\n 2. \n\n starttime  currenttime  starttime > currenttime \n\n currenttime  options  delay  0 \n\n 3. callback \n\ncallback  newtask newtask  unstable_schedulecallback \n\n 4. \n\n * \n\n taskqueue  requesthostcallback \n\n * \n\n timerqueue  requesthosttimeout \n\n 5. taskqueue  timerqueue \n\n// tasks are stored on a min heap\nvar taskqueue = [];\nvar timerqueue = [];\n\n\n1\n2\n3\n\n *  [] \n * taskqueue  timerqueue  taskqueue \n\n 6. \n\n *  expirationtime expirationtime \n *  starttime starttime starttime = currenttime + delay\n\n 7. \n\n\n\n * # js \n * #  9top k\n\n 8.  schedulerhostconfig  requestanimationframe  requestidlecallback  api requestidlecallbackreact  requestanimationframe  settimeout  requestidlecallback schedulerhostconfig \n\n * requesthosttimeout\n * cancelhosttimeout\n * requesthostcallback\n\n\n# flushwork  workloop\n\n unstable_schedulecallback  callback delay requesthosttimeout  requesthostcallback \n\n\n# \n\npush(taskqueue, newtask);\nif (!ishostcallbackscheduled && !isperformingwork) {\n  ishostcallbackscheduled = true;\n  //  \n  requesthostcallback(flushwork);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n unstable_schedulecallback \n\n\n# flushwork\n\n// performworkuntildeadline hastimeremaining=trueinitialtime=currenttime\nfunction flushwork(hastimeremaining, initialtime) {\n  if (enableprofiling) {\n    markschedulerunsuspended(initialtime);\n  }\n\n  // we'll need a host callback the next time work is scheduled.\n  //  isperformingwork \n  ishostcallbackscheduled = false;\n  if (ishosttimeoutscheduled) {\n    // we scheduled a timeout but it's no longer needed. cancel it.\n    // \n    //  handletimeout  workloop \n    // \n    ishosttimeoutscheduled = false;\n    cancelhosttimeout();\n  }\n\n  // isperformingwork \n  isperformingwork = true;\n  const previousprioritylevel = currentprioritylevel;\n  try {\n    if (enableprofiling) {\n      try {\n        //  workloop\n        return workloop(hastimeremaining, initialtime);\n      } catch (error) {\n        if (currenttask !== null) {\n          const currenttime = getcurrenttime();\n          marktaskerrored(currenttask, currenttime);\n          currenttask.isqueued = false;\n        }\n        throw error;\n      }\n    } else {\n      // no catch in prod codepath.\n      return workloop(hastimeremaining, initialtime);\n    }\n  } finally {\n    // \n    currenttask = null;\n    currentprioritylevel = previousprioritylevel;\n    isperformingwork = false;\n    if (enableprofiling) {\n      const currenttime = getcurrenttime();\n      markschedulersuspended(currenttime);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n workloop  workloop \n\n\n# advancetimers\n\n workloop  advancetimers  advancetimers \n\nadvancetimers \n\nfunction advancetimers(currenttime) {\n  // check for tasks that are no longer delayed and add them to the queue.\n  // \n  let timer = peek(timerqueue);\n  while (timer !== null) {\n    // callback  null\n    if (timer.callback === null) {\n      // timer was cancelled.\n      pop(timerqueue);\n    } else if (timer.starttime <= currenttime) {\n      // timer fired. transfer to the task queue.\n      // starttime \n      // \n      pop(timerqueue);\n      timer.sortindex = timer.expirationtime;\n      push(taskqueue, timer);\n      if (enableprofiling) {\n        marktaskstart(timer, currenttime);\n        timer.isqueued = true;\n      }\n    } else {\n      // remaining timers are pending.\n      // \n      return;\n    }\n    // \n    timer = peek(timerqueue);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\nadvancetimers \n\n\n# workloop\n\n\n\nfunction workloop(hastimeremaining, initialtime) {\n  let currenttime = initialtime;\n  // \n  advancetimers(currenttime);\n  // \n  currenttask = peek(taskqueue);\n  while (\n    currenttask !== null &&\n    // isschedulerpaused \n    !(enableschedulerdebugging && isschedulerpaused)\n  ) {\n    if (\n      currenttask.expirationtime > currenttime &&\n      (!hastimeremaining || shouldyieldtohost())\n    ) {\n      // \n      // \n      // this currenttask hasn't expired, and we've reached the deadline.\n      break;\n    }\n    // \n    const callback = currenttask.callback;\n    // \n    if (callback !== null) {\n      //  callback \n      currenttask.callback = null;\n      currentprioritylevel = currenttask.prioritylevel;\n      // didusercallbacktimeout  true\n      const didusercallbacktimeout = currenttask.expirationtime <= currenttime;\n      marktaskrun(currenttask, currenttime);\n      // \n      // \n      const continuationcallback = callback(didusercallbacktimeout);\n      currenttime = getcurrenttime();\n      // \n      if (typeof continuationcallback === 'function') {\n        // callback callback \n        currenttask.callback = continuationcallback;\n        marktaskyield(currenttask, currenttime);\n      } else {\n        if (enableprofiling) {\n          marktaskcompleted(currenttask, currenttime);\n          currenttask.isqueued = false;\n        }\n        // \n        if (currenttask === peek(taskqueue)) {\n          pop(taskqueue);\n        }\n      }\n      // \n      advancetimers(currenttime);\n    } else {\n      // \n      pop(taskqueue);\n    }\n    // \n    currenttask = peek(taskqueue);\n  }\n  // return whether there's additional work\n  if (currenttask !== null) {\n    //  true\n    // \n    //  performworkuntildeadline  port.postmessage  \n    return true;\n  } else {\n    // \n    let firsttimer = peek(timerqueue);\n    if (firsttimer !== null) {\n      requesthosttimeout(handletimeout, firsttimer.starttime - currenttime);\n    }\n    //  false \n    return false;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n *  expiration = start + time  timeout  expirationhastimeremaining  shouldyieldtohost () \n\n\n\n 1. \n\n\n\n\n\n * \n *  \n\n\n\n workloop  true\n\n 2. \n\n\n\n * \n * \n\n\n\nworkloop  callback  callback  'function'  workloop  callback  null workloop \n\n 1. \n\n\n\n 4. \n\n performworkuntildeadline  true  false \n\n:\n\n\n# handletimeout\n\n advancetimers \n\nfunction handletimeout(currenttime) {\n  ishosttimeoutscheduled = false;\n  // \n  advancetimers(currenttime);\n  // \n  if (!ishostcallbackscheduled) {\n    // \n    if (peek(taskqueue) !== null) {\n      ishostcallbackscheduled = true;\n      requesthostcallback(flushwork);\n    } else {\n      //  timeout \n      const firsttimer = peek(timerqueue);\n      if (firsttimer !== null) {\n        requesthosttimeout(handletimeout, firsttimer.starttime - currenttime);\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n\n * handletimeout \n *  workloop \n * \n\n\n# \n\n",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"schedulerHostConfig",frontmatter:{title:"schedulerHostConfig",date:"2022-04-14T22:02:21.000Z",permalink:"/react/scheduler/schedulerHostConfig/",categories:["react","scheduler"],tags:[null]},regularPath:"/10.react/30.%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%88Scheduler%EF%BC%89/20.schedulerHostConfig.html",relativePath:"10.react/30.Scheduler/20.schedulerHostConfig.md",key:"v-fefa4114",path:"/react/scheduler/schedulerHostConfig/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:" DOM ",slug:"-dom-",normalizedTitle:" dom ",charIndex:17},{level:2,title:"requestHostCallback",slug:"requesthostcallback-",normalizedTitle:"requesthostcallback",charIndex:29},{level:3,title:"postMessage",slug:"postmessage-",normalizedTitle:"postmessage",charIndex:62},{level:3,title:"performWorkUntilDeadline: ",slug:"performworkuntildeadline-",normalizedTitle:"performworkuntildeadline: ",charIndex:86},{level:3,title:"onAnimationFrame",slug:"onanimationframe",normalizedTitle:"onanimationframe",charIndex:124},{level:2,title:"cancelHostCallback",slug:"cancelhostcallback",normalizedTitle:"cancelhostcallback",charIndex:144},{level:2,title:"requestHostTimeout",slug:"requesthosttimeout-",normalizedTitle:"requesthosttimeout",charIndex:166},{level:2,title:"cancelHostTimeout",slug:"cancelhosttimeout-",normalizedTitle:"cancelhosttimeout",charIndex:198}],readingTime:{text:"7 min read",minutes:6.025,time:361500,words:1205},headersStr:"  DOM  requestHostCallback postMessage performWorkUntilDeadline:  onAnimationFrame cancelHostCallback requestHostTimeout cancelHostTimeout",content:"# \n\n\n\n * \n *  DOM \n * requestHostCallback\n   * postMessage\n   * performWorkUntilDeadline: \n   * onAnimationFrame\n * cancelHostCallback\n * requestHostTimeout\n * cancelHostTimeout\n\n\n\n\n#  DOM \n\n DOM  rAF Api setTimeout  node \n\nif (\n  // If Scheduler runs in a non-DOM environment, it falls back to a naive\n  // implementation using setTimeout.\n  //  DOM  setTimeout   DOM  rAF Api\n  typeof window === 'undefined' ||\n  // Check if MessageChannel is supported, too.\n  // DOM  MessageChannel API\n  //  window MessageChannel  setTimeout \n  typeof MessageChannel !== 'function'\n) {\n  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\n  // fallback to a naive implementation.\n  let _callback = null;\n  let _timeoutID = null;\n  //  callback \n  const _flushCallback = function() {\n    if (_callback !== null) {\n      try {\n        const currentTime = getCurrentTime();\n        const hasRemainingTime = true;\n        _callback(hasRemainingTime, currentTime);\n        _callback = null;\n      } catch (e) {\n        setTimeout(_flushCallback, 0);\n        throw e;\n      }\n    }\n  };\n  // Scheduler \n  const initialTime = Date.now();\n  // \n  getCurrentTime = function() {\n    return Date.now() - initialTime;\n  };\n  // \n  requestHostCallback = function(cb) {\n    if (_callback !== null) {\n      // Protect against re-entrancy.\n      //  requestHostCallback  0 \n      //  cb \n      //  callback  flush\n      setTimeout(requestHostCallback, 0, cb);\n    } else {\n      // callback  cb callback\n      _callback = cb;\n      setTimeout(_flushCallback, 0);\n    }\n  };\n  //   _callback \n  cancelHostCallback = function() {\n    _callback = null;\n  };\n  //  setTimeout\n  requestHostTimeout = function(cb, ms) {\n    _timeoutID = setTimeout(cb, ms);\n  };\n  //  _timeoutID \n  cancelHostTimeout = function() {\n    clearTimeout(_timeoutID);\n  };\n  shouldYieldToHost = function() {\n    return false;\n  };\n  // \n  requestPaint = forceFrameRate = function() {};\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n DOM  rAF  setTimeout \n\n\n# requestHostCallback\n\n// \nrequestHostCallback = function (callback) {\n  //  callback\n  scheduledHostCallback = callback;\n  if (enableMessageLoopImplementation) {\n    // \n    if (!isMessageLoopRunning) {\n      isMessageLoopRunning = true;\n      port.postMessage(null);\n    }\n  } else {\n    // enableMessageLoopImplementation false( messageChannel Api) RAF \n    if (!isRAFLoopRunning) {\n      // Start a rAF loop.\n      isRAFLoopRunning = true;\n      // rAFTime  performance.now() \n      requestAnimationFrame(rAFTime => {\n        onAnimationFrame(rAFTime);\n      });\n    }\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n enableMessageLoopImplementation \n\n\n# postMessage\n\n// see: https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel\nconst channel = new MessageChannel();\nconst port = channel.port2;\n//  port  performWorkUntilDeadline\nchannel.port1.onmessage = performWorkUntilDeadline;\n\n\n1\n2\n3\n4\n5\n\n\n MessageChannel API port1  post2  port1  port  performWorkUntilDeadline\n\n\n# performWorkUntilDeadline: \n\nperformWorkUntilDeadline \n\n// \nconst performWorkUntilDeadline = () => {\n  if (enableMessageLoopImplementation) {\n    if (scheduledHostCallback !== null) {\n      const currentTime = getCurrentTime();\n      // Yield after `frameLength` ms, regardless of where we are in the vsync\n      // cycle(). This means there's always time remaining at the beginning of\n      // the message event.\n      //  frameLength  yield\n      frameDeadline = currentTime + frameLength;\n      const hasTimeRemaining = true;\n      // \n      try {\n        const hasMoreWork = scheduledHostCallback(\n          hasTimeRemaining,\n          currentTime,\n        );\n        //  scheduledHostCallback\n        //  react \n        if (!hasMoreWork) {\n          isMessageLoopRunning = false;\n          scheduledHostCallback = null;\n        } else {\n          // If there's more work, schedule the next message event at the end\n          // of the preceding one.\n          // \n          //  react \n          port.postMessage(null);\n        }\n      } catch (error) {\n        // If a scheduler task throws, exit the current browser task so the\n        // error can be observed.\n        // \n        port.postMessage(null);\n        throw error;\n      }\n    } else {\n      // \n      isMessageLoopRunning = false;\n    }\n    // Yielding to the browser will give it a chance to paint, so we can\n    // reset this.\n    needsPaint = false;\n  } else {\n    //  MessageLoop  \n    if (scheduledHostCallback !== null) {\n      const currentTime = getCurrentTime();\n      const hasTimeRemaining = frameDeadline - currentTime > 0;\n      try {\n        const hasMoreWork = scheduledHostCallback(\n          hasTimeRemaining,\n          currentTime,\n        );\n        if (!hasMoreWork) {\n          scheduledHostCallback = null;\n        }\n      } catch (error) {\n        // If a scheduler task throws, exit the current browser task so the\n        // error can be observed, and post a new task as soon as possible\n        // so we can continue where we left off.\n        port.postMessage(null);\n        throw error;\n      }\n    }\n    // Yielding to the browser will give it a chance to paint, so we can\n    // reset this.\n    needsPaint = false;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# onAnimationFrame\n\nconst onAnimationFrame = rAFTime => {\n  // \n  if (scheduledHostCallback === null) {\n    // No scheduled work. Exit.\n    prevRAFTime = -1;\n    prevRAFInterval = -1;\n    isRAFLoopRunning = false;\n    return;\n  }\n\n  // Eagerly schedule the next animation callback at the beginning of the\n  // frame. If the scheduler queue is not empty at the end of the frame, it\n  // will continue flushing inside that callback. If the queue *is* empty,\n  // then it will exit immediately. Posting the callback at the start of the\n  // frame ensures it's fired within the earliest possible frame. If we\n  // waited until the end of the frame to post the callback, we risk the\n  // browser skipping a frame and not firing the callback until the frame\n  // after that.\n  // \n  // \n  // \n  isRAFLoopRunning = true;\n  requestAnimationFrame(nextRAFTime => {\\=\n    // onAnimationFrame\n    clearTimeout(rAFTimeoutID);\n    onAnimationFrame(nextRAFTime);\n  });\n\n  // requestAnimationFrame is throttled when the tab is backgrounded. We\n  // don't want to stop working entirely. So we'll fallback to a timeout loop.\n  // TODO: Need a better heuristic for backgrounded work.\n  //  tab rAF  setTimeout\n  const onTimeout = () => {\n    frameDeadline = getCurrentTime() + frameLength / 2;\n    performWorkUntilDeadline();\n    rAFTimeoutID = setTimeout(onTimeout, frameLength * 3);\n  };\n  rAFTimeoutID = setTimeout(onTimeout, frameLength * 3);\n\n  if (\n    prevRAFTime !== -1 &&\n    // Make sure this rAF time is different from the previous one. This check\n    // could fail if two rAFs fire in the same frame.\n    //  rAF  rAF rAFTime  prevRAFTime \n    rAFTime - prevRAFTime > 0.1\n  ) {\n    const rAFInterval = rAFTime - prevRAFTime;\n    if (!fpsLocked && prevRAFInterval !== -1) {\n      // We've observed two consecutive frame intervals. We'll use this to\n      // dynamically adjust the frame rate.\n\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently\n      // optimizing. For example, if we're running on 120hz display or 90hz VR\n      // display. Take the max of the two in case one of them was an anomaly\n      // due to missed frame deadlines.\n      // \n      //  frameLength CPU () yield  frameLength\n      //  frameLength\n      if (rAFInterval < frameLength && prevRAFInterval < frameLength) {\n        // \n        frameLength =\n          rAFInterval < prevRAFInterval ? prevRAFInterval : rAFInterval;\n        //  8.33\n        if (frameLength < 8.33) {\n          // Defensive coding. We don't support higher frame rates than 120hz.\n          // If the calculated frame length gets lower than 8, it is probably\n          // a bug.\n          //  120 \n          frameLength = 8.33;\n        }\n      }\n    }\n    prevRAFInterval = rAFInterval;\n  }\n  // rAFTimeframeDeadline\n  prevRAFTime = rAFTime;\n  frameDeadline = rAFTime + frameLength;\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  // \n  // \n  port.postMessage(null);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n\n# cancelHostCallback\n\ncancelHostCallback = function() {\n  scheduledHostCallback = null;\n};\n\n\n1\n2\n3\n\n\n\n# requestHostTimeout\n\n//  setTimeout\nrequestHostTimeout = function(callback, ms) {\n  taskTimeoutID = setTimeout(() => {\n    callback(getCurrentTime());\n  }, ms);\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# cancelHostTimeout\n\ncancelHostTimeout = function() {\n  clearTimeout(taskTimeoutID);\n  taskTimeoutID = -1;\n};\n\n\n1\n2\n3\n4\n",normalizedContent:"# \n\n\n\n * \n *  dom \n * requesthostcallback\n   * postmessage\n   * performworkuntildeadline: \n   * onanimationframe\n * cancelhostcallback\n * requesthosttimeout\n * cancelhosttimeout\n\n\n\n\n#  dom \n\n dom  raf api settimeout  node \n\nif (\n  // if scheduler runs in a non-dom environment, it falls back to a naive\n  // implementation using settimeout.\n  //  dom  settimeout   dom  raf api\n  typeof window === 'undefined' ||\n  // check if messagechannel is supported, too.\n  // dom  messagechannel api\n  //  window messagechannel  settimeout \n  typeof messagechannel !== 'function'\n) {\n  // if this accidentally gets imported in a non-browser environment, e.g. javascriptcore,\n  // fallback to a naive implementation.\n  let _callback = null;\n  let _timeoutid = null;\n  //  callback \n  const _flushcallback = function() {\n    if (_callback !== null) {\n      try {\n        const currenttime = getcurrenttime();\n        const hasremainingtime = true;\n        _callback(hasremainingtime, currenttime);\n        _callback = null;\n      } catch (e) {\n        settimeout(_flushcallback, 0);\n        throw e;\n      }\n    }\n  };\n  // scheduler \n  const initialtime = date.now();\n  // \n  getcurrenttime = function() {\n    return date.now() - initialtime;\n  };\n  // \n  requesthostcallback = function(cb) {\n    if (_callback !== null) {\n      // protect against re-entrancy.\n      //  requesthostcallback  0 \n      //  cb \n      //  callback  flush\n      settimeout(requesthostcallback, 0, cb);\n    } else {\n      // callback  cb callback\n      _callback = cb;\n      settimeout(_flushcallback, 0);\n    }\n  };\n  //   _callback \n  cancelhostcallback = function() {\n    _callback = null;\n  };\n  //  settimeout\n  requesthosttimeout = function(cb, ms) {\n    _timeoutid = settimeout(cb, ms);\n  };\n  //  _timeoutid \n  cancelhosttimeout = function() {\n    cleartimeout(_timeoutid);\n  };\n  shouldyieldtohost = function() {\n    return false;\n  };\n  // \n  requestpaint = forceframerate = function() {};\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n dom  raf  settimeout \n\n\n# requesthostcallback\n\n// \nrequesthostcallback = function (callback) {\n  //  callback\n  scheduledhostcallback = callback;\n  if (enablemessageloopimplementation) {\n    // \n    if (!ismessagelooprunning) {\n      ismessagelooprunning = true;\n      port.postmessage(null);\n    }\n  } else {\n    // enablemessageloopimplementation false( messagechannel api) raf \n    if (!israflooprunning) {\n      // start a raf loop.\n      israflooprunning = true;\n      // raftime  performance.now() \n      requestanimationframe(raftime => {\n        onanimationframe(raftime);\n      });\n    }\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n enablemessageloopimplementation \n\n\n# postmessage\n\n// see: https://developer.mozilla.org/en-us/docs/web/api/messagechannel\nconst channel = new messagechannel();\nconst port = channel.port2;\n//  port  performworkuntildeadline\nchannel.port1.onmessage = performworkuntildeadline;\n\n\n1\n2\n3\n4\n5\n\n\n messagechannel api port1  post2  port1  port  performworkuntildeadline\n\n\n# performworkuntildeadline: \n\nperformworkuntildeadline \n\n// \nconst performworkuntildeadline = () => {\n  if (enablemessageloopimplementation) {\n    if (scheduledhostcallback !== null) {\n      const currenttime = getcurrenttime();\n      // yield after `framelength` ms, regardless of where we are in the vsync\n      // cycle(). this means there's always time remaining at the beginning of\n      // the message event.\n      //  framelength  yield\n      framedeadline = currenttime + framelength;\n      const hastimeremaining = true;\n      // \n      try {\n        const hasmorework = scheduledhostcallback(\n          hastimeremaining,\n          currenttime,\n        );\n        //  scheduledhostcallback\n        //  react \n        if (!hasmorework) {\n          ismessagelooprunning = false;\n          scheduledhostcallback = null;\n        } else {\n          // if there's more work, schedule the next message event at the end\n          // of the preceding one.\n          // \n          //  react \n          port.postmessage(null);\n        }\n      } catch (error) {\n        // if a scheduler task throws, exit the current browser task so the\n        // error can be observed.\n        // \n        port.postmessage(null);\n        throw error;\n      }\n    } else {\n      // \n      ismessagelooprunning = false;\n    }\n    // yielding to the browser will give it a chance to paint, so we can\n    // reset this.\n    needspaint = false;\n  } else {\n    //  messageloop  \n    if (scheduledhostcallback !== null) {\n      const currenttime = getcurrenttime();\n      const hastimeremaining = framedeadline - currenttime > 0;\n      try {\n        const hasmorework = scheduledhostcallback(\n          hastimeremaining,\n          currenttime,\n        );\n        if (!hasmorework) {\n          scheduledhostcallback = null;\n        }\n      } catch (error) {\n        // if a scheduler task throws, exit the current browser task so the\n        // error can be observed, and post a new task as soon as possible\n        // so we can continue where we left off.\n        port.postmessage(null);\n        throw error;\n      }\n    }\n    // yielding to the browser will give it a chance to paint, so we can\n    // reset this.\n    needspaint = false;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# onanimationframe\n\nconst onanimationframe = raftime => {\n  // \n  if (scheduledhostcallback === null) {\n    // no scheduled work. exit.\n    prevraftime = -1;\n    prevrafinterval = -1;\n    israflooprunning = false;\n    return;\n  }\n\n  // eagerly schedule the next animation callback at the beginning of the\n  // frame. if the scheduler queue is not empty at the end of the frame, it\n  // will continue flushing inside that callback. if the queue *is* empty,\n  // then it will exit immediately. posting the callback at the start of the\n  // frame ensures it's fired within the earliest possible frame. if we\n  // waited until the end of the frame to post the callback, we risk the\n  // browser skipping a frame and not firing the callback until the frame\n  // after that.\n  // \n  // \n  // \n  israflooprunning = true;\n  requestanimationframe(nextraftime => {\\=\n    // onanimationframe\n    cleartimeout(raftimeoutid);\n    onanimationframe(nextraftime);\n  });\n\n  // requestanimationframe is throttled when the tab is backgrounded. we\n  // don't want to stop working entirely. so we'll fallback to a timeout loop.\n  // todo: need a better heuristic for backgrounded work.\n  //  tab raf  settimeout\n  const ontimeout = () => {\n    framedeadline = getcurrenttime() + framelength / 2;\n    performworkuntildeadline();\n    raftimeoutid = settimeout(ontimeout, framelength * 3);\n  };\n  raftimeoutid = settimeout(ontimeout, framelength * 3);\n\n  if (\n    prevraftime !== -1 &&\n    // make sure this raf time is different from the previous one. this check\n    // could fail if two rafs fire in the same frame.\n    //  raf  raf raftime  prevraftime \n    raftime - prevraftime > 0.1\n  ) {\n    const rafinterval = raftime - prevraftime;\n    if (!fpslocked && prevrafinterval !== -1) {\n      // we've observed two consecutive frame intervals. we'll use this to\n      // dynamically adjust the frame rate.\n\n      // if one frame goes long, then the next one can be short to catch up.\n      // if two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently\n      // optimizing. for example, if we're running on 120hz display or 90hz vr\n      // display. take the max of the two in case one of them was an anomaly\n      // due to missed frame deadlines.\n      // \n      //  framelength cpu () yield  framelength\n      //  framelength\n      if (rafinterval < framelength && prevrafinterval < framelength) {\n        // \n        framelength =\n          rafinterval < prevrafinterval ? prevrafinterval : rafinterval;\n        //  8.33\n        if (framelength < 8.33) {\n          // defensive coding. we don't support higher frame rates than 120hz.\n          // if the calculated frame length gets lower than 8, it is probably\n          // a bug.\n          //  120 \n          framelength = 8.33;\n        }\n      }\n    }\n    prevrafinterval = rafinterval;\n  }\n  // raftimeframedeadline\n  prevraftime = raftime;\n  framedeadline = raftime + framelength;\n\n  // we use the postmessage trick to defer idle work until after the repaint.\n  // \n  // \n  port.postmessage(null);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n\n# cancelhostcallback\n\ncancelhostcallback = function() {\n  scheduledhostcallback = null;\n};\n\n\n1\n2\n3\n\n\n\n# requesthosttimeout\n\n//  settimeout\nrequesthosttimeout = function(callback, ms) {\n  tasktimeoutid = settimeout(() => {\n    callback(getcurrenttime());\n  }, ms);\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# cancelhosttimeout\n\ncancelhosttimeout = function() {\n  cleartimeout(tasktimeoutid);\n  tasktimeoutid = -1;\n};\n\n\n1\n2\n3\n4\n",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"scheduler  API",frontmatter:{title:"scheduler  API",date:"2022-04-14T22:02:21.000Z",permalink:"/react/scheduler/scheduler/",categories:["react","scheduler"],tags:[null]},regularPath:"/10.react/30.%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%88Scheduler%EF%BC%89/30.scheduler.html",relativePath:"10.react/30.Scheduler/30.scheduler.md",key:"v-21473796",path:"/react/scheduler/scheduler/",headers:[{level:2,title:"scheduler ",slug:"scheduler-",normalizedTitle:"scheduler ",charIndex:27}],readingTime:{text:"1 min read",minutes:.29,time:17400,words:58},headersStr:"scheduler ",content:" Api\n\n\n# scheduler \n\nscheduler \n\nexport type PriorityLevel = 0 | 1 | 2 | 3 | 4 | 5;\n\nexport const NoPriority = 0; // \nexport const ImmediatePriority = 1; // zui\nexport const UserBlockingPriority = 2;\nexport const NormalPriority = 3;\nexport const LowPriority = 4;\nexport const IdlePriority = 5;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",normalizedContent:" api\n\n\n# scheduler \n\nscheduler \n\nexport type prioritylevel = 0 | 1 | 2 | 3 | 4 | 5;\n\nexport const nopriority = 0; // \nexport const immediatepriority = 1; // zui\nexport const userblockingpriority = 2;\nexport const normalpriority = 3;\nexport const lowpriority = 4;\nexport const idlepriority = 5;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/react/updater/index/",categories:["react","updater"],tags:[null]},regularPath:"/10.react/40.%E6%9B%B4%E6%96%B0%E5%99%A8%EF%BC%88Updater%EF%BC%89/0.index.html",relativePath:"10.react/40.Updater/0.index.md",key:"v-492f4a82",path:"/react/updater/index/",readingTime:{text:"1 min read",minutes:.115,time:6900,words:23},headersStr:null,content:" react-reconciliation  scheduleUpdateOnFiberensureRootIsScheduled  FiberRoot  scheduleSyncCallback scheduleCallback schedulePendingInteractions FiberRoot  performConcurrentWorkOnRoot FiberRoot  performSyncWorkOnRoot  React  FiberTree  ReactElementTree ",normalizedContent:" react-reconciliation  scheduleupdateonfiberensurerootisscheduled  fiberroot  schedulesynccallback schedulecallback schedulependinginteractions fiberroot  performconcurrentworkonroot fiberroot  performsyncworkonroot  react  fibertree  reactelementtree ",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"workLoop  performUnitOfWork",frontmatter:{title:"workLoop  performUnitOfWork",date:"2022-04-14T22:02:21.000Z",permalink:"/react/updater/workloop/",categories:["react","updater"],tags:[null]},regularPath:"/10.react/40.%E6%9B%B4%E6%96%B0%E5%99%A8%EF%BC%88Updater%EF%BC%89/10.workloop.html",relativePath:"10.react/40.Updater/10.workloop.md",key:"v-1d8100c2",path:"/react/updater/workloop/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"workLoopSync  workLoopConcurrent",slug:"workloopsync--workloopconcurrent",normalizedTitle:"workloopsync  workloopconcurrent",charIndex:17},{level:2,title:"performUnitOfWork",slug:"performunitofwork",normalizedTitle:"performunitofwork",charIndex:54},{level:2,title:"beginWork",slug:"beginwork",normalizedTitle:"beginwork",charIndex:75},{level:2,title:"mountIndeterminateComponent",slug:"mountindeterminatecomponent",normalizedTitle:"mountindeterminatecomponent",charIndex:88}],readingTime:{text:"10 min read",minutes:9.3,time:558e3,words:1860},headersStr:" workLoopSync  workLoopConcurrent performUnitOfWork beginWork mountIndeterminateComponent",content:"# \n\n\n\n * \n * workLoopSync  workLoopConcurrent\n * performUnitOfWork\n * beginWork\n * mountIndeterminateComponent\n\n\n\n react-reconciler \n\n\n# workLoopSync  workLoopConcurrent\n\n performConcurrentWorkOnRoot  workLoopConcurrent performSyncWorkOnRoot  workLoopSync  workLoopConcurrent  workLoopSync \n\n// The fiber we're working on\nlet workInProgress: Fiber | null = null;\n\n// The work loop is an extremely hot path. Tell Closure not to inline it.\n/** @noinline */\nfunction workLoopSync() {\n  // Already timed out, so perform work without checking if we need to yield.\n  while (workInProgress !== null) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n\n/** @noinline */\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n\n *  workLoop  performUnitOfWork \n * workInProgress  Fiber performUnitOfWork  workInProgress Fiber loop  workInProgress  performUnitOfWork  Fiber\n *  performUnitOfWork  Fiber  shouldYield  falseshouldYield workLoopConcurrent  performConcurrentWorkOnRoot  prepareFreshStack  workInProgress workInProgress  FiberRoot workLoopConcurrent \n * @inline  inlining  workLoopSync To Inline or Not to Inline? Enhanced Inlining DecisionsAn annotation to either prevent or force inlining of a function\n\n> Inlining heavy functions results in little performance improvement. First, very few runtime function calls are eliminated. Second, the path from the caller to a heavy function is not a hot path at all, and thus will not benefit from postinlining optimization. Third, inlining heavy functions might prevent frequent edges from being inlined if the code growth budget is spent.\n\n\n# performUnitOfWork\n\n unitOfWork  workLoop workLoop  performUnitOfWork  FiberunitOfWork  performUnitOfWork  workLoop  performUnitOfWork \n\nfunction performUnitOfWork(unitOfWork: Fiber): Fiber | null {\n  // The current, flushed, state of this fiber is the alternate. Ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  //  Fiber  alternate Fibercurrent  Fiber \n  // current  Fiber(current fiber)unitOfWork  Fiberpending fiber\n  const current = unitOfWork.alternate;\n\n  //  enableUserTimingAPI \n  startWorkTimer(unitOfWork);\n  setCurrentDebugFiberInDEV(unitOfWork);\n\n  let next;\n  //  unitOfWork.mode === ProfileModeenableProfilerTimer ProfileMode\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\n    startProfilerTimer(unitOfWork);\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n    // \n    next = beginWork(current, unitOfWork, renderExpirationTime);\n  }\n\n  resetCurrentDebugFiberInDEV();\n  // \n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    //  workLoop\n    next = completeUnitOfWork(unitOfWork);\n  }\n\n  //  workInProgress  owner component  null\n  ReactCurrentOwner.current = null;\n  return next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n\nnext = beginWork(current, unitOfWork, renderExpirationTime);\nunitOfWork.memoizedProps = unitOfWork.pendingProps;\nif (next === null) {\n  // If this doesn't spawn new work, complete the current work.\n  //  workLoop\n  next = completeUnitOfWork(unitOfWork);\n}\n\n//  workInProgress  owner component  null\nReactCurrentOwner.current = null;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nperformUnitOfWork \n\n 1.  beginWork Fiber  ReactElement child  null\n 2.  memoizedProps  pendingProps beginWork \n 3.  beginWork  completeUnitOfWork \n 4.  ReactCurrentOwner \n\n\n# beginWork\n\nbeginWork \n\nfunction () {\n  // update \n  if(isUpdate) {\n    // pending fiber \n    if(updateExpirationTime < renderExpirationTime) {\n      //  pending fiber  fiber  context stack;\n      switch (workInProgress.tag) {\n        case SomeType: \n          pushContext(workInProgress);\n          // ;\n          return null || child || child.sibling ;\n      }\n    }\n  }\n\n  //  pending fiber  ReactElement\n  switch (workInProgress.tag) {\n    case SomeType: \n      return mountOrUpdateComponent();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n\nfunction beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n): Fiber | null {\n  //  pending fiber \n  const updateExpirationTime = workInProgress.expirationTime;\n\n  // current current !== null  update \n  //  update  current mount  mountXXXComponent\n  if (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n    //  newFiber  oldFiber  props \n    if (\n      oldProps !== newProps ||\n      hasLegacyContextChanged()\n    ) {\n      // If props or context changed, mark the fiber as having performed work.\n      // This may be unset if the props are determined to be equal later (memo).\n      didReceiveUpdate = true;\n    } else if (updateExpirationTime < renderExpirationTime) {\n      // pending fiber  render \n      didReceiveUpdate = false;\n      // This fiber does not have any pending work. Bailout without entering\n      // the begin phase. There's still some bookkeeping we that needs to be done\n      // in this optimized path, mostly pushing stuff onto the stack.\n      //  pending fiber  context stack\n      switch (workInProgress.tag) {\n        case HostRoot:\n          pushHostRootContext(workInProgress);\n          resetHydrationState();\n          break;\n        case HostComponent:\n          pushHostContext(workInProgress);\n          if (\n            workInProgress.mode & ConcurrentMode &&\n            renderExpirationTime !== Never &&\n            shouldDeprioritizeSubtree(workInProgress.type, newProps)\n          ) {\n            if (enableSchedulerTracing) {\n              markSpawnedWork(Never);\n            }\n            // Schedule this fiber to re-render at offscreen priority. Then bailout.\n            workInProgress.expirationTime = workInProgress.childExpirationTime = Never;\n            return null;\n          }\n          break;\n        case ClassComponent: {\n          const Component = workInProgress.type;\n          if (isLegacyContextProvider(Component)) {\n            pushLegacyContextProvider(workInProgress);\n          }\n          break;\n        }\n        case HostPortal:\n          pushHostContainer(\n            workInProgress,\n            workInProgress.stateNode.containerInfo,\n          );\n          break;\n        case ContextProvider: {\n          const newValue = workInProgress.memoizedProps.value;\n          pushProvider(workInProgress, newValue);\n          break;\n        }\n        case Profiler:\n          if (enableProfilerTimer) {\n            workInProgress.effectTag |= Update;\n          }\n          break;\n        case SuspenseComponent: {\n          const state: SuspenseState | null = workInProgress.memoizedState;\n          if (state !== null) {\n            if (enableSuspenseServerRenderer) {\n              if (state.dehydrated !== null) {\n                pushSuspenseContext(\n                  workInProgress,\n                  setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n                );\n                // We know that this component will suspend again because if it has\n                // been unsuspended it has committed as a resolved Suspense component.\n                // If it needs to be retried, it should have work scheduled on it.\n                workInProgress.effectTag |= DidCapture;\n                break;\n              }\n            }\n\n            // If this boundary is currently timed out, we need to decide\n            // whether to retry the primary children, or to skip over it and\n            // go straight to the fallback. Check the priority of the primary\n            // child fragment.\n            const primaryChildFragment: Fiber = (workInProgress.child: any);\n            const primaryChildExpirationTime =\n              primaryChildFragment.childExpirationTime;\n            if (\n              primaryChildExpirationTime !== NoWork &&\n              primaryChildExpirationTime >= renderExpirationTime\n            ) {\n              // The primary children have pending work. Use the normal path\n              // to attempt to render the primary children again.\n              return updateSuspenseComponent(\n                current,\n                workInProgress,\n                renderExpirationTime,\n              );\n            } else {\n              pushSuspenseContext(\n                workInProgress,\n                setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n              );\n              // The primary children do not have pending work with sufficient\n              // priority. Bailout.\n              const child = bailoutOnAlreadyFinishedWork(\n                current,\n                workInProgress,\n                renderExpirationTime,\n              );\n              if (child !== null) {\n                // The fallback children have pending work. Skip over the\n                // primary children and work on the fallback.\n                return child.sibling;\n              } else {\n                return null;\n              }\n            }\n          } else {\n            pushSuspenseContext(\n              workInProgress,\n              setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n            );\n          }\n          break;\n        }\n        case SuspenseListComponent: {\n          const didSuspendBefore =\n            (current.effectTag & DidCapture) !== NoEffect;\n\n          const hasChildWork =\n            workInProgress.childExpirationTime >= renderExpirationTime;\n\n          if (didSuspendBefore) {\n            if (hasChildWork) {\n              // If something was in fallback state last time, and we have all the\n              // same children then we're still in progressive loading state.\n              // Something might get unblocked by state updates or retries in the\n              // tree which will affect the tail. So we need to use the normal\n              // path to compute the correct tail.\n              return updateSuspenseListComponent(\n                current,\n                workInProgress,\n                renderExpirationTime,\n              );\n            }\n            // If none of the children had any work, that means that none of\n            // them got retried so they'll still be blocked in the same way\n            // as before. We can fast bail out.\n            workInProgress.effectTag |= DidCapture;\n          }\n\n          // If nothing suspended before and we're rendering the same children,\n          // then the tail doesn't matter. Anything new that suspends will work\n          // in the \"together\" mode, so we can continue from the state we had.\n          let renderState = workInProgress.memoizedState;\n          if (renderState !== null) {\n            // Reset to the \"together\" mode in case we've started a different\n            // update in the past but didn't complete it.\n            renderState.rendering = null;\n            renderState.tail = null;\n          }\n          pushSuspenseContext(workInProgress, suspenseStackCursor.current);\n\n          if (hasChildWork) {\n            break;\n          } else {\n            // If none of the children had any work, that means that none of\n            // them got retried so they'll still be blocked in the same way\n            // as before. We can fast bail out.\n            return null;\n          }\n        }\n      }\n      //  child null\n      return bailoutOnAlreadyFinishedWork(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    } else {\n      // An update was scheduled on this fiber, but there are no new props\n      // nor legacy context. Set this to false. If an update queue or context\n      // consumer produces a changed value, it will set this to true. Otherwise,\n      // the component will assume the children have not changed and bail out.\n      // \n      didReceiveUpdate = false;\n    }\n  } else {\n    didReceiveUpdate = false;\n  }\n  // mount  begin \n  // Before entering the begin phase, clear the expiration time.\n  workInProgress.expirationTime = NoWork;\n\n  //  pending fiber  ReactElement\n  switch (workInProgress.tag) {\n    case IndeterminateComponent: {\n      return mountIndeterminateComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        renderExpirationTime,\n      );\n    }\n    case LazyComponent: {\n      const elementType = workInProgress.elementType;\n      return mountLazyComponent(\n        current,\n        workInProgress,\n        elementType,\n        updateExpirationTime,\n        renderExpirationTime,\n      );\n    }\n    case FunctionComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateFunctionComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderExpirationTime);\n    case HostComponent:\n      return updateHostComponent(current, workInProgress, renderExpirationTime);\n    case HostText:\n      return updateHostText(current, workInProgress);\n    case SuspenseComponent:\n      return updateSuspenseComponent(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    case HostPortal:\n      return updatePortalComponent(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    case ForwardRef: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === type\n          ? unresolvedProps\n          : resolveDefaultProps(type, unresolvedProps);\n      return updateForwardRef(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    case Fragment:\n      return updateFragment(current, workInProgress, renderExpirationTime);\n    case Mode:\n      return updateMode(current, workInProgress, renderExpirationTime);\n    case Profiler:\n      return updateProfiler(current, workInProgress, renderExpirationTime);\n    case ContextProvider:\n      return updateContextProvider(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    case ContextConsumer:\n      return updateContextConsumer(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    case MemoComponent: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      // Resolve outer props first, then resolve inner props.\n      let resolvedProps = resolveDefaultProps(type, unresolvedProps);\n      if (__DEV__) {\n        if (workInProgress.type !== workInProgress.elementType) {\n          const outerPropTypes = type.propTypes;\n          if (outerPropTypes) {\n            checkPropTypes(\n              outerPropTypes,\n              resolvedProps, // Resolved for outer only\n              'prop',\n              getComponentName(type),\n              getCurrentFiberStackInDev,\n            );\n          }\n        }\n      }\n      resolvedProps = resolveDefaultProps(type.type, resolvedProps);\n      return updateMemoComponent(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        updateExpirationTime,\n        renderExpirationTime,\n      );\n    }\n    case SimpleMemoComponent: {\n      return updateSimpleMemoComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        updateExpirationTime,\n        renderExpirationTime,\n      );\n    }\n    case IncompleteClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return mountIncompleteClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    case SuspenseListComponent: {\n      return updateSuspenseListComponent(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    }\n    case FundamentalComponent: {\n      if (enableFundamentalAPI) {\n        return updateFundamentalComponent(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      }\n      break;\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        return updateScopeComponent(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      }\n      break;\n    }\n  }\n  invariant(\n    false,\n    'Unknown unit of work tag (%s). This error is likely caused by a bug in ' +\n      'React. Please file an issue.',\n    workInProgress.tag,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n\n\n\n\n 1. beginWork  mount  update  update  workInProgress  render  renderExpirationTime  null  child   mountComponent  updateComponent  mount  update \n 2.  switch case  switch case  completeWork  switch case \n\n\n# mountIndeterminateComponent\n\n IndeterminateComponent \n\n shared/ReactWorkTags.js  IndeterminateComponent IndeterminateComponent  FC (Function Component)  CC (Class Function)  mount  update  FunctionComponent  ClassComponent\n\n mountLazyComponent  resolveLazyComponentTag  lazy component  ClassComponentFunctionComponentForwardRef  MemoComponent IndeterminateComponent \n\nexport const IndeterminateComponent = 2; // Before we know whether it is function or class\n\n\n1\n",normalizedContent:"# \n\n\n\n * \n * workloopsync  workloopconcurrent\n * performunitofwork\n * beginwork\n * mountindeterminatecomponent\n\n\n\n react-reconciler \n\n\n# workloopsync  workloopconcurrent\n\n performconcurrentworkonroot  workloopconcurrent performsyncworkonroot  workloopsync  workloopconcurrent  workloopsync \n\n// the fiber we're working on\nlet workinprogress: fiber | null = null;\n\n// the work loop is an extremely hot path. tell closure not to inline it.\n/** @noinline */\nfunction workloopsync() {\n  // already timed out, so perform work without checking if we need to yield.\n  while (workinprogress !== null) {\n    workinprogress = performunitofwork(workinprogress);\n  }\n}\n\n/** @noinline */\nfunction workloopconcurrent() {\n  // perform work until scheduler asks us to yield\n  while (workinprogress !== null && !shouldyield()) {\n    workinprogress = performunitofwork(workinprogress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n\n *  workloop  performunitofwork \n * workinprogress  fiber performunitofwork  workinprogress fiber loop  workinprogress  performunitofwork  fiber\n *  performunitofwork  fiber  shouldyield  falseshouldyield workloopconcurrent  performconcurrentworkonroot  preparefreshstack  workinprogress workinprogress  fiberroot workloopconcurrent \n * @inline  inlining  workloopsync to inline or not to inline? enhanced inlining decisionsan annotation to either prevent or force inlining of a function\n\n> inlining heavy functions results in little performance improvement. first, very few runtime function calls are eliminated. second, the path from the caller to a heavy function is not a hot path at all, and thus will not benefit from postinlining optimization. third, inlining heavy functions might prevent frequent edges from being inlined if the code growth budget is spent.\n\n\n# performunitofwork\n\n unitofwork  workloop workloop  performunitofwork  fiberunitofwork  performunitofwork  workloop  performunitofwork \n\nfunction performunitofwork(unitofwork: fiber): fiber | null {\n  // the current, flushed, state of this fiber is the alternate. ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  //  fiber  alternate fibercurrent  fiber \n  // current  fiber(current fiber)unitofwork  fiberpending fiber\n  const current = unitofwork.alternate;\n\n  //  enableusertimingapi \n  startworktimer(unitofwork);\n  setcurrentdebugfiberindev(unitofwork);\n\n  let next;\n  //  unitofwork.mode === profilemodeenableprofilertimer profilemode\n  if (enableprofilertimer && (unitofwork.mode & profilemode) !== nomode) {\n    startprofilertimer(unitofwork);\n    next = beginwork(current, unitofwork, renderexpirationtime);\n    stopprofilertimerifrunningandrecorddelta(unitofwork, true);\n  } else {\n    // \n    next = beginwork(current, unitofwork, renderexpirationtime);\n  }\n\n  resetcurrentdebugfiberindev();\n  // \n  unitofwork.memoizedprops = unitofwork.pendingprops;\n  if (next === null) {\n    // if this doesn't spawn new work, complete the current work.\n    //  workloop\n    next = completeunitofwork(unitofwork);\n  }\n\n  //  workinprogress  owner component  null\n  reactcurrentowner.current = null;\n  return next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n\nnext = beginwork(current, unitofwork, renderexpirationtime);\nunitofwork.memoizedprops = unitofwork.pendingprops;\nif (next === null) {\n  // if this doesn't spawn new work, complete the current work.\n  //  workloop\n  next = completeunitofwork(unitofwork);\n}\n\n//  workinprogress  owner component  null\nreactcurrentowner.current = null;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nperformunitofwork \n\n 1.  beginwork fiber  reactelement child  null\n 2.  memoizedprops  pendingprops beginwork \n 3.  beginwork  completeunitofwork \n 4.  reactcurrentowner \n\n\n# beginwork\n\nbeginwork \n\nfunction () {\n  // update \n  if(isupdate) {\n    // pending fiber \n    if(updateexpirationtime < renderexpirationtime) {\n      //  pending fiber  fiber  context stack;\n      switch (workinprogress.tag) {\n        case sometype: \n          pushcontext(workinprogress);\n          // ;\n          return null || child || child.sibling ;\n      }\n    }\n  }\n\n  //  pending fiber  reactelement\n  switch (workinprogress.tag) {\n    case sometype: \n      return mountorupdatecomponent();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n\nfunction beginwork(\n  current: fiber | null,\n  workinprogress: fiber,\n  renderexpirationtime: expirationtime,\n): fiber | null {\n  //  pending fiber \n  const updateexpirationtime = workinprogress.expirationtime;\n\n  // current current !== null  update \n  //  update  current mount  mountxxxcomponent\n  if (current !== null) {\n    const oldprops = current.memoizedprops;\n    const newprops = workinprogress.pendingprops;\n    //  newfiber  oldfiber  props \n    if (\n      oldprops !== newprops ||\n      haslegacycontextchanged()\n    ) {\n      // if props or context changed, mark the fiber as having performed work.\n      // this may be unset if the props are determined to be equal later (memo).\n      didreceiveupdate = true;\n    } else if (updateexpirationtime < renderexpirationtime) {\n      // pending fiber  render \n      didreceiveupdate = false;\n      // this fiber does not have any pending work. bailout without entering\n      // the begin phase. there's still some bookkeeping we that needs to be done\n      // in this optimized path, mostly pushing stuff onto the stack.\n      //  pending fiber  context stack\n      switch (workinprogress.tag) {\n        case hostroot:\n          pushhostrootcontext(workinprogress);\n          resethydrationstate();\n          break;\n        case hostcomponent:\n          pushhostcontext(workinprogress);\n          if (\n            workinprogress.mode & concurrentmode &&\n            renderexpirationtime !== never &&\n            shoulddeprioritizesubtree(workinprogress.type, newprops)\n          ) {\n            if (enableschedulertracing) {\n              markspawnedwork(never);\n            }\n            // schedule this fiber to re-render at offscreen priority. then bailout.\n            workinprogress.expirationtime = workinprogress.childexpirationtime = never;\n            return null;\n          }\n          break;\n        case classcomponent: {\n          const component = workinprogress.type;\n          if (islegacycontextprovider(component)) {\n            pushlegacycontextprovider(workinprogress);\n          }\n          break;\n        }\n        case hostportal:\n          pushhostcontainer(\n            workinprogress,\n            workinprogress.statenode.containerinfo,\n          );\n          break;\n        case contextprovider: {\n          const newvalue = workinprogress.memoizedprops.value;\n          pushprovider(workinprogress, newvalue);\n          break;\n        }\n        case profiler:\n          if (enableprofilertimer) {\n            workinprogress.effecttag |= update;\n          }\n          break;\n        case suspensecomponent: {\n          const state: suspensestate | null = workinprogress.memoizedstate;\n          if (state !== null) {\n            if (enablesuspenseserverrenderer) {\n              if (state.dehydrated !== null) {\n                pushsuspensecontext(\n                  workinprogress,\n                  setdefaultshallowsuspensecontext(suspensestackcursor.current),\n                );\n                // we know that this component will suspend again because if it has\n                // been unsuspended it has committed as a resolved suspense component.\n                // if it needs to be retried, it should have work scheduled on it.\n                workinprogress.effecttag |= didcapture;\n                break;\n              }\n            }\n\n            // if this boundary is currently timed out, we need to decide\n            // whether to retry the primary children, or to skip over it and\n            // go straight to the fallback. check the priority of the primary\n            // child fragment.\n            const primarychildfragment: fiber = (workinprogress.child: any);\n            const primarychildexpirationtime =\n              primarychildfragment.childexpirationtime;\n            if (\n              primarychildexpirationtime !== nowork &&\n              primarychildexpirationtime >= renderexpirationtime\n            ) {\n              // the primary children have pending work. use the normal path\n              // to attempt to render the primary children again.\n              return updatesuspensecomponent(\n                current,\n                workinprogress,\n                renderexpirationtime,\n              );\n            } else {\n              pushsuspensecontext(\n                workinprogress,\n                setdefaultshallowsuspensecontext(suspensestackcursor.current),\n              );\n              // the primary children do not have pending work with sufficient\n              // priority. bailout.\n              const child = bailoutonalreadyfinishedwork(\n                current,\n                workinprogress,\n                renderexpirationtime,\n              );\n              if (child !== null) {\n                // the fallback children have pending work. skip over the\n                // primary children and work on the fallback.\n                return child.sibling;\n              } else {\n                return null;\n              }\n            }\n          } else {\n            pushsuspensecontext(\n              workinprogress,\n              setdefaultshallowsuspensecontext(suspensestackcursor.current),\n            );\n          }\n          break;\n        }\n        case suspenselistcomponent: {\n          const didsuspendbefore =\n            (current.effecttag & didcapture) !== noeffect;\n\n          const haschildwork =\n            workinprogress.childexpirationtime >= renderexpirationtime;\n\n          if (didsuspendbefore) {\n            if (haschildwork) {\n              // if something was in fallback state last time, and we have all the\n              // same children then we're still in progressive loading state.\n              // something might get unblocked by state updates or retries in the\n              // tree which will affect the tail. so we need to use the normal\n              // path to compute the correct tail.\n              return updatesuspenselistcomponent(\n                current,\n                workinprogress,\n                renderexpirationtime,\n              );\n            }\n            // if none of the children had any work, that means that none of\n            // them got retried so they'll still be blocked in the same way\n            // as before. we can fast bail out.\n            workinprogress.effecttag |= didcapture;\n          }\n\n          // if nothing suspended before and we're rendering the same children,\n          // then the tail doesn't matter. anything new that suspends will work\n          // in the \"together\" mode, so we can continue from the state we had.\n          let renderstate = workinprogress.memoizedstate;\n          if (renderstate !== null) {\n            // reset to the \"together\" mode in case we've started a different\n            // update in the past but didn't complete it.\n            renderstate.rendering = null;\n            renderstate.tail = null;\n          }\n          pushsuspensecontext(workinprogress, suspensestackcursor.current);\n\n          if (haschildwork) {\n            break;\n          } else {\n            // if none of the children had any work, that means that none of\n            // them got retried so they'll still be blocked in the same way\n            // as before. we can fast bail out.\n            return null;\n          }\n        }\n      }\n      //  child null\n      return bailoutonalreadyfinishedwork(\n        current,\n        workinprogress,\n        renderexpirationtime,\n      );\n    } else {\n      // an update was scheduled on this fiber, but there are no new props\n      // nor legacy context. set this to false. if an update queue or context\n      // consumer produces a changed value, it will set this to true. otherwise,\n      // the component will assume the children have not changed and bail out.\n      // \n      didreceiveupdate = false;\n    }\n  } else {\n    didreceiveupdate = false;\n  }\n  // mount  begin \n  // before entering the begin phase, clear the expiration time.\n  workinprogress.expirationtime = nowork;\n\n  //  pending fiber  reactelement\n  switch (workinprogress.tag) {\n    case indeterminatecomponent: {\n      return mountindeterminatecomponent(\n        current,\n        workinprogress,\n        workinprogress.type,\n        renderexpirationtime,\n      );\n    }\n    case lazycomponent: {\n      const elementtype = workinprogress.elementtype;\n      return mountlazycomponent(\n        current,\n        workinprogress,\n        elementtype,\n        updateexpirationtime,\n        renderexpirationtime,\n      );\n    }\n    case functioncomponent: {\n      const component = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      const resolvedprops =\n        workinprogress.elementtype === component\n          ? unresolvedprops\n          : resolvedefaultprops(component, unresolvedprops);\n      return updatefunctioncomponent(\n        current,\n        workinprogress,\n        component,\n        resolvedprops,\n        renderexpirationtime,\n      );\n    }\n    case classcomponent: {\n      const component = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      const resolvedprops =\n        workinprogress.elementtype === component\n          ? unresolvedprops\n          : resolvedefaultprops(component, unresolvedprops);\n      return updateclasscomponent(\n        current,\n        workinprogress,\n        component,\n        resolvedprops,\n        renderexpirationtime,\n      );\n    }\n    case hostroot:\n      return updatehostroot(current, workinprogress, renderexpirationtime);\n    case hostcomponent:\n      return updatehostcomponent(current, workinprogress, renderexpirationtime);\n    case hosttext:\n      return updatehosttext(current, workinprogress);\n    case suspensecomponent:\n      return updatesuspensecomponent(\n        current,\n        workinprogress,\n        renderexpirationtime,\n      );\n    case hostportal:\n      return updateportalcomponent(\n        current,\n        workinprogress,\n        renderexpirationtime,\n      );\n    case forwardref: {\n      const type = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      const resolvedprops =\n        workinprogress.elementtype === type\n          ? unresolvedprops\n          : resolvedefaultprops(type, unresolvedprops);\n      return updateforwardref(\n        current,\n        workinprogress,\n        type,\n        resolvedprops,\n        renderexpirationtime,\n      );\n    }\n    case fragment:\n      return updatefragment(current, workinprogress, renderexpirationtime);\n    case mode:\n      return updatemode(current, workinprogress, renderexpirationtime);\n    case profiler:\n      return updateprofiler(current, workinprogress, renderexpirationtime);\n    case contextprovider:\n      return updatecontextprovider(\n        current,\n        workinprogress,\n        renderexpirationtime,\n      );\n    case contextconsumer:\n      return updatecontextconsumer(\n        current,\n        workinprogress,\n        renderexpirationtime,\n      );\n    case memocomponent: {\n      const type = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      // resolve outer props first, then resolve inner props.\n      let resolvedprops = resolvedefaultprops(type, unresolvedprops);\n      if (__dev__) {\n        if (workinprogress.type !== workinprogress.elementtype) {\n          const outerproptypes = type.proptypes;\n          if (outerproptypes) {\n            checkproptypes(\n              outerproptypes,\n              resolvedprops, // resolved for outer only\n              'prop',\n              getcomponentname(type),\n              getcurrentfiberstackindev,\n            );\n          }\n        }\n      }\n      resolvedprops = resolvedefaultprops(type.type, resolvedprops);\n      return updatememocomponent(\n        current,\n        workinprogress,\n        type,\n        resolvedprops,\n        updateexpirationtime,\n        renderexpirationtime,\n      );\n    }\n    case simplememocomponent: {\n      return updatesimplememocomponent(\n        current,\n        workinprogress,\n        workinprogress.type,\n        workinprogress.pendingprops,\n        updateexpirationtime,\n        renderexpirationtime,\n      );\n    }\n    case incompleteclasscomponent: {\n      const component = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      const resolvedprops =\n        workinprogress.elementtype === component\n          ? unresolvedprops\n          : resolvedefaultprops(component, unresolvedprops);\n      return mountincompleteclasscomponent(\n        current,\n        workinprogress,\n        component,\n        resolvedprops,\n        renderexpirationtime,\n      );\n    }\n    case suspenselistcomponent: {\n      return updatesuspenselistcomponent(\n        current,\n        workinprogress,\n        renderexpirationtime,\n      );\n    }\n    case fundamentalcomponent: {\n      if (enablefundamentalapi) {\n        return updatefundamentalcomponent(\n          current,\n          workinprogress,\n          renderexpirationtime,\n        );\n      }\n      break;\n    }\n    case scopecomponent: {\n      if (enablescopeapi) {\n        return updatescopecomponent(\n          current,\n          workinprogress,\n          renderexpirationtime,\n        );\n      }\n      break;\n    }\n  }\n  invariant(\n    false,\n    'unknown unit of work tag (%s). this error is likely caused by a bug in ' +\n      'react. please file an issue.',\n    workinprogress.tag,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n\n\n\n\n 1. beginwork  mount  update  update  workinprogress  render  renderexpirationtime  null  child   mountcomponent  updatecomponent  mount  update \n 2.  switch case  switch case  completework  switch case \n\n\n# mountindeterminatecomponent\n\n indeterminatecomponent \n\n shared/reactworktags.js  indeterminatecomponent indeterminatecomponent  fc (function component)  cc (class function)  mount  update  functioncomponent  classcomponent\n\n mountlazycomponent  resolvelazycomponenttag  lazy component  classcomponentfunctioncomponentforwardref  memocomponent indeterminatecomponent \n\nexport const indeterminatecomponent = 2; // before we know whether it is function or class\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/react/render/index/",categories:["react","render"],tags:[null]},regularPath:"/10.react/50.%E6%B8%B2%E6%9F%93%E5%99%A8%EF%BC%88Render%EF%BC%89/0.index.html",relativePath:"10.react/50.Render/0.index.md",key:"v-fcc2e96a",path:"/react/render/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"ReactDOM.render ",frontmatter:{title:"ReactDOM.render ",date:"2022-04-14T22:02:21.000Z",permalink:"/react/render/render/",categories:["react","render"],tags:[null]},regularPath:"/10.react/50.%E6%B8%B2%E6%9F%93%E5%99%A8%EF%BC%88Render%EF%BC%89/10.ReactDOM.html",relativePath:"10.react/50.Render/10.ReactDOM.md",key:"v-36e6278b",path:"/react/render/render/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"ReactDOM ",slug:"reactdom-",normalizedTitle:"reactdom ",charIndex:17},{level:2,title:"render ",slug:"render-",normalizedTitle:"render ",charIndex:34},{level:3,title:" ReactRoot",slug:"-reactroot",normalizedTitle:" reactroot",charIndex:49},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:67},{level:4,title:"FiberRoot",slug:"fiberroot",normalizedTitle:"fiberroot",charIndex:1695},{level:3,title:"updateContainer() ",slug:"updatecontainer-",normalizedTitle:"updatecontainer () ",charIndex:8771},{level:4,title:"createUpdate() ",slug:"createupdate-",normalizedTitle:"createupdate () ",charIndex:14084},{level:4,title:"enqueueUpdate() ",slug:"enqueueupdate-",normalizedTitle:"enqueueupdate () ",charIndex:15821}],readingTime:{text:"12 min read",minutes:11.985,time:719099.9999999999,words:2397},headersStr:" ReactDOM  render   ReactRoot  FiberRoot updateContainer()  createUpdate()  enqueueUpdate() ",content:"# \n\n\n\n * \n * ReactDOM \n * render \n   *  ReactRoot\n   * \n   * updateContainer() \n\n\n\n\n# ReactDOM \n\n react-dom  ReactDOM.js  ReactDOM\n\nconst ReactDOM: Object = {\n\tcreatePortal, //  portal\n\tfindDOMNode, //  DOM\n\thydrate,\n\trender,\n\tunstable_renderSubtreeIntoContainer,\n\tunmountComponentAtNode,\n\tunstable_batchedUpdates,\n\tunstable_interactiveUpdates,\n\tunstable_discreteUpdates,\n\tunstable_flushDiscreteUpdates,\n\tflushSync,\n\tunstable_createRoot,\n\tunstable_createSyncRoot,\n\tunstable_flushControlled,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# render \n\nrender \n\nrender(\n    element: React$Element < any >, // render \n    container: DOMContainer, // render \n    callback: ?Function, // callback\n) {\n    return legacyRenderSubtreeIntoContainer(\n        null,\n        element,\n        container,\n        false,\n        callback,\n    );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n root  parentComponent  null  legacyRenderSubtreeIntoContainer \n\nfunction legacyRenderSubtreeIntoContainer(\n    parentComponent: ? React$Component < any, any > ,\n    children : ReactNodeList, // \n    container: DOMContainer, // \n    forceHydrate: boolean,\n    callback: ? Function,\n) {\n    let root: _ReactSyncRoot = (container._reactRootContainer: any);\n    let fiberRoot;\n    if (!root) {\n        // Initial mount\n        //  ReactSyncRoot \n        root = container._reactRootContainer = legacyCreateRootFromDOMContainer(\n            container,\n            forceHydrate,\n        );\n        console.log('==>legacyRenderSubtreeIntoContainer_ ReactSyncRoot ', {\n            root\n        });\n        // {\n        //   _internalRoot: FiberRootNode //  fiber \n        //   callbackExpirationTime: 0\n        //   callbackNode: null\n        //   callbackPriority: 90\n        //   containerInfo: div#root // ROOT  DOM \n        //   context: {}\n        //   current: FiberNode {tag: 3, key: null, elementType: null, type: null, stateNode: FiberRootNode, }\n        //   finishedExpirationTime: 0\n        //   finishedWork: null\n        //   firstBatch: null\n        //   firstPendingTime: 0\n        //   firstSuspendedTime: 0\n        //   hydrate: false\n        //   interactionThreadID: 1\n        //   lastExpiredTime: 0\n        //   lastPingedTime: 0\n        //   lastSuspendedTime: 0\n        //   memoizedInteractions: Set(0) {}\n        //   nextKnownPendingLevel: 0\n        //   pendingChildren: null\n        //   pendingContext: null\n        //   pendingInteractionMap: Map(0) {}\n        //   pingCache: null\n        //   tag: 0\n        //   timeoutHandle: -1\n        // }\n        fiberRoot = root._internalRoot;\n        if (typeof callback === 'function') {\n            const originalCallback = callback;\n            callback = function () {\n                //  public  root  callback\n                const instance = getPublicRootInstance(fiberRoot);\n                console.log('==>getPublicRootInstance_ callback  root ', {\n                    instance\n                });\n                // instance: null \n                originalCallback.call(instance);\n            };\n        }\n        // Initial mount should not be batched.\n        // render  batchedUpdates\n        unbatchedUpdates(() => {\n            // \n            updateContainer(children, fiberRoot, parentComponent, callback);\n        });\n    } else {\n        //  root \n        fiberRoot = root._internalRoot;\n        if (typeof callback === 'function') {\n            const originalCallback = callback;\n            callback = function () {\n                const instance = getPublicRootInstance(fiberRoot);\n                originalCallback.call(instance);\n            };\n        }\n        // Update\n        updateContainer(children, fiberRoot, parentComponent, callback);\n    }\n    //  public  root \n    // render \n    return getPublicRootInstance(fiberRoot);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n\n 1.  render ()  legacyRenderSubtreeIntoContainer  _ReactSyncRoot  root fiberRoot = root._internalRoot \n 2. render ()  callback   public  root  callback\n 3. render  patch  unbatchedUpdates() \n 4.  patch  updateContainer \n\n\n#  ReactRoot\n\n root = container._reactRootContainer = legacyCreateRootFromDOMContainer(\n     container,\n     forceHydrate,\n );\n\n\n1\n2\n3\n4\n\n\n legacyCreateRootFromDOMContainer  ReactRoot ReatRoot  ReactSyncRoot  container._reactRootContainer \n\nlegacyCreateRootFromDOMContainer \n\nfunction legacyCreateRootFromDOMContainer(\n    container: DOMContainer,\n    forceHydrate: boolean,\n): _ReactSyncRoot {\n    //  Hydrate\n    const shouldHydrate =\n        forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n    // First clear any existing content.\n    if (!shouldHydrate) {\n        let rootSibling;\n        // lastChild  NULL\n\t\t// \n        while ((rootSibling = container.lastChild)) {\n            container.removeChild(rootSibling);\n        }\n    }\n\n    // Legacy roots are not batched.\n    return new ReactSyncRoot(\n        container,\n        LegacyRoot, // root \n        shouldHydrate ?\n        {\n            hydrate: true,\n        } :\n        undefined,\n    );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n 1.  root \n 2.  hydrate\n 3. LegacyRoot \n\n\n# \n\n# FiberRoot\n\nfiberRoot  FiberRootfiberRoot  react  updateContainer () \n\n react-reconciler/ReactFiberRoot.js \n\nexport type FiberRoot = {\n    ...BaseFiberRootProperties,\n    ...ProfilingOnlyFiberRootProperties,\n    ...SuspenseCallbackOnlyFiberRootProperties,\n};\n\n\n1\n2\n3\n4\n5\n\n\n BaseFiberRootProperties \n\ntype BaseFiberRootProperties = {\n    |\n    // The type of root (legacy, batched, concurrent, etc.)\n    // tag \n    // export type RootTag = 0 | 1 | 2;\n    // export const LegacyRoot = 0;\n    // export const BatchedRoot = 1;\n    // export const ConcurrentRoot = 2;\n    tag: RootTag,\n\n    // Any additional information from the host associated with this root.\n    // \n    containerInfo: any,\n    // Used only by persistent updates.\n    pendingChildren: any,\n    // The currently active root fiber. This is the mutable root of the tree.\n    //  Fiber \n    current: Fiber,\n\n    pingCache:\n        |\n        WeakMap < Thenable,\n    Set < ExpirationTime >>\n    |\n    Map < Thenable,\n    Set < ExpirationTime >>\n    |\n    null,\n\n    finishedExpirationTime: ExpirationTime,\n    // A finished work-in-progress HostRoot that's ready to be committed.\n    //  commit  Fiber\n    finishedWork: Fiber | null,\n    // Timeout handle returned by setTimeout. Used to cancel a pending timeout, if\n    // it's superseded by a new one.\n    timeoutHandle: TimeoutHandle | NoTimeout,\n    // Top context object, used by renderSubtreeIntoContainer\n    context: Object | null,\n    pendingContext: Object | null,\n    // Determines if we should attempt to hydrate on the initial mount\n    // hydrate\n    +hydrate: boolean,\n    // List of top-level batches. This list indicates whether a commit should be\n    // deferred. Also contains completion callbacks.\n    // TODO: Lift this into the renderer\n    firstBatch: Batch | null,\n    // Node returned by Scheduler.scheduleCallback\n    callbackNode: * ,\n    // Expiration of the callback associated with this root\n    // callback \n    callbackExpirationTime: ExpirationTime,\n    // Priority of the callback associated with this root\n    callbackPriority: ReactPriorityLevel,\n    // The earliest pending expiration time that exists in the tree\n    firstPendingTime: ExpirationTime,\n    // The earliest suspended expiration time that exists in the tree\n    firstSuspendedTime: ExpirationTime,\n    // The latest suspended expiration time that exists in the tree\n    lastSuspendedTime: ExpirationTime,\n    // The next known expiration time after the suspended range\n    nextKnownPendingLevel: ExpirationTime,\n    // The latest time at which a suspended component pinged the root to\n    // render again\n    lastPingedTime: ExpirationTime,\n    lastExpiredTime: ExpirationTime,\n    |\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\nFiberRoot \n\n\n# updateContainer () \n\n batchedUpdates()  unbatchedUpdates()  updateContainer() \n\nupdateContainer() \n\nfunction updateContainer(\n    element: ReactNodeList,\n    container: OpaqueRoot,\n    parentComponent: ? React$Component < any, any > ,\n    callback : ? Function,\n): ExpirationTime {\n    //  Fiber \n    const current = container.current;\n    const currentTime = requestCurrentTime();\n    const suspenseConfig = requestCurrentSuspenseConfig();\n    const expirationTime = computeExpirationForFiber(\n        currentTime,\n        current,\n        suspenseConfig,\n    );\n    return updateContainerAtExpirationTime(\n        element,\n        container,\n        parentComponent,\n        expirationTime,\n        suspenseConfig,\n        callback,\n    );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n elementcontainerparentComponent  callback ExpirationTime  expirationTime  suspenseConfig\n\n * requestCurrentSuspenseConfig()  ReactCurrentBatchConfig.suspense  batch \n\n/**\n * Keeps track of the current batch's configuration such as how long an update\n * should suspend for if it needs to.\n */\n//  batch \nconst ReactCurrentBatchConfig = {\n    suspense: (null: null | SuspenseConfig),\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * [[ExpirationTime,context ]]\n\ncomputeExpirationForFiber(\n  currentTime: ExpirationTime,\n  fiber: Fiber,\n  suspenseConfig: null | SuspenseConfig,\n): ExpirationTime {\n  const mode = fiber.mode;\n  if ((mode & BatchedMode) === NoMode) {\n    console.log('==>', {mode, BatchedMode});\n    // {mode: 8, BatchedMode: 2}\n    // 8&2=0\n    return Sync; // 1073741823 MAX_SIGNED_31_BIT_INT\n  }\n\n  const priorityLevel = getCurrentPriorityLevel();\n  if ((mode & ConcurrentMode) === NoMode) {\n    console.log('==>', {mode, ConcurrentMode});\n    return priorityLevel === ImmediatePriority ? Sync : Batched;\n  }\n\n  if ((executionContext & RenderContext) !== NoContext) {\n    console.log('==>', {executionContext, RenderContext});\n    // Use whatever time we're already rendering\n    // TODO: Should there be a way to opt out, like with `runWithPriority`?\n    return renderExpirationTime; // NoWork 0\n  }\n\n  let expirationTime;\n  if (suspenseConfig !== null) {\n    // Compute an expiration time based on the Suspense timeout.\n    expirationTime = computeSuspenseExpiration(\n      currentTime,\n      suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION,\n    );\n  } else {\n    // Compute an expiration time based on the Scheduler priority.\n    switch (priorityLevel) {\n      case ImmediatePriority:\n        expirationTime = Sync;\n        break;\n      case UserBlockingPriority:\n        // TODO: Rename this to computeUserBlockingExpiration\n        expirationTime = computeInteractiveExpiration(currentTime);\n        break;\n      case NormalPriority:\n      case LowPriority: // TODO: Handle LowPriority\n        // TODO: Rename this to... something better.\n        expirationTime = computeAsyncExpiration(currentTime);\n        break;\n      case IdlePriority:\n        expirationTime = Idle;\n        break;\n      default:\n        invariant(false, 'Expected a valid priority level');\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n updateContainerAtExpirationTime()  context\n\nfunction updateContainerAtExpirationTime(\n    element: ReactNodeList,\n    container: OpaqueRoot,\n    parentComponent: ? React$Component < any, any > ,\n    expirationTime : ExpirationTime,\n    suspenseConfig: null | SuspenseConfig,\n    callback: ? Function,\n) {\n    const current = container.current;\n  \t// context container.context  container.pendingContext\n    const context = getContextForSubtree(parentComponent);\n    if (container.context === null) {\n        container.context = context;\n    } else {\n        container.pendingContext = context;\n    }\n\n    return scheduleRootUpdate(\n        current,\n        element,\n        expirationTime,\n        suspenseConfig,\n        callback,\n    );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * [[ExpirationTime,context ]]\n\n scheduleRootUpdate()  render \n\nfunction scheduleRootUpdate(\n    current: Fiber,\n    element: ReactNodeList,\n    expirationTime: ExpirationTime,\n    suspenseConfig: null | SuspenseConfig,\n    callback: ? Function,\n) {\n    // render expirationTimesuspenseConfig  update\n    const update = createUpdate(expirationTime, suspenseConfig);\n\n    callback = callback === undefined ? null : callback;\n    if (callback !== null) {\n        warningWithoutStack(\n            typeof callback === 'function',\n            'render(...): Expected the last optional `callback` argument to be a ' +\n            'function. Instead received: %s.',\n            callback,\n        );\n        //  callback  update\n        update.callback = callback;\n    }\n    // \n    enqueueUpdate(current, update);\n    // expirationTime\n    scheduleWork(current, expirationTime);\n\n    return expirationTime;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n createUpdate()  enqueueUpdate()  scheduleWork() \n\n# createUpdate () \n\n Update  tag  UpdateState \n\n// createUpdateupdatepartialStatecallbackexpirationTime\nfunction createUpdate(\n    expirationTime: ExpirationTime,\n    suspenseConfig: null | SuspenseConfig,\n): Update < * > {\n    let update: Update < * > = { // update\n        expirationTime, // \n        suspenseConfig, // \n\n        tag: UpdateState, // 0UpdateState0\n        payload: null, // `setState`\n        callback: null, // \n\n        next: null, // \n        nextEffect: null, // \n    };\n    if (__DEV__) {\n        update.priority = getCurrentPriorityLevel();\n    }\n    return update;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nUpdate \n\ntype Update < State > = {\n    expirationTime: ExpirationTime,\n    suspenseConfig: null | SuspenseConfig,\n\n    tag: 0 | 1 | 2 | 3,\n    payload: any,\n    callback: (() => mixed) | null,\n\n    next: Update < State > | null,\n    nextEffect: Update < State > | null,\n\n    //DEV only\n    priority ? : ReactPriorityLevel,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * next  nextEffect \n * Update  tag \n\nexport const UpdateState = 0;\nexport const ReplaceState = 1;\nexport const ForceUpdate = 2;\nexport const CaptureUpdate = 3;\n\n\n1\n2\n3\n4\n\n\nUpdate \n\nKEY        TYPE              DESC\ntag        Number             0~3\n                             UpdateStateReplaceStateForceUpdateCaptureUpdate\npayload    Function|Object   \ncallback   Function           UpdateQueue  Update \nnext       Update            UpdateQueue  Update  next  Update \n\n# enqueueUpdate () \n\n update  update  enqueueUpdate()  fiber  update  fider  update \n\nfiber:\n\n{\n\tactualDuration: 0\n\tactualStartTime: -1\n\talternate: FiberNode { // alternateFiberNode\n\t\ttag: 3,\n\t\tkey: null,\n\t\telementType: null,\n\t\ttype: null,\n\t\tstateNode: FiberRootNode,\n\t\t\n\t}\n\tchild: null\n\tchildExpirationTime: 0\n\tdependencies: null\n\teffectTag: 0\n\telementType: null\n\texpirationTime: 1073741823\n\tfirstEffect: null\n\tindex: 0\n\tkey: null\n\tlastEffect: null\n\tmemoizedProps: null\n\tmemoizedState: null\n\tmode: 8\n\tnextEffect: null\n\tpendingProps: null\n\tref: null\n\treturn :null\n\tselfBaseDuration: 0\n\tsibling: null\n\tstateNode: FiberRootNode {\n\t\ttag: 0,\n\t\tcurrent: FiberNode,\n\t\tcontainerInfo: div# root,\n\t\tpendingChildren: null,\n\t\tpingCache: null,\n\t\t\n\t}\n\ttag: 3\n\ttreeBaseDuration: 0\n\ttype: null\n\tupdateQueue: {\n\t\tbaseState: null,\n\t\tfirstUpdate: {\n\t\t\t},\n\t\tlastUpdate: {\n\t\t\t},\n\t\tfirstCapturedUpdate: null,\n\t\tlastCapturedUpdate: null,\n\t\t\n\t}\n\t_debugHookTypes: null\n\t_debugID: 1\n\t_debugIsCurrentlyTiming: false\n\t_debugNeedsRemount: false\n\t_debugOwner: null\n\t_debugSource: null\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\nupdate:\n\n{\n    callback: null\n    expirationTime: 1073741823\n    next: null\n    nextEffect: null\n    payload: {\n        element: {$$typeof: Symbol(react.element), key: null, ref: null, props: {}, type: , }\n    }\n    priority: 97\n    suspenseConfig: null\n    tag: 0\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n enqueueUpdate() \n\n/**\n * @desc enqueueUpdateupdate\n * @param FiberupdateFiber\n * @returns\n */\nfunction enqueueUpdate < State > (fiber: Fiber, update: Update < State > ) {\n    // Update queues are created lazily.\n    const alternate = fiber.alternate; // workInProgress fiber\n\t//  current fiber  workInProgress fiber \n    let queue1;\n    let queue2;\n    if (alternate === null) { // \n        // There's only one fiber.\n        queue1 = fiber.updateQueue;\n        queue2 = null;\n        if (queue1 === null) { // \n\t\t\t//  fiber.memoizedStatebaseState\n            queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState); \n        }\n    } else {\n        // There are two owners.alternatenullworkInProgress fiber \n        queue1 = fiber.updateQueue;\n        queue2 = alternate.updateQueue;\n        if (queue1 === null) {\n            if (queue2 === null) {\n                // Neither fiber has an update queue. Create new ones.\n                queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n                queue2 = alternate.updateQueue = createUpdateQueue(\n                    alternate.memoizedState,\n                );\n            } else {\n                // Only one fiber has an update queue. Clone to create a new one.\n                queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);\n            }\n        } else {\n            if (queue2 === null) {\n                // Only one fiber has an update queue. Clone to create a new one.\n                queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);\n            } else {\n                // Both owners have an update queue.\n            }\n        }\n    }\n    if (queue2 === null || queue1 === queue2) { // \n        // There's only a single queue.\n        appendUpdateToQueue(queue1, update);\n    } else {\n        // There are two queues. We need to append the update to both queues,\n        // while accounting for the persistent structure of the list  we don't\n        // want the same update to be added multiple times.\n        if (queue1.lastUpdate === null || queue2.lastUpdate === null) { // \n            // One of the queues is not empty. We must add the update to both queues.\n            appendUpdateToQueue(queue1, update);\n            appendUpdateToQueue(queue2, update);\n        } else {\n            // Both queues are non-empty. The last update is the same in both lists,\n            // because of structural sharing. So, only append to one of the lists.\n            appendUpdateToQueue(queue1, update);\n            // But we still need to update the `lastUpdate` pointer of queue2.\n            queue2.lastUpdate = update;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n * fiber.aternate   Fiber current fiber workInProgress fiberdiff  workInProgress fiber current fiber  alternate  workInProgress fiberworkInProgress fiber  alternate  current fiberworkInProgress  fiber current  workInProgress fiberFiber  alternate  cloneFiber cloneFiber  Fiber  alternate\n\nfiber.alternate\n\n\n\n{\n    queue1: {\n        baseState: null\n        firstCapturedEffect: null\n        firstCapturedUpdate: null\n        firstEffect: null\n        firstUpdate: {\n            expirationTime: 1073741823,\n            suspenseConfig: null,\n            tag: 0,\n            payload: {\n                },\n            callback: null,\n            \n        }\n        lastCapturedEffect: null\n        lastCapturedUpdate: null\n        lastEffect: null\n        lastUpdate: {\n            expirationTime: 1073741823,\n            suspenseConfig: null,\n            tag: 0,\n            payload: {\n                },\n            callback: null,\n            \n        }\n        __proto__: Object\n    },\n    queue2: null\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n * createUpdateQueue (fiber.memoizedState) \n\nfiber.memoizedState  baseState baseState  memoizedState  null\n\n/**\n * @desc UpdateQueue\n * @param baseState: State\n * @returns UpdateQueue<State>\n */\nfunction createUpdateQueue < State > (baseState: State): UpdateQueue < State > {\n    const queue: UpdateQueue < State > = {\n        baseState,\n        firstUpdate: null, // \n        lastUpdate: null, // \n        firstCapturedUpdate: null, // \n        lastCapturedUpdate: null, // \n        firstEffect: null,\n        lastEffect: null,\n        firstCapturedEffect: null,\n        lastCapturedEffect: null,\n    };\n    return queue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nUpdateQueue   FiberNode  Callback CapturedUpdate \n\nKEY           TYPE     DESC\nbaseState     Object   \nfirstUpdate   Update    Update \nlastUpdate    Update    Update \nfirstEffect   Update   Callback Update \nlastEffect    Update   Callback Update \n\n * cloneUpdateQueue (queue) \n\ncloneUpdateQueue22  baseStatefirstUpdate  lastUpdate \n\nfunction cloneUpdateQueue < State > (\n    currentQueue: UpdateQueue < State > ,\n): UpdateQueue < State > {\n    const queue: UpdateQueue < State > = {\n        baseState: currentQueue.baseState,\n        firstUpdate: currentQueue.firstUpdate,\n        lastUpdate: currentQueue.lastUpdate,\n\n        // TODO: With resuming, if we bail out and resuse the child tree, we should\n        // keep these effects.\n        firstCapturedUpdate: null,\n        lastCapturedUpdate: null,\n\n        firstEffect: null,\n        lastEffect: null,\n\n        firstCapturedEffect: null,\n        lastCapturedEffect: null,\n    };\n    return queue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * appendUpdateToQueue (queue, update) \n\nappendUpdateToQueue ()  firstUpdate lastUpdate  lastUpdate  null update next  update\n\n/**\n * @description \n * @param {*} queue \n * @param {*} update \n */\nfunction appendUpdateToQueue < State > (\n    queue: UpdateQueue < State > ,\n    update: Update < State > ,\n) {\n    // Append the update to the end of the list.\n    if (queue.lastUpdate === null) {\n        // Queue is empty // \n        queue.firstUpdate = queue.lastUpdate = update; // update\n    } else {\n        queue.lastUpdate.next = update; // update next\n        queue.lastUpdate = update; //  update\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n 1. queue \n\nqueue1  fiber.updateQueue queue2  fiber.alternate.updateQueue updateQueue  fiber \n\nqueue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\nqueue2 = alternate.updateQueue = createUpdateQueue(\n    alternate.memoizedState,\n);\n\n\n1\n2\n3\n4\n",normalizedContent:"# \n\n\n\n * \n * reactdom \n * render \n   *  reactroot\n   * \n   * updatecontainer() \n\n\n\n\n# reactdom \n\n react-dom  reactdom.js  reactdom\n\nconst reactdom: object = {\n\tcreateportal, //  portal\n\tfinddomnode, //  dom\n\thydrate,\n\trender,\n\tunstable_rendersubtreeintocontainer,\n\tunmountcomponentatnode,\n\tunstable_batchedupdates,\n\tunstable_interactiveupdates,\n\tunstable_discreteupdates,\n\tunstable_flushdiscreteupdates,\n\tflushsync,\n\tunstable_createroot,\n\tunstable_createsyncroot,\n\tunstable_flushcontrolled,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# render \n\nrender \n\nrender(\n    element: react$element < any >, // render \n    container: domcontainer, // render \n    callback: ?function, // callback\n) {\n    return legacyrendersubtreeintocontainer(\n        null,\n        element,\n        container,\n        false,\n        callback,\n    );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n root  parentcomponent  null  legacyrendersubtreeintocontainer \n\nfunction legacyrendersubtreeintocontainer(\n    parentcomponent: ? react$component < any, any > ,\n    children : reactnodelist, // \n    container: domcontainer, // \n    forcehydrate: boolean,\n    callback: ? function,\n) {\n    let root: _reactsyncroot = (container._reactrootcontainer: any);\n    let fiberroot;\n    if (!root) {\n        // initial mount\n        //  reactsyncroot \n        root = container._reactrootcontainer = legacycreaterootfromdomcontainer(\n            container,\n            forcehydrate,\n        );\n        console.log('==>legacyrendersubtreeintocontainer_ reactsyncroot ', {\n            root\n        });\n        // {\n        //   _internalroot: fiberrootnode //  fiber \n        //   callbackexpirationtime: 0\n        //   callbacknode: null\n        //   callbackpriority: 90\n        //   containerinfo: div#root // root  dom \n        //   context: {}\n        //   current: fibernode {tag: 3, key: null, elementtype: null, type: null, statenode: fiberrootnode, }\n        //   finishedexpirationtime: 0\n        //   finishedwork: null\n        //   firstbatch: null\n        //   firstpendingtime: 0\n        //   firstsuspendedtime: 0\n        //   hydrate: false\n        //   interactionthreadid: 1\n        //   lastexpiredtime: 0\n        //   lastpingedtime: 0\n        //   lastsuspendedtime: 0\n        //   memoizedinteractions: set(0) {}\n        //   nextknownpendinglevel: 0\n        //   pendingchildren: null\n        //   pendingcontext: null\n        //   pendinginteractionmap: map(0) {}\n        //   pingcache: null\n        //   tag: 0\n        //   timeouthandle: -1\n        // }\n        fiberroot = root._internalroot;\n        if (typeof callback === 'function') {\n            const originalcallback = callback;\n            callback = function () {\n                //  public  root  callback\n                const instance = getpublicrootinstance(fiberroot);\n                console.log('==>getpublicrootinstance_ callback  root ', {\n                    instance\n                });\n                // instance: null \n                originalcallback.call(instance);\n            };\n        }\n        // initial mount should not be batched.\n        // render  batchedupdates\n        unbatchedupdates(() => {\n            // \n            updatecontainer(children, fiberroot, parentcomponent, callback);\n        });\n    } else {\n        //  root \n        fiberroot = root._internalroot;\n        if (typeof callback === 'function') {\n            const originalcallback = callback;\n            callback = function () {\n                const instance = getpublicrootinstance(fiberroot);\n                originalcallback.call(instance);\n            };\n        }\n        // update\n        updatecontainer(children, fiberroot, parentcomponent, callback);\n    }\n    //  public  root \n    // render \n    return getpublicrootinstance(fiberroot);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n\n 1.  render ()  legacyrendersubtreeintocontainer  _reactsyncroot  root fiberroot = root._internalroot \n 2. render ()  callback   public  root  callback\n 3. render  patch  unbatchedupdates() \n 4.  patch  updatecontainer \n\n\n#  reactroot\n\n root = container._reactrootcontainer = legacycreaterootfromdomcontainer(\n     container,\n     forcehydrate,\n );\n\n\n1\n2\n3\n4\n\n\n legacycreaterootfromdomcontainer  reactroot reatroot  reactsyncroot  container._reactrootcontainer \n\nlegacycreaterootfromdomcontainer \n\nfunction legacycreaterootfromdomcontainer(\n    container: domcontainer,\n    forcehydrate: boolean,\n): _reactsyncroot {\n    //  hydrate\n    const shouldhydrate =\n        forcehydrate || shouldhydrateduetolegacyheuristic(container);\n    // first clear any existing content.\n    if (!shouldhydrate) {\n        let rootsibling;\n        // lastchild  null\n\t\t// \n        while ((rootsibling = container.lastchild)) {\n            container.removechild(rootsibling);\n        }\n    }\n\n    // legacy roots are not batched.\n    return new reactsyncroot(\n        container,\n        legacyroot, // root \n        shouldhydrate ?\n        {\n            hydrate: true,\n        } :\n        undefined,\n    );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n 1.  root \n 2.  hydrate\n 3. legacyroot \n\n\n# \n\n# fiberroot\n\nfiberroot  fiberrootfiberroot  react  updatecontainer () \n\n react-reconciler/reactfiberroot.js \n\nexport type fiberroot = {\n    ...basefiberrootproperties,\n    ...profilingonlyfiberrootproperties,\n    ...suspensecallbackonlyfiberrootproperties,\n};\n\n\n1\n2\n3\n4\n5\n\n\n basefiberrootproperties \n\ntype basefiberrootproperties = {\n    |\n    // the type of root (legacy, batched, concurrent, etc.)\n    // tag \n    // export type roottag = 0 | 1 | 2;\n    // export const legacyroot = 0;\n    // export const batchedroot = 1;\n    // export const concurrentroot = 2;\n    tag: roottag,\n\n    // any additional information from the host associated with this root.\n    // \n    containerinfo: any,\n    // used only by persistent updates.\n    pendingchildren: any,\n    // the currently active root fiber. this is the mutable root of the tree.\n    //  fiber \n    current: fiber,\n\n    pingcache:\n        |\n        weakmap < thenable,\n    set < expirationtime >>\n    |\n    map < thenable,\n    set < expirationtime >>\n    |\n    null,\n\n    finishedexpirationtime: expirationtime,\n    // a finished work-in-progress hostroot that's ready to be committed.\n    //  commit  fiber\n    finishedwork: fiber | null,\n    // timeout handle returned by settimeout. used to cancel a pending timeout, if\n    // it's superseded by a new one.\n    timeouthandle: timeouthandle | notimeout,\n    // top context object, used by rendersubtreeintocontainer\n    context: object | null,\n    pendingcontext: object | null,\n    // determines if we should attempt to hydrate on the initial mount\n    // hydrate\n    +hydrate: boolean,\n    // list of top-level batches. this list indicates whether a commit should be\n    // deferred. also contains completion callbacks.\n    // todo: lift this into the renderer\n    firstbatch: batch | null,\n    // node returned by scheduler.schedulecallback\n    callbacknode: * ,\n    // expiration of the callback associated with this root\n    // callback \n    callbackexpirationtime: expirationtime,\n    // priority of the callback associated with this root\n    callbackpriority: reactprioritylevel,\n    // the earliest pending expiration time that exists in the tree\n    firstpendingtime: expirationtime,\n    // the earliest suspended expiration time that exists in the tree\n    firstsuspendedtime: expirationtime,\n    // the latest suspended expiration time that exists in the tree\n    lastsuspendedtime: expirationtime,\n    // the next known expiration time after the suspended range\n    nextknownpendinglevel: expirationtime,\n    // the latest time at which a suspended component pinged the root to\n    // render again\n    lastpingedtime: expirationtime,\n    lastexpiredtime: expirationtime,\n    |\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\nfiberroot \n\n\n# updatecontainer () \n\n batchedupdates()  unbatchedupdates()  updatecontainer() \n\nupdatecontainer() \n\nfunction updatecontainer(\n    element: reactnodelist,\n    container: opaqueroot,\n    parentcomponent: ? react$component < any, any > ,\n    callback : ? function,\n): expirationtime {\n    //  fiber \n    const current = container.current;\n    const currenttime = requestcurrenttime();\n    const suspenseconfig = requestcurrentsuspenseconfig();\n    const expirationtime = computeexpirationforfiber(\n        currenttime,\n        current,\n        suspenseconfig,\n    );\n    return updatecontaineratexpirationtime(\n        element,\n        container,\n        parentcomponent,\n        expirationtime,\n        suspenseconfig,\n        callback,\n    );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n elementcontainerparentcomponent  callback expirationtime  expirationtime  suspenseconfig\n\n * requestcurrentsuspenseconfig()  reactcurrentbatchconfig.suspense  batch \n\n/**\n * keeps track of the current batch's configuration such as how long an update\n * should suspend for if it needs to.\n */\n//  batch \nconst reactcurrentbatchconfig = {\n    suspense: (null: null | suspenseconfig),\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * [[expirationtime,context ]]\n\ncomputeexpirationforfiber(\n  currenttime: expirationtime,\n  fiber: fiber,\n  suspenseconfig: null | suspenseconfig,\n): expirationtime {\n  const mode = fiber.mode;\n  if ((mode & batchedmode) === nomode) {\n    console.log('==>', {mode, batchedmode});\n    // {mode: 8, batchedmode: 2}\n    // 8&2=0\n    return sync; // 1073741823 max_signed_31_bit_int\n  }\n\n  const prioritylevel = getcurrentprioritylevel();\n  if ((mode & concurrentmode) === nomode) {\n    console.log('==>', {mode, concurrentmode});\n    return prioritylevel === immediatepriority ? sync : batched;\n  }\n\n  if ((executioncontext & rendercontext) !== nocontext) {\n    console.log('==>', {executioncontext, rendercontext});\n    // use whatever time we're already rendering\n    // todo: should there be a way to opt out, like with `runwithpriority`?\n    return renderexpirationtime; // nowork 0\n  }\n\n  let expirationtime;\n  if (suspenseconfig !== null) {\n    // compute an expiration time based on the suspense timeout.\n    expirationtime = computesuspenseexpiration(\n      currenttime,\n      suspenseconfig.timeoutms | 0 || low_priority_expiration,\n    );\n  } else {\n    // compute an expiration time based on the scheduler priority.\n    switch (prioritylevel) {\n      case immediatepriority:\n        expirationtime = sync;\n        break;\n      case userblockingpriority:\n        // todo: rename this to computeuserblockingexpiration\n        expirationtime = computeinteractiveexpiration(currenttime);\n        break;\n      case normalpriority:\n      case lowpriority: // todo: handle lowpriority\n        // todo: rename this to... something better.\n        expirationtime = computeasyncexpiration(currenttime);\n        break;\n      case idlepriority:\n        expirationtime = idle;\n        break;\n      default:\n        invariant(false, 'expected a valid priority level');\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n updatecontaineratexpirationtime()  context\n\nfunction updatecontaineratexpirationtime(\n    element: reactnodelist,\n    container: opaqueroot,\n    parentcomponent: ? react$component < any, any > ,\n    expirationtime : expirationtime,\n    suspenseconfig: null | suspenseconfig,\n    callback: ? function,\n) {\n    const current = container.current;\n  \t// context container.context  container.pendingcontext\n    const context = getcontextforsubtree(parentcomponent);\n    if (container.context === null) {\n        container.context = context;\n    } else {\n        container.pendingcontext = context;\n    }\n\n    return schedulerootupdate(\n        current,\n        element,\n        expirationtime,\n        suspenseconfig,\n        callback,\n    );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * [[expirationtime,context ]]\n\n schedulerootupdate()  render \n\nfunction schedulerootupdate(\n    current: fiber,\n    element: reactnodelist,\n    expirationtime: expirationtime,\n    suspenseconfig: null | suspenseconfig,\n    callback: ? function,\n) {\n    // render expirationtimesuspenseconfig  update\n    const update = createupdate(expirationtime, suspenseconfig);\n\n    callback = callback === undefined ? null : callback;\n    if (callback !== null) {\n        warningwithoutstack(\n            typeof callback === 'function',\n            'render(...): expected the last optional `callback` argument to be a ' +\n            'function. instead received: %s.',\n            callback,\n        );\n        //  callback  update\n        update.callback = callback;\n    }\n    // \n    enqueueupdate(current, update);\n    // expirationtime\n    schedulework(current, expirationtime);\n\n    return expirationtime;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n createupdate()  enqueueupdate()  schedulework() \n\n# createupdate () \n\n update  tag  updatestate \n\n// createupdateupdatepartialstatecallbackexpirationtime\nfunction createupdate(\n    expirationtime: expirationtime,\n    suspenseconfig: null | suspenseconfig,\n): update < * > {\n    let update: update < * > = { // update\n        expirationtime, // \n        suspenseconfig, // \n\n        tag: updatestate, // 0updatestate0\n        payload: null, // `setstate`\n        callback: null, // \n\n        next: null, // \n        nexteffect: null, // \n    };\n    if (__dev__) {\n        update.priority = getcurrentprioritylevel();\n    }\n    return update;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nupdate \n\ntype update < state > = {\n    expirationtime: expirationtime,\n    suspenseconfig: null | suspenseconfig,\n\n    tag: 0 | 1 | 2 | 3,\n    payload: any,\n    callback: (() => mixed) | null,\n\n    next: update < state > | null,\n    nexteffect: update < state > | null,\n\n    //dev only\n    priority ? : reactprioritylevel,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * next  nexteffect \n * update  tag \n\nexport const updatestate = 0;\nexport const replacestate = 1;\nexport const forceupdate = 2;\nexport const captureupdate = 3;\n\n\n1\n2\n3\n4\n\n\nupdate \n\nkey        type              desc\ntag        number             0~3\n                             updatestatereplacestateforceupdatecaptureupdate\npayload    function|object   \ncallback   function           updatequeue  update \nnext       update            updatequeue  update  next  update \n\n# enqueueupdate () \n\n update  update  enqueueupdate()  fiber  update  fider  update \n\nfiber:\n\n{\n\tactualduration: 0\n\tactualstarttime: -1\n\talternate: fibernode { // alternatefibernode\n\t\ttag: 3,\n\t\tkey: null,\n\t\telementtype: null,\n\t\ttype: null,\n\t\tstatenode: fiberrootnode,\n\t\t\n\t}\n\tchild: null\n\tchildexpirationtime: 0\n\tdependencies: null\n\teffecttag: 0\n\telementtype: null\n\texpirationtime: 1073741823\n\tfirsteffect: null\n\tindex: 0\n\tkey: null\n\tlasteffect: null\n\tmemoizedprops: null\n\tmemoizedstate: null\n\tmode: 8\n\tnexteffect: null\n\tpendingprops: null\n\tref: null\n\treturn :null\n\tselfbaseduration: 0\n\tsibling: null\n\tstatenode: fiberrootnode {\n\t\ttag: 0,\n\t\tcurrent: fibernode,\n\t\tcontainerinfo: div# root,\n\t\tpendingchildren: null,\n\t\tpingcache: null,\n\t\t\n\t}\n\ttag: 3\n\ttreebaseduration: 0\n\ttype: null\n\tupdatequeue: {\n\t\tbasestate: null,\n\t\tfirstupdate: {\n\t\t\t},\n\t\tlastupdate: {\n\t\t\t},\n\t\tfirstcapturedupdate: null,\n\t\tlastcapturedupdate: null,\n\t\t\n\t}\n\t_debughooktypes: null\n\t_debugid: 1\n\t_debugiscurrentlytiming: false\n\t_debugneedsremount: false\n\t_debugowner: null\n\t_debugsource: null\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\nupdate:\n\n{\n    callback: null\n    expirationtime: 1073741823\n    next: null\n    nexteffect: null\n    payload: {\n        element: {$$typeof: symbol(react.element), key: null, ref: null, props: {}, type: , }\n    }\n    priority: 97\n    suspenseconfig: null\n    tag: 0\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n enqueueupdate() \n\n/**\n * @desc enqueueupdateupdate\n * @param fiberupdatefiber\n * @returns\n */\nfunction enqueueupdate < state > (fiber: fiber, update: update < state > ) {\n    // update queues are created lazily.\n    const alternate = fiber.alternate; // workinprogress fiber\n\t//  current fiber  workinprogress fiber \n    let queue1;\n    let queue2;\n    if (alternate === null) { // \n        // there's only one fiber.\n        queue1 = fiber.updatequeue;\n        queue2 = null;\n        if (queue1 === null) { // \n\t\t\t//  fiber.memoizedstatebasestate\n            queue1 = fiber.updatequeue = createupdatequeue(fiber.memoizedstate); \n        }\n    } else {\n        // there are two owners.alternatenullworkinprogress fiber \n        queue1 = fiber.updatequeue;\n        queue2 = alternate.updatequeue;\n        if (queue1 === null) {\n            if (queue2 === null) {\n                // neither fiber has an update queue. create new ones.\n                queue1 = fiber.updatequeue = createupdatequeue(fiber.memoizedstate);\n                queue2 = alternate.updatequeue = createupdatequeue(\n                    alternate.memoizedstate,\n                );\n            } else {\n                // only one fiber has an update queue. clone to create a new one.\n                queue1 = fiber.updatequeue = cloneupdatequeue(queue2);\n            }\n        } else {\n            if (queue2 === null) {\n                // only one fiber has an update queue. clone to create a new one.\n                queue2 = alternate.updatequeue = cloneupdatequeue(queue1);\n            } else {\n                // both owners have an update queue.\n            }\n        }\n    }\n    if (queue2 === null || queue1 === queue2) { // \n        // there's only a single queue.\n        appendupdatetoqueue(queue1, update);\n    } else {\n        // there are two queues. we need to append the update to both queues,\n        // while accounting for the persistent structure of the list  we don't\n        // want the same update to be added multiple times.\n        if (queue1.lastupdate === null || queue2.lastupdate === null) { // \n            // one of the queues is not empty. we must add the update to both queues.\n            appendupdatetoqueue(queue1, update);\n            appendupdatetoqueue(queue2, update);\n        } else {\n            // both queues are non-empty. the last update is the same in both lists,\n            // because of structural sharing. so, only append to one of the lists.\n            appendupdatetoqueue(queue1, update);\n            // but we still need to update the `lastupdate` pointer of queue2.\n            queue2.lastupdate = update;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n * fiber.aternate   fiber current fiber workinprogress fiberdiff  workinprogress fiber current fiber  alternate  workinprogress fiberworkinprogress fiber  alternate  current fiberworkinprogress  fiber current  workinprogress fiberfiber  alternate  clonefiber clonefiber  fiber  alternate\n\nfiber.alternate\n\n\n\n{\n    queue1: {\n        basestate: null\n        firstcapturedeffect: null\n        firstcapturedupdate: null\n        firsteffect: null\n        firstupdate: {\n            expirationtime: 1073741823,\n            suspenseconfig: null,\n            tag: 0,\n            payload: {\n                },\n            callback: null,\n            \n        }\n        lastcapturedeffect: null\n        lastcapturedupdate: null\n        lasteffect: null\n        lastupdate: {\n            expirationtime: 1073741823,\n            suspenseconfig: null,\n            tag: 0,\n            payload: {\n                },\n            callback: null,\n            \n        }\n        __proto__: object\n    },\n    queue2: null\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n * createupdatequeue (fiber.memoizedstate) \n\nfiber.memoizedstate  basestate basestate  memoizedstate  null\n\n/**\n * @desc updatequeue\n * @param basestate: state\n * @returns updatequeue<state>\n */\nfunction createupdatequeue < state > (basestate: state): updatequeue < state > {\n    const queue: updatequeue < state > = {\n        basestate,\n        firstupdate: null, // \n        lastupdate: null, // \n        firstcapturedupdate: null, // \n        lastcapturedupdate: null, // \n        firsteffect: null,\n        lasteffect: null,\n        firstcapturedeffect: null,\n        lastcapturedeffect: null,\n    };\n    return queue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nupdatequeue   fibernode  callback capturedupdate \n\nkey           type     desc\nbasestate     object   \nfirstupdate   update    update \nlastupdate    update    update \nfirsteffect   update   callback update \nlasteffect    update   callback update \n\n * cloneupdatequeue (queue) \n\ncloneupdatequeue22  basestatefirstupdate  lastupdate \n\nfunction cloneupdatequeue < state > (\n    currentqueue: updatequeue < state > ,\n): updatequeue < state > {\n    const queue: updatequeue < state > = {\n        basestate: currentqueue.basestate,\n        firstupdate: currentqueue.firstupdate,\n        lastupdate: currentqueue.lastupdate,\n\n        // todo: with resuming, if we bail out and resuse the child tree, we should\n        // keep these effects.\n        firstcapturedupdate: null,\n        lastcapturedupdate: null,\n\n        firsteffect: null,\n        lasteffect: null,\n\n        firstcapturedeffect: null,\n        lastcapturedeffect: null,\n    };\n    return queue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * appendupdatetoqueue (queue, update) \n\nappendupdatetoqueue ()  firstupdate lastupdate  lastupdate  null update next  update\n\n/**\n * @description \n * @param {*} queue \n * @param {*} update \n */\nfunction appendupdatetoqueue < state > (\n    queue: updatequeue < state > ,\n    update: update < state > ,\n) {\n    // append the update to the end of the list.\n    if (queue.lastupdate === null) {\n        // queue is empty // \n        queue.firstupdate = queue.lastupdate = update; // update\n    } else {\n        queue.lastupdate.next = update; // update next\n        queue.lastupdate = update; //  update\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n 1. queue \n\nqueue1  fiber.updatequeue queue2  fiber.alternate.updatequeue updatequeue  fiber \n\nqueue1 = fiber.updatequeue = createupdatequeue(fiber.memoizedstate);\nqueue2 = alternate.updatequeue = createupdatequeue(\n    alternate.memoizedstate,\n);\n\n\n1\n2\n3\n4\n",charsets:{cjk:!0},lastUpdated:"2022/04/18, 22:27:58",lastUpdatedTimestamp:1650292078e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/react/hooks/index/",categories:["react","hooks"],tags:[null]},regularPath:"/10.react/70.hooks%E5%8E%9F%E7%90%86/0.index.html",relativePath:"10.react/70.hooks/0.index.md",key:"v-0fd7e2db",path:"/react/hooks/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"useState  useReducer",frontmatter:{title:"useState  useReducer",date:"2022-04-14T22:02:21.000Z",permalink:"/react/hooks/useState/",categories:["react","hooks"],tags:[null]},regularPath:"/10.react/70.hooks%E5%8E%9F%E7%90%86/10.useState.html",relativePath:"10.react/70.hooks/10.useState.md",key:"v-fda4440a",path:"/react/hooks/useState/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"dispatcher ",slug:"dispatcher-",normalizedTitle:"dispatcher ",charIndex:17},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:37},{level:3,title:"dispatcher ",slug:"dispatcher--",normalizedTitle:"dispatcher ",charIndex:45},{level:3,title:"dispatcher ",slug:"dispatcher-",normalizedTitle:"dispatcher ",charIndex:72},{level:2,title:"useState ",slug:"usestate-",normalizedTitle:"usestate ",charIndex:94},{level:3,title:"mountState",slug:"mountstate",normalizedTitle:"mountstate",charIndex:112},{level:3,title:"dispatchAction",slug:"dispatchaction",normalizedTitle:"dispatchaction",charIndex:128},{level:3,title:"updateState",slug:"updatestate",normalizedTitle:"updatestate",charIndex:148},{level:4,title:" reducer  basicStateReducer",slug:"-reducer--basicstatereducer",normalizedTitle:" reducer  basicstatereducer",charIndex:22853},{level:2,title:"updateReducer",slug:"updatereducer",normalizedTitle:"updatereducer",charIndex:163},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:180},{level:3,title:"useState  UI ",slug:"usestate--ui-",normalizedTitle:"usestate  ui ",charIndex:190},{level:3,title:"renderPhaseUpdates ",slug:"renderphaseupdates-",normalizedTitle:"renderphaseupdates ",charIndex:218},{level:3,title:" setState ",slug:"-setstate--",normalizedTitle:" setstate ",charIndex:247},{level:3,title:" batch update  update?",slug:"-batch-update---update",normalizedTitle:" batch update  update?",charIndex:282},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:320},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:328}],readingTime:{text:"20 min read",minutes:19.28,time:1156800.0000000002,words:3856},headersStr:" dispatcher   dispatcher  dispatcher  useState  mountState dispatchAction updateState  reducer  basicStateReducer updateReducer  useState  UI  renderPhaseUpdates   setState   batch update  update?  ",content:"# \n\n\n\n * \n * dispatcher \n   * \n   * dispatcher \n   * dispatcher \n * useState \n   * mountState\n   * dispatchAction\n   * updateState\n * updateReducer\n * \n   * useState  UI \n   * renderPhaseUpdates \n   *  setState \n   *  batch update  update?\n * \n * \n\n\n\n\n# dispatcher \n\n react  react.js  hooks  API\n\nuseCallback, // \nuseContext, //  context  provider  createContext  context.Provider \nuseEffect, // UI \nuseImperativeHandle, //  ref \nuseDebugValue, // debug \nuseLayoutEffect, //  DOM \nuseMemo, // \nuseReducer, //  reducer useContext \nuseRef, // \nuseState, // \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n useState \n\n\n# \n\n hooks  react  ReactHooks.js useState \n\nfunction useState < S > (initialState: (() => S) | S) {\n    const dispatcher = resolveDispatcher();\n    return dispatcher.useState(initialState);\n}\n\n\n1\n2\n3\n4\n\n\n\n\n 1. S  state useState  initialState \n 2.  hook  resolveDispatcher  dispatcher \n\n\n# dispatcher \n\n resolveDispatcher ReactCurrentDispatcher \n\nconst dispatcher = ReactCurrentDispatcher.current;\n\n\n1\n\n\n hook \n\nInvalid hook call. Hooks can only be called inside of the body of a function component.\n\n\n1\n\n\nReactCurrentDispatcher  ReactSharedInternals  react-reconciler  ReactFiberHooks.js  Dispatcher \n\ntype Dispatcher = {\n    readContext < T > (\n        context: ReactContext < T > ,\n        observedBits: void | number | boolean,\n    ): T,\n    useState < S > (initialState: (() => S) | S): [S, Dispatch < BasicStateAction < S >> ],\n    useReducer < S,\n    I,\n    A > (\n        reducer: (S, A) => S,\n        initialArg: I,\n        init ? : (I) => S,\n    ): [S, Dispatch < A > ],\n    useContext < T > (\n        context: ReactContext < T > ,\n        observedBits: void | number | boolean,\n    ): T,\n    useRef < T > (initialValue: T): {\n        current: T\n    },\n    useEffect(\n        create: () => (() => void) | void,\n        deps: Array < mixed > | void | null,\n    ): void,\n    useLayoutEffect(\n        create: () => (() => void) | void,\n        deps: Array < mixed > | void | null,\n    ): void,\n    useCallback < T > (callback: T, deps: Array < mixed > | void | null): T,\n    useMemo < T > (nextCreate: () => T, deps: Array < mixed > | void | null): T,\n    useImperativeHandle < T > (\n        ref: {\n            current: T | null\n        } | ((inst: T | null) => mixed) | null | void,\n        create: () => T,\n        deps: Array < mixed > | void | null,\n    ): void,\n    useDebugValue < T > (value: T, formatterFn: ? (value: T) => mixed): void,\n    useResponder < E,\n    C > (\n        responder: ReactEventResponder < E, C > ,\n        props: Object,\n    ): ReactEventResponderListener < E,\n    C > ,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n hook  dispatcher  dispatcher dispatcher  ContextOnlyDispatcherHooksDispatcherOnMountHooksDispatcherOnUpdate  dev  dispatcher  dispatcher  hook \n\nexport const ContextOnlyDispatcher: Dispatcher = {\n    readContext,\n\n    useCallback: throwInvalidHookError,\n    useContext: throwInvalidHookError,\n    useEffect: throwInvalidHookError,\n    useImperativeHandle: throwInvalidHookError,\n    useLayoutEffect: throwInvalidHookError,\n    useMemo: throwInvalidHookError,\n    useReducer: throwInvalidHookError,\n    useRef: throwInvalidHookError,\n    useState: throwInvalidHookError,\n    useDebugValue: throwInvalidHookError,\n    useResponder: throwInvalidHookError,\n};\n\nconst HooksDispatcherOnMount: Dispatcher = {\n    readContext,\n\n    useCallback: mountCallback,\n    useContext: readContext,\n    useEffect: mountEffect,\n    useImperativeHandle: mountImperativeHandle,\n    useLayoutEffect: mountLayoutEffect,\n    useMemo: mountMemo,\n    useReducer: mountReducer,\n    useRef: mountRef,\n    useState: mountState,\n    useDebugValue: mountDebugValue,\n    useResponder: createResponderListener,\n};\n\nconst HooksDispatcherOnUpdate: Dispatcher = {\n    readContext,\n    useCallback: updateCallback,\n    useContext: readContext,\n    useEffect: updateEffect,\n    useImperativeHandle: updateImperativeHandle,\n    useLayoutEffect: updateLayoutEffect,\n    useMemo: updateMemo,\n    useReducer: updateReducer,\n    useRef: updateRef,\n    useState: updateState,\n    useDebugValue: updateDebugValue,\n    useResponder: createResponderListener,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n hook ContextOnlyDispatcher  Invalid hook call  HooksDispatcherOnMount  Mount  hookHooksDispatcherOnUpdate  update  hook  HooksDispatcherOnMount  hook  HooksDispatcherOnUpdate  hook \n\n\n# dispatcher \n\n dispatcher  dispatcher HooksDispatcherOnMountHooksDispatcherOnUpdate  dispatcher renderWithHooks ContextOnlyDispatcher  resetHooks \n\n hook \n\n renderWithHooks  dev \n\nfunction renderWithHooks(\n    current: Fiber | null, //  fiber\n    workInProgress: Fiber, //  fiber\n    Component: any, // hook  hook  FC\n    props: any, // hook hook \n    refOrContext: any,\n    nextRenderExpirationTime: ExpirationTime, // \n): any {\n    renderExpirationTime = nextRenderExpirationTime;\n    //  Fiber \n    currentlyRenderingFiber = workInProgress;\n    // 1.  dispatcher\n    //  fiber  update \n    nextCurrentHook = current !== null ? current.memoizedState : null;\n    \n    // current?.memoizedState  , dispatcher  HooksDispatcherOnUpdate HooksDispatcherOnMount\n    ReactCurrentDispatcher.current =\n        nextCurrentHook === null ?\n        HooksDispatcherOnMount :\n        HooksDispatcherOnUpdate;\n    // 2.  FC \n    //  Component()  FC,  FC props  refOrContext\n    let children = Component(props, refOrContext);\n\n\n    if (didScheduleRenderPhaseUpdate) {\n        do {\n            //  false\n            didScheduleRenderPhaseUpdate = false;\n            // numberOfReRenders > RE_RENDER_LIMIT, Too many re-renders \n            numberOfReRenders += 1;\n            \n            // Start over from the beginning of the list\n            nextCurrentHook = current !== null ? current.memoizedState : null;\n            nextWorkInProgressHook = firstWorkInProgressHook;\n\n            currentHook = null;\n            workInProgressHook = null;\n            componentUpdateQueue = null;\n\n            //  dev  prd  updateDispatcher\n            ReactCurrentDispatcher.current = __DEV__ ?\n                HooksDispatcherOnUpdateInDEV :\n                HooksDispatcherOnUpdate;\n            // re-render: \n            children = Component(props, refOrContext);\n        } while (didScheduleRenderPhaseUpdate);\n\n        renderPhaseUpdates = null;\n        numberOfReRenders = 0;\n    }\n\n    // We can assume the previous dispatcher is always this one, since we set it\n    // at the beginning of the render phase and there's no re-entrancy.\n    //  dispatcher  ContextOnlyDispatcher\n    //  renderWithHooks  hooks  mountDispatcher  updateDispatcher\n    ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n    //  renderedWorkrenderedWork  hook \n    const renderedWork: Fiber = (currentlyRenderingFiber: any);\n\n    renderedWork.memoizedState = firstWorkInProgressHook;\n    renderedWork.expirationTime = remainingExpirationTime;\n    renderedWork.updateQueue = (componentUpdateQueue: any);\n    renderedWork.effectTag |= sideEffectTag;\n\n    // This check uses currentHook so that it works the same in DEV and prod bundles.\n    // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n    const didRenderTooFewHooks =\n        currentHook !== null && currentHook.next !== null;\n\n    // \n    renderExpirationTime = NoWork;\n    currentlyRenderingFiber = null;\n\n    currentHook = null;\n    nextCurrentHook = null;\n    firstWorkInProgressHook = null;\n    workInProgressHook = null;\n    nextWorkInProgressHook = null;\n\n    remainingExpirationTime = NoWork;\n    componentUpdateQueue = null;\n    sideEffectTag = 0;\n\n    invariant(\n        !didRenderTooFewHooks,\n        'Rendered fewer hooks than expected. This may be caused by an accidental ' +\n        'early return statement.',\n    );\n\n    // \n    return children;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n\n\n\n * renderWithHooks  mount  FC \n * renderWithHooks  children  ReactElement\n\n\n\n 1. current  Fiber Fiber current.memoizedState  Fiber  this  state current.memoizedState  hook\n 2.  hook  current.memoizedState  dispatcher  HooksDispatcherOnMount  dispatcher  HooksDispatcherOnUpdate \n 3.  dispatchAction \n 4. dispatcher  ContextOnlyDispatcher  renderWithHooks dispatcher \n 5. renderWithHooks \n 6. \n\nif (didScheduleRenderPhaseUpdate) {\n    do {\n        //  false\n        didScheduleRenderPhaseUpdate = false;\n        // numberOfReRenders > RE_RENDER_LIMIT(25), Too many re-renders \n        numberOfReRenders += 1;\n\n        //  dev  prd  updateDispatcher\n        ReactCurrentDispatcher.current = __DEV__ ?\n            HooksDispatcherOnUpdateInDEV :\n            HooksDispatcherOnUpdate;\n        // re-render: \n        children = Component(props, refOrContext);\n    } while (didScheduleRenderPhaseUpdate);\n\n    renderPhaseUpdates = null;\n    numberOfReRenders = 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nrenderWithHooks  mount  didScheduleRenderPhaseUpdate  useReducer  true  render   render  FC  setState \n\n render-in-render  RE_RENDER_LIMIT  didScheduleRenderPhaseUpdate  render  render useReducer  render \n\nrenderWithHooks  F\n\nmount   FC  F  log children   FC  F  log children   FC   toggleLight ()   dispatchAction  didScheduleRenderPhaseUpdate  true   FC  render-in-render    FC   toggleLight ()   dispatchAction ...  render-in-render    24  24  numberOfReRenders  ( dev  resetHooks  didScheduleRenderPhaseUpdate )     RE_RENDER_LIMIT    FC children\n\n\n# useState \n\n dispatcher  mountupdate  contextOnly  hook  dispatcher \n\n useState \n\n\n# mountState\n\n HooksDispatcherOnMount  mountState  mountState \n\nfunction mountState < S > (\n    initialState: (() => S) | S,\n): [S, Dispatch < BasicStateAction < S >> ] {\n    // hook  hook  hook\n    const hook = mountWorkInProgressHook();\n    //  initialState \n    if (typeof initialState === 'function') {\n        initialState = initialState();\n    }\n    // memoizedStatebaseState memoizedState baseState \n    hook.memoizedState = hook.baseState = initialState;\n    //  hook \n    //  hook \n    const queue = (hook.queue = {\n        last: null,\n        dispatch: null,\n        lastRenderedReducer: basicStateReducer,\n        lastRenderedState: (initialState: any),\n    });\n    //  setState  setState  dispatchAction\n    const dispatch: Dispatch <\n        BasicStateAction < S > , >\n        = (queue.dispatch = (dispatchAction.bind(\n            null,\n            // Flow doesn't know this is non-null, but we do.\n            ((currentlyRenderingFiber: any): Fiber),\n            queue,\n        ): any));\n    return [hook.memoizedState, dispatch];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n\n 1. useState  Mount  hook.baseState  dispatch setState lastRenderedState StatelastRenderedReducer reduce  reducer \n 2.  setState  dispatchAction dispatchAction  currentlyRenderingFiber Fiberqueue\n 3. queue  hook  hook  dispatchAction  Map (queue, LinkedList)  hook \n\n\n# dispatchAction\n\n setState  dispatchAction \n\nfunction dispatchAction < S, A > (\n        fiber: Fiber, //  Fiber\n        queue: UpdateQueue < S, A > , // \n        action: A,\n    ) {\n        //  25 \n        invariant(\n            numberOfReRenders < RE_RENDER_LIMIT,\n            'Too many re-renders. React limits the number of renders to prevent ' +\n            'an infinite loop.',\n        );\n\n        const alternate = fiber.alternate;\n        if (\n            fiber === currentlyRenderingFiber ||\n            (alternate !== null && alternate === currentlyRenderingFiber)\n        ) { //  Fiber currentlyRenderingFiber  fiber\n            // This is a render phase update. Stash it in a lazily-created map of\n            // queue -> linked list of updates. After this render pass, we'll restart\n            // and apply the stashed updates on top of the work-in-progress hook.\n            //  updates  map  queue -> linked list\n            // \n            didScheduleRenderPhaseUpdate = true;\n            // \n            const update: Update < S, A > = {\n                expirationTime: renderExpirationTime, // \n                suspenseConfig: null,\n                action, // dispatchAction  updateState \n                eagerReducer: null,\n                eagerState: null,\n                next: null,\n            };\n            if (__DEV__) {\n                // \n                update.priority = getCurrentPriorityLevel();\n                // renderPhaseUpdates  update queue Map\n                if (renderPhaseUpdates === null) {\n                    renderPhaseUpdates = new Map();\n                }\n                //  hook  update \n                const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n                //  queue  update update \n                if (firstRenderPhaseUpdate === undefined) {\n                    renderPhaseUpdates.set(queue, update);\n                } else {\n                    //  hook  update  update  LinkedLink \n                    // Append the update to the end of the list.\n                    let lastRenderPhaseUpdate = firstRenderPhaseUpdate;\n                    while (lastRenderPhaseUpdate.next !== null) {\n                        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n                    }\n                    lastRenderPhaseUpdate.next = update;\n                }\n            } else {\n                // prod  \n                const currentTime = requestCurrentTime();\n                const suspenseConfig = requestCurrentSuspenseConfig();\n                //  fiber \n                const expirationTime = computeExpirationForFiber(\n                    currentTime,\n                    fiber,\n                    suspenseConfig,\n                );\n                //  update \n                const update: Update < S, A > = {\n                    expirationTime, //  fiber \n                    suspenseConfig, \n                    action, // dispatchAction \n                    eagerReducer: null, //  reducer queue.lastRenderedReducer\n                    eagerState: null, //  state \n                    next: null,\n                };\n\n                if (__DEV__) {\n                    update.priority = getCurrentPriorityLevel();\n                }\n                // update \n                // Append the update to the end of the list.\n                // \n                const last = queue.last;\n                if (last === null) {\n                    //  update  hook  update \n                    // \n                    //  mount  mount  queue\n                    // This is the first update. Create a circular list.\n                    update.next = update;\n                } else {\n                    // \n                    //  next  first\n                    const first = last.next;\n                    // \n                    if (first !== null) {\n                        //  update \n                        //  update  next  first\n                        // Still circular.\n                        update.next = first;\n                    }\n                    //  update \n                    last.next = update;\n                }\n                //  update\n                queue.last = update;\n                \n                //  fiber  expirationTime  state\n                //  state  return  scheduleWork \n                //  state   state  update \n                //  const eagerState = lastRenderedReducer(currentState, action) \n                if ( \n                    fiber.expirationTime === NoWork &&\n                    (alternate === null || alternate.expirationTime === NoWork)\n                ) {\n                    // The queue is currently empty, which means we can eagerly compute the\n                    // next state before entering the render phase. If the new state is the\n                    // same as the current state, we may be able to bail out entirely.\n                    const lastRenderedReducer = queue.lastRenderedReducer;\n                    if (lastRenderedReducer !== null) {\n                        let prevDispatcher;\n                        try {\n                            const currentState: S = (queue.lastRenderedState: any);\n                            const eagerState = lastRenderedReducer(currentState, action);\n                            // Stash the eagerly computed state, and the reducer used to compute\n                            // it, on the update object. If the reducer hasn't changed by the\n                            // time we enter the render phase, then the eager state can be used\n                            // without calling the reducer again.\n                            update.eagerReducer = lastRenderedReducer;\n                            update.eagerState = eagerState;\n                            if (is(eagerState, currentState)) {\n                                // Fast path. We can bail out without scheduling React to re-render.\n                                // It's still possible that we'll need to rebase this update later,\n                                // if the component re-renders for a different reason and by that\n                                // time the reducer has changed.\n                                return;\n                            }\n                        } catch (error) {\n                            // Suppress the error. It will throw again in the render phase.\n                        } finally {\n                            if (__DEV__) {\n                                ReactCurrentDispatcher.current = prevDispatcher;\n                            }\n                        }\n                    }\n                }\n\n                //  fiber \n                scheduleWork(fiber, expirationTime);\n            }\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n\n\n\n\n * hook  update  dispatchAction   render \n * hook  dev  prod  dev  renderPhaseUpdates Map (queue,  linkedList)  prod  renderPhaseUpdates Map (queue,  linkedList) \n *  hook  queue  hook queue  last  updatequeue  renderPhaseUpdates  update \n * update  update \n\n dispatchAction \n\n * dispatchAction  map<queue, linked list> update \n * scheduleWork (fiber, expirationTime)  fiber \n * react update \n\n\n\n update \n\nupdate \n\nupdate  queue.last  last  update  dispatchAction \n\n *  hook  update  scheduleWork  () \n *  update  state eagerState\n * scheduleWork \n\n\n\n 1. \n\n * \n * react  update  update \n * \n\n\n\n *  - 2 - \n\n\n# updateState\n\n render HooksDispatcherOnUpdate  dispatcher  updateState \n\n\n\nfunction updateState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  return updateReducer(basicStateReducer, (initialState: any));\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n\n * updateState  updateReducer  useReducer  update  updateReducer\n * updateReducer  reducer  initialState state  dispatch  useReducer  useReducer  useState \n * useState  reducer  basicStateReducer\n\n#  reducer  basicStateReducer\n\nfunction reducer(state, action): state {}\n\n\n1\n\n\nreducer  state   state  action state\n\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  return typeof action === 'function' ? action(state) : action;\n}\n\n\n1\n2\n3\n\n\nbasicStateReducer  action  action  useState  dispatch useState  basicStateReducer\n\n updateReducer  useReducer \n\n\n# updateReducer\n\n updateReducer \n\nfunction updateReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  //  hook\n  const hook = updateWorkInProgressHook();\n  // queue  hook queue  queue  update \n  // useState mount  Update last \n  const queue = hook.queue;\n  invariant(\n    queue !== null,\n    'Should have a queue. This is likely a bug in React. Please file an issue.',\n  );\n\n  //  reducer  queue \n  queue.lastRenderedReducer = reducer;\n  //  hook  render \n  if (numberOfReRenders > 0) {\n    // This is a re-render. Apply the new render phase updates to the previous\n    // work-in-progress hook.\n    //  dispatch  setState  queue  mount \n    //  dispatch mount \n    const dispatch: Dispatch<A> = (queue.dispatch: any);\n    // renderPhaseUpdates   Map<UpdateQueue,Update Linked List>\n    // \n    if (renderPhaseUpdates !== null) {\n      // Render phase updates are stored in a map of queue -> linked list\n      //  hook \n      const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n      //  reduce \n      // firstRenderPhaseUpdate \n      if (firstRenderPhaseUpdate !== undefined) {\n        //  reduce  queue \n        //  queue  queue  update  firstRenderPhaseUpdate\n        //  queue  firstRenderPhaseUpdate  firstRenderPhaseUpdate map  queue \n        //  queue \n        renderPhaseUpdates.delete(queue);\n        // state reduce  memoizedState \n        let newState = hook.memoizedState;\n        let update = firstRenderPhaseUpdate;\n        // useState update  queue queue \n        //  update batch update re-render\n        // \n        // reduce\n        do {\n          // Process this render phase update. We don't have to check the\n          // priority because it will always be the same as the current\n          // render's.\n          // \n          //  update  action , update \n          // setState  action  BasicStateAction\n          const action = update.action;\n          // reducer \n          newState = reducer(newState, action);\n          //  update\n          update = update.next;\n        } while (update !== null);\n\n        // Mark that the fiber performed work, but only if the new state is\n        // different from the current state.\n        //  newState  memoizedState  didReceiveUpdate  true\n        //  fiber \n        if (!is(newState, hook.memoizedState)) {\n          markWorkInProgressReceivedUpdate();\n        }\n        //  memoizedState render\n        hook.memoizedState = newState;\n        // Don't persist the state accumulated from the render phase updates to\n        // the base state unless the queue is empty.\n        // TODO: Not sure if this is the desired semantics, but it's what we\n        // do for gDSFP. I can't remember why.\n        // \n        if (hook.baseUpdate === queue.last) {\n          hook.baseState = newState;\n        }\n        // lastRenderedState  state render  newState\n        queue.lastRenderedState = newState;\n        //  render  newState  dispatch dispatch  queue  dispatchAction \n        return [newState, dispatch];\n      }\n    }\n    //  render memoizedState\n    return [hook.memoizedState, dispatch];\n  }\n  \n  // hook  render, render \n  // The last update in the entire queue\n  const last = queue.last;\n  // The last update that is part of the base state.\n  const baseUpdate = hook.baseUpdate;\n  const baseState = hook.baseState;\n\n  // Find the first unprocessed update.\n  let first;\n  // baseUpdate \n  if (baseUpdate !== null) {\n    if (last !== null) {\n      // For the first update, the queue is a circular linked list where\n      // `queue.last.next = queue.first`. Once the first update commits, and\n      // the `baseUpdate` is no longer empty, we can unravel the list.\n      //  updatequeue.last.next = queue.first,  update update  commit\n      // \n      last.next = null;\n    }\n    //  baseUpdate.next\n    first = baseUpdate.next;\n  } else {\n    //  last.next\n    first = last !== null ? last.next : null;\n  }\n  if (first !== null) {\n    // reduce \n    let newState = baseState;\n    let newBaseState = null;\n    let newBaseUpdate = null;\n    let prevUpdate = baseUpdate;\n    let update = first;\n    let didSkip = false;\n    //  reduce \n    do {\n      const updateExpirationTime = update.expirationTime;\n      //  update  renderExpirationTime, expirationTime \n      // renderExpirationTime = 0\n      if (updateExpirationTime < renderExpirationTime) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        //  update, newBaseUpdate newBaseState\n        // \n        if (!didSkip) {\n          didSkip = true;\n          newBaseUpdate = prevUpdate;\n          newBaseState = newState;\n        }\n        // remainingExpirationTime  update  renderExpirationTime\n        // \n        // Update the remaining priority in the queue.\n        if (updateExpirationTime > remainingExpirationTime) {\n          remainingExpirationTime = updateExpirationTime;\n          markUnprocessedUpdateTime(remainingExpirationTime);\n        }\n      //  update \n      } else {\n        // This update does have sufficient priority.\n\n        // Mark the event time of this update as relevant to this render pass.\n        // TODO: This should ideally use the true event time of this update rather than\n        // its priority which is a derived and not reverseable value.\n        // TODO: We should skip this update if it was already committed but currently\n        // we have no way of detecting the difference between a committed and suspended\n        // update here.\n        markRenderEventTimeAndConfig(\n          updateExpirationTime,\n          update.suspenseConfig,\n        );\n\n        // Process this update.\n        // eagerReducer   reducer \n        if (update.eagerReducer === reducer) {\n          // If this update was processed eagerly, and its reducer matches the\n          // current reducer, we can use the eagerly computed state.\n          //  reducer,  reducer \n          newState = ((update.eagerState: any): S);\n        } else {\n          // reduce \n          const action = update.action;\n          newState = reducer(newState, action);\n        }\n      }\n      // \n      prevUpdate = update;\n      //  update\n      update = update.next;\n      // first \n    } while (update !== null && update !== first);\n\n    //  updatenewBaseUpdate  update update\n    if (!didSkip) {\n      newBaseUpdate = prevUpdate;\n      newBaseState = newState;\n    }\n\n    // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n    // didReceiveUpdate  true  Fiber\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState;\n    hook.baseUpdate = newBaseUpdate;\n    hook.baseState = newBaseState;\n\n    queue.lastRenderedState = newState;\n  }\n\n  const dispatch: Dispatch<A> = (queue.dispatch: any);\n  return [hook.memoizedState, dispatch];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n\n\n\n\n * updateReducer  updates  state \n * queue  hook queue \n\n                    \nlastRenderedReducer    reduce  reducer\ndispatch               dispatchAction\nlast                   update queue  update \nlastRenderedState     \n\n * dispatch  reducer \n\nfunction dispatch(state || () => state): void //  action\nfunction reducer(state, action): state // \n\n\n1\n2\n\n\n * numberOfReRenders  renderWithHooks  renderWithHooks  re-render renderWithHooks  react-reconciler  ReactFiberBeginWork.js  FC  numberOfReRenders  finishHooks  resetHooks  numberOfReRenders  0 hook finish renderWithHooks \n\n * renderExpirationTime  NoWork = 0  updateExpirationTime  0  remainingExpirationTimeremainingExpirationTime \n\n * updateReducer \n\n\n\n *  hook  mount  updateState  update  update  reducereduce  newState \n * resetHooks   performSyncWorkOnRoot/performConcurrentWorkOnRoot  handleError  react  hook \n * Batched Updates\n\n hook  queue  react  dispatchAction  dispatchAction  reduce updates  reduce update  renderWithHooks  dispatchAction  render \n\ndo {\n  newState = reducer(newState, action);\n  update = update.next;\n} while (update !== null);\n\n\n1\n2\n3\n4\n\n\n\n# \n\n\n\n\n# useState  UI \n\n newState  newState  hook.memoizedState  hook.memoizedState  reRender  didReceiveUpdate  true UI  render didReceiveUpdate  react-reconciler  ReactFiberBeginWork.js useState  didReceiveUpdate UI  setState  dispatchAction  scheduleWork \n\n\n# renderPhaseUpdates \n\n renderPhaseUpdates  renderPhaseUpdates \n\nlet renderPhaseUpdates: Map<\n  UpdateQueue<any, any>,\n  Update<any, any>,\n> | null = null;\n\n\n1\n2\n3\n4\n\n\ndispatchAction \n\nif (renderPhaseUpdates === null) {\n  renderPhaseUpdates = new Map();\n}\nconst firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\nif (firstRenderPhaseUpdate === undefined) {\n  renderPhaseUpdates.set(queue, update);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nupdateReducer \n\nif (renderPhaseUpdates !== null) {\n  const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n  if (firstRenderPhaseUpdate !== undefined) {\n    renderPhaseUpdates.delete(queue);\n    ...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * renderPhaseUpdates  Map dispatchAction  setState  map useState  map  queuequeue last  update\n *  resetHooks  null updateReducer  queue \n\n\n#  setState \n\n setState  queue  queue  update  scheduleWork  fiber  updateReducer  newState newState updateReducer  newState  reducer useState  reducer  basicStateReducer basicStateReducer  setState setState  setState  merge  setState \n\nbasicStateReducer\n\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  return typeof action === 'function' ? action(state) : action;\n}\n\n\n1\n2\n3\n\n\nuseMergedState\n\nexport function useMergedState<T>(initialState: T) {\n  const [state, setState] = useState<T>(initialState);\n  let mergeState: any = setState;\n  if (typeof state === 'object') {\n    mergeState = (value: T) => {\n      if (value && typeof value === 'object') {\n        setState({\n          ...state,\n          ...value,\n        });\n      } else {\n        setState(value);\n      }\n    };\n  }\n  return [state, setState, mergeState];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n#  batch update  update?\n\n *  update  dispatchAction dispatchAction  update  queue  update\n * update  dispatchAction  reduce update  fiber \n *  fiber  queue  update  update  fiber  update \n\n\n# \n\n dispatcher mountStatedispatchActionupdateState \n\n 1. \n\n * dispatcher hook\n * mountState hook  queuemount  update\n * dispatchAction update update update \n * updateStateupdateReducer update fiber  state\n\n 2. \n\n *  hook api  dispatcher  dispatcher dev  dev  dispatcher\n * mount  mountState  state  queue  dispatchAction  renderPhaseUpdates dispatchAction \n * render  updateState  reducer  state  dispatch\n *  setState  dispatchAction dispatchAction  update  scheduleWork  Fiber\n\n\n# \n\n * \n * React Hooks ",normalizedContent:"# \n\n\n\n * \n * dispatcher \n   * \n   * dispatcher \n   * dispatcher \n * usestate \n   * mountstate\n   * dispatchaction\n   * updatestate\n * updatereducer\n * \n   * usestate  ui \n   * renderphaseupdates \n   *  setstate \n   *  batch update  update?\n * \n * \n\n\n\n\n# dispatcher \n\n react  react.js  hooks  api\n\nusecallback, // \nusecontext, //  context  provider  createcontext  context.provider \nuseeffect, // ui \nuseimperativehandle, //  ref \nusedebugvalue, // debug \nuselayouteffect, //  dom \nusememo, // \nusereducer, //  reducer usecontext \nuseref, // \nusestate, // \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n usestate \n\n\n# \n\n hooks  react  reacthooks.js usestate \n\nfunction usestate < s > (initialstate: (() => s) | s) {\n    const dispatcher = resolvedispatcher();\n    return dispatcher.usestate(initialstate);\n}\n\n\n1\n2\n3\n4\n\n\n\n\n 1. s  state usestate  initialstate \n 2.  hook  resolvedispatcher  dispatcher \n\n\n# dispatcher \n\n resolvedispatcher reactcurrentdispatcher \n\nconst dispatcher = reactcurrentdispatcher.current;\n\n\n1\n\n\n hook \n\ninvalid hook call. hooks can only be called inside of the body of a function component.\n\n\n1\n\n\nreactcurrentdispatcher  reactsharedinternals  react-reconciler  reactfiberhooks.js  dispatcher \n\ntype dispatcher = {\n    readcontext < t > (\n        context: reactcontext < t > ,\n        observedbits: void | number | boolean,\n    ): t,\n    usestate < s > (initialstate: (() => s) | s): [s, dispatch < basicstateaction < s >> ],\n    usereducer < s,\n    i,\n    a > (\n        reducer: (s, a) => s,\n        initialarg: i,\n        init ? : (i) => s,\n    ): [s, dispatch < a > ],\n    usecontext < t > (\n        context: reactcontext < t > ,\n        observedbits: void | number | boolean,\n    ): t,\n    useref < t > (initialvalue: t): {\n        current: t\n    },\n    useeffect(\n        create: () => (() => void) | void,\n        deps: array < mixed > | void | null,\n    ): void,\n    uselayouteffect(\n        create: () => (() => void) | void,\n        deps: array < mixed > | void | null,\n    ): void,\n    usecallback < t > (callback: t, deps: array < mixed > | void | null): t,\n    usememo < t > (nextcreate: () => t, deps: array < mixed > | void | null): t,\n    useimperativehandle < t > (\n        ref: {\n            current: t | null\n        } | ((inst: t | null) => mixed) | null | void,\n        create: () => t,\n        deps: array < mixed > | void | null,\n    ): void,\n    usedebugvalue < t > (value: t, formatterfn: ? (value: t) => mixed): void,\n    useresponder < e,\n    c > (\n        responder: reacteventresponder < e, c > ,\n        props: object,\n    ): reacteventresponderlistener < e,\n    c > ,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n hook  dispatcher  dispatcher dispatcher  contextonlydispatcherhooksdispatcheronmounthooksdispatcheronupdate  dev  dispatcher  dispatcher  hook \n\nexport const contextonlydispatcher: dispatcher = {\n    readcontext,\n\n    usecallback: throwinvalidhookerror,\n    usecontext: throwinvalidhookerror,\n    useeffect: throwinvalidhookerror,\n    useimperativehandle: throwinvalidhookerror,\n    uselayouteffect: throwinvalidhookerror,\n    usememo: throwinvalidhookerror,\n    usereducer: throwinvalidhookerror,\n    useref: throwinvalidhookerror,\n    usestate: throwinvalidhookerror,\n    usedebugvalue: throwinvalidhookerror,\n    useresponder: throwinvalidhookerror,\n};\n\nconst hooksdispatcheronmount: dispatcher = {\n    readcontext,\n\n    usecallback: mountcallback,\n    usecontext: readcontext,\n    useeffect: mounteffect,\n    useimperativehandle: mountimperativehandle,\n    uselayouteffect: mountlayouteffect,\n    usememo: mountmemo,\n    usereducer: mountreducer,\n    useref: mountref,\n    usestate: mountstate,\n    usedebugvalue: mountdebugvalue,\n    useresponder: createresponderlistener,\n};\n\nconst hooksdispatcheronupdate: dispatcher = {\n    readcontext,\n    usecallback: updatecallback,\n    usecontext: readcontext,\n    useeffect: updateeffect,\n    useimperativehandle: updateimperativehandle,\n    uselayouteffect: updatelayouteffect,\n    usememo: updatememo,\n    usereducer: updatereducer,\n    useref: updateref,\n    usestate: updatestate,\n    usedebugvalue: updatedebugvalue,\n    useresponder: createresponderlistener,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n hook contextonlydispatcher  invalid hook call  hooksdispatcheronmount  mount  hookhooksdispatcheronupdate  update  hook  hooksdispatcheronmount  hook  hooksdispatcheronupdate  hook \n\n\n# dispatcher \n\n dispatcher  dispatcher hooksdispatcheronmounthooksdispatcheronupdate  dispatcher renderwithhooks contextonlydispatcher  resethooks \n\n hook \n\n renderwithhooks  dev \n\nfunction renderwithhooks(\n    current: fiber | null, //  fiber\n    workinprogress: fiber, //  fiber\n    component: any, // hook  hook  fc\n    props: any, // hook hook \n    reforcontext: any,\n    nextrenderexpirationtime: expirationtime, // \n): any {\n    renderexpirationtime = nextrenderexpirationtime;\n    //  fiber \n    currentlyrenderingfiber = workinprogress;\n    // 1.  dispatcher\n    //  fiber  update \n    nextcurrenthook = current !== null ? current.memoizedstate : null;\n    \n    // current?.memoizedstate  , dispatcher  hooksdispatcheronupdate hooksdispatcheronmount\n    reactcurrentdispatcher.current =\n        nextcurrenthook === null ?\n        hooksdispatcheronmount :\n        hooksdispatcheronupdate;\n    // 2.  fc \n    //  component()  fc,  fc props  reforcontext\n    let children = component(props, reforcontext);\n\n\n    if (didschedulerenderphaseupdate) {\n        do {\n            //  false\n            didschedulerenderphaseupdate = false;\n            // numberofrerenders > re_render_limit, too many re-renders \n            numberofrerenders += 1;\n            \n            // start over from the beginning of the list\n            nextcurrenthook = current !== null ? current.memoizedstate : null;\n            nextworkinprogresshook = firstworkinprogresshook;\n\n            currenthook = null;\n            workinprogresshook = null;\n            componentupdatequeue = null;\n\n            //  dev  prd  updatedispatcher\n            reactcurrentdispatcher.current = __dev__ ?\n                hooksdispatcheronupdateindev :\n                hooksdispatcheronupdate;\n            // re-render: \n            children = component(props, reforcontext);\n        } while (didschedulerenderphaseupdate);\n\n        renderphaseupdates = null;\n        numberofrerenders = 0;\n    }\n\n    // we can assume the previous dispatcher is always this one, since we set it\n    // at the beginning of the render phase and there's no re-entrancy.\n    //  dispatcher  contextonlydispatcher\n    //  renderwithhooks  hooks  mountdispatcher  updatedispatcher\n    reactcurrentdispatcher.current = contextonlydispatcher;\n\n    //  renderedworkrenderedwork  hook \n    const renderedwork: fiber = (currentlyrenderingfiber: any);\n\n    renderedwork.memoizedstate = firstworkinprogresshook;\n    renderedwork.expirationtime = remainingexpirationtime;\n    renderedwork.updatequeue = (componentupdatequeue: any);\n    renderedwork.effecttag |= sideeffecttag;\n\n    // this check uses currenthook so that it works the same in dev and prod bundles.\n    // hooktypesdev could catch more cases (e.g. context) but only in dev bundles.\n    const didrendertoofewhooks =\n        currenthook !== null && currenthook.next !== null;\n\n    // \n    renderexpirationtime = nowork;\n    currentlyrenderingfiber = null;\n\n    currenthook = null;\n    nextcurrenthook = null;\n    firstworkinprogresshook = null;\n    workinprogresshook = null;\n    nextworkinprogresshook = null;\n\n    remainingexpirationtime = nowork;\n    componentupdatequeue = null;\n    sideeffecttag = 0;\n\n    invariant(\n        !didrendertoofewhooks,\n        'rendered fewer hooks than expected. this may be caused by an accidental ' +\n        'early return statement.',\n    );\n\n    // \n    return children;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n\n\n\n * renderwithhooks  mount  fc \n * renderwithhooks  children  reactelement\n\n\n\n 1. current  fiber fiber current.memoizedstate  fiber  this  state current.memoizedstate  hook\n 2.  hook  current.memoizedstate  dispatcher  hooksdispatcheronmount  dispatcher  hooksdispatcheronupdate \n 3.  dispatchaction \n 4. dispatcher  contextonlydispatcher  renderwithhooks dispatcher \n 5. renderwithhooks \n 6. \n\nif (didschedulerenderphaseupdate) {\n    do {\n        //  false\n        didschedulerenderphaseupdate = false;\n        // numberofrerenders > re_render_limit(25), too many re-renders \n        numberofrerenders += 1;\n\n        //  dev  prd  updatedispatcher\n        reactcurrentdispatcher.current = __dev__ ?\n            hooksdispatcheronupdateindev :\n            hooksdispatcheronupdate;\n        // re-render: \n        children = component(props, reforcontext);\n    } while (didschedulerenderphaseupdate);\n\n    renderphaseupdates = null;\n    numberofrerenders = 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nrenderwithhooks  mount  didschedulerenderphaseupdate  usereducer  true  render   render  fc  setstate \n\n render-in-render  re_render_limit  didschedulerenderphaseupdate  render  render usereducer  render \n\nrenderwithhooks  f\n\nmount   fc  f  log children   fc  f  log children   fc   togglelight ()   dispatchaction  didschedulerenderphaseupdate  true   fc  render-in-render    fc   togglelight ()   dispatchaction ...  render-in-render    24  24  numberofrerenders  ( dev  resethooks  didschedulerenderphaseupdate )     re_render_limit    fc children\n\n\n# usestate \n\n dispatcher  mountupdate  contextonly  hook  dispatcher \n\n usestate \n\n\n# mountstate\n\n hooksdispatcheronmount  mountstate  mountstate \n\nfunction mountstate < s > (\n    initialstate: (() => s) | s,\n): [s, dispatch < basicstateaction < s >> ] {\n    // hook  hook  hook\n    const hook = mountworkinprogresshook();\n    //  initialstate \n    if (typeof initialstate === 'function') {\n        initialstate = initialstate();\n    }\n    // memoizedstatebasestate memoizedstate basestate \n    hook.memoizedstate = hook.basestate = initialstate;\n    //  hook \n    //  hook \n    const queue = (hook.queue = {\n        last: null,\n        dispatch: null,\n        lastrenderedreducer: basicstatereducer,\n        lastrenderedstate: (initialstate: any),\n    });\n    //  setstate  setstate  dispatchaction\n    const dispatch: dispatch <\n        basicstateaction < s > , >\n        = (queue.dispatch = (dispatchaction.bind(\n            null,\n            // flow doesn't know this is non-null, but we do.\n            ((currentlyrenderingfiber: any): fiber),\n            queue,\n        ): any));\n    return [hook.memoizedstate, dispatch];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n\n 1. usestate  mount  hook.basestate  dispatch setstate lastrenderedstate statelastrenderedreducer reduce  reducer \n 2.  setstate  dispatchaction dispatchaction  currentlyrenderingfiber fiberqueue\n 3. queue  hook  hook  dispatchaction  map (queue, linkedlist)  hook \n\n\n# dispatchaction\n\n setstate  dispatchaction \n\nfunction dispatchaction < s, a > (\n        fiber: fiber, //  fiber\n        queue: updatequeue < s, a > , // \n        action: a,\n    ) {\n        //  25 \n        invariant(\n            numberofrerenders < re_render_limit,\n            'too many re-renders. react limits the number of renders to prevent ' +\n            'an infinite loop.',\n        );\n\n        const alternate = fiber.alternate;\n        if (\n            fiber === currentlyrenderingfiber ||\n            (alternate !== null && alternate === currentlyrenderingfiber)\n        ) { //  fiber currentlyrenderingfiber  fiber\n            // this is a render phase update. stash it in a lazily-created map of\n            // queue -> linked list of updates. after this render pass, we'll restart\n            // and apply the stashed updates on top of the work-in-progress hook.\n            //  updates  map  queue -> linked list\n            // \n            didschedulerenderphaseupdate = true;\n            // \n            const update: update < s, a > = {\n                expirationtime: renderexpirationtime, // \n                suspenseconfig: null,\n                action, // dispatchaction  updatestate \n                eagerreducer: null,\n                eagerstate: null,\n                next: null,\n            };\n            if (__dev__) {\n                // \n                update.priority = getcurrentprioritylevel();\n                // renderphaseupdates  update queue map\n                if (renderphaseupdates === null) {\n                    renderphaseupdates = new map();\n                }\n                //  hook  update \n                const firstrenderphaseupdate = renderphaseupdates.get(queue);\n                //  queue  update update \n                if (firstrenderphaseupdate === undefined) {\n                    renderphaseupdates.set(queue, update);\n                } else {\n                    //  hook  update  update  linkedlink \n                    // append the update to the end of the list.\n                    let lastrenderphaseupdate = firstrenderphaseupdate;\n                    while (lastrenderphaseupdate.next !== null) {\n                        lastrenderphaseupdate = lastrenderphaseupdate.next;\n                    }\n                    lastrenderphaseupdate.next = update;\n                }\n            } else {\n                // prod  \n                const currenttime = requestcurrenttime();\n                const suspenseconfig = requestcurrentsuspenseconfig();\n                //  fiber \n                const expirationtime = computeexpirationforfiber(\n                    currenttime,\n                    fiber,\n                    suspenseconfig,\n                );\n                //  update \n                const update: update < s, a > = {\n                    expirationtime, //  fiber \n                    suspenseconfig, \n                    action, // dispatchaction \n                    eagerreducer: null, //  reducer queue.lastrenderedreducer\n                    eagerstate: null, //  state \n                    next: null,\n                };\n\n                if (__dev__) {\n                    update.priority = getcurrentprioritylevel();\n                }\n                // update \n                // append the update to the end of the list.\n                // \n                const last = queue.last;\n                if (last === null) {\n                    //  update  hook  update \n                    // \n                    //  mount  mount  queue\n                    // this is the first update. create a circular list.\n                    update.next = update;\n                } else {\n                    // \n                    //  next  first\n                    const first = last.next;\n                    // \n                    if (first !== null) {\n                        //  update \n                        //  update  next  first\n                        // still circular.\n                        update.next = first;\n                    }\n                    //  update \n                    last.next = update;\n                }\n                //  update\n                queue.last = update;\n                \n                //  fiber  expirationtime  state\n                //  state  return  schedulework \n                //  state   state  update \n                //  const eagerstate = lastrenderedreducer(currentstate, action) \n                if ( \n                    fiber.expirationtime === nowork &&\n                    (alternate === null || alternate.expirationtime === nowork)\n                ) {\n                    // the queue is currently empty, which means we can eagerly compute the\n                    // next state before entering the render phase. if the new state is the\n                    // same as the current state, we may be able to bail out entirely.\n                    const lastrenderedreducer = queue.lastrenderedreducer;\n                    if (lastrenderedreducer !== null) {\n                        let prevdispatcher;\n                        try {\n                            const currentstate: s = (queue.lastrenderedstate: any);\n                            const eagerstate = lastrenderedreducer(currentstate, action);\n                            // stash the eagerly computed state, and the reducer used to compute\n                            // it, on the update object. if the reducer hasn't changed by the\n                            // time we enter the render phase, then the eager state can be used\n                            // without calling the reducer again.\n                            update.eagerreducer = lastrenderedreducer;\n                            update.eagerstate = eagerstate;\n                            if (is(eagerstate, currentstate)) {\n                                // fast path. we can bail out without scheduling react to re-render.\n                                // it's still possible that we'll need to rebase this update later,\n                                // if the component re-renders for a different reason and by that\n                                // time the reducer has changed.\n                                return;\n                            }\n                        } catch (error) {\n                            // suppress the error. it will throw again in the render phase.\n                        } finally {\n                            if (__dev__) {\n                                reactcurrentdispatcher.current = prevdispatcher;\n                            }\n                        }\n                    }\n                }\n\n                //  fiber \n                schedulework(fiber, expirationtime);\n            }\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n\n\n\n\n * hook  update  dispatchaction   render \n * hook  dev  prod  dev  renderphaseupdates map (queue,  linkedlist)  prod  renderphaseupdates map (queue,  linkedlist) \n *  hook  queue  hook queue  last  updatequeue  renderphaseupdates  update \n * update  update \n\n dispatchaction \n\n * dispatchaction  map<queue, linked list> update \n * schedulework (fiber, expirationtime)  fiber \n * react update \n\n\n\n update \n\nupdate \n\nupdate  queue.last  last  update  dispatchaction \n\n *  hook  update  schedulework  () \n *  update  state eagerstate\n * schedulework \n\n\n\n 1. \n\n * \n * react  update  update \n * \n\n\n\n *  - 2 - \n\n\n# updatestate\n\n render hooksdispatcheronupdate  dispatcher  updatestate \n\n\n\nfunction updatestate<s>(\n  initialstate: (() => s) | s,\n): [s, dispatch<basicstateaction<s>>] {\n  return updatereducer(basicstatereducer, (initialstate: any));\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n\n * updatestate  updatereducer  usereducer  update  updatereducer\n * updatereducer  reducer  initialstate state  dispatch  usereducer  usereducer  usestate \n * usestate  reducer  basicstatereducer\n\n#  reducer  basicstatereducer\n\nfunction reducer(state, action): state {}\n\n\n1\n\n\nreducer  state   state  action state\n\nfunction basicstatereducer<s>(state: s, action: basicstateaction<s>): s {\n  return typeof action === 'function' ? action(state) : action;\n}\n\n\n1\n2\n3\n\n\nbasicstatereducer  action  action  usestate  dispatch usestate  basicstatereducer\n\n updatereducer  usereducer \n\n\n# updatereducer\n\n updatereducer \n\nfunction updatereducer<s, i, a>(\n  reducer: (s, a) => s,\n  initialarg: i,\n  init?: i => s,\n): [s, dispatch<a>] {\n  //  hook\n  const hook = updateworkinprogresshook();\n  // queue  hook queue  queue  update \n  // usestate mount  update last \n  const queue = hook.queue;\n  invariant(\n    queue !== null,\n    'should have a queue. this is likely a bug in react. please file an issue.',\n  );\n\n  //  reducer  queue \n  queue.lastrenderedreducer = reducer;\n  //  hook  render \n  if (numberofrerenders > 0) {\n    // this is a re-render. apply the new render phase updates to the previous\n    // work-in-progress hook.\n    //  dispatch  setstate  queue  mount \n    //  dispatch mount \n    const dispatch: dispatch<a> = (queue.dispatch: any);\n    // renderphaseupdates   map<updatequeue,update linked list>\n    // \n    if (renderphaseupdates !== null) {\n      // render phase updates are stored in a map of queue -> linked list\n      //  hook \n      const firstrenderphaseupdate = renderphaseupdates.get(queue);\n      //  reduce \n      // firstrenderphaseupdate \n      if (firstrenderphaseupdate !== undefined) {\n        //  reduce  queue \n        //  queue  queue  update  firstrenderphaseupdate\n        //  queue  firstrenderphaseupdate  firstrenderphaseupdate map  queue \n        //  queue \n        renderphaseupdates.delete(queue);\n        // state reduce  memoizedstate \n        let newstate = hook.memoizedstate;\n        let update = firstrenderphaseupdate;\n        // usestate update  queue queue \n        //  update batch update re-render\n        // \n        // reduce\n        do {\n          // process this render phase update. we don't have to check the\n          // priority because it will always be the same as the current\n          // render's.\n          // \n          //  update  action , update \n          // setstate  action  basicstateaction\n          const action = update.action;\n          // reducer \n          newstate = reducer(newstate, action);\n          //  update\n          update = update.next;\n        } while (update !== null);\n\n        // mark that the fiber performed work, but only if the new state is\n        // different from the current state.\n        //  newstate  memoizedstate  didreceiveupdate  true\n        //  fiber \n        if (!is(newstate, hook.memoizedstate)) {\n          markworkinprogressreceivedupdate();\n        }\n        //  memoizedstate render\n        hook.memoizedstate = newstate;\n        // don't persist the state accumulated from the render phase updates to\n        // the base state unless the queue is empty.\n        // todo: not sure if this is the desired semantics, but it's what we\n        // do for gdsfp. i can't remember why.\n        // \n        if (hook.baseupdate === queue.last) {\n          hook.basestate = newstate;\n        }\n        // lastrenderedstate  state render  newstate\n        queue.lastrenderedstate = newstate;\n        //  render  newstate  dispatch dispatch  queue  dispatchaction \n        return [newstate, dispatch];\n      }\n    }\n    //  render memoizedstate\n    return [hook.memoizedstate, dispatch];\n  }\n  \n  // hook  render, render \n  // the last update in the entire queue\n  const last = queue.last;\n  // the last update that is part of the base state.\n  const baseupdate = hook.baseupdate;\n  const basestate = hook.basestate;\n\n  // find the first unprocessed update.\n  let first;\n  // baseupdate \n  if (baseupdate !== null) {\n    if (last !== null) {\n      // for the first update, the queue is a circular linked list where\n      // `queue.last.next = queue.first`. once the first update commits, and\n      // the `baseupdate` is no longer empty, we can unravel the list.\n      //  updatequeue.last.next = queue.first,  update update  commit\n      // \n      last.next = null;\n    }\n    //  baseupdate.next\n    first = baseupdate.next;\n  } else {\n    //  last.next\n    first = last !== null ? last.next : null;\n  }\n  if (first !== null) {\n    // reduce \n    let newstate = basestate;\n    let newbasestate = null;\n    let newbaseupdate = null;\n    let prevupdate = baseupdate;\n    let update = first;\n    let didskip = false;\n    //  reduce \n    do {\n      const updateexpirationtime = update.expirationtime;\n      //  update  renderexpirationtime, expirationtime \n      // renderexpirationtime = 0\n      if (updateexpirationtime < renderexpirationtime) {\n        // priority is insufficient. skip this update. if this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        //  update, newbaseupdate newbasestate\n        // \n        if (!didskip) {\n          didskip = true;\n          newbaseupdate = prevupdate;\n          newbasestate = newstate;\n        }\n        // remainingexpirationtime  update  renderexpirationtime\n        // \n        // update the remaining priority in the queue.\n        if (updateexpirationtime > remainingexpirationtime) {\n          remainingexpirationtime = updateexpirationtime;\n          markunprocessedupdatetime(remainingexpirationtime);\n        }\n      //  update \n      } else {\n        // this update does have sufficient priority.\n\n        // mark the event time of this update as relevant to this render pass.\n        // todo: this should ideally use the true event time of this update rather than\n        // its priority which is a derived and not reverseable value.\n        // todo: we should skip this update if it was already committed but currently\n        // we have no way of detecting the difference between a committed and suspended\n        // update here.\n        markrendereventtimeandconfig(\n          updateexpirationtime,\n          update.suspenseconfig,\n        );\n\n        // process this update.\n        // eagerreducer   reducer \n        if (update.eagerreducer === reducer) {\n          // if this update was processed eagerly, and its reducer matches the\n          // current reducer, we can use the eagerly computed state.\n          //  reducer,  reducer \n          newstate = ((update.eagerstate: any): s);\n        } else {\n          // reduce \n          const action = update.action;\n          newstate = reducer(newstate, action);\n        }\n      }\n      // \n      prevupdate = update;\n      //  update\n      update = update.next;\n      // first \n    } while (update !== null && update !== first);\n\n    //  updatenewbaseupdate  update update\n    if (!didskip) {\n      newbaseupdate = prevupdate;\n      newbasestate = newstate;\n    }\n\n    // mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n    // didreceiveupdate  true  fiber\n    if (!is(newstate, hook.memoizedstate)) {\n      markworkinprogressreceivedupdate();\n    }\n\n    hook.memoizedstate = newstate;\n    hook.baseupdate = newbaseupdate;\n    hook.basestate = newbasestate;\n\n    queue.lastrenderedstate = newstate;\n  }\n\n  const dispatch: dispatch<a> = (queue.dispatch: any);\n  return [hook.memoizedstate, dispatch];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n\n\n\n\n * updatereducer  updates  state \n * queue  hook queue \n\n                    \nlastrenderedreducer    reduce  reducer\ndispatch               dispatchaction\nlast                   update queue  update \nlastrenderedstate     \n\n * dispatch  reducer \n\nfunction dispatch(state || () => state): void //  action\nfunction reducer(state, action): state // \n\n\n1\n2\n\n\n * numberofrerenders  renderwithhooks  renderwithhooks  re-render renderwithhooks  react-reconciler  reactfiberbeginwork.js  fc  numberofrerenders  finishhooks  resethooks  numberofrerenders  0 hook finish renderwithhooks \n\n * renderexpirationtime  nowork = 0  updateexpirationtime  0  remainingexpirationtimeremainingexpirationtime \n\n * updatereducer \n\n\n\n *  hook  mount  updatestate  update  update  reducereduce  newstate \n * resethooks   performsyncworkonroot/performconcurrentworkonroot  handleerror  react  hook \n * batched updates\n\n hook  queue  react  dispatchaction  dispatchaction  reduce updates  reduce update  renderwithhooks  dispatchaction  render \n\ndo {\n  newstate = reducer(newstate, action);\n  update = update.next;\n} while (update !== null);\n\n\n1\n2\n3\n4\n\n\n\n# \n\n\n\n\n# usestate  ui \n\n newstate  newstate  hook.memoizedstate  hook.memoizedstate  rerender  didreceiveupdate  true ui  render didreceiveupdate  react-reconciler  reactfiberbeginwork.js usestate  didreceiveupdate ui  setstate  dispatchaction  schedulework \n\n\n# renderphaseupdates \n\n renderphaseupdates  renderphaseupdates \n\nlet renderphaseupdates: map<\n  updatequeue<any, any>,\n  update<any, any>,\n> | null = null;\n\n\n1\n2\n3\n4\n\n\ndispatchaction \n\nif (renderphaseupdates === null) {\n  renderphaseupdates = new map();\n}\nconst firstrenderphaseupdate = renderphaseupdates.get(queue);\nif (firstrenderphaseupdate === undefined) {\n  renderphaseupdates.set(queue, update);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nupdatereducer \n\nif (renderphaseupdates !== null) {\n  const firstrenderphaseupdate = renderphaseupdates.get(queue);\n  if (firstrenderphaseupdate !== undefined) {\n    renderphaseupdates.delete(queue);\n    ...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * renderphaseupdates  map dispatchaction  setstate  map usestate  map  queuequeue last  update\n *  resethooks  null updatereducer  queue \n\n\n#  setstate \n\n setstate  queue  queue  update  schedulework  fiber  updatereducer  newstate newstate updatereducer  newstate  reducer usestate  reducer  basicstatereducer basicstatereducer  setstate setstate  setstate  merge  setstate \n\nbasicstatereducer\n\nfunction basicstatereducer<s>(state: s, action: basicstateaction<s>): s {\n  return typeof action === 'function' ? action(state) : action;\n}\n\n\n1\n2\n3\n\n\nusemergedstate\n\nexport function usemergedstate<t>(initialstate: t) {\n  const [state, setstate] = usestate<t>(initialstate);\n  let mergestate: any = setstate;\n  if (typeof state === 'object') {\n    mergestate = (value: t) => {\n      if (value && typeof value === 'object') {\n        setstate({\n          ...state,\n          ...value,\n        });\n      } else {\n        setstate(value);\n      }\n    };\n  }\n  return [state, setstate, mergestate];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n#  batch update  update?\n\n *  update  dispatchaction dispatchaction  update  queue  update\n * update  dispatchaction  reduce update  fiber \n *  fiber  queue  update  update  fiber  update \n\n\n# \n\n dispatcher mountstatedispatchactionupdatestate \n\n 1. \n\n * dispatcher hook\n * mountstate hook  queuemount  update\n * dispatchaction update update update \n * updatestateupdatereducer update fiber  state\n\n 2. \n\n *  hook api  dispatcher  dispatcher dev  dev  dispatcher\n * mount  mountstate  state  queue  dispatchaction  renderphaseupdates dispatchaction \n * render  updatestate  reducer  state  dispatch\n *  setstate  dispatchaction dispatchaction  update  schedulework  fiber\n\n\n# \n\n * \n * react hooks ",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"useEffect",frontmatter:{title:"useEffect",date:"2022-04-14T22:02:21.000Z",permalink:"/react/hooks/useEffect/",categories:["react","hooks"],tags:[null]},regularPath:"/10.react/70.hooks%E5%8E%9F%E7%90%86/20.useEffect.html",relativePath:"10.react/70.hooks/20.useEffect.md",key:"v-228419df",path:"/react/hooks/useEffect/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:2,title:"mount  useEffect",slug:"mount--useeffect",normalizedTitle:"mount  useeffect",charIndex:23},{level:2,title:"update  useEffect",slug:"update--useeffect",normalizedTitle:"update  useeffect",charIndex:46},{level:3,title:"effect deps ",slug:"effect-deps-",normalizedTitle:"effect deps ",charIndex:72},{level:2,title:"useEffect  mount ",slug:"useeffect--mount-",normalizedTitle:"useeffect  mount ",charIndex:95},{level:2,title:"useEffect ",slug:"useeffect-",normalizedTitle:"useeffect ",charIndex:125},{level:2,title:"useEffect  lifecycle Api?",slug:"useeffect--lifecycle-api",normalizedTitle:"useeffect  lifecycle api?",charIndex:143},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:179}],readingTime:{text:"3 min read",minutes:2.61,time:156600,words:522},headersStr:"  mount  useEffect update  useEffect effect deps  useEffect  mount  useEffect  useEffect  lifecycle Api? ",content:"# \n\n\n\n * \n * \n * mount  useEffect\n * update  useEffect\n   * effect deps \n * useEffect  mount \n * useEffect \n * useEffect  lifecycle Api?\n * \n\n\n\n> useEffect  hooks  lifecycle ApiuseEffect   useEffect \n\n\n# \n\n react  ReactHooks.js  useEffect \n\nexport function useEffect(\n  create: () => (() => void) | void,\n  inputs: Array<mixed> | void | null,\n) {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, inputs);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n * useEffect  dispatcher \n * create  cleaner\n * inputs  propsstate \n\n\n# mount  useEffect\n\nuseEffect  HooksDispatcherOnMount  mountEffect  mountEffectImpl \n\nfunction mountEffectImpl(fiberEffectTag, hookEffectTag, create, deps): void {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  sideEffectTag |= fiberEffectTag;\n  // pushEffect  effect effect  hook.memoizedState \n  hook.memoizedState = pushEffect(hookEffectTag, create, undefined, nextDeps);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\npushEffect  effect  effect \n\nfunction pushEffect(tag, create, destroy, deps) {\n  //  effect  mount  next null.\n  const effect: Effect = {\n    tag,\n    create,\n    destroy,\n    deps,\n    // Circular\n    next: (null: any),\n  };\n  if (componentUpdateQueue === null) {\n    //  lastEffect\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    //  effect\n    componentUpdateQueue.lastEffect = effect.next = effect;\n  } else {\n    const lastEffect = componentUpdateQueue.lastEffect;\n    if (lastEffect === null) {\n      componentUpdateQueue.lastEffect = effect.next = effect;\n    } else {\n      //  firstEffect  effecteffect  firstEffect effect \n      const firstEffect = lastEffect.next;\n      lastEffect.next = effect;\n      effect.next = firstEffect;\n      componentUpdateQueue.lastEffect = effect;\n    }\n  }\n  return effect;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n\n * effect  componentUpdateQueue lastEffect  effect\n * Effect  effect \n * pushEffect  effect mount  pushEffect  useEffect  mount \n\n\n# update  useEffect\n\nupdate  useEffect  updateEffect  updateEffectImpl \n\nfunction updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps): void {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  let destroy = undefined;\n\n  if (currentHook !== null) {\n    //  effect\n    const prevEffect = currentHook.memoizedState;\n    destroy = prevEffect.destroy;\n    //  prevDeps  nextDeps  Effect \n    if (nextDeps !== null) {\n      const prevDeps = prevEffect.deps;\n      //  effect  effect  Effect tag  NoHookEffect\n      //  tag  NoHookEffect  effect \n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        pushEffect(NoHookEffect, create, destroy, nextDeps);\n        return;\n      }\n    }\n  }\n  //  effect\n  sideEffectTag |= fiberEffectTag;\n  hook.memoizedState = pushEffect(hookEffectTag, create, destroy, nextDeps);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# effect deps \n\nareHookInputsEqual \n\nfunction areHookInputsEqual(\n  nextDeps: Array<mixed>,\n  prevDeps: Array<mixed> | null,\n) {\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (is(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\nfunction is(x: any, y: any) {\n  //  null \n  return (\n    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n\n * areHookInputsEqual \n *  Object  useEffect  state useState  effect\n\n\n# useEffect  mount \n\n useEffect  effect  effect  effect effect   useEffect  mount \n\nconst didMount = useRef<boolean>(false);\n\nuseEffect(() => didMount.current = true, []);\n\nuseEffect(() => {\n  if(didMount.current) {\n    // Only run after mounted.\n  }\n}, [deps]);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# useEffect \n\neffect  effect effect  mount  update \n\n\n# useEffect  lifecycle Api?\n\n\n# \n\n * ",normalizedContent:"# \n\n\n\n * \n * \n * mount  useeffect\n * update  useeffect\n   * effect deps \n * useeffect  mount \n * useeffect \n * useeffect  lifecycle api?\n * \n\n\n\n> useeffect  hooks  lifecycle apiuseeffect   useeffect \n\n\n# \n\n react  reacthooks.js  useeffect \n\nexport function useeffect(\n  create: () => (() => void) | void,\n  inputs: array<mixed> | void | null,\n) {\n  const dispatcher = resolvedispatcher();\n  return dispatcher.useeffect(create, inputs);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n * useeffect  dispatcher \n * create  cleaner\n * inputs  propsstate \n\n\n# mount  useeffect\n\nuseeffect  hooksdispatcheronmount  mounteffect  mounteffectimpl \n\nfunction mounteffectimpl(fibereffecttag, hookeffecttag, create, deps): void {\n  const hook = mountworkinprogresshook();\n  const nextdeps = deps === undefined ? null : deps;\n  sideeffecttag |= fibereffecttag;\n  // pusheffect  effect effect  hook.memoizedstate \n  hook.memoizedstate = pusheffect(hookeffecttag, create, undefined, nextdeps);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\npusheffect  effect  effect \n\nfunction pusheffect(tag, create, destroy, deps) {\n  //  effect  mount  next null.\n  const effect: effect = {\n    tag,\n    create,\n    destroy,\n    deps,\n    // circular\n    next: (null: any),\n  };\n  if (componentupdatequeue === null) {\n    //  lasteffect\n    componentupdatequeue = createfunctioncomponentupdatequeue();\n    //  effect\n    componentupdatequeue.lasteffect = effect.next = effect;\n  } else {\n    const lasteffect = componentupdatequeue.lasteffect;\n    if (lasteffect === null) {\n      componentupdatequeue.lasteffect = effect.next = effect;\n    } else {\n      //  firsteffect  effecteffect  firsteffect effect \n      const firsteffect = lasteffect.next;\n      lasteffect.next = effect;\n      effect.next = firsteffect;\n      componentupdatequeue.lasteffect = effect;\n    }\n  }\n  return effect;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n\n * effect  componentupdatequeue lasteffect  effect\n * effect  effect \n * pusheffect  effect mount  pusheffect  useeffect  mount \n\n\n# update  useeffect\n\nupdate  useeffect  updateeffect  updateeffectimpl \n\nfunction updateeffectimpl(fibereffecttag, hookeffecttag, create, deps): void {\n  const hook = updateworkinprogresshook();\n  const nextdeps = deps === undefined ? null : deps;\n  let destroy = undefined;\n\n  if (currenthook !== null) {\n    //  effect\n    const preveffect = currenthook.memoizedstate;\n    destroy = preveffect.destroy;\n    //  prevdeps  nextdeps  effect \n    if (nextdeps !== null) {\n      const prevdeps = preveffect.deps;\n      //  effect  effect  effect tag  nohookeffect\n      //  tag  nohookeffect  effect \n      if (arehookinputsequal(nextdeps, prevdeps)) {\n        pusheffect(nohookeffect, create, destroy, nextdeps);\n        return;\n      }\n    }\n  }\n  //  effect\n  sideeffecttag |= fibereffecttag;\n  hook.memoizedstate = pusheffect(hookeffecttag, create, destroy, nextdeps);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# effect deps \n\narehookinputsequal \n\nfunction arehookinputsequal(\n  nextdeps: array<mixed>,\n  prevdeps: array<mixed> | null,\n) {\n  for (let i = 0; i < prevdeps.length && i < nextdeps.length; i++) {\n    if (is(nextdeps[i], prevdeps[i])) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\nfunction is(x: any, y: any) {\n  //  null \n  return (\n    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n\n * arehookinputsequal \n *  object  useeffect  state usestate  effect\n\n\n# useeffect  mount \n\n useeffect  effect  effect  effect effect   useeffect  mount \n\nconst didmount = useref<boolean>(false);\n\nuseeffect(() => didmount.current = true, []);\n\nuseeffect(() => {\n  if(didmount.current) {\n    // only run after mounted.\n  }\n}, [deps]);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# useeffect \n\neffect  effect effect  mount  update \n\n\n# useeffect  lifecycle api?\n\n\n# \n\n * ",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"useRef ",frontmatter:{title:"useRef ",date:"2022-04-14T22:02:21.000Z",permalink:"/react/hooks/useRef/",categories:["react","hooks"],tags:[null]},regularPath:"/10.react/70.hooks%E5%8E%9F%E7%90%86/30.useRef.html",relativePath:"10.react/70.hooks/30.useRef.md",key:"v-2778a33b",path:"/react/hooks/useRef/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"useRef ",slug:"useref-",normalizedTitle:"useref ",charIndex:17},{level:2,title:"mountRef: useRef on mount phrase",slug:"mountref-useref-on-mount-phrase",normalizedTitle:"mountref: useref on mount phrase",charIndex:30},{level:2,title:"updateRef: useRef on update phrase",slug:"updateref-useref-on-update-phrase",normalizedTitle:"updateref: useref on update phrase",charIndex:66},{level:2,title:"Q&A",slug:"q-a",normalizedTitle:"q&amp;a",charIndex:null},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:111}],readingTime:{text:"3 min read",minutes:2.16,time:129600.00000000003,words:432},headersStr:" useRef  mountRef: useRef on mount phrase updateRef: useRef on update phrase Q&A ",content:"# \n\n\n\n * \n * useRef \n * mountRef: useRef on mount phrase\n * updateRef: useRef on update phrase\n * Q&A\n * \n\n\n\n\n# useRef \n\n useRef  React  (react package)\n\nexport function useRef<T>(initialValue: T): {current: T} {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\n\n\n1\n2\n3\n4\n\n\n\n\n *  initialValue current \n * useRef  dispatcher \n\n useRef  dispatcher \n\n HooksDispatcherOnMount  useRef  mountRef HooksDispatcherOnUpdate  useRef  updateRef hook \n\n\n# mountRef: useRef on mount phrase\n\nmountRef \n\nfunction mountRef<T>(initialValue: T): {current: T} {\n  //  hook\n  const hook = mountWorkInProgressHook();\n  const ref = {current: initialValue};\n  if (__DEV__) {\n    Object.seal(ref);\n  }\n  //  current  hook\n  hook.memoizedState = ref;\n  return ref;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# updateRef: useRef on update phrase\n\n memoizedState \n\nfunction updateRef<T>(initialValue: T): {current: T} {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n\n\n1\n2\n3\n4\n\n\n\n# Q&A\n\n\n\n 1.  useRef  render \n\nuseRef  useState useState  useState \n\n useState  primitive value  object  object  object  primitive value \n\n\n\nfunction App(){\n    const [count, setCount] = useState(1);\n    useEffect(()=>{\n        setInterval(()=>{\n            console.log(count)\n        }, 1000)\n    }, [])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n setCount  count  1\n\n mount  useState  count  1 useEffect useEffect  [] mount  setCountcount count  count  1 count  count  setCount  Object.merge  count \n\n\n\n> Closures from MDN:\n> \n> A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer functions scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time.\n> \n> lexical environmentclosure JavaScript \n\n\n\nuseRef  object  useRef  React  {current: value}  current  current  current  current  current \n\n useRefuseRef  FC React  FC  render  renderWithHook  children = Component(props, refOrContext);  React  render  React  FC  render  render \n\n\n\nuseRef \n\n 1. useRef  re-render;\n 2. useRef  useRef \n\n\n\n 2.  {current: value}  vue3  ref () \n\n useRef  primitive value  current \n\n vue3  ref  .value  Proxy API  object  getset  ref  Proxy ref  class  ref  get  set  ref  ref  ref.value  getset  value  get  track set  trigger React  useRefvue3  ref  .value  track  trigger \n\n\n# \n\n *  react hooks   react hooks",normalizedContent:"# \n\n\n\n * \n * useref \n * mountref: useref on mount phrase\n * updateref: useref on update phrase\n * q&a\n * \n\n\n\n\n# useref \n\n useref  react  (react package)\n\nexport function useref<t>(initialvalue: t): {current: t} {\n  const dispatcher = resolvedispatcher();\n  return dispatcher.useref(initialvalue);\n}\n\n\n1\n2\n3\n4\n\n\n\n\n *  initialvalue current \n * useref  dispatcher \n\n useref  dispatcher \n\n hooksdispatcheronmount  useref  mountref hooksdispatcheronupdate  useref  updateref hook \n\n\n# mountref: useref on mount phrase\n\nmountref \n\nfunction mountref<t>(initialvalue: t): {current: t} {\n  //  hook\n  const hook = mountworkinprogresshook();\n  const ref = {current: initialvalue};\n  if (__dev__) {\n    object.seal(ref);\n  }\n  //  current  hook\n  hook.memoizedstate = ref;\n  return ref;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# updateref: useref on update phrase\n\n memoizedstate \n\nfunction updateref<t>(initialvalue: t): {current: t} {\n  const hook = updateworkinprogresshook();\n  return hook.memoizedstate;\n}\n\n\n1\n2\n3\n4\n\n\n\n# q&a\n\n\n\n 1.  useref  render \n\nuseref  usestate usestate  usestate \n\n usestate  primitive value  object  object  object  primitive value \n\n\n\nfunction app(){\n    const [count, setcount] = usestate(1);\n    useeffect(()=>{\n        setinterval(()=>{\n            console.log(count)\n        }, 1000)\n    }, [])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n setcount  count  1\n\n mount  usestate  count  1 useeffect useeffect  [] mount  setcountcount count  count  1 count  count  setcount  object.merge  count \n\n\n\n> closures from mdn:\n> \n> a closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). in other words, a closure gives you access to an outer functions scope from an inner function. in javascript, closures are created every time a function is created, at function creation time.\n> \n> lexical environmentclosure javascript \n\n\n\nuseref  object  useref  react  {current: value}  current  current  current  current  current \n\n userefuseref  fc react  fc  render  renderwithhook  children = component(props, reforcontext);  react  render  react  fc  render  render \n\n\n\nuseref \n\n 1. useref  re-render;\n 2. useref  useref \n\n\n\n 2.  {current: value}  vue3  ref () \n\n useref  primitive value  current \n\n vue3  ref  .value  proxy api  object  getset  ref  proxy ref  class  ref  get  set  ref  ref  ref.value  getset  value  get  track set  trigger react  userefvue3  ref  .value  track  trigger \n\n\n# \n\n *  react hooks   react hooks",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/react/summary/index/",categories:["react","summary"],tags:[null]},regularPath:"/10.react/80.%E6%80%BB%E7%BB%93/0.index.html",relativePath:"10.react/80./0.index.md",key:"v-230de106",path:"/react/summary/index/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"React ",slug:"react-",normalizedTitle:"react ",charIndex:17},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:23},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:40},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:48}],readingTime:{text:"1 min read",minutes:.885,time:53100,words:177},headersStr:" React    ",content:"# \n\n\n\n * \n * React \n * \n * \n * \n\n\n\n\n# React \n\n react  4 \n\n\n# \n\nreact \n\n * react react  api  react-domreact-native\n * react-domreact  web  react-reconciler  VNodeTree  DOM Tree render  VNode (jsx -> babel -> createElement -> ReactElement )  DOM Node \n * react-reconciler\n   *  reactreact-domscheduler \n   *  react \n   *  react  react-dom \n   * \n * scheduler\n   * \n   * \n   * \n\n\n# \n\n *  react  API react  react-dom  API ReactElementReactChildrenComponent APIHooks APIRender API \n\n * \n   \n   * Reconciler\n   * Scheduler\n   * Updater\n   * Render\n\n\n# \n\n 1. Reconciler\n\n react \n\n * react-dom react \n * \n *  react  react \n *  VNodeTree  DOM Treessr:  UI \n\n 2. Scheduler\n\n\n\n * \n * \n * \n\n 3. Updater\n\n react \n\n * \n *  diff \n\n 4. Render\n\n VNodeTree  DOMTree  UI \n\n *  react ReactDOM.render  commitRoot  VNode \n *  HostConfig  FiberTree  DOMTree ",normalizedContent:"# \n\n\n\n * \n * react \n * \n * \n * \n\n\n\n\n# react \n\n react  4 \n\n\n# \n\nreact \n\n * react react  api  react-domreact-native\n * react-domreact  web  react-reconciler  vnodetree  dom tree render  vnode (jsx -> babel -> createelement -> reactelement )  dom node \n * react-reconciler\n   *  reactreact-domscheduler \n   *  react \n   *  react  react-dom \n   * \n * scheduler\n   * \n   * \n   * \n\n\n# \n\n *  react  api react  react-dom  api reactelementreactchildrencomponent apihooks apirender api \n\n * \n   \n   * reconciler\n   * scheduler\n   * updater\n   * render\n\n\n# \n\n 1. reconciler\n\n react \n\n * react-dom react \n * \n *  react  react \n *  vnodetree  dom treessr:  ui \n\n 2. scheduler\n\n\n\n * \n * \n * \n\n 3. updater\n\n react \n\n * \n *  diff \n\n 4. render\n\n vnodetree  domtree  ui \n\n *  react reactdom.render  commitroot  vnode \n *  hostconfig  fibertree  domtree ",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/react/summary/bitOperation/",categories:["react","summary"],tags:[null]},regularPath:"/10.react/80.%E6%80%BB%E7%BB%93/10.bitOperation.html",relativePath:"10.react/80./10.bitOperation.md",key:"v-1154a3c8",path:"/react/summary/bitOperation/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:25},{level:3,title:"(&)",slug:"",normalizedTitle:" (&amp;)",charIndex:null},{level:3,title:"(|)",slug:"",normalizedTitle:" (|)",charIndex:725},{level:3,title:"(^)",slug:"",normalizedTitle:" (^)",charIndex:868},{level:3,title:"(~)",slug:"",normalizedTitle:" (~)",charIndex:1082},{level:3,title:"<<",slug:"",normalizedTitle:"&lt;&lt;",charIndex:null},{level:3,title:">>",slug:"",normalizedTitle:"&gt;&gt;",charIndex:null},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:108}],readingTime:{text:"2 min read",minutes:1.12,time:67200,words:224},headersStr:"   (&) (|) (^) (~) << >> ",content:"# \n\n\n\n * \n * \n * \n   * (&)\n   * (|)\n   * (^)\n   * (~)\n   * <<\n   * >>\n * \n\n\n\n\n# \n\n      \n&         1  1\n|         0  0\n^        0 1\n~       0  11  0\n<<       0\n>>       0\n          0\n\n\n# \n\n\n#  (&)\n\n *  0  0.\n * 01  1  1 0 00001111\n *  0 1 (x&1)===0 (x&1)===1 \n * x & (x - 1)  x  1\n *  1 \n\nlet count = 0  \nwhile(a){  \n  a &= (a - 1);  //  1\n  count++;  \n}\n\n\n1\n2\n3\n4\n5\n\n\n\n#  (|)\n\n *  101  1  1 1  1 00001111  1\n *  1  (-4|1)=-3(4|1)=5\n\n\n#  (^)\n\n * 0/1  1  0  1 0  00001111 \n * \n\na ^= b;\nb ^= a;\na ^= b;\n\n\n1\n2\n3\n\n\n\n\na:0 b:1\na:1 b:1\na:1 b:0\na:1 b:0\n\n\n1\n2\n3\n4\n\n\n\n#  (~)\n\nx  -(x+1)\n\n * a=~a + 1\n * a=a>=0?a:~a+1\n\n\n# <<\n\n *  2\n\n\n# >>\n\n *  2\n *  0  31  0 31  - 1\n * 16  8  8 : a = (a>> 8) | (a << 8)\n\n\n# \n\n * ",normalizedContent:"# \n\n\n\n * \n * \n * \n   * (&)\n   * (|)\n   * (^)\n   * (~)\n   * <<\n   * >>\n * \n\n\n\n\n# \n\n      \n&         1  1\n|         0  0\n^        0 1\n~       0  11  0\n<<       0\n>>       0\n          0\n\n\n# \n\n\n#  (&)\n\n *  0  0.\n * 01  1  1 0 00001111\n *  0 1 (x&1)===0 (x&1)===1 \n * x & (x - 1)  x  1\n *  1 \n\nlet count = 0  \nwhile(a){  \n  a &= (a - 1);  //  1\n  count++;  \n}\n\n\n1\n2\n3\n4\n5\n\n\n\n#  (|)\n\n *  101  1  1 1  1 00001111  1\n *  1  (-4|1)=-3(4|1)=5\n\n\n#  (^)\n\n * 0/1  1  0  1 0  00001111 \n * \n\na ^= b;\nb ^= a;\na ^= b;\n\n\n1\n2\n3\n\n\n\n\na:0 b:1\na:1 b:1\na:1 b:0\na:1 b:0\n\n\n1\n2\n3\n4\n\n\n\n#  (~)\n\nx  -(x+1)\n\n * a=~a + 1\n * a=a>=0?a:~a+1\n\n\n# <<\n\n *  2\n\n\n# >>\n\n *  2\n *  0  31  0 31  - 1\n * 16  8  8 : a = (a>> 8) | (a << 8)\n\n\n# \n\n * ",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"React ",frontmatter:{title:"React ",date:"2022-04-14T22:02:21.000Z",permalink:"/react/summary/first-render/",categories:["react","summary"],tags:[null]},regularPath:"/10.react/80.%E6%80%BB%E7%BB%93/20.first-render.html",relativePath:"10.react/80./20.first-render.md",key:"v-35203ba8",path:"/react/summary/first-render/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"ReactDOM.render",slug:"reactdom-render",normalizedTitle:"reactdom.render",charIndex:17},{level:3,title:"jsxWithValidation",slug:"jsxwithvalidation",normalizedTitle:"jsxwithvalidation",charIndex:38},{level:3,title:"render",slug:"render",normalizedTitle:"render",charIndex:26},{level:2,title:"legacyRenderSubtreeIntoContainer",slug:"legacyrendersubtreeintocontainer",normalizedTitle:"legacyrendersubtreeintocontainer",charIndex:71},{level:4,title:"legacyCreateRootFromDOMContainer",slug:"legacycreaterootfromdomcontainer",normalizedTitle:"legacycreaterootfromdomcontainer",charIndex:9819},{level:4,title:"listenToAllSupportedEvents",slug:"listentoallsupportedevents",normalizedTitle:"listentoallsupportedevents",charIndex:12912},{level:2,title:"createFiberRoot",slug:"createfiberroot",normalizedTitle:"createfiberroot",charIndex:107},{level:2,title:"createHostRootFiber",slug:"createhostrootfiber",normalizedTitle:"createhostrootfiber",charIndex:126},{level:2,title:"flushSync",slug:"flushsync",normalizedTitle:"flushsync",charIndex:149},{level:3,title:"flushPassiveEffects",slug:"flushpassiveeffects",normalizedTitle:"flushpassiveeffects",charIndex:164},{level:3,title:"flushSyncCallbacks",slug:"flushsynccallbacks",normalizedTitle:"flushsynccallbacks",charIndex:189},{level:2,title:"updateContainer",slug:"updatecontainer",normalizedTitle:"updatecontainer",charIndex:211},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:230},{level:2,title:"Q&A",slug:"q-a",normalizedTitle:"q&amp;a",charIndex:null},{level:3,title:"executionContext ",slug:"executioncontext-",normalizedTitle:"executioncontext ",charIndex:245},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:273},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:290}],readingTime:{text:"24 min read",minutes:23.56,time:1413600,words:4712},headersStr:" ReactDOM.render jsxWithValidation render legacyRenderSubtreeIntoContainer legacyCreateRootFromDOMContainer listenToAllSupportedEvents createFiberRoot createHostRootFiber flushSync flushPassiveEffects flushSyncCallbacks updateContainer  Q&A executionContext   ",content:"# \n\n\n\n * \n * ReactDOM.render\n   * jsxWithValidation\n   * render\n * legacyRenderSubtreeIntoContainer\n * createFiberRoot\n * createHostRootFiber\n * flushSync\n   * flushPassiveEffects\n   * flushSyncCallbacks\n * updateContainer\n * \n * Q&A\n   * executionContext \n   * \n * \n\n\n\n\n\n *  dev \n\n\n# ReactDOM.render\n\n ReactDOM.render  React \n\n\n# jsxWithValidation\n\n <App />  jsx \n\n// src/react/fixtures/legacy-jsx-runtimes/react-17/cjs/react-jsx-dev-runtime.development.js\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      // pass \n      // \n    }\n\n    //  ReactElement \n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        // isStaticChildren  key \n        if (isStaticChildren) {\n          if (Array.isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (type === exports.Fragment) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n}\n// Local Stack\n// {\n//   \"props\": {},\n//   \"isStaticChildren\": false,\n//   \"source\": {\n//     \"fileName\": \"/Users/jonsam/Projects/update_in_github/react-source-reading/src/index.js\",\n//     \"lineNumber\": 9,\n//     \"columnNumber\": 5\n//   },\n//   \"validType\": true,\n//   \"element\": {\n//     \"key\": null,\n//     \"ref\": null,\n//     \"props\": {},\n//     \"_owner\": null,\n//     \"_store\": {}\n//   }\n// }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n Element \n\nfunction isValidElementType(type) {\n  //  string  function  Element FC\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n  //  type  Fragmentprofilersuspense \n  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {\n    return true;\n  }\n\n  //  $$typeof LAZYMEMOPROVIDERCONTEXTFORWARD_REF \n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\njsxDEV  ReactElement \n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    //  ReactElement  $$typeof \n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    //  function\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    //  _store  weakMap  element  weakMap  _store \n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n// Local Stack\n// {\n//   \"config\": {},\n//   \"source\": {\n//     \"fileName\": \"/Users/jonsam/Projects/update_in_github/react-source-reading/src/index.js\",\n//     \"lineNumber\": 9,\n//     \"columnNumber\": 5\n//   },\n//   \"props\": {},\n//   \"key\": null,\n//   \"ref\": null\n// }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n * ReactElement  ReactElement \n * ReactElement  $$typeof ReactElement  REACT_ELEMENT_TYPE type  function\n *  ReactElement  _store  weakMap \n\n\n# render\n\n// src/react/packages/react-dom/src/client/ReactDOMLegacy.js\nfunction render(\n  element: React$Element<any>,\n  container: Container,\n  callback: ?Function,\n){\n  if (!isValidContainerLegacy(container)) {\n    throw new Error('Target container is not a DOM element.');\n  }\n  return legacyRenderSubtreeIntoContainer(\n    null,\n    element,\n    container,\n    false,\n    callback,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nLocal Stack\n\n ReactElement  render  container legacyRenderSubtreeIntoContainer  subTree  container \n\n container \n\n// We only use it in places that are currently more relaxed.\nexport function isValidContainerLegacy(node: any): boolean {\n  //  node.nodeType  node \n  return !!(\n    node &&\n    (node.nodeType === ELEMENT_NODE ||\n      node.nodeType === DOCUMENT_NODE ||\n      node.nodeType === DOCUMENT_FRAGMENT_NODE ||\n      (node.nodeType === COMMENT_NODE &&\n        (node: any).nodeValue === ' react-mount-point-unstable '))\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nLocal Stack\n\n\n\nassignedSlot: null\nattributeStyleMap: StylePropertyMap {size: 0}\nattributes: NamedNodeMap {0: id, id: id, length: 1}\nautocapitalize: \"\"\nautofocus: false\nbaseURI: \"http://localhost:3001/\"\nchildElementCount: 0\nchildNodes: NodeList []\nchildren: HTMLCollection []\nclassList: DOMTokenList [value: '']\nclassName: \"\"\nclientHeight: 0\nclientLeft: 0\nclientTop: 0\nclientWidth: 1792\ncontentEditable: \"inherit\"\ndataset: DOMStringMap {}\ndir: \"\"\ndraggable: false\nelementTiming: \"\"\nenterKeyHint: \"\"\nfirstChild: null\nfirstElementChild: null\nhidden: false\nid: \"root\"\ninnerHTML: \"\"\ninnerText: \"\"\ninputMode: \"\"\nisConnected: true\nisContentEditable: false\nlang: \"\"\nlastChild: null\nlastElementChild: null\nlocalName: \"div\"\nnamespaceURI: \"http://www.w3.org/1999/xhtml\"\nnextElementSibling: null\nnextSibling: text\nnodeName: \"DIV\"\nnodeType: 1\nnodeValue: null\nnonce: \"\"\noffsetHeight: 0\noffsetLeft: 0\noffsetParent: body\noffsetTop: 0\noffsetWidth: 1792\nouterHTML: \"<div id=\\\"root\\\"></div>\"\nouterText: \"\"\nownerDocument: document\nparentElement: body\nparentNode: body\npart: DOMTokenList [value: '']\nprefix: null\npreviousElementSibling: noscript\npreviousSibling: text\nscrollHeight: 0\nscrollLeft: 0\nscrollTop: 0\nscrollWidth: 1792\nshadowRoot: null\nslot: \"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n nodeType: 1 ELEMENT_NODE\n\n\n# legacyRenderSubtreeIntoContainer\n\n// src/react/packages/react-dom/src/client/ReactDOMLegacy.js\nfunction legacyRenderSubtreeIntoContainer(\n  parentComponent: ?React$Component<any, any>,\n  children: ReactNodeList,\n  container: Container,\n  forceHydrate: boolean,\n  callback: ?Function,\n) {\n  //  RootContainer \n  // _reactRootContainer  container  FiberRoot \n  let root = container._reactRootContainer;\n  let fiberRoot: FiberRoot;\n  if (!root) {\n    // Initial mount\n    // RootContainer  legacyCreateRootFromDOMContainer  Root \n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(\n      container,\n      forceHydrate,\n    );\n    fiberRoot = root;\n    //  render  callback callback\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Initial mount should not be batched.\n    //  mount \n    flushSync(() => {\n      updateContainer(children, fiberRoot, parentComponent, callback);\n    });\n  } else {\n    fiberRoot = root;\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Update\n    updateContainer(children, fiberRoot, parentComponent, callback);\n  }\n  return getPublicRootInstance(fiberRoot);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\nLocal Stack\n\n\n\ncallback: undefined\nchildren: {$$typeof: Symbol(react.element), type: Symbol(react.strict_mode), key: null, ref: null, props: {}, }\ncontainer: div#root\nfiberRoot: undefined\nforceHydrate: false\noriginalCallback: undefined\nparentComponent: null\nroot: undefined\n_originalCallback: undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nrender  callback container FiberRoot \n\nexport function getPublicRootInstance(\n  container: OpaqueRoot,\n): React$Component<any, any> | PublicInstance | null {\n  const containerFiber = container.current;\n  if (!containerFiber.child) {\n    return null;\n  }\n  switch (containerFiber.child.tag) {\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n    default:\n      //  instance  Fiber.child.stateNode  RootFiber\n      return containerFiber.child.stateNode;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# legacyCreateRootFromDOMContainer\n\nRootContainer  container  legacyCreateRootFromDOMContainer \n\nfunction legacyCreateRootFromDOMContainer(\n  container: Container,\n  forceHydrate: boolean,\n): FiberRoot {\n  // First clear any existing content.\n  //  SSR container \n  if (!forceHydrate) {\n    let rootSibling;\n    while ((rootSibling = container.lastChild)) {\n      container.removeChild(rootSibling);\n    }\n  }\n\n  //  createContainer  RootContainer\n  const root = createContainer(\n    container,\n    // export const LegacyRoot = 0;\n    // export const ConcurrentRoot = 1;\n    LegacyRoot,\n    forceHydrate,\n    null, // hydrationCallbacks\n    false, // isStrictMode\n    false, // concurrentUpdatesByDefaultOverride,\n    '', // identifierPrefix\n  );\n  //  FiberRoot  container \n  markContainerAsRoot(root.current, container);\n\n  const rootContainerElement =\n    container.nodeType === COMMENT_NODE ? container.parentNode : container;\n  //  container \n  listenToAllSupportedEvents(rootContainerElement);\n\n  return root;\n}\n\n// src/react/packages/react-reconciler/src/ReactFiberReconciler.new.js\nexport function createContainer(\n  containerInfo: Container,\n  tag: RootTag,\n  hydrate: boolean,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n  isStrictMode: boolean,\n  concurrentUpdatesByDefaultOverride: null | boolean,\n  identifierPrefix: string,\n): OpaqueRoot {\n  return createFiberRoot(\n    containerInfo,\n    tag,\n    hydrate,\n    hydrationCallbacks,\n    isStrictMode,\n    concurrentUpdatesByDefaultOverride,\n    identifierPrefix,\n  );\n}\n\n// src/react/packages/react-dom/src/client/ReactDOMComponentTree.js\nexport function markContainerAsRoot(hostRoot: Fiber, node: Container): void {\n  //  FiberRoot  container \n  // internalContainerInstanceKey \"__reactFiber$9yvlviys3ft\"\n  node[internalContainerInstanceKey] = hostRoot;\n}\n// randomKey  key  key \nconst randomKey = Math.random()\n  .toString(36)\n  .slice(2);\nconst internalContainerInstanceKey = '__reactContainer$' + randomKey;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n * RootContainer LegacyRoot  ConcurrentRoot React Legacy Mode  Concurrent Mode\n * RootContainer  FiberRoot ReactElement  FiberRoot  FiberRootHostRoot  Root Fiber RootFiber  Fiber FiberTree \n * randomKey  node  __reactContainer$ \n\n# listenToAllSupportedEvents\n\ncontainer  listenToAllSupportedEvents \n\n// src/react/packages/react-dom/src/events/DOMPluginEventSystem.js\n// \nconst listeningMarker =\n  '_reactListening' +\n  Math.random()\n    .toString(36)\n    .slice(2);\n// We should not delegate these events to the container, but rather\n// set them on the actual target element itself. This is primarily\n// because these events do not consistently bubble in the DOM.\n//  container  target element \n// \nexport const nonDelegatedEvents: Set<DOMEventName> = new Set([\n  'cancel',\n  'close',\n  'invalid',\n  'load',\n  'scroll',\n  'toggle',\n  // In order to reduce bytes, we insert the above array of media events\n  // into this Set. Note: the \"error\" event isn't an exclusive media event,\n  // and can occur on other elements too. Rather than duplicate that event,\n  // we just take it from the media events array.\n  // \n  ...mediaEventTypes,\n]);\n// List of events that need to be individually attached to media elements.\nexport const mediaEventTypes: Array<DOMEventName> = [\n  'abort',\n  'canplay',\n  'canplaythrough',\n  'durationchange',\n  'emptied',\n  'encrypted',\n  'ended',\n  'error',\n  'loadeddata',\n  'loadedmetadata',\n  'loadstart',\n  'pause',\n  'play',\n  'playing',\n  'progress',\n  'ratechange',\n  'resize',\n  'seeked',\n  'seeking',\n  'stalled',\n  'suspend',\n  'timeupdate',\n  'volumechange',\n  'waiting',\n];\nexport function listenToAllSupportedEvents(rootContainerElement: EventTarget) {\n  if (!(rootContainerElement: any)[listeningMarker]) {\n    //  true\n    (rootContainerElement: any)[listeningMarker] = true;\n    allNativeEvents.forEach(domEventName => {\n      // We handle selectionchange separately because it\n      // doesn't bubble and needs to be on the document.\n      //  selectionchange \n      // selectionchange  document \n      if (domEventName !== 'selectionchange') {\n        if (!nonDelegatedEvents.has(domEventName)) {\n          listenToNativeEvent(domEventName, false, rootContainerElement);\n        }\n        listenToNativeEvent(domEventName, true, rootContainerElement);\n      }\n    });\n    //  container  document \n    const ownerDocument =\n      (rootContainerElement: any).nodeType === DOCUMENT_NODE\n        ? rootContainerElement\n        : (rootContainerElement: any).ownerDocument;\n    if (ownerDocument !== null) {\n      // The selectionchange event also needs deduplication\n      // but it is attached to the document.\n      if (!(ownerDocument: any)[listeningMarker]) {\n        //  container  document  selectionchange \n        (ownerDocument: any)[listeningMarker] = true;\n        listenToNativeEvent('selectionchange', false, ownerDocument);\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n\n\n * react  container  document \n * react  document  selectionchange\n * react  react \n\n react  listenToNativeEvent  listenToNativeEvent  React \n\n\n# createFiberRoot\n\nexport function createFiberRoot(\n  containerInfo: any,\n  tag: RootTag,\n  hydrate: boolean,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n  isStrictMode: boolean,\n  concurrentUpdatesByDefaultOverride: null | boolean,\n  identifierPrefix: string,\n): FiberRoot {\n  //  containerInfo  FiberRoot \n  const root: FiberRoot = (new FiberRootNode(\n    containerInfo,\n    tag,\n    hydrate,\n    identifierPrefix,\n  ): any);\n  if (enableSuspenseCallback) {\n    root.hydrationCallbacks = hydrationCallbacks;\n  }\n\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  //  HostRoot  RootFiber\n  const uninitializedFiber = createHostRootFiber(\n    tag,\n    isStrictMode,\n    concurrentUpdatesByDefaultOverride,\n  );\n  // HostRoot  RootFiber  HostRoot.current = RootFiber; RootFiber.stateNode = HostRoot\n  root.current = uninitializedFiber;\n  uninitializedFiber.stateNode = root;\n\n  //  RootFiber \n  initializeUpdateQueue(uninitializedFiber);\n\n  return root;\n}\nfunction FiberRootNode(containerInfo, tag, hydrate, identifierPrefix) {\n  this.tag = tag;\n  this.containerInfo = containerInfo;\n  this.pendingChildren = null;\n  this.current = null;\n  this.pingCache = null;\n  this.finishedWork = null;\n  this.timeoutHandle = noTimeout;\n  this.context = null;\n  this.pendingContext = null;\n  this.isDehydrated = hydrate;\n  this.callbackNode = null;\n  this.callbackPriority = NoLane;\n  this.eventTimes = createLaneMap(NoLanes);\n  this.expirationTimes = createLaneMap(NoTimestamp);\n\n  this.pendingLanes = NoLanes;\n  this.suspendedLanes = NoLanes;\n  this.pingedLanes = NoLanes;\n  this.expiredLanes = NoLanes;\n  this.mutableReadLanes = NoLanes;\n  this.finishedLanes = NoLanes;\n\n  this.entangledLanes = NoLanes;\n  this.entanglements = createLaneMap(NoLanes);\n\n  this.identifierPrefix = identifierPrefix;\n\n  if (enableCache) {\n    this.pooledCache = null;\n    this.pooledCacheLanes = NoLanes;\n  }\n\n  if (supportsHydration) {\n    this.mutableSourceEagerHydrationData = null;\n  }\n\n  if (enableSuspenseCallback) {\n    this.hydrationCallbacks = null;\n  }\n\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    this.effectDuration = 0;\n    this.passiveEffectDuration = 0;\n  }\n\n  if (enableUpdaterTracking) {\n    this.memoizedUpdaters = new Set();\n    const pendingUpdatersLaneMap = (this.pendingUpdatersLaneMap = []);\n    for (let i = 0; i < TotalLanes; i++) {\n      pendingUpdatersLaneMap.push(new Set());\n    }\n  }\n}\n//  fiber \nexport function initializeUpdateQueue<State>(fiber: Fiber): void {\n  const queue: UpdateQueue<State> = {\n    baseState: fiber.memoizedState,\n    firstBaseUpdate: null,\n    lastBaseUpdate: null,\n    shared: {\n      pending: null,\n      interleaved: null,\n      lanes: NoLanes,\n    },\n    effects: null,\n  };\n  fiber.updateQueue = queue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n\n\nLocal Stack\n\ncreateFiberRoot \n\ncontainerInfo: div#root\nhydrate: false\nhydrationCallbacks: undefined\nroot: FiberRootNode\ncallbackNode: null\ncallbackPriority: 0\ncontainerInfo: div#root\ncontext: null\ncurrent: FiberNode\nactualDuration: 0\nactualStartTime: -1\nalternate: null\nchild: null\nchildLanes: 0\ndependencies: null\nelementType: null\nfirstEffect: null\nflags: 0\nindex: 0\nkey: null\nlanes: 0\nlastEffect: null\nmemoizedProps: null\nmemoizedState: null\nmode: 8\nnextEffect: null\npendingProps: null\nref: null\nreturn: null\nselfBaseDuration: 0\nsibling: null\nstateNode: FiberRootNode {tag: 0, containerInfo: div#root, pendingChildren: null, current: FiberNode, pingCache: null, }\ntag: 3\ntreeBaseDuration: 0\ntype: null\nupdateQueue:\nbaseState: null\neffects: null\nfirstBaseUpdate: null\nlastBaseUpdate: null\nshared: {pending: null}\n[[Prototype]]: Object\n_debugHookTypes: null\n_debugID: 1\n_debugNeedsRemount: false\n_debugOwner: null\n_debugSource: null\n[[Prototype]]: Object\nentangledLanes: 0\nentanglements: (31) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\neventTimes: (31) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nexpirationTimes: (31) [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]\nexpiredLanes: 0\nfinishedLanes: 0\nfinishedWork: null\nhydrate: false\ninteractionThreadID: 1\nmemoizedInteractions: Set(0) {size: 0}\nmutableReadLanes: 0\nmutableSourceEagerHydrationData: null\npendingChildren: null\npendingContext: null\npendingInteractionMap: Map(0) {size: 0}\npendingLanes: 0\npingCache: null\npingedLanes: 0\nsuspendedLanes: 0\ntag: 0\ntimeoutHandle: -1\n_debugRootType: \"createLegacyRoot()\"\n[[Prototype]]: Object\ntag: 0\nuninitializedFiber: FiberNode {tag: 3, key: null, elementType: null, type: null, stateNode: FiberRootNode, }\nClosure\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# createHostRootFiber\n\nexport function createHostRootFiber(\n  tag: RootTag,\n  isStrictMode: boolean,\n  concurrentUpdatesByDefaultOverride: null | boolean,\n): Fiber {\n  let mode;\n  if (tag === ConcurrentRoot) {\n    mode = ConcurrentMode;\n    if (isStrictMode === true) {\n      mode |= StrictLegacyMode;\n\n      if (enableStrictEffects) {\n        mode |= StrictEffectsMode;\n      }\n    } else if (enableStrictEffects && createRootStrictEffectsByDefault) {\n      mode |= StrictLegacyMode | StrictEffectsMode;\n    }\n    if (\n      // We only use this flag for our repo tests to check both behaviors.\n      // TODO: Flip this flag and rename it something like \"forceConcurrentByDefaultForTesting\"\n      !enableSyncDefaultUpdates ||\n      // Only for internal experiments.\n      (allowConcurrentByDefault && concurrentUpdatesByDefaultOverride)\n    ) {\n      mode |= ConcurrentUpdatesByDefaultMode;\n    }\n  } else {\n    mode = NoMode;\n  }\n\n  if (enableProfilerTimer && isDevToolsPresent) {\n    // Always collect profile timings when DevTools are present.\n    // This enables DevTools to start capturing timing at any point\n    // Without some nodes in the tree having empty base times.\n    mode |= ProfileMode;\n  }\n\n  return createFiber(HostRoot, null, null, mode);\n}\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\n// createFiber instanceof \nconst createFiber = function(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n): Fiber {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\nfunction FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.elementType = null;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n\n  this.mode = mode;\n\n  // Effects\n  this.flags = NoFlags;\n  this.subtreeFlags = NoFlags;\n  this.deletions = null;\n\n  this.lanes = NoLanes;\n  this.childLanes = NoLanes;\n\n  this.alternate = null;\n\n  if (enableProfilerTimer) {\n    // Note: The following is done to avoid a v8 performance cliff.\n    //\n    // Initializing the fields below to smis and later updating them with\n    // double values will cause Fibers to end up having separate shapes.\n    // This behavior/bug has something to do with Object.preventExtension().\n    // Fortunately this only impacts DEV builds.\n    // Unfortunately it makes React unusably slow for some applications.\n    // To work around this, initialize the fields below with doubles.\n    //\n    // Learn more about this here:\n    // https://github.com/facebook/react/issues/14365\n    // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n    this.actualDuration = Number.NaN;\n    this.actualStartTime = Number.NaN;\n    this.selfBaseDuration = Number.NaN;\n    this.treeBaseDuration = Number.NaN;\n\n    // It's okay to replace the initial doubles with smis after initialization.\n    // This won't trigger the performance cliff mentioned above,\n    // and it simplifies other profiler code (including DevTools).\n    this.actualDuration = 0;\n    this.actualStartTime = -1;\n    this.selfBaseDuration = 0;\n    this.treeBaseDuration = 0;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n\n * RootFiber  Fiber  createFiber  Fiber tag  HostRoot  Fiber \n * Fiber Fiber Instance Fiber Effects lanes instance  Fiber tag  fiber Fiber  FiberTree Effects  render lanes alternate \n * uninitializedFiber  RootFiber Instance  \n\n\n\n * tag  Fiber  Fiber \n\nLocal Stack\n\nReturn value: FiberNode\nactualDuration: 0\nactualStartTime: -1\nalternate: null\nchild: null\nchildLanes: 0\ndependencies: null\nelementType: null\nfirstEffect: null\nflags: 0\nindex: 0\nkey: null\nlanes: 0\nlastEffect: null\nmemoizedProps: null\nmemoizedState: null\nmode: 8\nnextEffect: null\npendingProps: null\nref: null\nreturn: null\nselfBaseDuration: 0\nsibling: null\nstateNode: null\ntag: 3\ntreeBaseDuration: 0\ntype: null\nupdateQueue: null\n_debugHookTypes: null\n_debugID: 1\n_debugNeedsRemount: false\n_debugOwner: null\n_debugSource: null\n[[Prototype]]: Object\nthis: undefined\nmode: 8\ntag: 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\nWorkTag Fiber \n\n// src/react/packages/react-reconciler/src/ReactWorkTags.js\nexport type WorkTag =\n  | 0\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12\n  | 13\n  | 14\n  | 15\n  | 16\n  | 17\n  | 18\n  | 19\n  | 20\n  | 21\n  | 22\n  | 23\n  | 24;\n\nexport const FunctionComponent = 0; // \nexport const ClassComponent = 1; // \nexport const IndeterminateComponent = 2; // Before we know whether it is function or class // \nexport const HostRoot = 3; // Root of a host tree. Could be nested inside another node. // HostRoot  RootFiber \nexport const HostPortal = 4; // A subtree. Could be an entry point to a different renderer. // HostPortal  Portal  HostRoot\nexport const HostComponent = 5;\nexport const HostText = 6;\nexport const Fragment = 7; // React.Fragment \nexport const Mode = 8;\nexport const ContextConsumer = 9; // context.Consumer \nexport const ContextProvider = 10; //  context.Provider \nexport const ForwardRef = 11; // React.forwardRef \nexport const Profiler = 12; \nexport const SuspenseComponent = 13; // suspense \nexport const MemoComponent = 14; // memo \nexport const SimpleMemoComponent = 15; //  compare  memo \nexport const LazyComponent = 16; // react.lazy \nexport const IncompleteClassComponent = 17;\nexport const DehydratedFragment = 18;\nexport const SuspenseListComponent = 19;\nexport const ScopeComponent = 21;\nexport const OffscreenComponent = 22;\nexport const LegacyHiddenComponent = 23;\nexport const CacheComponent = 24;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\nFiberNode  Fiber  FiberTree \n\n\n\n * FiberRoot  RootFiber \n * Fiber  child sibling return  FiberTree  sibling \n * child  return  sibling return  FiberTree \n\nLocal Stack\n\n\n\n render -> legacyRenderSubtreeIntoContainer -> legacyCreateRootFromDOMContainer -> createContainer -> createFiberRoot -> createHostRootFiber -> createFiber -> ...\n\n\n# flushSync\n\n HostRoot  RootFiber\n\nflushSync(() => {\n  updateContainer(children, fiberRoot, parentComponent, callback);\n});\n\n\n1\n2\n3\n\n\nflushSync  updateContainer \n\n flushSync \n\n// Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\ndeclare function flushSync<R>(fn: () => R): R;\n// eslint-disable-next-line no-redeclare\ndeclare function flushSync(): void;\n// eslint-disable-next-line no-redeclare\nexport function flushSync(fn) {\n  // In legacy mode, we flush pending passive effects at the beginning of the\n  // next event, not at the end of the previous one.\n  // rootWithPendingPassiveEffects  commit  HostRoot\n  //  commit  HostRoot RenderContext  CommitContext flush \n  if (\n    rootWithPendingPassiveEffects !== null &&\n    rootWithPendingPassiveEffects.tag === LegacyRoot &&\n    (executionContext & (RenderContext | CommitContext)) === NoContext\n  ) {\n    flushPassiveEffects();\n  }\n\n  const prevExecutionContext = executionContext;\n  // executionContext  BatchedContext\n  executionContext |= BatchedContext;\n\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  const previousPriority = getCurrentUpdatePriority();\n  try {\n    ReactCurrentBatchConfig.transition = 0;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    if (fn) {\n      return fn();\n    } else {\n      return undefined;\n    }\n  } finally {\n    //  fn  \n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n    executionContext = prevExecutionContext;\n    // Flush the immediate callbacks that were scheduled during this batch.\n    // Note that this will happen even if batchedUpdates is higher up\n    // the stack.\n    // flush  batch  callbacks\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n      flushSyncCallbacks();\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n * flushSync  ts \n * flushSync  flushPassiveEffects  commit  HostRoot \n * flushSync  commit  flushPassiveEffects BatchedContext \n *  rootWithPendingPassiveEffects  null flushPassiveEffects  flushPassiveEffects \n\n\n# flushPassiveEffects\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nexport function flushPassiveEffects(): boolean {\n  // Returns whether passive effects were flushed.\n  // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n  // probably just combine the two functions. I believe they were only separate\n  // in the first place because we used to wrap it with\n  // `Scheduler.runWithPriority`, which accepts a function. But now we track the\n  // priority within React itself, so we can mutate the variable directly.\n  if (rootWithPendingPassiveEffects !== null) {\n    // Cache the root since rootWithPendingPassiveEffects is cleared in\n    // flushPassiveEffectsImpl\n    //  root \n    const root = rootWithPendingPassiveEffects;\n    // Cache and clear the remaining lanes flag; it must be reset since this\n    // method can be called from various places, not always from commitRoot\n    // where the remaining lanes are known\n    //  remainingLanes\n    const remainingLanes = pendingPassiveEffectsRemainingLanes;\n    pendingPassiveEffectsRemainingLanes = NoLanes;\n\n    const renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n    const priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    const previousPriority = getCurrentUpdatePriority();\n    try {\n      ReactCurrentBatchConfig.transition = 0;\n      setCurrentUpdatePriority(priority);\n      return flushPassiveEffectsImpl();\n    } finally {\n      // flushPassiveEffectsImpl \n      setCurrentUpdatePriority(previousPriority);\n      ReactCurrentBatchConfig.transition = prevTransition;\n\n      // Once passive effects have run for the tree - giving components a\n      // chance to retain cache instances they use - release the pooled\n      // cache at the root (if there is one)\n      releaseRootPooledCache(root, remainingLanes);\n    }\n  }\n  return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n flushPassiveEffectsImpl \n\nfunction flushPassiveEffectsImpl() {\n  if (rootWithPendingPassiveEffects === null) {\n    return false;\n  }\n\n  const root = rootWithPendingPassiveEffects;\n  const lanes = pendingPassiveEffectsLanes;\n  //  PassiveEffects  flush\n  rootWithPendingPassiveEffects = null;\n  // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n  // Figure out why and fix it. It's not causing any known issues (probably\n  // because it's only used for profiling), but it's a refactor hazard.\n  pendingPassiveEffectsLanes = NoLanes;\n\n  // Render  Commit  flush \n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Cannot flush passive effects while already rendering.');\n  }\n\n  const prevExecutionContext = executionContext;\n  //  executionContext  CommitContext Commit \n  executionContext |= CommitContext;\n\n  //  passiveEffects  Mount  Unmount  commit\n  commitPassiveUnmountEffects(root.current);\n  commitPassiveMountEffects(root, root.current);\n\n  executionContext = prevExecutionContext;\n\n  //  callback  flush\n  flushSyncCallbacks();\n\n  // If additional passive effects were scheduled, increment a counter. If this\n  // exceeds the limit, we'll fire a warning.\n  // nestedPassiveUpdateCount \n  nestedPassiveUpdateCount =\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\n  return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n * flush effects  commit effects\n\n\n# flushSyncCallbacks\n\n// src/react/packages/react-reconciler/src/ReactFiberSyncTaskQueue.new.js\nexport function flushSyncCallbacks() {\n  // isFlushingSyncQueue  syncQueue  \n  if (!isFlushingSyncQueue && syncQueue !== null) {\n    // Prevent re-entrance.\n    isFlushingSyncQueue = true;\n    let i = 0;\n    const previousUpdatePriority = getCurrentUpdatePriority();\n    try {\n      const isSync = true;\n      const queue = syncQueue;\n      // TODO: Is this necessary anymore? The only user code that runs in this\n      // queue is in the render or commit phases.\n      setCurrentUpdatePriority(DiscreteEventPriority);\n      // flush syncQueue callback  callback\n      for (; i < queue.length; i++) {\n        let callback = queue[i];\n        do {\n          callback = callback(isSync);\n        } while (callback !== null);\n      }\n      //  syncQueue\n      syncQueue = null;\n      includesLegacySyncCallbacks = false;\n    } catch (error) {\n      // If something throws, leave the remaining callbacks on the queue.\n      // syncQueue  RootCallback \n      if (syncQueue !== null) {\n        syncQueue = syncQueue.slice(i + 1);\n      }\n      // Resume flushing in the next tick\n      //  tick \n      scheduleCallback(ImmediatePriority, flushSyncCallbacks);\n      throw error;\n    } finally {\n      setCurrentUpdatePriority(previousUpdatePriority);\n      isFlushingSyncQueue = false;\n    }\n  }\n  return null;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\nflushSyncCallbacks  syncQueue syncQueue  callback  callback +  syncQueue flush syncQueue  effect  react  effect \n\n *  syncQueue  flushSyncCallbacks  syncQueue \n *  next tick  syncQueue \n\n\n# updateContainer\n\nupdateContainer \n\nexport function updateContainer(\n  element: ReactNodeList,\n  container: OpaqueRoot,\n  parentComponent: ?React$Component<any, any>,\n  callback: ?Function,\n): Lane {\n  //  RootFiber\n  const current = container.current;\n  const eventTime = requestEventTime();\n  const lane = requestUpdateLane(current);\n\n  //  container  context \n  const context = getContextForSubtree(parentComponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  // \n  const update = createUpdate(eventTime, lane);\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = {element};\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    update.callback = callback;\n  }\n\n  // \n  enqueueUpdate(current, update, lane);\n  // \n  const root = scheduleUpdateOnFiber(current, lane, eventTime);\n  if (root !== null) {\n    entangleTransitions(root, current, lane);\n  }\n\n  return lane;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\nupdateContainer  RootFiber  scheduleWork  \n\n\n# \n\nReact  HostRoot  FiberRoot \n\n\n# Q&A\n\n\n# executionContext \n\nexecutionContext  React  executionContext \n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nexport const NoContext = /*             */ 0b0000;\nconst BatchedContext = /*               */ 0b0001; // Batch()\nconst RenderContext = /*                */ 0b0010; // Render()\nconst CommitContext = /*                */ 0b0100; // Commit()\nexport const RetryAfterError = /*       */ 0b1000; // \n\n// Describes where we are in the React execution stack\nlet executionContext: ExecutionContext = NoContext;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n executionContext  NoContent:\n\nCONTEXT                                                                 \nNoContext                                                                  \nBatchedContext    flushSyncbatchedUpdatesflushControlled   Batch ()    RenderSubtreeIntoContainer renderRoot \nRenderContext     renderRootSyncrenderRootConcurrent        Render ()    renderRoot commitRoot \nCommitContext     commitRootImplflushPassiveEffectsImpl     Commit ()    commitRoot \nRetryAfterError   recoverFromConcurrentError                 Error          \n\nReact  NoContextBatchedContextRenderContextCommitContextRetryAfterError  React \n\n\n# \n\nReact  react  effectTagworkTag  executionContext\n\n React \n\nconst NoContext = 0b0000;\nconst BatchedContext =  0b0001; \nconst RenderContext =  0b0010; \nconst CommitContext =  0b0100;\nconst RetryAfterError = 0b1000;\n\nlet executionContext = NoContext;\n\n//  RenderContainer Batch \n// \nexecutionContext |= BatchedContext; // 1\n//  Batch \n// 0 1  0  NoContext \n(executionContext & BatchedContext) !== NoContext; // true\n//  Render \n(executionContext & RenderContext) !== NoContext; // false\n//  RenderRoot Render \nexecutionContext |= RenderContext;\n//  Batch  Render \n(executionContext & (BatchedContext | RenderContext)) !== NoContext; // true\n//  Commit  Error \n(executionContext & (CommitContext | RetryAfterError)) === NoContext; // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n Vue \n\nconst enum ShapeFlags {\n  ELEMENT = 1,\n  FUNCTIONAL_COMPONENT = 1 << 1,\n  STATEFUL_COMPONENT = 1 << 2,\n  TEXT_CHILDREN = 1 << 3,\n  ARRAY_CHILDREN = 1 << 4,\n  SLOTS_CHILDREN = 1 << 5,\n  TELEPORT = 1 << 6,\n  SUSPENSE = 1 << 7,\n  COMPONENT_SHOULD_KEEP_ALIVE = 1 << 8,\n  COMPONENT_KEPT_ALIVE = 1 << 9,\n  COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n 1\n\n\n\n\n# \n\n *  React  - \n *  React Concurrent\n * React ",normalizedContent:"# \n\n\n\n * \n * reactdom.render\n   * jsxwithvalidation\n   * render\n * legacyrendersubtreeintocontainer\n * createfiberroot\n * createhostrootfiber\n * flushsync\n   * flushpassiveeffects\n   * flushsynccallbacks\n * updatecontainer\n * \n * q&a\n   * executioncontext \n   * \n * \n\n\n\n\n\n *  dev \n\n\n# reactdom.render\n\n reactdom.render  react \n\n\n# jsxwithvalidation\n\n <app />  jsx \n\n// src/react/fixtures/legacy-jsx-runtimes/react-17/cjs/react-jsx-dev-runtime.development.js\nfunction jsxwithvalidation(type, props, key, isstaticchildren, source, self) {\n  {\n    var validtype = isvalidelementtype(type); // we warn in this case but don't throw. we expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validtype) {\n      // pass \n      // \n    }\n\n    //  reactelement \n    var element = jsxdev(type, props, key, source, self); // the result can be nullish if a mock or a custom function is used.\n    // todo: drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // we don't want exception behavior to differ between dev and prod.\n    // (rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validtype) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        // isstaticchildren  key \n        if (isstaticchildren) {\n          if (array.isarray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validatechildkeys(children[i], type);\n            }\n\n            if (object.freeze) {\n              object.freeze(children);\n            }\n          } else {\n            error('react.jsx: static children should always be an array. ' + 'you are likely explicitly calling react.jsxs or react.jsxdev. ' + 'use the babel transform instead.');\n          }\n        } else {\n          validatechildkeys(children, type);\n        }\n      }\n    }\n\n    if (type === exports.fragment) {\n      validatefragmentprops(element);\n    } else {\n      validateproptypes(element);\n    }\n\n    return element;\n  }\n}\n// local stack\n// {\n//   \"props\": {},\n//   \"isstaticchildren\": false,\n//   \"source\": {\n//     \"filename\": \"/users/jonsam/projects/update_in_github/react-source-reading/src/index.js\",\n//     \"linenumber\": 9,\n//     \"columnnumber\": 5\n//   },\n//   \"validtype\": true,\n//   \"element\": {\n//     \"key\": null,\n//     \"ref\": null,\n//     \"props\": {},\n//     \"_owner\": null,\n//     \"_store\": {}\n//   }\n// }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n element \n\nfunction isvalidelementtype(type) {\n  //  string  function  element fc\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n  //  type  fragmentprofilersuspense \n  if (type === exports.fragment || type === react_profiler_type || type === react_debug_tracing_mode_type || type === react_strict_mode_type || type === react_suspense_type || type === react_suspense_list_type || type === react_legacy_hidden_type || enablescopeapi ) {\n    return true;\n  }\n\n  //  $$typeof lazymemoprovidercontextforward_ref \n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === react_lazy_type || type.$$typeof === react_memo_type || type.$$typeof === react_provider_type || type.$$typeof === react_context_type || type.$$typeof === react_forward_ref_type || type.$$typeof === react_fundamental_type || type.$$typeof === react_block_type || type[0] === react_server_block_type) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\njsxdev  reactelement \n\nvar reactelement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // this tag allows us to uniquely identify this as a react element\n    //  reactelement  $$typeof \n    $$typeof: react_element_type,\n    // built-in properties that belong on the element\n    //  function\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // the validation flag is currently mutative. we put it on\n    // an external backing store so that we can freeze the whole object.\n    // this can be replaced with a weakmap once they are implemented in\n    // commonly used development environments.\n    //  _store  weakmap  element  weakmap  _store \n    element._store = {}; // to make comparing reactelements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    object.defineproperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are dev only properties.\n\n    object.defineproperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    object.defineproperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (object.freeze) {\n      object.freeze(element.props);\n      object.freeze(element);\n    }\n  }\n\n  return element;\n};\n// local stack\n// {\n//   \"config\": {},\n//   \"source\": {\n//     \"filename\": \"/users/jonsam/projects/update_in_github/react-source-reading/src/index.js\",\n//     \"linenumber\": 9,\n//     \"columnnumber\": 5\n//   },\n//   \"props\": {},\n//   \"key\": null,\n//   \"ref\": null\n// }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n * reactelement  reactelement \n * reactelement  $$typeof reactelement  react_element_type type  function\n *  reactelement  _store  weakmap \n\n\n# render\n\n// src/react/packages/react-dom/src/client/reactdomlegacy.js\nfunction render(\n  element: react$element<any>,\n  container: container,\n  callback: ?function,\n){\n  if (!isvalidcontainerlegacy(container)) {\n    throw new error('target container is not a dom element.');\n  }\n  return legacyrendersubtreeintocontainer(\n    null,\n    element,\n    container,\n    false,\n    callback,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nlocal stack\n\n reactelement  render  container legacyrendersubtreeintocontainer  subtree  container \n\n container \n\n// we only use it in places that are currently more relaxed.\nexport function isvalidcontainerlegacy(node: any): boolean {\n  //  node.nodetype  node \n  return !!(\n    node &&\n    (node.nodetype === element_node ||\n      node.nodetype === document_node ||\n      node.nodetype === document_fragment_node ||\n      (node.nodetype === comment_node &&\n        (node: any).nodevalue === ' react-mount-point-unstable '))\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nlocal stack\n\n\n\nassignedslot: null\nattributestylemap: stylepropertymap {size: 0}\nattributes: namednodemap {0: id, id: id, length: 1}\nautocapitalize: \"\"\nautofocus: false\nbaseuri: \"http://localhost:3001/\"\nchildelementcount: 0\nchildnodes: nodelist []\nchildren: htmlcollection []\nclasslist: domtokenlist [value: '']\nclassname: \"\"\nclientheight: 0\nclientleft: 0\nclienttop: 0\nclientwidth: 1792\ncontenteditable: \"inherit\"\ndataset: domstringmap {}\ndir: \"\"\ndraggable: false\nelementtiming: \"\"\nenterkeyhint: \"\"\nfirstchild: null\nfirstelementchild: null\nhidden: false\nid: \"root\"\ninnerhtml: \"\"\ninnertext: \"\"\ninputmode: \"\"\nisconnected: true\niscontenteditable: false\nlang: \"\"\nlastchild: null\nlastelementchild: null\nlocalname: \"div\"\nnamespaceuri: \"http://www.w3.org/1999/xhtml\"\nnextelementsibling: null\nnextsibling: text\nnodename: \"div\"\nnodetype: 1\nnodevalue: null\nnonce: \"\"\noffsetheight: 0\noffsetleft: 0\noffsetparent: body\noffsettop: 0\noffsetwidth: 1792\nouterhtml: \"<div id=\\\"root\\\"></div>\"\noutertext: \"\"\nownerdocument: document\nparentelement: body\nparentnode: body\npart: domtokenlist [value: '']\nprefix: null\npreviouselementsibling: noscript\nprevioussibling: text\nscrollheight: 0\nscrollleft: 0\nscrolltop: 0\nscrollwidth: 1792\nshadowroot: null\nslot: \"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n nodetype: 1 element_node\n\n\n# legacyrendersubtreeintocontainer\n\n// src/react/packages/react-dom/src/client/reactdomlegacy.js\nfunction legacyrendersubtreeintocontainer(\n  parentcomponent: ?react$component<any, any>,\n  children: reactnodelist,\n  container: container,\n  forcehydrate: boolean,\n  callback: ?function,\n) {\n  //  rootcontainer \n  // _reactrootcontainer  container  fiberroot \n  let root = container._reactrootcontainer;\n  let fiberroot: fiberroot;\n  if (!root) {\n    // initial mount\n    // rootcontainer  legacycreaterootfromdomcontainer  root \n    root = container._reactrootcontainer = legacycreaterootfromdomcontainer(\n      container,\n      forcehydrate,\n    );\n    fiberroot = root;\n    //  render  callback callback\n    if (typeof callback === 'function') {\n      const originalcallback = callback;\n      callback = function() {\n        const instance = getpublicrootinstance(fiberroot);\n        originalcallback.call(instance);\n      };\n    }\n    // initial mount should not be batched.\n    //  mount \n    flushsync(() => {\n      updatecontainer(children, fiberroot, parentcomponent, callback);\n    });\n  } else {\n    fiberroot = root;\n    if (typeof callback === 'function') {\n      const originalcallback = callback;\n      callback = function() {\n        const instance = getpublicrootinstance(fiberroot);\n        originalcallback.call(instance);\n      };\n    }\n    // update\n    updatecontainer(children, fiberroot, parentcomponent, callback);\n  }\n  return getpublicrootinstance(fiberroot);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\nlocal stack\n\n\n\ncallback: undefined\nchildren: {$$typeof: symbol(react.element), type: symbol(react.strict_mode), key: null, ref: null, props: {}, }\ncontainer: div#root\nfiberroot: undefined\nforcehydrate: false\noriginalcallback: undefined\nparentcomponent: null\nroot: undefined\n_originalcallback: undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nrender  callback container fiberroot \n\nexport function getpublicrootinstance(\n  container: opaqueroot,\n): react$component<any, any> | publicinstance | null {\n  const containerfiber = container.current;\n  if (!containerfiber.child) {\n    return null;\n  }\n  switch (containerfiber.child.tag) {\n    case hostcomponent:\n      return getpublicinstance(containerfiber.child.statenode);\n    default:\n      //  instance  fiber.child.statenode  rootfiber\n      return containerfiber.child.statenode;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# legacycreaterootfromdomcontainer\n\nrootcontainer  container  legacycreaterootfromdomcontainer \n\nfunction legacycreaterootfromdomcontainer(\n  container: container,\n  forcehydrate: boolean,\n): fiberroot {\n  // first clear any existing content.\n  //  ssr container \n  if (!forcehydrate) {\n    let rootsibling;\n    while ((rootsibling = container.lastchild)) {\n      container.removechild(rootsibling);\n    }\n  }\n\n  //  createcontainer  rootcontainer\n  const root = createcontainer(\n    container,\n    // export const legacyroot = 0;\n    // export const concurrentroot = 1;\n    legacyroot,\n    forcehydrate,\n    null, // hydrationcallbacks\n    false, // isstrictmode\n    false, // concurrentupdatesbydefaultoverride,\n    '', // identifierprefix\n  );\n  //  fiberroot  container \n  markcontainerasroot(root.current, container);\n\n  const rootcontainerelement =\n    container.nodetype === comment_node ? container.parentnode : container;\n  //  container \n  listentoallsupportedevents(rootcontainerelement);\n\n  return root;\n}\n\n// src/react/packages/react-reconciler/src/reactfiberreconciler.new.js\nexport function createcontainer(\n  containerinfo: container,\n  tag: roottag,\n  hydrate: boolean,\n  hydrationcallbacks: null | suspensehydrationcallbacks,\n  isstrictmode: boolean,\n  concurrentupdatesbydefaultoverride: null | boolean,\n  identifierprefix: string,\n): opaqueroot {\n  return createfiberroot(\n    containerinfo,\n    tag,\n    hydrate,\n    hydrationcallbacks,\n    isstrictmode,\n    concurrentupdatesbydefaultoverride,\n    identifierprefix,\n  );\n}\n\n// src/react/packages/react-dom/src/client/reactdomcomponenttree.js\nexport function markcontainerasroot(hostroot: fiber, node: container): void {\n  //  fiberroot  container \n  // internalcontainerinstancekey \"__reactfiber$9yvlviys3ft\"\n  node[internalcontainerinstancekey] = hostroot;\n}\n// randomkey  key  key \nconst randomkey = math.random()\n  .tostring(36)\n  .slice(2);\nconst internalcontainerinstancekey = '__reactcontainer$' + randomkey;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n * rootcontainer legacyroot  concurrentroot react legacy mode  concurrent mode\n * rootcontainer  fiberroot reactelement  fiberroot  fiberroothostroot  root fiber rootfiber  fiber fibertree \n * randomkey  node  __reactcontainer$ \n\n# listentoallsupportedevents\n\ncontainer  listentoallsupportedevents \n\n// src/react/packages/react-dom/src/events/domplugineventsystem.js\n// \nconst listeningmarker =\n  '_reactlistening' +\n  math.random()\n    .tostring(36)\n    .slice(2);\n// we should not delegate these events to the container, but rather\n// set them on the actual target element itself. this is primarily\n// because these events do not consistently bubble in the dom.\n//  container  target element \n// \nexport const nondelegatedevents: set<domeventname> = new set([\n  'cancel',\n  'close',\n  'invalid',\n  'load',\n  'scroll',\n  'toggle',\n  // in order to reduce bytes, we insert the above array of media events\n  // into this set. note: the \"error\" event isn't an exclusive media event,\n  // and can occur on other elements too. rather than duplicate that event,\n  // we just take it from the media events array.\n  // \n  ...mediaeventtypes,\n]);\n// list of events that need to be individually attached to media elements.\nexport const mediaeventtypes: array<domeventname> = [\n  'abort',\n  'canplay',\n  'canplaythrough',\n  'durationchange',\n  'emptied',\n  'encrypted',\n  'ended',\n  'error',\n  'loadeddata',\n  'loadedmetadata',\n  'loadstart',\n  'pause',\n  'play',\n  'playing',\n  'progress',\n  'ratechange',\n  'resize',\n  'seeked',\n  'seeking',\n  'stalled',\n  'suspend',\n  'timeupdate',\n  'volumechange',\n  'waiting',\n];\nexport function listentoallsupportedevents(rootcontainerelement: eventtarget) {\n  if (!(rootcontainerelement: any)[listeningmarker]) {\n    //  true\n    (rootcontainerelement: any)[listeningmarker] = true;\n    allnativeevents.foreach(domeventname => {\n      // we handle selectionchange separately because it\n      // doesn't bubble and needs to be on the document.\n      //  selectionchange \n      // selectionchange  document \n      if (domeventname !== 'selectionchange') {\n        if (!nondelegatedevents.has(domeventname)) {\n          listentonativeevent(domeventname, false, rootcontainerelement);\n        }\n        listentonativeevent(domeventname, true, rootcontainerelement);\n      }\n    });\n    //  container  document \n    const ownerdocument =\n      (rootcontainerelement: any).nodetype === document_node\n        ? rootcontainerelement\n        : (rootcontainerelement: any).ownerdocument;\n    if (ownerdocument !== null) {\n      // the selectionchange event also needs deduplication\n      // but it is attached to the document.\n      if (!(ownerdocument: any)[listeningmarker]) {\n        //  container  document  selectionchange \n        (ownerdocument: any)[listeningmarker] = true;\n        listentonativeevent('selectionchange', false, ownerdocument);\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n\n\n * react  container  document \n * react  document  selectionchange\n * react  react \n\n react  listentonativeevent  listentonativeevent  react \n\n\n# createfiberroot\n\nexport function createfiberroot(\n  containerinfo: any,\n  tag: roottag,\n  hydrate: boolean,\n  hydrationcallbacks: null | suspensehydrationcallbacks,\n  isstrictmode: boolean,\n  concurrentupdatesbydefaultoverride: null | boolean,\n  identifierprefix: string,\n): fiberroot {\n  //  containerinfo  fiberroot \n  const root: fiberroot = (new fiberrootnode(\n    containerinfo,\n    tag,\n    hydrate,\n    identifierprefix,\n  ): any);\n  if (enablesuspensecallback) {\n    root.hydrationcallbacks = hydrationcallbacks;\n  }\n\n  // cyclic construction. this cheats the type system right now because\n  // statenode is any.\n  //  hostroot  rootfiber\n  const uninitializedfiber = createhostrootfiber(\n    tag,\n    isstrictmode,\n    concurrentupdatesbydefaultoverride,\n  );\n  // hostroot  rootfiber  hostroot.current = rootfiber; rootfiber.statenode = hostroot\n  root.current = uninitializedfiber;\n  uninitializedfiber.statenode = root;\n\n  //  rootfiber \n  initializeupdatequeue(uninitializedfiber);\n\n  return root;\n}\nfunction fiberrootnode(containerinfo, tag, hydrate, identifierprefix) {\n  this.tag = tag;\n  this.containerinfo = containerinfo;\n  this.pendingchildren = null;\n  this.current = null;\n  this.pingcache = null;\n  this.finishedwork = null;\n  this.timeouthandle = notimeout;\n  this.context = null;\n  this.pendingcontext = null;\n  this.isdehydrated = hydrate;\n  this.callbacknode = null;\n  this.callbackpriority = nolane;\n  this.eventtimes = createlanemap(nolanes);\n  this.expirationtimes = createlanemap(notimestamp);\n\n  this.pendinglanes = nolanes;\n  this.suspendedlanes = nolanes;\n  this.pingedlanes = nolanes;\n  this.expiredlanes = nolanes;\n  this.mutablereadlanes = nolanes;\n  this.finishedlanes = nolanes;\n\n  this.entangledlanes = nolanes;\n  this.entanglements = createlanemap(nolanes);\n\n  this.identifierprefix = identifierprefix;\n\n  if (enablecache) {\n    this.pooledcache = null;\n    this.pooledcachelanes = nolanes;\n  }\n\n  if (supportshydration) {\n    this.mutablesourceeagerhydrationdata = null;\n  }\n\n  if (enablesuspensecallback) {\n    this.hydrationcallbacks = null;\n  }\n\n  if (enableprofilertimer && enableprofilercommithooks) {\n    this.effectduration = 0;\n    this.passiveeffectduration = 0;\n  }\n\n  if (enableupdatertracking) {\n    this.memoizedupdaters = new set();\n    const pendingupdaterslanemap = (this.pendingupdaterslanemap = []);\n    for (let i = 0; i < totallanes; i++) {\n      pendingupdaterslanemap.push(new set());\n    }\n  }\n}\n//  fiber \nexport function initializeupdatequeue<state>(fiber: fiber): void {\n  const queue: updatequeue<state> = {\n    basestate: fiber.memoizedstate,\n    firstbaseupdate: null,\n    lastbaseupdate: null,\n    shared: {\n      pending: null,\n      interleaved: null,\n      lanes: nolanes,\n    },\n    effects: null,\n  };\n  fiber.updatequeue = queue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n\n\nlocal stack\n\ncreatefiberroot \n\ncontainerinfo: div#root\nhydrate: false\nhydrationcallbacks: undefined\nroot: fiberrootnode\ncallbacknode: null\ncallbackpriority: 0\ncontainerinfo: div#root\ncontext: null\ncurrent: fibernode\nactualduration: 0\nactualstarttime: -1\nalternate: null\nchild: null\nchildlanes: 0\ndependencies: null\nelementtype: null\nfirsteffect: null\nflags: 0\nindex: 0\nkey: null\nlanes: 0\nlasteffect: null\nmemoizedprops: null\nmemoizedstate: null\nmode: 8\nnexteffect: null\npendingprops: null\nref: null\nreturn: null\nselfbaseduration: 0\nsibling: null\nstatenode: fiberrootnode {tag: 0, containerinfo: div#root, pendingchildren: null, current: fibernode, pingcache: null, }\ntag: 3\ntreebaseduration: 0\ntype: null\nupdatequeue:\nbasestate: null\neffects: null\nfirstbaseupdate: null\nlastbaseupdate: null\nshared: {pending: null}\n[[prototype]]: object\n_debughooktypes: null\n_debugid: 1\n_debugneedsremount: false\n_debugowner: null\n_debugsource: null\n[[prototype]]: object\nentangledlanes: 0\nentanglements: (31) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\neventtimes: (31) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nexpirationtimes: (31) [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]\nexpiredlanes: 0\nfinishedlanes: 0\nfinishedwork: null\nhydrate: false\ninteractionthreadid: 1\nmemoizedinteractions: set(0) {size: 0}\nmutablereadlanes: 0\nmutablesourceeagerhydrationdata: null\npendingchildren: null\npendingcontext: null\npendinginteractionmap: map(0) {size: 0}\npendinglanes: 0\npingcache: null\npingedlanes: 0\nsuspendedlanes: 0\ntag: 0\ntimeouthandle: -1\n_debugroottype: \"createlegacyroot()\"\n[[prototype]]: object\ntag: 0\nuninitializedfiber: fibernode {tag: 3, key: null, elementtype: null, type: null, statenode: fiberrootnode, }\nclosure\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# createhostrootfiber\n\nexport function createhostrootfiber(\n  tag: roottag,\n  isstrictmode: boolean,\n  concurrentupdatesbydefaultoverride: null | boolean,\n): fiber {\n  let mode;\n  if (tag === concurrentroot) {\n    mode = concurrentmode;\n    if (isstrictmode === true) {\n      mode |= strictlegacymode;\n\n      if (enablestricteffects) {\n        mode |= stricteffectsmode;\n      }\n    } else if (enablestricteffects && createrootstricteffectsbydefault) {\n      mode |= strictlegacymode | stricteffectsmode;\n    }\n    if (\n      // we only use this flag for our repo tests to check both behaviors.\n      // todo: flip this flag and rename it something like \"forceconcurrentbydefaultfortesting\"\n      !enablesyncdefaultupdates ||\n      // only for internal experiments.\n      (allowconcurrentbydefault && concurrentupdatesbydefaultoverride)\n    ) {\n      mode |= concurrentupdatesbydefaultmode;\n    }\n  } else {\n    mode = nomode;\n  }\n\n  if (enableprofilertimer && isdevtoolspresent) {\n    // always collect profile timings when devtools are present.\n    // this enables devtools to start capturing timing at any point\n    // without some nodes in the tree having empty base times.\n    mode |= profilemode;\n  }\n\n  return createfiber(hostroot, null, null, mode);\n}\n// this is a constructor function, rather than a pojo constructor, still\n// please ensure we do the following:\n// 1) nobody should add any instance methods on this. instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) nobody should rely on `instanceof fiber` for type testing. we should\n//    always know when it is a fiber.\n// 3) we might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-jit environment.\n// 4) we can easily go from a constructor to a createfiber object literal if that\n//    is faster.\n// 5) it should be easy to port this to a c struct and keep a c implementation\n//    compatible.\n// createfiber instanceof \nconst createfiber = function(\n  tag: worktag,\n  pendingprops: mixed,\n  key: null | string,\n  mode: typeofmode,\n): fiber {\n  // $flowfixme: the shapes are exact here but flow doesn't like constructors\n  return new fibernode(tag, pendingprops, key, mode);\n};\nfunction fibernode(\n  tag: worktag,\n  pendingprops: mixed,\n  key: null | string,\n  mode: typeofmode,\n) {\n  // instance\n  this.tag = tag;\n  this.key = key;\n  this.elementtype = null;\n  this.type = null;\n  this.statenode = null;\n\n  // fiber\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingprops = pendingprops;\n  this.memoizedprops = null;\n  this.updatequeue = null;\n  this.memoizedstate = null;\n  this.dependencies = null;\n\n  this.mode = mode;\n\n  // effects\n  this.flags = noflags;\n  this.subtreeflags = noflags;\n  this.deletions = null;\n\n  this.lanes = nolanes;\n  this.childlanes = nolanes;\n\n  this.alternate = null;\n\n  if (enableprofilertimer) {\n    // note: the following is done to avoid a v8 performance cliff.\n    //\n    // initializing the fields below to smis and later updating them with\n    // double values will cause fibers to end up having separate shapes.\n    // this behavior/bug has something to do with object.preventextension().\n    // fortunately this only impacts dev builds.\n    // unfortunately it makes react unusably slow for some applications.\n    // to work around this, initialize the fields below with doubles.\n    //\n    // learn more about this here:\n    // https://github.com/facebook/react/issues/14365\n    // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n    this.actualduration = number.nan;\n    this.actualstarttime = number.nan;\n    this.selfbaseduration = number.nan;\n    this.treebaseduration = number.nan;\n\n    // it's okay to replace the initial doubles with smis after initialization.\n    // this won't trigger the performance cliff mentioned above,\n    // and it simplifies other profiler code (including devtools).\n    this.actualduration = 0;\n    this.actualstarttime = -1;\n    this.selfbaseduration = 0;\n    this.treebaseduration = 0;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n\n * rootfiber  fiber  createfiber  fiber tag  hostroot  fiber \n * fiber fiber instance fiber effects lanes instance  fiber tag  fiber fiber  fibertree effects  render lanes alternate \n * uninitializedfiber  rootfiber instance  \n\n\n\n * tag  fiber  fiber \n\nlocal stack\n\nreturn value: fibernode\nactualduration: 0\nactualstarttime: -1\nalternate: null\nchild: null\nchildlanes: 0\ndependencies: null\nelementtype: null\nfirsteffect: null\nflags: 0\nindex: 0\nkey: null\nlanes: 0\nlasteffect: null\nmemoizedprops: null\nmemoizedstate: null\nmode: 8\nnexteffect: null\npendingprops: null\nref: null\nreturn: null\nselfbaseduration: 0\nsibling: null\nstatenode: null\ntag: 3\ntreebaseduration: 0\ntype: null\nupdatequeue: null\n_debughooktypes: null\n_debugid: 1\n_debugneedsremount: false\n_debugowner: null\n_debugsource: null\n[[prototype]]: object\nthis: undefined\nmode: 8\ntag: 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\nworktag fiber \n\n// src/react/packages/react-reconciler/src/reactworktags.js\nexport type worktag =\n  | 0\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12\n  | 13\n  | 14\n  | 15\n  | 16\n  | 17\n  | 18\n  | 19\n  | 20\n  | 21\n  | 22\n  | 23\n  | 24;\n\nexport const functioncomponent = 0; // \nexport const classcomponent = 1; // \nexport const indeterminatecomponent = 2; // before we know whether it is function or class // \nexport const hostroot = 3; // root of a host tree. could be nested inside another node. // hostroot  rootfiber \nexport const hostportal = 4; // a subtree. could be an entry point to a different renderer. // hostportal  portal  hostroot\nexport const hostcomponent = 5;\nexport const hosttext = 6;\nexport const fragment = 7; // react.fragment \nexport const mode = 8;\nexport const contextconsumer = 9; // context.consumer \nexport const contextprovider = 10; //  context.provider \nexport const forwardref = 11; // react.forwardref \nexport const profiler = 12; \nexport const suspensecomponent = 13; // suspense \nexport const memocomponent = 14; // memo \nexport const simplememocomponent = 15; //  compare  memo \nexport const lazycomponent = 16; // react.lazy \nexport const incompleteclasscomponent = 17;\nexport const dehydratedfragment = 18;\nexport const suspenselistcomponent = 19;\nexport const scopecomponent = 21;\nexport const offscreencomponent = 22;\nexport const legacyhiddencomponent = 23;\nexport const cachecomponent = 24;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\nfibernode  fiber  fibertree \n\n\n\n * fiberroot  rootfiber \n * fiber  child sibling return  fibertree  sibling \n * child  return  sibling return  fibertree \n\nlocal stack\n\n\n\n render -> legacyrendersubtreeintocontainer -> legacycreaterootfromdomcontainer -> createcontainer -> createfiberroot -> createhostrootfiber -> createfiber -> ...\n\n\n# flushsync\n\n hostroot  rootfiber\n\nflushsync(() => {\n  updatecontainer(children, fiberroot, parentcomponent, callback);\n});\n\n\n1\n2\n3\n\n\nflushsync  updatecontainer \n\n flushsync \n\n// overload the definition to the two valid signatures.\n// warning, this opts-out of checking the function body.\ndeclare function flushsync<r>(fn: () => r): r;\n// eslint-disable-next-line no-redeclare\ndeclare function flushsync(): void;\n// eslint-disable-next-line no-redeclare\nexport function flushsync(fn) {\n  // in legacy mode, we flush pending passive effects at the beginning of the\n  // next event, not at the end of the previous one.\n  // rootwithpendingpassiveeffects  commit  hostroot\n  //  commit  hostroot rendercontext  commitcontext flush \n  if (\n    rootwithpendingpassiveeffects !== null &&\n    rootwithpendingpassiveeffects.tag === legacyroot &&\n    (executioncontext & (rendercontext | commitcontext)) === nocontext\n  ) {\n    flushpassiveeffects();\n  }\n\n  const prevexecutioncontext = executioncontext;\n  // executioncontext  batchedcontext\n  executioncontext |= batchedcontext;\n\n  const prevtransition = reactcurrentbatchconfig.transition;\n  const previouspriority = getcurrentupdatepriority();\n  try {\n    reactcurrentbatchconfig.transition = 0;\n    setcurrentupdatepriority(discreteeventpriority);\n    if (fn) {\n      return fn();\n    } else {\n      return undefined;\n    }\n  } finally {\n    //  fn  \n    setcurrentupdatepriority(previouspriority);\n    reactcurrentbatchconfig.transition = prevtransition;\n    executioncontext = prevexecutioncontext;\n    // flush the immediate callbacks that were scheduled during this batch.\n    // note that this will happen even if batchedupdates is higher up\n    // the stack.\n    // flush  batch  callbacks\n    if ((executioncontext & (rendercontext | commitcontext)) === nocontext) {\n      flushsynccallbacks();\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n * flushsync  ts \n * flushsync  flushpassiveeffects  commit  hostroot \n * flushsync  commit  flushpassiveeffects batchedcontext \n *  rootwithpendingpassiveeffects  null flushpassiveeffects  flushpassiveeffects \n\n\n# flushpassiveeffects\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nexport function flushpassiveeffects(): boolean {\n  // returns whether passive effects were flushed.\n  // todo: combine this check with the one in flushpassiveeffectsimpl. we should\n  // probably just combine the two functions. i believe they were only separate\n  // in the first place because we used to wrap it with\n  // `scheduler.runwithpriority`, which accepts a function. but now we track the\n  // priority within react itself, so we can mutate the variable directly.\n  if (rootwithpendingpassiveeffects !== null) {\n    // cache the root since rootwithpendingpassiveeffects is cleared in\n    // flushpassiveeffectsimpl\n    //  root \n    const root = rootwithpendingpassiveeffects;\n    // cache and clear the remaining lanes flag; it must be reset since this\n    // method can be called from various places, not always from commitroot\n    // where the remaining lanes are known\n    //  remaininglanes\n    const remaininglanes = pendingpassiveeffectsremaininglanes;\n    pendingpassiveeffectsremaininglanes = nolanes;\n\n    const renderpriority = lanestoeventpriority(pendingpassiveeffectslanes);\n    const priority = lowereventpriority(defaulteventpriority, renderpriority);\n    const prevtransition = reactcurrentbatchconfig.transition;\n    const previouspriority = getcurrentupdatepriority();\n    try {\n      reactcurrentbatchconfig.transition = 0;\n      setcurrentupdatepriority(priority);\n      return flushpassiveeffectsimpl();\n    } finally {\n      // flushpassiveeffectsimpl \n      setcurrentupdatepriority(previouspriority);\n      reactcurrentbatchconfig.transition = prevtransition;\n\n      // once passive effects have run for the tree - giving components a\n      // chance to retain cache instances they use - release the pooled\n      // cache at the root (if there is one)\n      releaserootpooledcache(root, remaininglanes);\n    }\n  }\n  return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n flushpassiveeffectsimpl \n\nfunction flushpassiveeffectsimpl() {\n  if (rootwithpendingpassiveeffects === null) {\n    return false;\n  }\n\n  const root = rootwithpendingpassiveeffects;\n  const lanes = pendingpassiveeffectslanes;\n  //  passiveeffects  flush\n  rootwithpendingpassiveeffects = null;\n  // todo: this is sometimes out of sync with rootwithpendingpassiveeffects.\n  // figure out why and fix it. it's not causing any known issues (probably\n  // because it's only used for profiling), but it's a refactor hazard.\n  pendingpassiveeffectslanes = nolanes;\n\n  // render  commit  flush \n  if ((executioncontext & (rendercontext | commitcontext)) !== nocontext) {\n    throw new error('cannot flush passive effects while already rendering.');\n  }\n\n  const prevexecutioncontext = executioncontext;\n  //  executioncontext  commitcontext commit \n  executioncontext |= commitcontext;\n\n  //  passiveeffects  mount  unmount  commit\n  commitpassiveunmounteffects(root.current);\n  commitpassivemounteffects(root, root.current);\n\n  executioncontext = prevexecutioncontext;\n\n  //  callback  flush\n  flushsynccallbacks();\n\n  // if additional passive effects were scheduled, increment a counter. if this\n  // exceeds the limit, we'll fire a warning.\n  // nestedpassiveupdatecount \n  nestedpassiveupdatecount =\n    rootwithpendingpassiveeffects === null ? 0 : nestedpassiveupdatecount + 1;\n  return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n * flush effects  commit effects\n\n\n# flushsynccallbacks\n\n// src/react/packages/react-reconciler/src/reactfibersynctaskqueue.new.js\nexport function flushsynccallbacks() {\n  // isflushingsyncqueue  syncqueue  \n  if (!isflushingsyncqueue && syncqueue !== null) {\n    // prevent re-entrance.\n    isflushingsyncqueue = true;\n    let i = 0;\n    const previousupdatepriority = getcurrentupdatepriority();\n    try {\n      const issync = true;\n      const queue = syncqueue;\n      // todo: is this necessary anymore? the only user code that runs in this\n      // queue is in the render or commit phases.\n      setcurrentupdatepriority(discreteeventpriority);\n      // flush syncqueue callback  callback\n      for (; i < queue.length; i++) {\n        let callback = queue[i];\n        do {\n          callback = callback(issync);\n        } while (callback !== null);\n      }\n      //  syncqueue\n      syncqueue = null;\n      includeslegacysynccallbacks = false;\n    } catch (error) {\n      // if something throws, leave the remaining callbacks on the queue.\n      // syncqueue  rootcallback \n      if (syncqueue !== null) {\n        syncqueue = syncqueue.slice(i + 1);\n      }\n      // resume flushing in the next tick\n      //  tick \n      schedulecallback(immediatepriority, flushsynccallbacks);\n      throw error;\n    } finally {\n      setcurrentupdatepriority(previousupdatepriority);\n      isflushingsyncqueue = false;\n    }\n  }\n  return null;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\nflushsynccallbacks  syncqueue syncqueue  callback  callback +  syncqueue flush syncqueue  effect  react  effect \n\n *  syncqueue  flushsynccallbacks  syncqueue \n *  next tick  syncqueue \n\n\n# updatecontainer\n\nupdatecontainer \n\nexport function updatecontainer(\n  element: reactnodelist,\n  container: opaqueroot,\n  parentcomponent: ?react$component<any, any>,\n  callback: ?function,\n): lane {\n  //  rootfiber\n  const current = container.current;\n  const eventtime = requesteventtime();\n  const lane = requestupdatelane(current);\n\n  //  container  context \n  const context = getcontextforsubtree(parentcomponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingcontext = context;\n  }\n\n  // \n  const update = createupdate(eventtime, lane);\n  // caution: react devtools currently depends on this property\n  // being called \"element\".\n  update.payload = {element};\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    update.callback = callback;\n  }\n\n  // \n  enqueueupdate(current, update, lane);\n  // \n  const root = scheduleupdateonfiber(current, lane, eventtime);\n  if (root !== null) {\n    entangletransitions(root, current, lane);\n  }\n\n  return lane;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\nupdatecontainer  rootfiber  schedulework  \n\n\n# \n\nreact  hostroot  fiberroot \n\n\n# q&a\n\n\n# executioncontext \n\nexecutioncontext  react  executioncontext \n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nexport const nocontext = /*             */ 0b0000;\nconst batchedcontext = /*               */ 0b0001; // batch()\nconst rendercontext = /*                */ 0b0010; // render()\nconst commitcontext = /*                */ 0b0100; // commit()\nexport const retryaftererror = /*       */ 0b1000; // \n\n// describes where we are in the react execution stack\nlet executioncontext: executioncontext = nocontext;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n executioncontext  nocontent:\n\ncontext                                                                 \nnocontext                                                                  \nbatchedcontext    flushsyncbatchedupdatesflushcontrolled   batch ()    rendersubtreeintocontainer renderroot \nrendercontext     renderrootsyncrenderrootconcurrent        render ()    renderroot commitroot \ncommitcontext     commitrootimplflushpassiveeffectsimpl     commit ()    commitroot \nretryaftererror   recoverfromconcurrenterror                 error          \n\nreact  nocontextbatchedcontextrendercontextcommitcontextretryaftererror  react \n\n\n# \n\nreact  react  effecttagworktag  executioncontext\n\n react \n\nconst nocontext = 0b0000;\nconst batchedcontext =  0b0001; \nconst rendercontext =  0b0010; \nconst commitcontext =  0b0100;\nconst retryaftererror = 0b1000;\n\nlet executioncontext = nocontext;\n\n//  rendercontainer batch \n// \nexecutioncontext |= batchedcontext; // 1\n//  batch \n// 0 1  0  nocontext \n(executioncontext & batchedcontext) !== nocontext; // true\n//  render \n(executioncontext & rendercontext) !== nocontext; // false\n//  renderroot render \nexecutioncontext |= rendercontext;\n//  batch  render \n(executioncontext & (batchedcontext | rendercontext)) !== nocontext; // true\n//  commit  error \n(executioncontext & (commitcontext | retryaftererror)) === nocontext; // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n vue \n\nconst enum shapeflags {\n  element = 1,\n  functional_component = 1 << 1,\n  stateful_component = 1 << 2,\n  text_children = 1 << 3,\n  array_children = 1 << 4,\n  slots_children = 1 << 5,\n  teleport = 1 << 6,\n  suspense = 1 << 7,\n  component_should_keep_alive = 1 << 8,\n  component_kept_alive = 1 << 9,\n  component = shapeflags.stateful_component | shapeflags.functional_component\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n 1\n\n\n\n\n# \n\n *  react  - \n *  react concurrent\n * react ",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"React ",frontmatter:{title:"React ",date:"2022-04-14T22:02:21.000Z",permalink:"/react/summary/event-listener/",categories:["react","summary"],tags:[null]},regularPath:"/10.react/80.%E6%80%BB%E7%BB%93/30.event-listener.html",relativePath:"10.react/80./30.event-listener.md",key:"v-59f008fe",path:"/react/summary/event-listener/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2}],readingTime:{text:"1 min read",minutes:.25,time:15e3,words:50},headersStr:"",content:"# \n\n\n\n * \n\n\n\n// src/react/packages/react-dom/src/events/DOMPluginEventSystem.js\nexport function listenToNativeEvent(\n  // \n  domEventName: DOMEventName,\n  // \n  isCapturePhaseListener: boolean,\n  // container  document\n  target: EventTarget,\n): void {\n\n  let eventSystemFlags = 0;\n  if (isCapturePhaseListener) {\n    eventSystemFlags |= IS_CAPTURE_PHASE;\n  }\n  addTrappedEventListener(\n    target,\n    domEventName,\n    eventSystemFlags,\n    isCapturePhaseListener,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# \n\n\n\n * \n\n\n\n// src/react/packages/react-dom/src/events/domplugineventsystem.js\nexport function listentonativeevent(\n  // \n  domeventname: domeventname,\n  // \n  iscapturephaselistener: boolean,\n  // container  document\n  target: eventtarget,\n): void {\n\n  let eventsystemflags = 0;\n  if (iscapturephaselistener) {\n    eventsystemflags |= is_capture_phase;\n  }\n  addtrappedeventlistener(\n    target,\n    domeventname,\n    eventsystemflags,\n    iscapturephaselistener,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"30  React ",frontmatter:{title:"30  React ",date:"2022-04-14T22:02:21.000Z",permalink:"/react/summary/10-min-react/",categories:["react","summary"],tags:[null]},regularPath:"/10.react/80.%E6%80%BB%E7%BB%93/40.10-min-react.html",relativePath:"10.react/80./40.10-min-react.md",key:"v-5de90ac4",path:"/react/summary/10-min-react/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"ReactDOMHostConfig",slug:"reactdomhostconfig",normalizedTitle:"reactdomhostconfig",charIndex:17},{level:2,title:"updateContainer",slug:"updatecontainer",normalizedTitle:"updatecontainer",charIndex:39},{level:2,title:"scheduleUpdateOnFiber",slug:"scheduleupdateonfiber",normalizedTitle:"scheduleupdateonfiber",charIndex:58},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:85},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:95},{level:2,title:"ensureRootIsScheduled",slug:"ensurerootisscheduled",normalizedTitle:"ensurerootisscheduled",charIndex:104},{level:3,title:"DiscreteEventPriority  ContinuousEventPriority",slug:"discreteeventpriority--continuouseventpriority",normalizedTitle:"discreteeventpriority  continuouseventpriority",charIndex:131},{level:3,title:"scheduleMicrotask  queueMicrotask",slug:"schedulemicrotask--queuemicrotask",normalizedTitle:"schedulemicrotask  queuemicrotask",charIndex:184},{level:2,title:"scheduleSyncCallback  scheduleCallback",slug:"schedulesynccallback--schedulecallback",normalizedTitle:"schedulesynccallback  schedulecallback",charIndex:222},{level:3,title:"scheduleSyncCallback  flushSyncCallbacks",slug:"schedulesynccallback--flushsynccallbacks",normalizedTitle:"schedulesynccallback  flushsynccallbacks",charIndex:267},{level:3,title:"scheduleCallback",slug:"schedulecallback",normalizedTitle:"schedulecallback",charIndex:245},{level:2,title:"performSyncWorkOnRoot",slug:"performsyncworkonroot",normalizedTitle:"performsyncworkonroot",charIndex:334},{level:2,title:"performConcurrentWorkOnRoot",slug:"performconcurrentworkonroot",normalizedTitle:"performconcurrentworkonroot",charIndex:359},{level:3,title:"finishConcurrentRender",slug:"finishconcurrentrender",normalizedTitle:"finishconcurrentrender",charIndex:392},{level:2,title:"renderRootSync",slug:"renderrootsync",normalizedTitle:"renderrootsync",charIndex:418},{level:2,title:"renderRootConcurrent",slug:"renderrootconcurrent",normalizedTitle:"renderrootconcurrent",charIndex:436},{level:3,title:"handleError",slug:"handleerror",normalizedTitle:"handleerror",charIndex:462},{level:2,title:"workLoopSync",slug:"workloopsync",normalizedTitle:"workloopsync",charIndex:477},{level:2,title:"workLoopConcurrent",slug:"workloopconcurrent",normalizedTitle:"workloopconcurrent",charIndex:493},{level:2,title:"performUnitOfWork",slug:"performunitofwork",normalizedTitle:"performunitofwork",charIndex:515},{level:2,title:"beginWork",slug:"beginwork",normalizedTitle:"beginwork",charIndex:536},{level:2,title:"completeUnitOfWork",slug:"completeunitofwork",normalizedTitle:"completeunitofwork",charIndex:549},{level:2,title:"completeWork",slug:"completework",normalizedTitle:"completework",charIndex:571},{level:2,title:"commitRoot",slug:"commitroot",normalizedTitle:"commitroot",charIndex:587}],readingTime:{text:"29 min read",minutes:28.035,time:1682100,words:5607},headersStr:" ReactDOMHostConfig updateContainer scheduleUpdateOnFiber   ensureRootIsScheduled DiscreteEventPriority  ContinuousEventPriority scheduleMicrotask  queueMicrotask scheduleSyncCallback  scheduleCallback scheduleSyncCallback  flushSyncCallbacks scheduleCallback performSyncWorkOnRoot performConcurrentWorkOnRoot finishConcurrentRender renderRootSync renderRootConcurrent handleError workLoopSync workLoopConcurrent performUnitOfWork beginWork completeUnitOfWork completeWork commitRoot",content:"# \n\n\n\n * \n * ReactDOMHostConfig\n * updateContainer\n * scheduleUpdateOnFiber\n   * \n   * \n * ensureRootIsScheduled\n   * DiscreteEventPriority  ContinuousEventPriority\n   * scheduleMicrotask  queueMicrotask\n * scheduleSyncCallback  scheduleCallback\n   * scheduleSyncCallback  flushSyncCallbacks\n   * scheduleCallback\n * performSyncWorkOnRoot\n * performConcurrentWorkOnRoot\n   * finishConcurrentRender\n * renderRootSync\n * renderRootConcurrent\n   * handleError\n * workLoopSync\n * workLoopConcurrent\n * performUnitOfWork\n * beginWork\n * completeUnitOfWork\n * completeWork\n * commitRoot\n\n\n\n\n# ReactDOMHostConfig\n\n updateContainer  scheduleUpdateOnFiber \n\n\n# updateContainer\n\n updateContainer \n\n updateContainer  legacyRenderSubtreeIntoContainerReactDOMRoot.prototype.renderReactDOMRoot.prototype.unmounthydrateRootscheduleRootReactDOMRoot  ReactDOM.createRoot scheduleRoot  src/react/packages/react-reconciler/src/ReactFiberHotReloading.new.js \n\n//  API\nlegacyRenderSubtreeIntoContainer <- ReactDOM.hydrate\n                                 <- ReactDOM.render\n                                 <- ReactDOM.unmountComponentAtNode\n\n\n1\n2\n3\n4\n\n\nupdateContainer  API  updateContainer \n\n// src/react/packages/react-reconciler/src/ReactFiberReconciler.new.js\nexport function updateContainer(\n  // \n  element: ReactNodeList,\n  // \n  container: OpaqueRoot,\n  parentComponent: ?React$Component<any, any>,\n  callback: ?Function,\n): Lane {\n  //  RootFiber\n  const current = container.current;\n  const eventTime = requestEventTime();\n  const lane = requestUpdateLane(current);\n\n  //  container  context \n  const context = getContextForSubtree(parentComponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  // \n  const update = createUpdate(eventTime, lane);\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = {element};\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    update.callback = callback;\n  }\n\n  // \n  enqueueUpdate(current, update, lane);\n  // \n  const root = scheduleUpdateOnFiber(current, lane, eventTime);\n  if (root !== null) {\n    entangleTransitions(root, current, lane);\n  }\n\n  return lane;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\nupdateContainer \n\n *  FiberRoot contextpendingContext\n *  payloadcallback\n *  scheduleUpdateOnFiber() \n\n\n\n 1. createUpdate FC setStateuseContext  dispatchAction this.setState \n 2. scheduleUpdateOnFiber \n\n\n# scheduleUpdateOnFiber\n\n updateContainer  scheduleUpdateOnFiber  fiber RootFiber  fiber \n\n\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\n// Lanes that were updated during the render phase (*not* an interleaved event).\nlet workInProgressRootRenderPhaseUpdatedLanes: Lanes = NoLanes;\n// Whether to root completed, errored, suspended, etc.\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\n\nexport function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {\n  return a | b;\n}\n\nexport function scheduleUpdateOnFiber(\n  //  RootFiber\n  fiber: Fiber,\n  // \n  lane: Lane,\n  eventTime: number,\n): FiberRoot | null {\n  // \n  checkForNestedUpdates();\n  //  fiber  lanesrootFiberRoot = fiber.stateNode updateContainer  fiber  RootFiber\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\n  // FiberRoot  FiberTree \n  if (root === null) {\n    return null;\n  }\n\n  // Mark that the root has a pending update.\n  //  root root.pendingLanes |= lane\n  markRootUpdated(root, lane, eventTime);\n  //  Render  root  HostRoot lane Render  lanes\n  if (\n    (executionContext & RenderContext) !== NoLanes &&\n    root === workInProgressRoot\n  ) {\n    // Track lanes that were updated during the render phase\n    //  lane  workInProgressRootRenderPhaseUpdatedLanes render  RootFiber \n    workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(\n      workInProgressRootRenderPhaseUpdatedLanes,\n      lane,\n    );\n    // \n  } else {\n    if (root === workInProgressRoot) {\n      //  workInProgressRootExitStatus  RootSuspendedWithDelay root  suspend suspended  root \n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // TODO: Make sure this doesn't override pings that happen while we've\n        // already started rendering.\n        markRootSuspended(root, workInProgressRootRenderLanes);\n      }\n    }\n    //  HostRoot \n    ensureRootIsScheduled(root, eventTime);\n    if (\n      lane === SyncLane &&\n      executionContext === NoContext &&\n      (fiber.mode & ConcurrentMode) === NoMode &&\n      // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n      !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)\n    ) {\n      // context  NoContext fiber.mode  ConcurrentMode prd  ReactCurrentActQueue.isBatchingLegacy  true\n      //  workInProgressRootRenderTargetTime  flushSyncCallbacks\n      // \n      // Flush the synchronous work now, unless we're already working or inside\n      // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n      // scheduleCallbackForFiber to preserve the ability to schedule a callback\n      // without immediately flushing it. We only do this for user-initiated\n      // updates, to preserve historical behavior of legacy mode.\n      resetRenderTimer();\n      flushSyncCallbacksOnlyInLegacyMode();\n    }\n  }\n  return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n\n *  fiber  lanes HostRoot\n *  ensureRootIsScheduled HostRoot \n * \n\n scheduleUpdateOnFiber  React \n\n\n\n<- <<< ... \n\nscheduleUpdateOnFiber <- updateDehydratedSuspenseComponent <- updateSuspenseComponent <- attemptEarlyBailoutIfNoScheduledUpdate <- beginWork\n                                                                                      <- beginWork\n                      <- classComponentUpdater[enqueueSetStateenqueueReplaceStateenqueueForceUpdate] <- adoptClassInstance <- mountIndeterminateComponent <- beginWork\n                                                                                                                              <- constructClassInstance <- updateClassComponent <- mountLazyComponent <- beginWork\n                                                                                                                                                                                <- beginWork\n                                                                                                                                                        <- mountIncompleteClassComponent <- beginWork\n                                                                                                        <- callComponentWillMount <- mountClassInstance <- updateClassComponent <- mountLazyComponent <- beginWork\n                                                                                                                                                                                <- beginWork\n                                                                                                                                                        <- mountIncompleteClassComponent <- beginWork\n                                                                                                        <- callComponentWillReceiveProps <- resumeMountClassInstance <- updateClassComponent <<< beginWork\n                                                                                                                                         <- updateClassInstance <<< beginWork\n                      <- [DEV]forceStoreRerender <- updateStoreInstance <- mountSyncExternalStore ...\n                                                                   <- updateSyncExternalStore ...\n                                            <- subscribeToStore ...\n                      <- [enableCache]refreshCache <- mountRefresh ...\n                      <- dispatchReducerAction <- mountReducer <- reducer.dispatch[useReducer]\n                      <- dispatchSetState <- useMutableSource <- stateHook.queue.dispatch <- dispatchAction[queue.reducer(state, dispatch)]  <- useState\n                                          <- mountState <- HooksDispatcherOnMount.useState <- ReactCurrentDispatcher.current <- useState\n                                                        <- mountTransition <- HooksDispatcherOnMount.useTransition <- useTransition\n                                                        <- mountDeferredValue <- HooksDispatcherOnMount.useDeferredValue <- useDeferredValue\n                      <- updateContainer <<< ReactDOM[hydraterenderunmountComponentAtNodecreateRoothydrateRootscheduleRoot]\n                      \x3c!-- <- attemptSynchronousHydration --\x3e\n                      \x3c!-- <- attemptDiscreteHydration --\x3e\n                      \x3c!-- <- attemptContinuousHydration --\x3e\n                      \x3c!-- <- attemptHydrationAtCurrentPriority --\x3e\n\nbeginWork <- workLoopConcurrent <- renderRootConcurrent <- performConcurrentWorkOnRoot <- ensureRootIsScheduled[root.callbackNode] <- scheduleUpdateOnFiber <<< beginWork\n          <- performUnitOfWork <- workLoopSync <- renderRootSync <- performConcurrentWorkOnRoot <<< beginWork\n                               <- workLoopConcurrent <- renderRootConcurrent <- performConcurrentWorkOnRoot <<< beginWork\n\ncommitRoot <- finishConcurrentRender[RootErroredRootSuspendedRootSuspendedWithDelayRootCompleted] <- performConcurrentWorkOnRoot\n           <- performSyncWorkOnRoot\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n\n\n# \n\n scheduleUpdateOnFiber  beginWork beginWork  scheduleUpdateOnFiber\n\n -> dispatchSetStateclassComponentUpdaterdispatchReducerActionupdateContainer \n-> scheduleUpdateOnFiber -> ensureRootIsScheduled -> performSyncWorkOnRootperformConcurrentWorkOnRoot \n-> renderRootSyncrenderRootConcurrent -> workLoopSyncworkLoopConcurrent \n-> performUnitOfWork -> beginWork -> mountupdate  ->  -> commitRoot -> ...\n\n\n1\n2\n3\n4\n\n\n\n\n *  FC setState this.setStateuseReducer  dispatch  ReactDOM  hydraterenderunmountComponentAtNodecreateRoothydrateRootscheduleRoot\n *  ensureRootIsScheduled -> performConcurrentWorkOnRoot  scheduleSyncCallback  scheduleCallback\n *  performSyncWorkOnRootperformConcurrentWorkOnRoot  commitRoot \n * beginWork -> mountupdate  \n * commitRoot  performSyncWorkOnRoot finishConcurrentRender commitRoot  renderRootSync  renderRootSync renderRootSync  commitRoot finishConcurrentRender finishSyncRender \n\n\n\n\n# \n\ndispatchSetStateclassComponentUpdaterdispatchReducerActionupdateContainer  ReactDOM  hydraterenderunmountComponentAtNodecreateRoothydrateRootscheduleRoot mount  ReactDOM API  FC useReducer  dispatch  ConcurrentAPI  useTransitionuseDeferredValue \n\n React  enqueueUpdate( \n\n enqueueUpdate( \n\n * src/react/packages/react-reconciler/src/ReactFiberClassComponent.new.js\n * src/react/packages/react-reconciler/src/ReactFiberHooks.new.js\n * src/react/packages/react-reconciler/src/ReactFiberReconciler.new.js\n * src/react/packages/react-reconciler/src/ReactFiberThrow.new.js\n * src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\n\n\n>> ReactFiberClassComponent\nclassComponentUpdater[enqueueSetStateenqueueReplaceStateenqueueForceUpdate]\n\n>> ReactFiberHooks\ndispatchReducerAction\ndispatchSetState\n\n>> ReactFiberReconciler\nupdateContainer\n\n//  Update  ErrorUpdate\n\n>> ReactFiberThrow\nmarkSuspenseBoundaryShouldCapture <- throwException <- handleError <- renderRootSync/renderRootConcurrent\n\n>> ReactFiberWorkLoop\ncaptureCommitPhaseErrorOnRoot <- captureCommitPhaseError <- safelyCallCommitHookLayoutEffectListMount/safelyCallComponentWillUnmount/safelyCallComponentDidMount/safelyAttachRef/safelyDetachRef/safelyCallDestroy/commitBeforeMutationEffects_complete/commitMutationEffects_begin/commitMutationEffects_complete/commitLayoutMountEffects_complete/reappearLayoutEffects_complete/commitPassiveMountEffects_complete\ncaptureCommitPhaseError <<< ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n\n useTransitionuseDeferredValue  React Concurrent Mode &  (FiberSuspenseuseTransitionuseDeferredValue)\n\n\n\n 1. scheduleUpdateOnFiber  updateContainer  API context props  react  scheduleUpdateOnFiber \n 2. checkForNestedUpdates  scheduleUpdateOnFiber scheduleUpdateOnFiber  react checkForNestedUpdates  nestedUpdateCount  commit  FiberRoot \n 3.  react    \n 4.  root === workInProgressRoot  suspended  workInProgressRoot  null FiberRoot  workInProgressRoot workInProgressRoot  prepareFreshStack  root  prepareFreshStack  renderRootSyncrenderRootConcurrentpingSuspendedRoot  performConcurrentWorkOnRootperformSyncWorkOnRoot  FatalError \n\n\n# ensureRootIsScheduled\n\n scheduleUpdateOnFiber  ensureRootIsScheduled fiber  HostRoot  HostRoot \n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\n  const existingCallbackNode = root.callbackNode;\n\n  // Check if any lanes are being starved by other work. If so, mark them as\n  // expired so we know to work on those next.\n  //  lanes \n  markStarvedLanesAsExpired(root, currentTime);\n\n  // Determine the next lanes to work on, and their priority.\n  //  lanes\n  const nextLanes = getNextLanes(\n    root,\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\n  );\n  //  lanes\n  if (nextLanes === NoLanes) {\n    // Special case: There's nothing to work on.\n    if (existingCallbackNode !== null) {\n      cancelCallback(existingCallbackNode);\n    }\n    root.callbackNode = null;\n    root.callbackPriority = NoLane;\n    return;\n  }\n\n  // We use the highest priority lane to represent the priority of the callback.\n  //  lanes  lane  callback \n  const newCallbackPriority = getHighestPriorityLane(nextLanes);\n\n  // Check if there's an existing task. We may be able to reuse it.\n  const existingCallbackPriority = root.callbackPriority;\n  //  callback callback \n  if (existingCallbackNode != null) {\n    // Cancel the existing callback. We'll schedule a new one below.\n    cancelCallback(existingCallbackNode);\n  }\n\n  // Schedule a new callback.\n  let newCallbackNode;\n  // \n  if (newCallbackPriority === SyncLane) {\n    // Special case: Sync React callbacks are scheduled on a special\n    // internal queue\n    // LegacyRoot \n    if (root.tag === LegacyRoot) {\n      scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));\n    } else {\n      //  performSyncWorkOnRoot\n      scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n    }\n    if (supportsMicrotasks) {\n     // Flush the queue in a microtask.\n     //  \n     scheduleMicrotask(() => {\n       // In Safari, appending an iframe forces microtasks to run.\n       // https://github.com/facebook/react/issues/22459\n       // We don't support running callbacks in the middle of render\n       // or commit so we need to check against that.\n       if (executionContext === NoContext) {\n         // It's only safe to do this conditionally because we always\n         // check for pending work before we exit the task.\n         // \n         flushSyncCallbacks();\n       }\n     });\n    } else {\n      // Flush the queue in an Immediate task.\n      //  ImmediatePriority flushSyncCallbacks \n      scheduleCallback(ImmediateSchedulerPriority, flushSyncCallbacks);\n    }\n    //  newCallbackNode  nullperformSyncWorkOnRoot \n    newCallbackNode = null;\n  } else {\n    let schedulerPriorityLevel;\n    //  lanes \n    switch (lanesToEventPriority(nextLanes)) {\n      // ImmediateSchedulerPriority\n      case DiscreteEventPriority:\n        schedulerPriorityLevel = ImmediateSchedulerPriority;\n        break;\n      // UserBlockingSchedulerPriority\n      case ContinuousEventPriority:\n        schedulerPriorityLevel = UserBlockingSchedulerPriority;\n        break;\n      // NormalSchedulerPriority\n      case DefaultEventPriority:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n      // Idle IdleSchedulerPriority\n      case IdleEventPriority:\n        schedulerPriorityLevel = IdleSchedulerPriority;\n        break;\n      default:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n    }\n    //  performConcurrentWorkOnRootScheduler.scheduleCallback  callbackNode(newTask)\n    newCallbackNode = scheduleCallback(\n      schedulerPriorityLevel,\n      performConcurrentWorkOnRoot.bind(null, root),\n    );\n  }\n  //  callbackPriority  callbackNode \n  root.callbackPriority = newCallbackPriority;\n  root.callbackNode = newCallbackNode;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n\n\n\n *  root  callbackNodecallbackPriority \n *  flushSyncCallbacks scheduleSyncCallback  performSyncWorkOnRoot  syncQueue ImmediateSchedulerPriority  flushSyncCallbacks \n *  nextLanes  performConcurrentWorkOnRoot\n *  scheduleSyncCallbackscheduleCallback scheduleCallback  Scheduler performSyncWorkOnRoot  performConcurrentWorkOnRoot scheduleSyncCallback \n\nnextLanes  Lane \n\n\n\n *  HostRoot  ensureRootIsScheduled  root  fiber  HostRoot  react \n\n\n# DiscreteEventPriority  ContinuousEventPriority\n\n * discreteEventclick, keyup, change\n * userBlockingdragEnter, mouseMove, scroll\n * continuouserror, progress, load\n\nReact \n\n\n# scheduleMicrotask  queueMicrotask\n\n queueMicrotask performSyncWorkOnRoot  setTimeout queueMicrotask  Promise queueMicrotask ()  callback\n\n queueMicrotask\n\n> queueMicrotask adds the function (task) into a queue and each function is executed one by one (FIFO) after the current task has completed its work and when there is no other code waiting to be run before control of the execution context is returned to the browser's event loop.\n\nreact  queueMicrotask \n\nconst localPromise = typeof Promise === 'function' ? Promise : undefined;\nexport const supportsMicrotasks = true;\nexport const scheduleTimeout: any =\n  typeof setTimeout === 'function' ? setTimeout : (undefined: any);\n\nexport const scheduleMicrotask: any =\n  typeof queueMicrotask === 'function'\n    ? queueMicrotask\n    : typeof localPromise !== 'undefined'\n    ? callback =>\n        localPromise\n          .resolve(null)\n          .then(callback)\n          .catch(handleErrorInNextTick)\n    : scheduleTimeout; // TODO: Determine the best fallback here.\n\nfunction handleErrorInNextTick(error) {\n  setTimeout(() => {\n    throw error;\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n\n *  JavaScript  queueMicrotask () \n * An Introduction to JavaScript's queueMicrotask\n * caniuse: queueMicrotask API\n\n\n# scheduleSyncCallback  scheduleCallback\n\n ensureRootIsScheduled ensureRootIsScheduled  scheduleSyncCallback  scheduleCallback\n\n\n# scheduleSyncCallback  flushSyncCallbacks\n\nscheduleSyncCallback  flushSyncCallbacks \n\n// src/react/packages/react-reconciler/src/ReactFiberSyncTaskQueue.new.js\nexport function scheduleSyncCallback(callback: SchedulerCallback) {\n  // Push this callback into an internal queue. We'll flush these either in\n  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.\n  if (syncQueue === null) {\n    syncQueue = [callback];\n  } else {\n    // Push onto existing queue. Don't need to schedule a callback because\n    // we already scheduled one when we created the queue.\n    syncQueue.push(callback);\n  }\n}\n\nexport function flushSyncCallbacks() {\n  // isFlushingSyncQueue  syncQueue  callbacks \n  if (!isFlushingSyncQueue && syncQueue !== null) {\n    // Prevent re-entrance.\n    isFlushingSyncQueue = true;\n    let i = 0;\n    const previousUpdatePriority = getCurrentUpdatePriority();\n    try {\n      const isSync = true;\n      const queue = syncQueue;\n      // TODO: Is this necessary anymore? The only user code that runs in this\n      // queue is in the render or commit phases.\n      setCurrentUpdatePriority(DiscreteEventPriority);\n      // flush syncQueue callback  callback\n      for (; i < queue.length; i++) {\n        let callback = queue[i];\n        do {\n          callback = callback(isSync);\n        } while (callback !== null);\n      }\n      //  syncQueue\n      syncQueue = null;\n      includesLegacySyncCallbacks = false;\n    } catch (error) {\n      // If something throws, leave the remaining callbacks on the queue.\n      // syncQueue  RootCallback \n      if (syncQueue !== null) {\n        syncQueue = syncQueue.slice(i + 1);\n      }\n      // Resume flushing in the next tick\n      // \n      scheduleCallback(ImmediatePriority, flushSyncCallbacks);\n      throw error;\n    } finally {\n      setCurrentUpdatePriority(previousUpdatePriority);\n      isFlushingSyncQueue = false;\n    }\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n\n *  syncQueue flush syncQueue\n\n React   flushSyncCallbacks \n\n\n# scheduleCallback\n\n react  performSyncWorkOnRoot\n\n\n\n\n# performSyncWorkOnRoot\n\n performSyncWorkOnRoot \n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\n// This is the entry point for synchronous tasks that don't go\n// through Scheduler\nfunction performSyncWorkOnRoot(root) {\n  //  Render  Commit  Batch \n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n  //  Render  effects  callbacks \n  flushPassiveEffects();\n  //  lanes\n  let lanes = getNextLanes(root, NoLanes);\n  //  lanes  SyncLane renderRootSync ensureRootIsScheduled \n  if (!includesSomeLane(lanes, SyncLane)) {\n    // There's no remaining sync work left.\n    ensureRootIsScheduled(root, now());\n    return null;\n  }\n  //  render HostRoot workInProgressRootExitStatus \n  //  RootIncompleteRootFatalErroredRootErroredRootSuspendedRootSuspendedWithDelayRootCompleted\n  let exitStatus = renderRootSync(root, lanes);\n  //  50 \n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\n    // If something threw an error, try rendering one more time. We'll render\n    // synchronously to block concurrent data mutations, and we'll includes\n    // all pending updates are included. If it still fails after the second\n    // attempt, we'll give up and commit the resulting tree.\n    const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n    if (errorRetryLanes !== NoLanes) {\n      lanes = errorRetryLanes;\n      exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n    }\n  }\n  //  HostRoot  suspend \n  if (exitStatus === RootFatalErrored) {\n    const fatalError = workInProgressRootFatalError;\n    prepareFreshStack(root, NoLanes);\n    markRootSuspended(root, lanes);\n    ensureRootIsScheduled(root, now());\n    throw fatalError;\n  }\n\n  // We now have a consistent tree. Because this is a sync render, we\n  // will commit it even if something suspended.\n  //  RootFiber  lanes  HostRoot \n  const finishedWork: Fiber = (root.current.alternate: any);\n  root.finishedWork = finishedWork;\n  root.finishedLanes = lanes;\n  //  HostRoot  yield \n  commitRoot(root);\n\n  // Before exiting, make sure there's a callback scheduled for the next\n  // pending level.\n  //  renderSync \n  ensureRootIsScheduled(root, now());\n\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n\n * flushPassiveEffects  flushSyncCallbackscommitPassiveUnmountEffectscommitPassiveMountEffects  performSyncWorkOnRoot  scheduleSyncCallback  performSyncWorkOnRoot  renderRootSync  SyncCallbacks\n *  renderRootSync  render  commit \n * commitRoot  raf \n * performSyncWorkOnRoot  ensureRootIsScheduled\n * performSyncWorkOnRoot  Scheduler \n\n\n\n *  renderRootSync \n * \n *  commitRoot  HostRoot  paint\n\n\n# performConcurrentWorkOnRoot\n\n performConcurrentWorkOnRoot  performConcurrentWorkOnRoot  performSyncWorkOnRoot \n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\n// If two updates are scheduled within the same event, we should treat their\n// event times as simultaneous, even if the actual clock time has advanced\n// between the first and second call.\nlet currentEventTime: number = NoTimestamp;\n\n// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  // Since we know we're in a React event, we can clear the current\n  // event time. The next update will compute a new event time.\n  currentEventTime = NoTimestamp;\n  currentEventTransitionLane = NoLanes;\n  //  Render  Commit  Batch \n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  // Flush any pending passive effects before deciding which lanes to work on,\n  // in case they schedule additional work.\n  const originalCallbackNode = root.callbackNode;\n  //  RenderConcurrent  callbacks  effects\n  const didFlushPassiveEffects = flushPassiveEffects();\n  if (didFlushPassiveEffects) {\n    // Something in the passive effect phase may have canceled the current task.\n    // Check if the task node for this root was changed.\n    //  flushPassiveEffects  callbackNode \n    if (root.callbackNode !== originalCallbackNode) {\n      // The current task was canceled. Exit. We don't need to call\n      // `ensureRootIsScheduled` because the check above implies either that\n      // there's a new task, or that there's no remaining work on this root.\n      return null;\n    } else {\n      // Current task was not canceled. Continue.\n    }\n  }\n\n  // Determine the next lanes to work on, using the fields stored\n  // on the root.\n  //  lanes\n  let lanes = getNextLanes(\n    root,\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\n  );\n  if (lanes === NoLanes) {\n    // Defensive coding. This is never expected to happen.\n    return null;\n  }\n\n  // We disable time-slicing in some cases: if the work has been CPU-bound\n  // for too long (\"expired\" work, to prevent starvation), or we're in\n  // sync-updates-by-default mode.\n  //  Render  Render\n  //  Blocking  lane  line  Render \n  const shouldTimeSlice =\n    !includesBlockingLane(root, lanes) &&\n    !includesExpiredLane(root, lanes) &&\n    (disableSchedulerTimeoutInWorkLoop || !didTimeout);\n  let exitStatus = shouldTimeSlice\n    ? renderRootConcurrent(root, lanes)\n    : renderRootSync(root, lanes);\n  //  Render  RootIncomplete\n  if (exitStatus !== RootIncomplete) {\n    if (exitStatus === RootErrored) {\n      // If something threw an error, try rendering one more time. We'll\n      // render synchronously to block concurrent data mutations, and we'll\n      // includes all pending updates are included. If it still fails after\n      // the second attempt, we'll give up and commit the resulting tree.\n      // \n      const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n      if (errorRetryLanes !== NoLanes) {\n        lanes = errorRetryLanes;\n        exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n      }\n    }\n    if (exitStatus === RootFatalErrored) {\n      const fatalError = workInProgressRootFatalError;\n      prepareFreshStack(root, NoLanes);\n      markRootSuspended(root, lanes);\n      ensureRootIsScheduled(root, now());\n      throw fatalError;\n    }\n\n    // Check if this render may have yielded to a concurrent event, and if so,\n    // confirm that any newly rendered stores are consistent.\n    const renderWasConcurrent = !includesBlockingLane(root, lanes);\n    const finishedWork: Fiber = (root.current.alternate: any);\n    if (\n      renderWasConcurrent &&\n      !isRenderConsistentWithExternalStores(finishedWork)\n    ) {\n      // A store was mutated in an interleaved event. Render again,\n      // synchronously, to block further mutations.\n      exitStatus = renderRootSync(root, lanes);\n\n      // We need to check again if something threw\n      if (exitStatus === RootErrored) {\n        const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n        if (errorRetryLanes !== NoLanes) {\n          lanes = errorRetryLanes;\n          exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n          // We assume the tree is now consistent because we didn't yield to any\n          // concurrent events.\n        }\n      }\n      if (exitStatus === RootFatalErrored) {\n        const fatalError = workInProgressRootFatalError;\n        prepareFreshStack(root, NoLanes);\n        markRootSuspended(root, lanes);\n        ensureRootIsScheduled(root, now());\n        throw fatalError;\n      }\n    }\n\n    // We now have a consistent tree. The next step is either to commit it,\n    // or, if something suspended, wait to commit it after a timeout.\n    root.finishedWork = finishedWork;\n    root.finishedLanes = lanes;\n    finishConcurrentRender(root, exitStatus, lanes);\n  }\n  //  Render \n  ensureRootIsScheduled(root, now());\n  //  HostRoot performConcurrentWorkOnRoot\n  // ensureRootIsScheduled  newCallbackNode root.callbackNode\n  if (root.callbackNode === originalCallbackNode) {\n    // The task node scheduled for this root is the same one that's\n    // currently executed. Need to return a continuation.\n    return performConcurrentWorkOnRoot.bind(null, root);\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n\n * currentEventTime  scheduleUpdateOnFiber  createUpdate  performConcurrentWorkOnRoot  update  eventTime\n * performConcurrentWorkOnRoot  Scheduler  performSyncWorkOnRoot \n * performSyncWorkOnRoot  performConcurrentWorkOnRoot  executionContext  renderRoot\n *  RenderConcurrent  callbacks  effects  callbacks  effects root.callbackNode  RenderRoot \n *  RenderRoot  lanes  lanes  blocking  renderRootSync  renderRootConcurrent \n * recoverFromConcurrentError  50  renderRootSync \n *  RenderRoot  ensureRootIsScheduled  HostRoot  HostRoot \n\n\n# finishConcurrentRender\n\n exitStatus  commitRoot \n\nfunction finishConcurrentRender(root, exitStatus, lanes) {\n  switch (exitStatus) {\n    //  performConcurrentWorkOnRoot \n    case RootIncomplete:\n    case RootFatalErrored: {\n      throw new Error('Root did not complete. This is a bug in React.');\n    }\n    // RootErrored  performConcurrentWorkOnRoot  commitRoot\n    case RootErrored: {\n      // We should have already attempted to retry this tree. If we reached\n      // this point, it errored again. Commit it.\n      commitRoot(root);\n      break;\n    }\n    //  renderRoot  RootSuspended HostRoot  suspended\n    case RootSuspended: {\n      markRootSuspended(root, lanes);\n\n      // We have an acceptable loading state. We need to figure out if we\n      // should immediately commit it or wait a bit.\n\n      if (\n        includesOnlyRetries(lanes) &&\n        // do not delay if we're inside an act() scope\n        !shouldForceFlushFallbacksInDEV()\n      ) {\n        // This render only included retries, no updates. Throttle committing\n        // retries so that we don't show too many loading states too quickly.\n        const msUntilTimeout =\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\n        // Don't bother with a very short suspense time.\n        if (msUntilTimeout > 10) {\n          const nextLanes = getNextLanes(root, NoLanes);\n          if (nextLanes !== NoLanes) {\n            // There's additional work on this root.\n            break;\n          }\n          const suspendedLanes = root.suspendedLanes;\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\n            // We should prefer to render the fallback of at the last\n            // suspended level. Ping the last suspended level to try\n            // rendering it again.\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\n            const eventTime = requestEventTime();\n            markRootPinged(root, suspendedLanes, eventTime);\n            break;\n          }\n\n          // The render is suspended, it hasn't timed out, and there's no\n          // lower priority work to do. Instead of committing the fallback\n          // immediately, wait for more data to arrive.\n          //  root.timeoutHandle  commitRoot\n          root.timeoutHandle = scheduleTimeout(\n            commitRoot.bind(null, root),\n            msUntilTimeout,\n          );\n          break;\n        }\n      }\n      // The work expired. Commit immediately.\n      commitRoot(root);\n      break;\n    }\n    case RootSuspendedWithDelay: {\n      markRootSuspended(root, lanes);\n\n      if (includesOnlyTransitions(lanes)) {\n        // This is a transition, so we should exit without committing a\n        // placeholder and without scheduling a timeout. Delay indefinitely\n        // until we receive more data.\n        break;\n      }\n\n      if (!shouldForceFlushFallbacksInDEV()) {\n        // This is not a transition, but we did trigger an avoided state.\n        // Schedule a placeholder to display after a short delay, using the Just\n        // Noticeable Difference.\n        // TODO: Is the JND optimization worth the added complexity? If this is\n        // the only reason we track the event time, then probably not.\n        // Consider removing.\n\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\n        const eventTimeMs = mostRecentEventTime;\n        const timeElapsedMs = now() - eventTimeMs;\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\n\n        // Don't bother with a very short suspense time.\n        if (msUntilTimeout > 10) {\n          // Instead of committing the fallback immediately, wait for more data\n          // to arrive.\n          root.timeoutHandle = scheduleTimeout(\n            commitRoot.bind(null, root),\n            msUntilTimeout,\n          );\n          break;\n        }\n      }\n\n      // Commit the placeholder.\n      commitRoot(root);\n      break;\n    }\n    //  RootCompleted commitRoot\n    case RootCompleted: {\n      // The work completed. Ready to commit.\n      commitRoot(root);\n      break;\n    }\n    default: {\n      throw new Error('Unknown root exit status.');\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n\n\n\n# renderRootSync\n\n performSyncWorkOnRoot  performConcurrentWorkOnRoot  renderRootSync  commitRoot \n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\n  //  executionContext\n  const prevExecutionContext = executionContext;\n  //  RenderContext  executionContext \n  executionContext |= RenderContext;\n  //  ReactCurrentDispatcher.currentReactCurrentDispatcher.current  ContextOnlyDispatcher\n  const prevDispatcher = pushDispatcher();\n\n  // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n  //  workInProgressRoot  workInProgressRootRenderLanes  root  lanes  root  workInProgress \n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    prepareFreshStack(root, lanes);\n  }\n  //  workLoopSync handleError  workLoopSync \n  do {\n    try {\n      workLoopSync();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n  //  workLoopSync \n  resetContextDependencies();\n  //  executionContext  RenderContext  CommitContext  BatchedContext\n  executionContext = prevExecutionContext;\n  //  ReactCurrentDispatcher.currentReactCurrentDispatcher.current  prevDispatcher\n  popDispatcher(prevDispatcher);\n  // workLoopSync workInProgress \n  if (workInProgress !== null) {\n    // This is a sync render, so we should have finished the whole tree.\n    throw new Error(\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\n        'bug in React. Please file an issue.',\n    );\n  }\n  //  workInProgress  workInProgressRoot  workInProgressRootRenderLanes\n  // Set this to null to indicate there's no in-progress render.\n  workInProgressRoot = null;\n  workInProgressRootRenderLanes = NoLanes;\n  // workInProgressRootExitStatus  HostRoot workLoopSync \n  return workInProgressRootExitStatus;\n}\n\nexport function resetContextDependencies(): void {\n  // This is called right before React yields execution, to ensure `readContext`\n  // cannot be called outside the render phase.\n  currentlyRenderingFiber = null;\n  lastContextDependency = null;\n  lastFullyObservedContext = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n *  executionContext  executionContext  workLoopSync  renderRoot  executionContext  RenderContext workLoop  executionContext  CommitContext executionContext  BatchContext\n *  renderRoot ReactCurrentDispatcher.current  ContextOnlyDispatcher useState  useReducer   ReactCurrentDispatcher.current  dispatcher  hooks hook  throwInvalidHookError \n *  workLoopSync  workLoopSync \n *  workInProgressworkInProgressRootworkInProgressRootRenderLanes \n\nexport const ContextOnlyDispatcher: Dispatcher = {\n  readContext,\n\n  useCallback: throwInvalidHookError,\n  useContext: throwInvalidHookError,\n  useEffect: throwInvalidHookError,\n  useImperativeHandle: throwInvalidHookError,\n  useInsertionEffect: throwInvalidHookError,\n  useLayoutEffect: throwInvalidHookError,\n  useMemo: throwInvalidHookError,\n  useReducer: throwInvalidHookError,\n  useRef: throwInvalidHookError,\n  useState: throwInvalidHookError,\n  useDebugValue: throwInvalidHookError,\n  useDeferredValue: throwInvalidHookError,\n  useTransition: throwInvalidHookError,\n  useMutableSource: throwInvalidHookError,\n  useSyncExternalStore: throwInvalidHookError,\n  useId: throwInvalidHookError,\n\n  unstable_isNewReconciler: enableNewReconciler,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# renderRootConcurrent\n\n performConcurrentWorkOnRoot  renderRootConcurrent  renderRootSync \n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\n  const prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  const prevDispatcher = pushDispatcher();\n\n  // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    resetRenderTimer();\n    prepareFreshStack(root, lanes);\n  }\n\n  do {\n    try {\n      workLoopConcurrent();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n  resetContextDependencies();\n\n  popDispatcher(prevDispatcher);\n  executionContext = prevExecutionContext;\n\n  // Check if the tree has completed.\n  if (workInProgress !== null) {\n    return RootIncomplete;\n  } else {\n    // Set this to null to indicate there's no in-progress render.\n    workInProgressRoot = null;\n    workInProgressRootRenderLanes = NoLanes;\n\n    // Return the final exit status.\n    return workInProgressRootExitStatus;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n *  workLoopConcurrent  workLoopConcurrent \n *  renderRootConcurrent workLoopConcurrent workInProgress  null  workLoopSync  exitStatus  RootIncomplete\n\n\n# handleError\n\nfunction handleError(root, thrownValue): void {\n  do {\n    let erroredWork = workInProgress;\n    try {\n      // Reset module-level state that was set during the render phase.\n      resetContextDependencies();\n      resetHooksAfterThrow();\n      // TODO: I found and added this missing line while investigating a\n      // separate issue. Write a regression test using string refs.\n      ReactCurrentOwner.current = null;\n\n      //  workInProgress  workInProgress.return \n      if (erroredWork === null || erroredWork.return === null) {\n        // Expected to be working on a non-root fiber. This is a fatal error\n        // because there's no ancestor that can handle it; the root is\n        // supposed to capture all errors that weren't caught by an error\n        // boundary.\n        workInProgressRootExitStatus = RootFatalErrored;\n        workInProgressRootFatalError = thrownValue;\n        // Set `workInProgress` to null. This represents advancing to the next\n        // sibling, or the parent if there are no siblings. But since the root\n        // has no siblings nor a parent, we set it to null. Usually this is\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n        // intentionally not calling those, we need set it here.\n        // TODO: Consider calling `unwindWork` to pop the contexts.\n        workInProgress = null;\n        return;\n      }\n\n      // \n      throwException(\n        root,\n        erroredWork.return,\n        erroredWork,\n        thrownValue,\n        workInProgressRootRenderLanes,\n      );\n      completeUnitOfWork(erroredWork);\n    } catch (yetAnotherThrownValue) {\n      // Something in the return path also threw.\n      //  workInProgress  workInProgress.return  erroredWork\n      thrownValue = yetAnotherThrownValue;\n      if (workInProgress === erroredWork && erroredWork !== null) {\n        // If this boundary has already errored, then we had trouble processing\n        // the error. Bubble it to the next boundary.\n        erroredWork = erroredWork.return;\n        workInProgress = erroredWork;\n      } else {\n        erroredWork = workInProgress;\n      }\n      continue;\n    }\n    //  yetAnotherThrownValue  work loop\n    // Return to the normal work loop.\n    return;\n  } while (true);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n *  workInProgress  nullexitStatus \n *  completeUnitOfWork  workInProgress  null workLoop\n * \n\n\n# workLoopSync\n\nrenderRootSync  workLoopSync  workLoopSync \n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\n// The work loop is an extremely hot path. Tell Closure not to inline it.\n/** @noinline */\nfunction workLoopSync() {\n  // Already timed out, so perform work without checking if we need to yield.\n  while (workInProgress !== null) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n *  workInProgress  performUnitOfWork  workInProgress HostRoot  Fiber \n * @noinline  chrome  Google Closure Compiler  inline@noinline js  inline  vue  @noinline  inline \n\n\n\ninline \n\nIn computing, inline expansion, or inlining, is a manual or compiler optimization that replaces a function call site with the body of the called function. Inline expansion is similar to macro expansion, but occurs during compilation, without changing the source code (the text), while macro expansion occurs prior to compilation, and results in different text that is then processed by the compiler.\n\n * Inline expansion\n\n\n# workLoopConcurrent\n\n renderRootConcurrent  workLoopConcurrent workLoopConcurrent  workLoopSync \n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\n/** @noinline */\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * workInProgress  null  shouldYield  workLoopConcurrent  (yield) \n\n\n# performUnitOfWork\n\n workLoopSync  workLoopConcurrent  performUnitOfWork performUnitOfWork performUnitOfWork \n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\nfunction performUnitOfWork(unitOfWork: Fiber): void {\n  // The current, flushed, state of this fiber is the alternate. Ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  const current = unitOfWork.alternate;\n\n  let next;\n \n  next = beginWork(current, unitOfWork, subtreeRenderLanes);\n\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n\n  ReactCurrentOwner.current = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n *  fiber  Reconciliation  Fiber  fiber.alternate  fiber  fiber  fiber.alternate unitOfWork  fiber current  fiber \n * beginWork  workInProgress  render fiber beginWork  fiber \n *  next  null  fiber render  completeUnitOfWork completeUnitOfWork  renderRootSync  renderRootConcurrent  handlerError  next  workInProgress performUnitOfWork  next  render\n\n\n# beginWork\n\n performUnitOfWork  beginWork  RootFiber  fiber FiberTree  beginWork\n\n// src/react/packages/react-reconciler/src/ReactFiberBeginWork.new.js\n\nfunction beginWork(\n  //  fiber\n  current: Fiber | null,\n  //  fiber\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  // \n  if (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n\n    if (\n      oldProps !== newProps ||\n      hasLegacyContextChanged() ||\n      // Force a re-render if the implementation changed due to hot reload:\n      (__DEV__ ? workInProgress.type !== current.type : false)\n    ) {\n      // If props or context changed, mark the fiber as having performed work.\n      // This may be unset if the props are determined to be equal later (memo).\n      didReceiveUpdate = true;\n    } else {\n      // Neither props nor legacy context changes. Check if there's a pending\n      // update or context change.\n      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(\n        current,\n        renderLanes,\n      );\n      if (\n        !hasScheduledUpdateOrContext &&\n        // If this is the second pass of an error or suspense boundary, there\n        // may not be work scheduled on `current`, so we check for this flag.\n        (workInProgress.flags & DidCapture) === NoFlags\n      ) {\n        // No pending updates or context. Bail out now.\n        didReceiveUpdate = false;\n        return attemptEarlyBailoutIfNoScheduledUpdate(\n          current,\n          workInProgress,\n          renderLanes,\n        );\n      }\n      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      } else {\n        // An update was scheduled on this fiber, but there are no new props\n        // nor legacy context. Set this to false. If an update queue or context\n        // consumer produces a changed value, it will set this to true. Otherwise,\n        // the component will assume the children have not changed and bail out.\n        didReceiveUpdate = false;\n      }\n    }\n  } else {\n    didReceiveUpdate = false;\n\n    if (getIsHydrating() && isForkedChild(workInProgress)) {\n      // Check if this child belongs to a list of muliple children in\n      // its parent.\n      //\n      // In a true multi-threaded implementation, we would render children on\n      // parallel threads. This would represent the beginning of a new render\n      // thread for this subtree.\n      //\n      // We only use this for id generation during hydration, which is why the\n      // logic is located in this special branch.\n      // index  fiber \n      const slotIndex = workInProgress.index;\n      const numberOfForks = getForksAtLevel(workInProgress);\n      pushTreeId(workInProgress, numberOfForks, slotIndex);\n    }\n  }\n\n  // Before entering the begin phase, clear pending update priority.\n  // TODO: This assumes that we're about to evaluate the component and process\n  // the update queue. However, there's an exception: SimpleMemoComponent\n  // sometimes bails out later in the begin phase. This indicates that we should\n  // move this assignment out of the common path and into each branch.\n  // \n  workInProgress.lanes = NoLanes;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent: {\n      return mountIndeterminateComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        renderLanes,\n      );\n    }\n    case LazyComponent: {\n      const elementType = workInProgress.elementType;\n      return mountLazyComponent(\n        current,\n        workInProgress,\n        elementType,\n        renderLanes,\n      );\n    }\n    case FunctionComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateFunctionComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderLanes);\n    case HostComponent:\n      return updateHostComponent(current, workInProgress, renderLanes);\n    case HostText:\n      return updateHostText(current, workInProgress);\n    case SuspenseComponent:\n      return updateSuspenseComponent(current, workInProgress, renderLanes);\n    case HostPortal:\n      return updatePortalComponent(current, workInProgress, renderLanes);\n    case ForwardRef: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === type\n          ? unresolvedProps\n          : resolveDefaultProps(type, unresolvedProps);\n      return updateForwardRef(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case Fragment:\n      return updateFragment(current, workInProgress, renderLanes);\n    case Mode:\n      return updateMode(current, workInProgress, renderLanes);\n    case Profiler:\n      return updateProfiler(current, workInProgress, renderLanes);\n    case ContextProvider:\n      return updateContextProvider(current, workInProgress, renderLanes);\n    case ContextConsumer:\n      return updateContextConsumer(current, workInProgress, renderLanes);\n    case MemoComponent: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      // Resolve outer props first, then resolve inner props.\n      let resolvedProps = resolveDefaultProps(type, unresolvedProps);\n      if (__DEV__) {\n        if (workInProgress.type !== workInProgress.elementType) {\n          const outerPropTypes = type.propTypes;\n          if (outerPropTypes) {\n            checkPropTypes(\n              outerPropTypes,\n              resolvedProps, // Resolved for outer only\n              'prop',\n              getComponentNameFromType(type),\n            );\n          }\n        }\n      }\n      resolvedProps = resolveDefaultProps(type.type, resolvedProps);\n      return updateMemoComponent(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case SimpleMemoComponent: {\n      return updateSimpleMemoComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes,\n      );\n    }\n    case IncompleteClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return mountIncompleteClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case SuspenseListComponent: {\n      return updateSuspenseListComponent(current, workInProgress, renderLanes);\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        return updateScopeComponent(current, workInProgress, renderLanes);\n      }\n      break;\n    }\n    case OffscreenComponent: {\n      return updateOffscreenComponent(current, workInProgress, renderLanes);\n    }\n    case LegacyHiddenComponent: {\n      return updateLegacyHiddenComponent(current, workInProgress, renderLanes);\n    }\n    case CacheComponent: {\n      if (enableCache) {\n        return updateCacheComponent(current, workInProgress, renderLanes);\n      }\n      break;\n    }\n  }\n\n  throw new Error(\n    `Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` +\n      'React. Please file an issue.',\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n\n * didReceiveUpdate  context  re-render\n *  workInProgress.tag  workLoop  performUnitOfWork \n *  updateXXXComponent  workInProgress.child  performUnitOfWork  next react  performUnitOfWork DFS\n\n\n# completeUnitOfWork\n\n\n# completeWork\n\n\n# commitRoot",normalizedContent:"# \n\n\n\n * \n * reactdomhostconfig\n * updatecontainer\n * scheduleupdateonfiber\n   * \n   * \n * ensurerootisscheduled\n   * discreteeventpriority  continuouseventpriority\n   * schedulemicrotask  queuemicrotask\n * schedulesynccallback  schedulecallback\n   * schedulesynccallback  flushsynccallbacks\n   * schedulecallback\n * performsyncworkonroot\n * performconcurrentworkonroot\n   * finishconcurrentrender\n * renderrootsync\n * renderrootconcurrent\n   * handleerror\n * workloopsync\n * workloopconcurrent\n * performunitofwork\n * beginwork\n * completeunitofwork\n * completework\n * commitroot\n\n\n\n\n# reactdomhostconfig\n\n updatecontainer  scheduleupdateonfiber \n\n\n# updatecontainer\n\n updatecontainer \n\n updatecontainer  legacyrendersubtreeintocontainerreactdomroot.prototype.renderreactdomroot.prototype.unmounthydraterootschedulerootreactdomroot  reactdom.createroot scheduleroot  src/react/packages/react-reconciler/src/reactfiberhotreloading.new.js \n\n//  api\nlegacyrendersubtreeintocontainer <- reactdom.hydrate\n                                 <- reactdom.render\n                                 <- reactdom.unmountcomponentatnode\n\n\n1\n2\n3\n4\n\n\nupdatecontainer  api  updatecontainer \n\n// src/react/packages/react-reconciler/src/reactfiberreconciler.new.js\nexport function updatecontainer(\n  // \n  element: reactnodelist,\n  // \n  container: opaqueroot,\n  parentcomponent: ?react$component<any, any>,\n  callback: ?function,\n): lane {\n  //  rootfiber\n  const current = container.current;\n  const eventtime = requesteventtime();\n  const lane = requestupdatelane(current);\n\n  //  container  context \n  const context = getcontextforsubtree(parentcomponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingcontext = context;\n  }\n\n  // \n  const update = createupdate(eventtime, lane);\n  // caution: react devtools currently depends on this property\n  // being called \"element\".\n  update.payload = {element};\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    update.callback = callback;\n  }\n\n  // \n  enqueueupdate(current, update, lane);\n  // \n  const root = scheduleupdateonfiber(current, lane, eventtime);\n  if (root !== null) {\n    entangletransitions(root, current, lane);\n  }\n\n  return lane;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\nupdatecontainer \n\n *  fiberroot contextpendingcontext\n *  payloadcallback\n *  scheduleupdateonfiber() \n\n\n\n 1. createupdate fc setstateusecontext  dispatchaction this.setstate \n 2. scheduleupdateonfiber \n\n\n# scheduleupdateonfiber\n\n updatecontainer  scheduleupdateonfiber  fiber rootfiber  fiber \n\n\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\n// lanes that were updated during the render phase (*not* an interleaved event).\nlet workinprogressrootrenderphaseupdatedlanes: lanes = nolanes;\n// whether to root completed, errored, suspended, etc.\nlet workinprogressrootexitstatus: rootexitstatus = rootincomplete;\n\nexport function mergelanes(a: lanes | lane, b: lanes | lane): lanes {\n  return a | b;\n}\n\nexport function scheduleupdateonfiber(\n  //  rootfiber\n  fiber: fiber,\n  // \n  lane: lane,\n  eventtime: number,\n): fiberroot | null {\n  // \n  checkfornestedupdates();\n  //  fiber  lanesrootfiberroot = fiber.statenode updatecontainer  fiber  rootfiber\n  const root = markupdatelanefromfibertoroot(fiber, lane);\n  // fiberroot  fibertree \n  if (root === null) {\n    return null;\n  }\n\n  // mark that the root has a pending update.\n  //  root root.pendinglanes |= lane\n  markrootupdated(root, lane, eventtime);\n  //  render  root  hostroot lane render  lanes\n  if (\n    (executioncontext & rendercontext) !== nolanes &&\n    root === workinprogressroot\n  ) {\n    // track lanes that were updated during the render phase\n    //  lane  workinprogressrootrenderphaseupdatedlanes render  rootfiber \n    workinprogressrootrenderphaseupdatedlanes = mergelanes(\n      workinprogressrootrenderphaseupdatedlanes,\n      lane,\n    );\n    // \n  } else {\n    if (root === workinprogressroot) {\n      //  workinprogressrootexitstatus  rootsuspendedwithdelay root  suspend suspended  root \n      if (workinprogressrootexitstatus === rootsuspendedwithdelay) {\n        // the root already suspended with a delay, which means this render\n        // definitely won't finish. since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. this has the\n        // effect of interrupting the current render and switching to the update.\n        // todo: make sure this doesn't override pings that happen while we've\n        // already started rendering.\n        markrootsuspended(root, workinprogressrootrenderlanes);\n      }\n    }\n    //  hostroot \n    ensurerootisscheduled(root, eventtime);\n    if (\n      lane === synclane &&\n      executioncontext === nocontext &&\n      (fiber.mode & concurrentmode) === nomode &&\n      // treat `act` as if it's inside `batchedupdates`, even in legacy mode.\n      !(__dev__ && reactcurrentactqueue.isbatchinglegacy)\n    ) {\n      // context  nocontext fiber.mode  concurrentmode prd  reactcurrentactqueue.isbatchinglegacy  true\n      //  workinprogressrootrendertargettime  flushsynccallbacks\n      // \n      // flush the synchronous work now, unless we're already working or inside\n      // a batch. this is intentionally inside scheduleupdateonfiber instead of\n      // schedulecallbackforfiber to preserve the ability to schedule a callback\n      // without immediately flushing it. we only do this for user-initiated\n      // updates, to preserve historical behavior of legacy mode.\n      resetrendertimer();\n      flushsynccallbacksonlyinlegacymode();\n    }\n  }\n  return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n\n *  fiber  lanes hostroot\n *  ensurerootisscheduled hostroot \n * \n\n scheduleupdateonfiber  react \n\n\n\n<- <<< ... \n\nscheduleupdateonfiber <- updatedehydratedsuspensecomponent <- updatesuspensecomponent <- attemptearlybailoutifnoscheduledupdate <- beginwork\n                                                                                      <- beginwork\n                      <- classcomponentupdater[enqueuesetstateenqueuereplacestateenqueueforceupdate] <- adoptclassinstance <- mountindeterminatecomponent <- beginwork\n                                                                                                                              <- constructclassinstance <- updateclasscomponent <- mountlazycomponent <- beginwork\n                                                                                                                                                                                <- beginwork\n                                                                                                                                                        <- mountincompleteclasscomponent <- beginwork\n                                                                                                        <- callcomponentwillmount <- mountclassinstance <- updateclasscomponent <- mountlazycomponent <- beginwork\n                                                                                                                                                                                <- beginwork\n                                                                                                                                                        <- mountincompleteclasscomponent <- beginwork\n                                                                                                        <- callcomponentwillreceiveprops <- resumemountclassinstance <- updateclasscomponent <<< beginwork\n                                                                                                                                         <- updateclassinstance <<< beginwork\n                      <- [dev]forcestorererender <- updatestoreinstance <- mountsyncexternalstore ...\n                                                                   <- updatesyncexternalstore ...\n                                            <- subscribetostore ...\n                      <- [enablecache]refreshcache <- mountrefresh ...\n                      <- dispatchreduceraction <- mountreducer <- reducer.dispatch[usereducer]\n                      <- dispatchsetstate <- usemutablesource <- statehook.queue.dispatch <- dispatchaction[queue.reducer(state, dispatch)]  <- usestate\n                                          <- mountstate <- hooksdispatcheronmount.usestate <- reactcurrentdispatcher.current <- usestate\n                                                        <- mounttransition <- hooksdispatcheronmount.usetransition <- usetransition\n                                                        <- mountdeferredvalue <- hooksdispatcheronmount.usedeferredvalue <- usedeferredvalue\n                      <- updatecontainer <<< reactdom[hydraterenderunmountcomponentatnodecreateroothydraterootscheduleroot]\n                      \x3c!-- <- attemptsynchronoushydration --\x3e\n                      \x3c!-- <- attemptdiscretehydration --\x3e\n                      \x3c!-- <- attemptcontinuoushydration --\x3e\n                      \x3c!-- <- attempthydrationatcurrentpriority --\x3e\n\nbeginwork <- workloopconcurrent <- renderrootconcurrent <- performconcurrentworkonroot <- ensurerootisscheduled[root.callbacknode] <- scheduleupdateonfiber <<< beginwork\n          <- performunitofwork <- workloopsync <- renderrootsync <- performconcurrentworkonroot <<< beginwork\n                               <- workloopconcurrent <- renderrootconcurrent <- performconcurrentworkonroot <<< beginwork\n\ncommitroot <- finishconcurrentrender[rooterroredrootsuspendedrootsuspendedwithdelayrootcompleted] <- performconcurrentworkonroot\n           <- performsyncworkonroot\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n\n\n# \n\n scheduleupdateonfiber  beginwork beginwork  scheduleupdateonfiber\n\n -> dispatchsetstateclasscomponentupdaterdispatchreduceractionupdatecontainer \n-> scheduleupdateonfiber -> ensurerootisscheduled -> performsyncworkonrootperformconcurrentworkonroot \n-> renderrootsyncrenderrootconcurrent -> workloopsyncworkloopconcurrent \n-> performunitofwork -> beginwork -> mountupdate  ->  -> commitroot -> ...\n\n\n1\n2\n3\n4\n\n\n\n\n *  fc setstate this.setstateusereducer  dispatch  reactdom  hydraterenderunmountcomponentatnodecreateroothydraterootscheduleroot\n *  ensurerootisscheduled -> performconcurrentworkonroot  schedulesynccallback  schedulecallback\n *  performsyncworkonrootperformconcurrentworkonroot  commitroot \n * beginwork -> mountupdate  \n * commitroot  performsyncworkonroot finishconcurrentrender commitroot  renderrootsync  renderrootsync renderrootsync  commitroot finishconcurrentrender finishsyncrender \n\n\n\n\n# \n\ndispatchsetstateclasscomponentupdaterdispatchreduceractionupdatecontainer  reactdom  hydraterenderunmountcomponentatnodecreateroothydraterootscheduleroot mount  reactdom api  fc usereducer  dispatch  concurrentapi  usetransitionusedeferredvalue \n\n react  enqueueupdate( \n\n enqueueupdate( \n\n * src/react/packages/react-reconciler/src/reactfiberclasscomponent.new.js\n * src/react/packages/react-reconciler/src/reactfiberhooks.new.js\n * src/react/packages/react-reconciler/src/reactfiberreconciler.new.js\n * src/react/packages/react-reconciler/src/reactfiberthrow.new.js\n * src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\n\n\n>> reactfiberclasscomponent\nclasscomponentupdater[enqueuesetstateenqueuereplacestateenqueueforceupdate]\n\n>> reactfiberhooks\ndispatchreduceraction\ndispatchsetstate\n\n>> reactfiberreconciler\nupdatecontainer\n\n//  update  errorupdate\n\n>> reactfiberthrow\nmarksuspenseboundaryshouldcapture <- throwexception <- handleerror <- renderrootsync/renderrootconcurrent\n\n>> reactfiberworkloop\ncapturecommitphaseerroronroot <- capturecommitphaseerror <- safelycallcommithooklayouteffectlistmount/safelycallcomponentwillunmount/safelycallcomponentdidmount/safelyattachref/safelydetachref/safelycalldestroy/commitbeforemutationeffects_complete/commitmutationeffects_begin/commitmutationeffects_complete/commitlayoutmounteffects_complete/reappearlayouteffects_complete/commitpassivemounteffects_complete\ncapturecommitphaseerror <<< ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n\n usetransitionusedeferredvalue  react concurrent mode &  (fibersuspenseusetransitionusedeferredvalue)\n\n\n\n 1. scheduleupdateonfiber  updatecontainer  api context props  react  scheduleupdateonfiber \n 2. checkfornestedupdates  scheduleupdateonfiber scheduleupdateonfiber  react checkfornestedupdates  nestedupdatecount  commit  fiberroot \n 3.  react    \n 4.  root === workinprogressroot  suspended  workinprogressroot  null fiberroot  workinprogressroot workinprogressroot  preparefreshstack  root  preparefreshstack  renderrootsyncrenderrootconcurrentpingsuspendedroot  performconcurrentworkonrootperformsyncworkonroot  fatalerror \n\n\n# ensurerootisscheduled\n\n scheduleupdateonfiber  ensurerootisscheduled fiber  hostroot  hostroot \n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\nfunction ensurerootisscheduled(root: fiberroot, currenttime: number) {\n  const existingcallbacknode = root.callbacknode;\n\n  // check if any lanes are being starved by other work. if so, mark them as\n  // expired so we know to work on those next.\n  //  lanes \n  markstarvedlanesasexpired(root, currenttime);\n\n  // determine the next lanes to work on, and their priority.\n  //  lanes\n  const nextlanes = getnextlanes(\n    root,\n    root === workinprogressroot ? workinprogressrootrenderlanes : nolanes,\n  );\n  //  lanes\n  if (nextlanes === nolanes) {\n    // special case: there's nothing to work on.\n    if (existingcallbacknode !== null) {\n      cancelcallback(existingcallbacknode);\n    }\n    root.callbacknode = null;\n    root.callbackpriority = nolane;\n    return;\n  }\n\n  // we use the highest priority lane to represent the priority of the callback.\n  //  lanes  lane  callback \n  const newcallbackpriority = gethighestprioritylane(nextlanes);\n\n  // check if there's an existing task. we may be able to reuse it.\n  const existingcallbackpriority = root.callbackpriority;\n  //  callback callback \n  if (existingcallbacknode != null) {\n    // cancel the existing callback. we'll schedule a new one below.\n    cancelcallback(existingcallbacknode);\n  }\n\n  // schedule a new callback.\n  let newcallbacknode;\n  // \n  if (newcallbackpriority === synclane) {\n    // special case: sync react callbacks are scheduled on a special\n    // internal queue\n    // legacyroot \n    if (root.tag === legacyroot) {\n      schedulelegacysynccallback(performsyncworkonroot.bind(null, root));\n    } else {\n      //  performsyncworkonroot\n      schedulesynccallback(performsyncworkonroot.bind(null, root));\n    }\n    if (supportsmicrotasks) {\n     // flush the queue in a microtask.\n     //  \n     schedulemicrotask(() => {\n       // in safari, appending an iframe forces microtasks to run.\n       // https://github.com/facebook/react/issues/22459\n       // we don't support running callbacks in the middle of render\n       // or commit so we need to check against that.\n       if (executioncontext === nocontext) {\n         // it's only safe to do this conditionally because we always\n         // check for pending work before we exit the task.\n         // \n         flushsynccallbacks();\n       }\n     });\n    } else {\n      // flush the queue in an immediate task.\n      //  immediatepriority flushsynccallbacks \n      schedulecallback(immediateschedulerpriority, flushsynccallbacks);\n    }\n    //  newcallbacknode  nullperformsyncworkonroot \n    newcallbacknode = null;\n  } else {\n    let schedulerprioritylevel;\n    //  lanes \n    switch (lanestoeventpriority(nextlanes)) {\n      // immediateschedulerpriority\n      case discreteeventpriority:\n        schedulerprioritylevel = immediateschedulerpriority;\n        break;\n      // userblockingschedulerpriority\n      case continuouseventpriority:\n        schedulerprioritylevel = userblockingschedulerpriority;\n        break;\n      // normalschedulerpriority\n      case defaulteventpriority:\n        schedulerprioritylevel = normalschedulerpriority;\n        break;\n      // idle idleschedulerpriority\n      case idleeventpriority:\n        schedulerprioritylevel = idleschedulerpriority;\n        break;\n      default:\n        schedulerprioritylevel = normalschedulerpriority;\n        break;\n    }\n    //  performconcurrentworkonrootscheduler.schedulecallback  callbacknode(newtask)\n    newcallbacknode = schedulecallback(\n      schedulerprioritylevel,\n      performconcurrentworkonroot.bind(null, root),\n    );\n  }\n  //  callbackpriority  callbacknode \n  root.callbackpriority = newcallbackpriority;\n  root.callbacknode = newcallbacknode;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n\n\n\n *  root  callbacknodecallbackpriority \n *  flushsynccallbacks schedulesynccallback  performsyncworkonroot  syncqueue immediateschedulerpriority  flushsynccallbacks \n *  nextlanes  performconcurrentworkonroot\n *  schedulesynccallbackschedulecallback schedulecallback  scheduler performsyncworkonroot  performconcurrentworkonroot schedulesynccallback \n\nnextlanes  lane \n\n\n\n *  hostroot  ensurerootisscheduled  root  fiber  hostroot  react \n\n\n# discreteeventpriority  continuouseventpriority\n\n * discreteeventclick, keyup, change\n * userblockingdragenter, mousemove, scroll\n * continuouserror, progress, load\n\nreact \n\n\n# schedulemicrotask  queuemicrotask\n\n queuemicrotask performsyncworkonroot  settimeout queuemicrotask  promise queuemicrotask ()  callback\n\n queuemicrotask\n\n> queuemicrotask adds the function (task) into a queue and each function is executed one by one (fifo) after the current task has completed its work and when there is no other code waiting to be run before control of the execution context is returned to the browser's event loop.\n\nreact  queuemicrotask \n\nconst localpromise = typeof promise === 'function' ? promise : undefined;\nexport const supportsmicrotasks = true;\nexport const scheduletimeout: any =\n  typeof settimeout === 'function' ? settimeout : (undefined: any);\n\nexport const schedulemicrotask: any =\n  typeof queuemicrotask === 'function'\n    ? queuemicrotask\n    : typeof localpromise !== 'undefined'\n    ? callback =>\n        localpromise\n          .resolve(null)\n          .then(callback)\n          .catch(handleerrorinnexttick)\n    : scheduletimeout; // todo: determine the best fallback here.\n\nfunction handleerrorinnexttick(error) {\n  settimeout(() => {\n    throw error;\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n\n *  javascript  queuemicrotask () \n * an introduction to javascript's queuemicrotask\n * caniuse: queuemicrotask api\n\n\n# schedulesynccallback  schedulecallback\n\n ensurerootisscheduled ensurerootisscheduled  schedulesynccallback  schedulecallback\n\n\n# schedulesynccallback  flushsynccallbacks\n\nschedulesynccallback  flushsynccallbacks \n\n// src/react/packages/react-reconciler/src/reactfibersynctaskqueue.new.js\nexport function schedulesynccallback(callback: schedulercallback) {\n  // push this callback into an internal queue. we'll flush these either in\n  // the next tick, or earlier if something calls `flushsynccallbackqueue`.\n  if (syncqueue === null) {\n    syncqueue = [callback];\n  } else {\n    // push onto existing queue. don't need to schedule a callback because\n    // we already scheduled one when we created the queue.\n    syncqueue.push(callback);\n  }\n}\n\nexport function flushsynccallbacks() {\n  // isflushingsyncqueue  syncqueue  callbacks \n  if (!isflushingsyncqueue && syncqueue !== null) {\n    // prevent re-entrance.\n    isflushingsyncqueue = true;\n    let i = 0;\n    const previousupdatepriority = getcurrentupdatepriority();\n    try {\n      const issync = true;\n      const queue = syncqueue;\n      // todo: is this necessary anymore? the only user code that runs in this\n      // queue is in the render or commit phases.\n      setcurrentupdatepriority(discreteeventpriority);\n      // flush syncqueue callback  callback\n      for (; i < queue.length; i++) {\n        let callback = queue[i];\n        do {\n          callback = callback(issync);\n        } while (callback !== null);\n      }\n      //  syncqueue\n      syncqueue = null;\n      includeslegacysynccallbacks = false;\n    } catch (error) {\n      // if something throws, leave the remaining callbacks on the queue.\n      // syncqueue  rootcallback \n      if (syncqueue !== null) {\n        syncqueue = syncqueue.slice(i + 1);\n      }\n      // resume flushing in the next tick\n      // \n      schedulecallback(immediatepriority, flushsynccallbacks);\n      throw error;\n    } finally {\n      setcurrentupdatepriority(previousupdatepriority);\n      isflushingsyncqueue = false;\n    }\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n\n *  syncqueue flush syncqueue\n\n react   flushsynccallbacks \n\n\n# schedulecallback\n\n react  performsyncworkonroot\n\n\n\n\n# performsyncworkonroot\n\n performsyncworkonroot \n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\n// this is the entry point for synchronous tasks that don't go\n// through scheduler\nfunction performsyncworkonroot(root) {\n  //  render  commit  batch \n  if ((executioncontext & (rendercontext | commitcontext)) !== nocontext) {\n    throw new error('should not already be working.');\n  }\n  //  render  effects  callbacks \n  flushpassiveeffects();\n  //  lanes\n  let lanes = getnextlanes(root, nolanes);\n  //  lanes  synclane renderrootsync ensurerootisscheduled \n  if (!includessomelane(lanes, synclane)) {\n    // there's no remaining sync work left.\n    ensurerootisscheduled(root, now());\n    return null;\n  }\n  //  render hostroot workinprogressrootexitstatus \n  //  rootincompleterootfatalerroredrooterroredrootsuspendedrootsuspendedwithdelayrootcompleted\n  let exitstatus = renderrootsync(root, lanes);\n  //  50 \n  if (root.tag !== legacyroot && exitstatus === rooterrored) {\n    // if something threw an error, try rendering one more time. we'll render\n    // synchronously to block concurrent data mutations, and we'll includes\n    // all pending updates are included. if it still fails after the second\n    // attempt, we'll give up and commit the resulting tree.\n    const errorretrylanes = getlanestoretrysynchronouslyonerror(root);\n    if (errorretrylanes !== nolanes) {\n      lanes = errorretrylanes;\n      exitstatus = recoverfromconcurrenterror(root, errorretrylanes);\n    }\n  }\n  //  hostroot  suspend \n  if (exitstatus === rootfatalerrored) {\n    const fatalerror = workinprogressrootfatalerror;\n    preparefreshstack(root, nolanes);\n    markrootsuspended(root, lanes);\n    ensurerootisscheduled(root, now());\n    throw fatalerror;\n  }\n\n  // we now have a consistent tree. because this is a sync render, we\n  // will commit it even if something suspended.\n  //  rootfiber  lanes  hostroot \n  const finishedwork: fiber = (root.current.alternate: any);\n  root.finishedwork = finishedwork;\n  root.finishedlanes = lanes;\n  //  hostroot  yield \n  commitroot(root);\n\n  // before exiting, make sure there's a callback scheduled for the next\n  // pending level.\n  //  rendersync \n  ensurerootisscheduled(root, now());\n\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n\n * flushpassiveeffects  flushsynccallbackscommitpassiveunmounteffectscommitpassivemounteffects  performsyncworkonroot  schedulesynccallback  performsyncworkonroot  renderrootsync  synccallbacks\n *  renderrootsync  render  commit \n * commitroot  raf \n * performsyncworkonroot  ensurerootisscheduled\n * performsyncworkonroot  scheduler \n\n\n\n *  renderrootsync \n * \n *  commitroot  hostroot  paint\n\n\n# performconcurrentworkonroot\n\n performconcurrentworkonroot  performconcurrentworkonroot  performsyncworkonroot \n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\n// if two updates are scheduled within the same event, we should treat their\n// event times as simultaneous, even if the actual clock time has advanced\n// between the first and second call.\nlet currenteventtime: number = notimestamp;\n\n// this is the entry point for every concurrent task, i.e. anything that\n// goes through scheduler.\nfunction performconcurrentworkonroot(root, didtimeout) {\n  // since we know we're in a react event, we can clear the current\n  // event time. the next update will compute a new event time.\n  currenteventtime = notimestamp;\n  currenteventtransitionlane = nolanes;\n  //  render  commit  batch \n  if ((executioncontext & (rendercontext | commitcontext)) !== nocontext) {\n    throw new error('should not already be working.');\n  }\n\n  // flush any pending passive effects before deciding which lanes to work on,\n  // in case they schedule additional work.\n  const originalcallbacknode = root.callbacknode;\n  //  renderconcurrent  callbacks  effects\n  const didflushpassiveeffects = flushpassiveeffects();\n  if (didflushpassiveeffects) {\n    // something in the passive effect phase may have canceled the current task.\n    // check if the task node for this root was changed.\n    //  flushpassiveeffects  callbacknode \n    if (root.callbacknode !== originalcallbacknode) {\n      // the current task was canceled. exit. we don't need to call\n      // `ensurerootisscheduled` because the check above implies either that\n      // there's a new task, or that there's no remaining work on this root.\n      return null;\n    } else {\n      // current task was not canceled. continue.\n    }\n  }\n\n  // determine the next lanes to work on, using the fields stored\n  // on the root.\n  //  lanes\n  let lanes = getnextlanes(\n    root,\n    root === workinprogressroot ? workinprogressrootrenderlanes : nolanes,\n  );\n  if (lanes === nolanes) {\n    // defensive coding. this is never expected to happen.\n    return null;\n  }\n\n  // we disable time-slicing in some cases: if the work has been cpu-bound\n  // for too long (\"expired\" work, to prevent starvation), or we're in\n  // sync-updates-by-default mode.\n  //  render  render\n  //  blocking  lane  line  render \n  const shouldtimeslice =\n    !includesblockinglane(root, lanes) &&\n    !includesexpiredlane(root, lanes) &&\n    (disableschedulertimeoutinworkloop || !didtimeout);\n  let exitstatus = shouldtimeslice\n    ? renderrootconcurrent(root, lanes)\n    : renderrootsync(root, lanes);\n  //  render  rootincomplete\n  if (exitstatus !== rootincomplete) {\n    if (exitstatus === rooterrored) {\n      // if something threw an error, try rendering one more time. we'll\n      // render synchronously to block concurrent data mutations, and we'll\n      // includes all pending updates are included. if it still fails after\n      // the second attempt, we'll give up and commit the resulting tree.\n      // \n      const errorretrylanes = getlanestoretrysynchronouslyonerror(root);\n      if (errorretrylanes !== nolanes) {\n        lanes = errorretrylanes;\n        exitstatus = recoverfromconcurrenterror(root, errorretrylanes);\n      }\n    }\n    if (exitstatus === rootfatalerrored) {\n      const fatalerror = workinprogressrootfatalerror;\n      preparefreshstack(root, nolanes);\n      markrootsuspended(root, lanes);\n      ensurerootisscheduled(root, now());\n      throw fatalerror;\n    }\n\n    // check if this render may have yielded to a concurrent event, and if so,\n    // confirm that any newly rendered stores are consistent.\n    const renderwasconcurrent = !includesblockinglane(root, lanes);\n    const finishedwork: fiber = (root.current.alternate: any);\n    if (\n      renderwasconcurrent &&\n      !isrenderconsistentwithexternalstores(finishedwork)\n    ) {\n      // a store was mutated in an interleaved event. render again,\n      // synchronously, to block further mutations.\n      exitstatus = renderrootsync(root, lanes);\n\n      // we need to check again if something threw\n      if (exitstatus === rooterrored) {\n        const errorretrylanes = getlanestoretrysynchronouslyonerror(root);\n        if (errorretrylanes !== nolanes) {\n          lanes = errorretrylanes;\n          exitstatus = recoverfromconcurrenterror(root, errorretrylanes);\n          // we assume the tree is now consistent because we didn't yield to any\n          // concurrent events.\n        }\n      }\n      if (exitstatus === rootfatalerrored) {\n        const fatalerror = workinprogressrootfatalerror;\n        preparefreshstack(root, nolanes);\n        markrootsuspended(root, lanes);\n        ensurerootisscheduled(root, now());\n        throw fatalerror;\n      }\n    }\n\n    // we now have a consistent tree. the next step is either to commit it,\n    // or, if something suspended, wait to commit it after a timeout.\n    root.finishedwork = finishedwork;\n    root.finishedlanes = lanes;\n    finishconcurrentrender(root, exitstatus, lanes);\n  }\n  //  render \n  ensurerootisscheduled(root, now());\n  //  hostroot performconcurrentworkonroot\n  // ensurerootisscheduled  newcallbacknode root.callbacknode\n  if (root.callbacknode === originalcallbacknode) {\n    // the task node scheduled for this root is the same one that's\n    // currently executed. need to return a continuation.\n    return performconcurrentworkonroot.bind(null, root);\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n\n * currenteventtime  scheduleupdateonfiber  createupdate  performconcurrentworkonroot  update  eventtime\n * performconcurrentworkonroot  scheduler  performsyncworkonroot \n * performsyncworkonroot  performconcurrentworkonroot  executioncontext  renderroot\n *  renderconcurrent  callbacks  effects  callbacks  effects root.callbacknode  renderroot \n *  renderroot  lanes  lanes  blocking  renderrootsync  renderrootconcurrent \n * recoverfromconcurrenterror  50  renderrootsync \n *  renderroot  ensurerootisscheduled  hostroot  hostroot \n\n\n# finishconcurrentrender\n\n exitstatus  commitroot \n\nfunction finishconcurrentrender(root, exitstatus, lanes) {\n  switch (exitstatus) {\n    //  performconcurrentworkonroot \n    case rootincomplete:\n    case rootfatalerrored: {\n      throw new error('root did not complete. this is a bug in react.');\n    }\n    // rooterrored  performconcurrentworkonroot  commitroot\n    case rooterrored: {\n      // we should have already attempted to retry this tree. if we reached\n      // this point, it errored again. commit it.\n      commitroot(root);\n      break;\n    }\n    //  renderroot  rootsuspended hostroot  suspended\n    case rootsuspended: {\n      markrootsuspended(root, lanes);\n\n      // we have an acceptable loading state. we need to figure out if we\n      // should immediately commit it or wait a bit.\n\n      if (\n        includesonlyretries(lanes) &&\n        // do not delay if we're inside an act() scope\n        !shouldforceflushfallbacksindev()\n      ) {\n        // this render only included retries, no updates. throttle committing\n        // retries so that we don't show too many loading states too quickly.\n        const msuntiltimeout =\n          globalmostrecentfallbacktime + fallback_throttle_ms - now();\n        // don't bother with a very short suspense time.\n        if (msuntiltimeout > 10) {\n          const nextlanes = getnextlanes(root, nolanes);\n          if (nextlanes !== nolanes) {\n            // there's additional work on this root.\n            break;\n          }\n          const suspendedlanes = root.suspendedlanes;\n          if (!issubsetoflanes(suspendedlanes, lanes)) {\n            // we should prefer to render the fallback of at the last\n            // suspended level. ping the last suspended level to try\n            // rendering it again.\n            // fixme: what if the suspended lanes are idle? should not restart.\n            const eventtime = requesteventtime();\n            markrootpinged(root, suspendedlanes, eventtime);\n            break;\n          }\n\n          // the render is suspended, it hasn't timed out, and there's no\n          // lower priority work to do. instead of committing the fallback\n          // immediately, wait for more data to arrive.\n          //  root.timeouthandle  commitroot\n          root.timeouthandle = scheduletimeout(\n            commitroot.bind(null, root),\n            msuntiltimeout,\n          );\n          break;\n        }\n      }\n      // the work expired. commit immediately.\n      commitroot(root);\n      break;\n    }\n    case rootsuspendedwithdelay: {\n      markrootsuspended(root, lanes);\n\n      if (includesonlytransitions(lanes)) {\n        // this is a transition, so we should exit without committing a\n        // placeholder and without scheduling a timeout. delay indefinitely\n        // until we receive more data.\n        break;\n      }\n\n      if (!shouldforceflushfallbacksindev()) {\n        // this is not a transition, but we did trigger an avoided state.\n        // schedule a placeholder to display after a short delay, using the just\n        // noticeable difference.\n        // todo: is the jnd optimization worth the added complexity? if this is\n        // the only reason we track the event time, then probably not.\n        // consider removing.\n\n        const mostrecenteventtime = getmostrecenteventtime(root, lanes);\n        const eventtimems = mostrecenteventtime;\n        const timeelapsedms = now() - eventtimems;\n        const msuntiltimeout = jnd(timeelapsedms) - timeelapsedms;\n\n        // don't bother with a very short suspense time.\n        if (msuntiltimeout > 10) {\n          // instead of committing the fallback immediately, wait for more data\n          // to arrive.\n          root.timeouthandle = scheduletimeout(\n            commitroot.bind(null, root),\n            msuntiltimeout,\n          );\n          break;\n        }\n      }\n\n      // commit the placeholder.\n      commitroot(root);\n      break;\n    }\n    //  rootcompleted commitroot\n    case rootcompleted: {\n      // the work completed. ready to commit.\n      commitroot(root);\n      break;\n    }\n    default: {\n      throw new error('unknown root exit status.');\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n\n\n\n# renderrootsync\n\n performsyncworkonroot  performconcurrentworkonroot  renderrootsync  commitroot \n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\nfunction renderrootsync(root: fiberroot, lanes: lanes) {\n  //  executioncontext\n  const prevexecutioncontext = executioncontext;\n  //  rendercontext  executioncontext \n  executioncontext |= rendercontext;\n  //  reactcurrentdispatcher.currentreactcurrentdispatcher.current  contextonlydispatcher\n  const prevdispatcher = pushdispatcher();\n\n  // if the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. otherwise we'll continue where we left off.\n  //  workinprogressroot  workinprogressrootrenderlanes  root  lanes  root  workinprogress \n  if (workinprogressroot !== root || workinprogressrootrenderlanes !== lanes) {\n    preparefreshstack(root, lanes);\n  }\n  //  workloopsync handleerror  workloopsync \n  do {\n    try {\n      workloopsync();\n      break;\n    } catch (thrownvalue) {\n      handleerror(root, thrownvalue);\n    }\n  } while (true);\n  //  workloopsync \n  resetcontextdependencies();\n  //  executioncontext  rendercontext  commitcontext  batchedcontext\n  executioncontext = prevexecutioncontext;\n  //  reactcurrentdispatcher.currentreactcurrentdispatcher.current  prevdispatcher\n  popdispatcher(prevdispatcher);\n  // workloopsync workinprogress \n  if (workinprogress !== null) {\n    // this is a sync render, so we should have finished the whole tree.\n    throw new error(\n      'cannot commit an incomplete root. this error is likely caused by a ' +\n        'bug in react. please file an issue.',\n    );\n  }\n  //  workinprogress  workinprogressroot  workinprogressrootrenderlanes\n  // set this to null to indicate there's no in-progress render.\n  workinprogressroot = null;\n  workinprogressrootrenderlanes = nolanes;\n  // workinprogressrootexitstatus  hostroot workloopsync \n  return workinprogressrootexitstatus;\n}\n\nexport function resetcontextdependencies(): void {\n  // this is called right before react yields execution, to ensure `readcontext`\n  // cannot be called outside the render phase.\n  currentlyrenderingfiber = null;\n  lastcontextdependency = null;\n  lastfullyobservedcontext = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n *  executioncontext  executioncontext  workloopsync  renderroot  executioncontext  rendercontext workloop  executioncontext  commitcontext executioncontext  batchcontext\n *  renderroot reactcurrentdispatcher.current  contextonlydispatcher usestate  usereducer   reactcurrentdispatcher.current  dispatcher  hooks hook  throwinvalidhookerror \n *  workloopsync  workloopsync \n *  workinprogressworkinprogressrootworkinprogressrootrenderlanes \n\nexport const contextonlydispatcher: dispatcher = {\n  readcontext,\n\n  usecallback: throwinvalidhookerror,\n  usecontext: throwinvalidhookerror,\n  useeffect: throwinvalidhookerror,\n  useimperativehandle: throwinvalidhookerror,\n  useinsertioneffect: throwinvalidhookerror,\n  uselayouteffect: throwinvalidhookerror,\n  usememo: throwinvalidhookerror,\n  usereducer: throwinvalidhookerror,\n  useref: throwinvalidhookerror,\n  usestate: throwinvalidhookerror,\n  usedebugvalue: throwinvalidhookerror,\n  usedeferredvalue: throwinvalidhookerror,\n  usetransition: throwinvalidhookerror,\n  usemutablesource: throwinvalidhookerror,\n  usesyncexternalstore: throwinvalidhookerror,\n  useid: throwinvalidhookerror,\n\n  unstable_isnewreconciler: enablenewreconciler,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# renderrootconcurrent\n\n performconcurrentworkonroot  renderrootconcurrent  renderrootsync \n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\nfunction renderrootconcurrent(root: fiberroot, lanes: lanes) {\n  const prevexecutioncontext = executioncontext;\n  executioncontext |= rendercontext;\n  const prevdispatcher = pushdispatcher();\n\n  // if the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. otherwise we'll continue where we left off.\n  if (workinprogressroot !== root || workinprogressrootrenderlanes !== lanes) {\n    resetrendertimer();\n    preparefreshstack(root, lanes);\n  }\n\n  do {\n    try {\n      workloopconcurrent();\n      break;\n    } catch (thrownvalue) {\n      handleerror(root, thrownvalue);\n    }\n  } while (true);\n  resetcontextdependencies();\n\n  popdispatcher(prevdispatcher);\n  executioncontext = prevexecutioncontext;\n\n  // check if the tree has completed.\n  if (workinprogress !== null) {\n    return rootincomplete;\n  } else {\n    // set this to null to indicate there's no in-progress render.\n    workinprogressroot = null;\n    workinprogressrootrenderlanes = nolanes;\n\n    // return the final exit status.\n    return workinprogressrootexitstatus;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n *  workloopconcurrent  workloopconcurrent \n *  renderrootconcurrent workloopconcurrent workinprogress  null  workloopsync  exitstatus  rootincomplete\n\n\n# handleerror\n\nfunction handleerror(root, thrownvalue): void {\n  do {\n    let erroredwork = workinprogress;\n    try {\n      // reset module-level state that was set during the render phase.\n      resetcontextdependencies();\n      resethooksafterthrow();\n      // todo: i found and added this missing line while investigating a\n      // separate issue. write a regression test using string refs.\n      reactcurrentowner.current = null;\n\n      //  workinprogress  workinprogress.return \n      if (erroredwork === null || erroredwork.return === null) {\n        // expected to be working on a non-root fiber. this is a fatal error\n        // because there's no ancestor that can handle it; the root is\n        // supposed to capture all errors that weren't caught by an error\n        // boundary.\n        workinprogressrootexitstatus = rootfatalerrored;\n        workinprogressrootfatalerror = thrownvalue;\n        // set `workinprogress` to null. this represents advancing to the next\n        // sibling, or the parent if there are no siblings. but since the root\n        // has no siblings nor a parent, we set it to null. usually this is\n        // handled by `completeunitofwork` or `unwindwork`, but since we're\n        // intentionally not calling those, we need set it here.\n        // todo: consider calling `unwindwork` to pop the contexts.\n        workinprogress = null;\n        return;\n      }\n\n      // \n      throwexception(\n        root,\n        erroredwork.return,\n        erroredwork,\n        thrownvalue,\n        workinprogressrootrenderlanes,\n      );\n      completeunitofwork(erroredwork);\n    } catch (yetanotherthrownvalue) {\n      // something in the return path also threw.\n      //  workinprogress  workinprogress.return  erroredwork\n      thrownvalue = yetanotherthrownvalue;\n      if (workinprogress === erroredwork && erroredwork !== null) {\n        // if this boundary has already errored, then we had trouble processing\n        // the error. bubble it to the next boundary.\n        erroredwork = erroredwork.return;\n        workinprogress = erroredwork;\n      } else {\n        erroredwork = workinprogress;\n      }\n      continue;\n    }\n    //  yetanotherthrownvalue  work loop\n    // return to the normal work loop.\n    return;\n  } while (true);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n *  workinprogress  nullexitstatus \n *  completeunitofwork  workinprogress  null workloop\n * \n\n\n# workloopsync\n\nrenderrootsync  workloopsync  workloopsync \n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\n// the work loop is an extremely hot path. tell closure not to inline it.\n/** @noinline */\nfunction workloopsync() {\n  // already timed out, so perform work without checking if we need to yield.\n  while (workinprogress !== null) {\n    performunitofwork(workinprogress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n *  workinprogress  performunitofwork  workinprogress hostroot  fiber \n * @noinline  chrome  google closure compiler  inline@noinline js  inline  vue  @noinline  inline \n\n\n\ninline \n\nin computing, inline expansion, or inlining, is a manual or compiler optimization that replaces a function call site with the body of the called function. inline expansion is similar to macro expansion, but occurs during compilation, without changing the source code (the text), while macro expansion occurs prior to compilation, and results in different text that is then processed by the compiler.\n\n * inline expansion\n\n\n# workloopconcurrent\n\n renderrootconcurrent  workloopconcurrent workloopconcurrent  workloopsync \n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\n/** @noinline */\nfunction workloopconcurrent() {\n  // perform work until scheduler asks us to yield\n  while (workinprogress !== null && !shouldyield()) {\n    performunitofwork(workinprogress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * workinprogress  null  shouldyield  workloopconcurrent  (yield) \n\n\n# performunitofwork\n\n workloopsync  workloopconcurrent  performunitofwork performunitofwork performunitofwork \n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\nfunction performunitofwork(unitofwork: fiber): void {\n  // the current, flushed, state of this fiber is the alternate. ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  const current = unitofwork.alternate;\n\n  let next;\n \n  next = beginwork(current, unitofwork, subtreerenderlanes);\n\n  unitofwork.memoizedprops = unitofwork.pendingprops;\n  if (next === null) {\n    // if this doesn't spawn new work, complete the current work.\n    completeunitofwork(unitofwork);\n  } else {\n    workinprogress = next;\n  }\n\n  reactcurrentowner.current = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n *  fiber  reconciliation  fiber  fiber.alternate  fiber  fiber  fiber.alternate unitofwork  fiber current  fiber \n * beginwork  workinprogress  render fiber beginwork  fiber \n *  next  null  fiber render  completeunitofwork completeunitofwork  renderrootsync  renderrootconcurrent  handlererror  next  workinprogress performunitofwork  next  render\n\n\n# beginwork\n\n performunitofwork  beginwork  rootfiber  fiber fibertree  beginwork\n\n// src/react/packages/react-reconciler/src/reactfiberbeginwork.new.js\n\nfunction beginwork(\n  //  fiber\n  current: fiber | null,\n  //  fiber\n  workinprogress: fiber,\n  renderlanes: lanes,\n): fiber | null {\n  // \n  if (current !== null) {\n    const oldprops = current.memoizedprops;\n    const newprops = workinprogress.pendingprops;\n\n    if (\n      oldprops !== newprops ||\n      haslegacycontextchanged() ||\n      // force a re-render if the implementation changed due to hot reload:\n      (__dev__ ? workinprogress.type !== current.type : false)\n    ) {\n      // if props or context changed, mark the fiber as having performed work.\n      // this may be unset if the props are determined to be equal later (memo).\n      didreceiveupdate = true;\n    } else {\n      // neither props nor legacy context changes. check if there's a pending\n      // update or context change.\n      const hasscheduledupdateorcontext = checkscheduledupdateorcontext(\n        current,\n        renderlanes,\n      );\n      if (\n        !hasscheduledupdateorcontext &&\n        // if this is the second pass of an error or suspense boundary, there\n        // may not be work scheduled on `current`, so we check for this flag.\n        (workinprogress.flags & didcapture) === noflags\n      ) {\n        // no pending updates or context. bail out now.\n        didreceiveupdate = false;\n        return attemptearlybailoutifnoscheduledupdate(\n          current,\n          workinprogress,\n          renderlanes,\n        );\n      }\n      if ((current.flags & forceupdateforlegacysuspense) !== noflags) {\n        // this is a special case that only exists for legacy mode.\n        // see https://github.com/facebook/react/pull/19216.\n        didreceiveupdate = true;\n      } else {\n        // an update was scheduled on this fiber, but there are no new props\n        // nor legacy context. set this to false. if an update queue or context\n        // consumer produces a changed value, it will set this to true. otherwise,\n        // the component will assume the children have not changed and bail out.\n        didreceiveupdate = false;\n      }\n    }\n  } else {\n    didreceiveupdate = false;\n\n    if (getishydrating() && isforkedchild(workinprogress)) {\n      // check if this child belongs to a list of muliple children in\n      // its parent.\n      //\n      // in a true multi-threaded implementation, we would render children on\n      // parallel threads. this would represent the beginning of a new render\n      // thread for this subtree.\n      //\n      // we only use this for id generation during hydration, which is why the\n      // logic is located in this special branch.\n      // index  fiber \n      const slotindex = workinprogress.index;\n      const numberofforks = getforksatlevel(workinprogress);\n      pushtreeid(workinprogress, numberofforks, slotindex);\n    }\n  }\n\n  // before entering the begin phase, clear pending update priority.\n  // todo: this assumes that we're about to evaluate the component and process\n  // the update queue. however, there's an exception: simplememocomponent\n  // sometimes bails out later in the begin phase. this indicates that we should\n  // move this assignment out of the common path and into each branch.\n  // \n  workinprogress.lanes = nolanes;\n\n  switch (workinprogress.tag) {\n    case indeterminatecomponent: {\n      return mountindeterminatecomponent(\n        current,\n        workinprogress,\n        workinprogress.type,\n        renderlanes,\n      );\n    }\n    case lazycomponent: {\n      const elementtype = workinprogress.elementtype;\n      return mountlazycomponent(\n        current,\n        workinprogress,\n        elementtype,\n        renderlanes,\n      );\n    }\n    case functioncomponent: {\n      const component = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      const resolvedprops =\n        workinprogress.elementtype === component\n          ? unresolvedprops\n          : resolvedefaultprops(component, unresolvedprops);\n      return updatefunctioncomponent(\n        current,\n        workinprogress,\n        component,\n        resolvedprops,\n        renderlanes,\n      );\n    }\n    case classcomponent: {\n      const component = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      const resolvedprops =\n        workinprogress.elementtype === component\n          ? unresolvedprops\n          : resolvedefaultprops(component, unresolvedprops);\n      return updateclasscomponent(\n        current,\n        workinprogress,\n        component,\n        resolvedprops,\n        renderlanes,\n      );\n    }\n    case hostroot:\n      return updatehostroot(current, workinprogress, renderlanes);\n    case hostcomponent:\n      return updatehostcomponent(current, workinprogress, renderlanes);\n    case hosttext:\n      return updatehosttext(current, workinprogress);\n    case suspensecomponent:\n      return updatesuspensecomponent(current, workinprogress, renderlanes);\n    case hostportal:\n      return updateportalcomponent(current, workinprogress, renderlanes);\n    case forwardref: {\n      const type = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      const resolvedprops =\n        workinprogress.elementtype === type\n          ? unresolvedprops\n          : resolvedefaultprops(type, unresolvedprops);\n      return updateforwardref(\n        current,\n        workinprogress,\n        type,\n        resolvedprops,\n        renderlanes,\n      );\n    }\n    case fragment:\n      return updatefragment(current, workinprogress, renderlanes);\n    case mode:\n      return updatemode(current, workinprogress, renderlanes);\n    case profiler:\n      return updateprofiler(current, workinprogress, renderlanes);\n    case contextprovider:\n      return updatecontextprovider(current, workinprogress, renderlanes);\n    case contextconsumer:\n      return updatecontextconsumer(current, workinprogress, renderlanes);\n    case memocomponent: {\n      const type = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      // resolve outer props first, then resolve inner props.\n      let resolvedprops = resolvedefaultprops(type, unresolvedprops);\n      if (__dev__) {\n        if (workinprogress.type !== workinprogress.elementtype) {\n          const outerproptypes = type.proptypes;\n          if (outerproptypes) {\n            checkproptypes(\n              outerproptypes,\n              resolvedprops, // resolved for outer only\n              'prop',\n              getcomponentnamefromtype(type),\n            );\n          }\n        }\n      }\n      resolvedprops = resolvedefaultprops(type.type, resolvedprops);\n      return updatememocomponent(\n        current,\n        workinprogress,\n        type,\n        resolvedprops,\n        renderlanes,\n      );\n    }\n    case simplememocomponent: {\n      return updatesimplememocomponent(\n        current,\n        workinprogress,\n        workinprogress.type,\n        workinprogress.pendingprops,\n        renderlanes,\n      );\n    }\n    case incompleteclasscomponent: {\n      const component = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      const resolvedprops =\n        workinprogress.elementtype === component\n          ? unresolvedprops\n          : resolvedefaultprops(component, unresolvedprops);\n      return mountincompleteclasscomponent(\n        current,\n        workinprogress,\n        component,\n        resolvedprops,\n        renderlanes,\n      );\n    }\n    case suspenselistcomponent: {\n      return updatesuspenselistcomponent(current, workinprogress, renderlanes);\n    }\n    case scopecomponent: {\n      if (enablescopeapi) {\n        return updatescopecomponent(current, workinprogress, renderlanes);\n      }\n      break;\n    }\n    case offscreencomponent: {\n      return updateoffscreencomponent(current, workinprogress, renderlanes);\n    }\n    case legacyhiddencomponent: {\n      return updatelegacyhiddencomponent(current, workinprogress, renderlanes);\n    }\n    case cachecomponent: {\n      if (enablecache) {\n        return updatecachecomponent(current, workinprogress, renderlanes);\n      }\n      break;\n    }\n  }\n\n  throw new error(\n    `unknown unit of work tag (${workinprogress.tag}). this error is likely caused by a bug in ` +\n      'react. please file an issue.',\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n\n * didreceiveupdate  context  re-render\n *  workinprogress.tag  workloop  performunitofwork \n *  updatexxxcomponent  workinprogress.child  performunitofwork  next react  performunitofwork dfs\n\n\n# completeunitofwork\n\n\n# completework\n\n\n# commitroot",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/react/tour/index/",categories:["react","React"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/0.index.html",relativePath:"10.react/90.React/0.index.md",key:"v-071d800b",path:"/react/tour/index/",headers:[{level:2,title:"React ",slug:"react-",normalizedTitle:" react ",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:509},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:686}],readingTime:{text:"1 min read",minutes:.25,time:15e3,words:50},headersStr:"React   ",content:"#  React \n\n * \n *  React \n * \n *     \n *  React  Vue \n * \n\n\n# \n\n * \n * \n * \n * \n * \n * \n\n\n# \n\nReact \n\n\n\n * P0: \n * P1: \n * P2P3: \n\n",normalizedContent:"#  react \n\n * \n *  react \n * \n *     \n *  react  vue \n * \n\n\n# \n\n * \n * \n * \n * \n * \n * \n\n\n# \n\nreact \n\n\n\n * p0: \n * p1: \n * p2p3: \n\n",charsets:{cjk:!0},lastUpdated:"2022/08/24, 18:21:13",lastUpdatedTimestamp:1661336473e3},{title:"Plan ",frontmatter:{title:"Plan ",date:"2022-04-15T10:00:16.000Z",permalink:"/react/tour/plan/",categories:["react","React"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/1.Plan.html",relativePath:"10.react/90.React/1.Plan.md",key:"v-7532101f",path:"/react/tour/plan/",headers:[{level:2,title:"Plan ",slug:"plan-",normalizedTitle:"plan ",charIndex:2},{level:2,title:"TODO",slug:"todo",normalizedTitle:"todo",charIndex:999}],readingTime:{text:"2 min read",minutes:1.085,time:65099.99999999999,words:217},headersStr:"Plan  TODO",content:"# Plan \n\n * React \n   * ReactElement  P0\n   * ReactChildren  P0\n   * React  P0\n   * React  P0\n   * React  P1\n   * React  P2\n   * React  P2\n   * React  P2\n * React \n   * Fiber  P0\n   * React P0\n   * React P0\n   * React P0\n   * React P0\n   * React P0\n   * React P0\n   * React P0\n   * React P0\n   * React P0\n   * React P0\n   * React  P0\n   * expirationTime  P1React \n   * lane  P1\n * React \n   * React P0\n   * React P0\n * React Hooks \n   * useState  useReducer  P0\n   * useEffect  P0\n   * useMemo  useCallback  P0\n * React \n   * React  P2\n   * React  P2\n   * React  P2\n   * React  P2\n   * React  Lazy  P3\n   *  React  P3\n\n[]  [x] \n\n\n# TODO\n\n * ",normalizedContent:"# plan \n\n * react \n   * reactelement  p0\n   * reactchildren  p0\n   * react  p0\n   * react  p0\n   * react  p1\n   * react  p2\n   * react  p2\n   * react  p2\n * react \n   * fiber  p0\n   * react p0\n   * react p0\n   * react p0\n   * react p0\n   * react p0\n   * react p0\n   * react p0\n   * react p0\n   * react p0\n   * react p0\n   * react  p0\n   * expirationtime  p1react \n   * lane  p1\n * react \n   * react p0\n   * react p0\n * react hooks \n   * usestate  usereducer  p0\n   * useeffect  p0\n   * usememo  usecallback  p0\n * react \n   * react  p2\n   * react  p2\n   * react  p2\n   * react  p2\n   * react  lazy  p3\n   *  react  p3\n\n[]  [x] \n\n\n# todo\n\n * ",charsets:{cjk:!0},lastUpdated:"2022/10/28, 18:38:54",lastUpdatedTimestamp:1666953534e3},{title:"React ReactElement ",frontmatter:{title:"React ReactElement ",date:"2022-04-14T22:02:21.000Z",permalink:"/react/tour/react-basic-element/",categories:["react","React"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/10.react-basic-element.html",relativePath:"10.react/90.React/10.react-basic-element.md",key:"v-05b01242",path:"/react/tour/react-basic-element/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:19},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:27},{level:2,title:"React API ",slug:"react-api-",normalizedTitle:"react api ",charIndex:35},{level:2,title:"JSX",slug:"jsx",normalizedTitle:"jsx",charIndex:51},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:60},{level:3,title:" JSX",slug:"-jsx",normalizedTitle:" jsx",charIndex:68},{level:3,title:"JSX   JS",slug:"jsx---js",normalizedTitle:"jsx   js",charIndex:84},{level:2,title:"ReactElement",slug:"reactelement",normalizedTitle:"reactelement",charIndex:102},{level:3,title:"createElement",slug:"createelement",normalizedTitle:"createelement",charIndex:120},{level:2,title:"isValidElement",slug:"isvalidelement",normalizedTitle:"isvalidelement",charIndex:137},{level:2,title:"VDOM",slug:"vdom",normalizedTitle:"vdom",charIndex:155},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:163},{level:3,title:"React ",slug:"react-",normalizedTitle:"react ",charIndex:171},{level:3,title:" React 17  React17 ",slug:"-react-17--react-17-",normalizedTitle:" react 17  react17 ",charIndex:193},{level:3,title:"React  VDOM  ReactElement ",slug:"react--vdom--reactelement-",normalizedTitle:"react  vdom  reactelement ",charIndex:239},{level:3,title:"owner  ReactElement  Fiber owner ",slug:"owner--reactelement--fiber--owner-",normalizedTitle:"owner  reactelement  fiber owner ",charIndex:276},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:327},{level:3,title:"VDOM Tree  Fiber Tree ",slug:"vdom-tree--fiber-tree-",normalizedTitle:"vdom tree  fiber tree ",charIndex:335},{level:3,title:" className?",slug:"-classname",normalizedTitle:" classname?",charIndex:371},{level:3,title:"ReactElement TreeFiber Tree  DOM Tree ",slug:"reactelement-treefiber-tree--dom-tree-",normalizedTitle:"reactelement treefiber tree  dom tree ",charIndex:392},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:440}],readingTime:{text:"8 min read",minutes:7.695,time:461700.00000000006,words:1539},headersStr:"   React API  JSX   JSX JSX   JS ReactElement createElement isValidElement VDOM  React   React 17  React17  React  VDOM  ReactElement  owner  ReactElement  Fiber owner   VDOM Tree  Fiber Tree   className? ReactElement TreeFiber Tree  DOM Tree  ",content:'# \n\n\n\n * \n   * \n * \n * React API \n * JSX\n   * \n   *  JSX\n   * JSX   JS\n * ReactElement\n   * createElement\n * isValidElement\n * VDOM\n * \n   * React \n   *  React 17  React17 \n   * React  VDOM  ReactElement \n   * owner  ReactElement  Fiber owner \n * \n   * VDOM Tree  Fiber Tree \n   *  className?\n   * ReactElement TreeFiber Tree  DOM Tree \n * \n\n\n\n\n# \n\n *  React API \n *  JSXReactElementVDOM  JSX \n *  React  JSX  VDOM \n\n\n# \n\n React React  React  reactreact-domschedulerreact-reconciler\n\n\n\n * react React  API FragmentforwardRefmemohook \n * react-domReact  web  API rendercreatePortalcreateRoot \n * schedulerReact \n * react-reconcilerReact  React  FiberTree DIFF EffectTag List  FiberTree  DOM \n\n\n# React API \n\n react  React.js  React  React  API \n\nconst React = {\n  //  children \n  //  ReactChildren ReactChildren\n  Children: { \n    map,\n    forEach,\n    count,\n    toArray,\n    only,\n  },\n  //  ref  React  ref\n  createRef, \n  //  Component\n  Component,\n  // PureComponent  prop  state  shouldComponentUpdate \n  PureComponent, \n  //  Context  Context  Provider  context \n  createContext,\n  // forwardRef React ref \n  forwardRef, \n  // lazy \n  lazy, \n  // memo  props \n  memo,\n  // Hook API\n  //  memoized \n  useCallback,\n  //  context  <MyContext.Provider>  context \n  useContext,\n  // React \n  useEffect,\n  //  ref \n  useImperativeHandle,\n  //  React  hook \n  useDebugValue,\n  //  DOM  effect DOM useLayoutEffect \n  useLayoutEffect,\n  //  memoized \n  useMemo,\n  // useState  reducer state  dispatch \n  useReducer,\n  // useRef  ref  .current  ref \n  useRef,\n  //  state state \n  useState,\n  // Fragments  DOM \n  Fragment: REACT_FRAGMENT_TYPE,\n  // Profiler  React \n  Profiler: REACT_PROFILER_TYPE,\n  // StrictMode \n  StrictMode: REACT_STRICT_MODE_TYPE, \n  // Suspense \n  Suspense: REACT_SUSPENSE_TYPE, // lazyfeedback\n  //  React \n  createElement: __DEV__ ? createElementWithValidation : createElement,\n  //  element  React \n  cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement,\n  //  React \n  isValidElement: isValidElement,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n\n * ChildrencreateElementcloneElement\n * ComponentPureComponentcreateRefFragmentforwardRef\n * hooks api: useCallback,useContext,useEffect,useImperativeHandle,useDebugValue,useLayoutEffect,useMemo,useReducer,useRef,useState\n * lazymemoSuspense\n * createContext\n\n\n# JSX\n\n\n# \n\n JSX\n\n> JSX (JavaScript Syntax ExtensionJavaScript )  JavaScript  React HTML   JSX\n\n\n\nJSX  React  UI  JavaScript \n\nReact  JSX \n\n * JSX  JS  HTML  babel \n * JSX  @babel/plugin-transform-react-jsx-source \n\n\n#  JSX\n\n JSX React  JSX   React  JSX \n\n> React  UI \n> \n> React    React  JSX\n\n *  UI   ReactVue UI \n *   JS   \n   * JSX React.jsSolid.js  HTML  JavaScript \n   * SFC Vue.js  svelte.js  template  style  script \n\n\n# JSX   JS\n\n babel-transform-react-jsx \n\nconst work = () => {dosomething();}\nconst Conponent = () => {\n return (\n    <div style={{color: \'#ffffff\'}}>\n      <h1 class="title">heading</h1>\n      <div class="body" onClick={work}>content</div>\n    </div>\n    )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\nconst work = () => {\n  dosomething();\n};\n\nconst Conponent = () => {\n  return /*#__PURE__*/ React.createElement(\n    "div",\n    {\n      style: {\n        color: "#ffffff"\n      }\n    },\n    /*#__PURE__*/ React.createElement(\n      "h1",\n      {\n        class: "title"\n      },\n      "heading"\n    ),\n    /*#__PURE__*/ React.createElement(\n      "div",\n      {\n        class: "body",\n        onClick: work\n      },\n      "content"\n    )\n  );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n\n * babel  jsx js html  React.createElement \n * React.createElement  /*#__PURE__*/ \n *  rest \n\nJSX  html  vue  h createElement  JSX  JSX  JSX \n\n\n# ReactElement\n\n ReactElement  VDOM \n\n\n# createElement\n\ncreateElement  React ReactElement babel  JSX \n\nReact.createElement("div", {\n    class: "class_name",\n    id: "id_name",\n    key: "key_name",\n    ref: "ref_name"\n}, React.createElement("span", null, "Tom"), React.createElement("span", null, "Jerry"));\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n{\n    $$typeof: REACT_ELEMENT_TYPE,\n    type\'div\'\n    key: \'key_name\',\n    ref: "ref_name",\n    props: {\n        class: "class_name",\n        id: "id_name",\n        children: [\n            React.createElement("span", null, "Tom"),\n            React.createElement("span", null, "Jerry")\n        ]\n    }\n     _owner: ReactCurrentOwner.current,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n ReactElement React  VDOM patch VDOM \n\n VDOM  typeattrchildren  ReactElement ReactElement  attr  children  props  React   props  stateprops state  \n\n\n\ncreateElement \n\n// src/react/packages/react/src/ReactElement.js\n//  type config  children  react \nexport function createElement(type, config, children) {\n  let propName;\n  const props = {};\n\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n\n  if (config != null) {\n    //  ref \n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    //  key \n    if (hasValidKey(config)) {\n      key = \'\' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // \n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n  //  children children \n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    // \n    // children  props  props  children \n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    // \n    props.children = childArray;\n  }\n\n  // \n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  //  ReactElement\n  return ReactElement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n\n *  keyrefselfsource \n *  props configs  RESERVED_PROPS children  ReactElement  ( \'div\' )\n *  ReactElement  ReactElement\n\n ReactElement  React  DOM :\n\nconst ReactElement = function (type, key, ref, self, source, owner, props) {\n  // ReactElement\n  const element = {\n    // ReactElement  element  ReactElement\n    $$typeof: REACT_ELEMENT_TYPE,\n    // element \n    type: type,\n    // element  key  React \n    key: key,\n    // element  ref \n    ref: ref,\n    // element  childrenclassid \n    props: props,\n    // element  Fiber Fiber \n    _owner: owner,\n  };\n\n  return element;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * $$typeof ReactElement  element  ReactElement REACT_ELEMENT_TYPE = symbolFor(\'react.element\') \n * typeelement  \'div\'\'span\' \n * keyelement  key  React \n * ref:element  ref \n * propselement  childrenclassid \n * _ownerelement  Fiber Fiber \n\n\n# isValidElement\n\nisValidElement  element  ReactElement\n\nexport function isValidElement(object) {\n  return (\n    typeof object === \'object\' &&\n    object !== null &&\n    // $$typeof: Symbol(react.element)\n    object.$$typeof === REACT_ELEMENT_TYPE \n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# VDOM\n\nVDOM  DOMDocument Object Model JavaScript  ReactVue  VDOM \n\n * VDOM  DOM \n * VDOM  reflow  repaint\n * VDOM  DOM Tree  VDOM TreeVDOM Tree \n *  VDOM JavaScript  UI  DIFF \n\n VDOM \n\n *  UI  VDOM Tree\n * DIFF  JavaScript  VDOM  VDOM Tree DIFF  VDOM  React  DIFFVue  DIFF key  type DIFF  VDOM \n\n DOM   \n\n\n# \n\n\n# React \n\npackages.\n create-subscription\n dom-event-testing-library\n eslint-plugin-react-hooks\n jest-mock-scheduler\n jest-react\n react //  API\n react-art //  canvas, svg\n react-cache\n react-client\n react-debug-tools\n\x3c!-- devtools  --\x3e\n react-devtools\n react-devtools-core\n react-devtools-extensions\n react-devtools-inline\n react-devtools-shared\n react-devtools-shell\n react-devtools-timeline\n react-dom //  web \n react-fetch\n react-fs\n react-interactions\n react-is\n react-native-renderer //  ReactNative\n react-noop-renderer\n react-pg\n react-reconciler // \n react-refresh\n\x3c!-- SSR  --\x3e\n react-server\n react-server-dom-relay\n react-server-dom-webpack\n react-server-native-relay\n react-suspense-test-utils\n react-test-renderer\n scheduler // \n shared\n use-subscription\n use-sync-external-store\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n#  React 17  React17 \n\n JSX JSX  babel TS  JS  React ReferenceError React is not defined \n\n React17  babel  JSX \n\n> React 17  React  package  Babel  TypeScript  JSX  JSX  React.createElement React  package React  JSX \n\n React  React  JSX \n\n// \nimport {jsx as _jsx} from \'react/jsx-runtime\';\n\nfunction App() {\n  return _jsx(\'h1\', { children: \'Hello world\' });\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n JSX  jsx \n\n\n# React  VDOM  ReactElement \n\nReactElement  React  VDOM  FiberReact  Fiber  concurrent  ReactDOM  UI \n\nVDOM  DOM  JavaScript ReactElement  DOM Fiber  DOM  Effect Tag\n\n\n# _owner  ReactElement  Fiber _owner \n\n_owner  ReactCurrentOwner.current  ReactCurrentOwner.current  finishClassComponent \n\n// src/react/packages/react-reconciler/src/ReactFiberBeginWork.new.js\nReactCurrentOwner.current = workInProgress;\n\n\n1\n2\n\n\n finishClassComponent  updateClassComponent  mountIncompleteClassComponent  mountIndeterminateComponent  ClassComponent  _owner  workInProgress workInProgress  performUnitOfWork \n\nfunction performUnitOfWork(unitOfWork: Fiber): void {\n  let next;\n  next = beginWork(current, unitOfWork, subtreeRenderLanes);\n\n  if (next === null) {\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n\n  ReactCurrentOwner.current = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n workInProgress  Fiber workInProgress  React  ReactCurrentOwner.current  createElement  ReactElement  Fiber \n\n_owner \n\n 1.  element._owner  element  Fiber  \n\n element.children  key  validateExplicitKey \n\nif (\n    element &&\n    element._owner &&\n    element._owner !== ReactCurrentOwner.current\n  ) {\n    // \n    childOwner = ` It was passed a child from ${getComponentNameFromType(\n      element._owner.type,\n    )}.`;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# \n\n\n# VDOM Tree  Fiber Tree \n\nFiber  stateNode  Fiber  VDOM Tree\n\n\n\n 1. JSX  js \n 2.  ReactDOM.render  FiberRoot  HostRootFiber\n 3.  FiberTree\n 4. createElement  ReactElement Tree VDOM Tree\n 5. VDOM Tree  DOM Tree\n 6.  3\n\n\n#  className?\n\n Vue  JSX  class  class React  className\n\n\n# ReactElement TreeFiber Tree  DOM Tree \n\n\n# \n\n React Element \n\n *  React \n * React \n * React API \n * JSX \n * ReactElement \n * VDOM ',normalizedContent:'# \n\n\n\n * \n   * \n * \n * react api \n * jsx\n   * \n   *  jsx\n   * jsx   js\n * reactelement\n   * createelement\n * isvalidelement\n * vdom\n * \n   * react \n   *  react 17  react17 \n   * react  vdom  reactelement \n   * owner  reactelement  fiber owner \n * \n   * vdom tree  fiber tree \n   *  classname?\n   * reactelement treefiber tree  dom tree \n * \n\n\n\n\n# \n\n *  react api \n *  jsxreactelementvdom  jsx \n *  react  jsx  vdom \n\n\n# \n\n react react  react  reactreact-domschedulerreact-reconciler\n\n\n\n * react react  api fragmentforwardrefmemohook \n * react-domreact  web  api rendercreateportalcreateroot \n * schedulerreact \n * react-reconcilerreact  react  fibertree diff effecttag list  fibertree  dom \n\n\n# react api \n\n react  react.js  react  react  api \n\nconst react = {\n  //  children \n  //  reactchildren reactchildren\n  children: { \n    map,\n    foreach,\n    count,\n    toarray,\n    only,\n  },\n  //  ref  react  ref\n  createref, \n  //  component\n  component,\n  // purecomponent  prop  state  shouldcomponentupdate \n  purecomponent, \n  //  context  context  provider  context \n  createcontext,\n  // forwardref react ref \n  forwardref, \n  // lazy \n  lazy, \n  // memo  props \n  memo,\n  // hook api\n  //  memoized \n  usecallback,\n  //  context  <mycontext.provider>  context \n  usecontext,\n  // react \n  useeffect,\n  //  ref \n  useimperativehandle,\n  //  react  hook \n  usedebugvalue,\n  //  dom  effect dom uselayouteffect \n  uselayouteffect,\n  //  memoized \n  usememo,\n  // usestate  reducer state  dispatch \n  usereducer,\n  // useref  ref  .current  ref \n  useref,\n  //  state state \n  usestate,\n  // fragments  dom \n  fragment: react_fragment_type,\n  // profiler  react \n  profiler: react_profiler_type,\n  // strictmode \n  strictmode: react_strict_mode_type, \n  // suspense \n  suspense: react_suspense_type, // lazyfeedback\n  //  react \n  createelement: __dev__ ? createelementwithvalidation : createelement,\n  //  element  react \n  cloneelement: __dev__ ? cloneelementwithvalidation : cloneelement,\n  //  react \n  isvalidelement: isvalidelement,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n\n * childrencreateelementcloneelement\n * componentpurecomponentcreatereffragmentforwardref\n * hooks api: usecallback,usecontext,useeffect,useimperativehandle,usedebugvalue,uselayouteffect,usememo,usereducer,useref,usestate\n * lazymemosuspense\n * createcontext\n\n\n# jsx\n\n\n# \n\n jsx\n\n> jsx (javascript syntax extensionjavascript )  javascript  react html   jsx\n\n\n\njsx  react  ui  javascript \n\nreact  jsx \n\n * jsx  js  html  babel \n * jsx  @babel/plugin-transform-react-jsx-source \n\n\n#  jsx\n\n jsx react  jsx   react  jsx \n\n> react  ui \n> \n> react    react  jsx\n\n *  ui   reactvue ui \n *   js   \n   * jsx react.jssolid.js  html  javascript \n   * sfc vue.js  svelte.js  template  style  script \n\n\n# jsx   js\n\n babel-transform-react-jsx \n\nconst work = () => {dosomething();}\nconst conponent = () => {\n return (\n    <div style={{color: \'#ffffff\'}}>\n      <h1 class="title">heading</h1>\n      <div class="body" onclick={work}>content</div>\n    </div>\n    )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\nconst work = () => {\n  dosomething();\n};\n\nconst conponent = () => {\n  return /*#__pure__*/ react.createelement(\n    "div",\n    {\n      style: {\n        color: "#ffffff"\n      }\n    },\n    /*#__pure__*/ react.createelement(\n      "h1",\n      {\n        class: "title"\n      },\n      "heading"\n    ),\n    /*#__pure__*/ react.createelement(\n      "div",\n      {\n        class: "body",\n        onclick: work\n      },\n      "content"\n    )\n  );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n\n * babel  jsx js html  react.createelement \n * react.createelement  /*#__pure__*/ \n *  rest \n\njsx  html  vue  h createelement  jsx  jsx  jsx \n\n\n# reactelement\n\n reactelement  vdom \n\n\n# createelement\n\ncreateelement  react reactelement babel  jsx \n\nreact.createelement("div", {\n    class: "class_name",\n    id: "id_name",\n    key: "key_name",\n    ref: "ref_name"\n}, react.createelement("span", null, "tom"), react.createelement("span", null, "jerry"));\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n{\n    $$typeof: react_element_type,\n    type\'div\'\n    key: \'key_name\',\n    ref: "ref_name",\n    props: {\n        class: "class_name",\n        id: "id_name",\n        children: [\n            react.createelement("span", null, "tom"),\n            react.createelement("span", null, "jerry")\n        ]\n    }\n     _owner: reactcurrentowner.current,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n reactelement react  vdom patch vdom \n\n vdom  typeattrchildren  reactelement reactelement  attr  children  props  react   props  stateprops state  \n\n\n\ncreateelement \n\n// src/react/packages/react/src/reactelement.js\n//  type config  children  react \nexport function createelement(type, config, children) {\n  let propname;\n  const props = {};\n\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n\n  if (config != null) {\n    //  ref \n    if (hasvalidref(config)) {\n      ref = config.ref;\n    }\n    //  key \n    if (hasvalidkey(config)) {\n      key = \'\' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // \n    for (propname in config) {\n      if (\n        hasownproperty.call(config, propname) &&\n        !reserved_props.hasownproperty(propname)\n      ) {\n        props[propname] = config[propname];\n      }\n    }\n  }\n  //  children children \n  const childrenlength = arguments.length - 2;\n  if (childrenlength === 1) {\n    // \n    // children  props  props  children \n    props.children = children;\n  } else if (childrenlength > 1) {\n    const childarray = array(childrenlength);\n    for (let i = 0; i < childrenlength; i++) {\n      childarray[i] = arguments[i + 2];\n    }\n    // \n    props.children = childarray;\n  }\n\n  // \n  if (type && type.defaultprops) {\n    const defaultprops = type.defaultprops;\n    for (propname in defaultprops) {\n      if (props[propname] === undefined) {\n        props[propname] = defaultprops[propname];\n      }\n    }\n  }\n  //  reactelement\n  return reactelement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    reactcurrentowner.current,\n    props,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n\n *  keyrefselfsource \n *  props configs  reserved_props children  reactelement  ( \'div\' )\n *  reactelement  reactelement\n\n reactelement  react  dom :\n\nconst reactelement = function (type, key, ref, self, source, owner, props) {\n  // reactelement\n  const element = {\n    // reactelement  element  reactelement\n    $$typeof: react_element_type,\n    // element \n    type: type,\n    // element  key  react \n    key: key,\n    // element  ref \n    ref: ref,\n    // element  childrenclassid \n    props: props,\n    // element  fiber fiber \n    _owner: owner,\n  };\n\n  return element;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * $$typeof reactelement  element  reactelement react_element_type = symbolfor(\'react.element\') \n * typeelement  \'div\'\'span\' \n * keyelement  key  react \n * ref:element  ref \n * propselement  childrenclassid \n * _ownerelement  fiber fiber \n\n\n# isvalidelement\n\nisvalidelement  element  reactelement\n\nexport function isvalidelement(object) {\n  return (\n    typeof object === \'object\' &&\n    object !== null &&\n    // $$typeof: symbol(react.element)\n    object.$$typeof === react_element_type \n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# vdom\n\nvdom  domdocument object model javascript  reactvue  vdom \n\n * vdom  dom \n * vdom  reflow  repaint\n * vdom  dom tree  vdom treevdom tree \n *  vdom javascript  ui  diff \n\n vdom \n\n *  ui  vdom tree\n * diff  javascript  vdom  vdom tree diff  vdom  react  diffvue  diff key  type diff  vdom \n\n dom   \n\n\n# \n\n\n# react \n\npackages.\n create-subscription\n dom-event-testing-library\n eslint-plugin-react-hooks\n jest-mock-scheduler\n jest-react\n react //  api\n react-art //  canvas, svg\n react-cache\n react-client\n react-debug-tools\n\x3c!-- devtools  --\x3e\n react-devtools\n react-devtools-core\n react-devtools-extensions\n react-devtools-inline\n react-devtools-shared\n react-devtools-shell\n react-devtools-timeline\n react-dom //  web \n react-fetch\n react-fs\n react-interactions\n react-is\n react-native-renderer //  reactnative\n react-noop-renderer\n react-pg\n react-reconciler // \n react-refresh\n\x3c!-- ssr  --\x3e\n react-server\n react-server-dom-relay\n react-server-dom-webpack\n react-server-native-relay\n react-suspense-test-utils\n react-test-renderer\n scheduler // \n shared\n use-subscription\n use-sync-external-store\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n#  react 17  react17 \n\n jsx jsx  babel ts  js  react referenceerror react is not defined \n\n react17  babel  jsx \n\n> react 17  react  package  babel  typescript  jsx  jsx  react.createelement react  package react  jsx \n\n react  react  jsx \n\n// \nimport {jsx as _jsx} from \'react/jsx-runtime\';\n\nfunction app() {\n  return _jsx(\'h1\', { children: \'hello world\' });\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n jsx  jsx \n\n\n# react  vdom  reactelement \n\nreactelement  react  vdom  fiberreact  fiber  concurrent  reactdom  ui \n\nvdom  dom  javascript reactelement  dom fiber  dom  effect tag\n\n\n# _owner  reactelement  fiber _owner \n\n_owner  reactcurrentowner.current  reactcurrentowner.current  finishclasscomponent \n\n// src/react/packages/react-reconciler/src/reactfiberbeginwork.new.js\nreactcurrentowner.current = workinprogress;\n\n\n1\n2\n\n\n finishclasscomponent  updateclasscomponent  mountincompleteclasscomponent  mountindeterminatecomponent  classcomponent  _owner  workinprogress workinprogress  performunitofwork \n\nfunction performunitofwork(unitofwork: fiber): void {\n  let next;\n  next = beginwork(current, unitofwork, subtreerenderlanes);\n\n  if (next === null) {\n    completeunitofwork(unitofwork);\n  } else {\n    workinprogress = next;\n  }\n\n  reactcurrentowner.current = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n workinprogress  fiber workinprogress  react  reactcurrentowner.current  createelement  reactelement  fiber \n\n_owner \n\n 1.  element._owner  element  fiber  \n\n element.children  key  validateexplicitkey \n\nif (\n    element &&\n    element._owner &&\n    element._owner !== reactcurrentowner.current\n  ) {\n    // \n    childowner = ` it was passed a child from ${getcomponentnamefromtype(\n      element._owner.type,\n    )}.`;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# \n\n\n# vdom tree  fiber tree \n\nfiber  statenode  fiber  vdom tree\n\n\n\n 1. jsx  js \n 2.  reactdom.render  fiberroot  hostrootfiber\n 3.  fibertree\n 4. createelement  reactelement tree vdom tree\n 5. vdom tree  dom tree\n 6.  3\n\n\n#  classname?\n\n vue  jsx  class  class react  classname\n\n\n# reactelement treefiber tree  dom tree \n\n\n# \n\n react element \n\n *  react \n * react \n * react api \n * jsx \n * reactelement \n * vdom ',charsets:{cjk:!0},lastUpdated:"2022/08/24, 18:21:13",lastUpdatedTimestamp:1661336473e3},{title:"React React ",frontmatter:{title:"React React ",date:"2022-04-14T22:02:21.000Z",permalink:"/react/tour/react-reconciliation-2/",categories:["react","React"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/100.react-reconciliation-2.html",relativePath:"10.react/90.React/100.react-reconciliation-2.md",key:"v-1e97eeff",path:"/react/tour/react-reconciliation-2/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:2,title:"scheduleSyncCallback",slug:"schedulesynccallback",normalizedTitle:"schedulesynccallback",charIndex:23},{level:3,title:"flushSyncCallbacks",slug:"flushsynccallbacks",normalizedTitle:"flushsynccallbacks",charIndex:49},{level:2,title:"scheduleCallback",slug:"schedulecallback",normalizedTitle:"schedulecallback",charIndex:71},{level:2,title:"performSyncWorkOnRoot",slug:"performsyncworkonroot",normalizedTitle:"performsyncworkonroot",charIndex:91},{level:2,title:"performConcurrentWorkOnRoot",slug:"performconcurrentworkonroot",normalizedTitle:"performconcurrentworkonroot",charIndex:116},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:147},{level:3,title:" scheduleSyncCallback ",slug:"-schedulesynccallback-",normalizedTitle:" schedulesynccallback ",charIndex:155},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:189},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:202},{level:3,title:" performSyncWorkOnRoot  performConcurrentWorkOnRoot ",slug:"-performsyncworkonroot--performconcurrentworkonroot-",normalizedTitle:" performsyncworkonroot  performconcurrentworkonroot ",charIndex:210},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:287}],readingTime:{text:"5 min read",minutes:4.89,time:293400,words:978},headersStr:"  scheduleSyncCallback flushSyncCallbacks scheduleCallback performSyncWorkOnRoot performConcurrentWorkOnRoot   scheduleSyncCallback     performSyncWorkOnRoot  performConcurrentWorkOnRoot  ",content:"# \n\n\n\n * \n * \n * scheduleSyncCallback\n   * flushSyncCallbacks\n * scheduleCallback\n * performSyncWorkOnRoot\n * performConcurrentWorkOnRoot\n * \n   *  scheduleSyncCallback \n   * \n * \n   *  performSyncWorkOnRoot  performConcurrentWorkOnRoot \n * \n\n\n\n\n# \n\n updateContainer  scheduleUpdateOnFiber  ensureRootIsScheduled \n\n ensureRootIsScheduled  scheduleCallback  Batch  Render \n\n----------------------------------------\n\n ensureRootIsScheduled ensureRootIsScheduled  scheduleSyncCallback  scheduleCallback \n\n\n# scheduleSyncCallback\n\n\n\n 1. \n 2. \n\n\n\n// src/react/packages/react-reconciler/src/ReactFiberSyncTaskQueue.new.js\nexport function scheduleSyncCallback(callback: SchedulerCallback) {\n  // \n  if (syncQueue === null) {\n    syncQueue = [callback];\n  } else {\n    syncQueue.push(callback);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nscheduleSyncCallback  flushSyncCallbacks\n\n\n# flushSyncCallbacks\n\n\n\n// src/react/packages/react-reconciler/src/ReactFiberSyncTaskQueue.new.js\nexport function flushSyncCallbacks() {\n  // isFlushingSyncQueue  syncQueue  callbacks \n  if (!isFlushingSyncQueue && syncQueue !== null) {\n    // \n    isFlushingSyncQueue = true;\n    let i = 0;\n    const previousUpdatePriority = getCurrentUpdatePriority();\n    try {\n      const isSync = true;\n      const queue = syncQueue;\n      setCurrentUpdatePriority(DiscreteEventPriority);\n      // flush syncQueue callback  callback\n      for (; i < queue.length; i++) {\n        let callback = queue[i];\n        do {\n          callback = callback(isSync);\n        } while (callback !== null);\n      }\n      //  syncQueue\n      syncQueue = null;\n      includesLegacySyncCallbacks = false;\n    } catch (error) {\n      // If something throws, leave the remaining callbacks on the queue.\n      // syncQueue  Callback \n      if (syncQueue !== null) {\n        syncQueue = syncQueue.slice(i + 1);\n      }\n      // Resume flushing in the next tick\n      // \n      scheduleCallback(ImmediatePriority, flushSyncCallbacks);\n      throw error;\n    } finally {\n      setCurrentUpdatePriority(previousUpdatePriority);\n      isFlushingSyncQueue = false;\n    }\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n\n 1. \n 2.  ImmediatePriority \n\n\n# scheduleCallback\n\n react  performSyncWorkOnRoot\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nfunction scheduleCallback(priorityLevel, callback) {\n // In production, always call Scheduler. This function will be stripped out.\n return Scheduler_scheduleCallback(priorityLevel, callback);\n}\n\n\n1\n2\n3\n4\n5\n\n\n Scheduler_scheduleCallback \n\n\n# performSyncWorkOnRoot\n\n\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n// This is the entry point for synchronous tasks that don't go\n// through Scheduler\nfunction performSyncWorkOnRoot(root) {\n  //  Render  Commit  Batch \n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n  // ......\n  //  FiberRoot  lanes\n  let lanes = getNextLanes(root, NoLanes);\n  //  lanes  lanes\n  if (!includesSomeLane(lanes, SyncLane)) {\n    // There's no remaining sync work left.\n    ensureRootIsScheduled(root, now());\n    return null;\n  }\n  //  FiberRoot exitStatus\n  let exitStatus = renderRootSync(root, lanes);\n  //  RootErrored  50 \n  // ......\n  //  RootFatalErrored FiberRoot  suspend\n  // ......\n\n  // We now have a consistent tree. Because this is a sync render, we\n  // will commit it even if something suspended.\n  //  finishedWork  finishedLanes Commit  FiberRoot\n  const finishedWork: Fiber = (root.current.alternate: any);\n  root.finishedWork = finishedWork;\n  root.finishedLanes = lanes;\n  commitRoot(root);\n\n  // Before exiting, make sure there's a callback scheduled for the next\n  // pending level.\n  ensureRootIsScheduled(root, now());\n\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n\n *  renderRootSync  FiberRoot \n *  finishedWork  finishedLanes \n *  commitRoot  FiberRoot  Commit \n *  ensureRootIsScheduled  FiberRoot \n\n\n# performConcurrentWorkOnRoot\n\n Render  Commit \n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  // ......\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  // ......\n\n  // Determine the next lanes to work on, using the fields stored\n  // on the root.\n  let lanes = getNextLanes(\n    root,\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\n  );\n  // ......\n\n  // We disable time-slicing in some cases: if the work has been CPU-bound\n  // for too long (\"expired\" work, to prevent starvation), or we're in\n  // sync-updates-by-default mode.\n  // \n  const shouldTimeSlice =\n    !includesBlockingLane(root, lanes) &&\n    !includesExpiredLane(root, lanes);\n  let exitStatus = shouldTimeSlice\n    ? renderRootConcurrent(root, lanes)\n    : renderRootSync(root, lanes);\n  if (exitStatus !== RootIncomplete) {\n    // ......\n    const finishedWork: Fiber = (root.current.alternate: any);\n    // We now have a consistent tree. The next step is either to commit it,\n    // or, if something suspended, wait to commit it after a timeout.\n    root.finishedWork = finishedWork;\n    root.finishedLanes = lanes;\n    finishConcurrentRender(root, exitStatus, lanes);\n  }\n  ensureRootIsScheduled(root, now());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n finishConcurrentRender  Commit \n\n\n# \n\n\n#  scheduleSyncCallback \n\n\n\n scheduleSyncCallback  flushSyncCallbacks  OOP \n\nclass Queue{\n  private queue = [];\n  private lock = true;\n  \n  add(task) {\n    this.queue.push(task);\n  }\n\n  flush() {\n    if(!this.lock || !this.queue.length) return this;\n    this.lock = false;\n    const queue = this.queue;\n    let i = 0;\n    try {\n      // do tasks from the queue\n      for (; i < queue.length; i++) {\n        let task = queue[i];\n        do {\n          task = task();\n        } while (task !== null);\n      }\n      this.queue = [];\n    } catch (error) {\n      // process errors\n    } finally {\n       this.lock =  true;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n\n * \n * \n * \n * \n * \n * \n\n\n# \n\nreact  UI  Render \n\n renderRootSync  renderRootSync  exitStatus  Render \n\n//  FiberRoot exitStatus\nlet exitStatus = renderRootSync(root, lanes);\n//  RootErrored\nif (exitStatus === RootErrored) {\n  // If something threw an error, try rendering one more time. We'll render\n  // synchronously to block concurrent data mutations, and we'll includes\n  // all pending updates are included. If it still fails after the second\n  // attempt, we'll give up and commit the resulting tree.\n  //   50 \n  const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n  if (errorRetryLanes !== NoLanes) {\n    lanes = errorRetryLanes;\n    exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n  }\n}\n//  RootFatalErrored FiberRoot  suspend\nif (exitStatus === RootFatalErrored) {\n  const fatalError = workInProgressRootFatalError;\n  // \n  prepareFreshStack(root, NoLanes);\n  markRootSuspended(root, lanes);\n  ensureRootIsScheduled(root, now());\n  throw fatalError;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n\n *  50  FiberTree\n *  FiberRoot  suspended\n\n exitStatus \n\n\n# \n\n\n#  performSyncWorkOnRoot  performConcurrentWorkOnRoot \n\n *  Batch  Render  Commit :\n\n// This is the entry point for synchronous tasks that don't go\n// through Scheduler\nfunction performSyncWorkOnRoot() {}\n// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\nfunction performConcurrentWorkOnRoot() {}\n\n\n1\n2\n3\n4\n5\n6\n\n\n entry point \n\n * \n\n\n# \n\n\n\n *  React    React \n *  Render  Commit \n * performWork  FiberRoot  FiberRoot  FiberTree ",normalizedContent:"# \n\n\n\n * \n * \n * schedulesynccallback\n   * flushsynccallbacks\n * schedulecallback\n * performsyncworkonroot\n * performconcurrentworkonroot\n * \n   *  schedulesynccallback \n   * \n * \n   *  performsyncworkonroot  performconcurrentworkonroot \n * \n\n\n\n\n# \n\n updatecontainer  scheduleupdateonfiber  ensurerootisscheduled \n\n ensurerootisscheduled  schedulecallback  batch  render \n\n----------------------------------------\n\n ensurerootisscheduled ensurerootisscheduled  schedulesynccallback  schedulecallback \n\n\n# schedulesynccallback\n\n\n\n 1. \n 2. \n\n\n\n// src/react/packages/react-reconciler/src/reactfibersynctaskqueue.new.js\nexport function schedulesynccallback(callback: schedulercallback) {\n  // \n  if (syncqueue === null) {\n    syncqueue = [callback];\n  } else {\n    syncqueue.push(callback);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nschedulesynccallback  flushsynccallbacks\n\n\n# flushsynccallbacks\n\n\n\n// src/react/packages/react-reconciler/src/reactfibersynctaskqueue.new.js\nexport function flushsynccallbacks() {\n  // isflushingsyncqueue  syncqueue  callbacks \n  if (!isflushingsyncqueue && syncqueue !== null) {\n    // \n    isflushingsyncqueue = true;\n    let i = 0;\n    const previousupdatepriority = getcurrentupdatepriority();\n    try {\n      const issync = true;\n      const queue = syncqueue;\n      setcurrentupdatepriority(discreteeventpriority);\n      // flush syncqueue callback  callback\n      for (; i < queue.length; i++) {\n        let callback = queue[i];\n        do {\n          callback = callback(issync);\n        } while (callback !== null);\n      }\n      //  syncqueue\n      syncqueue = null;\n      includeslegacysynccallbacks = false;\n    } catch (error) {\n      // if something throws, leave the remaining callbacks on the queue.\n      // syncqueue  callback \n      if (syncqueue !== null) {\n        syncqueue = syncqueue.slice(i + 1);\n      }\n      // resume flushing in the next tick\n      // \n      schedulecallback(immediatepriority, flushsynccallbacks);\n      throw error;\n    } finally {\n      setcurrentupdatepriority(previousupdatepriority);\n      isflushingsyncqueue = false;\n    }\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n\n 1. \n 2.  immediatepriority \n\n\n# schedulecallback\n\n react  performsyncworkonroot\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nfunction schedulecallback(prioritylevel, callback) {\n // in production, always call scheduler. this function will be stripped out.\n return scheduler_schedulecallback(prioritylevel, callback);\n}\n\n\n1\n2\n3\n4\n5\n\n\n scheduler_schedulecallback \n\n\n# performsyncworkonroot\n\n\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n// this is the entry point for synchronous tasks that don't go\n// through scheduler\nfunction performsyncworkonroot(root) {\n  //  render  commit  batch \n  if ((executioncontext & (rendercontext | commitcontext)) !== nocontext) {\n    throw new error('should not already be working.');\n  }\n  // ......\n  //  fiberroot  lanes\n  let lanes = getnextlanes(root, nolanes);\n  //  lanes  lanes\n  if (!includessomelane(lanes, synclane)) {\n    // there's no remaining sync work left.\n    ensurerootisscheduled(root, now());\n    return null;\n  }\n  //  fiberroot exitstatus\n  let exitstatus = renderrootsync(root, lanes);\n  //  rooterrored  50 \n  // ......\n  //  rootfatalerrored fiberroot  suspend\n  // ......\n\n  // we now have a consistent tree. because this is a sync render, we\n  // will commit it even if something suspended.\n  //  finishedwork  finishedlanes commit  fiberroot\n  const finishedwork: fiber = (root.current.alternate: any);\n  root.finishedwork = finishedwork;\n  root.finishedlanes = lanes;\n  commitroot(root);\n\n  // before exiting, make sure there's a callback scheduled for the next\n  // pending level.\n  ensurerootisscheduled(root, now());\n\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n\n *  renderrootsync  fiberroot \n *  finishedwork  finishedlanes \n *  commitroot  fiberroot  commit \n *  ensurerootisscheduled  fiberroot \n\n\n# performconcurrentworkonroot\n\n render  commit \n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n// this is the entry point for every concurrent task, i.e. anything that\n// goes through scheduler.\nfunction performconcurrentworkonroot(root, didtimeout) {\n  // ......\n\n  if ((executioncontext & (rendercontext | commitcontext)) !== nocontext) {\n    throw new error('should not already be working.');\n  }\n\n  // ......\n\n  // determine the next lanes to work on, using the fields stored\n  // on the root.\n  let lanes = getnextlanes(\n    root,\n    root === workinprogressroot ? workinprogressrootrenderlanes : nolanes,\n  );\n  // ......\n\n  // we disable time-slicing in some cases: if the work has been cpu-bound\n  // for too long (\"expired\" work, to prevent starvation), or we're in\n  // sync-updates-by-default mode.\n  // \n  const shouldtimeslice =\n    !includesblockinglane(root, lanes) &&\n    !includesexpiredlane(root, lanes);\n  let exitstatus = shouldtimeslice\n    ? renderrootconcurrent(root, lanes)\n    : renderrootsync(root, lanes);\n  if (exitstatus !== rootincomplete) {\n    // ......\n    const finishedwork: fiber = (root.current.alternate: any);\n    // we now have a consistent tree. the next step is either to commit it,\n    // or, if something suspended, wait to commit it after a timeout.\n    root.finishedwork = finishedwork;\n    root.finishedlanes = lanes;\n    finishconcurrentrender(root, exitstatus, lanes);\n  }\n  ensurerootisscheduled(root, now());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n finishconcurrentrender  commit \n\n\n# \n\n\n#  schedulesynccallback \n\n\n\n schedulesynccallback  flushsynccallbacks  oop \n\nclass queue{\n  private queue = [];\n  private lock = true;\n  \n  add(task) {\n    this.queue.push(task);\n  }\n\n  flush() {\n    if(!this.lock || !this.queue.length) return this;\n    this.lock = false;\n    const queue = this.queue;\n    let i = 0;\n    try {\n      // do tasks from the queue\n      for (; i < queue.length; i++) {\n        let task = queue[i];\n        do {\n          task = task();\n        } while (task !== null);\n      }\n      this.queue = [];\n    } catch (error) {\n      // process errors\n    } finally {\n       this.lock =  true;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n\n * \n * \n * \n * \n * \n * \n\n\n# \n\nreact  ui  render \n\n renderrootsync  renderrootsync  exitstatus  render \n\n//  fiberroot exitstatus\nlet exitstatus = renderrootsync(root, lanes);\n//  rooterrored\nif (exitstatus === rooterrored) {\n  // if something threw an error, try rendering one more time. we'll render\n  // synchronously to block concurrent data mutations, and we'll includes\n  // all pending updates are included. if it still fails after the second\n  // attempt, we'll give up and commit the resulting tree.\n  //   50 \n  const errorretrylanes = getlanestoretrysynchronouslyonerror(root);\n  if (errorretrylanes !== nolanes) {\n    lanes = errorretrylanes;\n    exitstatus = recoverfromconcurrenterror(root, errorretrylanes);\n  }\n}\n//  rootfatalerrored fiberroot  suspend\nif (exitstatus === rootfatalerrored) {\n  const fatalerror = workinprogressrootfatalerror;\n  // \n  preparefreshstack(root, nolanes);\n  markrootsuspended(root, lanes);\n  ensurerootisscheduled(root, now());\n  throw fatalerror;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n\n *  50  fibertree\n *  fiberroot  suspended\n\n exitstatus \n\n\n# \n\n\n#  performsyncworkonroot  performconcurrentworkonroot \n\n *  batch  render  commit :\n\n// this is the entry point for synchronous tasks that don't go\n// through scheduler\nfunction performsyncworkonroot() {}\n// this is the entry point for every concurrent task, i.e. anything that\n// goes through scheduler.\nfunction performconcurrentworkonroot() {}\n\n\n1\n2\n3\n4\n5\n6\n\n\n entry point \n\n * \n\n\n# \n\n\n\n *  react    react \n *  render  commit \n * performwork  fiberroot  fiberroot  fibertree ",charsets:{cjk:!0},lastUpdated:"2022/07/22, 14:56:40",lastUpdatedTimestamp:1658473e6},{title:"React React ",frontmatter:{title:"React React ",date:"2022-07-12T12:02:21.000Z",permalink:"/react/tour/react-reconciliation-3/",categories:["react","React"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/110.react-reconciliation-3.html",relativePath:"10.react/90.React/110.react-reconciliation-3.md",key:"v-5962efbf",path:"/react/tour/react-reconciliation-3/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:2,title:"renderRootSync",slug:"renderrootsync",normalizedTitle:"renderrootsync",charIndex:23},{level:2,title:"renderRootConcurrent",slug:"renderrootconcurrent",normalizedTitle:"renderrootconcurrent",charIndex:41},{level:2,title:"workLoopSync",slug:"workloopsync",normalizedTitle:"workloopsync",charIndex:65},{level:2,title:"workLoopConcurrent",slug:"workloopconcurrent",normalizedTitle:"workloopconcurrent",charIndex:81},{level:2,title:"performUnitOfWork",slug:"performunitofwork",normalizedTitle:"performunitofwork",charIndex:103},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:124},{level:3,title:" WorkLoop?",slug:"-workloop",normalizedTitle:" workloop?",charIndex:132},{level:3,title:" workLoop  performUnitOfWork ",slug:"-workloop--performunitofwork-",normalizedTitle:" workloop  performunitofwork ",charIndex:152},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:194},{level:3,title:"workInProgress ",slug:"workinprogress-",normalizedTitle:"workinprogress ",charIndex:202},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:229}],readingTime:{text:"6 min read",minutes:5.29,time:317400,words:1058},headersStr:"  renderRootSync renderRootConcurrent workLoopSync workLoopConcurrent performUnitOfWork   WorkLoop?  workLoop  performUnitOfWork   workInProgress  ",content:"# \n\n\n\n * \n * \n * renderRootSync\n * renderRootConcurrent\n * workLoopSync\n * workLoopConcurrent\n * performUnitOfWork\n * \n   *  WorkLoop?\n   *  workLoop  performUnitOfWork \n * \n   * workInProgress \n * \n\n\n\n\n# \n\n React  scheduleSyncCallback  scheduleCallback  performSyncWorkOnRoot  performConcurrentWorkOnRoot  Render \n\n\n# renderRootSync\n\n Render  FiberRoot \n\n\n\n VDOM  DOM  Render  React  ExecutionContext  RenderContext   FiberTree  FiberTree  FiberTree currentFiberTree FiberTree  VDOM  DOM Render String Commit \n\n\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\n  const prevExecutionContext = executionContext;\n  // executionContext  RenderContext\n  executionContext |= RenderContext;\n  //  dispatcher  contextOnlyDispatcher dispatcher\n  const prevDispatcher = pushDispatcher();\n  // ......\n  do {\n    try {\n      //  workLoop\n      workLoopSync();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n  // ......\n  // Render  dispatcher\n  executionContext = prevExecutionContext;\n  popDispatcher(prevDispatcher);\n  // ......\n\n  // Set this to null to indicate there's no in-progress render.\n  workInProgressRoot = null;\n  workInProgressRootRenderLanes = NoLanes;\n\n  return workInProgressRootExitStatus;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n\n * workLoopSync  FiberTree DFS\n *  workInProgressRootExitStatus  src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js  ReactFiberWorkLoop  workLoop  exitStatus \n *  renderRootSync  executionContext  RenderContext \n\n\n\n * pushDispatcher  popDispatcher dispatcher  hook  pushDispatcher  ReactCurrentDispatcher.current  ContextOnlyDispatcher  hook  hook  Render  hook \n *  Render  executionContext  Batch  Render  Commit \n\n\n# renderRootConcurrent\n\n Render  FiberRoot \n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\n  const prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  const prevDispatcher = pushDispatcher();\n\n  // ......\n  do {\n    try {\n      workLoopConcurrent();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n  // ......\n\n  popDispatcher(prevDispatcher);\n  executionContext = prevExecutionContext;\n\n  // Set this to null to indicate there's no in-progress render.\n  workInProgressRoot = null;\n  workInProgressRootRenderLanes = NoLanes;\n\n  // Return the final exit status.\n  return workInProgressRootExitStatus;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n renderRootSync  workLoop  workLoopConcurrent \n\n handleError \n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nfunction handleError(root, thrownValue): void {\n  do {\n    //  workInProgress  Fiber\n    let erroredWork = workInProgress;\n    try {\n      // ......\n      if (erroredWork === null || erroredWork.return === null) {\n        // Expected to be working on a non-root fiber. This is a fatal error\n        // because there's no ancestor that can handle it; the root is\n        // supposed to capture all errors that weren't caught by an error\n        // boundary.\n        //  Fiber Fiber \n        workInProgressRootExitStatus = RootFatalErrored;\n        workInProgressRootFatalError = thrownValue;\n        workInProgress = null;\n        return;\n      }\n      // ......\n\n      throwException(\n        root,\n        erroredWork.return,\n        erroredWork,\n        thrownValue,\n        workInProgressRootRenderLanes,\n      );\n      //  workLoop\n      completeUnitOfWork(erroredWork);\n    } catch (yetAnotherThrownValue) {\n      // ......\n    }\n    // Return to the normal work loop.\n    return;\n  } while (true);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n *  Fiber \n *  Fiber Work  Fiber \n\n\n# workLoopSync\n\n WorkLoop  workInProgress  Fiber workInProgress Fiber shouldYield  TimeOut \n\n\n\n workInProgress  FiberNode  \n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n// The work loop is an extremely hot path. Tell Closure not to inline it.\n/** @noinline */\nfunction workLoopSync() {\n  // Already timed out, so perform work without checking if we need to yield.\n  while (workInProgress !== null) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n while loop  work loop  workInProgress FiberTree  performUnitOfWork  traverse  FiberNode Work\n\ntraverse \n\ntraverse  compile  traverse  generate  FiberTree  FiberNode \n\n@noinline annotation\n\n Java \n\n * @inline\n * @noinline\n\n WHILE  performUnitOfWork  hot path  @noinline  JavaScript \n\n\n\n * Automatic Inlining in JavaScript Engines  ariya.io\n * Optimizing for V8 - Inlining, Deoptimizations | Codegen::RecordSafepoint\n\n\n# workLoopConcurrent\n\n WorkLoop  workInProgress  shouldYield  WorkLoop\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n/** @noinline */\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n WorkLoop  performUnitOfWork  WorkLoop \n\nshouldYield shouldYieldToHost\n\n\n# performUnitOfWork\n\n WorkLoop  WorkLoop  performUnitOfWork  traverse  FiberNode  Work  performUnitOfWork  FiberTree  FiberNode \n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nfunction performUnitOfWork(unitOfWork: Fiber): void {\n  // The current, flushed, state of this fiber is the alternate. \n  //  Fiber  currentFiberTree  Fiber\n  const current = unitOfWork.alternate;\n  //  Fiber FiberDFS\n  const next = beginWork(current, unitOfWork, subtreeRenderLanes);\n  //  pendingProps  memoizedProps Fiber \n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    //  Fiber \n    completeUnitOfWork(unitOfWork);\n  } else {\n    // workInProgress  Fiber\n    workInProgress = next;\n  }\n  // ReactCurrentOwner.current \n  ReactCurrentOwner.current = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n\n 1. Fiber  Fiber  Fiber   Fiber \n\ntype Fiber = {\n  // Fiber  fiber  alternate fiber\n  alternate: Fiber | null,\n  // Input is the data coming into process this fiber. Arguments. Props.\n  //  work-in-progress  props\n  pendingProps: any,\n  //  props\n  memoizedProps: any,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n WorkLoop  WorkInProgress FiberTree unitOfWork  WorkInProgress FiberNode FiberTree  unitOfWork.alternate  currentFiberTree  FiberNode current  FiberNode unitOfWork  FiberNode\n\n 2.  beginWork  Fiber  completeUnitOfWork  Fiber  beginWork  completeWork  next === null  WorkLoop\n 3.  beginWork  FiberNode workInProgress  WorkLoop  completeUnitOfWork \n 4. ReactCurrentOwner.current  ReactCurrentOwner.current  React \n 5.  performUnitOfWork   \n\nReactCurrentOwner.current?\n\n ReactCompositeComponent  render  ReactDomComponent  DOM  ReactCompositeComponent  ReactDomComponent  owner  ReactCurrentOwner.current  DOM \n\n ReactElement.__owner \n\n\n\n * React ReactCurrentOwner | Que's Blog\n * _owner  ReactElement  Fiber _owner \n\n\n# \n\n\n#  WorkLoop?\n\nWorkLoop  workInProgress FiberTree  FiberNode  beginWork  completeWork  EffectTag  ETag \n\nWorkLoop  workInProgress FiberTree  VDOM  DOM  ETag  workInProgress FiberTree  current FiberTree WorkLoop  Render  fiberRoot.current \n\n RootFiber  WorkLoop  FiberTree  WorkLoop  WorkLoop \n\n\n#  workLoop  performUnitOfWork \n\nworkLoop  FiberTree  performUnitOfWork  FiberNode  beginWork  completeWork  FiberTree  FiberTree \n\n performUnitOfWork  workLoopConcurrent  @noinline  workLoop  performUnitOfWork \n\n\n# \n\n\n# workInProgress \n\n workInProgress  WorkLoop  workInProgress  workInProgress \n\n renderRootSync  renderRootConcurrent \n\n// If the root or lanes have changed, throw out the existing stack\n// and prepare a fresh one. Otherwise we'll continue where we left off.\nif (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n  // ......\n  prepareFreshStack(root, lanes);\n}\n\nfunction prepareFreshStack(root: FiberRoot, lanes: Lanes) {\n  // ......\n  workInProgressRoot = root;\n  workInProgress = createWorkInProgress(root.current, null);\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\n  // ......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n workInProgressRoot  FiberTree  workInProgressStack  workInProgress  workInProgress  root.current  FiberNode \n\n\n# \n\n\n\n * Render  WorkLoop  WorkLoop \n * workLoopSync  workLoopConcurrent  FiberTree   performUnitOfWork  FiberNode workLoopConcurrent  workInProgress \n * performUnitOfWork  beginWork  completeWork  completeUnitOfWork ",normalizedContent:"# \n\n\n\n * \n * \n * renderrootsync\n * renderrootconcurrent\n * workloopsync\n * workloopconcurrent\n * performunitofwork\n * \n   *  workloop?\n   *  workloop  performunitofwork \n * \n   * workinprogress \n * \n\n\n\n\n# \n\n react  schedulesynccallback  schedulecallback  performsyncworkonroot  performconcurrentworkonroot  render \n\n\n# renderrootsync\n\n render  fiberroot \n\n\n\n vdom  dom  render  react  executioncontext  rendercontext   fibertree  fibertree  fibertree currentfibertree fibertree  vdom  dom render string commit \n\n\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nfunction renderrootsync(root: fiberroot, lanes: lanes) {\n  const prevexecutioncontext = executioncontext;\n  // executioncontext  rendercontext\n  executioncontext |= rendercontext;\n  //  dispatcher  contextonlydispatcher dispatcher\n  const prevdispatcher = pushdispatcher();\n  // ......\n  do {\n    try {\n      //  workloop\n      workloopsync();\n      break;\n    } catch (thrownvalue) {\n      handleerror(root, thrownvalue);\n    }\n  } while (true);\n  // ......\n  // render  dispatcher\n  executioncontext = prevexecutioncontext;\n  popdispatcher(prevdispatcher);\n  // ......\n\n  // set this to null to indicate there's no in-progress render.\n  workinprogressroot = null;\n  workinprogressrootrenderlanes = nolanes;\n\n  return workinprogressrootexitstatus;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n\n * workloopsync  fibertree dfs\n *  workinprogressrootexitstatus  src/react/packages/react-reconciler/src/reactfiberworkloop.new.js  reactfiberworkloop  workloop  exitstatus \n *  renderrootsync  executioncontext  rendercontext \n\n\n\n * pushdispatcher  popdispatcher dispatcher  hook  pushdispatcher  reactcurrentdispatcher.current  contextonlydispatcher  hook  hook  render  hook \n *  render  executioncontext  batch  render  commit \n\n\n# renderrootconcurrent\n\n render  fiberroot \n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nfunction renderrootconcurrent(root: fiberroot, lanes: lanes) {\n  const prevexecutioncontext = executioncontext;\n  executioncontext |= rendercontext;\n  const prevdispatcher = pushdispatcher();\n\n  // ......\n  do {\n    try {\n      workloopconcurrent();\n      break;\n    } catch (thrownvalue) {\n      handleerror(root, thrownvalue);\n    }\n  } while (true);\n  // ......\n\n  popdispatcher(prevdispatcher);\n  executioncontext = prevexecutioncontext;\n\n  // set this to null to indicate there's no in-progress render.\n  workinprogressroot = null;\n  workinprogressrootrenderlanes = nolanes;\n\n  // return the final exit status.\n  return workinprogressrootexitstatus;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n renderrootsync  workloop  workloopconcurrent \n\n handleerror \n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nfunction handleerror(root, thrownvalue): void {\n  do {\n    //  workinprogress  fiber\n    let erroredwork = workinprogress;\n    try {\n      // ......\n      if (erroredwork === null || erroredwork.return === null) {\n        // expected to be working on a non-root fiber. this is a fatal error\n        // because there's no ancestor that can handle it; the root is\n        // supposed to capture all errors that weren't caught by an error\n        // boundary.\n        //  fiber fiber \n        workinprogressrootexitstatus = rootfatalerrored;\n        workinprogressrootfatalerror = thrownvalue;\n        workinprogress = null;\n        return;\n      }\n      // ......\n\n      throwexception(\n        root,\n        erroredwork.return,\n        erroredwork,\n        thrownvalue,\n        workinprogressrootrenderlanes,\n      );\n      //  workloop\n      completeunitofwork(erroredwork);\n    } catch (yetanotherthrownvalue) {\n      // ......\n    }\n    // return to the normal work loop.\n    return;\n  } while (true);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n *  fiber \n *  fiber work  fiber \n\n\n# workloopsync\n\n workloop  workinprogress  fiber workinprogress fiber shouldyield  timeout \n\n\n\n workinprogress  fibernode  \n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n// the work loop is an extremely hot path. tell closure not to inline it.\n/** @noinline */\nfunction workloopsync() {\n  // already timed out, so perform work without checking if we need to yield.\n  while (workinprogress !== null) {\n    performunitofwork(workinprogress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n while loop  work loop  workinprogress fibertree  performunitofwork  traverse  fibernode work\n\ntraverse \n\ntraverse  compile  traverse  generate  fibertree  fibernode \n\n@noinline annotation\n\n java \n\n * @inline\n * @noinline\n\n while  performunitofwork  hot path  @noinline  javascript \n\n\n\n * automatic inlining in javascript engines  ariya.io\n * optimizing for v8 - inlining, deoptimizations | codegen::recordsafepoint\n\n\n# workloopconcurrent\n\n workloop  workinprogress  shouldyield  workloop\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n/** @noinline */\nfunction workloopconcurrent() {\n  // perform work until scheduler asks us to yield\n  while (workinprogress !== null && !shouldyield()) {\n    performunitofwork(workinprogress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n workloop  performunitofwork  workloop \n\nshouldyield shouldyieldtohost\n\n\n# performunitofwork\n\n workloop  workloop  performunitofwork  traverse  fibernode  work  performunitofwork  fibertree  fibernode \n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nfunction performunitofwork(unitofwork: fiber): void {\n  // the current, flushed, state of this fiber is the alternate. \n  //  fiber  currentfibertree  fiber\n  const current = unitofwork.alternate;\n  //  fiber fiberdfs\n  const next = beginwork(current, unitofwork, subtreerenderlanes);\n  //  pendingprops  memoizedprops fiber \n  unitofwork.memoizedprops = unitofwork.pendingprops;\n  if (next === null) {\n    // if this doesn't spawn new work, complete the current work.\n    //  fiber \n    completeunitofwork(unitofwork);\n  } else {\n    // workinprogress  fiber\n    workinprogress = next;\n  }\n  // reactcurrentowner.current \n  reactcurrentowner.current = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n\n 1. fiber  fiber  fiber   fiber \n\ntype fiber = {\n  // fiber  fiber  alternate fiber\n  alternate: fiber | null,\n  // input is the data coming into process this fiber. arguments. props.\n  //  work-in-progress  props\n  pendingprops: any,\n  //  props\n  memoizedprops: any,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n workloop  workinprogress fibertree unitofwork  workinprogress fibernode fibertree  unitofwork.alternate  currentfibertree  fibernode current  fibernode unitofwork  fibernode\n\n 2.  beginwork  fiber  completeunitofwork  fiber  beginwork  completework  next === null  workloop\n 3.  beginwork  fibernode workinprogress  workloop  completeunitofwork \n 4. reactcurrentowner.current  reactcurrentowner.current  react \n 5.  performunitofwork   \n\nreactcurrentowner.current?\n\n reactcompositecomponent  render  reactdomcomponent  dom  reactcompositecomponent  reactdomcomponent  owner  reactcurrentowner.current  dom \n\n reactelement.__owner \n\n\n\n * react reactcurrentowner | que's blog\n * _owner  reactelement  fiber _owner \n\n\n# \n\n\n#  workloop?\n\nworkloop  workinprogress fibertree  fibernode  beginwork  completework  effecttag  etag \n\nworkloop  workinprogress fibertree  vdom  dom  etag  workinprogress fibertree  current fibertree workloop  render  fiberroot.current \n\n rootfiber  workloop  fibertree  workloop  workloop \n\n\n#  workloop  performunitofwork \n\nworkloop  fibertree  performunitofwork  fibernode  beginwork  completework  fibertree  fibertree \n\n performunitofwork  workloopconcurrent  @noinline  workloop  performunitofwork \n\n\n# \n\n\n# workinprogress \n\n workinprogress  workloop  workinprogress  workinprogress \n\n renderrootsync  renderrootconcurrent \n\n// if the root or lanes have changed, throw out the existing stack\n// and prepare a fresh one. otherwise we'll continue where we left off.\nif (workinprogressroot !== root || workinprogressrootrenderlanes !== lanes) {\n  // ......\n  preparefreshstack(root, lanes);\n}\n\nfunction preparefreshstack(root: fiberroot, lanes: lanes) {\n  // ......\n  workinprogressroot = root;\n  workinprogress = createworkinprogress(root.current, null);\n  workinprogressrootrenderlanes = subtreerenderlanes = workinprogressrootincludedlanes = lanes;\n  // ......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n workinprogressroot  fibertree  workinprogressstack  workinprogress  workinprogress  root.current  fibernode \n\n\n# \n\n\n\n * render  workloop  workloop \n * workloopsync  workloopconcurrent  fibertree   performunitofwork  fibernode workloopconcurrent  workinprogress \n * performunitofwork  beginwork  completework  completeunitofwork ",charsets:{cjk:!0},lastUpdated:"2022/07/28, 09:19:48",lastUpdatedTimestamp:1658971188e3},{title:"React React ",frontmatter:{title:"React React ",date:"2022-07-20T12:02:21.000Z",permalink:"/react/tour/react-reconciliation-4/",categories:["react","React"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/120.react-reconciliation-4.html",relativePath:"10.react/90.React/120.react-reconciliation-4.md",key:"v-d7a41f02",path:"/react/tour/react-reconciliation-4/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:2,title:"beginWork",slug:"beginwork",normalizedTitle:"beginwork",charIndex:23},{level:3,title:"didReceiveUpdate",slug:"didreceiveupdate",normalizedTitle:"didreceiveupdate",charIndex:38},{level:3,title:"beginWork",slug:"beginwork-2",normalizedTitle:"beginwork",charIndex:23},{level:2,title:"mountIndeterminateComponent",slug:"mountindeterminatecomponent",normalizedTitle:"mountindeterminatecomponent",charIndex:73},{level:2,title:"mountLazyComponent",slug:"mountlazycomponent",normalizedTitle:"mountlazycomponent",charIndex:104},{level:2,title:"updateFunctionComponent",slug:"updatefunctioncomponent",normalizedTitle:"updatefunctioncomponent",charIndex:126},{level:2,title:"updateClassComponent",slug:"updateclasscomponent",normalizedTitle:"updateclasscomponent",charIndex:153},{level:2,title:"updateHostRoot",slug:"updatehostroot",normalizedTitle:"updatehostroot",charIndex:177},{level:2,title:"updateHostComponent",slug:"updatehostcomponent",normalizedTitle:"updatehostcomponent",charIndex:195},{level:2,title:"updateHostText",slug:"updatehosttext",normalizedTitle:"updatehosttext",charIndex:218},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:236},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:242},{level:3,title:"Component  workInProgress.type ",slug:"component--workinprogress-type-",normalizedTitle:"component  workinprogress.type ",charIndex:250},{level:3,title:"mountIndeterminateComponent Component(props, context)?",slug:"mountindeterminatecomponent-component-props-context",normalizedTitle:"mountindeterminatecomponent  component (props, context)?",charIndex:null},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:362}],readingTime:{text:"6 min read",minutes:5.285,time:317100,words:1057},headersStr:"  beginWork didReceiveUpdate beginWork mountIndeterminateComponent mountLazyComponent updateFunctionComponent updateClassComponent updateHostRoot updateHostComponent updateHostText   Component  workInProgress.type  mountIndeterminateComponent Component(props, context)? ",content:"# \n\n\n\n * \n * \n * beginWork\n   * didReceiveUpdate\n   * beginWork\n * mountIndeterminateComponent\n * mountLazyComponent\n * updateFunctionComponent\n * updateClassComponent\n * updateHostRoot\n * updateHostComponent\n * updateHostText\n * \n * \n   * Component  workInProgress.type \n   * mountIndeterminateComponent Component(props, context)?\n * \n\n\n\n\n# \n\n React  renderRootSync  renderRootConcurrent  workLoopSync  workLoopConcurrent  performUnitOfWork 5 \n\n5  Render  WorkLoop  performUnitOfWork  Fiber \n\n\n\n\n\n\n# beginWork\n\n beginWork  workInProgress Fiber  mount  update \n\n\n# didReceiveUpdate\n\ndidReceiveUpdate  didReceiveUpdate  didReceiveUpdate  Fiber  null \n\n\n\nif (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n    if (oldProps !== newProps) {\n      //  props \n      didReceiveUpdate = true;\n    } else {\n      // ......\n      didReceiveUpdate = false;\n    }\n  } else {\n    didReceiveUpdate = false;\n    // ......\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n\n *  current  current FiberTree  FiberNode workInProgress  workInProgress FiberTree  FiberNode\n * current === null  mount  update  React  mount  update \n\n\n\n Props  Component  Props?  performUnitOfWork  unitOfWork.memoizedProps = unitOfWork.pendingProps  oldProps  newProps \n\n didReceiveUpdate  beginWork \n\n\n# beginWork\n\n\n\n\n\n// src/react/packages/react-reconciler/src/ReactFiberBeginWork.new.js\nfunction beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  switch (workInProgress.tag) {\n    case IndeterminateComponent: \n      return mountIndeterminateComponent(/*......*/);\n    case LazyComponent: \n      return mountLazyComponent(/*......*/);\n    case FunctionComponent: \n      return updateFunctionComponent(/*......*/);\n    case ClassComponent: \n      return updateClassComponent(/*......*/);\n    case HostRoot:\n      return updateHostRoot(/*......*/);\n    case HostComponent:\n      return updateHostComponent(/*......*/);\n    case HostText:\n      return updateHostText(/*......*/);\n    case SuspenseComponent:\n      return updateSuspenseComponent(/*......*/);\n    case HostPortal:\n      return updatePortalComponent(/*......*/);\n    case ForwardRef: \n      return updateForwardRef(/*......*/);\n    case Fragment:\n      return updateFragment(/*......*/);\n    // ......\n    case ContextProvider:\n      return updateContextProvider(/*......*/);\n    case ContextConsumer:\n      return updateContextConsumer(/*......*/);\n    case MemoComponent: \n      return updateMemoComponent(/*......*/);\n    case SimpleMemoComponent: \n      return updateSimpleMemoComponent(/*......*/);\n    case IncompleteClassComponent: \n      return mountIncompleteClassComponent(/*......*/);\n    // ......\n    case OffscreenComponent: \n      return updateOffscreenComponent(/*......*/);\n    // ......\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# mountIndeterminateComponent\n\n   ReactChildren ReactElement\n\n:\n\n// src/react/packages/react-reconciler/src/ReactFiberBeginWork.new.js\nfunction mountIndeterminateComponent(\n  _current,\n  workInProgress,\n  Component,\n  renderLanes,\n) {\n  // ......\n  const props = workInProgress.pendingProps;\n  //  workInProgress context workInProgress.dependencies.firstContext = null\n  prepareToReadContext(workInProgress, renderLanes);\n  //  Component value \n  const value = Component(props, context)\n\n  // \n  if (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.render === 'function' &&\n    value.$$typeof === undefined\n  ) {\n    //  workInProgress \n    workInProgress.tag = ClassComponent;\n    workInProgress.updateQueue = null;\n    // ......\n    //  state\n    workInProgress.memoizedState =\n      value.state !== null && value.state !== undefined ? value.state : null;\n    //  state \n    initializeUpdateQueue(workInProgress);\n    //  workInProgress Fiber \n    adoptClassInstance(workInProgress, value);\n    //  `getDerivedStateFromProps`  `componentWillMount`\n    mountClassInstance(workInProgress, Component, props, renderLanes);\n    //  ReactElement\n    return finishClassComponent(\n      null,\n      workInProgress,\n      Component,\n      true,\n      false,\n      renderLanes,\n    );\n  } else {\n    //  workInProgress  FunctionComponent\n    workInProgress.tag = FunctionComponent;\n    // ......\n    //  ReactElement\n    reconcileChildren(null, workInProgress, value, renderLanes);\n    //  child \n    return workInProgress.child;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n\n *  Component workInProgress.type  Fiber.type  fiber  function/class/module  Fiber  ReactElement \n *  Component  object  render \n *    ClassComponent  FunctionComponent  child  WorkLoop \n\n\n# mountLazyComponent\n\nmountLazyComponent  LazyComponent   beginWork Lazy \n\n\n\n current ChildrenFiberTree \n\n\n# updateFunctionComponent\n\nupdateFunctionComponent  FunctionComponent \n\nfunction updateFunctionComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps: any,\n  renderLanes,\n) {\n  // ......\n  //  ReactChildren\n  const nextChildren = renderWithHooks(\n    current,\n    workInProgress,\n    Component,\n    nextProps,\n    undefined,\n    renderLanes,\n  );\n  //  Fiber \n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    //  `cloneChildFibers`  child \n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n  // ......\n  //  ReactChildren\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n\n 1.  ReactChildren\n 2.  cloneChildFibers  reconcileChildren \n\n\n# updateClassComponent\n\nupdateClassComponent  ClassComponent class \n\nfunction updateClassComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps: any,\n  renderLanes: Lanes,\n) {\n  // ......\n  // \n  const instance = workInProgress.stateNode;\n  let shouldUpdate;\n  if (instance === null) {\n    // ......\n    // new Component(props, context)\n    constructClassInstance(workInProgress, Component, nextProps);\n    // \n    mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n    shouldUpdate = true;\n  } else if (current === null) {\n    //  `componentWillReceiveProps``getDerivedStateFromProps`\n    shouldUpdate = resumeMountClassInstance(\n      workInProgress,\n      Component,\n      nextProps,\n      renderLanes,\n    );\n  } else {\n    //  `componentWillReceiveProps``getDerivedStateFromProps` props, state  context\n    shouldUpdate = updateClassInstance(\n      current,\n      workInProgress,\n      Component,\n      nextProps,\n      renderLanes,\n    );\n  }\n  //  shouldUpdate reconcileChildren  cloneChildFibers\n  const nextUnitOfWork = finishClassComponent(\n    current,\n    workInProgress,\n    Component,\n    shouldUpdate,\n    false,\n    renderLanes,\n  );\n  // ......\n  return nextUnitOfWork;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n instance  current  3 \n\n /                                    \nmount       mount           update \nupdate      suspended mount    update \n\n shouldUpdate  cloneChildFibers  reconcileChildren  FunctionComponent \n\n\n# updateHostRoot\n\nupdateHostRoot  HostRootFiber FiberTree  FiberRoot \n\nfunction updateHostRoot(current, workInProgress, renderLanes) {\n  // ......\n  const nextProps = workInProgress.pendingProps;\n  const prevChildren = workInProgress.memoizedState.element;\n  //  current  updateQueue  workInProgress\n  cloneUpdateQueue(current, workInProgress);\n  //  workInProgress  updateQueue  workInProgress.memoizedState\n  processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n  const nextChildren = workInProgress.memoizedState.element;\n  //  updateQueue  children \n  if (nextChildren === prevChildren) {\n    // ......\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n  // ......\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  // ...... \n  return workInProgress.child;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * cloneUpdateQueue  current  updateQueue  workInProgress  processUpdateQueue  current  processUpdateQueue reduce updateQueue  update state  effect\n *  updateQueue  children \n\n\n# updateHostComponent\n\nHostComponent  HTML  updateHostComponent  HTML \n\nfunction updateHostComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  // ......\n  const type = workInProgress.type;\n  const nextProps = workInProgress.pendingProps;\n  const prevProps = current !== null ? current.memoizedProps : null;\n  let nextChildren = nextProps.children;\n  //  textarea, noscript  nextChildren \n  //  HostText \n  const isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    nextChildren = null;\n  //  DirectTextChild ContentReset\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n    workInProgress.flags |= ContentReset;\n  }\n  // ......\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n *  HostComponent \n\n\n# updateHostText\n\nupdateHostText  HostText \n\nfunction updateHostText(current, workInProgress) {\n  // ......\n  return null;\n}\n\n\n1\n2\n3\n4\n\n\n children null performUnitOfWork \n\n\n# \n\n\n# \n\n\n# Component  workInProgress.type \n\n Component  FiberNode  prepareFreshStack  workInProgress  Fiber.type  React \n\n\n# mountIndeterminateComponent  Component(props, context) ?\n\n mountIndeterminateComponent  class  class  class \n\n *  class \n\nfunction TestIndeterminateComponent() {\n  return {\n    componentDidMount() {\n      console.log('componentDidMount')\n    },\n    state: { count: 1 },\n    updateCount() {\n     const { count } = this.state;\n     this.updater.enqueueSetState(\n      this,\n      { count: count + 1 },\n      undefined,\n      \"setState\"\n     );\n    },\n    render() {\n     return <div onClick={() => this.updateCount()}>{this.state.count}</div>;\n    },\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n mountIndeterminateComponent  function   initializeUpdateQueue  adoptClassInstance  mountClassInstance \n\n *  React.component  propsstateupdater  setState  forceUpdate  src/react/packages/react/src/ReactBaseClasses.js \n * mountIndeterminateComponent   \n\n\n# \n\n *  3  Component  nextChildren  workInProgress.child \n * beginWork  beginWork  fiber  workInProgress  null fiber  fiber  completeWork \n * beginWork  workInProgress FiberTree\n *  beginWork fiber  diff ",normalizedContent:"# \n\n\n\n * \n * \n * beginwork\n   * didreceiveupdate\n   * beginwork\n * mountindeterminatecomponent\n * mountlazycomponent\n * updatefunctioncomponent\n * updateclasscomponent\n * updatehostroot\n * updatehostcomponent\n * updatehosttext\n * \n * \n   * component  workinprogress.type \n   * mountindeterminatecomponent component(props, context)?\n * \n\n\n\n\n# \n\n react  renderrootsync  renderrootconcurrent  workloopsync  workloopconcurrent  performunitofwork 5 \n\n5  render  workloop  performunitofwork  fiber \n\n\n\n\n\n\n# beginwork\n\n beginwork  workinprogress fiber  mount  update \n\n\n# didreceiveupdate\n\ndidreceiveupdate  didreceiveupdate  didreceiveupdate  fiber  null \n\n\n\nif (current !== null) {\n    const oldprops = current.memoizedprops;\n    const newprops = workinprogress.pendingprops;\n    if (oldprops !== newprops) {\n      //  props \n      didreceiveupdate = true;\n    } else {\n      // ......\n      didreceiveupdate = false;\n    }\n  } else {\n    didreceiveupdate = false;\n    // ......\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n\n *  current  current fibertree  fibernode workinprogress  workinprogress fibertree  fibernode\n * current === null  mount  update  react  mount  update \n\n\n\n props  component  props?  performunitofwork  unitofwork.memoizedprops = unitofwork.pendingprops  oldprops  newprops \n\n didreceiveupdate  beginwork \n\n\n# beginwork\n\n\n\n\n\n// src/react/packages/react-reconciler/src/reactfiberbeginwork.new.js\nfunction beginwork(\n  current: fiber | null,\n  workinprogress: fiber,\n  renderlanes: lanes,\n): fiber | null {\n  switch (workinprogress.tag) {\n    case indeterminatecomponent: \n      return mountindeterminatecomponent(/*......*/);\n    case lazycomponent: \n      return mountlazycomponent(/*......*/);\n    case functioncomponent: \n      return updatefunctioncomponent(/*......*/);\n    case classcomponent: \n      return updateclasscomponent(/*......*/);\n    case hostroot:\n      return updatehostroot(/*......*/);\n    case hostcomponent:\n      return updatehostcomponent(/*......*/);\n    case hosttext:\n      return updatehosttext(/*......*/);\n    case suspensecomponent:\n      return updatesuspensecomponent(/*......*/);\n    case hostportal:\n      return updateportalcomponent(/*......*/);\n    case forwardref: \n      return updateforwardref(/*......*/);\n    case fragment:\n      return updatefragment(/*......*/);\n    // ......\n    case contextprovider:\n      return updatecontextprovider(/*......*/);\n    case contextconsumer:\n      return updatecontextconsumer(/*......*/);\n    case memocomponent: \n      return updatememocomponent(/*......*/);\n    case simplememocomponent: \n      return updatesimplememocomponent(/*......*/);\n    case incompleteclasscomponent: \n      return mountincompleteclasscomponent(/*......*/);\n    // ......\n    case offscreencomponent: \n      return updateoffscreencomponent(/*......*/);\n    // ......\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# mountindeterminatecomponent\n\n   reactchildren reactelement\n\n:\n\n// src/react/packages/react-reconciler/src/reactfiberbeginwork.new.js\nfunction mountindeterminatecomponent(\n  _current,\n  workinprogress,\n  component,\n  renderlanes,\n) {\n  // ......\n  const props = workinprogress.pendingprops;\n  //  workinprogress context workinprogress.dependencies.firstcontext = null\n  preparetoreadcontext(workinprogress, renderlanes);\n  //  component value \n  const value = component(props, context)\n\n  // \n  if (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.render === 'function' &&\n    value.$$typeof === undefined\n  ) {\n    //  workinprogress \n    workinprogress.tag = classcomponent;\n    workinprogress.updatequeue = null;\n    // ......\n    //  state\n    workinprogress.memoizedstate =\n      value.state !== null && value.state !== undefined ? value.state : null;\n    //  state \n    initializeupdatequeue(workinprogress);\n    //  workinprogress fiber \n    adoptclassinstance(workinprogress, value);\n    //  `getderivedstatefromprops`  `componentwillmount`\n    mountclassinstance(workinprogress, component, props, renderlanes);\n    //  reactelement\n    return finishclasscomponent(\n      null,\n      workinprogress,\n      component,\n      true,\n      false,\n      renderlanes,\n    );\n  } else {\n    //  workinprogress  functioncomponent\n    workinprogress.tag = functioncomponent;\n    // ......\n    //  reactelement\n    reconcilechildren(null, workinprogress, value, renderlanes);\n    //  child \n    return workinprogress.child;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n\n *  component workinprogress.type  fiber.type  fiber  function/class/module  fiber  reactelement \n *  component  object  render \n *    classcomponent  functioncomponent  child  workloop \n\n\n# mountlazycomponent\n\nmountlazycomponent  lazycomponent   beginwork lazy \n\n\n\n current childrenfibertree \n\n\n# updatefunctioncomponent\n\nupdatefunctioncomponent  functioncomponent \n\nfunction updatefunctioncomponent(\n  current,\n  workinprogress,\n  component,\n  nextprops: any,\n  renderlanes,\n) {\n  // ......\n  //  reactchildren\n  const nextchildren = renderwithhooks(\n    current,\n    workinprogress,\n    component,\n    nextprops,\n    undefined,\n    renderlanes,\n  );\n  //  fiber \n  if (current !== null && !didreceiveupdate) {\n    bailouthooks(current, workinprogress, renderlanes);\n    //  `clonechildfibers`  child \n    return bailoutonalreadyfinishedwork(current, workinprogress, renderlanes);\n  }\n  // ......\n  //  reactchildren\n  reconcilechildren(current, workinprogress, nextchildren, renderlanes);\n  return workinprogress.child;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n\n 1.  reactchildren\n 2.  clonechildfibers  reconcilechildren \n\n\n# updateclasscomponent\n\nupdateclasscomponent  classcomponent class \n\nfunction updateclasscomponent(\n  current: fiber | null,\n  workinprogress: fiber,\n  component: any,\n  nextprops: any,\n  renderlanes: lanes,\n) {\n  // ......\n  // \n  const instance = workinprogress.statenode;\n  let shouldupdate;\n  if (instance === null) {\n    // ......\n    // new component(props, context)\n    constructclassinstance(workinprogress, component, nextprops);\n    // \n    mountclassinstance(workinprogress, component, nextprops, renderlanes);\n    shouldupdate = true;\n  } else if (current === null) {\n    //  `componentwillreceiveprops``getderivedstatefromprops`\n    shouldupdate = resumemountclassinstance(\n      workinprogress,\n      component,\n      nextprops,\n      renderlanes,\n    );\n  } else {\n    //  `componentwillreceiveprops``getderivedstatefromprops` props, state  context\n    shouldupdate = updateclassinstance(\n      current,\n      workinprogress,\n      component,\n      nextprops,\n      renderlanes,\n    );\n  }\n  //  shouldupdate reconcilechildren  clonechildfibers\n  const nextunitofwork = finishclasscomponent(\n    current,\n    workinprogress,\n    component,\n    shouldupdate,\n    false,\n    renderlanes,\n  );\n  // ......\n  return nextunitofwork;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n instance  current  3 \n\n /                                    \nmount       mount           update \nupdate      suspended mount    update \n\n shouldupdate  clonechildfibers  reconcilechildren  functioncomponent \n\n\n# updatehostroot\n\nupdatehostroot  hostrootfiber fibertree  fiberroot \n\nfunction updatehostroot(current, workinprogress, renderlanes) {\n  // ......\n  const nextprops = workinprogress.pendingprops;\n  const prevchildren = workinprogress.memoizedstate.element;\n  //  current  updatequeue  workinprogress\n  cloneupdatequeue(current, workinprogress);\n  //  workinprogress  updatequeue  workinprogress.memoizedstate\n  processupdatequeue(workinprogress, nextprops, null, renderlanes);\n  const nextchildren = workinprogress.memoizedstate.element;\n  //  updatequeue  children \n  if (nextchildren === prevchildren) {\n    // ......\n    return bailoutonalreadyfinishedwork(current, workinprogress, renderlanes);\n  }\n  // ......\n  reconcilechildren(current, workinprogress, nextchildren, renderlanes);\n  // ...... \n  return workinprogress.child;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * cloneupdatequeue  current  updatequeue  workinprogress  processupdatequeue  current  processupdatequeue reduce updatequeue  update state  effect\n *  updatequeue  children \n\n\n# updatehostcomponent\n\nhostcomponent  html  updatehostcomponent  html \n\nfunction updatehostcomponent(\n  current: fiber | null,\n  workinprogress: fiber,\n  renderlanes: lanes,\n) {\n  // ......\n  const type = workinprogress.type;\n  const nextprops = workinprogress.pendingprops;\n  const prevprops = current !== null ? current.memoizedprops : null;\n  let nextchildren = nextprops.children;\n  //  textarea, noscript  nextchildren \n  //  hosttext \n  const isdirecttextchild = shouldsettextcontent(type, nextprops);\n\n  if (isdirecttextchild) {\n    nextchildren = null;\n  //  directtextchild contentreset\n  } else if (prevprops !== null && shouldsettextcontent(type, prevprops)) {\n    workinprogress.flags |= contentreset;\n  }\n  // ......\n  reconcilechildren(current, workinprogress, nextchildren, renderlanes);\n  return workinprogress.child;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n *  hostcomponent \n\n\n# updatehosttext\n\nupdatehosttext  hosttext \n\nfunction updatehosttext(current, workinprogress) {\n  // ......\n  return null;\n}\n\n\n1\n2\n3\n4\n\n\n children null performunitofwork \n\n\n# \n\n\n# \n\n\n# component  workinprogress.type \n\n component  fibernode  preparefreshstack  workinprogress  fiber.type  react \n\n\n# mountindeterminatecomponent  component(props, context) ?\n\n mountindeterminatecomponent  class  class  class \n\n *  class \n\nfunction testindeterminatecomponent() {\n  return {\n    componentdidmount() {\n      console.log('componentdidmount')\n    },\n    state: { count: 1 },\n    updatecount() {\n     const { count } = this.state;\n     this.updater.enqueuesetstate(\n      this,\n      { count: count + 1 },\n      undefined,\n      \"setstate\"\n     );\n    },\n    render() {\n     return <div onclick={() => this.updatecount()}>{this.state.count}</div>;\n    },\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n mountindeterminatecomponent  function   initializeupdatequeue  adoptclassinstance  mountclassinstance \n\n *  react.component  propsstateupdater  setstate  forceupdate  src/react/packages/react/src/reactbaseclasses.js \n * mountindeterminatecomponent   \n\n\n# \n\n *  3  component  nextchildren  workinprogress.child \n * beginwork  beginwork  fiber  workinprogress  null fiber  fiber  completework \n * beginwork  workinprogress fibertree\n *  beginwork fiber  diff ",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"React React ",frontmatter:{title:"React React ",date:"2022-07-25T12:02:21.000Z",permalink:"/react/tour/react-reconciliation-5/",categories:["react","React"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/130.react-reconciliation-5.html",relativePath:"10.react/90.React/130.react-reconciliation-5.md",key:"v-620e1d82",path:"/react/tour/react-reconciliation-5/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:2,title:"bailoutOnAlreadyFinishedWork",slug:"bailoutonalreadyfinishedwork",normalizedTitle:"bailoutonalreadyfinishedwork",charIndex:23},{level:2,title:"cloneChildFibers",slug:"clonechildfibers",normalizedTitle:"clonechildfibers",charIndex:55},{level:2,title:"reconcileChildren",slug:"reconcilechildren",normalizedTitle:"reconcilechildren",charIndex:75},{level:2,title:"reconcileChildFibers",slug:"reconcilechildfibers",normalizedTitle:"reconcilechildfibers",charIndex:96},{level:2,title:"reconcileChildrenArray",slug:"reconcilechildrenarray",normalizedTitle:"reconcilechildrenarray",charIndex:120},{level:2,title:"reconcileSingleElement",slug:"reconcilesingleelement",normalizedTitle:"reconcilesingleelement",charIndex:146},{level:2,title:"reconcileSingleTextNode",slug:"reconcilesingletextnode",normalizedTitle:"reconcilesingletextnode",charIndex:172},{level:2,title:"placeSingleChild",slug:"placesinglechild",normalizedTitle:"placesinglechild",charIndex:199},{level:2,title:"updateSlot",slug:"updateslot",normalizedTitle:"updateslot",charIndex:219},{level:2,title:"updateFromMap",slug:"updatefrommap",normalizedTitle:"updatefrommap",charIndex:233},{level:2,title:"placeChild",slug:"placechild",normalizedTitle:"placechild",charIndex:250},{level:2,title:"deleteChild",slug:"deletechild",normalizedTitle:"deletechild",charIndex:264},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:279},{level:3,title:" reconcileChildren ",slug:"-reconcilechildren-",normalizedTitle:" reconcilechildren ",charIndex:287},{level:3,title:"workInProgress Tree ",slug:"workinprogress-tree-",normalizedTitle:"workinprogress tree ",charIndex:329},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:361},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:367},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:373}],readingTime:{text:"9 min read",minutes:8.96,time:537600,words:1792},headersStr:"  bailoutOnAlreadyFinishedWork cloneChildFibers reconcileChildren reconcileChildFibers reconcileChildrenArray reconcileSingleElement reconcileSingleTextNode placeSingleChild updateSlot updateFromMap placeChild deleteChild   reconcileChildren  workInProgress Tree    ",content:"# \n\n\n\n * \n * \n * bailoutOnAlreadyFinishedWork\n * cloneChildFibers\n * reconcileChildren\n * reconcileChildFibers\n * reconcileChildrenArray\n * reconcileSingleElement\n * reconcileSingleTextNode\n * placeSingleChild\n * updateSlot\n * updateFromMap\n * placeChild\n * deleteChild\n * \n   *  reconcileChildren \n   * workInProgress Tree \n * \n * \n * \n\n\n\n\n# \n\n beginWork  React  cloneChildFibers  reconcileChildren \n\n\n# bailoutOnAlreadyFinishedWork\n\n bailoutOnAlreadyFinishedWork  cloneChildFibers \n\n// src/react/packages/react-reconciler/src/ReactFiberBeginWork.new.js\nfunction bailoutOnAlreadyFinishedWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  // ......\n  markSkippedUpdateLanes(workInProgress.lanes);\n\n  // Check if the children have any pending work.\n  //  childLanes \n  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n    // The children don't have any work either. We can skip them.\n    return null;\n  }\n  // This fiber doesn't have work, but its subtree does. Clone the child\n  // fibers and continue.\n  //  fibers \n  cloneChildFibers(current, workInProgress);\n  return workInProgress.child;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n\n * markSkippedUpdateLanes  lanes  workInProgress.lanes  lanes \n *  renderLanes  workInProgress  childLanes  FiberTree  null \n\n\n# cloneChildFibers\n\n Fiber \n\nexport function cloneChildFibers(\n  current: Fiber | null,\n  workInProgress: Fiber,\n): void {\n  // ......\n  let currentChild = workInProgress.child;\n  let newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n  workInProgress.child = newChild;\n  newChild.return = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(\n      currentChild,\n      currentChild.pendingProps,\n    );\n    newChild.return = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n\n\n\n * createWorkInProgress  workInProgress fiber  current FiberNode  workInProgress  Fiber  createFiber \n * newChild \n\n\n# reconcileChildren\n\n\n\nexport function reconcileChildren(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  nextChildren: any,\n  renderLanes: Lanes,\n) {\n  if (current === null) {\n    workInProgress.child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderLanes,\n    );\n  } else {\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      current.child,\n      nextChildren,\n      renderLanes,\n    );\n  }\n}\n\nconst reconcileChildFibers = ChildReconciler(true);\nconst mountChildFibers = ChildReconciler(false);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n\n *  mountChildFibers  reconcileChildFibers  ChildReconciler \n * reconcileChildren  workInProgress.child \n\n\n# reconcileChildFibers\n\n workInProgress  children \n\n// src/react/packages/react-reconciler/src/ReactChildFiber.new.js\n// This API will tag the children with the side-effect of the reconciliation\n// itself. They will be added to the side-effect list as we pass through the\n// children and the parent.\nfunction reconcileChildFibers(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  newChild: any,\n  lanes: Lanes,\n): Fiber | null {\n  //  Element Fragment  REACT_FRAGMENT_TYPE\n  const isUnkeyedTopLevelFragment =\n    typeof newChild === 'object' &&\n    newChild !== null &&\n    newChild.type === REACT_FRAGMENT_TYPE &&\n    newChild.key === null;\n  if (isUnkeyedTopLevelFragment) {\n    newChild = newChild.props.children;\n  }\n\n  // \n  if (typeof newChild === 'object' && newChild !== null) {\n    switch (newChild.$$typeof) {\n      case REACT_ELEMENT_TYPE:\n        return placeSingleChild(reconcileSingleElement(/*...*/));\n      case REACT_PORTAL_TYPE:\n        return placeSingleChild(reconcileSinglePortal(/*...*/));\n      case REACT_LAZY_TYPE:\n        return reconcileChildFibers(/*...*/);\n    }\n\n    if (isArray(newChild)) {\n      return reconcileChildrenArray(/*...*/);\n    }\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(/*...*/);\n    }\n    // ......\n  }\n  // \n  if (\n    (typeof newChild === 'string' && newChild !== '') ||\n    typeof newChild === 'number'\n  ) {\n    return placeSingleChild(reconcileSingleTextNode(/*...*/));\n  }\n\n  // \n  return deleteRemainingChildren(returnFiber, currentFirstChild);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n\n *  newChild  newChild  ReactElement React.createElement  ReactElement \n * React.Fragment \n *  Fiber  ReactElement  ReactElement.$$typeof  ElementPortalLazy \n * reconcileplace workInProgress FiberTree  Fiber \n *  Lazy \n *  reconcileChildFibers \n * reconcileChildFibers  ReactElement  Fiber  newChild  ReactElement Fiber \n\n Element  REACT_ELEMENT_TYPE  Element \n\n\n# reconcileChildrenArray\n\n DIFF  DIFF  current Fiber  ReactElement  workInProgress Fiber\n\n\n\n\n\n * current \n * ReactElement \n * current Fiber\n * ReactElement ReactElement\n *  DIFF Fiber\n\n\n\n// src/react/packages/react-reconciler/src/ReactChildFiber.new.js\nfunction reconcileChildrenArray(\n  // workInProgress Fiber\n  returnFiber: Fiber,\n  // current Fiber \n  currentFirstChild: Fiber | null,\n  //  ReactElement\n  newChildren: Array<*>,\n  // \n  lanes: Lanes,\n): Fiber | null {\n  // ......\n  // \n  let resultingFirstChild: Fiber | null = null;\n  // \n  let previousNewFiber: Fiber | null = null;\n  //  current \n  let oldFiber = currentFirstChild;\n  // \n  let lastPlacedIndex = 0;\n  let newIdx = 0;\n  // \n  let nextOldFiber = null;\n  //  DIFF\n  for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n    // \n    // \n    if (oldFiber.index > newIdx) {\n      nextOldFiber = oldFiber;\n      oldFiber = null;\n    } else {\n      // \n      nextOldFiber = oldFiber.sibling;\n    }\n    // \n    //  children  key  null\n    const newFiber = updateSlot(\n      returnFiber,\n      //  null\n      oldFiber,\n      // \n      newChildren[newIdx],\n      lanes,\n    );\n    // \n    if (newFiber === null) {\n      if (oldFiber === null) {\n        oldFiber = nextOldFiber;\n      }\n      break;\n    }\n    // \n    if (shouldTrackSideEffects) {\n      if (oldFiber && newFiber.alternate === null) {\n        deleteChild(returnFiber, oldFiber);\n      }\n    }\n    // \n    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n    //  resultingFirstChild  sibling \n    if (previousNewFiber === null) {\n      resultingFirstChild = newFiber;\n    } else {\n      previousNewFiber.sibling = newFiber;\n    }\n    previousNewFiber = newFiber;\n    // \n    oldFiber = nextOldFiber;\n  }\n  // DIFF \n  if (newIdx === newChildren.length) {\n    deleteRemainingChildren(returnFiber, oldFiber);\n    // ......\n    return resultingFirstChild;\n  }\n  //  DIFF\n  if (oldFiber === null) {\n    // \n    for (; newIdx < newChildren.length; newIdx++) {\n      // \n      const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\n      if (newFiber === null) {\n        continue;\n      }\n      // \n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      // \n      if (previousNewFiber === null) {\n        resultingFirstChild = newFiber;\n      } else {\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n    }\n    // ......\n    return resultingFirstChild;\n  }\n\n  //  DIFF DIFF  key \n  //  DIFF \n  const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n  // \n  for (; newIdx < newChildren.length; newIdx++) {\n    // \n    //  key \n    const newFiber = updateFromMap(\n      existingChildren,\n      returnFiber,\n      newIdx,\n      newChildren[newIdx],\n      lanes,\n    );\n    // \n    if (newFiber !== null) {\n      if (shouldTrackSideEffects) {\n        // \n        if (newFiber.alternate !== null) {\n          existingChildren.delete(\n            newFiber.key === null ? newIdx : newFiber.key,\n          );\n        }\n      }\n      // \n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        resultingFirstChild = newFiber;\n      } else {\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n    }\n  }\n  // \n  if (shouldTrackSideEffects) {\n    existingChildren.forEach(child => deleteChild(returnFiber, child));\n  }\n  // ......\n  // \n  return resultingFirstChild;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n\n\n\n\n * DIFF  DIFF key  key  newChild.key === key  null DIFF  DIFF\n *  DIFF  DIFF vue3  DIFF  vue3  DIFF React  DIFF  DIFF React  sibling  Vue3  vue3 \n *  key  warnOnInvalidKey  key  key \n *  key  key  DIFF  key \n\n\n# reconcileSingleElement\n\n Element \n\n// src/react/packages/react-reconciler/src/ReactChildFiber.new.js\nfunction reconcileSingleElement(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    element: ReactElement,\n    lanes: Lanes,\n  ): Fiber {\n  const key = element.key;\n  let child = currentFirstChild;\n  // \n  while (child !== null) {\n    // key\n    if (child.key === key) {\n      const elementType = element.type;\n      //  Element  Fragment Fragment\n      //  reconcileChildFibers  Element \n      if (elementType === REACT_FRAGMENT_TYPE) {\n        if (child.tag === Fragment) {\n          //  child \n          deleteRemainingChildren(returnFiber, child.sibling);\n          //  child  Element  child  sibling \n          const existing = useFiber(child, element.props.children);\n          //  return  returnFiber\n          existing.return = returnFiber;\n          // ......\n          return existing;\n        }\n      } else {\n        //  Element  Fragment Element \n        if (child.elementType === elementType /*......*/) {\n          // \n          deleteRemainingChildren(returnFiber, child.sibling);\n          // \n          const existing = useFiber(child, element.props);\n          //  string refs\n          existing.ref = coerceRef(returnFiber, child, element);\n          //  return  returnFiber\n          existing.return = returnFiber;\n          // ......\n          return existing;\n        }\n      }\n      // Didn't match.\n      deleteRemainingChildren(returnFiber, child);\n      break;\n    } else {\n      // \n      deleteChild(returnFiber, child);\n    }\n    // \n    child = child.sibling;\n  }\n  //  Element Fiber\n  if (element.type === REACT_FRAGMENT_TYPE) {\n    const created = createFiberFromFragment(/*......*/);\n    created.return = returnFiber;\n    return created;\n  } else {\n    const created = createFiberFromElement(element, returnFiber.mode, lanes);\n    created.ref = coerceRef(returnFiber, currentFirstChild, element);\n    created.return = returnFiber;\n    return created;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n\n\n * coerceRef  String Refs  Legacy API: String Refs\n *  Element  Element Fragment   Element useFiber  createFiberFromFragment  createFiberFromElement \n\n\n# reconcileSingleTextNode\n\n Element \n\nfunction reconcileSingleTextNode(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  textContent: string,\n  lanes: Lanes,\n): Fiber {\n  // \n  if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n    const existing = useFiber(currentFirstChild, textContent);\n    existing.return = returnFiber;\n    return existing;\n  }\n  // \n  deleteRemainingChildren(returnFiber, currentFirstChild);\n  const created = createFiberFromText(textContent, returnFiber.mode, lanes);\n  created.return = returnFiber;\n  return created;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n Element  createFiberFromText  FIber  return \n\n\n# placeSingleChild\n\n reconcileSingleElement Effect Tag\n\n// src/react/packages/react-reconciler/src/ReactChildFiber.new.js\nfunction placeSingleChild(newFiber: Fiber): Fiber {\n  //  Placement \n  if (shouldTrackSideEffects && newFiber.alternate === null) {\n    newFiber.flags |= Placement;\n  }\n  return newFiber;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# updateSlot\n\n reconcileChildrenArray \n\nfunction updateSlot(\n    returnFiber: Fiber,\n    oldFiber: Fiber | null,\n    newChild: any,\n    lanes: Lanes,\n  ): Fiber | null {\n  const key = oldFiber !== null ? oldFiber.key : null;\n  //  updateTextNode \n  if (\n    (typeof newChild === 'string' && newChild !== '') ||\n    typeof newChild === 'number'\n  ) {\n    // ......\n    return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);\n  }\n\n  if (typeof newChild === 'object' && newChild !== null) {\n    switch (newChild.$$typeof) {\n      case REACT_ELEMENT_TYPE: {\n        if (newChild.key === key) {\n          return updateElement(returnFiber, oldFiber, newChild, lanes);\n        } else {\n          return null;\n        }\n      }\n      case REACT_PORTAL_TYPE: {\n        if (newChild.key === key) {\n          return updatePortal(returnFiber, oldFiber, newChild, lanes);\n        } else {\n          return null;\n        }\n      }\n      case REACT_LAZY_TYPE: {\n        const payload = newChild._payload;\n        const init = newChild._init;\n        return updateSlot(returnFiber, oldFiber, init(payload), lanes);\n      }\n    }\n    //  Fragment \n    if (isArray(newChild) || getIteratorFn(newChild)) {\n      // ......\n      return updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n    }\n    // ......\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n\n     TEXT             ELEMENT         PORTAL         LAZY         FRAGMENT\n   updateTextNode   updateElement   updatePortal   updateSlot   updateFragment\n\n key  null\n\n\n# updateFromMap\n\n reconcileChildrenArray  updateSlot \n\n\n# placeChild\n\n reconcileChildrenArray \n\nfunction placeChild(\n  newFiber: Fiber,\n  lastPlacedIndex: number,\n  newIndex: number,\n): number {\n  // \n  newFiber.index = newIndex;\n  const current = newFiber.alternate;\n  // ......\n  // current  current \n  //  Placement\n  // \n  if (current !== null) {\n    const oldIndex = current.index;\n    if (oldIndex < lastPlacedIndex) {\n      newFiber.flags |= Placement;\n      return lastPlacedIndex;\n    } else {\n      return oldIndex;\n    }\n  } else {\n    //  Placement \n    newFiber.flags |= Placement;\n    return lastPlacedIndex;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# deleteChild\n\n returnFiber  ChildDeletion \n\nfunction deleteChild(returnFiber: Fiber, childToDelete: Fiber): void {\n  //  ChildDeletion \n  if (!shouldTrackSideEffects) return;\n  //  returnFiber.deletions  returnFiber  ChildDeletion \n  const deletions = returnFiber.deletions;\n  if (deletions === null) {\n    returnFiber.deletions = [childToDelete];\n    returnFiber.flags |= ChildDeletion;\n  } else {\n    deletions.push(childToDelete);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# \n\n\n#  reconcileChildren \n\n cloneChildFibers  reconcileChildren  renderWithHooks  constructClassInstance  mountClassInstance  updateClassInstance  finishClassComponent \n\n\n# workInProgress Tree \n\n\n\n\n\n WorkLoop  workInProgress  workInProgress  beginWork  reconcileChildren mount reconcileChildFibers  workInProgress Fiber\n\n\n# \n\n\n# \n\n React  workInProgress DIFF Effect TagworkInProgress  ReactElement Fiber  ReactElement  Fiber  workInProgress Fiber  DOM \n\n\n\n * React DIFF \n * React  FiberRoot  Vue3 \n * React  VDOM  VDOM  ReactElement FiberTree ReactElement  React  FiberTree  ReactElement  VDOM FiberTree  VDOM\n *  Placement  ChildDeletion  ContentReset DOM  Placement  ChildDeletion  ContentReset  HostComponent \n\n\n# \n\n * React    react diff",normalizedContent:"# \n\n\n\n * \n * \n * bailoutonalreadyfinishedwork\n * clonechildfibers\n * reconcilechildren\n * reconcilechildfibers\n * reconcilechildrenarray\n * reconcilesingleelement\n * reconcilesingletextnode\n * placesinglechild\n * updateslot\n * updatefrommap\n * placechild\n * deletechild\n * \n   *  reconcilechildren \n   * workinprogress tree \n * \n * \n * \n\n\n\n\n# \n\n beginwork  react  clonechildfibers  reconcilechildren \n\n\n# bailoutonalreadyfinishedwork\n\n bailoutonalreadyfinishedwork  clonechildfibers \n\n// src/react/packages/react-reconciler/src/reactfiberbeginwork.new.js\nfunction bailoutonalreadyfinishedwork(\n  current: fiber | null,\n  workinprogress: fiber,\n  renderlanes: lanes,\n): fiber | null {\n  // ......\n  markskippedupdatelanes(workinprogress.lanes);\n\n  // check if the children have any pending work.\n  //  childlanes \n  if (!includessomelane(renderlanes, workinprogress.childlanes)) {\n    // the children don't have any work either. we can skip them.\n    return null;\n  }\n  // this fiber doesn't have work, but its subtree does. clone the child\n  // fibers and continue.\n  //  fibers \n  clonechildfibers(current, workinprogress);\n  return workinprogress.child;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n\n * markskippedupdatelanes  lanes  workinprogress.lanes  lanes \n *  renderlanes  workinprogress  childlanes  fibertree  null \n\n\n# clonechildfibers\n\n fiber \n\nexport function clonechildfibers(\n  current: fiber | null,\n  workinprogress: fiber,\n): void {\n  // ......\n  let currentchild = workinprogress.child;\n  let newchild = createworkinprogress(currentchild, currentchild.pendingprops);\n  workinprogress.child = newchild;\n  newchild.return = workinprogress;\n  while (currentchild.sibling !== null) {\n    currentchild = currentchild.sibling;\n    newchild = newchild.sibling = createworkinprogress(\n      currentchild,\n      currentchild.pendingprops,\n    );\n    newchild.return = workinprogress;\n  }\n  newchild.sibling = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n\n\n\n * createworkinprogress  workinprogress fiber  current fibernode  workinprogress  fiber  createfiber \n * newchild \n\n\n# reconcilechildren\n\n\n\nexport function reconcilechildren(\n  current: fiber | null,\n  workinprogress: fiber,\n  nextchildren: any,\n  renderlanes: lanes,\n) {\n  if (current === null) {\n    workinprogress.child = mountchildfibers(\n      workinprogress,\n      null,\n      nextchildren,\n      renderlanes,\n    );\n  } else {\n    workinprogress.child = reconcilechildfibers(\n      workinprogress,\n      current.child,\n      nextchildren,\n      renderlanes,\n    );\n  }\n}\n\nconst reconcilechildfibers = childreconciler(true);\nconst mountchildfibers = childreconciler(false);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n\n *  mountchildfibers  reconcilechildfibers  childreconciler \n * reconcilechildren  workinprogress.child \n\n\n# reconcilechildfibers\n\n workinprogress  children \n\n// src/react/packages/react-reconciler/src/reactchildfiber.new.js\n// this api will tag the children with the side-effect of the reconciliation\n// itself. they will be added to the side-effect list as we pass through the\n// children and the parent.\nfunction reconcilechildfibers(\n  returnfiber: fiber,\n  currentfirstchild: fiber | null,\n  newchild: any,\n  lanes: lanes,\n): fiber | null {\n  //  element fragment  react_fragment_type\n  const isunkeyedtoplevelfragment =\n    typeof newchild === 'object' &&\n    newchild !== null &&\n    newchild.type === react_fragment_type &&\n    newchild.key === null;\n  if (isunkeyedtoplevelfragment) {\n    newchild = newchild.props.children;\n  }\n\n  // \n  if (typeof newchild === 'object' && newchild !== null) {\n    switch (newchild.$$typeof) {\n      case react_element_type:\n        return placesinglechild(reconcilesingleelement(/*...*/));\n      case react_portal_type:\n        return placesinglechild(reconcilesingleportal(/*...*/));\n      case react_lazy_type:\n        return reconcilechildfibers(/*...*/);\n    }\n\n    if (isarray(newchild)) {\n      return reconcilechildrenarray(/*...*/);\n    }\n    if (getiteratorfn(newchild)) {\n      return reconcilechildreniterator(/*...*/);\n    }\n    // ......\n  }\n  // \n  if (\n    (typeof newchild === 'string' && newchild !== '') ||\n    typeof newchild === 'number'\n  ) {\n    return placesinglechild(reconcilesingletextnode(/*...*/));\n  }\n\n  // \n  return deleteremainingchildren(returnfiber, currentfirstchild);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n\n *  newchild  newchild  reactelement react.createelement  reactelement \n * react.fragment \n *  fiber  reactelement  reactelement.$$typeof  elementportallazy \n * reconcileplace workinprogress fibertree  fiber \n *  lazy \n *  reconcilechildfibers \n * reconcilechildfibers  reactelement  fiber  newchild  reactelement fiber \n\n element  react_element_type  element \n\n\n# reconcilechildrenarray\n\n diff  diff  current fiber  reactelement  workinprogress fiber\n\n\n\n\n\n * current \n * reactelement \n * current fiber\n * reactelement reactelement\n *  diff fiber\n\n\n\n// src/react/packages/react-reconciler/src/reactchildfiber.new.js\nfunction reconcilechildrenarray(\n  // workinprogress fiber\n  returnfiber: fiber,\n  // current fiber \n  currentfirstchild: fiber | null,\n  //  reactelement\n  newchildren: array<*>,\n  // \n  lanes: lanes,\n): fiber | null {\n  // ......\n  // \n  let resultingfirstchild: fiber | null = null;\n  // \n  let previousnewfiber: fiber | null = null;\n  //  current \n  let oldfiber = currentfirstchild;\n  // \n  let lastplacedindex = 0;\n  let newidx = 0;\n  // \n  let nextoldfiber = null;\n  //  diff\n  for (; oldfiber !== null && newidx < newchildren.length; newidx++) {\n    // \n    // \n    if (oldfiber.index > newidx) {\n      nextoldfiber = oldfiber;\n      oldfiber = null;\n    } else {\n      // \n      nextoldfiber = oldfiber.sibling;\n    }\n    // \n    //  children  key  null\n    const newfiber = updateslot(\n      returnfiber,\n      //  null\n      oldfiber,\n      // \n      newchildren[newidx],\n      lanes,\n    );\n    // \n    if (newfiber === null) {\n      if (oldfiber === null) {\n        oldfiber = nextoldfiber;\n      }\n      break;\n    }\n    // \n    if (shouldtracksideeffects) {\n      if (oldfiber && newfiber.alternate === null) {\n        deletechild(returnfiber, oldfiber);\n      }\n    }\n    // \n    lastplacedindex = placechild(newfiber, lastplacedindex, newidx);\n    //  resultingfirstchild  sibling \n    if (previousnewfiber === null) {\n      resultingfirstchild = newfiber;\n    } else {\n      previousnewfiber.sibling = newfiber;\n    }\n    previousnewfiber = newfiber;\n    // \n    oldfiber = nextoldfiber;\n  }\n  // diff \n  if (newidx === newchildren.length) {\n    deleteremainingchildren(returnfiber, oldfiber);\n    // ......\n    return resultingfirstchild;\n  }\n  //  diff\n  if (oldfiber === null) {\n    // \n    for (; newidx < newchildren.length; newidx++) {\n      // \n      const newfiber = createchild(returnfiber, newchildren[newidx], lanes);\n      if (newfiber === null) {\n        continue;\n      }\n      // \n      lastplacedindex = placechild(newfiber, lastplacedindex, newidx);\n      // \n      if (previousnewfiber === null) {\n        resultingfirstchild = newfiber;\n      } else {\n        previousnewfiber.sibling = newfiber;\n      }\n      previousnewfiber = newfiber;\n    }\n    // ......\n    return resultingfirstchild;\n  }\n\n  //  diff diff  key \n  //  diff \n  const existingchildren = mapremainingchildren(returnfiber, oldfiber);\n\n  // \n  for (; newidx < newchildren.length; newidx++) {\n    // \n    //  key \n    const newfiber = updatefrommap(\n      existingchildren,\n      returnfiber,\n      newidx,\n      newchildren[newidx],\n      lanes,\n    );\n    // \n    if (newfiber !== null) {\n      if (shouldtracksideeffects) {\n        // \n        if (newfiber.alternate !== null) {\n          existingchildren.delete(\n            newfiber.key === null ? newidx : newfiber.key,\n          );\n        }\n      }\n      // \n      lastplacedindex = placechild(newfiber, lastplacedindex, newidx);\n      if (previousnewfiber === null) {\n        resultingfirstchild = newfiber;\n      } else {\n        previousnewfiber.sibling = newfiber;\n      }\n      previousnewfiber = newfiber;\n    }\n  }\n  // \n  if (shouldtracksideeffects) {\n    existingchildren.foreach(child => deletechild(returnfiber, child));\n  }\n  // ......\n  // \n  return resultingfirstchild;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n\n\n\n\n * diff  diff key  key  newchild.key === key  null diff  diff\n *  diff  diff vue3  diff  vue3  diff react  diff  diff react  sibling  vue3  vue3 \n *  key  warnoninvalidkey  key  key \n *  key  key  diff  key \n\n\n# reconcilesingleelement\n\n element \n\n// src/react/packages/react-reconciler/src/reactchildfiber.new.js\nfunction reconcilesingleelement(\n    returnfiber: fiber,\n    currentfirstchild: fiber | null,\n    element: reactelement,\n    lanes: lanes,\n  ): fiber {\n  const key = element.key;\n  let child = currentfirstchild;\n  // \n  while (child !== null) {\n    // key\n    if (child.key === key) {\n      const elementtype = element.type;\n      //  element  fragment fragment\n      //  reconcilechildfibers  element \n      if (elementtype === react_fragment_type) {\n        if (child.tag === fragment) {\n          //  child \n          deleteremainingchildren(returnfiber, child.sibling);\n          //  child  element  child  sibling \n          const existing = usefiber(child, element.props.children);\n          //  return  returnfiber\n          existing.return = returnfiber;\n          // ......\n          return existing;\n        }\n      } else {\n        //  element  fragment element \n        if (child.elementtype === elementtype /*......*/) {\n          // \n          deleteremainingchildren(returnfiber, child.sibling);\n          // \n          const existing = usefiber(child, element.props);\n          //  string refs\n          existing.ref = coerceref(returnfiber, child, element);\n          //  return  returnfiber\n          existing.return = returnfiber;\n          // ......\n          return existing;\n        }\n      }\n      // didn't match.\n      deleteremainingchildren(returnfiber, child);\n      break;\n    } else {\n      // \n      deletechild(returnfiber, child);\n    }\n    // \n    child = child.sibling;\n  }\n  //  element fiber\n  if (element.type === react_fragment_type) {\n    const created = createfiberfromfragment(/*......*/);\n    created.return = returnfiber;\n    return created;\n  } else {\n    const created = createfiberfromelement(element, returnfiber.mode, lanes);\n    created.ref = coerceref(returnfiber, currentfirstchild, element);\n    created.return = returnfiber;\n    return created;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n\n\n * coerceref  string refs  legacy api: string refs\n *  element  element fragment   element usefiber  createfiberfromfragment  createfiberfromelement \n\n\n# reconcilesingletextnode\n\n element \n\nfunction reconcilesingletextnode(\n  returnfiber: fiber,\n  currentfirstchild: fiber | null,\n  textcontent: string,\n  lanes: lanes,\n): fiber {\n  // \n  if (currentfirstchild !== null && currentfirstchild.tag === hosttext) {\n    deleteremainingchildren(returnfiber, currentfirstchild.sibling);\n    const existing = usefiber(currentfirstchild, textcontent);\n    existing.return = returnfiber;\n    return existing;\n  }\n  // \n  deleteremainingchildren(returnfiber, currentfirstchild);\n  const created = createfiberfromtext(textcontent, returnfiber.mode, lanes);\n  created.return = returnfiber;\n  return created;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n element  createfiberfromtext  fiber  return \n\n\n# placesinglechild\n\n reconcilesingleelement effect tag\n\n// src/react/packages/react-reconciler/src/reactchildfiber.new.js\nfunction placesinglechild(newfiber: fiber): fiber {\n  //  placement \n  if (shouldtracksideeffects && newfiber.alternate === null) {\n    newfiber.flags |= placement;\n  }\n  return newfiber;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# updateslot\n\n reconcilechildrenarray \n\nfunction updateslot(\n    returnfiber: fiber,\n    oldfiber: fiber | null,\n    newchild: any,\n    lanes: lanes,\n  ): fiber | null {\n  const key = oldfiber !== null ? oldfiber.key : null;\n  //  updatetextnode \n  if (\n    (typeof newchild === 'string' && newchild !== '') ||\n    typeof newchild === 'number'\n  ) {\n    // ......\n    return updatetextnode(returnfiber, oldfiber, '' + newchild, lanes);\n  }\n\n  if (typeof newchild === 'object' && newchild !== null) {\n    switch (newchild.$$typeof) {\n      case react_element_type: {\n        if (newchild.key === key) {\n          return updateelement(returnfiber, oldfiber, newchild, lanes);\n        } else {\n          return null;\n        }\n      }\n      case react_portal_type: {\n        if (newchild.key === key) {\n          return updateportal(returnfiber, oldfiber, newchild, lanes);\n        } else {\n          return null;\n        }\n      }\n      case react_lazy_type: {\n        const payload = newchild._payload;\n        const init = newchild._init;\n        return updateslot(returnfiber, oldfiber, init(payload), lanes);\n      }\n    }\n    //  fragment \n    if (isarray(newchild) || getiteratorfn(newchild)) {\n      // ......\n      return updatefragment(returnfiber, oldfiber, newchild, lanes, null);\n    }\n    // ......\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n\n     text             element         portal         lazy         fragment\n   updatetextnode   updateelement   updateportal   updateslot   updatefragment\n\n key  null\n\n\n# updatefrommap\n\n reconcilechildrenarray  updateslot \n\n\n# placechild\n\n reconcilechildrenarray \n\nfunction placechild(\n  newfiber: fiber,\n  lastplacedindex: number,\n  newindex: number,\n): number {\n  // \n  newfiber.index = newindex;\n  const current = newfiber.alternate;\n  // ......\n  // current  current \n  //  placement\n  // \n  if (current !== null) {\n    const oldindex = current.index;\n    if (oldindex < lastplacedindex) {\n      newfiber.flags |= placement;\n      return lastplacedindex;\n    } else {\n      return oldindex;\n    }\n  } else {\n    //  placement \n    newfiber.flags |= placement;\n    return lastplacedindex;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# deletechild\n\n returnfiber  childdeletion \n\nfunction deletechild(returnfiber: fiber, childtodelete: fiber): void {\n  //  childdeletion \n  if (!shouldtracksideeffects) return;\n  //  returnfiber.deletions  returnfiber  childdeletion \n  const deletions = returnfiber.deletions;\n  if (deletions === null) {\n    returnfiber.deletions = [childtodelete];\n    returnfiber.flags |= childdeletion;\n  } else {\n    deletions.push(childtodelete);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# \n\n\n#  reconcilechildren \n\n clonechildfibers  reconcilechildren  renderwithhooks  constructclassinstance  mountclassinstance  updateclassinstance  finishclasscomponent \n\n\n# workinprogress tree \n\n\n\n\n\n workloop  workinprogress  workinprogress  beginwork  reconcilechildren mount reconcilechildfibers  workinprogress fiber\n\n\n# \n\n\n# \n\n react  workinprogress diff effect tagworkinprogress  reactelement fiber  reactelement  fiber  workinprogress fiber  dom \n\n\n\n * react diff \n * react  fiberroot  vue3 \n * react  vdom  vdom  reactelement fibertree reactelement  react  fibertree  reactelement  vdom fibertree  vdom\n *  placement  childdeletion  contentreset dom  placement  childdeletion  contentreset  hostcomponent \n\n\n# \n\n * react    react diff",charsets:{cjk:!0},lastUpdated:"2022/08/01, 20:37:47",lastUpdatedTimestamp:1659357467e3},{title:"React React ",frontmatter:{title:"React React ",date:"2022-07-30T12:02:21.000Z",permalink:"/react/tour/react-reconciliation-6/",categories:["react","React"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/140.react-reconciliation-6.html",relativePath:"10.react/90.React/140.react-reconciliation-6.md",key:"v-09c3f1ff",path:"/react/tour/react-reconciliation-6/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:2,title:"completeUnitOfWork",slug:"completeunitofwork",normalizedTitle:"completeunitofwork",charIndex:23},{level:2,title:"completeWork",slug:"completework",normalizedTitle:"completework",charIndex:45},{level:2,title:"bubbleProperties",slug:"bubbleproperties",normalizedTitle:"bubbleproperties",charIndex:61},{level:2,title:"Render ",slug:"render-",normalizedTitle:"render ",charIndex:81},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:97},{level:3,title:"bubbleProperties  subtreeFlags?",slug:"bubbleproperties--subtreeflags",normalizedTitle:"bubbleproperties  subtreeflags?",charIndex:105},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:147},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:153},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:159}],readingTime:{text:"5 min read",minutes:4.32,time:259200.00000000006,words:864},headersStr:"  completeUnitOfWork completeWork bubbleProperties Render   bubbleProperties  subtreeFlags?   ",content:"# \n\n\n\n * \n * \n * completeUnitOfWork\n * completeWork\n * bubbleProperties\n * Render \n * \n   * bubbleProperties  subtreeFlags?\n * \n * \n * \n\n\n\n\n# \n\n React     workInProgress  IndeterminateComponent  LazyComponent  FunctionComponent  ClassComponent   JSX  ReactElement     state  props  FiberTree DOM \n\n   React  \n\n    \n\n performUnitOfWork \n\nconst next = beginWork(current, unitOfWork, subtreeRenderLanes);\nif (next === null) {\n  completeUnitOfWork(unitOfWork);\n} else {\n  workInProgress = next;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n next  performUnitOfWork  next  unitOfWork  workInProgress  completeUnitOfWork \n\n\n\n FiberTree  sibling return  WorkLoop?\n\n\n# completeUnitOfWork\n\n beginWork workInProgress completeWork  performUnitOfWork  FiberTree \n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nfunction completeUnitOfWork(unitOfWork: Fiber): void {\n  // Attempt to complete the current unit of work, then move to the next\n  // sibling. If there are no more siblings, return to the parent fiber.\n  let completedWork = unitOfWork;\n  do {\n    //  workInProgress Fiber  alternate  current Fiber\n    const current = completedWork.alternate;\n    //  workInProgress Fiber  return \n    const returnFiber = completedWork.return;\n\n    //  flags  Incomplete \n    if ((completedWork.flags & Incomplete) === NoFlags) {\n      // ......\n      // completeWork  next  null\n      const next = completeWork(current, completedWork, subtreeRenderLanes);\n      // workInProgress \n      if (next !== null) {\n        workInProgress = next;\n        return;\n      }\n    } else {\n      // Fiber \n      // unwindWork \n      //  return \n      const next = unwindWork(completedWork, subtreeRenderLanes);\n      if (next !== null) {\n        next.flags &= HostEffectMask;\n        workInProgress = next;\n        return;\n      }\n      // ......\n      //  returnFiber  Incomplete \n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its subtree flags.\n        returnFiber.flags |= Incomplete;\n        returnFiber.subtreeFlags = NoFlags;\n        returnFiber.deletions = null;\n      }\n    }\n    //  beginWork  completeWork\n    const siblingFiber = completedWork.sibling;\n    if (siblingFiber !== null) {\n      workInProgress = siblingFiber;\n      return;\n    }\n    //  completedWork  workInProgress \n    //  return\n    completedWork = returnFiber;\n    workInProgress = completedWork;\n  } while (completedWork !== null);\n\n  // \n  //  `RootCompleted`\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootCompleted;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n\n *  performUnitOfWork  completeUnitOfWork  DFS  child  sibling  return DFS  child -> sibling -> return \n *  completeUnitOfWork  Incomplete  beginWork  completeWork \n *  WorkLoop  RootCompleted  renderRootSync  renderRootConcurrent  performSyncWorkOnRoot  performConcurrentWorkOnRoot  Render  Commit \n * workInProgressRootExitStatus  workInProgress  RootFiber WorkLoop   \n\n\n\nRootExitStatus \n\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\nconst RootIncomplete = 0; // \nconst RootFatalErrored = 1; // \nconst RootErrored = 2; // \nconst RootSuspended = 3; // \nconst RootSuspendedWithDelay = 4; // \nconst RootCompleted = 5; // \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# completeWork\n\n completeUnitOfWork  completeWork  workInProgress Fiber \n\nfunction completeWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  const newProps = workInProgress.pendingProps;\n  // ......\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n    case LazyComponent:\n    case SimpleMemoComponent:\n    case FunctionComponent:\n    case ForwardRef:\n    case Fragment:\n    case Mode:\n    case Profiler:\n    case ContextConsumer:\n    case MemoComponent:\n      bubbleProperties(workInProgress);\n      return null;\n    case ClassComponent: {\n      // ......\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case HostRoot: {\n      // ......\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case HostComponent: {\n      // ......\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case HostText: {\n      // ......\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case SuspenseComponent: /*......*/\n    case HostPortal:\n      // ......\n      bubbleProperties(workInProgress);\n      return null;\n    case ContextProvider:\n      // ......\n      bubbleProperties(workInProgress);\n      return null;\n    case IncompleteClassComponent: {\n      // ......\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case SuspenseListComponent:  /*......*/\n    case ScopeComponent:  /*......*/\n    case OffscreenComponent:\n    case LegacyHiddenComponent:  /*......*/\n    case CacheComponent: /*......*/\n  }\n  // ......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n bubbleProperties \n\n\n# bubbleProperties\n\n childLanes  subtreeFlags  FiberTree  childLanes  subtreeFlags \n\nfunction bubbleProperties(completedWork: Fiber) {\n  //  bailoutOnAlreadyFinishedWork  beginWork \n  // child  cloneChildFibers\n  const didBailout =\n    completedWork.alternate !== null &&\n    completedWork.alternate.child === completedWork.child;\n  // ......\n  let newChildLanes = NoLanes;\n  let subtreeFlags = NoFlags;\n  let child = completedWork.child;\n  while (child !== null) {\n    newChildLanes = mergeLanes(\n      newChildLanes,\n      mergeLanes(child.lanes, child.childLanes),\n    );\n    subtreeFlags |= child.subtreeFlags;\n    subtreeFlags |= child.flags;\n    child.return = completedWork;\n    child = child.sibling;\n  }\n\n  completedWork.subtreeFlags |= subtreeFlags;\n  completedWork.childLanes = newChildLanes;\n\n  return didBailout;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n\n * didBailout  bailout    bailout \n\n\n# Render \n\nRender  Commit  Batch  Render  Commit  ExecutionContext  Batch  Render  Commit  Render  Host  Web SSR \n\nReact  batch  Render  Render  yield  Commit  Commit  Batch  Render  Commit  workInProgress FiberTree  current FiberTree \n\n Render  performSyncWorkOnRoot  performConcurrentWorkOnRoot React \n\n// performSyncWorkOnRoot\nlet exitStatus = renderRootSync(root, lanes);\n// performConcurrentWorkOnRoot\nlet exitStatus = shouldTimeSlice\n    ? renderRootConcurrent(root, lanes)\n    : renderRootSync(root, lanes);\n\nconst finishedWork: Fiber = (root.current.alternate: any);\nroot.finishedWork = finishedWork;\nroot.finishedLanes = lanes;\n// performSyncWorkOnRoot\ncommitRoot(root);\n// performConcurrentWorkOnRoot\nfinishConcurrentRender(root, exitStatus, lanes);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n Render  Commit  Render  finishedWork  finishedLanes  workInProgress FiberTree  lanes Commit \n\nReact  root  FiberRoot  FiberRoot  current  finishedWork  FiberTree current  workInProgress  alternate \n\n Commit \n\n\n# \n\n\n# bubbleProperties  subtreeFlags ?\n\n React  Fiber  EffectTag  Effect List  Commit  Effect List  mutation  React  Effect List  subtreeFlags  subtreeFlags  EffectTag  completeWork  Commit  subtreeFlags  mutation \n\nReact Effects List \n\n\n# \n\n\n# \n\n WorkLoop     \n\n * completeUnitOfWork   WorkLoop  beginWork  completeWork  beginWork  Fiber  EffectTag  completeWork \n\n\n# ",normalizedContent:"# \n\n\n\n * \n * \n * completeunitofwork\n * completework\n * bubbleproperties\n * render \n * \n   * bubbleproperties  subtreeflags?\n * \n * \n * \n\n\n\n\n# \n\n react     workinprogress  indeterminatecomponent  lazycomponent  functioncomponent  classcomponent   jsx  reactelement     state  props  fibertree dom \n\n   react  \n\n    \n\n performunitofwork \n\nconst next = beginwork(current, unitofwork, subtreerenderlanes);\nif (next === null) {\n  completeunitofwork(unitofwork);\n} else {\n  workinprogress = next;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n next  performunitofwork  next  unitofwork  workinprogress  completeunitofwork \n\n\n\n fibertree  sibling return  workloop?\n\n\n# completeunitofwork\n\n beginwork workinprogress completework  performunitofwork  fibertree \n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nfunction completeunitofwork(unitofwork: fiber): void {\n  // attempt to complete the current unit of work, then move to the next\n  // sibling. if there are no more siblings, return to the parent fiber.\n  let completedwork = unitofwork;\n  do {\n    //  workinprogress fiber  alternate  current fiber\n    const current = completedwork.alternate;\n    //  workinprogress fiber  return \n    const returnfiber = completedwork.return;\n\n    //  flags  incomplete \n    if ((completedwork.flags & incomplete) === noflags) {\n      // ......\n      // completework  next  null\n      const next = completework(current, completedwork, subtreerenderlanes);\n      // workinprogress \n      if (next !== null) {\n        workinprogress = next;\n        return;\n      }\n    } else {\n      // fiber \n      // unwindwork \n      //  return \n      const next = unwindwork(completedwork, subtreerenderlanes);\n      if (next !== null) {\n        next.flags &= hosteffectmask;\n        workinprogress = next;\n        return;\n      }\n      // ......\n      //  returnfiber  incomplete \n      if (returnfiber !== null) {\n        // mark the parent fiber as incomplete and clear its subtree flags.\n        returnfiber.flags |= incomplete;\n        returnfiber.subtreeflags = noflags;\n        returnfiber.deletions = null;\n      }\n    }\n    //  beginwork  completework\n    const siblingfiber = completedwork.sibling;\n    if (siblingfiber !== null) {\n      workinprogress = siblingfiber;\n      return;\n    }\n    //  completedwork  workinprogress \n    //  return\n    completedwork = returnfiber;\n    workinprogress = completedwork;\n  } while (completedwork !== null);\n\n  // \n  //  `rootcompleted`\n  if (workinprogressrootexitstatus === rootincomplete) {\n    workinprogressrootexitstatus = rootcompleted;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n\n *  performunitofwork  completeunitofwork  dfs  child  sibling  return dfs  child -> sibling -> return \n *  completeunitofwork  incomplete  beginwork  completework \n *  workloop  rootcompleted  renderrootsync  renderrootconcurrent  performsyncworkonroot  performconcurrentworkonroot  render  commit \n * workinprogressrootexitstatus  workinprogress  rootfiber workloop   \n\n\n\nrootexitstatus \n\ntype rootexitstatus = 0 | 1 | 2 | 3 | 4 | 5;\nconst rootincomplete = 0; // \nconst rootfatalerrored = 1; // \nconst rooterrored = 2; // \nconst rootsuspended = 3; // \nconst rootsuspendedwithdelay = 4; // \nconst rootcompleted = 5; // \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# completework\n\n completeunitofwork  completework  workinprogress fiber \n\nfunction completework(\n  current: fiber | null,\n  workinprogress: fiber,\n  renderlanes: lanes,\n): fiber | null {\n  const newprops = workinprogress.pendingprops;\n  // ......\n  switch (workinprogress.tag) {\n    case indeterminatecomponent:\n    case lazycomponent:\n    case simplememocomponent:\n    case functioncomponent:\n    case forwardref:\n    case fragment:\n    case mode:\n    case profiler:\n    case contextconsumer:\n    case memocomponent:\n      bubbleproperties(workinprogress);\n      return null;\n    case classcomponent: {\n      // ......\n      bubbleproperties(workinprogress);\n      return null;\n    }\n    case hostroot: {\n      // ......\n      bubbleproperties(workinprogress);\n      return null;\n    }\n    case hostcomponent: {\n      // ......\n      bubbleproperties(workinprogress);\n      return null;\n    }\n    case hosttext: {\n      // ......\n      bubbleproperties(workinprogress);\n      return null;\n    }\n    case suspensecomponent: /*......*/\n    case hostportal:\n      // ......\n      bubbleproperties(workinprogress);\n      return null;\n    case contextprovider:\n      // ......\n      bubbleproperties(workinprogress);\n      return null;\n    case incompleteclasscomponent: {\n      // ......\n      bubbleproperties(workinprogress);\n      return null;\n    }\n    case suspenselistcomponent:  /*......*/\n    case scopecomponent:  /*......*/\n    case offscreencomponent:\n    case legacyhiddencomponent:  /*......*/\n    case cachecomponent: /*......*/\n  }\n  // ......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n bubbleproperties \n\n\n# bubbleproperties\n\n childlanes  subtreeflags  fibertree  childlanes  subtreeflags \n\nfunction bubbleproperties(completedwork: fiber) {\n  //  bailoutonalreadyfinishedwork  beginwork \n  // child  clonechildfibers\n  const didbailout =\n    completedwork.alternate !== null &&\n    completedwork.alternate.child === completedwork.child;\n  // ......\n  let newchildlanes = nolanes;\n  let subtreeflags = noflags;\n  let child = completedwork.child;\n  while (child !== null) {\n    newchildlanes = mergelanes(\n      newchildlanes,\n      mergelanes(child.lanes, child.childlanes),\n    );\n    subtreeflags |= child.subtreeflags;\n    subtreeflags |= child.flags;\n    child.return = completedwork;\n    child = child.sibling;\n  }\n\n  completedwork.subtreeflags |= subtreeflags;\n  completedwork.childlanes = newchildlanes;\n\n  return didbailout;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n\n * didbailout  bailout    bailout \n\n\n# render \n\nrender  commit  batch  render  commit  executioncontext  batch  render  commit  render  host  web ssr \n\nreact  batch  render  render  yield  commit  commit  batch  render  commit  workinprogress fibertree  current fibertree \n\n render  performsyncworkonroot  performconcurrentworkonroot react \n\n// performsyncworkonroot\nlet exitstatus = renderrootsync(root, lanes);\n// performconcurrentworkonroot\nlet exitstatus = shouldtimeslice\n    ? renderrootconcurrent(root, lanes)\n    : renderrootsync(root, lanes);\n\nconst finishedwork: fiber = (root.current.alternate: any);\nroot.finishedwork = finishedwork;\nroot.finishedlanes = lanes;\n// performsyncworkonroot\ncommitroot(root);\n// performconcurrentworkonroot\nfinishconcurrentrender(root, exitstatus, lanes);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n render  commit  render  finishedwork  finishedlanes  workinprogress fibertree  lanes commit \n\nreact  root  fiberroot  fiberroot  current  finishedwork  fibertree current  workinprogress  alternate \n\n commit \n\n\n# \n\n\n# bubbleproperties  subtreeflags ?\n\n react  fiber  effecttag  effect list  commit  effect list  mutation  react  effect list  subtreeflags  subtreeflags  effecttag  completework  commit  subtreeflags  mutation \n\nreact effects list \n\n\n# \n\n\n# \n\n workloop     \n\n * completeunitofwork   workloop  beginwork  completework  beginwork  fiber  effecttag  completework \n\n\n# ",charsets:{cjk:!0},lastUpdated:"2022/08/01, 20:37:47",lastUpdatedTimestamp:1659357467e3},{title:"React React ",frontmatter:{title:"React React ",date:"2022-08-01T12:02:21.000Z",permalink:"/react/tour/react-reconciliation-7/",categories:["react","React"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/150.react-reconciliation-7.html",relativePath:"10.react/90.React/150.react-reconciliation-7.md",key:"v-448ef2bf",path:"/react/tour/react-reconciliation-7/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:2,title:"finishConcurrentRender",slug:"finishconcurrentrender",normalizedTitle:"finishconcurrentrender",charIndex:23},{level:2,title:"commitRoot",slug:"commitroot",normalizedTitle:"commitroot",charIndex:49},{level:2,title:"EffectList ",slug:"effectlist-",normalizedTitle:"effectlist ",charIndex:63},{level:2,title:"commitBeforeMutationEffects",slug:"commitbeforemutationeffects",normalizedTitle:"commitbeforemutationeffects",charIndex:81},{level:2,title:"commitMutationEffects",slug:"commitmutationeffects",normalizedTitle:"commitmutationeffects",charIndex:112},{level:2,title:"commitLayoutEffects",slug:"commitlayouteffects",normalizedTitle:"commitlayouteffects",charIndex:137},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:160},{level:3,title:"commitRootImpl  flushPassiveEffects ",slug:"commitrootimpl--flushpassiveeffects-",normalizedTitle:"commitrootimpl  flushpassiveeffects ",charIndex:168},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:217},{level:3,title:" layout  requestPaint?",slug:"-layout--requestpaint",normalizedTitle:" layout  requestpaint?",charIndex:225},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:261},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:267}],readingTime:{text:"8 min read",minutes:7.08,time:424800,words:1416},headersStr:"  finishConcurrentRender commitRoot EffectList  commitBeforeMutationEffects commitMutationEffects commitLayoutEffects  commitRootImpl  flushPassiveEffects    layout  requestPaint?  ",content:"# \n\n\n\n * \n * \n * finishConcurrentRender\n * commitRoot\n * EffectList \n * commitBeforeMutationEffects\n * commitMutationEffects\n * commitLayoutEffects\n * \n   * commitRootImpl  flushPassiveEffects \n * \n   *  layout  requestPaint?\n * \n * \n\n\n\n\n# \n\n React      Batch  Render  Commit  FiberTree  DOMTree \n\n commitRoot  finishConcurrentRender  finishConcurrentRender \n\n\n# finishConcurrentRender\n\n finishConcurrentRender  commitRoot  Render  Commit  Render exitStatus Commit  DOM \n\nfunction finishConcurrentRender(root, exitStatus, lanes) {\n  switch (exitStatus) {\n    // ......\n    case RootErrored: {\n      commitRoot(root);\n      break;\n    }\n    case RootSuspended:\n    case RootSuspendedWithDelay: {\n      markRootSuspended(root, lanes);\n      // ......\n      // The work expired. Commit immediately.\n      commitRoot(root);\n      break;\n    }\n    case RootCompleted: {\n      // The work completed. Ready to commit.\n      commitRoot(root);\n      break;\n    }\n    //  ......\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n\n *  RootIncomplete ()  RootFatalErrored \n *  RootSuspended  RootSuspendedWithDelay \n\n\n# commitRoot\n\ncommitRoot  commitRootImpl \n\nfunction commitRootImpl(root, renderPriorityLevel) {\n  do {\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n    // means `flushPassiveEffects` will sometimes result in additional\n    // passive effects. So we need to keep flushing in a loop until there are\n    // no more pending effects.\n    flushPassiveEffects();\n  } while (rootWithPendingPassiveEffects !== null);\n  // ......\n  //  Batch \n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n  const finishedWork = root.finishedWork;\n  //  commit \n  const lanes = root.finishedLanes;\n  // ......\n  // finishedWork lanes\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\n  //  root.pendingLanes \n  markRootFinished(root, remainingLanes);\n  // ......\n  // If there are pending passive effects, schedule a callback to process them.\n  // Do this as early as possible, so it is queued before anything else that\n  // might get scheduled in the commit phase. \n  //  PassiveMask \n  // const PassiveMask = Passive | ChildDeletion;\n  if (\n    (finishedWork.subtreeFlags & PassiveMask) !== NoFlags ||\n    (finishedWork.flags & PassiveMask) !== NoFlags\n  ) {\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      // ......\n      scheduleCallback(NormalSchedulerPriority, () => {\n        flushPassiveEffects();\n        // This render triggered passive effects\n        return null;\n      });\n    }\n  }\n\n  // Check if there are any effects in the whole tree.\n  // \n  const subtreeHasEffects =\n    (finishedWork.subtreeFlags &\n      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==\n    NoFlags;\n  // \n  const rootHasEffect =\n    (finishedWork.flags &\n      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==\n    NoFlags;\n  // \n  if (subtreeHasEffects || rootHasEffect) {\n    // ......\n    const prevExecutionContext = executionContext;\n    // executionContext  CommitContext\n    executionContext |= CommitContext;\n    // ......\n    // The commit phase is broken into several sub-phases. We do a separate pass\n    // of the effect list for each phase: all mutation effects come before all\n    // layout effects, and so on.\n\n    // The first phase a \"before mutation\" phase. We use this phase to read the\n    // state of the host tree right before we mutate it. This is where\n    // getSnapshotBeforeUpdate is called.\n    // Commit   before mutation, mutation  layout\n    // before mutation  mutation \n    const shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(\n      root,\n      finishedWork,\n    );\n    // ......\n    // The next phase is the mutation phase, where we mutate the host tree.\n    // mutation  DOM \n    commitMutationEffects(root, finishedWork, lanes);\n    // ......\n    // The work-in-progress tree is now the current tree. This must come after\n    // the mutation phase, so that the previous tree is still current during\n    // componentWillUnmount, but before the layout phase, so that the finished\n    // work is current during componentDidMount/Update.\n    // workInProgress currentmutationlayout\n    // mutationcomponentWillUnmount\n    // layoutcomponentDidMount/Update\n    root.current = finishedWork;\n    // The next phase is the layout phase, where we call effects that read\n    // the host tree after it's been mutated. The idiomatic use case for this is\n    // layout, but class component lifecycles also fire here for legacy reasons.\n    // layout  mutation \n    commitLayoutEffects(finishedWork, root, lanes);\n    // ......\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\n    // opportunity to paint.\n    //  `Render` \n    requestPaint();\n    // Commit   executionContext \n    executionContext = prevExecutionContext;\n    // ......\n  } \n  \n  if (\n    includesSomeLane(pendingPassiveEffectsLanes, SyncLane) &&\n    root.tag !== LegacyRoot\n  ) {\n    flushPassiveEffects();\n  }\n  // ......\n  //  commitRoot  Root \n  ensureRootIsScheduled(root, now());\n  // ......\n  // If layout work was scheduled, flush it now.\n  flushSyncCallbacks();\n  // ......\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n\n\n Commit \n\n * flushPassiveEffects : flushPassiveEffects  useEffect  useEffect  hook  PassiveMask  flushPassiveEffects \n *  Commit  BeforeMutationMask  MutationMask  LayoutMask  PassiveMask  finishedWork  Commit \n * Commit  beforeMutation  mutation  layout  commitBeforeMutationEffects  commitMutationEffects  commitLayoutEffects \n * workInProgress FiberTree  current FiberTree  mutation layout  root.current = finishedWork  current FiberTree  workInProgress FiberTree \n *  mutation React  EffectTag  JavaScript  DOM  layout  yield requestPaint \n\n\n\n\n\n * before mutation getSnapshotBeforeUpdate DOM  useEffect\n * mutation HostComponent DOM  componentWillUnmount useLayoutEffect \n * layout DOM  componentDidMount  componentDidUpdate setState  useEffect  effect  useEffect\n\n FiberTree  Effect  React  EffectList  Effect  subtreeFlags  EffectList \n\n\n# EffectList \n\n commitMutationEffects  FiberTree  EffectList      beginWork  completeWork  FiberTree \n\n// src/react/packages/react-reconciler/src/ReactFiberCommitWork.new.js\nfunction commitMutationEffects( \n  root: FiberRoot,\n  firstChild: Fiber,\n  ) {\n  nextEffect = firstChild;\n  commitMutationEffects_begin(root);\n}\n\nfunction commitMutationEffects_begin(root: FiberRoot) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    // begin work......beginWork\n    const child = fiber.child;\n    // MutationMask  BeforeMutationMask  LayoutMask\n    //  Fiber  subtreeFlags EffectTag\n    // \n    if ((fiber.subtreeFlags & MutationMask) !== NoFlags && child !== null) {\n      // ......\n      // \n      nextEffect = child;\n    } else {\n      //  EffectTag\n      commitMutationEffects_complete(root);\n    }\n  }\n}\n\nfunction commitMutationEffects_complete(root: FiberRoot) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n\n    // complete work......completeWork\n    // \n    //  return\n    const sibling = fiber.sibling;\n    if (sibling !== null) {\n      // ......\n      nextEffect = sibling;\n      return;\n    }\n    nextEffect = fiber.return;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n     commitBeforeMutationEffects  commitMutationEffects  commitLayoutEffects  beginWork  completeWork \n\n\n# commitBeforeMutationEffects\n\n// completeWork\ncommitBeforeMutationEffectsOnFiber(fiber);\n\n\n1\n2\n\n\n\n\n *  fiber  commitBeforeMutationEffectsOnFiber \n\n\n# commitMutationEffects\n\n// beginWork\nconst deletions = fiber.deletions;\nif (deletions !== null) {\n  for (let i = 0; i < deletions.length; i++) {\n    const childToDelete = deletions[i];\n    commitDeletion(root, childToDelete, fiber);\n    // ......\n  }\n}\n// completeWork\ncommitMutationEffectsOnFiber(fiber, root);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n\n *  fiber  deletions \n *  commitMutationEffectsOnFiber \n *  commitMutationEffectsOnFiber  EffectTag  EffectTag  DOM \n\n\n# commitLayoutEffects\n\n// completeWork\nif ((fiber.flags & LayoutMask) !== NoFlags) {\n  const current = fiber.alternate;\n  // ......\n  commitLayoutEffectOnFiber(root, current, fiber, committedLanes);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n *  commitLayoutEffectOnFiber  fiber  LayoutMask \n\n commitBeforeMutationEffectsOnFiber  commitMutationEffectsOnFiber  EffectTag  commitLayoutEffectOnFiber  fiber  LayoutMask  MutationMask  BeforeMutationMask  LayoutMask  EffectTag \n\n// Groups of flags that are used in the commit phase to skip over trees that\n// don't contain effects, by checking subtreeFlags.\nexport const BeforeMutationMask = Update | Snapshot | ChildDeletion | Visibility;\nexport const MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;\nexport const LayoutMask = Update | Callback | Ref | Visibility;\n\n\n1\n2\n3\n4\n5\n\n\n subtreeFlags  EffectTag \n\n\n# \n\n\n# commitRootImpl  flushPassiveEffects \n\n flushPassiveEffects  useEffect    Passive \n\n DOM  React React  Commit \n\n  Render  Callback/Handler  Effect  Props/State  JSX React  /  Hook \n\n commitRootImpl  flushPassiveEffects \n\n// [1]\ndo {flushPassiveEffects()} while (rootWithPendingPassiveEffects !== null); \n\n// [2]\nscheduleCallback(NormalSchedulerPriority, () => flushPassiveEffects());\n\n// [3]\nif (includesSomeLane(pendingPassiveEffectsLanes, SyncLane)) flushPassiveEffects();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n *  flushPassiveEffects  Commit  passiveEffects useEffect   flushPassiveEffects  while \n *  flushPassiveEffects  Commit  flushPassiveEffects  Commit  Render  flushPassiveEffects  Commit   useEffect   effect \n *  flushPassiveEffects  root.finishedLanes  lanes   React 18  flushSync  useEffect   effect \n\n\n\n * flushPassiveEffects  Commit \n * useEffect  Commit  Batch  useEffect \n * useEffect  useLayoutEffect  Commit \n\n\n# \n\n\n#  layout  requestPaint ?\n\n\n\nBy default, the browser will wait until the current thread of execution finishes and do one consolidated reflow and repaint (as this is considered more efficient than doing many reflows and repaints). This is not specified in any specification so the browser can implement as it wants to.\n\nBut, there are some specific operations that will generally trigger a reflow (and sometimes a corresponding repaint). These operations are operations (requesting certain properties related to the position of elements) which can only be completed when an accurate reflow has been done. So, it is possible to manually trigger a reflow by requesting one of these properties.\n\nhtml - When does the DOM repaint during Javascript routines? - Stack Overflow\n\n reflow  repaint  reflow  reflow  JavaScript  DOM  repaint  reflow  repaint \n\n\n# \n\n commitRoot  commitRoot  Commit  Commit  beforeMutation  mutation  layout  commitBeforeMutationEffects  commitMutationEffects  commitLayoutEffects  commitBeforeMutationEffects  commitMutationEffects  JavaScript  DOM  commitLayoutEffects \n\n workInProgress  current  mutation  layout  yield  Render  mutation  DOM reflowrepaint\n\n EffectList    EffectTagMask   beginWork  completeWork  commitBeforeMutationEffectsOnFiber  commitMutationEffectsOnFiber  commitLayoutEffectOnFiber \n\n\n# \n\n * React  commit ",normalizedContent:"# \n\n\n\n * \n * \n * finishconcurrentrender\n * commitroot\n * effectlist \n * commitbeforemutationeffects\n * commitmutationeffects\n * commitlayouteffects\n * \n   * commitrootimpl  flushpassiveeffects \n * \n   *  layout  requestpaint?\n * \n * \n\n\n\n\n# \n\n react      batch  render  commit  fibertree  domtree \n\n commitroot  finishconcurrentrender  finishconcurrentrender \n\n\n# finishconcurrentrender\n\n finishconcurrentrender  commitroot  render  commit  render exitstatus commit  dom \n\nfunction finishconcurrentrender(root, exitstatus, lanes) {\n  switch (exitstatus) {\n    // ......\n    case rooterrored: {\n      commitroot(root);\n      break;\n    }\n    case rootsuspended:\n    case rootsuspendedwithdelay: {\n      markrootsuspended(root, lanes);\n      // ......\n      // the work expired. commit immediately.\n      commitroot(root);\n      break;\n    }\n    case rootcompleted: {\n      // the work completed. ready to commit.\n      commitroot(root);\n      break;\n    }\n    //  ......\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n\n *  rootincomplete ()  rootfatalerrored \n *  rootsuspended  rootsuspendedwithdelay \n\n\n# commitroot\n\ncommitroot  commitrootimpl \n\nfunction commitrootimpl(root, renderprioritylevel) {\n  do {\n    // `flushpassiveeffects` will call `flushsyncupdatequeue` at the end, which\n    // means `flushpassiveeffects` will sometimes result in additional\n    // passive effects. so we need to keep flushing in a loop until there are\n    // no more pending effects.\n    flushpassiveeffects();\n  } while (rootwithpendingpassiveeffects !== null);\n  // ......\n  //  batch \n  if ((executioncontext & (rendercontext | commitcontext)) !== nocontext) {\n    throw new error('should not already be working.');\n  }\n  const finishedwork = root.finishedwork;\n  //  commit \n  const lanes = root.finishedlanes;\n  // ......\n  // finishedwork lanes\n  let remaininglanes = mergelanes(finishedwork.lanes, finishedwork.childlanes);\n  //  root.pendinglanes \n  markrootfinished(root, remaininglanes);\n  // ......\n  // if there are pending passive effects, schedule a callback to process them.\n  // do this as early as possible, so it is queued before anything else that\n  // might get scheduled in the commit phase. \n  //  passivemask \n  // const passivemask = passive | childdeletion;\n  if (\n    (finishedwork.subtreeflags & passivemask) !== noflags ||\n    (finishedwork.flags & passivemask) !== noflags\n  ) {\n    if (!rootdoeshavepassiveeffects) {\n      rootdoeshavepassiveeffects = true;\n      // ......\n      schedulecallback(normalschedulerpriority, () => {\n        flushpassiveeffects();\n        // this render triggered passive effects\n        return null;\n      });\n    }\n  }\n\n  // check if there are any effects in the whole tree.\n  // \n  const subtreehaseffects =\n    (finishedwork.subtreeflags &\n      (beforemutationmask | mutationmask | layoutmask | passivemask)) !==\n    noflags;\n  // \n  const roothaseffect =\n    (finishedwork.flags &\n      (beforemutationmask | mutationmask | layoutmask | passivemask)) !==\n    noflags;\n  // \n  if (subtreehaseffects || roothaseffect) {\n    // ......\n    const prevexecutioncontext = executioncontext;\n    // executioncontext  commitcontext\n    executioncontext |= commitcontext;\n    // ......\n    // the commit phase is broken into several sub-phases. we do a separate pass\n    // of the effect list for each phase: all mutation effects come before all\n    // layout effects, and so on.\n\n    // the first phase a \"before mutation\" phase. we use this phase to read the\n    // state of the host tree right before we mutate it. this is where\n    // getsnapshotbeforeupdate is called.\n    // commit   before mutation, mutation  layout\n    // before mutation  mutation \n    const shouldfireafteractiveinstanceblur = commitbeforemutationeffects(\n      root,\n      finishedwork,\n    );\n    // ......\n    // the next phase is the mutation phase, where we mutate the host tree.\n    // mutation  dom \n    commitmutationeffects(root, finishedwork, lanes);\n    // ......\n    // the work-in-progress tree is now the current tree. this must come after\n    // the mutation phase, so that the previous tree is still current during\n    // componentwillunmount, but before the layout phase, so that the finished\n    // work is current during componentdidmount/update.\n    // workinprogress currentmutationlayout\n    // mutationcomponentwillunmount\n    // layoutcomponentdidmount/update\n    root.current = finishedwork;\n    // the next phase is the layout phase, where we call effects that read\n    // the host tree after it's been mutated. the idiomatic use case for this is\n    // layout, but class component lifecycles also fire here for legacy reasons.\n    // layout  mutation \n    commitlayouteffects(finishedwork, root, lanes);\n    // ......\n    // tell scheduler to yield at the end of the frame, so the browser has an\n    // opportunity to paint.\n    //  `render` \n    requestpaint();\n    // commit   executioncontext \n    executioncontext = prevexecutioncontext;\n    // ......\n  } \n  \n  if (\n    includessomelane(pendingpassiveeffectslanes, synclane) &&\n    root.tag !== legacyroot\n  ) {\n    flushpassiveeffects();\n  }\n  // ......\n  //  commitroot  root \n  ensurerootisscheduled(root, now());\n  // ......\n  // if layout work was scheduled, flush it now.\n  flushsynccallbacks();\n  // ......\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n\n\n commit \n\n * flushpassiveeffects : flushpassiveeffects  useeffect  useeffect  hook  passivemask  flushpassiveeffects \n *  commit  beforemutationmask  mutationmask  layoutmask  passivemask  finishedwork  commit \n * commit  beforemutation  mutation  layout  commitbeforemutationeffects  commitmutationeffects  commitlayouteffects \n * workinprogress fibertree  current fibertree  mutation layout  root.current = finishedwork  current fibertree  workinprogress fibertree \n *  mutation react  effecttag  javascript  dom  layout  yield requestpaint \n\n\n\n\n\n * before mutation getsnapshotbeforeupdate dom  useeffect\n * mutation hostcomponent dom  componentwillunmount uselayouteffect \n * layout dom  componentdidmount  componentdidupdate setstate  useeffect  effect  useeffect\n\n fibertree  effect  react  effectlist  effect  subtreeflags  effectlist \n\n\n# effectlist \n\n commitmutationeffects  fibertree  effectlist      beginwork  completework  fibertree \n\n// src/react/packages/react-reconciler/src/reactfibercommitwork.new.js\nfunction commitmutationeffects( \n  root: fiberroot,\n  firstchild: fiber,\n  ) {\n  nexteffect = firstchild;\n  commitmutationeffects_begin(root);\n}\n\nfunction commitmutationeffects_begin(root: fiberroot) {\n  while (nexteffect !== null) {\n    const fiber = nexteffect;\n    // begin work......beginwork\n    const child = fiber.child;\n    // mutationmask  beforemutationmask  layoutmask\n    //  fiber  subtreeflags effecttag\n    // \n    if ((fiber.subtreeflags & mutationmask) !== noflags && child !== null) {\n      // ......\n      // \n      nexteffect = child;\n    } else {\n      //  effecttag\n      commitmutationeffects_complete(root);\n    }\n  }\n}\n\nfunction commitmutationeffects_complete(root: fiberroot) {\n  while (nexteffect !== null) {\n    const fiber = nexteffect;\n\n    // complete work......completework\n    // \n    //  return\n    const sibling = fiber.sibling;\n    if (sibling !== null) {\n      // ......\n      nexteffect = sibling;\n      return;\n    }\n    nexteffect = fiber.return;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n     commitbeforemutationeffects  commitmutationeffects  commitlayouteffects  beginwork  completework \n\n\n# commitbeforemutationeffects\n\n// completework\ncommitbeforemutationeffectsonfiber(fiber);\n\n\n1\n2\n\n\n\n\n *  fiber  commitbeforemutationeffectsonfiber \n\n\n# commitmutationeffects\n\n// beginwork\nconst deletions = fiber.deletions;\nif (deletions !== null) {\n  for (let i = 0; i < deletions.length; i++) {\n    const childtodelete = deletions[i];\n    commitdeletion(root, childtodelete, fiber);\n    // ......\n  }\n}\n// completework\ncommitmutationeffectsonfiber(fiber, root);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n\n *  fiber  deletions \n *  commitmutationeffectsonfiber \n *  commitmutationeffectsonfiber  effecttag  effecttag  dom \n\n\n# commitlayouteffects\n\n// completework\nif ((fiber.flags & layoutmask) !== noflags) {\n  const current = fiber.alternate;\n  // ......\n  commitlayouteffectonfiber(root, current, fiber, committedlanes);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n *  commitlayouteffectonfiber  fiber  layoutmask \n\n commitbeforemutationeffectsonfiber  commitmutationeffectsonfiber  effecttag  commitlayouteffectonfiber  fiber  layoutmask  mutationmask  beforemutationmask  layoutmask  effecttag \n\n// groups of flags that are used in the commit phase to skip over trees that\n// don't contain effects, by checking subtreeflags.\nexport const beforemutationmask = update | snapshot | childdeletion | visibility;\nexport const mutationmask = placement | update | childdeletion | contentreset | ref | hydrating | visibility;\nexport const layoutmask = update | callback | ref | visibility;\n\n\n1\n2\n3\n4\n5\n\n\n subtreeflags  effecttag \n\n\n# \n\n\n# commitrootimpl  flushpassiveeffects \n\n flushpassiveeffects  useeffect    passive \n\n dom  react react  commit \n\n  render  callback/handler  effect  props/state  jsx react  /  hook \n\n commitrootimpl  flushpassiveeffects \n\n// [1]\ndo {flushpassiveeffects()} while (rootwithpendingpassiveeffects !== null); \n\n// [2]\nschedulecallback(normalschedulerpriority, () => flushpassiveeffects());\n\n// [3]\nif (includessomelane(pendingpassiveeffectslanes, synclane)) flushpassiveeffects();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n *  flushpassiveeffects  commit  passiveeffects useeffect   flushpassiveeffects  while \n *  flushpassiveeffects  commit  flushpassiveeffects  commit  render  flushpassiveeffects  commit   useeffect   effect \n *  flushpassiveeffects  root.finishedlanes  lanes   react 18  flushsync  useeffect   effect \n\n\n\n * flushpassiveeffects  commit \n * useeffect  commit  batch  useeffect \n * useeffect  uselayouteffect  commit \n\n\n# \n\n\n#  layout  requestpaint ?\n\n\n\nby default, the browser will wait until the current thread of execution finishes and do one consolidated reflow and repaint (as this is considered more efficient than doing many reflows and repaints). this is not specified in any specification so the browser can implement as it wants to.\n\nbut, there are some specific operations that will generally trigger a reflow (and sometimes a corresponding repaint). these operations are operations (requesting certain properties related to the position of elements) which can only be completed when an accurate reflow has been done. so, it is possible to manually trigger a reflow by requesting one of these properties.\n\nhtml - when does the dom repaint during javascript routines? - stack overflow\n\n reflow  repaint  reflow  reflow  javascript  dom  repaint  reflow  repaint \n\n\n# \n\n commitroot  commitroot  commit  commit  beforemutation  mutation  layout  commitbeforemutationeffects  commitmutationeffects  commitlayouteffects  commitbeforemutationeffects  commitmutationeffects  javascript  dom  commitlayouteffects \n\n workinprogress  current  mutation  layout  yield  render  mutation  dom reflowrepaint\n\n effectlist    effecttagmask   beginwork  completework  commitbeforemutationeffectsonfiber  commitmutationeffectsonfiber  commitlayouteffectonfiber \n\n\n# \n\n * react  commit ",charsets:{cjk:!0},lastUpdated:"2022/08/08, 19:51:35",lastUpdatedTimestamp:1659959495e3},{title:"React React ",frontmatter:{title:"React React ",date:"2022-08-05T12:02:21.000Z",permalink:"/react/tour/react-reconciliation-8/",categories:["react","React"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/160.react-reconciliation-8.html",relativePath:"10.react/90.React/160.react-reconciliation-8.md",key:"v-7f59f37f",path:"/react/tour/react-reconciliation-8/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:2,title:"commitBeforeMutationEffectsOnFiber",slug:"commitbeforemutationeffectsonfiber",normalizedTitle:"commitbeforemutationeffectsonfiber",charIndex:23},{level:2,title:"commitMutationEffectsOnFiber",slug:"commitmutationeffectsonfiber",normalizedTitle:"commitmutationeffectsonfiber",charIndex:61},{level:2,title:"commitLayoutEffectOnFiber",slug:"commitlayouteffectonfiber",normalizedTitle:"commitlayouteffectonfiber",charIndex:93},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:122},{level:3,title:"useLayoutEffect  layout ",slug:"uselayouteffect--layout-",normalizedTitle:"uselayouteffect  layout ",charIndex:130},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:165},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:171},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:177}],readingTime:{text:"6 min read",minutes:5.495,time:329700,words:1099},headersStr:"  commitBeforeMutationEffectsOnFiber commitMutationEffectsOnFiber commitLayoutEffectOnFiber  useLayoutEffect  layout    ",content:'# \n\n\n\n * \n * \n * commitBeforeMutationEffectsOnFiber\n * commitMutationEffectsOnFiber\n * commitLayoutEffectOnFiber\n * \n   * useLayoutEffect  layout \n * \n * \n * \n\n\n\n\n# \n\n Commit  beforeMutation  mutation  layout  workInProgress FiberTree  WorkInProgress FiberTree  current FiberTree  EffectList  DOM  \n\n\n\n * FiberTree  ReactElementTree  DOMTree  React  DOMTree  ReactElementTree setStateJSX Event Listener FiberTree  FiberRoot updateQueueEffectList\n *   React  Tree  DFSReact  FiberTree EffectList  DFS  Tree  DFS DFS visit DFS \n\n\n# commitBeforeMutationEffectsOnFiber\n\n mutation  getSnapshotBeforeUpdate \n\nfunction commitBeforeMutationEffectsOnFiber(finishedWork: Fiber) {\n  const current = finishedWork.alternate;\n  const flags = finishedWork.flags;\n  // ......\n  // Snapshot EffectTag  getSnapshotBeforeUpdate  `HostRoot` \n  if ((flags & Snapshot) !== NoFlags) {\n    // ......\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent: {\n        break;\n      }\n      case ClassComponent: {\n        // \n        if (current !== null) {\n          //  current Fiber  propstate \n          const prevProps = current.memoizedProps;\n          const prevState = current.memoizedState;\n          const instance = finishedWork.stateNode;\n          // ......\n          //  getSnapshotBeforeUpdatesee https://zh-hans.reactjs.org/docs/react-component.html#getsnapshotbeforeupdate\n          const snapshot = instance.getSnapshotBeforeUpdate(\n            //  elementType  type  lazyComponent\n            //  ReactElement  props see https://zh-hans.reactjs.org/docs/react-component.html#defaultprops\n            finishedWork.elementType === finishedWork.type\n              ? prevProps\n              : resolveDefaultProps(finishedWork.type, prevProps),\n            prevState,\n          );\n          // ......\n          //  snapshot  componentDidUpdate \n          instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n        }\n        break;\n      }\n      case HostRoot: {\n        //  HostRoot \n        const root = finishedWork.stateNode;\n        clearContainer(root.containerInfo);\n        break;\n      }\n      case HostComponent:\n      case HostText:\n      case HostPortal:\n      case IncompleteClassComponent:\n        break;\n      // ......\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n Snapshot  fiber  Snapshot  getSnapshotBeforeUpdate  HostRoot  DOM DOM  HostRoot  ReactDOM.render  root  RootFiber  HostRoot \n\n\n\n *  getSnapshotBeforeUpdate(prevProps, prevState)  snapshot  componentDidUpdate(prevProps, prevState, snapshot) \n *  HostRoot  root  DOM \n\n\n# commitMutationEffectsOnFiber\n\nplacementupdate mutation  mutation  JavaScript  DOM \n\nfunction commitMutationEffectsOnFiber(finishedWork: Fiber, root: FiberRoot) {\n  const flags = finishedWork.flags;\n  //  ContentReset \n  if (flags & ContentReset) {\n    commitResetTextContent(finishedWork);\n  }\n  //  Ref  current  Ref \n  if (flags & Ref) {\n    const current = finishedWork.alternate;\n    if (current !== null) {\n      commitDetachRef(current);\n    }\n    // ......\n  }\n  // ......\n\n  // The following switch statement is only concerned about placement,\n  // updates, and deletions. To avoid needing to add a case for every possible\n  // bitmap value, we remove the secondary effects from the effect tag and\n  // switch on that value.\n  //  placementupdates  deletions \n  const primaryFlags = flags & (Placement | Update | Hydrating);\n  outer: switch (primaryFlags) {\n    //  Placement Placement  mutation \n    case Placement: {\n      commitPlacement(finishedWork);\n      // Clear the "placement" from effect tag so that we know that this is\n      // inserted, before any life-cycles like componentDidMount gets called.\n      // \n      finishedWork.flags &= ~Placement;\n      break;\n    }\n    //  PlacementAndUpdate Placement  update  mutation \n    case PlacementAndUpdate: {\n      // Placement\n      commitPlacement(finishedWork);\n      finishedWork.flags &= ~Placement;\n      //  update \n      const current = finishedWork.alternate;\n      commitWork(current, finishedWork);\n      break;\n    }\n    case Hydrating: {\n      // SSR  DOM \n      finishedWork.flags &= ~Hydrating;\n      break;\n    }\n    case HydratingAndUpdate: {\n      finishedWork.flags &= ~Hydrating;\n      const current = finishedWork.alternate;\n      commitWork(current, finishedWork);\n      break;\n    }\n    case Update: {\n      const current = finishedWork.alternate;\n      commitWork(current, finishedWork);\n      break;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n primaryFlags mutation \n\n *  ContentReset  Ref  ContentReset  Ref  current  Ref  Ref  layout  Ref Ref  hook \n * commitMutationEffectsOnFiber  placementupdate  hydrating primaryFlags  PlacementAndUpdate  PlacementAndUpdate \n\nconst PlacementAndUpdate = Placement | Update;\nconst HydratingAndUpdate = Hydrating | Update;\n\n\n1\n2\n\n *  Placement  commitPlacement  mutation \n *  Update  commitWork  mutation \n\n\n# commitLayoutEffectOnFiber\n\n\n\n// src/react/packages/react-reconciler/src/ReactFiberCommitWork.new.js\nconst LayoutMask = Update | Callback | Ref | Visibility;\n\nfunction commitLayoutEffectOnFiber(\n  finishedRoot: FiberRoot, \n  current: Fiber | null,\n  finishedWork: Fiber,\n  committedLanes: Lanes,\n): void {\n  if ((finishedWork.flags & LayoutMask) !== NoFlags) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent: {\n        // ......\n        //  useLayoutEffect \n        commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);\n        break;\n      }\n      case ClassComponent: {\n        const instance = finishedWork.stateNode;\n        // \n        if (finishedWork.flags & Update) {\n          //  `Update`  componentDidMount \n          //  componentDidUpdate \n          if (current === null) {\n            // ......\n            instance.componentDidMount();\n          } else {\n            //  workProgress  current  current  props  state\n            const prevProps =\n              finishedWork.elementType === finishedWork.type\n                ? current.memoizedProps\n                : resolveDefaultProps(\n                    finishedWork.type,\n                    current.memoizedProps,\n                  );\n            const prevState = current.memoizedState;\n            // ......\n            //  current fiber  workInProgress fiber  props  state \n            // see https://zh-hans.reactjs.org/docs/react-component.html#componentdidupdate\n            instance.componentDidUpdate(\n              prevProps,\n              prevState,\n              instance.__reactInternalSnapshotBeforeUpdate, // getSnapshotBeforeUpdate  snapshot\n            );\n          }\n        }\n        const updateQueue: UpdateQueue<*,> | null = (finishedWork.updateQueue: any);\n        if (updateQueue !== null) {\n          // ......\n          //  updateQueue \n          commitUpdateQueue(finishedWork, updateQueue, instance);\n        }\n        break;\n      }\n      case HostRoot: {\n        //  HostRoot  updateQueue updateQueue  object, callback effect\n        //  commitUpdateQueue  effect effect  context  HostRoot \n        const updateQueue: UpdateQueue<*,> | null = (finishedWork.updateQueue: any);\n        if (updateQueue !== null) {\n          let instance = null;\n          if (finishedWork.child !== null) {\n            switch (finishedWork.child.tag) {\n              case HostComponent:\n                // getPublicInstance  HOST \n                instance = getPublicInstance(finishedWork.child.stateNode);\n                break;\n              case ClassComponent:\n                instance = finishedWork.child.stateNode;\n                break;\n            }\n          }\n          commitUpdateQueue(finishedWork, updateQueue, instance);\n        }\n        break;\n      }\n      case HostComponent:\n      case HostText: \n      case HostPortal:\n      case Profiler: \n      case SuspenseComponent: \n      case SuspenseListComponent:\n      case IncompleteClassComponent:\n      case ScopeComponent:\n      case OffscreenComponent:\n      case LegacyHiddenComponent:\n        break;\n      // ......\n    }\n  }\n\n  // ......\n  //  fiber  Ref  Ref \n  if (finishedWork.flags & Ref) {\n    commitAttachRef(finishedWork);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\n\n\n mutation  DOM  requestPaint  layout  DOM \n\n *  FunctionComponent  ForwardRef  render render  Refs  SimpleMemoComponent  props   commitHookEffectListMount  useLayoutEffect \n *  ClassComponent  componentDidMount  componentDidUpdate  commitUpdateQueue  setState  setState(updater[, callback])  callback setState  updater  layout  callback  state state \n *  HostRoot RootFiber  commitUpdateQueue  render(element, container[, callback])  callback  Callback  setState  HostRoot  render  hydrate \n\n\n# \n\n\n# useLayoutEffect  layout \n\n layout  layout  layout   commitLayoutEffectOnFiber  layout  useLayoutEffect  componentDidMount  componentDidUpdate  Callback   layout  mutation  DOM \n\n layout  DOM    DOM  useLayoutEffect  DOM  useLayoutEffect \n\n\n# \n\n\n# \n\n EffectList   \n\n * commitBeforeMutationEffectsOnFiber :  beforeMutation  Snapshot  Snapshot   mutation  DOM  mutation  DOM  Snapshot  getSnapshotBeforeUpdate \n * commitMutationEffectsOnFiber :  mutation  Update  Placement  Update  Placement      DOM  mutation  DOM  mutation \n * commitLayoutEffectOnFiber :  layout  LayoutMask  mutation  DOM \n   1. useLayoutEffect  useLayoutEffect  DOM  useEffect  useLayoutEffect  componentDidMount  componentDidUpdate React  useEffect  useLayoutEffect  DOM  useEffect  useEffect  useEffect  SSR  Hook API useLayoutEffect\n   2.  componentDidMount  componentDidUpdate React  useEffect  useLayoutEffect \n   3.  Callback  Callback  Callback  setState  ReactDOM  render  hydrate \n\n EffectTag  DOM \n\n\n# \n\n * React ',normalizedContent:'# \n\n\n\n * \n * \n * commitbeforemutationeffectsonfiber\n * commitmutationeffectsonfiber\n * commitlayouteffectonfiber\n * \n   * uselayouteffect  layout \n * \n * \n * \n\n\n\n\n# \n\n commit  beforemutation  mutation  layout  workinprogress fibertree  workinprogress fibertree  current fibertree  effectlist  dom  \n\n\n\n * fibertree  reactelementtree  domtree  react  domtree  reactelementtree setstatejsx event listener fibertree  fiberroot updatequeueeffectlist\n *   react  tree  dfsreact  fibertree effectlist  dfs  tree  dfs dfs visit dfs \n\n\n# commitbeforemutationeffectsonfiber\n\n mutation  getsnapshotbeforeupdate \n\nfunction commitbeforemutationeffectsonfiber(finishedwork: fiber) {\n  const current = finishedwork.alternate;\n  const flags = finishedwork.flags;\n  // ......\n  // snapshot effecttag  getsnapshotbeforeupdate  `hostroot` \n  if ((flags & snapshot) !== noflags) {\n    // ......\n    switch (finishedwork.tag) {\n      case functioncomponent:\n      case forwardref:\n      case simplememocomponent: {\n        break;\n      }\n      case classcomponent: {\n        // \n        if (current !== null) {\n          //  current fiber  propstate \n          const prevprops = current.memoizedprops;\n          const prevstate = current.memoizedstate;\n          const instance = finishedwork.statenode;\n          // ......\n          //  getsnapshotbeforeupdatesee https://zh-hans.reactjs.org/docs/react-component.html#getsnapshotbeforeupdate\n          const snapshot = instance.getsnapshotbeforeupdate(\n            //  elementtype  type  lazycomponent\n            //  reactelement  props see https://zh-hans.reactjs.org/docs/react-component.html#defaultprops\n            finishedwork.elementtype === finishedwork.type\n              ? prevprops\n              : resolvedefaultprops(finishedwork.type, prevprops),\n            prevstate,\n          );\n          // ......\n          //  snapshot  componentdidupdate \n          instance.__reactinternalsnapshotbeforeupdate = snapshot;\n        }\n        break;\n      }\n      case hostroot: {\n        //  hostroot \n        const root = finishedwork.statenode;\n        clearcontainer(root.containerinfo);\n        break;\n      }\n      case hostcomponent:\n      case hosttext:\n      case hostportal:\n      case incompleteclasscomponent:\n        break;\n      // ......\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n snapshot  fiber  snapshot  getsnapshotbeforeupdate  hostroot  dom dom  hostroot  reactdom.render  root  rootfiber  hostroot \n\n\n\n *  getsnapshotbeforeupdate(prevprops, prevstate)  snapshot  componentdidupdate(prevprops, prevstate, snapshot) \n *  hostroot  root  dom \n\n\n# commitmutationeffectsonfiber\n\nplacementupdate mutation  mutation  javascript  dom \n\nfunction commitmutationeffectsonfiber(finishedwork: fiber, root: fiberroot) {\n  const flags = finishedwork.flags;\n  //  contentreset \n  if (flags & contentreset) {\n    commitresettextcontent(finishedwork);\n  }\n  //  ref  current  ref \n  if (flags & ref) {\n    const current = finishedwork.alternate;\n    if (current !== null) {\n      commitdetachref(current);\n    }\n    // ......\n  }\n  // ......\n\n  // the following switch statement is only concerned about placement,\n  // updates, and deletions. to avoid needing to add a case for every possible\n  // bitmap value, we remove the secondary effects from the effect tag and\n  // switch on that value.\n  //  placementupdates  deletions \n  const primaryflags = flags & (placement | update | hydrating);\n  outer: switch (primaryflags) {\n    //  placement placement  mutation \n    case placement: {\n      commitplacement(finishedwork);\n      // clear the "placement" from effect tag so that we know that this is\n      // inserted, before any life-cycles like componentdidmount gets called.\n      // \n      finishedwork.flags &= ~placement;\n      break;\n    }\n    //  placementandupdate placement  update  mutation \n    case placementandupdate: {\n      // placement\n      commitplacement(finishedwork);\n      finishedwork.flags &= ~placement;\n      //  update \n      const current = finishedwork.alternate;\n      commitwork(current, finishedwork);\n      break;\n    }\n    case hydrating: {\n      // ssr  dom \n      finishedwork.flags &= ~hydrating;\n      break;\n    }\n    case hydratingandupdate: {\n      finishedwork.flags &= ~hydrating;\n      const current = finishedwork.alternate;\n      commitwork(current, finishedwork);\n      break;\n    }\n    case update: {\n      const current = finishedwork.alternate;\n      commitwork(current, finishedwork);\n      break;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n primaryflags mutation \n\n *  contentreset  ref  contentreset  ref  current  ref  ref  layout  ref ref  hook \n * commitmutationeffectsonfiber  placementupdate  hydrating primaryflags  placementandupdate  placementandupdate \n\nconst placementandupdate = placement | update;\nconst hydratingandupdate = hydrating | update;\n\n\n1\n2\n\n *  placement  commitplacement  mutation \n *  update  commitwork  mutation \n\n\n# commitlayouteffectonfiber\n\n\n\n// src/react/packages/react-reconciler/src/reactfibercommitwork.new.js\nconst layoutmask = update | callback | ref | visibility;\n\nfunction commitlayouteffectonfiber(\n  finishedroot: fiberroot, \n  current: fiber | null,\n  finishedwork: fiber,\n  committedlanes: lanes,\n): void {\n  if ((finishedwork.flags & layoutmask) !== noflags) {\n    switch (finishedwork.tag) {\n      case functioncomponent:\n      case forwardref:\n      case simplememocomponent: {\n        // ......\n        //  uselayouteffect \n        commithookeffectlistmount(hooklayout | hookhaseffect, finishedwork);\n        break;\n      }\n      case classcomponent: {\n        const instance = finishedwork.statenode;\n        // \n        if (finishedwork.flags & update) {\n          //  `update`  componentdidmount \n          //  componentdidupdate \n          if (current === null) {\n            // ......\n            instance.componentdidmount();\n          } else {\n            //  workprogress  current  current  props  state\n            const prevprops =\n              finishedwork.elementtype === finishedwork.type\n                ? current.memoizedprops\n                : resolvedefaultprops(\n                    finishedwork.type,\n                    current.memoizedprops,\n                  );\n            const prevstate = current.memoizedstate;\n            // ......\n            //  current fiber  workinprogress fiber  props  state \n            // see https://zh-hans.reactjs.org/docs/react-component.html#componentdidupdate\n            instance.componentdidupdate(\n              prevprops,\n              prevstate,\n              instance.__reactinternalsnapshotbeforeupdate, // getsnapshotbeforeupdate  snapshot\n            );\n          }\n        }\n        const updatequeue: updatequeue<*,> | null = (finishedwork.updatequeue: any);\n        if (updatequeue !== null) {\n          // ......\n          //  updatequeue \n          commitupdatequeue(finishedwork, updatequeue, instance);\n        }\n        break;\n      }\n      case hostroot: {\n        //  hostroot  updatequeue updatequeue  object, callback effect\n        //  commitupdatequeue  effect effect  context  hostroot \n        const updatequeue: updatequeue<*,> | null = (finishedwork.updatequeue: any);\n        if (updatequeue !== null) {\n          let instance = null;\n          if (finishedwork.child !== null) {\n            switch (finishedwork.child.tag) {\n              case hostcomponent:\n                // getpublicinstance  host \n                instance = getpublicinstance(finishedwork.child.statenode);\n                break;\n              case classcomponent:\n                instance = finishedwork.child.statenode;\n                break;\n            }\n          }\n          commitupdatequeue(finishedwork, updatequeue, instance);\n        }\n        break;\n      }\n      case hostcomponent:\n      case hosttext: \n      case hostportal:\n      case profiler: \n      case suspensecomponent: \n      case suspenselistcomponent:\n      case incompleteclasscomponent:\n      case scopecomponent:\n      case offscreencomponent:\n      case legacyhiddencomponent:\n        break;\n      // ......\n    }\n  }\n\n  // ......\n  //  fiber  ref  ref \n  if (finishedwork.flags & ref) {\n    commitattachref(finishedwork);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\n\n\n mutation  dom  requestpaint  layout  dom \n\n *  functioncomponent  forwardref  render render  refs  simplememocomponent  props   commithookeffectlistmount  uselayouteffect \n *  classcomponent  componentdidmount  componentdidupdate  commitupdatequeue  setstate  setstate(updater[, callback])  callback setstate  updater  layout  callback  state state \n *  hostroot rootfiber  commitupdatequeue  render(element, container[, callback])  callback  callback  setstate  hostroot  render  hydrate \n\n\n# \n\n\n# uselayouteffect  layout \n\n layout  layout  layout   commitlayouteffectonfiber  layout  uselayouteffect  componentdidmount  componentdidupdate  callback   layout  mutation  dom \n\n layout  dom    dom  uselayouteffect  dom  uselayouteffect \n\n\n# \n\n\n# \n\n effectlist   \n\n * commitbeforemutationeffectsonfiber :  beforemutation  snapshot  snapshot   mutation  dom  mutation  dom  snapshot  getsnapshotbeforeupdate \n * commitmutationeffectsonfiber :  mutation  update  placement  update  placement      dom  mutation  dom  mutation \n * commitlayouteffectonfiber :  layout  layoutmask  mutation  dom \n   1. uselayouteffect  uselayouteffect  dom  useeffect  uselayouteffect  componentdidmount  componentdidupdate react  useeffect  uselayouteffect  dom  useeffect  useeffect  useeffect  ssr  hook api uselayouteffect\n   2.  componentdidmount  componentdidupdate react  useeffect  uselayouteffect \n   3.  callback  callback  callback  setstate  reactdom  render  hydrate \n\n effecttag  dom \n\n\n# \n\n * react ',charsets:{cjk:!0},lastUpdated:"2022/08/08, 19:51:35",lastUpdatedTimestamp:1659959495e3},{title:"React React ",frontmatter:{title:"React React ",date:"2022-08-08T12:02:21.000Z",permalink:"/react/tour/react-reconciliation-9/",categories:["react","React"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/170.react-reconciliation-9.html",relativePath:"10.react/90.React/170.react-reconciliation-9.md",key:"v-8bb61782",path:"/react/tour/react-reconciliation-9/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:2,title:"commitDeletion",slug:"commitdeletion",normalizedTitle:"commitdeletion",charIndex:23},{level:3,title:"unmountHostComponents",slug:"unmounthostcomponents",normalizedTitle:"unmounthostcomponents",charIndex:43},{level:3,title:"commitUnmount",slug:"commitunmount",normalizedTitle:"commitunmount",charIndex:70},{level:3,title:"detachFiberMutation",slug:"detachfibermutation",normalizedTitle:"detachfibermutation",charIndex:89},{level:2,title:"commitPlacement",slug:"commitplacement",normalizedTitle:"commitplacement",charIndex:112},{level:3,title:"insertOrAppendPlacementNode",slug:"insertorappendplacementnode",normalizedTitle:"insertorappendplacementnode",charIndex:133},{level:2,title:"commitWork",slug:"commitwork",normalizedTitle:"commitwork",charIndex:164},{level:2,title:"commitHookEffectListMount",slug:"commithookeffectlistmount",normalizedTitle:"commithookeffectlistmount",charIndex:178},{level:2,title:"commitDetachRef",slug:"commitdetachref",normalizedTitle:"commitdetachref",charIndex:207},{level:2,title:"commitAttachRef",slug:"commitattachref",normalizedTitle:"commitattachref",charIndex:226},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:245},{level:3,title:" DOM ",slug:"--dom-",normalizedTitle:"  dom ",charIndex:15939},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:275},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:289},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:295}],readingTime:{text:"9 min read",minutes:8.68,time:520799.99999999994,words:1736},headersStr:"  commitDeletion unmountHostComponents commitUnmount detachFiberMutation commitPlacement insertOrAppendPlacementNode commitWork commitHookEffectListMount commitDetachRef commitAttachRef   DOM    ",content:"# \n\n\n\n * \n * \n * commitDeletion\n   * unmountHostComponents\n   * commitUnmount\n   * detachFiberMutation\n * commitPlacement\n   * insertOrAppendPlacementNode\n * commitWork\n * commitHookEffectListMount\n * commitDetachRef\n * commitAttachRef\n * \n   *  DOM \n * \n * \n * \n\n\n\n\n# \n\n Commit  commitBeforeMutationEffects  commitMutationEffects  commitLayoutEffects  layout React  Commit \n\n Commit  DOM  mutation  mutation  DOM  mutation  mutation  HostConfig  DOM \n\n\n# commitDeletion\n\n Refs  return \n\n\n\n// src/react/packages/react-reconciler/src/ReactFiberCommitWork.new.js\nfunction commitDeletion(\n  finishedRoot: FiberRoot,\n  // \n  current: Fiber,\n  // \n  nearestMountedAncestor: Fiber,\n): void {\n  // ......\n  // Recursively delete all host nodes from the parent.\n  // Detach refs and call componentWillUnmount() on the whole subtree.\n  //  Refs \n  unmountHostComponents(finishedRoot, current, nearestMountedAncestor);\n  //  return  childsiblingalternate \n  //  GC\n  detachFiberMutation(current);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# unmountHostComponents\n\n Host HostComponent  HostText fiberTree \n\nfunction unmountHostComponents(\n  finishedRoot: FiberRoot,\n  current: Fiber,\n  nearestMountedAncestor: Fiber,\n): void {\n  let node: Fiber = current;\n  let currentParent;\n  //  FiberRoot RootFiber\n  let currentParentIsContainer;\n  // ......\n\n  while (true) {\n    // ......\n    //  HostComponent  HostText \n    if (node.tag === HostComponent || node.tag === HostText) {\n      // \n      commitNestedUnmounts(finishedRoot, node, nearestMountedAncestor);\n      //  DOM Tree \n      if (currentParentIsContainer) {\n        removeChildFromContainer(\n          ((currentParent: any): Container),\n          (node.stateNode: Instance | TextInstance),\n        );\n      } else {\n        removeChild(\n          ((currentParent: any): Instance),\n          (node.stateNode: Instance | TextInstance),\n        );\n      }\n    } /*......*/else {\n      // \n      commitUnmount(finishedRoot, node, nearestMountedAncestor);\n      // \n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    }\n    // \n    if (node === current) {\n      return;\n    }\n    // \n    while (node.sibling === null) {\n      // \n      if (node.return === null || node.return === current) {\n        return;\n      }\n      node = node.return;\n      // ......\n    }\n    // \n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n   DOM  HOST  HostComponent  HostText \n\n * commitNestedUnmounts :    commitUnmount  HOST \n * removeChildFromContainer  removeChild  HostConfig  JavaScript  HOST  DOM  DOM \n * commitUnmount \n\n\n# commitUnmount\n\n componentWillUnmount \n\nfunction commitUnmount(\n  finishedRoot: FiberRoot,\n  current: Fiber,\n  nearestMountedAncestor: Fiber,\n): void {\n  // ......\n  switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent: {\n      const updateQueue: FunctionComponentUpdateQueue | null = (current.updateQueue: any);\n      if (updateQueue !== null) {\n        const lastEffect = updateQueue.lastEffect;\n        //  updateQueue  effect \n        if (lastEffect !== null) {\n          const firstEffect = lastEffect.next;\n          let effect = firstEffect;\n          do {\n            // \n            const {destroy, tag} = effect;\n            if (destroy !== undefined) {\n              // HookInsertion  HookLayout  useInsertionEffect  useLayoutEffect \n              if ((tag & HookInsertion) !== NoHookEffect) {\n                safelyCallDestroy(current, nearestMountedAncestor, destroy);\n              } else if ((tag & HookLayout) !== NoHookEffect) {\n                // ......\n                safelyCallDestroy(current, nearestMountedAncestor, destroy);\n              }\n            }\n            effect = effect.next;\n          } while (effect !== firstEffect);\n        }\n      }\n      return;\n    }\n    case ClassComponent: {\n      //  Refs \n      safelyDetachRef(current, nearestMountedAncestor);\n      const instance = current.stateNode;\n      //  componentWillUnmount \n      if (typeof instance.componentWillUnmount === 'function') {\n        safelyCallComponentWillUnmount(\n          current,\n          nearestMountedAncestor,\n          instance,\n        );\n      }\n      return;\n    }\n    case HostComponent: \n    case HostPortal:\n    case DehydratedFragment: \n    case ScopeComponent: {\n      // ......\n      return;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n\n *  updateQueue  effect  effect  useInsertionEffect  HookInsertion  useLayoutEffect  HookLayout  effect  Hook \n *  componentWillUnmount  tryCatch   commitUnmount  safely  DOM \n\n\n# detachFiberMutation\n\n alternate  return  return \n\nfunction detachFiberMutation(fiber: Fiber) {\n  // Cut off the return pointer to disconnect it from the tree.\n  // This enables us to detect and warn against state updates on an unmounted component.\n  // It also prevents events from bubbling from within disconnected components.\n  //\n  // Ideally, we should also clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child.\n  // This child itself will be GC:ed when the parent updates the next time.\n  //\n  // Note that we can't clear child or sibling pointers yet.\n  // They're needed for passive effects and for findDOMNode.\n  // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n  //\n  // Don't reset the alternate yet, either. We need that so we can detach the\n  // alternate's fields in the passive phase. Clearing the return pointer is\n  // sufficient for findDOMNode semantics.\n  //  workInProgress fiber  current fiber  return  child \n  //  GC  FiberTree  return \n  const alternate = fiber.alternate;\n  if (alternate !== null) {\n    alternate.return = null;\n  }\n  fiber.return = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# commitPlacement\n\n\n\nfunction commitPlacement(finishedWork: Fiber): void {\n  // ......\n  //  HOST  HostComponentHostRootHostPortal\n  const parentFiber = getHostParentFiber(finishedWork);\n\n  let parent;\n  //  HostRoot  HostPortal\n  let isContainer;\n  // stateNode  fiber  DOM \n  const parentStateNode = parentFiber.stateNode;\n  switch (parentFiber.tag) {\n    case HostComponent:\n      parent = parentStateNode;\n      isContainer = false;\n      break;\n    case HostRoot:\n      parent = parentStateNode.containerInfo;\n      isContainer = true;\n      break;\n    case HostPortal:\n      parent = parentStateNode.containerInfo;\n      isContainer = true;\n      break;\n    // ......\n  }\n  // ......\n  //  HOST \n  // \n  const before = getHostSibling(finishedWork);\n  // We only have the top Fiber that was inserted but we need to recurse down its\n  // children to find all the terminal nodes.\n  if (isContainer) {\n    insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);\n  } else {\n    insertOrAppendPlacementNode(finishedWork, before, parent);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n\n * getHostParentFiber  HOST   HOST HOST  HostComponent  HostRoot  HostPortal  Fiber.stateNode  HOST  Fiber  DOM \n * getHostSibling  HOST  Placement  HOST  null HOST  DOM \n * insertOrAppendPlacementNode \n\n\n# insertOrAppendPlacementNode\n\n\n\nfunction insertOrAppendPlacementNode(\n  node: Fiber,\n  before: ?Instance,\n  parent: Instance,\n): void {\n  const {tag} = node;\n  const isHost = tag === HostComponent || tag === HostText;\n  //  HOST  before  before \n  // \n  if (isHost) {\n    const stateNode = node.stateNode;\n    if (before) {\n      insertBefore(parent, stateNode, before);\n    } else {\n      appendChild(parent, stateNode);\n    }\n  } /*......*/ else {\n    const child = node.child;\n    //  HOST \n    if (child !== null) {\n      insertOrAppendPlacementNode(child, before, parent);\n      let sibling = child.sibling;\n      while (sibling !== null) {\n        insertOrAppendPlacementNode(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n HOST \n\n *  HOST \n *  HOST \n\n\n# commitWork\n\n HostComponent  HostText  HOST \n\n// src/react/packages/react-reconciler/src/ReactFiberCommitWork.new.js\nfunction commitWork(current: Fiber | null, finishedWork: Fiber): void {\n  // ......\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent: {\n      //  fc-like  useInsertionEffect \n      commitHookEffectListUnmount(\n        HookInsertion | HookHasEffect,\n        finishedWork,\n        finishedWork.return,\n      );\n      //  useInsertionEffect see https://zh-hans.reactjs.org/docs/hooks-reference.html#useinsertioneffect\n      commitHookEffectListMount(HookInsertion | HookHasEffect, finishedWork);\n      // Layout effects are destroyed during the mutation phase so that all\n      // destroy functions for all fibers are called before any create functions.\n      // This prevents sibling component effects from interfering with each other,\n      // e.g. a destroy function in one component should never override a ref set\n      // by a create function in another component during the same commit.\n      // ......\n      //  useLayoutEffect \n      commitHookEffectListUnmount(\n        HookLayout | HookHasEffect,\n        finishedWork,\n        finishedWork.return,\n      );\n      return;\n    }\n    case HostComponent: {\n      const instance: Instance = finishedWork.stateNode;\n      if (instance != null) {\n        // Commit the work prepared earlier.\n        const newProps = finishedWork.memoizedProps;\n        // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n        const oldProps = current !== null ? current.memoizedProps : newProps;\n        const type = finishedWork.type;\n        const updatePayload: null | UpdatePayload = (finishedWork.updateQueue: any);\n        finishedWork.updateQueue = null;\n        if (updatePayload !== null) {\n          // \n          commitUpdate(\n            instance,\n            updatePayload,\n            type,\n            oldProps,\n            newProps,\n            finishedWork,\n          );\n        }\n      }\n      return;\n    }\n    case HostText: {\n      // ......\n      const textInstance: TextInstance = finishedWork.stateNode;\n      const newText: string = finishedWork.memoizedProps;\n      // For hydration we reuse the update path but we treat the oldProps\n      // as the newProps. The updatePayload will contain the real change in\n      // this case.\n      const oldText: string =\n        current !== null ? current.memoizedProps : newText;\n      // \n      commitTextUpdate(textInstance, oldText, newText);\n      return;\n    }\n    case ClassComponent: \n    case HostRoot: \n    case Profiler: \n    case SuspenseComponent: \n    case SuspenseListComponent: \n    case IncompleteClassComponent: {\n      // ......\n      return;\n    }\n    case ScopeComponent: {\n      // ......\n      break;\n    }\n  }\n  // ......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n *  useInsertionEffect  useInsertionEffect  useLayoutEffect  mutation  layout \n * useInsertionEffect  DOM  css-in-js  useLayoutEffect  DOM DOM  CSS  Hook API   useInsertionEffect\n *  HostComponent  commitUpdate  HostText  commitTextUpdate  HostConfig  HOST  DOM \n\n\n# commitHookEffectListMount\n\n useEffect  useLayoutEffect  useInsertionEffect  Hook  Hook \n\n\n# commitDetachRef\n\n Ref \n\nfunction commitDetachRef(current: Fiber) {\n  const currentRef = current.ref;\n  if (currentRef !== null) {\n    //  ref  function ref null\n    if (typeof currentRef === 'function') {\n      currentRef(null);\n      // ......\n    } else {\n      //  ref null \n      currentRef.current = null;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# commitAttachRef\n\n Ref \n\nfunction commitAttachRef(finishedWork: Fiber) {\n  const ref = finishedWork.ref;\n  //  commitMutationEffectsOnFiber  detach  current fiber  Ref\n  //  workInProgress fiber  Ref Ref \n  if (ref !== null) {\n    //  DOM `Fiber.stateNode`  HOST  DOM \n    // \n    const instance = finishedWork.stateNode;\n    let instanceToUse;\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n      default:\n        instanceToUse = instance;\n    }\n    // ......\n    // function ref  ref\n    if (typeof ref === 'function') {\n      ref(instanceToUse);\n    } else {\n      // ......\n      ref.current = instanceToUse;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n *  HOST Ref  HOST  HostComponent Ref  DOM  HostText  HostRoot  HostPortal  Ref Ref \n * Ref  Ref  Ref Refs and the DOM   Refs\n\n\n# \n\n\n#   DOM \n\n insertOrAppendPlacementNode  React  HOST  insertBefore  appendChild      placeChild \n\nif (current !== null) {\n  const oldIndex = current.index;\n  if (oldIndex < lastPlacedIndex) {\n    newFiber.flags |= Placement;\n    return lastPlacedIndex;\n  } else {\n    return oldIndex;\n  }\n} else {\n  newFiber.flags |= Placement;\n  return lastPlacedIndex\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n Placement \n\n *   \n *   \n\n\n\n\n\n *  EffectTag List FiberTree  Render \n *  EffectTag List  DOM Commit  mutation \n\n    \n\n\n# \n\n\n# \n\n commitDeletion  commitPlacement  commitWork  mutation  DOM    FiberTree  DOMTree FiberTree  DOMTree  FiberTree FiberTree  DOMTree  Fiber.stateNode  Fiber.tag \n\nFiber.tag  HOST  HostComponent  HostText  Fiber  DOM  EffectTag  HOST  Fiber.stateNode  HOST  DOM  DOM \n\nReact  DOM mutation\n\n * Deletion  removeChild \n * Placement  insertBefore  appendChild \n * Update  commitUpdate \n\nRef  DOM  HostConfig  removeChild  commitUpdate  HostConfig  HOST \n\n\n# \n\n * Know about the useInsertionEffect hook in React 18 | Saeloun Blog\n * Library Upgrade Guide: style most CSS-in-JS libs  Discussion #110  reactwg/react-18",normalizedContent:"# \n\n\n\n * \n * \n * commitdeletion\n   * unmounthostcomponents\n   * commitunmount\n   * detachfibermutation\n * commitplacement\n   * insertorappendplacementnode\n * commitwork\n * commithookeffectlistmount\n * commitdetachref\n * commitattachref\n * \n   *  dom \n * \n * \n * \n\n\n\n\n# \n\n commit  commitbeforemutationeffects  commitmutationeffects  commitlayouteffects  layout react  commit \n\n commit  dom  mutation  mutation  dom  mutation  mutation  hostconfig  dom \n\n\n# commitdeletion\n\n refs  return \n\n\n\n// src/react/packages/react-reconciler/src/reactfibercommitwork.new.js\nfunction commitdeletion(\n  finishedroot: fiberroot,\n  // \n  current: fiber,\n  // \n  nearestmountedancestor: fiber,\n): void {\n  // ......\n  // recursively delete all host nodes from the parent.\n  // detach refs and call componentwillunmount() on the whole subtree.\n  //  refs \n  unmounthostcomponents(finishedroot, current, nearestmountedancestor);\n  //  return  childsiblingalternate \n  //  gc\n  detachfibermutation(current);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# unmounthostcomponents\n\n host hostcomponent  hosttext fibertree \n\nfunction unmounthostcomponents(\n  finishedroot: fiberroot,\n  current: fiber,\n  nearestmountedancestor: fiber,\n): void {\n  let node: fiber = current;\n  let currentparent;\n  //  fiberroot rootfiber\n  let currentparentiscontainer;\n  // ......\n\n  while (true) {\n    // ......\n    //  hostcomponent  hosttext \n    if (node.tag === hostcomponent || node.tag === hosttext) {\n      // \n      commitnestedunmounts(finishedroot, node, nearestmountedancestor);\n      //  dom tree \n      if (currentparentiscontainer) {\n        removechildfromcontainer(\n          ((currentparent: any): container),\n          (node.statenode: instance | textinstance),\n        );\n      } else {\n        removechild(\n          ((currentparent: any): instance),\n          (node.statenode: instance | textinstance),\n        );\n      }\n    } /*......*/else {\n      // \n      commitunmount(finishedroot, node, nearestmountedancestor);\n      // \n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    }\n    // \n    if (node === current) {\n      return;\n    }\n    // \n    while (node.sibling === null) {\n      // \n      if (node.return === null || node.return === current) {\n        return;\n      }\n      node = node.return;\n      // ......\n    }\n    // \n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n   dom  host  hostcomponent  hosttext \n\n * commitnestedunmounts :    commitunmount  host \n * removechildfromcontainer  removechild  hostconfig  javascript  host  dom  dom \n * commitunmount \n\n\n# commitunmount\n\n componentwillunmount \n\nfunction commitunmount(\n  finishedroot: fiberroot,\n  current: fiber,\n  nearestmountedancestor: fiber,\n): void {\n  // ......\n  switch (current.tag) {\n    case functioncomponent:\n    case forwardref:\n    case memocomponent:\n    case simplememocomponent: {\n      const updatequeue: functioncomponentupdatequeue | null = (current.updatequeue: any);\n      if (updatequeue !== null) {\n        const lasteffect = updatequeue.lasteffect;\n        //  updatequeue  effect \n        if (lasteffect !== null) {\n          const firsteffect = lasteffect.next;\n          let effect = firsteffect;\n          do {\n            // \n            const {destroy, tag} = effect;\n            if (destroy !== undefined) {\n              // hookinsertion  hooklayout  useinsertioneffect  uselayouteffect \n              if ((tag & hookinsertion) !== nohookeffect) {\n                safelycalldestroy(current, nearestmountedancestor, destroy);\n              } else if ((tag & hooklayout) !== nohookeffect) {\n                // ......\n                safelycalldestroy(current, nearestmountedancestor, destroy);\n              }\n            }\n            effect = effect.next;\n          } while (effect !== firsteffect);\n        }\n      }\n      return;\n    }\n    case classcomponent: {\n      //  refs \n      safelydetachref(current, nearestmountedancestor);\n      const instance = current.statenode;\n      //  componentwillunmount \n      if (typeof instance.componentwillunmount === 'function') {\n        safelycallcomponentwillunmount(\n          current,\n          nearestmountedancestor,\n          instance,\n        );\n      }\n      return;\n    }\n    case hostcomponent: \n    case hostportal:\n    case dehydratedfragment: \n    case scopecomponent: {\n      // ......\n      return;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n\n *  updatequeue  effect  effect  useinsertioneffect  hookinsertion  uselayouteffect  hooklayout  effect  hook \n *  componentwillunmount  trycatch   commitunmount  safely  dom \n\n\n# detachfibermutation\n\n alternate  return  return \n\nfunction detachfibermutation(fiber: fiber) {\n  // cut off the return pointer to disconnect it from the tree.\n  // this enables us to detect and warn against state updates on an unmounted component.\n  // it also prevents events from bubbling from within disconnected components.\n  //\n  // ideally, we should also clear the child pointer of the parent alternate to let this\n  // get gc:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for gc:ing the subtree of this child.\n  // this child itself will be gc:ed when the parent updates the next time.\n  //\n  // note that we can't clear child or sibling pointers yet.\n  // they're needed for passive effects and for finddomnode.\n  // we defer those fields, and all other cleanup, to the passive phase (see detachfiberaftereffects).\n  //\n  // don't reset the alternate yet, either. we need that so we can detach the\n  // alternate's fields in the passive phase. clearing the return pointer is\n  // sufficient for finddomnode semantics.\n  //  workinprogress fiber  current fiber  return  child \n  //  gc  fibertree  return \n  const alternate = fiber.alternate;\n  if (alternate !== null) {\n    alternate.return = null;\n  }\n  fiber.return = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# commitplacement\n\n\n\nfunction commitplacement(finishedwork: fiber): void {\n  // ......\n  //  host  hostcomponenthostroothostportal\n  const parentfiber = gethostparentfiber(finishedwork);\n\n  let parent;\n  //  hostroot  hostportal\n  let iscontainer;\n  // statenode  fiber  dom \n  const parentstatenode = parentfiber.statenode;\n  switch (parentfiber.tag) {\n    case hostcomponent:\n      parent = parentstatenode;\n      iscontainer = false;\n      break;\n    case hostroot:\n      parent = parentstatenode.containerinfo;\n      iscontainer = true;\n      break;\n    case hostportal:\n      parent = parentstatenode.containerinfo;\n      iscontainer = true;\n      break;\n    // ......\n  }\n  // ......\n  //  host \n  // \n  const before = gethostsibling(finishedwork);\n  // we only have the top fiber that was inserted but we need to recurse down its\n  // children to find all the terminal nodes.\n  if (iscontainer) {\n    insertorappendplacementnodeintocontainer(finishedwork, before, parent);\n  } else {\n    insertorappendplacementnode(finishedwork, before, parent);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n\n * gethostparentfiber  host   host host  hostcomponent  hostroot  hostportal  fiber.statenode  host  fiber  dom \n * gethostsibling  host  placement  host  null host  dom \n * insertorappendplacementnode \n\n\n# insertorappendplacementnode\n\n\n\nfunction insertorappendplacementnode(\n  node: fiber,\n  before: ?instance,\n  parent: instance,\n): void {\n  const {tag} = node;\n  const ishost = tag === hostcomponent || tag === hosttext;\n  //  host  before  before \n  // \n  if (ishost) {\n    const statenode = node.statenode;\n    if (before) {\n      insertbefore(parent, statenode, before);\n    } else {\n      appendchild(parent, statenode);\n    }\n  } /*......*/ else {\n    const child = node.child;\n    //  host \n    if (child !== null) {\n      insertorappendplacementnode(child, before, parent);\n      let sibling = child.sibling;\n      while (sibling !== null) {\n        insertorappendplacementnode(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n host \n\n *  host \n *  host \n\n\n# commitwork\n\n hostcomponent  hosttext  host \n\n// src/react/packages/react-reconciler/src/reactfibercommitwork.new.js\nfunction commitwork(current: fiber | null, finishedwork: fiber): void {\n  // ......\n  switch (finishedwork.tag) {\n    case functioncomponent:\n    case forwardref:\n    case memocomponent:\n    case simplememocomponent: {\n      //  fc-like  useinsertioneffect \n      commithookeffectlistunmount(\n        hookinsertion | hookhaseffect,\n        finishedwork,\n        finishedwork.return,\n      );\n      //  useinsertioneffect see https://zh-hans.reactjs.org/docs/hooks-reference.html#useinsertioneffect\n      commithookeffectlistmount(hookinsertion | hookhaseffect, finishedwork);\n      // layout effects are destroyed during the mutation phase so that all\n      // destroy functions for all fibers are called before any create functions.\n      // this prevents sibling component effects from interfering with each other,\n      // e.g. a destroy function in one component should never override a ref set\n      // by a create function in another component during the same commit.\n      // ......\n      //  uselayouteffect \n      commithookeffectlistunmount(\n        hooklayout | hookhaseffect,\n        finishedwork,\n        finishedwork.return,\n      );\n      return;\n    }\n    case hostcomponent: {\n      const instance: instance = finishedwork.statenode;\n      if (instance != null) {\n        // commit the work prepared earlier.\n        const newprops = finishedwork.memoizedprops;\n        // for hydration we reuse the update path but we treat the oldprops\n        // as the newprops. the updatepayload will contain the real change in\n        // this case.\n        const oldprops = current !== null ? current.memoizedprops : newprops;\n        const type = finishedwork.type;\n        const updatepayload: null | updatepayload = (finishedwork.updatequeue: any);\n        finishedwork.updatequeue = null;\n        if (updatepayload !== null) {\n          // \n          commitupdate(\n            instance,\n            updatepayload,\n            type,\n            oldprops,\n            newprops,\n            finishedwork,\n          );\n        }\n      }\n      return;\n    }\n    case hosttext: {\n      // ......\n      const textinstance: textinstance = finishedwork.statenode;\n      const newtext: string = finishedwork.memoizedprops;\n      // for hydration we reuse the update path but we treat the oldprops\n      // as the newprops. the updatepayload will contain the real change in\n      // this case.\n      const oldtext: string =\n        current !== null ? current.memoizedprops : newtext;\n      // \n      committextupdate(textinstance, oldtext, newtext);\n      return;\n    }\n    case classcomponent: \n    case hostroot: \n    case profiler: \n    case suspensecomponent: \n    case suspenselistcomponent: \n    case incompleteclasscomponent: {\n      // ......\n      return;\n    }\n    case scopecomponent: {\n      // ......\n      break;\n    }\n  }\n  // ......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n *  useinsertioneffect  useinsertioneffect  uselayouteffect  mutation  layout \n * useinsertioneffect  dom  css-in-js  uselayouteffect  dom dom  css  hook api   useinsertioneffect\n *  hostcomponent  commitupdate  hosttext  committextupdate  hostconfig  host  dom \n\n\n# commithookeffectlistmount\n\n useeffect  uselayouteffect  useinsertioneffect  hook  hook \n\n\n# commitdetachref\n\n ref \n\nfunction commitdetachref(current: fiber) {\n  const currentref = current.ref;\n  if (currentref !== null) {\n    //  ref  function ref null\n    if (typeof currentref === 'function') {\n      currentref(null);\n      // ......\n    } else {\n      //  ref null \n      currentref.current = null;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# commitattachref\n\n ref \n\nfunction commitattachref(finishedwork: fiber) {\n  const ref = finishedwork.ref;\n  //  commitmutationeffectsonfiber  detach  current fiber  ref\n  //  workinprogress fiber  ref ref \n  if (ref !== null) {\n    //  dom `fiber.statenode`  host  dom \n    // \n    const instance = finishedwork.statenode;\n    let instancetouse;\n    switch (finishedwork.tag) {\n      case hostcomponent:\n        instancetouse = getpublicinstance(instance);\n        break;\n      default:\n        instancetouse = instance;\n    }\n    // ......\n    // function ref  ref\n    if (typeof ref === 'function') {\n      ref(instancetouse);\n    } else {\n      // ......\n      ref.current = instancetouse;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n *  host ref  host  hostcomponent ref  dom  hosttext  hostroot  hostportal  ref ref \n * ref  ref  ref refs and the dom   refs\n\n\n# \n\n\n#   dom \n\n insertorappendplacementnode  react  host  insertbefore  appendchild      placechild \n\nif (current !== null) {\n  const oldindex = current.index;\n  if (oldindex < lastplacedindex) {\n    newfiber.flags |= placement;\n    return lastplacedindex;\n  } else {\n    return oldindex;\n  }\n} else {\n  newfiber.flags |= placement;\n  return lastplacedindex\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n placement \n\n *   \n *   \n\n\n\n\n\n *  effecttag list fibertree  render \n *  effecttag list  dom commit  mutation \n\n    \n\n\n# \n\n\n# \n\n commitdeletion  commitplacement  commitwork  mutation  dom    fibertree  domtree fibertree  domtree  fibertree fibertree  domtree  fiber.statenode  fiber.tag \n\nfiber.tag  host  hostcomponent  hosttext  fiber  dom  effecttag  host  fiber.statenode  host  dom  dom \n\nreact  dom mutation\n\n * deletion  removechild \n * placement  insertbefore  appendchild \n * update  commitupdate \n\nref  dom  hostconfig  removechild  commitupdate  hostconfig  host \n\n\n# \n\n * know about the useinsertioneffect hook in react 18 | saeloun blog\n * library upgrade guide: style most css-in-js libs  discussion #110  reactwg/react-18",charsets:{cjk:!0},lastUpdated:"2022/08/09, 20:11:40",lastUpdatedTimestamp:16600471e5},{title:"React React ",frontmatter:{title:"React React ",date:"2022-08-09T12:02:21.000Z",permalink:"/react/tour/react-reconciliation-10/",categories:["react","React"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/180.react-reconciliation-10.html",relativePath:"10.react/90.React/180.react-reconciliation-10.md",key:"v-4079c547",path:"/react/tour/react-reconciliation-10/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:2,title:"removeChild",slug:"removechild",normalizedTitle:"removechild",charIndex:23},{level:2,title:"insertBefore",slug:"insertbefore",normalizedTitle:"insertbefore",charIndex:38},{level:2,title:"appendChild",slug:"appendchild",normalizedTitle:"appendchild",charIndex:54},{level:2,title:"commitTextUpdate",slug:"committextupdate",normalizedTitle:"committextupdate",charIndex:69},{level:2,title:"commitUpdate",slug:"commitupdate",normalizedTitle:"commitupdate",charIndex:89},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:105},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:111},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:117},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:123}],readingTime:{text:"2 min read",minutes:1.23,time:73800,words:246},headersStr:"  removeChild insertBefore appendChild commitTextUpdate commitUpdate    ",content:'# \n\n\n\n * \n * \n * removeChild\n * insertBefore\n * appendChild\n * commitTextUpdate\n * commitUpdate\n * \n * \n * \n * \n\n\n\n\n# \n\n mutation  EffectTag List  DOM  DOM  DOM  React  HOST  DOM, canvas, consolenodejs  DOM \n\nReact  HOST renderer HostConfig  HostConfig  DOM React \n\n\n\nA "host config" is an object that you need to provide, and that describes how to make something happen in the "host" environment (e.g. DOM, canvas, console, native, or whatever your rendering target is).\n\n DOM \n\n\n# removeChild\n\n\n\nfunction removeChild(\n  parentInstance: Instance,\n  child: Instance | TextInstance | SuspenseInstance,\n): void {\n  parentInstance.removeChild(child);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# insertBefore\n\n\n\nfunction insertBefore(\n  parentInstance: Instance,\n  child: Instance | TextInstance,\n  beforeChild: Instance | TextInstance | SuspenseInstance,\n): void {\n  parentInstance.insertBefore(child, beforeChild);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# appendChild\n\n\n\nfunction appendChild(\n  parentInstance: Instance,\n  child: Instance | TextInstance,\n): void {\n  parentInstance.appendChild(child);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# commitTextUpdate\n\n\n\nfunction commitTextUpdate(\n  textInstance: TextInstance,\n  oldText: string,\n  newText: string,\n): void {\n  textInstance.nodeValue = newText;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# commitUpdate\n\n\n\nfunction commitUpdate(\n  domElement: Instance,\n  updatePayload: Array<mixed>,\n  type: string,\n  oldProps: Props,\n  newProps: Props,\n  internalInstanceHandle: Object,\n): void {\n  // src/react/packages/react-dom/src/client/ReactDOMComponent.js\n  // Apply the diff to the DOM node.\n  updateProperties(domElement, updatePayload, type, oldProps, newProps);\n  // Update the props handle so that we know which props are the ones with\n  // with current event handlers.\n  updateFiberProps(domElement, newProps);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# \n\n\n# \n\n\n# \n\n\n# \n\n * react/README.md at main  facebook/react',normalizedContent:'# \n\n\n\n * \n * \n * removechild\n * insertbefore\n * appendchild\n * committextupdate\n * commitupdate\n * \n * \n * \n * \n\n\n\n\n# \n\n mutation  effecttag list  dom  dom  dom  react  host  dom, canvas, consolenodejs  dom \n\nreact  host renderer hostconfig  hostconfig  dom react \n\n\n\na "host config" is an object that you need to provide, and that describes how to make something happen in the "host" environment (e.g. dom, canvas, console, native, or whatever your rendering target is).\n\n dom \n\n\n# removechild\n\n\n\nfunction removechild(\n  parentinstance: instance,\n  child: instance | textinstance | suspenseinstance,\n): void {\n  parentinstance.removechild(child);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# insertbefore\n\n\n\nfunction insertbefore(\n  parentinstance: instance,\n  child: instance | textinstance,\n  beforechild: instance | textinstance | suspenseinstance,\n): void {\n  parentinstance.insertbefore(child, beforechild);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# appendchild\n\n\n\nfunction appendchild(\n  parentinstance: instance,\n  child: instance | textinstance,\n): void {\n  parentinstance.appendchild(child);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# committextupdate\n\n\n\nfunction committextupdate(\n  textinstance: textinstance,\n  oldtext: string,\n  newtext: string,\n): void {\n  textinstance.nodevalue = newtext;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# commitupdate\n\n\n\nfunction commitupdate(\n  domelement: instance,\n  updatepayload: array<mixed>,\n  type: string,\n  oldprops: props,\n  newprops: props,\n  internalinstancehandle: object,\n): void {\n  // src/react/packages/react-dom/src/client/reactdomcomponent.js\n  // apply the diff to the dom node.\n  updateproperties(domelement, updatepayload, type, oldprops, newprops);\n  // update the props handle so that we know which props are the ones with\n  // with current event handlers.\n  updatefiberprops(domelement, newprops);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# \n\n\n# \n\n\n# \n\n\n# \n\n * react/readme.md at main  facebook/react',charsets:{cjk:!0},lastUpdated:"2022/08/09, 20:11:40",lastUpdatedTimestamp:16600471e5},{title:"",frontmatter:{title:"",date:"2022-08-22T14:19:35.000Z",permalink:"/react/tour/talk/",categories:["react","React"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/2.talk.html",relativePath:"10.react/90.React/2.talk.md",key:"v-5585c5df",path:"/react/tour/talk/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:2,title:" React ",slug:"-react-",normalizedTitle:" react ",charIndex:25},{level:2,title:" React ",slug:"-react-",normalizedTitle:" react ",charIndex:43},{level:2,title:" React ",slug:"-react-",normalizedTitle:" react ",charIndex:60},{level:2,title:" React ",slug:"-react-",normalizedTitle:" react ",charIndex:84},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:108},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:117}],readingTime:{text:"2 min read",minutes:1.205,time:72300.00000000001,words:241},headersStr:"   React   React   React   React   ",content:"# \n\n\n\n * \n * \n *  React \n *  React \n *  React \n *  React \n * \n * \n\n\n\n React  React \n\n React \n\n React \n\n\n# \n\n *  Javascript \n *  React \n\n\n#  React \n\n React \n\n 1. React  API  useState useState \n 2.  API \n 3. \n 4.  antd  React  API \n 5.  React \n\n React \n\n 1.  setState \n 2.  key  key \n 3.  useRef useMemouseCallback \n 4.  hook hook \n 5. \n\n React  React \n\n\n#  React \n\n\n\n 1. \n 2.  API \n 3. \n\n\n\n 1. React  Dev \n 2. React \n 3. \n\n\n#  React \n\n * \n * \n * js \n\n\n#  React \n\n *  dev \n *  15 \n * \n\n\n# \n\n React     \n\n React      \n\n * \n *  React \n * setState \n * Virtual DOM  React  VDOM \n * React  Diff \n *  React  React \n * \n * React Hook \n * useEffect  useLayoutEffect \n * React Hooks \n * React Hooks \n * React key  \n *  React  Vue \n * React \n * React  JSX  JSX\n *  react \n *  React-Fiber \n *  React  render \n * React \n * ......\n\n  React   \n\n React \n\n\n# \n\n * React - \n * 2021 React  - ",normalizedContent:"# \n\n\n\n * \n * \n *  react \n *  react \n *  react \n *  react \n * \n * \n\n\n\n react  react \n\n react \n\n react \n\n\n# \n\n *  javascript \n *  react \n\n\n#  react \n\n react \n\n 1. react  api  usestate usestate \n 2.  api \n 3. \n 4.  antd  react  api \n 5.  react \n\n react \n\n 1.  setstate \n 2.  key  key \n 3.  useref usememousecallback \n 4.  hook hook \n 5. \n\n react  react \n\n\n#  react \n\n\n\n 1. \n 2.  api \n 3. \n\n\n\n 1. react  dev \n 2. react \n 3. \n\n\n#  react \n\n * \n * \n * js \n\n\n#  react \n\n *  dev \n *  15 \n * \n\n\n# \n\n react     \n\n react      \n\n * \n *  react \n * setstate \n * virtual dom  react  vdom \n * react  diff \n *  react  react \n * \n * react hook \n * useeffect  uselayouteffect \n * react hooks \n * react hooks \n * react key  \n *  react  vue \n * react \n * react  jsx  jsx\n *  react \n *  react-fiber \n *  react  render \n * react \n * ......\n\n  react   \n\n react \n\n\n# \n\n * react - \n * 2021 react  - ",charsets:{cjk:!0},lastUpdated:"2022/08/24, 18:21:13",lastUpdatedTimestamp:1661336473e3},{title:"React ReactChildren ",frontmatter:{title:"React ReactChildren ",date:"2022-04-14T22:02:21.000Z",permalink:"/react/tour/react-basic-children/",categories:["react","React"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/20.react-basic-children.html",relativePath:"10.react/90.React/20.react-basic-children.md",key:"v-50140a3b",path:"/react/tour/react-basic-children/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:25},{level:2,title:" React.Children?",slug:"-react-children",normalizedTitle:" react.children?",charIndex:33},{level:2,title:"map",slug:"map",normalizedTitle:"map",charIndex:56},{level:2,title:"forEach",slug:"foreach",normalizedTitle:"foreach",charIndex:63},{level:2,title:"count",slug:"count",normalizedTitle:"count",charIndex:74},{level:2,title:"toArray",slug:"toarray",normalizedTitle:"toarray",charIndex:83},{level:2,title:"only",slug:"only",normalizedTitle:"only",charIndex:94},{level:2,title:"cloneElement",slug:"cloneelement",normalizedTitle:"cloneelement",charIndex:102},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:118},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:124},{level:3,title:"ChildrenKey ",slug:"childrenkey-",normalizedTitle:"childrenkey ",charIndex:132},{level:3,title:"ReactElementJSX.Element  ReactNode ",slug:"reactelementjsx-element--reactnode-",normalizedTitle:"reactelementjsx.element  reactnode ",charIndex:157},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:203},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:220}],readingTime:{text:"6 min read",minutes:5.55,time:333e3,words:1110},headersStr:"    React.Children? map forEach count toArray only cloneElement   ChildrenKey  ReactElementJSX.Element  ReactNode   ",content:"# \n\n\n\n * \n * \n   * \n *  React.Children?\n * map\n * forEach\n * count\n * toArray\n * only\n * cloneElement\n * \n * \n   * ChildrenKey \n   * ReactElementJSX.Element  ReactNode \n   * \n * \n\n\n\n\n# \n\n ReactElement   JSXReactElementVDOMComponent  ReactNode  ReactChildren \n\n\n# \n\n *  ReactChildren \n *  ReactElementReactNodeReactChildren\n *  ReactChildren \n\n\n#  React.Children?\n\n> React.Children  this.props.children \n\nChildren  props.children Children  ReactNodeReactNode ClassComponent  render ()  FunctionComponent \n\n ReactChildren \n\n * ReactNode ReactNode map \n *  ReactNode \n\n React React Children \n\n// ReactChildrenReactChildren\n{ \n  map,\n  forEach,\n  count,\n  toArray,\n  only,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\n\n# map\n\nmap  ReactChildren \n\nmap  mapChildren mapChildren  mapIntoArray\n\nfunction mapChildren(\n  children: ?ReactNodeList,\n  func: MapFunc,\n  context: mixed,\n): ?Array<React$Node> {\n  if (children == null) {\n    return children;\n  }\n  const result = [];\n  let count = 0;\n  //  mapIntoArray  children func result\n  mapIntoArray(children, result, '', '', function(child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n mapIntoArray  children  undefinedbooleannullstringnumber  ReactElement  ReactPortal  object T mapIntoArray  children  T []  object \n\nfunction mapIntoArray(\n  children: ?ReactNodeList,\n  array: Array<React$Node>,\n  escapedPrefix: string,\n  nameSoFar: string,\n  callback: (?React$Node) => ?ReactNodeList,\n): number {\n  //  undefinedbooleannullstringnumber object  ReactElement  ReactPortal \n  // invokeCallback  true\n  if (invokeCallback) {\n    const child = children;\n    //  callback\n    let mappedChild = callback(child);\n    //  key \n    const childKey =\n      nameSoFar === '' ? SEPARATOR + getElementKey(child, 0) : nameSoFar;\n    //  map \n    if (isArray(mappedChild)) {\n      // ......\n      //  callback  c => c flat\n      mapIntoArray(mappedChild, array, escapedChildKey, '', c => c);\n    } else if (mappedChild != null) {\n      //  mappedChild  ReactElement\n      if (isValidElement(mappedChild)) {\n        //  mappedChild  key \n        mappedChild = cloneAndReplaceKey(\n          mappedChild,\n          //  mappedChild  key\n          escapedPrefix +\n            (mappedChild.key && (!child || child.key !== mappedChild.key)\n              ? escapeUserProvidedKey('' + mappedChild.key) + '/'\n              : '') +\n            childKey,\n        );\n      }\n      //  mappedChild \n      array.push(mappedChild);\n    }\n    //  count  callback \n    return 1;\n  }\n\n  // ......\n\n  return subtreeCount;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n\n *  children callback callback callback  ReactElement.props.children \n *  map  result  key \n\n\n# forEach\n\nforEach  ReactChildren \n\nforEach  forEachChildren  mapChildren  forEach \n\nfunction forEachChildren(\n  children: ?ReactNodeList,\n  forEachFunc: ForEachFunc,\n  forEachContext: mixed,\n): void {\n  mapChildren(\n    children,\n    function() {\n      // arguments  callback \n      forEachFunc.apply(this, arguments);\n    },\n    forEachContext,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nforEach  map  map \n\n\n# count\n\ncount  children \n\ncount  countChildren  1\n\nfunction countChildren(children: ?ReactNodeList): number {\n  let n = 0;\n  mapChildren(children, () => {\n    n++;\n  });\n  return n;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# toArray\n\ntoArray  children  mapChildren \n\nfunction toArray(children: ?ReactNodeList): Array<React$Node> {\n  return mapChildren(children, child => child) || [];\n}\n\n\n1\n2\n3\n\n\n\n# only\n\nonly  children \n\nonly  onlyChild \n\nfunction onlyChild<T>(children: T): T {\n  if (!isValidElement(children)) {\n    throw new Error(\n      'React.Children.only expected to receive a single React element child.',\n    );\n  }\n  return children;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# cloneElement\n\n\n# \n\n React.Children  API  cloneElement  createElement  antd  Timeline \n\n// components/timeline/Timeline.tsx\n//  truthyItems \nconst items = React.Children.map(\n  truthyItems,\n  (ele: React.ReactElement<any>, idx) => {\n    const pendingClass = idx === itemsCount - 2 ? lastCls : \"\";\n    const readyClass = idx === itemsCount - 1 ? lastCls : \"\";\n    //  className \n    return cloneElement(ele, {\n      className: classNames([\n        ele.props.className,\n        !reverse && !!pending ? pendingClass : readyClass,\n        getPositionCls(ele, idx),\n      ]),\n    });\n  }\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# \n\n\n# ChildrenKey \n\n mapIntoArray  cloneAndReplaceKey  key \n\n// key = \nconst SEPARATOR = '.';\nconst SUBSEPARATOR = ':';\n//  '' mappedChild\nconst escapedPrefix = escapeUserProvidedKey(childKey) + '/';\nconst nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n//  ''\nconst nameSoFar = nextNamePrefix + getElementKey(child, i);\nconst childKey = nameSoFar === '' ? SEPARATOR + getElementKey(child, 0) : nameSoFar;\nconst key = escapedPrefix +\n            (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey('' + mappedChild.key) + '/' : '') +\n            childKey;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\n *  children key1 = escapeUserProvidedKey (mappedChild.key) + '/' + SEPARATOR + randomKey;\n *  mappedChild  childrenkey2 = escapeUserProvidedKey (SEPARATOR + randomKey + '/') + '/' + key1;\n * key3 = escapeUserProvidedKey (mappedChild.key) + '/' + SUBSEPARATOR + randomKey;\n *  mappedChild  childrenkey4 = escapeUserProvidedKey (SUBSEPARATOR + randomKey + '/') + '/' + key3;\n\n mapIntoArray  key \n\n randomKey\n\nfunction getElementKey(element: any, index: number): string {\n  //  key \n  if (typeof element === 'object' && element !== null && element.key != null) {\n    return escape('' + element.key);\n  }\n  //  36  0-9-a-z (35).toString(36) === 'z'\n  return index.toString(36);\n}\n//  key  key  escape  `$`\nfunction escape(key: string): string {\n  const escapeRegex = /[=:]/g;\n  const escaperLookup = {\n    '=': '=0',\n    ':': '=2',\n  };\n  const escapedString = key.replace(escapeRegex, function(match) {\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n 36  idkey \n\n// \nconst genSeed = () => (~~(Math.random()*36)).toString(36); // \"s\"\n\nfunction randomStringGenerator(length){\n   let s = '';\n   while(s.length < length) s += genSeed();\n   return s;\n}\nrandomStringGenerator(6); // \"6muky\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# ReactElementJSX.Element  ReactNode \n\n React \n\ninterface ReactElement<P = any, T extends string | JSXElementConstructor<any> = string | JSXElementConstructor<any>> {\n  type: T;\n  props: P;\n  key: Key | null;\n}\ntype ReactText = string | number;\ntype ReactChild = ReactElement | ReactText;\ntype ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined;\n\nnamespace JSX {\n  interface Element extends React.ReactElement<any, any> { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n ReactNode > JSX.Element > ReactElement \n\n * ReactNodeReactNode  React  ReactChildReactChild  ReactElement\n * JSX.ElementJSX.Element  ReactElement  JSX.Element  JSX  ReactNode  type  props  any\n * ReactElementReactElement  type  props  key  object DOM  FunctionComponent  ClassComponent  render \n\n\n# \n\nReact 17  ReactChildren  React 16 \n\n traverseContext \n\n// traverseContextPool  size\nconst POOL_SIZE = 10;\nconst traverseContextPool = [];\n//  traverseContextPool  traverseContext\nfunction getPooledTraverseContext(\n  mapResult, // \n  keyPrefix, // traverseContext  key\n  mapFunction, // \n  mapContext, //  context\n) {\n  // \n  if (traverseContextPool.length) {\n    // traverseContext\n    const traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    //  traverseContext\n    return traverseContext;\n  } else {\n    //  traverseContext 10 \n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0,\n    };\n  }\n}\n//  traverseContext  traverseContextPool\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n POOL_SIZE  POOL_SIZE  context \n\n\n# \n\n\n\n * ReactNodeReactElementReactChildren \n * React.children map,forEach,count,toArray,only \n *  ReactChildren ",normalizedContent:"# \n\n\n\n * \n * \n   * \n *  react.children?\n * map\n * foreach\n * count\n * toarray\n * only\n * cloneelement\n * \n * \n   * childrenkey \n   * reactelementjsx.element  reactnode \n   * \n * \n\n\n\n\n# \n\n reactelement   jsxreactelementvdomcomponent  reactnode  reactchildren \n\n\n# \n\n *  reactchildren \n *  reactelementreactnodereactchildren\n *  reactchildren \n\n\n#  react.children?\n\n> react.children  this.props.children \n\nchildren  props.children children  reactnodereactnode classcomponent  render ()  functioncomponent \n\n reactchildren \n\n * reactnode reactnode map \n *  reactnode \n\n react react children \n\n// reactchildrenreactchildren\n{ \n  map,\n  foreach,\n  count,\n  toarray,\n  only,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\n\n# map\n\nmap  reactchildren \n\nmap  mapchildren mapchildren  mapintoarray\n\nfunction mapchildren(\n  children: ?reactnodelist,\n  func: mapfunc,\n  context: mixed,\n): ?array<react$node> {\n  if (children == null) {\n    return children;\n  }\n  const result = [];\n  let count = 0;\n  //  mapintoarray  children func result\n  mapintoarray(children, result, '', '', function(child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n mapintoarray  children  undefinedbooleannullstringnumber  reactelement  reactportal  object t mapintoarray  children  t []  object \n\nfunction mapintoarray(\n  children: ?reactnodelist,\n  array: array<react$node>,\n  escapedprefix: string,\n  namesofar: string,\n  callback: (?react$node) => ?reactnodelist,\n): number {\n  //  undefinedbooleannullstringnumber object  reactelement  reactportal \n  // invokecallback  true\n  if (invokecallback) {\n    const child = children;\n    //  callback\n    let mappedchild = callback(child);\n    //  key \n    const childkey =\n      namesofar === '' ? separator + getelementkey(child, 0) : namesofar;\n    //  map \n    if (isarray(mappedchild)) {\n      // ......\n      //  callback  c => c flat\n      mapintoarray(mappedchild, array, escapedchildkey, '', c => c);\n    } else if (mappedchild != null) {\n      //  mappedchild  reactelement\n      if (isvalidelement(mappedchild)) {\n        //  mappedchild  key \n        mappedchild = cloneandreplacekey(\n          mappedchild,\n          //  mappedchild  key\n          escapedprefix +\n            (mappedchild.key && (!child || child.key !== mappedchild.key)\n              ? escapeuserprovidedkey('' + mappedchild.key) + '/'\n              : '') +\n            childkey,\n        );\n      }\n      //  mappedchild \n      array.push(mappedchild);\n    }\n    //  count  callback \n    return 1;\n  }\n\n  // ......\n\n  return subtreecount;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n\n *  children callback callback callback  reactelement.props.children \n *  map  result  key \n\n\n# foreach\n\nforeach  reactchildren \n\nforeach  foreachchildren  mapchildren  foreach \n\nfunction foreachchildren(\n  children: ?reactnodelist,\n  foreachfunc: foreachfunc,\n  foreachcontext: mixed,\n): void {\n  mapchildren(\n    children,\n    function() {\n      // arguments  callback \n      foreachfunc.apply(this, arguments);\n    },\n    foreachcontext,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nforeach  map  map \n\n\n# count\n\ncount  children \n\ncount  countchildren  1\n\nfunction countchildren(children: ?reactnodelist): number {\n  let n = 0;\n  mapchildren(children, () => {\n    n++;\n  });\n  return n;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# toarray\n\ntoarray  children  mapchildren \n\nfunction toarray(children: ?reactnodelist): array<react$node> {\n  return mapchildren(children, child => child) || [];\n}\n\n\n1\n2\n3\n\n\n\n# only\n\nonly  children \n\nonly  onlychild \n\nfunction onlychild<t>(children: t): t {\n  if (!isvalidelement(children)) {\n    throw new error(\n      'react.children.only expected to receive a single react element child.',\n    );\n  }\n  return children;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# cloneelement\n\n\n# \n\n react.children  api  cloneelement  createelement  antd  timeline \n\n// components/timeline/timeline.tsx\n//  truthyitems \nconst items = react.children.map(\n  truthyitems,\n  (ele: react.reactelement<any>, idx) => {\n    const pendingclass = idx === itemscount - 2 ? lastcls : \"\";\n    const readyclass = idx === itemscount - 1 ? lastcls : \"\";\n    //  classname \n    return cloneelement(ele, {\n      classname: classnames([\n        ele.props.classname,\n        !reverse && !!pending ? pendingclass : readyclass,\n        getpositioncls(ele, idx),\n      ]),\n    });\n  }\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# \n\n\n# childrenkey \n\n mapintoarray  cloneandreplacekey  key \n\n// key = \nconst separator = '.';\nconst subseparator = ':';\n//  '' mappedchild\nconst escapedprefix = escapeuserprovidedkey(childkey) + '/';\nconst nextnameprefix = namesofar === '' ? separator : namesofar + subseparator;\n//  ''\nconst namesofar = nextnameprefix + getelementkey(child, i);\nconst childkey = namesofar === '' ? separator + getelementkey(child, 0) : namesofar;\nconst key = escapedprefix +\n            (mappedchild.key && (!child || child.key !== mappedchild.key) ? escapeuserprovidedkey('' + mappedchild.key) + '/' : '') +\n            childkey;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\n *  children key1 = escapeuserprovidedkey (mappedchild.key) + '/' + separator + randomkey;\n *  mappedchild  childrenkey2 = escapeuserprovidedkey (separator + randomkey + '/') + '/' + key1;\n * key3 = escapeuserprovidedkey (mappedchild.key) + '/' + subseparator + randomkey;\n *  mappedchild  childrenkey4 = escapeuserprovidedkey (subseparator + randomkey + '/') + '/' + key3;\n\n mapintoarray  key \n\n randomkey\n\nfunction getelementkey(element: any, index: number): string {\n  //  key \n  if (typeof element === 'object' && element !== null && element.key != null) {\n    return escape('' + element.key);\n  }\n  //  36  0-9-a-z (35).tostring(36) === 'z'\n  return index.tostring(36);\n}\n//  key  key  escape  `$`\nfunction escape(key: string): string {\n  const escaperegex = /[=:]/g;\n  const escaperlookup = {\n    '=': '=0',\n    ':': '=2',\n  };\n  const escapedstring = key.replace(escaperegex, function(match) {\n    return escaperlookup[match];\n  });\n\n  return '$' + escapedstring;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n 36  idkey \n\n// \nconst genseed = () => (~~(math.random()*36)).tostring(36); // \"s\"\n\nfunction randomstringgenerator(length){\n   let s = '';\n   while(s.length < length) s += genseed();\n   return s;\n}\nrandomstringgenerator(6); // \"6muky\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# reactelementjsx.element  reactnode \n\n react \n\ninterface reactelement<p = any, t extends string | jsxelementconstructor<any> = string | jsxelementconstructor<any>> {\n  type: t;\n  props: p;\n  key: key | null;\n}\ntype reacttext = string | number;\ntype reactchild = reactelement | reacttext;\ntype reactnode = reactchild | reactfragment | reactportal | boolean | null | undefined;\n\nnamespace jsx {\n  interface element extends react.reactelement<any, any> { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n reactnode > jsx.element > reactelement \n\n * reactnodereactnode  react  reactchildreactchild  reactelement\n * jsx.elementjsx.element  reactelement  jsx.element  jsx  reactnode  type  props  any\n * reactelementreactelement  type  props  key  object dom  functioncomponent  classcomponent  render \n\n\n# \n\nreact 17  reactchildren  react 16 \n\n traversecontext \n\n// traversecontextpool  size\nconst pool_size = 10;\nconst traversecontextpool = [];\n//  traversecontextpool  traversecontext\nfunction getpooledtraversecontext(\n  mapresult, // \n  keyprefix, // traversecontext  key\n  mapfunction, // \n  mapcontext, //  context\n) {\n  // \n  if (traversecontextpool.length) {\n    // traversecontext\n    const traversecontext = traversecontextpool.pop();\n    traversecontext.result = mapresult;\n    traversecontext.keyprefix = keyprefix;\n    traversecontext.func = mapfunction;\n    traversecontext.context = mapcontext;\n    traversecontext.count = 0;\n    //  traversecontext\n    return traversecontext;\n  } else {\n    //  traversecontext 10 \n    return {\n      result: mapresult,\n      keyprefix: keyprefix,\n      func: mapfunction,\n      context: mapcontext,\n      count: 0,\n    };\n  }\n}\n//  traversecontext  traversecontextpool\nfunction releasetraversecontext(traversecontext) {\n  traversecontext.result = null;\n  traversecontext.keyprefix = null;\n  traversecontext.func = null;\n  traversecontext.context = null;\n  traversecontext.count = 0;\n  if (traversecontextpool.length < pool_size) {\n    traversecontextpool.push(traversecontext);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n pool_size  pool_size  context \n\n\n# \n\n\n\n * reactnodereactelementreactchildren \n * react.children map,foreach,count,toarray,only \n *  reactchildren ",charsets:{cjk:!0},lastUpdated:"2022/07/22, 14:56:40",lastUpdatedTimestamp:1658473e6},{title:"React React ",frontmatter:{title:"React React ",date:"2022-07-19T19:17:26.000Z",permalink:"/react/tour/react-basic-glimpse/",categories:["react","React"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/30.react-basic-view.html",relativePath:"10.react/90.React/30.react-basic-view.md",key:"v-ec07c126",path:"/react/tour/react-basic-glimpse/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:23},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:31}],readingTime:{text:"1 min read",minutes:.165,time:9900,words:33},headersStr:"   ",content:"# \n\n\n\n * \n * \n * \n * \n\n\n\n\n# \n\n\n# \n\n\n# \n\n *   Overreacted\n * Algebraic Effects for Functional Programming\n * ",normalizedContent:"# \n\n\n\n * \n * \n * \n * \n\n\n\n\n# \n\n\n# \n\n\n# \n\n *   overreacted\n * algebraic effects for functional programming\n * ",charsets:{cjk:!0},lastUpdated:"2022/08/24, 18:21:13",lastUpdatedTimestamp:1661336473e3},{title:"React React ",frontmatter:{title:"React React ",date:"2022-08-09T17:07:40.000Z",permalink:"/react/tour/react-scheduler-1/",categories:["react","React"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/300.react-scheduler-1.html",relativePath:"10.react/90.React/300.react-scheduler-1.md",key:"v-2d7c6c07",path:"/react/tour/react-scheduler-1/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2}],readingTime:{text:"1 min read",minutes:.075,time:4500,words:15},headersStr:"",content:"# \n\n\n\n * \n\n",normalizedContent:"# \n\n\n\n * \n\n",charsets:{cjk:!0},lastUpdated:"2022/08/09, 20:11:40",lastUpdatedTimestamp:16600471e5},{title:"React React ",frontmatter:{title:"React React ",date:"2022-04-14T22:02:21.000Z",permalink:"/react/tour/react-reconciliation-1/",categories:["react","React"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/90.react-reconciliation-1.html",relativePath:"10.react/90.React/90.react-reconciliation-1.md",key:"v-49f7f4ca",path:"/react/tour/react-reconciliation-1/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:2,title:"updateContainer",slug:"updatecontainer--",normalizedTitle:"updatecontainer",charIndex:23},{level:2,title:"scheduleUpdateOnFiber",slug:"scheduleupdateonfiber--",normalizedTitle:"scheduleupdateonfiber",charIndex:52},{level:2,title:"ensureRootIsScheduled",slug:"ensurerootisscheduled--",normalizedTitle:"ensurerootisscheduled",charIndex:87},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:124},{level:3,title:" updateContainer ",slug:"-updatecontainer---",normalizedTitle:" updatecontainer   ",charIndex:7130},{level:3,title:"scheduleMicrotask  queueMicrotask",slug:"schedulemicrotask--queuemicrotask",normalizedTitle:"schedulemicrotask  queuemicrotask",charIndex:168},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:206},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:214},{level:3,title:"lanes ",slug:"lanes-",normalizedTitle:"lanes ",charIndex:228},{level:3,title:"FiberRoot  RootFiber ",slug:"fiberroot--rootfiber-",normalizedTitle:"fiberroot  rootfiber ",charIndex:248},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:279}],readingTime:{text:"5 min read",minutes:4.315,time:258900.00000000003,words:863},headersStr:"  updateContainer scheduleUpdateOnFiber ensureRootIsScheduled   updateContainer  scheduleMicrotask  queueMicrotask   lanes  FiberRoot  RootFiber  ",content:"# \n\n\n\n * \n * \n * updateContainer\n * scheduleUpdateOnFiber\n * ensureRootIsScheduled\n * \n   *  updateContainer \n   * scheduleMicrotask  queueMicrotask\n * \n   * \n   * lanes \n   * FiberRoot  RootFiber \n * \n\n\n\n\n# \n\n\n# updateContainer\n\n> updateContainer \n\n\n\n// src/react/packages/react-reconciler/src/ReactFiberReconciler.new.js\nexport function updateContainer(\n  // \n  element: ReactNodeList,\n  // \n  container: OpaqueRoot,\n): Lane {\n  //  RootFiber\n  const current = container.current;\n  const eventTime = requestEventTime();\n  const lane = requestUpdateLane(current);\n  //  container  context \n  const context = getContextForSubtree();\n  // \n  const update = createUpdate(eventTime, lane);\n  // \n  enqueueUpdate(current, update, lane);\n  // \n  const root = scheduleUpdateOnFiber(current, lane, eventTime);\n\n  return lane;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n React  React  updateContainer  API updateContainer  update  update  React \n\n updateContainer \n\n * \n *  scheduleUpdateOnFiber() \n\n\n# scheduleUpdateOnFiber\n\n> scheduleUpdateOnFiber  FiberTree \n\n updateContainer  scheduleUpdateOnFiber  fiber RootFiber  fiber \n\n\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nlet workInProgressRootRenderPhaseUpdatedLanes: Lanes = NoLanes;\n\nexport function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {\n  return a | b;\n}\n\nexport function scheduleUpdateOnFiber(\n  //  RootFiber\n  fiber: Fiber,\n  // \n  lane: Lane,\n  eventTime: number,\n): FiberRoot | null {\n  // \n  checkForNestedUpdates();\n  //  fiber  lanesrootFiberRoot = fiber.stateNode updateContainer  fiber  RootFiber\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\n\n  //  root root.pendingLanes |= lane\n  markRootUpdated(root, lane, eventTime);\n  //  Render  root  FiberRoot lane Render  lanes\n  if (\n    (executionContext & RenderContext) !== NoLanes &&\n    root === workInProgressRoot\n  ) {\n    //  lane  workInProgressRootRenderPhaseUpdatedLanes render  RootFiber \n    workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(\n      workInProgressRootRenderPhaseUpdatedLanes,\n      lane,\n    );\n  } else {\n    //  FiberRoot \n    ensureRootIsScheduled(root, eventTime);\n  }\n  return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n fiber ensureRootIsScheduled  rootroot  FiberRoot Fiber FiberRoot  FiberTree FiberRoot  RootFiber \n\nmarkUpdateLaneFromFiberToRoot  FiberRoot  RootFiberroot \n\n\n\n *  fiber  lanes FiberRoot\n *  ensureRootIsScheduled FiberRoot \n\n\n# ensureRootIsScheduled\n\n> ensureRootIsScheduled \n\n scheduleUpdateOnFiber  ensureRootIsScheduled fiber  FiberRoot  FiberRoot \n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\n  // \n  const existingCallbackNode = root.callbackNode;\n\n  //  lanes\n  const nextLanes = getNextLanes(\n    root,\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\n  );\n  //  lanes\n  if (nextLanes === NoLanes) {\n    root.callbackNode = null;\n    root.callbackPriority = NoLane;\n    return;\n  }\n\n  //  lanes  lane \n  const newCallbackPriority = getHighestPriorityLane(nextLanes);\n\n  // \n  if (existingCallbackNode != null) {\n    cancelCallback(existingCallbackNode);\n  }\n\n  // \n  let newCallbackNode;\n  // \n  if (newCallbackPriority === SyncLane) {\n      //  performSyncWorkOnRoot\n      scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n    if (supportsMicrotasks) {\n     // \n     scheduleMicrotask(() => {\n       if (executionContext === NoContext) {\n         // \n         flushSyncCallbacks();\n       }\n     });\n    } else {\n      //  ImmediatePriority flushSyncCallbacks \n      scheduleCallback(ImmediateSchedulerPriority, flushSyncCallbacks);\n    }\n    //  newCallbackNode  nullperformSyncWorkOnRoot \n    newCallbackNode = null;\n  } else {\n    let schedulerPriorityLevel;\n    //  lanes \n    switch (lanesToEventPriority(nextLanes)) {\n      // ImmediateSchedulerPriority\n      case DiscreteEventPriority:\n        schedulerPriorityLevel = ImmediateSchedulerPriority;\n        break;\n      // UserBlockingSchedulerPriority\n      case ContinuousEventPriority:\n        schedulerPriorityLevel = UserBlockingSchedulerPriority;\n        break;\n      // NormalSchedulerPriority\n      case DefaultEventPriority:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n      // Idle IdleSchedulerPriority\n      case IdleEventPriority:\n        schedulerPriorityLevel = IdleSchedulerPriority;\n        break;\n      default:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n    }\n    //  performConcurrentWorkOnRootScheduler.scheduleCallback  callbackNode(newTask)\n    newCallbackNode = scheduleCallback(\n      schedulerPriorityLevel,\n      performConcurrentWorkOnRoot.bind(null, root),\n    );\n  }\n  //  callbackPriority  callbackNode \n  root.callbackPriority = newCallbackPriority;\n  root.callbackNode = newCallbackNode;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\nensureRootIsScheduled  FiberRoot \n\n\n\n *  root  callbackNodecallbackPriority  ensureRootIsScheduled \n *  scheduleSyncCallback  performSyncWorkOnRoot  syncQueue flushSyncCallbacks ImmediateSchedulerPriority  flushSyncCallbacks \n *  nextLanes  performConcurrentWorkOnRoot\n *  scheduleSyncCallbackscheduleCallback scheduleCallback  Scheduler performSyncWorkOnRoot  performConcurrentWorkOnRoot scheduleSyncCallback \n\n\n# \n\n\n#  updateContainer   \n\n updateContainer \n\n updateContainer  legacyRenderSubtreeIntoContainerReactDOMRoot.prototype.renderReactDOMRoot.prototype.unmounthydrateRootscheduleRootReactDOMRoot  ReactDOM.createRoot \n\n//  API\nlegacyRenderSubtreeIntoContainer <- ReactDOM.hydrate\n                                 <- ReactDOM.render\n                                 <- ReactDOM.unmountComponentAtNode\n\n\n1\n2\n3\n4\n\n\nupdateContainer  API  updateContainer  scheduleUpdateOnFiber  updateContainer  container  container FiberRoot\n\n\n# scheduleMicrotask  queueMicrotask\n\nflush scheduleMicrotask \n\nconst localPromise = typeof Promise === 'function' ? Promise : undefined;\nexport const scheduleTimeout: any =\n  typeof setTimeout === 'function' ? setTimeout : (undefined: any);\n\nexport const scheduleMicrotask: any =\n  typeof queueMicrotask === 'function'\n    ? queueMicrotask\n    : typeof localPromise !== 'undefined'\n    ? callback =>\n        localPromise\n          .resolve(null)\n          .then(callback)\n          .catch(handleErrorInNextTick)\n    : scheduleTimeout;\n\nfunction handleErrorInNextTick(error) {\n  // \n  setTimeout(() => {\n    throw error;\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n queueMicrotask\n\n> queueMicrotask adds the function (task) into a queue and each function is executed one by one (FIFO) after the current task has completed its work and when there is no other code waiting to be run before control of the execution context is returned to the browser's event loop. MDN\n\n queueMicrotask queueMicrotask  Promise  setTimeout \n\n\n# \n\n\n# \n\n react  |  0  0 |= \n\nconst NoContext = 0b0000;\nconst BatchedContext =  0b0001; \nconst RenderContext =  0b0010;\n\nlet executionContext = NoContext;\n\n//  RenderContainer Batch \n// \nexecutionContext |= BatchedContext; // 1\n\n//  Batch \n// 0 1  0  NoContext \n(executionContext & BatchedContext) !== NoContext; // true\n//  Render \n(executionContext & RenderContext) !== NoContext; // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# lanes \n\nReact  v16  React  expirationTime  v17  lane  expirationTime lane \n\n\n# FiberRoot  RootFiber \n\n FiberRoot  RootFiberHostRoot\n\n * FiberRoot  RootFiber FiberRoot.current = RootFiberRootFiber.stateNode = FiberRoot\n * FiberRoot  FiberTree  FiberTree \n * RootFiber  Fiber FiberTree  Fiber\n * HostRoot  HostRootFiberRootFiber  HostRoot\n\n FiberRootFiber  FiberRoot FiberTree \n\n\n# \n\n\n\n * updateContainer scheduleUpdateOnFiber \n * scheduleUpdateOnFiber FiberRoot ensureRootIsScheduled FiberRoot \n * ensureRootIsScheduled",normalizedContent:"# \n\n\n\n * \n * \n * updatecontainer\n * scheduleupdateonfiber\n * ensurerootisscheduled\n * \n   *  updatecontainer \n   * schedulemicrotask  queuemicrotask\n * \n   * \n   * lanes \n   * fiberroot  rootfiber \n * \n\n\n\n\n# \n\n\n# updatecontainer\n\n> updatecontainer \n\n\n\n// src/react/packages/react-reconciler/src/reactfiberreconciler.new.js\nexport function updatecontainer(\n  // \n  element: reactnodelist,\n  // \n  container: opaqueroot,\n): lane {\n  //  rootfiber\n  const current = container.current;\n  const eventtime = requesteventtime();\n  const lane = requestupdatelane(current);\n  //  container  context \n  const context = getcontextforsubtree();\n  // \n  const update = createupdate(eventtime, lane);\n  // \n  enqueueupdate(current, update, lane);\n  // \n  const root = scheduleupdateonfiber(current, lane, eventtime);\n\n  return lane;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n react  react  updatecontainer  api updatecontainer  update  update  react \n\n updatecontainer \n\n * \n *  scheduleupdateonfiber() \n\n\n# scheduleupdateonfiber\n\n> scheduleupdateonfiber  fibertree \n\n updatecontainer  scheduleupdateonfiber  fiber rootfiber  fiber \n\n\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nlet workinprogressrootrenderphaseupdatedlanes: lanes = nolanes;\n\nexport function mergelanes(a: lanes | lane, b: lanes | lane): lanes {\n  return a | b;\n}\n\nexport function scheduleupdateonfiber(\n  //  rootfiber\n  fiber: fiber,\n  // \n  lane: lane,\n  eventtime: number,\n): fiberroot | null {\n  // \n  checkfornestedupdates();\n  //  fiber  lanesrootfiberroot = fiber.statenode updatecontainer  fiber  rootfiber\n  const root = markupdatelanefromfibertoroot(fiber, lane);\n\n  //  root root.pendinglanes |= lane\n  markrootupdated(root, lane, eventtime);\n  //  render  root  fiberroot lane render  lanes\n  if (\n    (executioncontext & rendercontext) !== nolanes &&\n    root === workinprogressroot\n  ) {\n    //  lane  workinprogressrootrenderphaseupdatedlanes render  rootfiber \n    workinprogressrootrenderphaseupdatedlanes = mergelanes(\n      workinprogressrootrenderphaseupdatedlanes,\n      lane,\n    );\n  } else {\n    //  fiberroot \n    ensurerootisscheduled(root, eventtime);\n  }\n  return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n fiber ensurerootisscheduled  rootroot  fiberroot fiber fiberroot  fibertree fiberroot  rootfiber \n\nmarkupdatelanefromfibertoroot  fiberroot  rootfiberroot \n\n\n\n *  fiber  lanes fiberroot\n *  ensurerootisscheduled fiberroot \n\n\n# ensurerootisscheduled\n\n> ensurerootisscheduled \n\n scheduleupdateonfiber  ensurerootisscheduled fiber  fiberroot  fiberroot \n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nfunction ensurerootisscheduled(root: fiberroot, currenttime: number) {\n  // \n  const existingcallbacknode = root.callbacknode;\n\n  //  lanes\n  const nextlanes = getnextlanes(\n    root,\n    root === workinprogressroot ? workinprogressrootrenderlanes : nolanes,\n  );\n  //  lanes\n  if (nextlanes === nolanes) {\n    root.callbacknode = null;\n    root.callbackpriority = nolane;\n    return;\n  }\n\n  //  lanes  lane \n  const newcallbackpriority = gethighestprioritylane(nextlanes);\n\n  // \n  if (existingcallbacknode != null) {\n    cancelcallback(existingcallbacknode);\n  }\n\n  // \n  let newcallbacknode;\n  // \n  if (newcallbackpriority === synclane) {\n      //  performsyncworkonroot\n      schedulesynccallback(performsyncworkonroot.bind(null, root));\n    if (supportsmicrotasks) {\n     // \n     schedulemicrotask(() => {\n       if (executioncontext === nocontext) {\n         // \n         flushsynccallbacks();\n       }\n     });\n    } else {\n      //  immediatepriority flushsynccallbacks \n      schedulecallback(immediateschedulerpriority, flushsynccallbacks);\n    }\n    //  newcallbacknode  nullperformsyncworkonroot \n    newcallbacknode = null;\n  } else {\n    let schedulerprioritylevel;\n    //  lanes \n    switch (lanestoeventpriority(nextlanes)) {\n      // immediateschedulerpriority\n      case discreteeventpriority:\n        schedulerprioritylevel = immediateschedulerpriority;\n        break;\n      // userblockingschedulerpriority\n      case continuouseventpriority:\n        schedulerprioritylevel = userblockingschedulerpriority;\n        break;\n      // normalschedulerpriority\n      case defaulteventpriority:\n        schedulerprioritylevel = normalschedulerpriority;\n        break;\n      // idle idleschedulerpriority\n      case idleeventpriority:\n        schedulerprioritylevel = idleschedulerpriority;\n        break;\n      default:\n        schedulerprioritylevel = normalschedulerpriority;\n        break;\n    }\n    //  performconcurrentworkonrootscheduler.schedulecallback  callbacknode(newtask)\n    newcallbacknode = schedulecallback(\n      schedulerprioritylevel,\n      performconcurrentworkonroot.bind(null, root),\n    );\n  }\n  //  callbackpriority  callbacknode \n  root.callbackpriority = newcallbackpriority;\n  root.callbacknode = newcallbacknode;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\nensurerootisscheduled  fiberroot \n\n\n\n *  root  callbacknodecallbackpriority  ensurerootisscheduled \n *  schedulesynccallback  performsyncworkonroot  syncqueue flushsynccallbacks immediateschedulerpriority  flushsynccallbacks \n *  nextlanes  performconcurrentworkonroot\n *  schedulesynccallbackschedulecallback schedulecallback  scheduler performsyncworkonroot  performconcurrentworkonroot schedulesynccallback \n\n\n# \n\n\n#  updatecontainer   \n\n updatecontainer \n\n updatecontainer  legacyrendersubtreeintocontainerreactdomroot.prototype.renderreactdomroot.prototype.unmounthydraterootschedulerootreactdomroot  reactdom.createroot \n\n//  api\nlegacyrendersubtreeintocontainer <- reactdom.hydrate\n                                 <- reactdom.render\n                                 <- reactdom.unmountcomponentatnode\n\n\n1\n2\n3\n4\n\n\nupdatecontainer  api  updatecontainer  scheduleupdateonfiber  updatecontainer  container  container fiberroot\n\n\n# schedulemicrotask  queuemicrotask\n\nflush schedulemicrotask \n\nconst localpromise = typeof promise === 'function' ? promise : undefined;\nexport const scheduletimeout: any =\n  typeof settimeout === 'function' ? settimeout : (undefined: any);\n\nexport const schedulemicrotask: any =\n  typeof queuemicrotask === 'function'\n    ? queuemicrotask\n    : typeof localpromise !== 'undefined'\n    ? callback =>\n        localpromise\n          .resolve(null)\n          .then(callback)\n          .catch(handleerrorinnexttick)\n    : scheduletimeout;\n\nfunction handleerrorinnexttick(error) {\n  // \n  settimeout(() => {\n    throw error;\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n queuemicrotask\n\n> queuemicrotask adds the function (task) into a queue and each function is executed one by one (fifo) after the current task has completed its work and when there is no other code waiting to be run before control of the execution context is returned to the browser's event loop. mdn\n\n queuemicrotask queuemicrotask  promise  settimeout \n\n\n# \n\n\n# \n\n react  |  0  0 |= \n\nconst nocontext = 0b0000;\nconst batchedcontext =  0b0001; \nconst rendercontext =  0b0010;\n\nlet executioncontext = nocontext;\n\n//  rendercontainer batch \n// \nexecutioncontext |= batchedcontext; // 1\n\n//  batch \n// 0 1  0  nocontext \n(executioncontext & batchedcontext) !== nocontext; // true\n//  render \n(executioncontext & rendercontext) !== nocontext; // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# lanes \n\nreact  v16  react  expirationtime  v17  lane  expirationtime lane \n\n\n# fiberroot  rootfiber \n\n fiberroot  rootfiberhostroot\n\n * fiberroot  rootfiber fiberroot.current = rootfiberrootfiber.statenode = fiberroot\n * fiberroot  fibertree  fibertree \n * rootfiber  fiber fibertree  fiber\n * hostroot  hostrootfiberrootfiber  hostroot\n\n fiberrootfiber  fiberroot fibertree \n\n\n# \n\n\n\n * updatecontainer scheduleupdateonfiber \n * scheduleupdateonfiber fiberroot ensurerootisscheduled fiberroot \n * ensurerootisscheduled",charsets:{cjk:!0},lastUpdated:"2022/07/22, 14:56:40",lastUpdatedTimestamp:1658473e6},{title:" React ",frontmatter:{title:" React ",date:"2022-08-23T09:55:52.000Z",permalink:"/react/tour/dr-1/",categories:["react","React"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/900.react-docs-reading-1.html",relativePath:"10.react/90.React/900.react-docs-reading-1.md",key:"v-321a8dff",path:"/react/tour/dr-1/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"React  MVC ",slug:"react--mvc-",normalizedTitle:"react  mvc ",charIndex:261},{level:3,title:"React  MVC ",slug:"react--mvc-",normalizedTitle:"react  mvc ",charIndex:528},{level:3,title:"React  MVVM ",slug:"react--mvvm-",normalizedTitle:"react  mvvm ",charIndex:659},{level:3,title:"React ",slug:"react-",normalizedTitle:"react ",charIndex:1569},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:1613},{level:3,title:"",slug:"-",normalizedTitle:" ",charIndex:3231},{level:4,title:"",slug:"",normalizedTitle:"",charIndex:3283},{level:4,title:"",slug:"",normalizedTitle:"",charIndex:5068},{level:2,title:"React  JSX",slug:"react--jsx",normalizedTitle:"react  jsx",charIndex:6553},{level:3,title:" UI",slug:"-ui",normalizedTitle:" ui",charIndex:6574},{level:3,title:" UI ",slug:"-ui-",normalizedTitle:" ui ",charIndex:7030},{level:2,title:"Inline Functions",slug:"inline-functions",normalizedTitle:"inline functions",charIndex:7759},{level:2,title:"React ",slug:"react-",normalizedTitle:"react ",charIndex:10101},{level:2,title:"JSX  XSS ",slug:"jsx--xss-",normalizedTitle:"jsx  xss ",charIndex:11076},{level:2,title:"ReactElement  DOM Element",slug:"reactelement--dom-element",normalizedTitle:"reactelement  dom element",charIndex:12229},{level:2,title:"React ",slug:"react-",normalizedTitle:"react ",charIndex:12763},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:9792}],readingTime:{text:"6 min read",minutes:5.53,time:331800,words:1106},headersStr:" React  MVC  React  MVC  React  MVVM  React      React  JSX  UI  UI  Inline Functions React  JSX  XSS  ReactElement  DOM Element React  ",content:'# \n\n React  \n\n React \n\n\n\n\n# React  MVC \n\n\n\nReact  MVC \n\nReact   UI \n\nReact is a library for building composable user interfaces. It encourages the creation of reusable UI components which present data that changes over time.\n\n\n\n\n# React  MVC \n\nReact  Controller  MVC React MVC  Controller \n\n\n# React  MVVM \n\nMVVM  MVC  VM VM  ViewModel View  Model  MVVM  ViewModel  ViewModel \n\n ViewModel  ViewModel  Vue2  Object. defineProperty vue3  Proxy API  API  API  Proxy Vue  MVVM  Model  ORM Model      XHR  LocalStorage/indexedDB/Session/Cookie  Vuex  ViewModel  Model  ViewModel \n\nReact  MVVM  React \n\n\n# React \n\n React  React \n\nui = render (data)\n\nReact  React      view=f(t,data)  video=f(t,yuvData)  yuvData React \n\n render React \n\n render  data  ui \n\n\n# \n\n React  JSX \n\nReact Context  setState  React React IoC React  fiber  lazyComponentsuspense  React \n\n   JSX  JavaScript Syntax Extension  React   \n\n\n#  \n\n# \n\n  \n\n\n\n Vue  SFC  SFC  ViewModel  Vue  DIFF  DIFF  DIFF SFC  Vue Vue  DIFF \n\n Vue  SFC React React    Component(props, context)  React  React \n\n * Props&State : props/state\n * Handler : \n * Effect : \n * Render : \n * Hook : Hook  State    Effect  Handler  Hook  Hook  Mixin  Effect  Mixin  Hook \n\n\n\n Props&State  Handler  useCallback  Render  babel  ReactElement  inline handler  Effect  Hook \n\n React React JavaScript React ......\n\n useEffect  useLayoutEffect  React \n\n  \n\n * React updateQueue EffectTag \n * \n *        \n * ......\n\n# \n\n  \n\n\n\n  ......  ...... \n\n   React \n\nReact \n\n * onclickonfocusoninput\n *  localStorage  DOM\n\n React   \n\n  \n\n *  React  FiberRoot  \n *  React  useEffect  useLayoutEffect  Commit  layout  useLayoutEffect  useEffect \n\n   \n\n\n# React  JSX\n\n\n#  UI\n\n\n\nReact  UI  React  :\n\n * JavaScript  \n *  React \n *  JavaScript  XSS \n\n\n\n React  HTML  SFC Vue  template  HTML React  JSX  HTML  JS\n\n\n#  UI \n\n\n\n * React  UI  UI  UI UI \n * React  UI   \n\n JSX\n\n UI  SFC  template  script  style  React  SFC    \n\n React    DOM  DOM  VDOM JSX  ReactElement  DOM  ReactElement  VDOM  VDOM VDOM  DIFF  ReactElement  DIFF  DIFF JSX    VDOM  DOM  DOM  VDOM \n\n   Inline Functions JSX  React  Inline Functions \n\n\n# Inline Functions\n\n Inline Functions :\n\nfunction Component() {\n  const handleClick = () => {handleThis();}\n  return <div onClick={handleClick}></div>\n}\n\n\n1\n2\n3\n4\n\n\n\n\nfunction Component() {\n  const handleClick = () => {\n    handleThis();\n  };\n\n  return /*#__PURE__*/ React.createElement("div", {\n    onClick: handleClick\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n Inline Functions \n\nfunction Component() {\n  return <div onClick={() => {handleThis();}}></div>\n}\n\n\n1\n2\n3\n\n\n\n\nfunction Component() {\n  return /*#__PURE__*/ React.createElement("div", {\n    onClick: () => {\n      handleThis();\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n ReactElement  Inline Functions \n\n *  GCReact  GC\n *  Callback  Inline Functions  Memo \n\n Function Ref ( Refs:  Refs)  Inline Functions  Ref  DOM  forwardRef \n\n Inline Functions  Eslint  Inline Functions eslint-plugin-react/jsx-no-bind\n\n * FC  class  closurelexical environment  Context \n\nMDN \n\n * React Hook  \n * \n\nFC  Inline Functions \n\n useCallback  useCallback  useMemo anti-pattern\n\n Inline Functions tradeOff React \n\n\n\n * How To Use Inline Functions In React Applications Efficiently\n * javascript - Need to understand inline function call with react FC - Stack Overflow\n * React, Inline Functions, and Performance | by Ryan Florence | Medium\n * When to useMemo and useCallback\n * Dont over-engineer  Page Fault Blog\n\n\n# React \n\n\n\n *  render    render   render   DOM \n * render  DOM    DOM  \n *  React  root.render ()\n\n: \n\n * render   Render  ReactDOM.render  ReactDOM.createRoot.render   renderRootSync  renderRootConcurrent  HOST  Render   \n *   FiberTree   \n *   EffectTag List  EffectTag mutation DOM \n *  render   workInProgress FiberTree  current FiberTree  DIFF \n *  DOM   DIFF  EffectTag List \n *  DOM VDOM\n\n\n# JSX  XSS \n\n\n\nReact DOM \n\n JSX EscapeJSX \n\n JSX  HTML  dangerouslySetInnerHTML React  jam3/no-sanitizer-with-danger theodo/RisXSS: RisXSS  dangerouslySetInnerHTML \n\n\n\n"The prop name dangerouslySetInnerHTML is intentionally chosen to be frightening. ..."\n\n"After fully understanding the security ramifications and properly sanitizing the data..."\n\n sanitizer \n\n * cure53/DOMPurify: DOMPurify - a DOM-only, super-fast, uber-tolerant XSS sanitizer for HTML, MathML and SVG. DOMPurify works with a secure default, but offers a lot of configurability and hooks. Demo:;\n\n * leizongmin/js-xss: Sanitize untrusted HTML (to prevent XSS) with a configuration specified by a Whitelist;\n\n * YahooArchive/xss-filters: Secure XSS Filters.;\n\n * Lodash Documentation - escape\n\n * milesj/interweave:  React library to safely render HTML, filter attributes, autowrap text with matchers, render emoji characters, and much more.\n\n * javascript - React.js: Set innerHTML vs dangerouslySetInnerHTML - Stack Overflow\n\n\n# ReactElement  DOM Element\n\n\n\n *  React \n * \n *  DOM React \n * React DOM  DOM  React \n\nJSX  ReactElement JavaScript  DOM  ReactElement  VDOM DIFF \n\nVDOM  VDOM  DIFF VDOM  HOST \n\nReactElement  DOM    ReactElement  DOM  FiberTree \n\n\n# React \n\n\n\nReact  UI\n\n  \n\nReactElement ReactElement \n\n React          ReactElement \n\nReactElement  React ReactElement    \n\nReactElement  \n\n   ReactElement \n\nReact  React  Batch \n\n React ReactElement  React React  JSX  FiberTree \n\n ReactElement  ReactElementTree React  React  Fiber React  Fiber  DFS  child FiberTree  parent  sibling \n\nReact  ReactElement  Fiber React  FiberTree  root.render  DIFF \n\n FiberTree FiberTree  FiberTree    DIFF        DOM  Render  Render \n\n Commit React  mutation    fiber  DOM  FiberTree   DOM   \n\n   React  ReactElement    React    \n\n\n# \n\n *  React?  React Blog\n * JSX',normalizedContent:'# \n\n react  \n\n react \n\n\n\n\n# react  mvc \n\n\n\nreact  mvc \n\nreact   ui \n\nreact is a library for building composable user interfaces. it encourages the creation of reusable ui components which present data that changes over time.\n\n\n\n\n# react  mvc \n\nreact  controller  mvc react mvc  controller \n\n\n# react  mvvm \n\nmvvm  mvc  vm vm  viewmodel view  model  mvvm  viewmodel  viewmodel \n\n viewmodel  viewmodel  vue2  object. defineproperty vue3  proxy api  api  api  proxy vue  mvvm  model  orm model      xhr  localstorage/indexeddb/session/cookie  vuex  viewmodel  model  viewmodel \n\nreact  mvvm  react \n\n\n# react \n\n react  react \n\nui = render (data)\n\nreact  react      view=f(t,data)  video=f(t,yuvdata)  yuvdata react \n\n render react \n\n render  data  ui \n\n\n# \n\n react  jsx \n\nreact context  setstate  react react ioc react  fiber  lazycomponentsuspense  react \n\n   jsx  javascript syntax extension  react   \n\n\n#  \n\n# \n\n  \n\n\n\n vue  sfc  sfc  viewmodel  vue  diff  diff  diff sfc  vue vue  diff \n\n vue  sfc react react    component(props, context)  react  react \n\n * props&state : props/state\n * handler : \n * effect : \n * render : \n * hook : hook  state    effect  handler  hook  hook  mixin  effect  mixin  hook \n\n\n\n props&state  handler  usecallback  render  babel  reactelement  inline handler  effect  hook \n\n react react javascript react ......\n\n useeffect  uselayouteffect  react \n\n  \n\n * react updatequeue effecttag \n * \n *        \n * ......\n\n# \n\n  \n\n\n\n  ......  ...... \n\n   react \n\nreact \n\n * onclickonfocusoninput\n *  localstorage  dom\n\n react   \n\n  \n\n *  react  fiberroot  \n *  react  useeffect  uselayouteffect  commit  layout  uselayouteffect  useeffect \n\n   \n\n\n# react  jsx\n\n\n#  ui\n\n\n\nreact  ui  react  :\n\n * javascript  \n *  react \n *  javascript  xss \n\n\n\n react  html  sfc vue  template  html react  jsx  html  js\n\n\n#  ui \n\n\n\n * react  ui  ui  ui ui \n * react  ui   \n\n jsx\n\n ui  sfc  template  script  style  react  sfc    \n\n react    dom  dom  vdom jsx  reactelement  dom  reactelement  vdom  vdom vdom  diff  reactelement  diff  diff jsx    vdom  dom  dom  vdom \n\n   inline functions jsx  react  inline functions \n\n\n# inline functions\n\n inline functions :\n\nfunction component() {\n  const handleclick = () => {handlethis();}\n  return <div onclick={handleclick}></div>\n}\n\n\n1\n2\n3\n4\n\n\n\n\nfunction component() {\n  const handleclick = () => {\n    handlethis();\n  };\n\n  return /*#__pure__*/ react.createelement("div", {\n    onclick: handleclick\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n inline functions \n\nfunction component() {\n  return <div onclick={() => {handlethis();}}></div>\n}\n\n\n1\n2\n3\n\n\n\n\nfunction component() {\n  return /*#__pure__*/ react.createelement("div", {\n    onclick: () => {\n      handlethis();\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n reactelement  inline functions \n\n *  gcreact  gc\n *  callback  inline functions  memo \n\n function ref ( refs:  refs)  inline functions  ref  dom  forwardref \n\n inline functions  eslint  inline functions eslint-plugin-react/jsx-no-bind\n\n * fc  class  closurelexical environment  context \n\nmdn \n\n * react hook  \n * \n\nfc  inline functions \n\n usecallback  usecallback  usememo anti-pattern\n\n inline functions tradeoff react \n\n\n\n * how to use inline functions in react applications efficiently\n * javascript - need to understand inline function call with react fc - stack overflow\n * react, inline functions, and performance | by ryan florence | medium\n * when to usememo and usecallback\n * dont over-engineer  page fault blog\n\n\n# react \n\n\n\n *  render    render   render   dom \n * render  dom    dom  \n *  react  root.render ()\n\n: \n\n * render   render  reactdom.render  reactdom.createroot.render   renderrootsync  renderrootconcurrent  host  render   \n *   fibertree   \n *   effecttag list  effecttag mutation dom \n *  render   workinprogress fibertree  current fibertree  diff \n *  dom   diff  effecttag list \n *  dom vdom\n\n\n# jsx  xss \n\n\n\nreact dom \n\n jsx escapejsx \n\n jsx  html  dangerouslysetinnerhtml react  jam3/no-sanitizer-with-danger theodo/risxss: risxss  dangerouslysetinnerhtml \n\n\n\n"the prop name dangerouslysetinnerhtml is intentionally chosen to be frightening. ..."\n\n"after fully understanding the security ramifications and properly sanitizing the data..."\n\n sanitizer \n\n * cure53/dompurify: dompurify - a dom-only, super-fast, uber-tolerant xss sanitizer for html, mathml and svg. dompurify works with a secure default, but offers a lot of configurability and hooks. demo:;\n\n * leizongmin/js-xss: sanitize untrusted html (to prevent xss) with a configuration specified by a whitelist;\n\n * yahooarchive/xss-filters: secure xss filters.;\n\n * lodash documentation - escape\n\n * milesj/interweave:  react library to safely render html, filter attributes, autowrap text with matchers, render emoji characters, and much more.\n\n * javascript - react.js: set innerhtml vs dangerouslysetinnerhtml - stack overflow\n\n\n# reactelement  dom element\n\n\n\n *  react \n * \n *  dom react \n * react dom  dom  react \n\njsx  reactelement javascript  dom  reactelement  vdom diff \n\nvdom  vdom  diff vdom  host \n\nreactelement  dom    reactelement  dom  fibertree \n\n\n# react \n\n\n\nreact  ui\n\n  \n\nreactelement reactelement \n\n react          reactelement \n\nreactelement  react reactelement    \n\nreactelement  \n\n   reactelement \n\nreact  react  batch \n\n react reactelement  react react  jsx  fibertree \n\n reactelement  reactelementtree react  react  fiber react  fiber  dfs  child fibertree  parent  sibling \n\nreact  reactelement  fiber react  fibertree  root.render  diff \n\n fibertree fibertree  fibertree    diff        dom  render  render \n\n commit react  mutation    fiber  dom  fibertree   dom   \n\n   react  reactelement    react    \n\n\n# \n\n *  react?  react blog\n * jsx',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:" React ",frontmatter:{title:" React ",date:"2022-08-23T09:55:52.000Z",permalink:"/react/tour/dr-2/",categories:["react","React"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/910.react-docs-reading-2.html",relativePath:"10.react/90.React/910.react-docs-reading-2.md",key:"v-2e216f3f",path:"/react/tour/dr-2/",headers:[{level:2,title:"Props  State ",slug:"props--state-",normalizedTitle:"props  state ",charIndex:2},{level:3,title:"Props ",slug:"props-",normalizedTitle:"props ",charIndex:2},{level:3,title:"Props  State",slug:"props--state",normalizedTitle:"props  state",charIndex:1630},{level:3,title:" !== DOM",slug:"-dom",normalizedTitle:"==  dom ",charIndex:2085},{level:3,title:"State ",slug:"state-",normalizedTitle:"state ",charIndex:14},{level:3,title:" State",slug:"-state",normalizedTitle:" state",charIndex:3414},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:4068},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:4521},{level:3,title:"",slug:"-",normalizedTitle:" ",charIndex:4896},{level:3,title:"React  Props  State ",slug:"react--props--state-",normalizedTitle:"react  props  state ",charIndex:5527},{level:3,title:"State ",slug:"state-",normalizedTitle:"state ",charIndex:5844},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:5959},{level:2,title:"React  Rxjs",slug:"react--rxjs",normalizedTitle:"react  rxjs",charIndex:6262},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:132}],readingTime:{text:"4 min read",minutes:3.145,time:188700,words:629},headersStr:"Props  State  Props  Props  State  !== DOM State   State    React  Props  State  State   React  Rxjs ",content:'# Props  State \n\n\n# Props \n\n\n\n *  class  props\n *  React  props \n\nProps \n\n   Props \n\nWIKI: \n\n\n\n *  I/O \n *  \n\n\n\n * \n * \n\n\n\n\n\n *  memo \n\n// reconcileSingleElement: src/react/packages/react-reconciler/src/ReactChildFiber.new.js\n// \nconst existing = useFiber(child, element.props);\n// \nconst created = createFiberFromElement(element, returnFiber.mode, lanes);\n\n\n1\n2\n3\n4\n5\n\n\nReact  JSX  Props Props React  Props  PureComponent  memo  bug\n\n memo  React \n\n * \n\n useEffect  useLayoutEffect \n\n\n\n * \n * javascript - Does React make any guarantees that the `props` object reference stays stable? - Stack Overflow\n * How to use React.memo() to improve performance\n * RFClarification: why is `setState` asynchronous?  Issue #11527  facebook/react\n\n\n# Props  State\n\nProps  props  context \n\nProps  State  React  Props React  Props  State  Props  Props  State React React  Props  Props  React  React \n\n\n# ==  DOM \n\n   React  DOM    React    DFS  DOM  DOM \n\n\n# State \n\n Vue React  React React        React  Batch    flush  Effect \n\n\n\n * \n * \n\n React  Vue \n\nVue3 \n\n * ViewModal ref  reactive   API  track \n *  trigger  DOM \n\nReact \n\n *  Batch React  setState  React  Fiber \n *  Render React \n\nReact  Vue  DOM \n\n\n\nReact  Reactive React  React  ReactiveReact  pull  push \n\n * How React isn\'t reactive, and why you shouldn\'t care - DEV Community \n * Design Principles  React\n * Core Concepts | React-RxJS\n\n\n#  State\n\n\n\n setState () \n\n *  State\n * State \n * State \n\n State \n\nReact  State  setState State React  State  State  State Props  Props  React \n\nState   State State \n\n\n\n * reactjs - Why React say "State Updates May Be Asynchronous", "maybe" but not "must"? - Stack Overflow\n\n\n# \n\nReact \n\n\n\n *  class  state  state  props      state  state  UI   \n *  props  state \n *  React \n\n\n# \n\n React  Props  State  Flutter Flutter  React React React \n\n React React \n\n\n#  \n\n  Props Props  React  Props   Props  React  State State  Props State \n\n * State  Props  \n * State  React  \n\n   State  Props\n\n *  Props  State  Props  Props State  Props  React  Props Props  Props \n * State  React State  StateReact \n\n\n# React  Props  State \n\n Props  State  React \n\n * Props React  Props \n * State React  State \n\n     push  pull \n\nState  React Props  React  Props  State \n\n\n# State \n\nState  State  Context  context.Provider \n\n\n# \n\n\n\n *  React  false  preventDefault\n * e React  W3C React \n\nReact  DOM  DOM  DOM  addEventListener React  JSX  Props  DOM \n\n\n# React  Rxjs\n\n\n\n * Rxjs + React  angular  5  - \n * Reactive Programming with React and RxJs | Better Programming\n\n\n\n * A Visual Guide to React Rendering - Props | Alex Sidorenko\n * reactjs - React: Parent component re-renders all children, even those that haven\'t changed on state change - Stack Overflow\n * State &   React\n\n\n# ',normalizedContent:'# props  state \n\n\n# props \n\n\n\n *  class  props\n *  react  props \n\nprops \n\n   props \n\nwiki: \n\n\n\n *  i/o \n *  \n\n\n\n * \n * \n\n\n\n\n\n *  memo \n\n// reconcilesingleelement: src/react/packages/react-reconciler/src/reactchildfiber.new.js\n// \nconst existing = usefiber(child, element.props);\n// \nconst created = createfiberfromelement(element, returnfiber.mode, lanes);\n\n\n1\n2\n3\n4\n5\n\n\nreact  jsx  props props react  props  purecomponent  memo  bug\n\n memo  react \n\n * \n\n useeffect  uselayouteffect \n\n\n\n * \n * javascript - does react make any guarantees that the `props` object reference stays stable? - stack overflow\n * how to use react.memo() to improve performance\n * rfclarification: why is `setstate` asynchronous?  issue #11527  facebook/react\n\n\n# props  state\n\nprops  props  context \n\nprops  state  react  props react  props  state  props  props  state react react  props  props  react  react \n\n\n# ==  dom \n\n   react  dom    react    dfs  dom  dom \n\n\n# state \n\n vue react  react react        react  batch    flush  effect \n\n\n\n * \n * \n\n react  vue \n\nvue3 \n\n * viewmodal ref  reactive   api  track \n *  trigger  dom \n\nreact \n\n *  batch react  setstate  react  fiber \n *  render react \n\nreact  vue  dom \n\n\n\nreact  reactive react  react  reactivereact  pull  push \n\n * how react isn\'t reactive, and why you shouldn\'t care - dev community \n * design principles  react\n * core concepts | react-rxjs\n\n\n#  state\n\n\n\n setstate () \n\n *  state\n * state \n * state \n\n state \n\nreact  state  setstate state react  state  state  state props  props  react \n\nstate   state state \n\n\n\n * reactjs - why react say "state updates may be asynchronous", "maybe" but not "must"? - stack overflow\n\n\n# \n\nreact \n\n\n\n *  class  state  state  props      state  state  ui   \n *  props  state \n *  react \n\n\n# \n\n react  props  state  flutter flutter  react react react \n\n react react \n\n\n#  \n\n  props props  react  props   props  react  state state  props state \n\n * state  props  \n * state  react  \n\n   state  props\n\n *  props  state  props  props state  props  react  props props  props \n * state  react state  statereact \n\n\n# react  props  state \n\n props  state  react \n\n * props react  props \n * state react  state \n\n     push  pull \n\nstate  react props  react  props  state \n\n\n# state \n\nstate  state  context  context.provider \n\n\n# \n\n\n\n *  react  false  preventdefault\n * e react  w3c react \n\nreact  dom  dom  dom  addeventlistener react  jsx  props  dom \n\n\n# react  rxjs\n\n\n\n * rxjs + react  angular  5  - \n * reactive programming with react and rxjs | better programming\n\n\n\n * a visual guide to react rendering - props | alex sidorenko\n * reactjs - react: parent component re-renders all children, even those that haven\'t changed on state change - stack overflow\n * state &   react\n\n\n# ',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/index/",categories:["vue3"],tags:[null]},regularPath:"/20.vue3/0.index.html",relativePath:"20.vue3/0.index.md",key:"v-1d06307d",path:"/vue3/index/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:273},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:395},{level:2,title:"TODO ",slug:"todo-",normalizedTitle:"todo ",charIndex:436},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:448}],readingTime:{text:"1 min read",minutes:.415,time:24900,words:83},headersStr:"   TODO  ",content:"# \n\n\n\n          \nvue3      v3.1.4\nIDE         VScode\n       VuePress\n Repo     Repo\n Repo   jonsam-ng/fancy-front-end\n        source.jonsam.site\n        reactivityruntime-coreruntime-dom\n        \n\n\n# \n\n 1.  vue \n\ngit clone https://github.com/jonsam-ng/vue-next.git\nyarn \n\n\n1\n2\n\n 2. \n\n\n# \n\n * vue3js.cn\n * vue3 \n\n\n# TODO \n\n\n# ",normalizedContent:"# \n\n\n\n          \nvue3      v3.1.4\nide         vscode\n       vuepress\n repo     repo\n repo   jonsam-ng/fancy-front-end\n        source.jonsam.site\n        reactivityruntime-coreruntime-dom\n        \n\n\n# \n\n 1.  vue \n\ngit clone https://github.com/jonsam-ng/vue-next.git\nyarn \n\n\n1\n2\n\n 2. \n\n\n# \n\n * vue3js.cn\n * vue3 \n\n\n# todo \n\n\n# ",charsets:{cjk:!0},lastUpdated:"2022/07/13, 18:32:13",lastUpdatedTimestamp:1657708333e3},{title:"plan ",frontmatter:{title:"plan ",date:"2022-04-16T15:41:35.000Z",permalink:"/vue3/plan/",categories:["vue3"],tags:[null]},regularPath:"/20.vue3/1.plan.html",relativePath:"20.vue3/1.plan.md",key:"v-cecea10e",path:"/vue3/plan/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/16, 15:48:02",lastUpdatedTimestamp:1650095282e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/basic/index/",categories:["vue3","basic"],tags:[null]},regularPath:"/20.vue3/10.%E5%9F%BA%E7%A1%80/0.index.html",relativePath:"20.vue3/10./0.index.md",key:"v-620539aa",path:"/vue3/basic/index/",readingTime:{text:"0 min read",minutes:0,time:0,words:0},headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/reactivity/index/",categories:["vue3","reactivity"],tags:[null]},regularPath:"/20.vue3/20.reactivity/0.index.html",relativePath:"20.vue3/20.reactivity/0.index.md",key:"v-5d322c1d",path:"/vue3/reactivity/index/",headers:[{level:2,title:"Reactivity Api",slug:"reactivity-api",normalizedTitle:"reactivity api",charIndex:120},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2922},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:3325}],readingTime:{text:"3 min read",minutes:2.345,time:140700.00000000003,words:469},headersStr:"Reactivity Api  ",content:"reactivity  vue  reactivity  refreactivecomputedeffect  operations 5 \n\n\n# Reactivity Api\n\nexport {\n  ref, // Takes an inner value and returns a reactive and mutable ref object.The ref object has a single property .value that points to the inner value.\n  shallowRef, // Creates a ref that tracks its own .value mutation but doesn't make its value reactive.\n  isRef, // Checks if a value is a ref object.\n  toRef, // Can be used to create a ref for a property on a source reactive object.\n  toRefs, // Converts a reactive object to a plain object where each property of the resulting object is a ref pointing to the corresponding property of the original object.\n  unref, // Returns the inner value if the argument is a ref, otherwise return the argument itself.\n  proxyRefs,\n  customRef, // Creates a customized ref with explicit control over its dependency tracking and updates triggering. It expects a factory function, which receives track and trigger functions as arguments and should return an object with get and set.\n  triggerRef, // Execute any effects tied to a shallowRef manually.\n  Ref,\n  ToRefs,\n  UnwrapRef,\n  ShallowUnwrapRef,\n  RefUnwrapBailTypes\n} from './ref'\nexport {\n  reactive, // Returns a reactive copy of the object.\n  readonly, // Takes an object (reactive or plain) or a ref and returns a readonly proxy to the original.\n  isReactive, // Checks if an object is a reactive proxy created by reactive.\n  isReadonly, // Checks if an object is a readonly proxy created by readonly.\n  isProxy, // Checks if an object is a proxy created by reactive or readonly.\n  shallowReactive, // Creates a reactive proxy that tracks reactivity of its own properties but does not perform deep reactive conversion of nested objects (exposes raw values).\n  shallowReadonly, // Creates a proxy that makes its own properties readonly, but does not perform deep readonly conversion of nested objects (exposes raw values).\n  markRaw, // Marks an object so that it will never be converted to a proxy.\n  toRaw, // Returns the raw, original object of a reactive or readonly proxy.\n  ReactiveFlags,\n  DeepReadonly,\n  UnwrapNestedRefs\n} from './reactive'\nexport {\n  computed, // Takes a getter function and returns an immutable reactive ref object for the returned value from the getter.\n  ComputedRef,\n  WritableComputedRef,\n  WritableComputedOptions,\n  ComputedGetter,\n  ComputedSetter\n} from './computed'\nexport {\n  effect,\n  stop,\n  trigger,\n  track,\n  enableTracking,\n  pauseTracking,\n  resetTracking,\n  ITERATE_KEY,\n  ReactiveEffect,\n  ReactiveEffectOptions,\n  DebuggerEvent\n} from './effect'\nexport { TrackOpTypes, TriggerOpTypes } from './operations'\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n Reactivity Apieffect  runtime-core \n\n\n# \n\nreactivity \n\npackages/reactivity/src\n baseHandlers.ts // COMMON type: array/object proxy handlers.\n collectionHandlers.ts // COLLECTION type: map/set/weakSet/weakMap proxy handlers.\n computed.ts // \n effect.ts // \n index.ts //  API\n operations.ts // operations \n reactive.ts // reactive  API\n ref.ts // ref  API\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# \n\n * vue3 docs: Reactivity API\n * vue3  API",normalizedContent:"reactivity  vue  reactivity  refreactivecomputedeffect  operations 5 \n\n\n# reactivity api\n\nexport {\n  ref, // takes an inner value and returns a reactive and mutable ref object.the ref object has a single property .value that points to the inner value.\n  shallowref, // creates a ref that tracks its own .value mutation but doesn't make its value reactive.\n  isref, // checks if a value is a ref object.\n  toref, // can be used to create a ref for a property on a source reactive object.\n  torefs, // converts a reactive object to a plain object where each property of the resulting object is a ref pointing to the corresponding property of the original object.\n  unref, // returns the inner value if the argument is a ref, otherwise return the argument itself.\n  proxyrefs,\n  customref, // creates a customized ref with explicit control over its dependency tracking and updates triggering. it expects a factory function, which receives track and trigger functions as arguments and should return an object with get and set.\n  triggerref, // execute any effects tied to a shallowref manually.\n  ref,\n  torefs,\n  unwrapref,\n  shallowunwrapref,\n  refunwrapbailtypes\n} from './ref'\nexport {\n  reactive, // returns a reactive copy of the object.\n  readonly, // takes an object (reactive or plain) or a ref and returns a readonly proxy to the original.\n  isreactive, // checks if an object is a reactive proxy created by reactive.\n  isreadonly, // checks if an object is a readonly proxy created by readonly.\n  isproxy, // checks if an object is a proxy created by reactive or readonly.\n  shallowreactive, // creates a reactive proxy that tracks reactivity of its own properties but does not perform deep reactive conversion of nested objects (exposes raw values).\n  shallowreadonly, // creates a proxy that makes its own properties readonly, but does not perform deep readonly conversion of nested objects (exposes raw values).\n  markraw, // marks an object so that it will never be converted to a proxy.\n  toraw, // returns the raw, original object of a reactive or readonly proxy.\n  reactiveflags,\n  deepreadonly,\n  unwrapnestedrefs\n} from './reactive'\nexport {\n  computed, // takes a getter function and returns an immutable reactive ref object for the returned value from the getter.\n  computedref,\n  writablecomputedref,\n  writablecomputedoptions,\n  computedgetter,\n  computedsetter\n} from './computed'\nexport {\n  effect,\n  stop,\n  trigger,\n  track,\n  enabletracking,\n  pausetracking,\n  resettracking,\n  iterate_key,\n  reactiveeffect,\n  reactiveeffectoptions,\n  debuggerevent\n} from './effect'\nexport { trackoptypes, triggeroptypes } from './operations'\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n reactivity apieffect  runtime-core \n\n\n# \n\nreactivity \n\npackages/reactivity/src\n basehandlers.ts // common type: array/object proxy handlers.\n collectionhandlers.ts // collection type: map/set/weakset/weakmap proxy handlers.\n computed.ts // \n effect.ts // \n index.ts //  api\n operations.ts // operations \n reactive.ts // reactive  api\n ref.ts // ref  api\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# \n\n * vue3 docs: reactivity api\n * vue3  api",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"Ref",frontmatter:{title:"Ref",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/reactivity/ref/",categories:["vue3","reactivity"],tags:[null]},regularPath:"/20.vue3/20.reactivity/10.ref.html",relativePath:"20.vue3/20.reactivity/10.ref.md",key:"v-dcaaef7a",path:"/vue3/reactivity/ref/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"ref",slug:"ref",normalizedTitle:"ref",charIndex:17},{level:2,title:"shallowRef",slug:"shallowref",normalizedTitle:"shallowref",charIndex:24},{level:2,title:"isRef",slug:"isref",normalizedTitle:"isref",charIndex:38},{level:2,title:"toRef",slug:"toref",normalizedTitle:"toref",charIndex:47},{level:2,title:"toRefs",slug:"torefs",normalizedTitle:"torefs",charIndex:56},{level:2,title:"unref",slug:"unref",normalizedTitle:"unref",charIndex:66},{level:2,title:"customRef",slug:"customref",normalizedTitle:"customref",charIndex:75},{level:2,title:"triggerRef",slug:"triggerref",normalizedTitle:"triggerref",charIndex:88},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:102}],readingTime:{text:"5 min read",minutes:4.8,time:288e3,words:960},headersStr:" ref shallowRef isRef toRef toRefs unref customRef triggerRef ",content:"# \n\n\n\n * \n * ref\n * shallowRef\n * isRef\n * toRef\n * toRefs\n * unref\n * customRef\n * triggerRef\n * \n\n\n\n\n# ref\n\n\n\nTakes an inner value and returns a reactive and mutable ref object. The ref object has a single property .value that points to the inner value.\n\n ref ref  property .value\n\n * ref  unknown  createRef \n * createRef  ref  RefImpl  ref  RefImpl ref  RefImpl  shadow  false ref  deep reactivity \n\nexport function ref(value?: unknown) {\n  return createRef(value)\n}\nfunction createRef(rawValue: unknown, shallow = false) {\n  if (isRef(rawValue)) {\n    return rawValue\n  }\n  return new RefImpl(rawValue, shallow)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n class RefImpl:\n\nclass RefImpl<T> {\n  private _value: T\n\n  public readonly __v_isRef = true\n\n  //  shadow   _rawValue reactive\n  //  _value \n  constructor(private _rawValue: T, public readonly _shallow: boolean) {\n    // \n    this._value = _shallow ? _rawValue : convert(_rawValue)\n  }\n  \n  get value() {\n    //  target  row target\n    track(toRaw(this), TrackOpTypes.GET, 'value')\n    return this._value\n  }\n\n  set value(newVal) {\n    //  setter\n    // this._rawValue  set  rowValue\n    if (hasChanged(toRaw(newVal), this._rawValue)) {\n      this._rawValue = newVal\n      this._value = this._shallow ? newVal : convert(newVal)\n      //  newVal\n      trigger(toRaw(this), TriggerOpTypes.SET, 'value', newVal)\n    }\n  }\n}\n//  reactive\nconst convert = <T extends unknown>(val: T): T =>\n  isObject(val) ? reactive(val) : val\n// compare whether a value has changed, accounting for NaN.\n//  NaN  NaN === NaN  false null === null  true\nexport const hasChanged = (value: any, oldValue: any): boolean =>\n  value !== oldValue && (value === value || oldValue === oldValue)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n *  ref  vue  target  get  set   get  target  set  vue2  Object.defineProperty () vue3  Proxy \n * _value  ref __v_isRef  ref  isRef  ref \n * getter  setter  es6  value  getter  track  target  toRaw (this)  ref  value  setter trigger  target track  trigger  effect \n *  reactive  ref  convert ref  object  reactive  deep reactivity  ref Proxy Api  object  MDN  'The Proxy object enables you to create a proxy for another object, which can intercept and redefine fundamental operations for that object.'  ref  object property \n\n\n\n * MDN: Object.defineProperty\n * MDN: Proxy\n\n\n# shallowRef\n\n\n\nCreates a ref that tracks its own .value mutation but doesn't make its value reactive.\n\n .value  ref\n\nexport function shallowRef(value?: unknown) {\n  return createRef(value, true)\n}\n\n\n1\n2\n3\n\n\nshallowRef  shallowRef _shallow  true ref  object  setter  reactive _rawValue Object object  ref.value  isReactive (ref.value)  false \n\n\n# isRef\n\n\n\nChecks if a value is a ref object.\n\n ref \n\nexport function isRef(r: any): r is Ref {\n  return Boolean(r && r.__v_isRef === true)\n}\n\n\n1\n2\n3\n\n\n __v_isRef  ref \n\n\n# toRef\n\n\n\nCan be used to create a ref for a property on a source reactive object. The ref can then be passed around, retaining the reactive connection to its source property.\n\n property  refref  property \n\nexport function toRef<T extends object, K extends keyof T>(\n  object: T,\n  key: K\n): ToRef<T[K]> {\n  return isRef(object[key])\n    ? object[key]\n    : (new ObjectRefImpl(object, key) as any)\n}\nclass ObjectRefImpl<T extends object, K extends keyof T> {\n  public readonly __v_isRef = true\n\n  constructor(private readonly _object: T, private readonly _key: K) {}\n\n  get value() {\n    return this._object[this._key]\n  }\n\n  set value(newVal) {\n    this._object[this._key] = newVal\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n ObjectRefImpl \n\n\n# toRefs\n\n\n\nConverts a reactive object to a plain object where each property of the resulting object is a ref pointing to the corresponding property of the original object.\n\n property  property  ref\n\nexport function toRefs<T extends object>(object: T): ToRefs<T> {\n  const ret: any = isArray(object) ? new Array(object.length) : {}\n  for (const key in object) {\n    ret[key] = toRef(object, key)\n  }\n  return ret\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * toRefs  array  object\n\n\n# unref\n\n\n\nReturns the inner value if the argument is a ref, otherwise return the argument itself. This is a sugar function for val = isRef(val) ? val.value : val.\n\n ref val = isRef (val) ? val.value : val \n\nexport function unref<T>(ref: T | Ref<T>): T {\n  return isRef(ref) ? (ref.value as any) : ref\n}\n\n\n1\n2\n3\n\n\n\n# customRef\n\n\n\nCreates a customized ref with explicit control over its dependency tracking and updates triggering. It expects a factory function, which receives track and trigger functions as arguments and should return an object with get and set.\n\n ref track  trigger  get  set \n\nexport function customRef<T>(factory: CustomRefFactory<T>): Ref<T> {\n  return new CustomRefImpl(factory) as any\n}\nclass CustomRefImpl<T> {\n  private readonly _get: ReturnType<CustomRefFactory<T>>['get']\n  private readonly _set: ReturnType<CustomRefFactory<T>>['set']\n\n  public readonly __v_isRef = true\n\n  constructor(factory: CustomRefFactory<T>) {\n    //  track  trigger \n    //  getter  setter\n    const { get, set } = factory(\n      () => track(this, TrackOpTypes.GET, 'value'),\n      () => trigger(this, TriggerOpTypes.SET, 'value')\n    )\n    this._get = get\n    this._set = set\n  }\n\n  get value() {\n    return this._get()\n  }\n\n  set value(newVal) {\n    this._set(newVal)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n CustomRefImpl \n\n * ref  value  getter  setter  getter  track  setter  trigger track  trigger  vue \n * customRef  getter  setter  ref \n\n\n# triggerRef\n\n\n\nExecute any effects tied to a shallowRef manually.\n\n shallowRef \n\nexport function triggerRef(ref: Ref) {\n  trigger(toRaw(ref), TriggerOpTypes.SET, 'value', __DEV__ ? ref.value : void 0)\n}\n\n\n1\n2\n3\n\n\ntriggerRef  ref \n\n\n# \n\n vue3  Ref Api  reactive  effect ",normalizedContent:"# \n\n\n\n * \n * ref\n * shallowref\n * isref\n * toref\n * torefs\n * unref\n * customref\n * triggerref\n * \n\n\n\n\n# ref\n\n\n\ntakes an inner value and returns a reactive and mutable ref object. the ref object has a single property .value that points to the inner value.\n\n ref ref  property .value\n\n * ref  unknown  createref \n * createref  ref  refimpl  ref  refimpl ref  refimpl  shadow  false ref  deep reactivity \n\nexport function ref(value?: unknown) {\n  return createref(value)\n}\nfunction createref(rawvalue: unknown, shallow = false) {\n  if (isref(rawvalue)) {\n    return rawvalue\n  }\n  return new refimpl(rawvalue, shallow)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n class refimpl:\n\nclass refimpl<t> {\n  private _value: t\n\n  public readonly __v_isref = true\n\n  //  shadow   _rawvalue reactive\n  //  _value \n  constructor(private _rawvalue: t, public readonly _shallow: boolean) {\n    // \n    this._value = _shallow ? _rawvalue : convert(_rawvalue)\n  }\n  \n  get value() {\n    //  target  row target\n    track(toraw(this), trackoptypes.get, 'value')\n    return this._value\n  }\n\n  set value(newval) {\n    //  setter\n    // this._rawvalue  set  rowvalue\n    if (haschanged(toraw(newval), this._rawvalue)) {\n      this._rawvalue = newval\n      this._value = this._shallow ? newval : convert(newval)\n      //  newval\n      trigger(toraw(this), triggeroptypes.set, 'value', newval)\n    }\n  }\n}\n//  reactive\nconst convert = <t extends unknown>(val: t): t =>\n  isobject(val) ? reactive(val) : val\n// compare whether a value has changed, accounting for nan.\n//  nan  nan === nan  false null === null  true\nexport const haschanged = (value: any, oldvalue: any): boolean =>\n  value !== oldvalue && (value === value || oldvalue === oldvalue)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n *  ref  vue  target  get  set   get  target  set  vue2  object.defineproperty () vue3  proxy \n * _value  ref __v_isref  ref  isref  ref \n * getter  setter  es6  value  getter  track  target  toraw (this)  ref  value  setter trigger  target track  trigger  effect \n *  reactive  ref  convert ref  object  reactive  deep reactivity  ref proxy api  object  mdn  'the proxy object enables you to create a proxy for another object, which can intercept and redefine fundamental operations for that object.'  ref  object property \n\n\n\n * mdn: object.defineproperty\n * mdn: proxy\n\n\n# shallowref\n\n\n\ncreates a ref that tracks its own .value mutation but doesn't make its value reactive.\n\n .value  ref\n\nexport function shallowref(value?: unknown) {\n  return createref(value, true)\n}\n\n\n1\n2\n3\n\n\nshallowref  shallowref _shallow  true ref  object  setter  reactive _rawvalue object object  ref.value  isreactive (ref.value)  false \n\n\n# isref\n\n\n\nchecks if a value is a ref object.\n\n ref \n\nexport function isref(r: any): r is ref {\n  return boolean(r && r.__v_isref === true)\n}\n\n\n1\n2\n3\n\n\n __v_isref  ref \n\n\n# toref\n\n\n\ncan be used to create a ref for a property on a source reactive object. the ref can then be passed around, retaining the reactive connection to its source property.\n\n property  refref  property \n\nexport function toref<t extends object, k extends keyof t>(\n  object: t,\n  key: k\n): toref<t[k]> {\n  return isref(object[key])\n    ? object[key]\n    : (new objectrefimpl(object, key) as any)\n}\nclass objectrefimpl<t extends object, k extends keyof t> {\n  public readonly __v_isref = true\n\n  constructor(private readonly _object: t, private readonly _key: k) {}\n\n  get value() {\n    return this._object[this._key]\n  }\n\n  set value(newval) {\n    this._object[this._key] = newval\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n objectrefimpl \n\n\n# torefs\n\n\n\nconverts a reactive object to a plain object where each property of the resulting object is a ref pointing to the corresponding property of the original object.\n\n property  property  ref\n\nexport function torefs<t extends object>(object: t): torefs<t> {\n  const ret: any = isarray(object) ? new array(object.length) : {}\n  for (const key in object) {\n    ret[key] = toref(object, key)\n  }\n  return ret\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * torefs  array  object\n\n\n# unref\n\n\n\nreturns the inner value if the argument is a ref, otherwise return the argument itself. this is a sugar function for val = isref(val) ? val.value : val.\n\n ref val = isref (val) ? val.value : val \n\nexport function unref<t>(ref: t | ref<t>): t {\n  return isref(ref) ? (ref.value as any) : ref\n}\n\n\n1\n2\n3\n\n\n\n# customref\n\n\n\ncreates a customized ref with explicit control over its dependency tracking and updates triggering. it expects a factory function, which receives track and trigger functions as arguments and should return an object with get and set.\n\n ref track  trigger  get  set \n\nexport function customref<t>(factory: customreffactory<t>): ref<t> {\n  return new customrefimpl(factory) as any\n}\nclass customrefimpl<t> {\n  private readonly _get: returntype<customreffactory<t>>['get']\n  private readonly _set: returntype<customreffactory<t>>['set']\n\n  public readonly __v_isref = true\n\n  constructor(factory: customreffactory<t>) {\n    //  track  trigger \n    //  getter  setter\n    const { get, set } = factory(\n      () => track(this, trackoptypes.get, 'value'),\n      () => trigger(this, triggeroptypes.set, 'value')\n    )\n    this._get = get\n    this._set = set\n  }\n\n  get value() {\n    return this._get()\n  }\n\n  set value(newval) {\n    this._set(newval)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n customrefimpl \n\n * ref  value  getter  setter  getter  track  setter  trigger track  trigger  vue \n * customref  getter  setter  ref \n\n\n# triggerref\n\n\n\nexecute any effects tied to a shallowref manually.\n\n shallowref \n\nexport function triggerref(ref: ref) {\n  trigger(toraw(ref), triggeroptypes.set, 'value', __dev__ ? ref.value : void 0)\n}\n\n\n1\n2\n3\n\n\ntriggerref  ref \n\n\n# \n\n vue3  ref api  reactive  effect ",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"Reactive",frontmatter:{title:"Reactive",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/basic/reactive/",categories:["vue3","reactivity"],tags:[null]},regularPath:"/20.vue3/20.reactivity/20.reactive.html",relativePath:"20.vue3/20.reactivity/20.reactive.md",key:"v-4d69bd7d",path:"/vue3/basic/reactive/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"Proxy",slug:"proxy",normalizedTitle:"proxy",charIndex:17},{level:2,title:"Object.defineProperty",slug:"object-defineproperty",normalizedTitle:"object.defineproperty",charIndex:26},{level:2,title:"createReactiveObject",slug:"createreactiveobject",normalizedTitle:"createreactiveobject",charIndex:51},{level:2,title:"reactive",slug:"reactive",normalizedTitle:"reactive",charIndex:75},{level:2,title:"readonly",slug:"readonly",normalizedTitle:"readonly",charIndex:87},{level:2,title:"shallowReactive",slug:"shallowreactive",normalizedTitle:"shallowreactive",charIndex:99},{level:2,title:"shallowReadonly",slug:"shallowreadonly",normalizedTitle:"shallowreadonly",charIndex:118},{level:2,title:"isReadonly",slug:"isreadonly",normalizedTitle:"isreadonly",charIndex:137},{level:2,title:"isReactive",slug:"isreactive",normalizedTitle:"isreactive",charIndex:151},{level:2,title:"isProxy",slug:"isproxy",normalizedTitle:"isproxy",charIndex:165},{level:2,title:"markRaw",slug:"markraw",normalizedTitle:"markraw",charIndex:176},{level:2,title:"toRaw",slug:"toraw",normalizedTitle:"toraw",charIndex:187},{level:2,title:"Q&A",slug:"q-a",normalizedTitle:"q&amp;a",charIndex:null},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:203}],readingTime:{text:"7 min read",minutes:6.67,time:400200,words:1334},headersStr:" Proxy Object.defineProperty createReactiveObject reactive readonly shallowReactive shallowReadonly isReadonly isReactive isProxy markRaw toRaw Q&A ",content:"# \n\n\n\n * \n * Proxy\n * Object.defineProperty\n * createReactiveObject\n * reactive\n * readonly\n * shallowReactive\n * shallowReadonly\n * isReadonly\n * isReactive\n * isProxy\n * markRaw\n * toRaw\n * Q&A\n * \n\n\n\n\n# Proxy\n\nProxy \n\nconst p = new Proxy(target, handler)\n\n\n1\n\n * target:  Proxy \n * handler:  p \n\n vue2.0  Object.defineProperty()  vue 3  Proxy  Object.defineProperty()Proxy Api \n\n * \n * \n *  MapSetWeakMap  WeakSet (Proxy )\n\nProxy Api  ie  vue3  ie  ie  vue2\n\nMDN: Proxy\n\n\n# Object.defineProperty\n\nObject.defineProperty () \n\nObject.defineProperty(obj, prop, descriptor)\n\n\n1\n\n * obj\n * prop Symbol \n * descriptor\n\nDESCRIPTOR                                                                          \nconfigurable    configurable  true                                 boolean   false\n               \nenumerable      enumerable  true                boolean   false\nvalue           JavaScript                       \\         undefined\nwritable        writable  true  value        boolean   false\n               (en-US) \nget             getter  getter                                   \\         undefined\n               undefined this \n               this \nset             setter  setter                                   \\         undefined\n               undefined this\n               \n\nMDN: Object.defineProperty()\n\n\n# createReactiveObject\n\n reactive/shallowReactive/readonly/shallowReadonly  api \n\nexport const enum ReactiveFlags {\n  SKIP = '__v_skip',\n  IS_REACTIVE = '__v_isReactive',\n  IS_READONLY = '__v_isReadonly',\n  RAW = '__v_raw'\n}\n\nexport interface Target {\n  [ReactiveFlags.SKIP]?: boolean // \n  [ReactiveFlags.IS_REACTIVE]?: boolean //  reactive \n  [ReactiveFlags.IS_READONLY]?: boolean //  readonly \n  [ReactiveFlags.RAW]?: any // \n}\n\nfunction createReactiveObject(\n  target: Target, // reactive target\n  isReadonly: boolean, // \n  baseHandlers: ProxyHandler<any>, //  handlersobject/array\n  collectionHandlers: ProxyHandler<any>, // COLLECTION  handlersmap/set/weakMap/weakSet\n  proxyMap: WeakMap<Target, any> //  Map(t, p) \n) {\n  // reactive  object\n  if (!isObject(target)) {\n    if (__DEV__) {\n      console.warn(`value cannot be made reactive: ${String(target)}`)\n    }\n    return target\n  }\n  // target is already a Proxy, return it.\n  // exception: calling readonly() on a reactive object\n  //  Proxy \n  //  readonly  reactive \n  if (\n    target[ReactiveFlags.RAW] &&\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\n  ) {\n    return target\n  }\n  // target already has corresponding Proxy\n  // target  Proxy  proxyMap  existingProxy\n  const existingProxy = proxyMap.get(target)\n  if (existingProxy) {\n    return existingProxy\n  }\n  // only a whitelist of value types can be observed.\n  // getTargetType  target INVALIDCOMMONCOLLECTION\n  // \n  const targetType = getTargetType(target)\n  if (targetType === TargetType.INVALID) {\n    return target\n  }\n  //  target  Proxy \n  // COLLECTION  collectionHandlers baseHandlers\n  const proxy = new Proxy(\n    target,\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\n  )\n  //  proxy  proxyMap : Map<target, proxy>\n  proxyMap.set(target, proxy)\n  //  proxy  target \n  return proxy\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n\n *  5 target: isReadonlybaseHandlers handlers object/arraycollectionHandlersCOLLECTION  handlers map/set/weakMap/weakSetproxyMap  Map (target, proxy)  Map\n *  object Proxy target  Proxy  proxyMap \n * createReactiveObject \n\nhandlers  proxyMap  api \n\n\n# reactive\n\n\n\nReturns a reactive copy of the object.\n\nThe reactive conversion is \"deep\"it affects all nested properties. In the ES2015 Proxy based implementation, the returned proxy is not equal to the original object. It is recommended to work exclusively with the reactive proxy and avoid relying on the original object.\n\n\n\n  ES2015  Proxy \n\n\n\nexport function reactive(target: object) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  // readonly \n  if (target && (target as Target)[ReactiveFlags.IS_READONLY]) {\n    return target\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  )\n}\n\nexport const mutableHandlers: ProxyHandler<object> = {\n  get,\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n}\n\nexport const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {\n  get: /*#__PURE__*/ createInstrumentationGetter(false, false)\n}\n\nexport const reactiveMap = new WeakMap<Target, any>()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nhandles  handler \n\n\n# readonly\n\n\n\nTakes an object (reactive or plain) or a ref and returns a readonly proxy to the original. A readonly proxy is deep: any nested property accessed will be readonly as well.\n\n ()  ref  property \n\nexport function readonly<T extends object>(\n  target: T\n): DeepReadonly<UnwrapNestedRefs<T>> {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  )\n}\n\nexport const readonlyHandlers: ProxyHandler<object> = {\n  get: readonlyGet,\n  set(target, key) {\n    return true\n  },\n  deleteProperty(target, key) {\n    return true\n  }\n}\n\nexport const readonlyCollectionHandlers: ProxyHandler<CollectionTypes> = {\n  get: /*#__PURE__*/ createInstrumentationGetter(true, false)\n}\n\nexport const readonlyMap = new WeakMap<Target, any>()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * readonly  set  delete true\n\n\n# shallowReactive\n\n\n\nCreates a reactive proxy that tracks reactivity of its own properties but does not perform deep reactive conversion of nested objects (exposes raw values).\n\n property  ()\n\nexport function shallowReactive<T extends object>(target: T): T {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  )\n}\n\nexport const shallowReactiveHandlers = /*#__PURE__*/ extend(\n  {},\n  mutableHandlers,\n  {\n    get: shallowGet,\n    set: shallowSet\n  }\n)\n\nexport const shallowCollectionHandlers: ProxyHandler<CollectionTypes> = {\n  get: /*#__PURE__*/ createInstrumentationGetter(false, true)\n}\n\nexport const shallowReactiveMap = new WeakMap<Target, any>()\n\nexport const extend = Object.assign\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# shallowReadonly\n\n\n\nCreates a proxy that makes its own properties readonly, but does not perform deep readonly conversion of nested objects (exposes raw values).\n\n proxy property  ()\n\nexport function shallowReadonly<T extends object>(\n  target: T\n): Readonly<{ [K in keyof T]: UnwrapNestedRefs<T[K]> }> {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  )\n}\n\nexport const shallowReadonlyHandlers = /*#__PURE__*/ extend(\n  {},\n  readonlyHandlers,\n  {\n    get: shallowReadonlyGet\n  }\n)\n\nexport const shallowReadonlyCollectionHandlers: ProxyHandler<\n  CollectionTypes\n> = {\n  get: /*#__PURE__*/ createInstrumentationGetter(true, true)\n}\n\nexport const shallowReadonlyMap = new WeakMap<Target, any>()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# isReadonly\n\n\n\nChecks if an object is a readonly proxy created by readonly.\n\n readonly \n\nexport function isReadonly(value: unknown): boolean {\n  return !!(value && (value as Target)[ReactiveFlags.IS_READONLY])\n}\n\n\n1\n2\n3\n\n\nisReadonly  target  __v_isReadonly \n\n\n# isReactive\n\n\n\nChecks if an object is a reactive proxy created by reactive.\n\n reactive \n\nexport function isReactive(value: unknown): boolean {\n  if (isReadonly(value)) {\n    return isReactive((value as Target)[ReactiveFlags.RAW])\n  }\n  return !!(value && (value as Target)[ReactiveFlags.IS_REACTIVE])\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n value  reactive  __v_isReactive \n\n\n# isProxy\n\n\n\nChecks if an object is a proxy created by reactive or readonly.\n\n reactive  readonly  proxy\n\nexport function isProxy(value: unknown): boolean {\n  return isReactive(value) || isReadonly(value)\n}\n\n\n1\n2\n3\n\n\n reactive  readonly \n\n\n# markRaw\n\n\n\nMarks an object so that it will never be converted to a proxy. Returns the object itself.\n\n proxy\n\nexport function markRaw<T extends object>(value: T): T {\n  // markRaw  '__v_skip'  true \n  def(value, ReactiveFlags.SKIP, true)\n  return value\n}\n\nexport const def = (obj: object, key: string | symbol, value: any) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    value\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nmarkRaw  __v_skip  effect  target  effect  markRaw \n\n\n# toRaw\n\n\n\nReturns the raw, original object of a reactive or readonly proxy. This is an escape hatch that can be used to temporarily read without incurring proxy access/tracking overhead or write without triggering changes. It is not recommended to hold a persistent reference to the original object. Use with caution.\n\n reactive  readonly   / \n\nexport function toRaw<T>(observed: T): T {\n  return (\n    (observed && toRaw((observed as Target)[ReactiveFlags.RAW])) || observed\n  )\n}\n\n\n1\n2\n3\n4\n5\n\n *  proxy  raw object  \n * markRaw  toRaw  Proxy\n\n\n# Q&A\n\n 1. createReactiveObject \n\n * reactive deep reactivity\n * readonly deep readonly\n * shallowReactive shallow reactivity\n * shallowReactive shallow readonly\n\n 2. createReactiveObject \n\n target \n\nfunction targetTypeMap(rawType: string) {\n  switch (rawType) {\n    case 'Object':\n    case 'Array':\n      return TargetType.COMMON\n    case 'Map':\n    case 'Set':\n    case 'WeakMap':\n    case 'WeakSet':\n      return TargetType.COLLECTION\n    default:\n      return TargetType.INVALID\n  }\n}\n\n//  value \nfunction getTargetType(value: Target) {\n  return value[ReactiveFlags.SKIP] || !Object.isExtensible(value)\n    ? TargetType.INVALID\n    : targetTypeMap(toRawType(value))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n\n * COMMONObjectArray\n * COLLECTIONMapSetWeakMapWeakSet\n\n configurable: false  writable: false  proxy \n\n\n# \n\n reactivity  reactive  reactive object  reactive object  Proxy  handlers  proxyMapproxyMap  proxy handlers  Proxy  Handler ",normalizedContent:"# \n\n\n\n * \n * proxy\n * object.defineproperty\n * createreactiveobject\n * reactive\n * readonly\n * shallowreactive\n * shallowreadonly\n * isreadonly\n * isreactive\n * isproxy\n * markraw\n * toraw\n * q&a\n * \n\n\n\n\n# proxy\n\nproxy \n\nconst p = new proxy(target, handler)\n\n\n1\n\n * target:  proxy \n * handler:  p \n\n vue2.0  object.defineproperty()  vue 3  proxy  object.defineproperty()proxy api \n\n * \n * \n *  mapsetweakmap  weakset (proxy )\n\nproxy api  ie  vue3  ie  ie  vue2\n\nmdn: proxy\n\n\n# object.defineproperty\n\nobject.defineproperty () \n\nobject.defineproperty(obj, prop, descriptor)\n\n\n1\n\n * obj\n * prop symbol \n * descriptor\n\ndescriptor                                                                          \nconfigurable    configurable  true                                 boolean   false\n               \nenumerable      enumerable  true                boolean   false\nvalue           javascript                       \\         undefined\nwritable        writable  true  value        boolean   false\n               (en-us) \nget             getter  getter                                   \\         undefined\n               undefined this \n               this \nset             setter  setter                                   \\         undefined\n               undefined this\n               \n\nmdn: object.defineproperty()\n\n\n# createreactiveobject\n\n reactive/shallowreactive/readonly/shallowreadonly  api \n\nexport const enum reactiveflags {\n  skip = '__v_skip',\n  is_reactive = '__v_isreactive',\n  is_readonly = '__v_isreadonly',\n  raw = '__v_raw'\n}\n\nexport interface target {\n  [reactiveflags.skip]?: boolean // \n  [reactiveflags.is_reactive]?: boolean //  reactive \n  [reactiveflags.is_readonly]?: boolean //  readonly \n  [reactiveflags.raw]?: any // \n}\n\nfunction createreactiveobject(\n  target: target, // reactive target\n  isreadonly: boolean, // \n  basehandlers: proxyhandler<any>, //  handlersobject/array\n  collectionhandlers: proxyhandler<any>, // collection  handlersmap/set/weakmap/weakset\n  proxymap: weakmap<target, any> //  map(t, p) \n) {\n  // reactive  object\n  if (!isobject(target)) {\n    if (__dev__) {\n      console.warn(`value cannot be made reactive: ${string(target)}`)\n    }\n    return target\n  }\n  // target is already a proxy, return it.\n  // exception: calling readonly() on a reactive object\n  //  proxy \n  //  readonly  reactive \n  if (\n    target[reactiveflags.raw] &&\n    !(isreadonly && target[reactiveflags.is_reactive])\n  ) {\n    return target\n  }\n  // target already has corresponding proxy\n  // target  proxy  proxymap  existingproxy\n  const existingproxy = proxymap.get(target)\n  if (existingproxy) {\n    return existingproxy\n  }\n  // only a whitelist of value types can be observed.\n  // gettargettype  target invalidcommoncollection\n  // \n  const targettype = gettargettype(target)\n  if (targettype === targettype.invalid) {\n    return target\n  }\n  //  target  proxy \n  // collection  collectionhandlers basehandlers\n  const proxy = new proxy(\n    target,\n    targettype === targettype.collection ? collectionhandlers : basehandlers\n  )\n  //  proxy  proxymap : map<target, proxy>\n  proxymap.set(target, proxy)\n  //  proxy  target \n  return proxy\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n\n *  5 target: isreadonlybasehandlers handlers object/arraycollectionhandlerscollection  handlers map/set/weakmap/weaksetproxymap  map (target, proxy)  map\n *  object proxy target  proxy  proxymap \n * createreactiveobject \n\nhandlers  proxymap  api \n\n\n# reactive\n\n\n\nreturns a reactive copy of the object.\n\nthe reactive conversion is \"deep\"it affects all nested properties. in the es2015 proxy based implementation, the returned proxy is not equal to the original object. it is recommended to work exclusively with the reactive proxy and avoid relying on the original object.\n\n\n\n  es2015  proxy \n\n\n\nexport function reactive(target: object) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  // readonly \n  if (target && (target as target)[reactiveflags.is_readonly]) {\n    return target\n  }\n  return createreactiveobject(\n    target,\n    false,\n    mutablehandlers,\n    mutablecollectionhandlers,\n    reactivemap\n  )\n}\n\nexport const mutablehandlers: proxyhandler<object> = {\n  get,\n  set,\n  deleteproperty,\n  has,\n  ownkeys\n}\n\nexport const mutablecollectionhandlers: proxyhandler<collectiontypes> = {\n  get: /*#__pure__*/ createinstrumentationgetter(false, false)\n}\n\nexport const reactivemap = new weakmap<target, any>()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nhandles  handler \n\n\n# readonly\n\n\n\ntakes an object (reactive or plain) or a ref and returns a readonly proxy to the original. a readonly proxy is deep: any nested property accessed will be readonly as well.\n\n ()  ref  property \n\nexport function readonly<t extends object>(\n  target: t\n): deepreadonly<unwrapnestedrefs<t>> {\n  return createreactiveobject(\n    target,\n    true,\n    readonlyhandlers,\n    readonlycollectionhandlers,\n    readonlymap\n  )\n}\n\nexport const readonlyhandlers: proxyhandler<object> = {\n  get: readonlyget,\n  set(target, key) {\n    return true\n  },\n  deleteproperty(target, key) {\n    return true\n  }\n}\n\nexport const readonlycollectionhandlers: proxyhandler<collectiontypes> = {\n  get: /*#__pure__*/ createinstrumentationgetter(true, false)\n}\n\nexport const readonlymap = new weakmap<target, any>()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * readonly  set  delete true\n\n\n# shallowreactive\n\n\n\ncreates a reactive proxy that tracks reactivity of its own properties but does not perform deep reactive conversion of nested objects (exposes raw values).\n\n property  ()\n\nexport function shallowreactive<t extends object>(target: t): t {\n  return createreactiveobject(\n    target,\n    false,\n    shallowreactivehandlers,\n    shallowcollectionhandlers,\n    shallowreactivemap\n  )\n}\n\nexport const shallowreactivehandlers = /*#__pure__*/ extend(\n  {},\n  mutablehandlers,\n  {\n    get: shallowget,\n    set: shallowset\n  }\n)\n\nexport const shallowcollectionhandlers: proxyhandler<collectiontypes> = {\n  get: /*#__pure__*/ createinstrumentationgetter(false, true)\n}\n\nexport const shallowreactivemap = new weakmap<target, any>()\n\nexport const extend = object.assign\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# shallowreadonly\n\n\n\ncreates a proxy that makes its own properties readonly, but does not perform deep readonly conversion of nested objects (exposes raw values).\n\n proxy property  ()\n\nexport function shallowreadonly<t extends object>(\n  target: t\n): readonly<{ [k in keyof t]: unwrapnestedrefs<t[k]> }> {\n  return createreactiveobject(\n    target,\n    true,\n    shallowreadonlyhandlers,\n    shallowreadonlycollectionhandlers,\n    shallowreadonlymap\n  )\n}\n\nexport const shallowreadonlyhandlers = /*#__pure__*/ extend(\n  {},\n  readonlyhandlers,\n  {\n    get: shallowreadonlyget\n  }\n)\n\nexport const shallowreadonlycollectionhandlers: proxyhandler<\n  collectiontypes\n> = {\n  get: /*#__pure__*/ createinstrumentationgetter(true, true)\n}\n\nexport const shallowreadonlymap = new weakmap<target, any>()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# isreadonly\n\n\n\nchecks if an object is a readonly proxy created by readonly.\n\n readonly \n\nexport function isreadonly(value: unknown): boolean {\n  return !!(value && (value as target)[reactiveflags.is_readonly])\n}\n\n\n1\n2\n3\n\n\nisreadonly  target  __v_isreadonly \n\n\n# isreactive\n\n\n\nchecks if an object is a reactive proxy created by reactive.\n\n reactive \n\nexport function isreactive(value: unknown): boolean {\n  if (isreadonly(value)) {\n    return isreactive((value as target)[reactiveflags.raw])\n  }\n  return !!(value && (value as target)[reactiveflags.is_reactive])\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n value  reactive  __v_isreactive \n\n\n# isproxy\n\n\n\nchecks if an object is a proxy created by reactive or readonly.\n\n reactive  readonly  proxy\n\nexport function isproxy(value: unknown): boolean {\n  return isreactive(value) || isreadonly(value)\n}\n\n\n1\n2\n3\n\n\n reactive  readonly \n\n\n# markraw\n\n\n\nmarks an object so that it will never be converted to a proxy. returns the object itself.\n\n proxy\n\nexport function markraw<t extends object>(value: t): t {\n  // markraw  '__v_skip'  true \n  def(value, reactiveflags.skip, true)\n  return value\n}\n\nexport const def = (obj: object, key: string | symbol, value: any) => {\n  object.defineproperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    value\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nmarkraw  __v_skip  effect  target  effect  markraw \n\n\n# toraw\n\n\n\nreturns the raw, original object of a reactive or readonly proxy. this is an escape hatch that can be used to temporarily read without incurring proxy access/tracking overhead or write without triggering changes. it is not recommended to hold a persistent reference to the original object. use with caution.\n\n reactive  readonly   / \n\nexport function toraw<t>(observed: t): t {\n  return (\n    (observed && toraw((observed as target)[reactiveflags.raw])) || observed\n  )\n}\n\n\n1\n2\n3\n4\n5\n\n *  proxy  raw object  \n * markraw  toraw  proxy\n\n\n# q&a\n\n 1. createreactiveobject \n\n * reactive deep reactivity\n * readonly deep readonly\n * shallowreactive shallow reactivity\n * shallowreactive shallow readonly\n\n 2. createreactiveobject \n\n target \n\nfunction targettypemap(rawtype: string) {\n  switch (rawtype) {\n    case 'object':\n    case 'array':\n      return targettype.common\n    case 'map':\n    case 'set':\n    case 'weakmap':\n    case 'weakset':\n      return targettype.collection\n    default:\n      return targettype.invalid\n  }\n}\n\n//  value \nfunction gettargettype(value: target) {\n  return value[reactiveflags.skip] || !object.isextensible(value)\n    ? targettype.invalid\n    : targettypemap(torawtype(value))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n\n * commonobjectarray\n * collectionmapsetweakmapweakset\n\n configurable: false  writable: false  proxy \n\n\n# \n\n reactivity  reactive  reactive object  reactive object  proxy  handlers  proxymapproxymap  proxy handlers  proxy  handler ",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"Handler",frontmatter:{title:"Handler",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/basic/handler/",categories:["vue3","reactivity"],tags:[null]},regularPath:"/20.vue3/20.reactivity/30.handler.html",relativePath:"20.vue3/20.reactivity/30.handler.md",key:"v-eea5a8ce",path:"/vue3/basic/handler/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"baseHandlers",slug:"basehandlers",normalizedTitle:"basehandlers",charIndex:17},{level:3,title:"get",slug:"get",normalizedTitle:"get",charIndex:35},{level:4,title:"arrayInstrumentations",slug:"arrayinstrumentations",normalizedTitle:"arrayinstrumentations",charIndex:1871},{level:3,title:"set",slug:"set",normalizedTitle:"set",charIndex:44},{level:3,title:"deleteProperty",slug:"deleteproperty",normalizedTitle:"deleteproperty",charIndex:53},{level:3,title:"has",slug:"has",normalizedTitle:"has",charIndex:73},{level:3,title:"ownKeys",slug:"ownkeys",normalizedTitle:"ownkeys",charIndex:82},{level:3,title:"shallowGet",slug:"shallowget",normalizedTitle:"shallowget",charIndex:95},{level:3,title:"shallowSet",slug:"shallowset",normalizedTitle:"shallowset",charIndex:111},{level:3,title:"readonlyGet",slug:"readonlyget",normalizedTitle:"readonlyget",charIndex:127},{level:3,title:"shallowReadonlyGet",slug:"shallowreadonlyget",normalizedTitle:"shallowreadonlyget",charIndex:144},{level:2,title:"collectionHandlers",slug:"collectionhandlers",normalizedTitle:"collectionhandlers",charIndex:166},{level:3,title:"createInstrumentationGetter",slug:"createinstrumentationgetter",normalizedTitle:"createinstrumentationgetter",charIndex:190},{level:3,title:"createInstrumentations",slug:"createinstrumentations",normalizedTitle:"createinstrumentations",charIndex:223},{level:3,title:"get",slug:"get-2",normalizedTitle:"get",charIndex:35},{level:3,title:"size",slug:"size",normalizedTitle:"size",charIndex:260},{level:3,title:"has",slug:"has-2",normalizedTitle:"has",charIndex:73},{level:3,title:"add",slug:"add",normalizedTitle:"add",charIndex:279},{level:3,title:"set",slug:"set-2",normalizedTitle:"set",charIndex:44},{level:3,title:"delete",slug:"delete",normalizedTitle:"delete",charIndex:53},{level:3,title:"clear",slug:"clear",normalizedTitle:"clear",charIndex:309},{level:3,title:"forEach",slug:"foreach",normalizedTitle:"foreach",charIndex:320},{level:2,title:"Q&A",slug:"q-a",normalizedTitle:"q&amp;a",charIndex:null},{level:3,title:"Proxy Handlers ",slug:"proxy-handlers-",normalizedTitle:"proxy handlers ",charIndex:340},{level:3,title:" Tree Shaking",slug:"-tree-shaking",normalizedTitle:" tree shaking",charIndex:370},{level:3,title:"Proxy",slug:"proxy",normalizedTitle:"proxy ",charIndex:18454},{level:3,title:"Proxy  MapSet ",slug:"proxy--mapset-",normalizedTitle:"proxy  mapset ",charIndex:410},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:438},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:446}],readingTime:{text:"12 min read",minutes:11.565,time:693900,words:2313},headersStr:" baseHandlers get arrayInstrumentations set deleteProperty has ownKeys shallowGet shallowSet readonlyGet shallowReadonlyGet collectionHandlers createInstrumentationGetter createInstrumentations get size has add set delete clear forEach Q&A Proxy Handlers   Tree Shaking Proxy Proxy  MapSet   ",content:"# \n\n\n\n * \n * baseHandlers\n   * get\n   * set\n   * deleteProperty\n   * has\n   * ownKeys\n   * shallowGet\n   * shallowSet\n   * readonlyGet\n   * shallowReadonlyGet\n * collectionHandlers\n   * createInstrumentationGetter\n   * createInstrumentations\n   * get\n   * size\n   * has\n   * add\n   * set\n   * delete\n   * clear\n   * forEach\n * Q&A\n   * Proxy Handlers \n   *  Tree Shaking\n   * Proxy\n   * Proxy  MapSet \n * \n * \n\n\n\n>  Reactive  reactive object  handler baseHandlers  collectionHandlers  handler  Reactive  creative object \n\n\n# baseHandlers\n\nbaseHandlers  reactivity/baseHandlers.tsbaseHandlers  arrayobject \n\n\n# get\n\n handler \n\nconst get = /*#__PURE__*/ createGetter()\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target: Target, key: string | symbol, receiver: object) {\n    // __v_isReactive  __v_isReactive__v_raw \n    //  get  reactive  readonly\n    //  target \n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly\n    } else if (\n      key === ReactiveFlags.RAW &&\n      receiver ===\n        (isReadonly\n          ? shallow\n            ? shallowReadonlyMap\n            : readonlyMap\n          : shallow\n            ? shallowReactiveMap\n            : reactiveMap\n        )\n          //  __v_raw  receiver ProxyMap  target\n          //  target  raw object\n          //  receiver === proxyMap.get(target) receiver  proxy objecttarget  raw object\n          .get(target)\n    ) {\n      return target\n    }\n\n    const targetIsArray = isArray(target)\n    //  readonlytarget  key  arrayInstrumentations \n    //  target \n    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\n      return Reflect.get(arrayInstrumentations, key, receiver)\n    }\n    //  target[key],\n    const res = Reflect.get(target, key, receiver)\n    //  key  Symbol  key \n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res\n    }\n    // Reactive target target.key \n    //  ref \n    if (!isReadonly) {\n      track(target, TrackOpTypes.GET, key)\n    }\n    //  shallow \n    if (shallow) {\n      return res\n    }\n    //  ref unwrapping\n    if (isRef(res)) {\n      // ref unwrapping - does not apply for Array + integer key.\n      // target  key  string int  '1', \n      const shouldUnwrap = !targetIsArray || !isIntegerKey(key)\n      return shouldUnwrap ? res.value : res\n    }\n    // typeof [] === \"object\"\n    // \n    if (isObject(res)) {\n      // Convert returned value into a proxy as well. we do the isObject check\n      // here to avoid invalid value warning. Also need to lazy access readonly\n      // and reactive here to avoid circular dependency.\n      //  proxy deep proxy\n      return isReadonly ? readonly(res) : reactive(res)\n    }\n    // \n    return res\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n * /*#__PURE__*/  createGetter  Tree Shaking Tree Shaking\n * createGetter  getter setter \n\n *  proxy  __v_raw  proxy object  proxyMap target  target  raw target  handlers.get () \n *  object  track  track track Proxy Api  Proxy  Proxy API  object keys  track  hack  arrayInstrumentations \n *  Reflect.get  receiver Reflect.get receiver  this stackoverflow: JavaScript: Difference between Reflect.get() and obj['foo']\n *  ref Ref unwrapping only happens when nested inside a reactive Object. There is no unwrapping performed when the ref is accessed from an Array or a native collection type like Mapvue3: ref-unwrapping\n\n\n\n\n\n\nif (!isReadonly) {\n  track(target, TrackOpTypes.GET, key)\n}\n\nif (isObject(res)) {\n  // Convert returned value into a proxy as well. we do the isObject check\n  // here to avoid invalid value warning. Also need to lazy access readonly\n  // and reactive here to avoid circular dependency.\n  //  proxy deep proxy\n  return isReadonly ? readonly(res) : reactive(res)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\n *  readonly  track  get handler readonly  readonly !== none reactivityreadonly \n * isObject  object  array readonly  reactive deep proxy deep reactivity \n\n - handler.get()\n\nhandler.get () \n\nvar p = new Proxy(target, {\n  get: function(target, property, receiver) {\n  }\n});\n\n\n1\n2\n3\n4\n\n\n get this  handler .\n\n * target\n * property\n * receiverProxy  Proxy \n\nMDN: handler.get()\n\n - Reflect  Reflect.get()\n\nReflect  JavaScript  proxy handlers (en-US) Reflect Reflect  Math Reflect  proxy handler methods (en-US) .Reflect  ie Reflect \n\nReflect.get ()  (target [propertyKey]) \n\nReflect.get(target, propertyKey[, receiver])\n\n\n1\n\n * target\n * propertyKey\n * receiver Proxy  receiver  target  getterreceiver  getter  this \n\n\n\n * MDN: Reflect\n * Reflect.get()\n * JS  Reflect \n *  Javascript  Proxy  Reflect\n\n# arrayInstrumentations\n\narrayInstrumentations  createArrayInstrumentations \n\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations()\n// (hack)\nfunction createArrayInstrumentations() {\n  const instrumentations: Record<string, Function> = {}\n  // instrument identity-sensitive Array methods to account for possible reactive\n  // values\n  //  hack\n  ;(['includes', 'indexOf', 'lastIndexOf'] as const).forEach(key => {\n    // \n    const method = Array.prototype[key] as any\n    // this  receiver  receiver  receiver  target\n    //  this  target \n    instrumentations[key] = function(this: unknown[], ...args: unknown[]) {\n      //  row valuereceiver  proxy object\n      const arr = toRaw(this)\n      //  track\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, TrackOpTypes.GET, i + '')\n      }\n      // we run the method using the original args first (which may be reactive)\n      //  row vlaue\n      const res = method.apply(arr, args)\n      if (res === -1 || res === false) {\n        // if that didn't work, run it again using raw values.\n        //  proxy value raw value\n        return method.apply(arr, args.map(toRaw))\n      } else {\n        return res\n      }\n    }\n  })\n  // instrument length-altering mutation methods to avoid length being tracked\n  // which leads to infinite loops in some cases (#2137)\n  //  hack\n  //  track \n  ;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach(key => {\n    const method = Array.prototype[key] as any\n    instrumentations[key] = function(this: unknown[], ...args: unknown[]) {\n      //  track track \n      //  this  raw object track trigger \n      pauseTracking()\n      const res = method.apply(this, args)\n      resetTracking()\n      return res\n    }\n  })\n  return instrumentations\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n *  hack 'includes', 'indexOf', 'lastIndexOf'  identity-sensitive Array methods track  'push', 'pop', 'shift', 'unshift', 'splice'  length-altering mutation methods tracK track Proxy \n *  track  2  trigger raw object track track  proxy object trigger track\n\n\n# set\n\n handler \n\nconst set = /*#__PURE__*/ createSetter()\nfunction createSetter(shallow = false) {\n  return function set(\n    target: object, // raw target object\n    key: string | symbol, // target property\n    value: unknown, // new value for property\n    receiver: object // proxy target object\n  ): boolean {\n    // \n    let oldValue = (target as any)[key]\n    if (!shallow) {\n      // value  raw value\n      value = toRaw(value)\n      oldValue = toRaw(oldValue)\n      //  target  ref  ref  ref\n      //  return  trigger\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value\n        return true\n      }\n    } else {\n      // in shallow mode, objects are set as-is regardless of reactive or not\n    }\n    // key  target  array  int key  key\n    //  key  '-100' isIntegerKey \n    const hadKey =\n      isArray(target) && isIntegerKey(key)\n        ? Number(key) < target.length\n        : hasOwn(target, key)\n    // \n    const result = Reflect.set(target, key, value, receiver)\n    // don't trigger if target is something up in the prototype chain of original\n    //  trigger\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        // \n        trigger(target, TriggerOpTypes.ADD, key, value)\n      } else if (hasChanged(value, oldValue)) {\n        // \n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\n      }\n    }\n    return result\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n *  shallow   target  ref  ref  ref.value  return  trigger  ref  trigger  ref \n * target === toRaw(receiver)  receiver  target  proxy  trigger target  set  trigger\n *  hadKey  ADD  SET effects track  trigger  effect \n\n\n\nget ()  track ()set ()  trigger () ref  getter  tracksetter  trigger get  set  track  trigger  vue \n\n\n# deleteProperty\n\n handler \n\nfunction deleteProperty(target: object, key: string | symbol): boolean {\n  const hadKey = hasOwn(target, key)\n  const oldValue = (target as any)[key]\n  const result = Reflect.deleteProperty(target, key)\n  // key  trigger DELETE\n  if (result && hadKey) {\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\n  }\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# has\n\n handler \n\nfunction has(target: object, key: string | symbol): boolean {\n  const result = Reflect.has(target, key)\n  //  key  Sumbol builtInSymbols  track\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\n    track(target, TrackOpTypes.HAS, key)\n  }\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nhas  track\n\n\n\nhandler.has ()  The handler.has () method is a trap for the in operator.\n\nMDN: handler.has()\n\n\n# ownKeys\n\n handler  Symbol \n\nfunction ownKeys(target: object): (string | symbol)[] {\n  //  track ITERATEkey  prod \n  track(target, TrackOpTypes.ITERATE, isArray(target) ? 'length' : ITERATE_KEY)\n  return Reflect.ownKeys(target)\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n\nhandler.ownKeys () ownKeys  Object.keys() \n\nMDN: handler.ownKeys()\n\n\n# shallowGet\n\n hallowReactive\n\nconst shallowGet = /*#__PURE__*/ createGetter(false, true)\n\n\n1\n\n\n track  deep reactivity\n\n\n# shallowSet\n\n shallowReactive\n\nconst shallowSet = /*#__PURE__*/ createSetter(true)\n\n\n1\n\n\n set \n\n\n# readonlyGet\n\n readonly\n\nconst readonlyGet = /*#__PURE__*/ createGetter(true)\n\n\n1\n\n\n track  deep readonly\n\n\n# shallowReadonlyGet\n\n shallowReadonly\n\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true)\n\n\n1\n\n\n track \n\n\n# collectionHandlers\n\ncollectionHandlers  reactivity/collectionHandlers.tscollectionHandlers  MapSetWeakSetWeakMap \n\n\n# createInstrumentationGetter\n\n reactivereadonlyshallowReactive  shallowReadonly  API\n\nfunction createInstrumentationGetter(isReadonly: boolean, shallow: boolean) {\n  //  isReadonly  shallow  instrumentations\n  const instrumentations = shallow\n    ? isReadonly\n      ? shallowReadonlyInstrumentations\n      : shallowInstrumentations\n    : isReadonly\n      ? readonlyInstrumentations\n      : mutableInstrumentations\n\n  return (\n    target: CollectionTypes,\n    key: string | symbol,\n    receiver: CollectionTypes\n  ) => {\n    // buildin \n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly\n    } else if (key === ReactiveFlags.RAW) {\n      return target\n    }\n\n    //  instrumentations  target \n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target\n        ? instrumentations\n        : target,\n      key,\n      receiver\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n return  key  instrumentations  instrumentations  target  CollectionTypes get handlerProxy \n\nconst m = new Map([[\"name\", 'any']]);\nconst p = new Proxy(m, {\n  get(target, key, receiver) {\n    const v = Reflect.get(...arguments);\n    console.info('==> get', key);\n    return typeof v === \"function\" ? v.bind(target) : v;\n  },\n  set(target, key, receiver) {\n    const v = Reflect.set(...arguments);\n    console.info('==> set', key);\n    return typeof v === \"function\" ? v.bind(target) : v;\n  },\n})\n//  console \np.get(\"name\");\n// >> ==> get get\np.set('name', 'some')\n// >> ==> get set\np.delete(\"name\")\n// >> ==> get delete\np.clear()\n// >> ==> get clear\np.entries()\n// >> ==> get entries\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n Proxy Api  get handler  get  key  isReadonly  shallow  instrumentations instrumentations  key \n\n\n# createInstrumentations\n\n isReadOnly  shallow  handlers\n\nfunction createInstrumentations() {\n  // reactive\n  const mutableInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key)\n    },\n    get size() {\n      return size((this as unknown) as IterableCollections)\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  }\n  // shallowReactive\n  const shallowInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key, false, true)\n    },\n    get size() {\n      return size((this as unknown) as IterableCollections)\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  }\n  // readOnly\n  const readonlyInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key, true)\n    },\n    get size() {\n      return size((this as unknown) as IterableCollections, true)\n    },\n    has(this: MapTypes, key: unknown) {\n      return has.call(this, key, true)\n    },\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\n    set: createReadonlyMethod(TriggerOpTypes.SET),\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\n    forEach: createForEach(true, false)\n  }\n  // shallowReadOnly\n  const shallowReadonlyInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key, true, true)\n    },\n    get size() {\n      return size((this as unknown) as IterableCollections, true)\n    },\n    has(this: MapTypes, key: unknown) {\n      return has.call(this, key, true)\n    },\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\n    set: createReadonlyMethod(TriggerOpTypes.SET),\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\n    forEach: createForEach(true, true)\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n\n\n\n# get\n\n\n# size\n\n\n# has\n\n\n# add\n\n\n# set\n\n\n# delete\n\n\n# clear\n\n\n# forEach\n\n\n# Q&A\n\n\n# Proxy Handlers \n\n      HANDLER\nread    get | has | ownKeys\nwrite   set | deleteProperty\n\n\n#  Tree Shaking\n\n\n\n\n\n *  I/O \n *  \n\n Tree Shaking\n\nTree Shaking JavaScript  (dead-code)\n\n Tree Shaking\n\n/*#__PURE__*/  Tree Shaking \n\n\n\n * Wiki: Pure function\n *  JavaScript Pure Function\n * Webpack: Tree Shaking\n\n\n# Proxy \n\n\n\nconst arr = [1,2,3];\nconst proxy = new Proxy(arr, {\n  get: function (target, key, receiver) {\n      console.log('getkey ===> ' + key);\n      return Reflect.get(target, key, receiver);\n  },\n  set(target, key, value, receiver){\n      console.log('setkey ===> ' + key, value);\n      return Reflect.set(target, key, value, receiver);\n  }\n})\n//  console \nproxy[0]\n//>> getkey ===> 0\nproxy[3] = 12\n//>> setkey ===> 3 12\nproxy.includes(1)\n// >> getkey ===> includes\n// >> getkey ===> length\n// >> getkey ===> 0\nproxy.indexOf(2)\n// >> getkey ===> indexOf\n// >> getkey ===> length\n// >> getkey ===> 0\n// >> getkey ===> 1\n\nproxy.pop()\n// >> getkey ===> pop\n// >> getkey ===> length\n// >> getkey ===> 3\n// >> setkey ===> length 3\nproxy.push(4)\n// >> getkey ===> push\n// >> getkey ===> length\n// >> setkey ===> 3 4\n// >> setkey ===> length 4\nproxy.slice(0,1)\n//  >> getkey ===> slice\n//  >> getkey ===> length\n//  >> getkey ===> constructor\n//  >> getkey ===> 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n\n * Proxy  Proxy API \n * identity-sensitive Array methods  get () set (); length-altering mutation methods  get ()  set ()\n *  get ()  track () set ()  trigger () track ()  trigger ()\n *  receiver  target  proxy  Proxy  Reflect \n\n\n# Proxy  MapSet \n\n get ()add ()  this \n\n\n\nconst m = new Map([[\"name\", 'any']]);\nconst p = new Proxy(m, {\n  get(target, key, receiver) {\n    const v = Reflect.get(...arguments);\n    console.log({key, v}, this);\n    return v;\n  }\n})\np.get(\"name\");\n// >> {key: \"get\", v: }key: \"get\"v:  ()arguments: (...)caller: (...)length: 1name: \"get\"[[Prototype]]:  ()[[Scopes]]: Scopes[0][[Prototype]]: Object {get: }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n Uncaught TypeError: Method Map.prototype.get called on incompatible receiver #<Map>  this  get ()v  v  this  target target \n\nconst m = new Map([[\"name\", 'any']]);\nconst p = new Proxy(m, {\n  get(target, key, receiver) {\n    const v = Reflect.get(...arguments);\n    console.log({key, v}, this);\n    return typeof v === \"function\" ? v.bind(target) : v;\n  }\n})\np.get(\"name\");\n// >> \"any\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n Map \n\n\n# \n\n\n# \n\n * MDN: Proxy() constructor",normalizedContent:"# \n\n\n\n * \n * basehandlers\n   * get\n   * set\n   * deleteproperty\n   * has\n   * ownkeys\n   * shallowget\n   * shallowset\n   * readonlyget\n   * shallowreadonlyget\n * collectionhandlers\n   * createinstrumentationgetter\n   * createinstrumentations\n   * get\n   * size\n   * has\n   * add\n   * set\n   * delete\n   * clear\n   * foreach\n * q&a\n   * proxy handlers \n   *  tree shaking\n   * proxy\n   * proxy  mapset \n * \n * \n\n\n\n>  reactive  reactive object  handler basehandlers  collectionhandlers  handler  reactive  creative object \n\n\n# basehandlers\n\nbasehandlers  reactivity/basehandlers.tsbasehandlers  arrayobject \n\n\n# get\n\n handler \n\nconst get = /*#__pure__*/ creategetter()\nfunction creategetter(isreadonly = false, shallow = false) {\n  return function get(target: target, key: string | symbol, receiver: object) {\n    // __v_isreactive  __v_isreactive__v_raw \n    //  get  reactive  readonly\n    //  target \n    if (key === reactiveflags.is_reactive) {\n      return !isreadonly\n    } else if (key === reactiveflags.is_readonly) {\n      return isreadonly\n    } else if (\n      key === reactiveflags.raw &&\n      receiver ===\n        (isreadonly\n          ? shallow\n            ? shallowreadonlymap\n            : readonlymap\n          : shallow\n            ? shallowreactivemap\n            : reactivemap\n        )\n          //  __v_raw  receiver proxymap  target\n          //  target  raw object\n          //  receiver === proxymap.get(target) receiver  proxy objecttarget  raw object\n          .get(target)\n    ) {\n      return target\n    }\n\n    const targetisarray = isarray(target)\n    //  readonlytarget  key  arrayinstrumentations \n    //  target \n    if (!isreadonly && targetisarray && hasown(arrayinstrumentations, key)) {\n      return reflect.get(arrayinstrumentations, key, receiver)\n    }\n    //  target[key],\n    const res = reflect.get(target, key, receiver)\n    //  key  symbol  key \n    if (issymbol(key) ? builtinsymbols.has(key) : isnontrackablekeys(key)) {\n      return res\n    }\n    // reactive target target.key \n    //  ref \n    if (!isreadonly) {\n      track(target, trackoptypes.get, key)\n    }\n    //  shallow \n    if (shallow) {\n      return res\n    }\n    //  ref unwrapping\n    if (isref(res)) {\n      // ref unwrapping - does not apply for array + integer key.\n      // target  key  string int  '1', \n      const shouldunwrap = !targetisarray || !isintegerkey(key)\n      return shouldunwrap ? res.value : res\n    }\n    // typeof [] === \"object\"\n    // \n    if (isobject(res)) {\n      // convert returned value into a proxy as well. we do the isobject check\n      // here to avoid invalid value warning. also need to lazy access readonly\n      // and reactive here to avoid circular dependency.\n      //  proxy deep proxy\n      return isreadonly ? readonly(res) : reactive(res)\n    }\n    // \n    return res\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n * /*#__pure__*/  creategetter  tree shaking tree shaking\n * creategetter  getter setter \n\n *  proxy  __v_raw  proxy object  proxymap target  target  raw target  handlers.get () \n *  object  track  track track proxy api  proxy  proxy api  object keys  track  hack  arrayinstrumentations \n *  reflect.get  receiver reflect.get receiver  this stackoverflow: javascript: difference between reflect.get() and obj['foo']\n *  ref ref unwrapping only happens when nested inside a reactive object. there is no unwrapping performed when the ref is accessed from an array or a native collection type like mapvue3: ref-unwrapping\n\n\n\n\n\n\nif (!isreadonly) {\n  track(target, trackoptypes.get, key)\n}\n\nif (isobject(res)) {\n  // convert returned value into a proxy as well. we do the isobject check\n  // here to avoid invalid value warning. also need to lazy access readonly\n  // and reactive here to avoid circular dependency.\n  //  proxy deep proxy\n  return isreadonly ? readonly(res) : reactive(res)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\n *  readonly  track  get handler readonly  readonly !== none reactivityreadonly \n * isobject  object  array readonly  reactive deep proxy deep reactivity \n\n - handler.get()\n\nhandler.get () \n\nvar p = new proxy(target, {\n  get: function(target, property, receiver) {\n  }\n});\n\n\n1\n2\n3\n4\n\n\n get this  handler .\n\n * target\n * property\n * receiverproxy  proxy \n\nmdn: handler.get()\n\n - reflect  reflect.get()\n\nreflect  javascript  proxy handlers (en-us) reflect reflect  math reflect  proxy handler methods (en-us) .reflect  ie reflect \n\nreflect.get ()  (target [propertykey]) \n\nreflect.get(target, propertykey[, receiver])\n\n\n1\n\n * target\n * propertykey\n * receiver proxy  receiver  target  getterreceiver  getter  this \n\n\n\n * mdn: reflect\n * reflect.get()\n * js  reflect \n *  javascript  proxy  reflect\n\n# arrayinstrumentations\n\narrayinstrumentations  createarrayinstrumentations \n\nconst arrayinstrumentations = /*#__pure__*/ createarrayinstrumentations()\n// (hack)\nfunction createarrayinstrumentations() {\n  const instrumentations: record<string, function> = {}\n  // instrument identity-sensitive array methods to account for possible reactive\n  // values\n  //  hack\n  ;(['includes', 'indexof', 'lastindexof'] as const).foreach(key => {\n    // \n    const method = array.prototype[key] as any\n    // this  receiver  receiver  receiver  target\n    //  this  target \n    instrumentations[key] = function(this: unknown[], ...args: unknown[]) {\n      //  row valuereceiver  proxy object\n      const arr = toraw(this)\n      //  track\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, trackoptypes.get, i + '')\n      }\n      // we run the method using the original args first (which may be reactive)\n      //  row vlaue\n      const res = method.apply(arr, args)\n      if (res === -1 || res === false) {\n        // if that didn't work, run it again using raw values.\n        //  proxy value raw value\n        return method.apply(arr, args.map(toraw))\n      } else {\n        return res\n      }\n    }\n  })\n  // instrument length-altering mutation methods to avoid length being tracked\n  // which leads to infinite loops in some cases (#2137)\n  //  hack\n  //  track \n  ;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).foreach(key => {\n    const method = array.prototype[key] as any\n    instrumentations[key] = function(this: unknown[], ...args: unknown[]) {\n      //  track track \n      //  this  raw object track trigger \n      pausetracking()\n      const res = method.apply(this, args)\n      resettracking()\n      return res\n    }\n  })\n  return instrumentations\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n *  hack 'includes', 'indexof', 'lastindexof'  identity-sensitive array methods track  'push', 'pop', 'shift', 'unshift', 'splice'  length-altering mutation methods track track proxy \n *  track  2  trigger raw object track track  proxy object trigger track\n\n\n# set\n\n handler \n\nconst set = /*#__pure__*/ createsetter()\nfunction createsetter(shallow = false) {\n  return function set(\n    target: object, // raw target object\n    key: string | symbol, // target property\n    value: unknown, // new value for property\n    receiver: object // proxy target object\n  ): boolean {\n    // \n    let oldvalue = (target as any)[key]\n    if (!shallow) {\n      // value  raw value\n      value = toraw(value)\n      oldvalue = toraw(oldvalue)\n      //  target  ref  ref  ref\n      //  return  trigger\n      if (!isarray(target) && isref(oldvalue) && !isref(value)) {\n        oldvalue.value = value\n        return true\n      }\n    } else {\n      // in shallow mode, objects are set as-is regardless of reactive or not\n    }\n    // key  target  array  int key  key\n    //  key  '-100' isintegerkey \n    const hadkey =\n      isarray(target) && isintegerkey(key)\n        ? number(key) < target.length\n        : hasown(target, key)\n    // \n    const result = reflect.set(target, key, value, receiver)\n    // don't trigger if target is something up in the prototype chain of original\n    //  trigger\n    if (target === toraw(receiver)) {\n      if (!hadkey) {\n        // \n        trigger(target, triggeroptypes.add, key, value)\n      } else if (haschanged(value, oldvalue)) {\n        // \n        trigger(target, triggeroptypes.set, key, value, oldvalue)\n      }\n    }\n    return result\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n *  shallow   target  ref  ref  ref.value  return  trigger  ref  trigger  ref \n * target === toraw(receiver)  receiver  target  proxy  trigger target  set  trigger\n *  hadkey  add  set effects track  trigger  effect \n\n\n\nget ()  track ()set ()  trigger () ref  getter  tracksetter  trigger get  set  track  trigger  vue \n\n\n# deleteproperty\n\n handler \n\nfunction deleteproperty(target: object, key: string | symbol): boolean {\n  const hadkey = hasown(target, key)\n  const oldvalue = (target as any)[key]\n  const result = reflect.deleteproperty(target, key)\n  // key  trigger delete\n  if (result && hadkey) {\n    trigger(target, triggeroptypes.delete, key, undefined, oldvalue)\n  }\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# has\n\n handler \n\nfunction has(target: object, key: string | symbol): boolean {\n  const result = reflect.has(target, key)\n  //  key  sumbol builtinsymbols  track\n  if (!issymbol(key) || !builtinsymbols.has(key)) {\n    track(target, trackoptypes.has, key)\n  }\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nhas  track\n\n\n\nhandler.has ()  the handler.has () method is a trap for the in operator.\n\nmdn: handler.has()\n\n\n# ownkeys\n\n handler  symbol \n\nfunction ownkeys(target: object): (string | symbol)[] {\n  //  track iteratekey  prod \n  track(target, trackoptypes.iterate, isarray(target) ? 'length' : iterate_key)\n  return reflect.ownkeys(target)\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n\nhandler.ownkeys () ownkeys  object.keys() \n\nmdn: handler.ownkeys()\n\n\n# shallowget\n\n hallowreactive\n\nconst shallowget = /*#__pure__*/ creategetter(false, true)\n\n\n1\n\n\n track  deep reactivity\n\n\n# shallowset\n\n shallowreactive\n\nconst shallowset = /*#__pure__*/ createsetter(true)\n\n\n1\n\n\n set \n\n\n# readonlyget\n\n readonly\n\nconst readonlyget = /*#__pure__*/ creategetter(true)\n\n\n1\n\n\n track  deep readonly\n\n\n# shallowreadonlyget\n\n shallowreadonly\n\nconst shallowreadonlyget = /*#__pure__*/ creategetter(true, true)\n\n\n1\n\n\n track \n\n\n# collectionhandlers\n\ncollectionhandlers  reactivity/collectionhandlers.tscollectionhandlers  mapsetweaksetweakmap \n\n\n# createinstrumentationgetter\n\n reactivereadonlyshallowreactive  shallowreadonly  api\n\nfunction createinstrumentationgetter(isreadonly: boolean, shallow: boolean) {\n  //  isreadonly  shallow  instrumentations\n  const instrumentations = shallow\n    ? isreadonly\n      ? shallowreadonlyinstrumentations\n      : shallowinstrumentations\n    : isreadonly\n      ? readonlyinstrumentations\n      : mutableinstrumentations\n\n  return (\n    target: collectiontypes,\n    key: string | symbol,\n    receiver: collectiontypes\n  ) => {\n    // buildin \n    if (key === reactiveflags.is_reactive) {\n      return !isreadonly\n    } else if (key === reactiveflags.is_readonly) {\n      return isreadonly\n    } else if (key === reactiveflags.raw) {\n      return target\n    }\n\n    //  instrumentations  target \n    return reflect.get(\n      hasown(instrumentations, key) && key in target\n        ? instrumentations\n        : target,\n      key,\n      receiver\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n return  key  instrumentations  instrumentations  target  collectiontypes get handlerproxy \n\nconst m = new map([[\"name\", 'any']]);\nconst p = new proxy(m, {\n  get(target, key, receiver) {\n    const v = reflect.get(...arguments);\n    console.info('==> get', key);\n    return typeof v === \"function\" ? v.bind(target) : v;\n  },\n  set(target, key, receiver) {\n    const v = reflect.set(...arguments);\n    console.info('==> set', key);\n    return typeof v === \"function\" ? v.bind(target) : v;\n  },\n})\n//  console \np.get(\"name\");\n// >> ==> get get\np.set('name', 'some')\n// >> ==> get set\np.delete(\"name\")\n// >> ==> get delete\np.clear()\n// >> ==> get clear\np.entries()\n// >> ==> get entries\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n proxy api  get handler  get  key  isreadonly  shallow  instrumentations instrumentations  key \n\n\n# createinstrumentations\n\n isreadonly  shallow  handlers\n\nfunction createinstrumentations() {\n  // reactive\n  const mutableinstrumentations: record<string, function> = {\n    get(this: maptypes, key: unknown) {\n      return get(this, key)\n    },\n    get size() {\n      return size((this as unknown) as iterablecollections)\n    },\n    has,\n    add,\n    set,\n    delete: deleteentry,\n    clear,\n    foreach: createforeach(false, false)\n  }\n  // shallowreactive\n  const shallowinstrumentations: record<string, function> = {\n    get(this: maptypes, key: unknown) {\n      return get(this, key, false, true)\n    },\n    get size() {\n      return size((this as unknown) as iterablecollections)\n    },\n    has,\n    add,\n    set,\n    delete: deleteentry,\n    clear,\n    foreach: createforeach(false, true)\n  }\n  // readonly\n  const readonlyinstrumentations: record<string, function> = {\n    get(this: maptypes, key: unknown) {\n      return get(this, key, true)\n    },\n    get size() {\n      return size((this as unknown) as iterablecollections, true)\n    },\n    has(this: maptypes, key: unknown) {\n      return has.call(this, key, true)\n    },\n    add: createreadonlymethod(triggeroptypes.add),\n    set: createreadonlymethod(triggeroptypes.set),\n    delete: createreadonlymethod(triggeroptypes.delete),\n    clear: createreadonlymethod(triggeroptypes.clear),\n    foreach: createforeach(true, false)\n  }\n  // shallowreadonly\n  const shallowreadonlyinstrumentations: record<string, function> = {\n    get(this: maptypes, key: unknown) {\n      return get(this, key, true, true)\n    },\n    get size() {\n      return size((this as unknown) as iterablecollections, true)\n    },\n    has(this: maptypes, key: unknown) {\n      return has.call(this, key, true)\n    },\n    add: createreadonlymethod(triggeroptypes.add),\n    set: createreadonlymethod(triggeroptypes.set),\n    delete: createreadonlymethod(triggeroptypes.delete),\n    clear: createreadonlymethod(triggeroptypes.clear),\n    foreach: createforeach(true, true)\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n\n\n\n# get\n\n\n# size\n\n\n# has\n\n\n# add\n\n\n# set\n\n\n# delete\n\n\n# clear\n\n\n# foreach\n\n\n# q&a\n\n\n# proxy handlers \n\n      handler\nread    get | has | ownkeys\nwrite   set | deleteproperty\n\n\n#  tree shaking\n\n\n\n\n\n *  i/o \n *  \n\n tree shaking\n\ntree shaking javascript  (dead-code)\n\n tree shaking\n\n/*#__pure__*/  tree shaking \n\n\n\n * wiki: pure function\n *  javascript pure function\n * webpack: tree shaking\n\n\n# proxy \n\n\n\nconst arr = [1,2,3];\nconst proxy = new proxy(arr, {\n  get: function (target, key, receiver) {\n      console.log('getkey ===> ' + key);\n      return reflect.get(target, key, receiver);\n  },\n  set(target, key, value, receiver){\n      console.log('setkey ===> ' + key, value);\n      return reflect.set(target, key, value, receiver);\n  }\n})\n//  console \nproxy[0]\n//>> getkey ===> 0\nproxy[3] = 12\n//>> setkey ===> 3 12\nproxy.includes(1)\n// >> getkey ===> includes\n// >> getkey ===> length\n// >> getkey ===> 0\nproxy.indexof(2)\n// >> getkey ===> indexof\n// >> getkey ===> length\n// >> getkey ===> 0\n// >> getkey ===> 1\n\nproxy.pop()\n// >> getkey ===> pop\n// >> getkey ===> length\n// >> getkey ===> 3\n// >> setkey ===> length 3\nproxy.push(4)\n// >> getkey ===> push\n// >> getkey ===> length\n// >> setkey ===> 3 4\n// >> setkey ===> length 4\nproxy.slice(0,1)\n//  >> getkey ===> slice\n//  >> getkey ===> length\n//  >> getkey ===> constructor\n//  >> getkey ===> 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n\n * proxy  proxy api \n * identity-sensitive array methods  get () set (); length-altering mutation methods  get ()  set ()\n *  get ()  track () set ()  trigger () track ()  trigger ()\n *  receiver  target  proxy  proxy  reflect \n\n\n# proxy  mapset \n\n get ()add ()  this \n\n\n\nconst m = new map([[\"name\", 'any']]);\nconst p = new proxy(m, {\n  get(target, key, receiver) {\n    const v = reflect.get(...arguments);\n    console.log({key, v}, this);\n    return v;\n  }\n})\np.get(\"name\");\n// >> {key: \"get\", v: }key: \"get\"v:  ()arguments: (...)caller: (...)length: 1name: \"get\"[[prototype]]:  ()[[scopes]]: scopes[0][[prototype]]: object {get: }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n uncaught typeerror: method map.prototype.get called on incompatible receiver #<map>  this  get ()v  v  this  target target \n\nconst m = new map([[\"name\", 'any']]);\nconst p = new proxy(m, {\n  get(target, key, receiver) {\n    const v = reflect.get(...arguments);\n    console.log({key, v}, this);\n    return typeof v === \"function\" ? v.bind(target) : v;\n  }\n})\np.get(\"name\");\n// >> \"any\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n map \n\n\n# \n\n\n# \n\n * mdn: proxy() constructor",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"Effect",frontmatter:{title:"Effect",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/basic/effect/",categories:["vue3","reactivity"],tags:[null]},regularPath:"/20.vue3/20.reactivity/40.effect.html",relativePath:"20.vue3/20.reactivity/40.effect.md",key:"v-7c3809bd",path:"/vue3/basic/effect/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"effects",slug:"effects",normalizedTitle:"effects",charIndex:17},{level:2,title:"track",slug:"track",normalizedTitle:"track",charIndex:28},{level:2,title:"trigger",slug:"trigger",normalizedTitle:"trigger",charIndex:37},{level:2,title:"track ",slug:"track-",normalizedTitle:"track ",charIndex:48},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:64},{level:3,title:"effect ",slug:"effect-",normalizedTitle:"effect ",charIndex:74},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:87}],readingTime:{text:"9 min read",minutes:8.28,time:496799.99999999994,words:1656},headersStr:" effects track trigger track   effect  ",content:"# \n\n\n\n * \n * effects\n * track\n * trigger\n * track \n * \n   * effect \n * \n\n\n\n\n# effects\n\n effect  effect fn ()  effect \n\nexport function effect<T = any>(\n  fn: () => T, //  effect \n  options: ReactiveEffectOptions = EMPTY_OBJ //  effect \n): ReactiveEffect<T> {\n  if (isEffect(fn)) {\n    //  effect  raw fn  effect\n    fn = fn.raw\n  }\n  //  effect\n  const effect = createReactiveEffect(fn, options)\n  //  lazy effect \n  //  effect \n  if (!options.lazy) {\n    effect()\n  }\n  return effect\n}\nexport function isEffect(fn: any): fn is ReactiveEffect {\n  //  _isEffect  effect \n  return fn && fn._isEffect === true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n createReactiveEffect  effect\n\n effect\n\nexport interface ReactiveEffect<T = any> {\n  (): T\n  _isEffect: true //  effect isEffect \n  id: number // effect id\n  active: boolean //  stop  effect \n  raw: () => T // \n  deps: Array<Dep> //  effect  Array<Set> Set  Map<key, effect>\n  options: ReactiveEffectOptions //  effect \n  allowRecurse: boolean // \n}\nexport interface ReactiveEffectOptions {\n  lazy?: boolean //  effect \n  scheduler?: (job: ReactiveEffect) => void // effect  effect \n  onTrack?: (event: DebuggerEvent) => void //  dev  track track \n  onTrigger?: (event: DebuggerEvent) => void //  dev  trigger run effect \n  onStop?: () => void // stop effect \n  allowRecurse?: boolean // \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n createReactiveEffect \n\n//  effect \nconst effectStack: ReactiveEffect[] = []\nfunction createReactiveEffect<T = any>(\n  fn: () => T,\n  options: ReactiveEffectOptions\n): ReactiveEffect<T> {\n  //  fn  effecteffect  function\n  const effect = function reactiveEffect(): unknown {\n    //  effect effect\n    //  effect  stop \n    //  scheduled effect stop  track\n    // effect  effect \n    if (!effect.active) {\n      return fn()\n    }\n    //  effect  effect effect \n    if (!effectStack.includes(effect)) {\n      //  effect effect \n      //  effect  effect \n      cleanup(effect)\n      try {\n        // \n        enableTracking()\n        //  effect \n        effectStack.push(effect)\n        //  effect  effect\n        activeEffect = effect\n        // \n        return fn()\n      } finally {\n        //  fn  effect\n        //  effect \n        effectStack.pop()\n        //  track \n        resetTracking()\n        // activeEffect  effect\n        activeEffect = effectStack[effectStack.length - 1]\n      }\n    }\n  } as ReactiveEffect\n  effect.id = uid++\n  // \n  effect.allowRecurse = !!options.allowRecurse\n  effect._isEffect = true\n  // effect \n  effect.active = true\n  effect.raw = fn\n  effect.deps = []\n  effect.options = options\n  return effect\n}\n\nfunction cleanup(effect: ReactiveEffect) {\n  //  effect \n  const { deps } = effect\n  if (deps.length) {\n    //  key \n    for (let i = 0; i < deps.length; i++) {\n      //  effect \n      deps[i].delete(effect)\n    }\n    //  effect.deps\n    deps.length = 0\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n\n\n 1. effect.active  effect \n\nstop  effect.active  onStop \n\nexport function stop(effect: ReactiveEffect) {\n  if (effect.active) {\n    cleanup(effect)\n    if (effect.options.onStop) {\n      effect.options.onStop()\n    }\n    effect.active = false\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n effect  stop  trigger effect  effect \n\n 2. effectStack \n\neffectStack  effect effect \n\n\n# track\n\ntrack  target track \n\n// \nexport function track(target: object, type: TrackOpTypes, key: unknown) {\n  //  type  prod \n  // shouldTrack  activeEffect === undefined  effect\n  if (!shouldTrack || activeEffect === undefined) {\n    return\n  }\n  //  target Map<target, Map<key, Set>>\n  // targetMap  depsMap  dep  activeEffect\n  let depsMap = targetMap.get(target)\n  // \n  if (!depsMap) {\n    targetMap.set(target, (depsMap = new Map()))\n  }\n  let dep = depsMap.get(key)\n  if (!dep) {\n    depsMap.set(key, (dep = new Set()))\n  }\n  //  effect  activeEffect.deps dep\n  // activeEffect  effect\n  if (!dep.has(activeEffect)) {\n    dep.add(activeEffect)\n    activeEffect.deps.push(dep)\n    if (__DEV__ && activeEffect.options.onTrack) {\n      activeEffect.options.onTrack({\n        effect: activeEffect,\n        target,\n        type,\n        key\n      })\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n *  track track  enable  effect\n * depsMap  Map<target, Map<key, Set>> map-map-set \n\n\n# trigger\n\ntrigger  target  effect ()trigger \n\nexport function trigger(\n  target: object,\n  type: TriggerOpTypes,\n  key?: unknown,\n  newValue?: unknown,\n  oldValue?: unknown,\n  oldTarget?: Map<unknown, unknown> | Set<unknown>\n) {\n  //  target Map<target, Map<key, Set>>\n  const depsMap = targetMap.get(target)\n  // \n  if (!depsMap) {\n    // never been tracked\n    return\n  }\n  // \n  const effects = new Set<ReactiveEffect>()\n  // add  key set  effect  effects \n  const add = (effectsToAdd: Set<ReactiveEffect> | undefined) => {\n    if (effectsToAdd) {\n      effectsToAdd.forEach(effect => {\n        //  effect  effect \n        if (effect !== activeEffect || effect.allowRecurse) {\n          // \n          effects.add(effect)\n        }\n      })\n    }\n  }\n\n  //  CLEAR \n  if (type === TriggerOpTypes.CLEAR) {\n    // collection being cleared\n    // trigger all effects for target\n    // Map  forEach  values Set\n    //  target  effect\n    depsMap.forEach(add)\n  } else if (key === 'length' && isArray(target)) {\n    //  target \n    // \n    depsMap.forEach((dep, key) => {\n      // key >= newValue   newValue  key set \n      if (key === 'length' || key >= (newValue as number)) {\n        //  set \n        add(dep)\n      }\n    })\n  } else {\n    // schedule runs for SET | ADD | DELETE\n    // void 0 returns undefined and can not be overwritten while undefined can be overwritten.\n    //  see https://stackoverflow.com/questions/7452341/what-does-void-0-mean\n    //  key === undefined key  Set\n    //  key set\n    if (key !== void 0) {\n      add(depsMap.get(key))\n    }\n\n    // also run for iteration key on ADD | DELETE | Map.SET\n    // iteration key  effect\n    switch (type) {\n      // \n      case TriggerOpTypes.ADD:\n        if (!isArray(target)) {\n          //  target  effect \n          add(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            add(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        } else if (isIntegerKey(key)) {\n          // new index added to array -> length changes\n          //  length\n          add(depsMap.get('length'))\n        }\n        break\n      // \n      case TriggerOpTypes.DELETE:\n        if (!isArray(target)) {\n          add(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            add(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        }\n        // TODO  length\n        break\n      // \n      case TriggerOpTypes.SET:\n        if (isMap(target)) {\n          add(depsMap.get(ITERATE_KEY))\n        }\n        break\n    }\n  }\n\n  //  effect scheduler  scheduler \n  const run = (effect: ReactiveEffect) => {\n    if (__DEV__ && effect.options.onTrigger) {\n      effect.options.onTrigger({\n        effect,\n        target,\n        key,\n        type,\n        newValue,\n        oldValue,\n        oldTarget\n      })\n    }\n    if (effect.options.scheduler) {\n      effect.options.scheduler(effect)\n    } else {\n      effect()\n    }\n  }\n  // \n  effects.forEach(run)\n}\n\nexport const enum TriggerOpTypes {\n  SET = 'set',\n  ADD = 'add',\n  DELETE = 'delete',\n  CLEAR = 'clear'\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n\n * trigger SETADDDELETECLEAR\n *  effect  effect  trigger effects effect  effect ()  cleanUp\n\n\n# track \n\n track \n\nlet shouldTrack = true\n//  shouldTrack \nconst trackStack: boolean[] = []\n\nexport function pauseTracking() {\n  trackStack.push(shouldTrack)\n  shouldTrack = false\n}\n\nexport function enableTracking() {\n  trackStack.push(shouldTrack)\n  shouldTrack = true\n}\n\nexport function resetTracking() {\n  const last = trackStack.pop()\n  shouldTrack = last === undefined ? true : last\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * shouldTrack  track \n * trackStack  track  track \n\n\n# \n\n\n# effect \n\n track  activeEffect activeEffect  effect trigger  track  effect  activeEffect  activeEffect  effect \n\n\n\nit('should observe basic properties', () => {\n  let dummy\n  let temp\n  const counter = reactive({ num: 0 })\n  console.log('==>', 1)\n  effect(() => (dummy = counter.num))\n  console.log('==>', 2)\n  effect(() => (temp = counter.num * 2))\n  console.log('==>', 3)\n\n  expect(dummy).toBe(0)\n  console.log('==>', 4)\n  expect(counter.num).toBe(0)\n  console.log('==>', 5)\n  counter.num = 7\n  console.log('==>', 6)\n  expect(dummy).toBe(7)\n  console.log('==>', 7)\n  expect(temp).toBe(14)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n jest \n\n//  reactive target  proxy\n==> createReactiveObject { target: { num: 0 } }\n\n==> 1\n//  target  effect \n==> createReactiveEffect [Arguments] { '0': [Function], '1': {} }\n//  effect get handler\n==> get { target: { num: 0 }, key: 'num' }\n// get  track  Map<{ num: 0 }, Map<num, Set<effect>>> effect  Set \n//  get  track activeEffect  effect\n==> track [Arguments] { '0': { num: 0 }, '1': 'get', '2': 'num' } { activeEffect:\n   { [Function: reactiveEffect]\n     id: 0,\n     allowRecurse: false,\n     _isEffect: true,\n     active: true,\n     raw: [Function],\n     deps: [],\n     options: {} } }\n\n==> 2\n//  effect\n==> createReactiveEffect [Arguments] { '0': [Function], '1': {} }\n//  get\n==> get { target: { num: 0 }, key: 'num' }\n// get handler activeEffect \n==> track [Arguments] { '0': { num: 0 }, '1': 'get', '2': 'num' } { activeEffect:\n   { [Function: reactiveEffect]\n     id: 1,\n     allowRecurse: false,\n     _isEffect: true,\n     active: true,\n     raw: [Function],\n     deps: [],\n     options: {} } }\n\n==> 3\n// \n==> 4\n//  get handler\n==> get { target: { num: 0 }, key: 'num' }\n//  effect\n==> track [Arguments] { '0': { num: 0 }, '1': 'get', '2': 'num' } { activeEffect: undefined }\n\n==> 5\n//  set handler\n==> set { target: { num: 0 }, key: 'num' }\n//  value  toRaw get handlerkey  __v_rawbuiltin  track\n==> get { target: { num: 7 }, key: '__v_raw' }\n// set handler  triggerkey  numbernewValue  7\n// depsMap.get(target).get(key)  effect\n==> trigger [Arguments] { '0': { num: 7 }, '1': 'set', '2': 'num', '3': 7, '4': 0 }\n//  get handlerdummy\n==> get { target: { num: 7 }, key: 'num' }\n// \n//  effect  cleanup\n==> track [Arguments] { '0': { num: 7 }, '1': 'get', '2': 'num' } { activeEffect:\n   { [Function: reactiveEffect]\n     id: 0,\n     allowRecurse: false,\n     _isEffect: true,\n     active: true,\n     raw: [Function],\n     deps: [],\n     options: {} } }\n//  get handler temp\n==> get { target: { num: 7 }, key: 'num' }\n// \n==> track [Arguments] { '0': { num: 7 }, '1': 'get', '2': 'num' } { activeEffect:\n   { [Function: reactiveEffect]\n     id: 1,\n     allowRecurse: false,\n     _isEffect: true,\n     active: true,\n     raw: [Function],\n     deps: [],\n     options: {} } }\n\n==> 6\n// \n\n==> 7\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n\n\n effect \n\n * effect  effect lazy effect  get handler effect track activeEffect  track  effect  activeEffect   effect \n * effect  cleanup effect  effect get handler effect  track\n\n\n# \n\n effect  track  refreactive  api effect  api effect  track  trigger     target  key target",normalizedContent:"# \n\n\n\n * \n * effects\n * track\n * trigger\n * track \n * \n   * effect \n * \n\n\n\n\n# effects\n\n effect  effect fn ()  effect \n\nexport function effect<t = any>(\n  fn: () => t, //  effect \n  options: reactiveeffectoptions = empty_obj //  effect \n): reactiveeffect<t> {\n  if (iseffect(fn)) {\n    //  effect  raw fn  effect\n    fn = fn.raw\n  }\n  //  effect\n  const effect = createreactiveeffect(fn, options)\n  //  lazy effect \n  //  effect \n  if (!options.lazy) {\n    effect()\n  }\n  return effect\n}\nexport function iseffect(fn: any): fn is reactiveeffect {\n  //  _iseffect  effect \n  return fn && fn._iseffect === true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n createreactiveeffect  effect\n\n effect\n\nexport interface reactiveeffect<t = any> {\n  (): t\n  _iseffect: true //  effect iseffect \n  id: number // effect id\n  active: boolean //  stop  effect \n  raw: () => t // \n  deps: array<dep> //  effect  array<set> set  map<key, effect>\n  options: reactiveeffectoptions //  effect \n  allowrecurse: boolean // \n}\nexport interface reactiveeffectoptions {\n  lazy?: boolean //  effect \n  scheduler?: (job: reactiveeffect) => void // effect  effect \n  ontrack?: (event: debuggerevent) => void //  dev  track track \n  ontrigger?: (event: debuggerevent) => void //  dev  trigger run effect \n  onstop?: () => void // stop effect \n  allowrecurse?: boolean // \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n createreactiveeffect \n\n//  effect \nconst effectstack: reactiveeffect[] = []\nfunction createreactiveeffect<t = any>(\n  fn: () => t,\n  options: reactiveeffectoptions\n): reactiveeffect<t> {\n  //  fn  effecteffect  function\n  const effect = function reactiveeffect(): unknown {\n    //  effect effect\n    //  effect  stop \n    //  scheduled effect stop  track\n    // effect  effect \n    if (!effect.active) {\n      return fn()\n    }\n    //  effect  effect effect \n    if (!effectstack.includes(effect)) {\n      //  effect effect \n      //  effect  effect \n      cleanup(effect)\n      try {\n        // \n        enabletracking()\n        //  effect \n        effectstack.push(effect)\n        //  effect  effect\n        activeeffect = effect\n        // \n        return fn()\n      } finally {\n        //  fn  effect\n        //  effect \n        effectstack.pop()\n        //  track \n        resettracking()\n        // activeeffect  effect\n        activeeffect = effectstack[effectstack.length - 1]\n      }\n    }\n  } as reactiveeffect\n  effect.id = uid++\n  // \n  effect.allowrecurse = !!options.allowrecurse\n  effect._iseffect = true\n  // effect \n  effect.active = true\n  effect.raw = fn\n  effect.deps = []\n  effect.options = options\n  return effect\n}\n\nfunction cleanup(effect: reactiveeffect) {\n  //  effect \n  const { deps } = effect\n  if (deps.length) {\n    //  key \n    for (let i = 0; i < deps.length; i++) {\n      //  effect \n      deps[i].delete(effect)\n    }\n    //  effect.deps\n    deps.length = 0\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n\n\n 1. effect.active  effect \n\nstop  effect.active  onstop \n\nexport function stop(effect: reactiveeffect) {\n  if (effect.active) {\n    cleanup(effect)\n    if (effect.options.onstop) {\n      effect.options.onstop()\n    }\n    effect.active = false\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n effect  stop  trigger effect  effect \n\n 2. effectstack \n\neffectstack  effect effect \n\n\n# track\n\ntrack  target track \n\n// \nexport function track(target: object, type: trackoptypes, key: unknown) {\n  //  type  prod \n  // shouldtrack  activeeffect === undefined  effect\n  if (!shouldtrack || activeeffect === undefined) {\n    return\n  }\n  //  target map<target, map<key, set>>\n  // targetmap  depsmap  dep  activeeffect\n  let depsmap = targetmap.get(target)\n  // \n  if (!depsmap) {\n    targetmap.set(target, (depsmap = new map()))\n  }\n  let dep = depsmap.get(key)\n  if (!dep) {\n    depsmap.set(key, (dep = new set()))\n  }\n  //  effect  activeeffect.deps dep\n  // activeeffect  effect\n  if (!dep.has(activeeffect)) {\n    dep.add(activeeffect)\n    activeeffect.deps.push(dep)\n    if (__dev__ && activeeffect.options.ontrack) {\n      activeeffect.options.ontrack({\n        effect: activeeffect,\n        target,\n        type,\n        key\n      })\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n *  track track  enable  effect\n * depsmap  map<target, map<key, set>> map-map-set \n\n\n# trigger\n\ntrigger  target  effect ()trigger \n\nexport function trigger(\n  target: object,\n  type: triggeroptypes,\n  key?: unknown,\n  newvalue?: unknown,\n  oldvalue?: unknown,\n  oldtarget?: map<unknown, unknown> | set<unknown>\n) {\n  //  target map<target, map<key, set>>\n  const depsmap = targetmap.get(target)\n  // \n  if (!depsmap) {\n    // never been tracked\n    return\n  }\n  // \n  const effects = new set<reactiveeffect>()\n  // add  key set  effect  effects \n  const add = (effectstoadd: set<reactiveeffect> | undefined) => {\n    if (effectstoadd) {\n      effectstoadd.foreach(effect => {\n        //  effect  effect \n        if (effect !== activeeffect || effect.allowrecurse) {\n          // \n          effects.add(effect)\n        }\n      })\n    }\n  }\n\n  //  clear \n  if (type === triggeroptypes.clear) {\n    // collection being cleared\n    // trigger all effects for target\n    // map  foreach  values set\n    //  target  effect\n    depsmap.foreach(add)\n  } else if (key === 'length' && isarray(target)) {\n    //  target \n    // \n    depsmap.foreach((dep, key) => {\n      // key >= newvalue   newvalue  key set \n      if (key === 'length' || key >= (newvalue as number)) {\n        //  set \n        add(dep)\n      }\n    })\n  } else {\n    // schedule runs for set | add | delete\n    // void 0 returns undefined and can not be overwritten while undefined can be overwritten.\n    //  see https://stackoverflow.com/questions/7452341/what-does-void-0-mean\n    //  key === undefined key  set\n    //  key set\n    if (key !== void 0) {\n      add(depsmap.get(key))\n    }\n\n    // also run for iteration key on add | delete | map.set\n    // iteration key  effect\n    switch (type) {\n      // \n      case triggeroptypes.add:\n        if (!isarray(target)) {\n          //  target  effect \n          add(depsmap.get(iterate_key))\n          if (ismap(target)) {\n            add(depsmap.get(map_key_iterate_key))\n          }\n        } else if (isintegerkey(key)) {\n          // new index added to array -> length changes\n          //  length\n          add(depsmap.get('length'))\n        }\n        break\n      // \n      case triggeroptypes.delete:\n        if (!isarray(target)) {\n          add(depsmap.get(iterate_key))\n          if (ismap(target)) {\n            add(depsmap.get(map_key_iterate_key))\n          }\n        }\n        // todo  length\n        break\n      // \n      case triggeroptypes.set:\n        if (ismap(target)) {\n          add(depsmap.get(iterate_key))\n        }\n        break\n    }\n  }\n\n  //  effect scheduler  scheduler \n  const run = (effect: reactiveeffect) => {\n    if (__dev__ && effect.options.ontrigger) {\n      effect.options.ontrigger({\n        effect,\n        target,\n        key,\n        type,\n        newvalue,\n        oldvalue,\n        oldtarget\n      })\n    }\n    if (effect.options.scheduler) {\n      effect.options.scheduler(effect)\n    } else {\n      effect()\n    }\n  }\n  // \n  effects.foreach(run)\n}\n\nexport const enum triggeroptypes {\n  set = 'set',\n  add = 'add',\n  delete = 'delete',\n  clear = 'clear'\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n\n * trigger setadddeleteclear\n *  effect  effect  trigger effects effect  effect ()  cleanup\n\n\n# track \n\n track \n\nlet shouldtrack = true\n//  shouldtrack \nconst trackstack: boolean[] = []\n\nexport function pausetracking() {\n  trackstack.push(shouldtrack)\n  shouldtrack = false\n}\n\nexport function enabletracking() {\n  trackstack.push(shouldtrack)\n  shouldtrack = true\n}\n\nexport function resettracking() {\n  const last = trackstack.pop()\n  shouldtrack = last === undefined ? true : last\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * shouldtrack  track \n * trackstack  track  track \n\n\n# \n\n\n# effect \n\n track  activeeffect activeeffect  effect trigger  track  effect  activeeffect  activeeffect  effect \n\n\n\nit('should observe basic properties', () => {\n  let dummy\n  let temp\n  const counter = reactive({ num: 0 })\n  console.log('==>', 1)\n  effect(() => (dummy = counter.num))\n  console.log('==>', 2)\n  effect(() => (temp = counter.num * 2))\n  console.log('==>', 3)\n\n  expect(dummy).tobe(0)\n  console.log('==>', 4)\n  expect(counter.num).tobe(0)\n  console.log('==>', 5)\n  counter.num = 7\n  console.log('==>', 6)\n  expect(dummy).tobe(7)\n  console.log('==>', 7)\n  expect(temp).tobe(14)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n jest \n\n//  reactive target  proxy\n==> createreactiveobject { target: { num: 0 } }\n\n==> 1\n//  target  effect \n==> createreactiveeffect [arguments] { '0': [function], '1': {} }\n//  effect get handler\n==> get { target: { num: 0 }, key: 'num' }\n// get  track  map<{ num: 0 }, map<num, set<effect>>> effect  set \n//  get  track activeeffect  effect\n==> track [arguments] { '0': { num: 0 }, '1': 'get', '2': 'num' } { activeeffect:\n   { [function: reactiveeffect]\n     id: 0,\n     allowrecurse: false,\n     _iseffect: true,\n     active: true,\n     raw: [function],\n     deps: [],\n     options: {} } }\n\n==> 2\n//  effect\n==> createreactiveeffect [arguments] { '0': [function], '1': {} }\n//  get\n==> get { target: { num: 0 }, key: 'num' }\n// get handler activeeffect \n==> track [arguments] { '0': { num: 0 }, '1': 'get', '2': 'num' } { activeeffect:\n   { [function: reactiveeffect]\n     id: 1,\n     allowrecurse: false,\n     _iseffect: true,\n     active: true,\n     raw: [function],\n     deps: [],\n     options: {} } }\n\n==> 3\n// \n==> 4\n//  get handler\n==> get { target: { num: 0 }, key: 'num' }\n//  effect\n==> track [arguments] { '0': { num: 0 }, '1': 'get', '2': 'num' } { activeeffect: undefined }\n\n==> 5\n//  set handler\n==> set { target: { num: 0 }, key: 'num' }\n//  value  toraw get handlerkey  __v_rawbuiltin  track\n==> get { target: { num: 7 }, key: '__v_raw' }\n// set handler  triggerkey  numbernewvalue  7\n// depsmap.get(target).get(key)  effect\n==> trigger [arguments] { '0': { num: 7 }, '1': 'set', '2': 'num', '3': 7, '4': 0 }\n//  get handlerdummy\n==> get { target: { num: 7 }, key: 'num' }\n// \n//  effect  cleanup\n==> track [arguments] { '0': { num: 7 }, '1': 'get', '2': 'num' } { activeeffect:\n   { [function: reactiveeffect]\n     id: 0,\n     allowrecurse: false,\n     _iseffect: true,\n     active: true,\n     raw: [function],\n     deps: [],\n     options: {} } }\n//  get handler temp\n==> get { target: { num: 7 }, key: 'num' }\n// \n==> track [arguments] { '0': { num: 7 }, '1': 'get', '2': 'num' } { activeeffect:\n   { [function: reactiveeffect]\n     id: 1,\n     allowrecurse: false,\n     _iseffect: true,\n     active: true,\n     raw: [function],\n     deps: [],\n     options: {} } }\n\n==> 6\n// \n\n==> 7\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n\n\n effect \n\n * effect  effect lazy effect  get handler effect track activeeffect  track  effect  activeeffect   effect \n * effect  cleanup effect  effect get handler effect  track\n\n\n# \n\n effect  track  refreactive  api effect  api effect  track  trigger     target  key target",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"Computed",frontmatter:{title:"Computed",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/basic/computed/",categories:["vue3","reactivity"],tags:[null]},regularPath:"/20.vue3/20.reactivity/50.computed.html",relativePath:"20.vue3/20.reactivity/50.computed.md",key:"v-47f301c6",path:"/vue3/basic/computed/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"computed",slug:"computed",normalizedTitle:"computed",charIndex:17},{level:2,title:"ComputedRefImpl",slug:"computedrefimpl",normalizedTitle:"computedrefimpl",charIndex:29},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:48}],readingTime:{text:"5 min read",minutes:4.185,time:251099.99999999997,words:837},headersStr:" computed ComputedRefImpl ",content:"# \n\n\n\n * \n * computed\n * ComputedRefImpl\n * \n\n\n\n\n# computed\n\n\n\nTakes a getter function and returns an immutable () reactive ref object for the returned value from the getter.Alternatively, it can take an object with get and set functions to create a writable ref object.  getter  getter  ref  get  set  ref \n\n// \nexport function computed<T>(getter: ComputedGetter<T>): ComputedRef<T>\nexport function computed<T>(\n  options: WritableComputedOptions<T>\n): WritableComputedRef<T>\nexport function computed<T>(\n  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>\n) {\n  let getter: ComputedGetter<T>\n  let setter: ComputedSetter<T>\n  //  getter  setter\n  if (isFunction(getterOrOptions)) {\n    // \n    getter = getterOrOptions\n    setter = __DEV__\n      ? () => {\n          console.warn('Write operation failed: computed value is readonly')\n        }\n      : NOOP\n  } else {\n    // \n    getter = getterOrOptions.get\n    setter = getterOrOptions.set\n  }\n\n  return new ComputedRefImpl(\n    getter,\n    setter,\n    isFunction(getterOrOptions) || !getterOrOptions.set\n  ) as any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\ncomputed  ComputedRefImpl  getter  setter ref \n\n\n# ComputedRefImpl\n\n computedRef \n\nclass ComputedRefImpl<T> {\n  private _value!: T\n  private _dirty = true // \n\n  public readonly effect: ReactiveEffect<T>\n\n  public readonly __v_isRef = true;\n  public readonly [ReactiveFlags.IS_READONLY]: boolean\n\n  constructor(\n    getter: ComputedGetter<T>,\n    private readonly _setter: ComputedSetter<T>,\n    isReadonly: boolean\n  ) {\n    //  lazy effect\n    this.effect = effect(getter, {\n      // \n      lazy: true, //  effect \n      // _dirty \n      //  effect \n      scheduler: () => {\n        if (!this._dirty) {\n          this._dirty = true\n          trigger(toRaw(this), TriggerOpTypes.SET, 'value')\n        }\n      }\n    })\n\n    this[ReactiveFlags.IS_READONLY] = isReadonly\n  }\n\n  get value() {\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n    //  proxy\n    const self = toRaw(this)\n    //  effect\n    if (self._dirty) {\n      self._value = this.effect()\n      self._dirty = false\n    }\n    // \n    track(self, TrackOpTypes.GET, 'value')\n    return self._value\n  }\n\n  set value(newValue: T) {\n    //  _setter\n    this._setter(newValue)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n ref \n\n *  effect  lazy effect\n\n computed \n\nit('should return updated value', () => {\n  const value = reactive<{ foo?: number }>({})\n  console.log('==> 1')\n  const cValue = computed(() => value.foo)\n  let temp\n  console.log('==> 2')\n  effect(() => (temp = cValue.value))\n  console.log('==> 3')\n  expect(cValue.value).toBe(undefined)\n  console.log('==> 4')\n  value.foo = 1\n  console.log('==> 5')\n  expect(cValue.value).toBe(1)\n  console.log('==> 6')\n  expect(temp).toBe(1)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n//  reactive \n==> createReactiveObject { target: {} }\n\n==> 1\n//  ComputedRefImpl  effect effect()\n==> createReactiveEffect [Arguments] {\n  '0': [Function],\n  '1': { lazy: true, scheduler: [Function: scheduler] } }\n\n==> 2\n\n==> createReactiveEffect [Arguments] { '0': [Function], '1': {} }\n\n==> ComputedRefImpl get { _dirty: true }\n\n==> get { target: {}, key: 'foo' }\n\n==> track [Arguments] { '0': {}, '1': 'get', '2': 'foo' } { activeEffect:\n   { [Function: reactiveEffect]\n     id: 0,\n     allowRecurse: false,\n     _isEffect: true,\n     active: true,\n     raw: [Function],\n     deps: [],\n     options: { lazy: true, scheduler: [Function: scheduler] } } }\n\n==> track [Arguments] {\n  '0':\n   ComputedRefImpl {\n     _setter: [Function],\n     _dirty: false,\n     __v_isRef: true,\n     effect:\n      { [Function: reactiveEffect]\n        id: 0,\n        allowRecurse: false,\n        _isEffect: true,\n        active: true,\n        raw: [Function],\n        deps: [Array],\n        options: [Object] },\n     __v_isReadonly: true,\n     _value: undefined },\n  '1': 'get',\n  '2': 'value' } { activeEffect:\n   { [Function: reactiveEffect]\n     id: 1,\n     allowRecurse: false,\n     _isEffect: true,\n     active: true,\n     raw: [Function],\n     deps: [],\n     options: {} } }\n\n==> 3\n\n==> ComputedRefImpl get { _dirty: false }\n\n==> track [Arguments] {\n  '0':\n   ComputedRefImpl {\n     _setter: [Function],\n     _dirty: false,\n     __v_isRef: true,\n     effect:\n      { [Function: reactiveEffect]\n        id: 0,\n        allowRecurse: false,\n        _isEffect: true,\n        active: true,\n        raw: [Function],\n        deps: [Array],\n        options: [Object] },\n     __v_isReadonly: true,\n     _value: undefined },\n  '1': 'get',\n  '2': 'value' } { activeEffect: undefined }\n\n==> 4\n\n==> set { target: {}, key: 'foo' }\n\n==> get { target: { foo: 1 }, key: '__v_raw' }\n\n==> trigger [Arguments] { '0': { foo: 1 }, '1': 'add', '2': 'foo', '3': 1 }\n\n==> ComputedRefImpl effect scheduler { _dirty: false }\n\n==> trigger [Arguments] {\n  '0':\n   ComputedRefImpl {\n     _setter: [Function],\n     _dirty: true,\n     __v_isRef: true,\n     effect:\n      { [Function: reactiveEffect]\n        id: 0,\n        allowRecurse: false,\n        _isEffect: true,\n        active: true,\n        raw: [Function],\n        deps: [Array],\n        options: [Object] },\n     __v_isReadonly: true,\n     _value: undefined },\n  '1': 'set',\n  '2': 'value' }\n\n==> ComputedRefImpl get { _dirty: true }\n\n==> get { target: { foo: 1 }, key: 'foo' }\n\n==> track [Arguments] { '0': { foo: 1 }, '1': 'get', '2': 'foo' } { activeEffect:\n   { [Function: reactiveEffect]\n     id: 0,\n     allowRecurse: false,\n     _isEffect: true,\n     active: true,\n     raw: [Function],\n     deps: [],\n     options: { lazy: true, scheduler: [Function: scheduler] } } }\n\n==> track [Arguments] {\n  '0':\n   ComputedRefImpl {\n     _setter: [Function],\n     _dirty: false,\n     __v_isRef: true,\n     effect:\n      { [Function: reactiveEffect]\n        id: 0,\n        allowRecurse: false,\n        _isEffect: true,\n        active: true,\n        raw: [Function],\n        deps: [Array],\n        options: [Object] },\n     __v_isReadonly: true,\n     _value: 1 },\n  '1': 'get',\n  '2': 'value' } { activeEffect:\n   { [Function: reactiveEffect]\n     id: 1,\n     allowRecurse: false,\n     _isEffect: true,\n     active: true,\n     raw: [Function],\n     deps: [],\n     options: {} } }\n\n==> 5\n\n==> ComputedRefImpl get { _dirty: false }\n\n==> track [Arguments] {\n  '0':\n   ComputedRefImpl {\n     _setter: [Function],\n     _dirty: false,\n     __v_isRef: true,\n     effect:\n      { [Function: reactiveEffect]\n        id: 0,\n        allowRecurse: false,\n        _isEffect: true,\n        active: true,\n        raw: [Function],\n        deps: [Array],\n        options: [Object] },\n     __v_isReadonly: true,\n     _value: 1 },\n  '1': 'get',\n  '2': 'value' } { activeEffect: undefined }\n\n==> 6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n\n\n\n# ",normalizedContent:"# \n\n\n\n * \n * computed\n * computedrefimpl\n * \n\n\n\n\n# computed\n\n\n\ntakes a getter function and returns an immutable () reactive ref object for the returned value from the getter.alternatively, it can take an object with get and set functions to create a writable ref object.  getter  getter  ref  get  set  ref \n\n// \nexport function computed<t>(getter: computedgetter<t>): computedref<t>\nexport function computed<t>(\n  options: writablecomputedoptions<t>\n): writablecomputedref<t>\nexport function computed<t>(\n  getteroroptions: computedgetter<t> | writablecomputedoptions<t>\n) {\n  let getter: computedgetter<t>\n  let setter: computedsetter<t>\n  //  getter  setter\n  if (isfunction(getteroroptions)) {\n    // \n    getter = getteroroptions\n    setter = __dev__\n      ? () => {\n          console.warn('write operation failed: computed value is readonly')\n        }\n      : noop\n  } else {\n    // \n    getter = getteroroptions.get\n    setter = getteroroptions.set\n  }\n\n  return new computedrefimpl(\n    getter,\n    setter,\n    isfunction(getteroroptions) || !getteroroptions.set\n  ) as any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\ncomputed  computedrefimpl  getter  setter ref \n\n\n# computedrefimpl\n\n computedref \n\nclass computedrefimpl<t> {\n  private _value!: t\n  private _dirty = true // \n\n  public readonly effect: reactiveeffect<t>\n\n  public readonly __v_isref = true;\n  public readonly [reactiveflags.is_readonly]: boolean\n\n  constructor(\n    getter: computedgetter<t>,\n    private readonly _setter: computedsetter<t>,\n    isreadonly: boolean\n  ) {\n    //  lazy effect\n    this.effect = effect(getter, {\n      // \n      lazy: true, //  effect \n      // _dirty \n      //  effect \n      scheduler: () => {\n        if (!this._dirty) {\n          this._dirty = true\n          trigger(toraw(this), triggeroptypes.set, 'value')\n        }\n      }\n    })\n\n    this[reactiveflags.is_readonly] = isreadonly\n  }\n\n  get value() {\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n    //  proxy\n    const self = toraw(this)\n    //  effect\n    if (self._dirty) {\n      self._value = this.effect()\n      self._dirty = false\n    }\n    // \n    track(self, trackoptypes.get, 'value')\n    return self._value\n  }\n\n  set value(newvalue: t) {\n    //  _setter\n    this._setter(newvalue)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n ref \n\n *  effect  lazy effect\n\n computed \n\nit('should return updated value', () => {\n  const value = reactive<{ foo?: number }>({})\n  console.log('==> 1')\n  const cvalue = computed(() => value.foo)\n  let temp\n  console.log('==> 2')\n  effect(() => (temp = cvalue.value))\n  console.log('==> 3')\n  expect(cvalue.value).tobe(undefined)\n  console.log('==> 4')\n  value.foo = 1\n  console.log('==> 5')\n  expect(cvalue.value).tobe(1)\n  console.log('==> 6')\n  expect(temp).tobe(1)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n//  reactive \n==> createreactiveobject { target: {} }\n\n==> 1\n//  computedrefimpl  effect effect()\n==> createreactiveeffect [arguments] {\n  '0': [function],\n  '1': { lazy: true, scheduler: [function: scheduler] } }\n\n==> 2\n\n==> createreactiveeffect [arguments] { '0': [function], '1': {} }\n\n==> computedrefimpl get { _dirty: true }\n\n==> get { target: {}, key: 'foo' }\n\n==> track [arguments] { '0': {}, '1': 'get', '2': 'foo' } { activeeffect:\n   { [function: reactiveeffect]\n     id: 0,\n     allowrecurse: false,\n     _iseffect: true,\n     active: true,\n     raw: [function],\n     deps: [],\n     options: { lazy: true, scheduler: [function: scheduler] } } }\n\n==> track [arguments] {\n  '0':\n   computedrefimpl {\n     _setter: [function],\n     _dirty: false,\n     __v_isref: true,\n     effect:\n      { [function: reactiveeffect]\n        id: 0,\n        allowrecurse: false,\n        _iseffect: true,\n        active: true,\n        raw: [function],\n        deps: [array],\n        options: [object] },\n     __v_isreadonly: true,\n     _value: undefined },\n  '1': 'get',\n  '2': 'value' } { activeeffect:\n   { [function: reactiveeffect]\n     id: 1,\n     allowrecurse: false,\n     _iseffect: true,\n     active: true,\n     raw: [function],\n     deps: [],\n     options: {} } }\n\n==> 3\n\n==> computedrefimpl get { _dirty: false }\n\n==> track [arguments] {\n  '0':\n   computedrefimpl {\n     _setter: [function],\n     _dirty: false,\n     __v_isref: true,\n     effect:\n      { [function: reactiveeffect]\n        id: 0,\n        allowrecurse: false,\n        _iseffect: true,\n        active: true,\n        raw: [function],\n        deps: [array],\n        options: [object] },\n     __v_isreadonly: true,\n     _value: undefined },\n  '1': 'get',\n  '2': 'value' } { activeeffect: undefined }\n\n==> 4\n\n==> set { target: {}, key: 'foo' }\n\n==> get { target: { foo: 1 }, key: '__v_raw' }\n\n==> trigger [arguments] { '0': { foo: 1 }, '1': 'add', '2': 'foo', '3': 1 }\n\n==> computedrefimpl effect scheduler { _dirty: false }\n\n==> trigger [arguments] {\n  '0':\n   computedrefimpl {\n     _setter: [function],\n     _dirty: true,\n     __v_isref: true,\n     effect:\n      { [function: reactiveeffect]\n        id: 0,\n        allowrecurse: false,\n        _iseffect: true,\n        active: true,\n        raw: [function],\n        deps: [array],\n        options: [object] },\n     __v_isreadonly: true,\n     _value: undefined },\n  '1': 'set',\n  '2': 'value' }\n\n==> computedrefimpl get { _dirty: true }\n\n==> get { target: { foo: 1 }, key: 'foo' }\n\n==> track [arguments] { '0': { foo: 1 }, '1': 'get', '2': 'foo' } { activeeffect:\n   { [function: reactiveeffect]\n     id: 0,\n     allowrecurse: false,\n     _iseffect: true,\n     active: true,\n     raw: [function],\n     deps: [],\n     options: { lazy: true, scheduler: [function: scheduler] } } }\n\n==> track [arguments] {\n  '0':\n   computedrefimpl {\n     _setter: [function],\n     _dirty: false,\n     __v_isref: true,\n     effect:\n      { [function: reactiveeffect]\n        id: 0,\n        allowrecurse: false,\n        _iseffect: true,\n        active: true,\n        raw: [function],\n        deps: [array],\n        options: [object] },\n     __v_isreadonly: true,\n     _value: 1 },\n  '1': 'get',\n  '2': 'value' } { activeeffect:\n   { [function: reactiveeffect]\n     id: 1,\n     allowrecurse: false,\n     _iseffect: true,\n     active: true,\n     raw: [function],\n     deps: [],\n     options: {} } }\n\n==> 5\n\n==> computedrefimpl get { _dirty: false }\n\n==> track [arguments] {\n  '0':\n   computedrefimpl {\n     _setter: [function],\n     _dirty: false,\n     __v_isref: true,\n     effect:\n      { [function: reactiveeffect]\n        id: 0,\n        allowrecurse: false,\n        _iseffect: true,\n        active: true,\n        raw: [function],\n        deps: [array],\n        options: [object] },\n     __v_isreadonly: true,\n     _value: 1 },\n  '1': 'get',\n  '2': 'value' } { activeeffect: undefined }\n\n==> 6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n\n\n\n# ",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/runtime-core/index/",categories:["vue3","runtime-core"],tags:[null]},regularPath:"/20.vue3/30.runtime-core/0.index.html",relativePath:"20.vue3/30.runtime-core/0.index.md",key:"v-7844a83d",path:"/vue3/runtime-core/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/runtime-dom/index/",categories:["vue3","runtime-dom"],tags:[null]},regularPath:"/20.vue3/40.runtime-dom/0.index.html",relativePath:"20.vue3/40.runtime-dom/0.index.md",key:"v-847c1376",path:"/vue3/runtime-dom/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"apiCreateApp",frontmatter:{title:"apiCreateApp",date:"2022-07-13T17:59:59.000Z",permalink:"/vue3/runtime-dom/apiCreateApp/",categories:["vue3","runtime-dom"],tags:[null]},regularPath:"/20.vue3/40.runtime-dom/10.apiCreateApp.html",relativePath:"20.vue3/40.runtime-dom/10.apiCreateApp.md",key:"v-36768879",path:"/vue3/runtime-dom/apiCreateApp/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"createApp",slug:"createapp",normalizedTitle:"createapp",charIndex:17},{level:2,title:"createRenderer",slug:"createrenderer",normalizedTitle:"createrenderer",charIndex:30},{level:2,title:"createAppAPI",slug:"createappapi",normalizedTitle:"createappapi",charIndex:48},{level:2,title:"createAppContext",slug:"createappcontext",normalizedTitle:"createappcontext",charIndex:64}],readingTime:{text:"3 min read",minutes:2.645,time:158700,words:529},headersStr:" createApp createRenderer createAppAPI createAppContext",content:"# \n\n\n\n * \n * createApp\n * createRenderer\n * createAppAPI\n * createAppContext\n\n\n\n\n# createApp\n\n// packages/runtime-dom/src/index.ts\n// see https://vuejs.org/api/application.html#createapp\nconst createApp = ((...args) => {\n  const app = ensureRenderer().createApp(...args)\n  // ......\n  const { mount } = app\n  app.mount = (containerOrSelector: Element | ShadowRoot | string): any => {\n    const container = normalizeContainer(containerOrSelector)\n    if (!container) return\n    // ......\n    // clear content before mounting\n    container.innerHTML = ''\n    const proxy = mount(container, false, container instanceof SVGElement)\n    // ......\n    return proxy\n  }\n  return app\n}) as CreateAppFunction<Element>\n\n// lazy create the renderer - this makes core renderer logic tree-shakable\n// in case the user only imports reactivity utilities from Vue.\nlet renderer: Renderer<Element | ShadowRoot> | HydrationRenderer\n\nfunction ensureRenderer() {\n  return (\n    renderer ||\n    (renderer = createRenderer<Node, Element | ShadowRoot>(rendererOptions))\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# createRenderer\n\nexport function createRenderer<\n  HostNode = RendererNode,\n  HostElement = RendererElement\n>(options: RendererOptions<HostNode, HostElement>) {\n  return baseCreateRenderer<HostNode, HostElement>(options)\n}\n\nfunction baseCreateRenderer(options: RendererOptions) {\n  // ......\n   const render: RootRenderFunction = (vnode, container, isSVG) => {\n    // ......\n    patch(container._vnode || null, vnode, container, null, null, null, isSVG)\n    // ......\n    container._vnode = vnode\n  }\n  return {\n    render,\n    hydrate,\n    createApp: createAppAPI(render, hydrate)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# createAppAPI\n\n// packages/runtime-core/src/apiCreateApp.ts\nexport function createAppAPI<HostElement>(\n  render: RootRenderFunction,\n  hydrate?: RootHydrateFunction\n): CreateAppFunction<HostElement> {\n  return function createApp(rootComponent, rootProps = null) {\n    // ......\n\n    const context = createAppContext()\n    const installedPlugins = new Set()\n\n    let isMounted = false\n\n    const app: App = (context.app = {\n      _uid: uid++,\n      _component: rootComponent as ConcreteComponent,\n      _props: rootProps,\n      _container: null,\n      _context: context,\n      _instance: null,\n\n      version,\n\n      get config() {\n        return context.config\n      },\n      // ......\n\n      use(plugin: Plugin, ...options: any[]) {\n        if (installedPlugins.has(plugin)) {\n          __DEV__ && warn(`Plugin has already been applied to target app.`)\n        } else if (plugin && isFunction(plugin.install)) {\n          installedPlugins.add(plugin)\n          plugin.install(app, ...options)\n        } else if (isFunction(plugin)) {\n          installedPlugins.add(plugin)\n          plugin(app, ...options)\n        } \n        // ......\n        return app\n      },\n\n      mixin(mixin: ComponentOptions) {\n        if (__FEATURE_OPTIONS_API__) {\n          if (!context.mixins.includes(mixin)) {\n            context.mixins.push(mixin)\n          }\n          // ......\n        } \n        // ......\n        return app\n      },\n\n      component(name: string, component?: Component): any {\n        if (!component) {\n          return context.components[name]\n        }\n        // ......\n        context.components[name] = component\n        return app\n      },\n\n      directive(name: string, directive?: Directive) {\n        if (!directive) {\n          return context.directives[name] as any\n        }\n        // ......\n        context.directives[name] = directive\n        return app\n      },\n\n      mount(\n        rootContainer: HostElement,\n        isHydrate?: boolean,\n        isSVG?: boolean\n      ): any {\n        if (!isMounted) {\n          // ......\n          const vnode = createVNode(\n            rootComponent as ConcreteComponent,\n            rootProps\n          )\n          // store app context on the root VNode.\n          // this will be set on the root instance on initial mount.\n          vnode.appContext = context\n          // ......\n\n          if (isHydrate && hydrate) {\n            hydrate(vnode as VNode<Node, Element>, rootContainer as any)\n          } else {\n            render(vnode, rootContainer, isSVG)\n          }\n          isMounted = true\n          app._container = rootContainer\n          // ......\n          return getExposeProxy(vnode.component!) || vnode.component!.proxy\n        } \n        // ......\n      },\n\n      unmount() {\n        if (isMounted) {\n          (null, app._container)\n          // ..render....\n          delete app._container.__vue_app__\n        } \n        // .......\n      },\n\n      provide(key, value) {\n        // ......\n        context.provides[key as string | symbol] = value\n        return app\n      }\n    })\n    // ......\n    return app\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n\n\n\n# createAppContext\n\n// see https://vuejs.org/api/application.html#app-config\nfunction createAppContext(): AppContext {\n  return {\n    app: null as any,\n    config: {\n      isNativeTag: NO,\n      performance: false,\n      globalProperties: {},\n      optionMergeStrategies: {},\n      errorHandler: undefined,\n      warnHandler: undefined,\n      compilerOptions: {}\n    },\n    mixins: [],\n    components: {},\n    directives: {},\n    provides: Object.create(null),\n    optionsCache: new WeakMap(),\n    propsCache: new WeakMap(),\n    emitsCache: new WeakMap()\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",normalizedContent:"# \n\n\n\n * \n * createapp\n * createrenderer\n * createappapi\n * createappcontext\n\n\n\n\n# createapp\n\n// packages/runtime-dom/src/index.ts\n// see https://vuejs.org/api/application.html#createapp\nconst createapp = ((...args) => {\n  const app = ensurerenderer().createapp(...args)\n  // ......\n  const { mount } = app\n  app.mount = (containerorselector: element | shadowroot | string): any => {\n    const container = normalizecontainer(containerorselector)\n    if (!container) return\n    // ......\n    // clear content before mounting\n    container.innerhtml = ''\n    const proxy = mount(container, false, container instanceof svgelement)\n    // ......\n    return proxy\n  }\n  return app\n}) as createappfunction<element>\n\n// lazy create the renderer - this makes core renderer logic tree-shakable\n// in case the user only imports reactivity utilities from vue.\nlet renderer: renderer<element | shadowroot> | hydrationrenderer\n\nfunction ensurerenderer() {\n  return (\n    renderer ||\n    (renderer = createrenderer<node, element | shadowroot>(rendereroptions))\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# createrenderer\n\nexport function createrenderer<\n  hostnode = renderernode,\n  hostelement = rendererelement\n>(options: rendereroptions<hostnode, hostelement>) {\n  return basecreaterenderer<hostnode, hostelement>(options)\n}\n\nfunction basecreaterenderer(options: rendereroptions) {\n  // ......\n   const render: rootrenderfunction = (vnode, container, issvg) => {\n    // ......\n    patch(container._vnode || null, vnode, container, null, null, null, issvg)\n    // ......\n    container._vnode = vnode\n  }\n  return {\n    render,\n    hydrate,\n    createapp: createappapi(render, hydrate)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# createappapi\n\n// packages/runtime-core/src/apicreateapp.ts\nexport function createappapi<hostelement>(\n  render: rootrenderfunction,\n  hydrate?: roothydratefunction\n): createappfunction<hostelement> {\n  return function createapp(rootcomponent, rootprops = null) {\n    // ......\n\n    const context = createappcontext()\n    const installedplugins = new set()\n\n    let ismounted = false\n\n    const app: app = (context.app = {\n      _uid: uid++,\n      _component: rootcomponent as concretecomponent,\n      _props: rootprops,\n      _container: null,\n      _context: context,\n      _instance: null,\n\n      version,\n\n      get config() {\n        return context.config\n      },\n      // ......\n\n      use(plugin: plugin, ...options: any[]) {\n        if (installedplugins.has(plugin)) {\n          __dev__ && warn(`plugin has already been applied to target app.`)\n        } else if (plugin && isfunction(plugin.install)) {\n          installedplugins.add(plugin)\n          plugin.install(app, ...options)\n        } else if (isfunction(plugin)) {\n          installedplugins.add(plugin)\n          plugin(app, ...options)\n        } \n        // ......\n        return app\n      },\n\n      mixin(mixin: componentoptions) {\n        if (__feature_options_api__) {\n          if (!context.mixins.includes(mixin)) {\n            context.mixins.push(mixin)\n          }\n          // ......\n        } \n        // ......\n        return app\n      },\n\n      component(name: string, component?: component): any {\n        if (!component) {\n          return context.components[name]\n        }\n        // ......\n        context.components[name] = component\n        return app\n      },\n\n      directive(name: string, directive?: directive) {\n        if (!directive) {\n          return context.directives[name] as any\n        }\n        // ......\n        context.directives[name] = directive\n        return app\n      },\n\n      mount(\n        rootcontainer: hostelement,\n        ishydrate?: boolean,\n        issvg?: boolean\n      ): any {\n        if (!ismounted) {\n          // ......\n          const vnode = createvnode(\n            rootcomponent as concretecomponent,\n            rootprops\n          )\n          // store app context on the root vnode.\n          // this will be set on the root instance on initial mount.\n          vnode.appcontext = context\n          // ......\n\n          if (ishydrate && hydrate) {\n            hydrate(vnode as vnode<node, element>, rootcontainer as any)\n          } else {\n            render(vnode, rootcontainer, issvg)\n          }\n          ismounted = true\n          app._container = rootcontainer\n          // ......\n          return getexposeproxy(vnode.component!) || vnode.component!.proxy\n        } \n        // ......\n      },\n\n      unmount() {\n        if (ismounted) {\n          (null, app._container)\n          // ..render....\n          delete app._container.__vue_app__\n        } \n        // .......\n      },\n\n      provide(key, value) {\n        // ......\n        context.provides[key as string | symbol] = value\n        return app\n      }\n    })\n    // ......\n    return app\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n\n\n\n# createappcontext\n\n// see https://vuejs.org/api/application.html#app-config\nfunction createappcontext(): appcontext {\n  return {\n    app: null as any,\n    config: {\n      isnativetag: no,\n      performance: false,\n      globalproperties: {},\n      optionmergestrategies: {},\n      errorhandler: undefined,\n      warnhandler: undefined,\n      compileroptions: {}\n    },\n    mixins: [],\n    components: {},\n    directives: {},\n    provides: object.create(null),\n    optionscache: new weakmap(),\n    propscache: new weakmap(),\n    emitscache: new weakmap()\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",charsets:{cjk:!0},lastUpdated:"2022/07/13, 18:52:25",lastUpdatedTimestamp:1657709545e3},{title:"apiDefineComponent",frontmatter:{title:"apiDefineComponent",date:"2022-07-13T18:57:20.000Z",permalink:"/vue3/runtime-dom/apiDefineComponent/",categories:["vue3","runtime-dom"],tags:[null]},regularPath:"/20.vue3/40.runtime-dom/20.apiDefineComponent.html",relativePath:"20.vue3/40.runtime-dom/20.apiDefineComponent.md",key:"v-af98cc06",path:"/vue3/runtime-dom/apiDefineComponent/",headers:[{level:2,title:"defineComponent",slug:"definecomponent",normalizedTitle:"definecomponent",charIndex:2},{level:2,title:"defineAsyncComponent",slug:"defineasynccomponent",normalizedTitle:"defineasynccomponent",charIndex:290}],readingTime:{text:"3 min read",minutes:2.235,time:134100,words:447},headersStr:"defineComponent defineAsyncComponent",content:"# defineComponent\n\n// packages/runtime-core/src/apiDefineComponent.ts\n// see https://vuejs.org/api/general.html#definecomponent\nfunction defineComponent(options: unknown) {\n  return isFunction(options) ? { setup: options, name: options.name } : options\n}\n\n\n1\n2\n3\n4\n5\n\n\nSFC  object\n\n\n# defineAsyncComponent\n\n// see https://vuejs.org/api/general.html#defineasynccomponent\nexport function defineAsyncComponent<\n  T extends Component = { new (): ComponentPublicInstance }\n>(source: AsyncComponentLoader<T> | AsyncComponentOptions<T>): T {\n  if (isFunction(source)) {\n    source = { loader: source }\n  }\n\n  const {\n    loader,\n    loadingComponent,\n    errorComponent,\n    delay = 200,\n    timeout, // undefined = never times out\n    suspensible = true,\n    onError: userOnError\n  } = source\n\n  let pendingRequest: Promise<ConcreteComponent> | null = null\n  let resolvedComp: ConcreteComponent | undefined\n\n  // ......\n  const load = (): Promise<ConcreteComponent> => {\n    let thisRequest: Promise<ConcreteComponent>\n    return (\n      pendingRequest ||\n      (thisRequest = pendingRequest =\n        loader()\n          .catch(err => {\n            // ......\n          })\n          .then((comp: any) => {\n            // ......\n            // interop module default\n            if (\n              comp &&\n              (comp.__esModule || comp[Symbol.toStringTag] === 'Module')\n            ) {\n              comp = comp.default\n            }\n            //  ......\n            resolvedComp = comp\n            return comp\n          }))\n    )\n  }\n\n  return defineComponent({\n    name: 'AsyncComponentWrapper',\n\n    __asyncLoader: load,\n\n    get __asyncResolved() {\n      return resolvedComp\n    },\n\n    setup() {\n      const instance = currentInstance!\n\n      // already resolved\n      if (resolvedComp) {\n        return () => createInnerComp(resolvedComp!, instance)\n      }\n\n      const onError = (err: Error) => {\n        pendingRequest = null\n        handleError(\n          err,\n          instance,\n          ErrorCodes.ASYNC_COMPONENT_LOADER,\n          !errorComponent /* do not throw in dev if user provided error component */\n        )\n      }\n\n      // suspense-controlled or SSR.\n      if (\n        (__FEATURE_SUSPENSE__ && suspensible && instance.suspense) ||\n        (__SSR__ && isInSSRComponentSetup)\n      ) {\n        return load()\n          .then(comp => {\n            return () => createInnerComp(comp, instance)\n          })\n          .catch(err => {\n            onError(err)\n            return () =>\n              errorComponent\n                ? createVNode(errorComponent as ConcreteComponent, {\n                    error: err\n                  })\n                : null\n          })\n      }\n\n      const loaded = ref(false)\n      const error = ref()\n      const delayed = ref(!!delay)\n\n      if (delay) {\n        setTimeout(() => {\n          delayed.value = false\n        }, delay)\n      }\n\n      if (timeout != null) {\n        setTimeout(() => {\n          if (!loaded.value && !error.value) {\n            const err = new Error(\n              `Async component timed out after ${timeout}ms.`\n            )\n            onError(err)\n            error.value = err\n          }\n        }, timeout)\n      }\n\n      load()\n        .then(() => {\n          loaded.value = true\n          if (instance.parent && isKeepAlive(instance.parent.vnode)) {\n            // parent is keep-alive, force update so the loaded component's\n            // name is taken into account\n            queueJob(instance.parent.update)\n          }\n        })\n        .catch(err => {\n          onError(err)\n          error.value = err\n        })\n\n      return () => {\n        if (loaded.value && resolvedComp) {\n          return createInnerComp(resolvedComp, instance)\n        } else if (error.value && errorComponent) {\n          return createVNode(errorComponent as ConcreteComponent, {\n            error: error.value\n          })\n        } else if (loadingComponent && !delayed.value) {\n          return createVNode(loadingComponent as ConcreteComponent)\n        }\n      }\n    }\n  }) as T\n}\n\nfunction createInnerComp(\n  comp: ConcreteComponent,\n  {\n    vnode: { ref, props, children, shapeFlag },\n    parent\n  }: ComponentInternalInstance\n) {\n  const vnode = createVNode(comp, props, children)\n  // ensure inner component inherits the async wrapper's ref owner\n  vnode.ref = ref\n  return vnode\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n",normalizedContent:"# definecomponent\n\n// packages/runtime-core/src/apidefinecomponent.ts\n// see https://vuejs.org/api/general.html#definecomponent\nfunction definecomponent(options: unknown) {\n  return isfunction(options) ? { setup: options, name: options.name } : options\n}\n\n\n1\n2\n3\n4\n5\n\n\nsfc  object\n\n\n# defineasynccomponent\n\n// see https://vuejs.org/api/general.html#defineasynccomponent\nexport function defineasynccomponent<\n  t extends component = { new (): componentpublicinstance }\n>(source: asynccomponentloader<t> | asynccomponentoptions<t>): t {\n  if (isfunction(source)) {\n    source = { loader: source }\n  }\n\n  const {\n    loader,\n    loadingcomponent,\n    errorcomponent,\n    delay = 200,\n    timeout, // undefined = never times out\n    suspensible = true,\n    onerror: useronerror\n  } = source\n\n  let pendingrequest: promise<concretecomponent> | null = null\n  let resolvedcomp: concretecomponent | undefined\n\n  // ......\n  const load = (): promise<concretecomponent> => {\n    let thisrequest: promise<concretecomponent>\n    return (\n      pendingrequest ||\n      (thisrequest = pendingrequest =\n        loader()\n          .catch(err => {\n            // ......\n          })\n          .then((comp: any) => {\n            // ......\n            // interop module default\n            if (\n              comp &&\n              (comp.__esmodule || comp[symbol.tostringtag] === 'module')\n            ) {\n              comp = comp.default\n            }\n            //  ......\n            resolvedcomp = comp\n            return comp\n          }))\n    )\n  }\n\n  return definecomponent({\n    name: 'asynccomponentwrapper',\n\n    __asyncloader: load,\n\n    get __asyncresolved() {\n      return resolvedcomp\n    },\n\n    setup() {\n      const instance = currentinstance!\n\n      // already resolved\n      if (resolvedcomp) {\n        return () => createinnercomp(resolvedcomp!, instance)\n      }\n\n      const onerror = (err: error) => {\n        pendingrequest = null\n        handleerror(\n          err,\n          instance,\n          errorcodes.async_component_loader,\n          !errorcomponent /* do not throw in dev if user provided error component */\n        )\n      }\n\n      // suspense-controlled or ssr.\n      if (\n        (__feature_suspense__ && suspensible && instance.suspense) ||\n        (__ssr__ && isinssrcomponentsetup)\n      ) {\n        return load()\n          .then(comp => {\n            return () => createinnercomp(comp, instance)\n          })\n          .catch(err => {\n            onerror(err)\n            return () =>\n              errorcomponent\n                ? createvnode(errorcomponent as concretecomponent, {\n                    error: err\n                  })\n                : null\n          })\n      }\n\n      const loaded = ref(false)\n      const error = ref()\n      const delayed = ref(!!delay)\n\n      if (delay) {\n        settimeout(() => {\n          delayed.value = false\n        }, delay)\n      }\n\n      if (timeout != null) {\n        settimeout(() => {\n          if (!loaded.value && !error.value) {\n            const err = new error(\n              `async component timed out after ${timeout}ms.`\n            )\n            onerror(err)\n            error.value = err\n          }\n        }, timeout)\n      }\n\n      load()\n        .then(() => {\n          loaded.value = true\n          if (instance.parent && iskeepalive(instance.parent.vnode)) {\n            // parent is keep-alive, force update so the loaded component's\n            // name is taken into account\n            queuejob(instance.parent.update)\n          }\n        })\n        .catch(err => {\n          onerror(err)\n          error.value = err\n        })\n\n      return () => {\n        if (loaded.value && resolvedcomp) {\n          return createinnercomp(resolvedcomp, instance)\n        } else if (error.value && errorcomponent) {\n          return createvnode(errorcomponent as concretecomponent, {\n            error: error.value\n          })\n        } else if (loadingcomponent && !delayed.value) {\n          return createvnode(loadingcomponent as concretecomponent)\n        }\n      }\n    }\n  }) as t\n}\n\nfunction createinnercomp(\n  comp: concretecomponent,\n  {\n    vnode: { ref, props, children, shapeflag },\n    parent\n  }: componentinternalinstance\n) {\n  const vnode = createvnode(comp, props, children)\n  // ensure inner component inherits the async wrapper's ref owner\n  vnode.ref = ref\n  return vnode\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n",charsets:{cjk:!0},lastUpdated:"2022/07/18, 21:05:56",lastUpdatedTimestamp:1658149556e3},{title:"scheduler",frontmatter:{title:"scheduler",date:"2022-07-13T19:00:32.000Z",permalink:"/pages/286896/",categories:["vue3","runtime-dom"],tags:[null]},regularPath:"/20.vue3/40.runtime-dom/90.scheduler.html",relativePath:"20.vue3/40.runtime-dom/90.scheduler.md",key:"v-7b4d74fd",path:"/pages/286896/",headers:[{level:2,title:"nextTick",slug:"nexttick",normalizedTitle:"nexttick",charIndex:2}],readingTime:{text:"1 min read",minutes:.27,time:16200.000000000004,words:54},headersStr:"nextTick",content:"# nextTick\n\n// packages/runtime-core/src/scheduler.ts\n// see https://vuejs.org/api/general.html#nexttick\nconst resolvedPromise = /*#__PURE__*/ Promise.resolve() as Promise<any>\nlet currentFlushPromise: Promise<void> | null = null\n\nfunction nextTick<T = void>(\n  this: T,\n  fn?: (this: T) => void\n): Promise<void> {\n  const p = currentFlushPromise || resolvedPromise\n  return fn ? p.then(this ? fn.bind(this) : fn) : p\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",normalizedContent:"# nexttick\n\n// packages/runtime-core/src/scheduler.ts\n// see https://vuejs.org/api/general.html#nexttick\nconst resolvedpromise = /*#__pure__*/ promise.resolve() as promise<any>\nlet currentflushpromise: promise<void> | null = null\n\nfunction nexttick<t = void>(\n  this: t,\n  fn?: (this: t) => void\n): promise<void> {\n  const p = currentflushpromise || resolvedpromise\n  return fn ? p.then(this ? fn.bind(this) : fn) : p\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",charsets:{cjk:!0},lastUpdated:"2022/07/18, 21:05:56",lastUpdatedTimestamp:1658149556e3},{title:"",frontmatter:{title:"",date:"2022-04-14T23:36:48.000Z",permalink:"/web/index/",categories:null,tags:[null]},regularPath:"/30.web/0.index.html",relativePath:"30.web/0.index.md",key:"v-50e647d9",path:"/web/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"Plan ",frontmatter:{title:"Plan ",date:"2022-04-16T13:46:07.000Z",permalink:"/web/plan/",categories:null,tags:[null]},regularPath:"/30.web/1.plan.html",relativePath:"30.web/1.plan.md",key:"v-26e7ba7d",path:"/web/plan/",headers:[{level:2,title:"Plan",slug:"plan",normalizedTitle:"plan",charIndex:2},{level:2,title:"Current ",slug:"current-",normalizedTitle:"current ",charIndex:43}],readingTime:{text:"1 min read",minutes:.09,time:5399.999999999999,words:18},headersStr:"Plan Current ",content:"# Plan\n\n * Qiankun \n * Single-spa \n\n\n# Current \n\n * Webpack ",normalizedContent:"# plan\n\n * qiankun \n * single-spa \n\n\n# current \n\n * webpack ",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/vite/index/",categories:["vite"],tags:[null]},regularPath:"/30.web/10.vite%E6%BA%90%E7%A0%81/0.index.html",relativePath:"30.web/10.vite/0.index.md",key:"v-566737cd",path:"/vite/index/",headers:[{level:2,title:" vite",slug:"-vite",normalizedTitle:" vite",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:1180},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:1415},{level:2,title:"TODO ",slug:"todo-",normalizedTitle:"todo ",charIndex:1455},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:1467}],readingTime:{text:"1 min read",minutes:.89,time:53400,words:178},headersStr:" vite   TODO  ",content:"#  vite\n\n vitevite  vite \n\n *   ESM \n\n webpack  chunk : 1. 2.  dev server vite  ESM  dev server  ESM vite  ESM  vite  ESM  development  production  rollup  rollup \n\n *  HMR\n\n HMR hot module reload\n\n *   TypeScriptJSXCSS \n\nTypeScript vite  TypeScript vite  vue3  webpack vite  vite  webpack vite  development  webpack  webpack \n\n *       Rollup \n\n *   Rollup-superset \n\nvite  rollup  vite \n\n *   API API  TypeScript \n\n vite  vite vite: \n\n\n# \n\n          \nvite      \nIDE         VSCode\n Repo   https://github.com/jonsam-ng/fe-source-reading\n        https://source.jonsam.site\n        dev serverHMR SFC  JSX \n        \n\n\n# \n\n * vitejs/vite\n * Vite \n\n\n# TODO \n\n\n# ",normalizedContent:"#  vite\n\n vitevite  vite \n\n *   esm \n\n webpack  chunk : 1. 2.  dev server vite  esm  dev server  esm vite  esm  vite  esm  development  production  rollup  rollup \n\n *  hmr\n\n hmr hot module reload\n\n *   typescriptjsxcss \n\ntypescript vite  typescript vite  vue3  webpack vite  vite  webpack vite  development  webpack  webpack \n\n *       rollup \n\n *   rollup-superset \n\nvite  rollup  vite \n\n *   api api  typescript \n\n vite  vite vite: \n\n\n# \n\n          \nvite      \nide         vscode\n repo   https://github.com/jonsam-ng/fe-source-reading\n        https://source.jonsam.site\n        dev serverhmr sfc  jsx \n        \n\n\n# \n\n * vitejs/vite\n * vite \n\n\n# todo \n\n\n# ",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/vite/basic/index/",categories:["vite","basic"],tags:[null]},regularPath:"/30.web/10.vite%E6%BA%90%E7%A0%81/10.%E5%9F%BA%E7%A1%80/0.index.html",relativePath:"30.web/10.vite/10./0.index.md",key:"v-6e8687a2",path:"/vite/basic/index/",readingTime:{text:"1 min read",minutes:.545,time:32700.000000000004,words:109},headersStr:null,content:" packages  vite \n\n * create-app: vite cli \n * create-vite: vite template litpreactreactsveltevanillavue  ts \n * vite-playground: vite playground \n * plugin-legacy:  vite \n * plugin-react:  react  vite \n * plugin-vue:  vue SFC vite \n * plugin-vue-jsx:  vue  jsx \n * vite: vite \n\nvite  vite \n\n * vite:  vite dev server\n * plugin-vue:  vite  vue  vite  vite  SFC \n * plugin-react:  vite  react  vite  vite  JSX \n * create-app:  vite \n * create-vite: \n * plugin-legacy:  vite  legacy  vite \n *  monorepo ",normalizedContent:" packages  vite \n\n * create-app: vite cli \n * create-vite: vite template litpreactreactsveltevanillavue  ts \n * vite-playground: vite playground \n * plugin-legacy:  vite \n * plugin-react:  react  vite \n * plugin-vue:  vue sfc vite \n * plugin-vue-jsx:  vue  jsx \n * vite: vite \n\nvite  vite \n\n * vite:  vite dev server\n * plugin-vue:  vite  vue  vite  vite  sfc \n * plugin-react:  vite  react  vite  vite  jsx \n * create-app:  vite \n * create-vite: \n * plugin-legacy:  vite  legacy  vite \n *  monorepo ",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/vite/core/index/",categories:["vite","vite"],tags:[null]},regularPath:"/30.web/10.vite%E6%BA%90%E7%A0%81/20.vite/0.index.html",relativePath:"30.web/10.vite/20.vite/0.index.md",key:"v-7373c0fa",path:"/vite/core/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"clivite ",frontmatter:{title:"clivite ",date:"2022-04-14T22:02:21.000Z",permalink:"/vite/core/cli/",categories:["vite","vite"],tags:[null]},regularPath:"/30.web/10.vite%E6%BA%90%E7%A0%81/20.vite/10.cli.html",relativePath:"30.web/10.vite/20.vite/10.cli.md",key:"v-55a8d0bf",path:"/vite/core/cli/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"start",slug:"start",normalizedTitle:"start",charIndex:17},{level:2,title:"cli",slug:"cli",normalizedTitle:"cli",charIndex:26},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:33}],readingTime:{text:"3 min read",minutes:2.66,time:159600.00000000003,words:532},headersStr:" start cli ",content:"# \n\n\n\n * \n * start\n * cli\n * \n\n\n\n\n# start\n\n vite  vite  npm  vite  bin  vite  package.json  bin  bin/vite.js  vite.js \n\n vite.js  cli  debugprofile  process.env  global  start \n\nfunction start() {\n  require('../dist/node/cli')\n}\n\n\n1\n2\n3\n\n\n src/node/cli.ts  cli \n\n\n# cli\n\n 1.  cli.option\n\n// cli.option(name, description, config?)\ncli.option('-c, --config <file>', `[string] use specified config file`)\n\n\n1\n2\n\n * \n * \n\n 2.  command \n\n * vite serve (dev)  dev server\n\naction \n\nasync (root: string, options: ServerOptions & GlobalCLIOptions) => {\n    // output structure is preserved even after bundling so require()\n    // is ok here\n    const {\n        createServer\n    } = await import('./server')\n    try {\n        //  dev server\n        const server = await createServer({\n            root,\n            base: options.base,\n            mode: options.mode,\n            configFile: options.config,\n            logLevel: options.logLevel,\n            clearScreen: options.clearScreen,\n            server: cleanOptions(options)\n        })\n        //  http server\n        if (!server.httpServer) {\n            throw new Error('HTTP server not available')\n        }\n        //  dev server \n        await server.listen()\n        //   info logger\n        const info = server.config.logger.info\n\n        info(\n            chalk.cyan(`\\n  vite v${require('vite/package.json').version}`) +\n            chalk.green(` dev server running at:\\n`), {\n                clear: !server.config.logger.hasWarned\n            }\n        )\n        //  server url\n        server.printUrls()\n        // \n        // @ts-ignore\n        if (global.__vite_start_time) {\n            // @ts-ignore\n            const startupDuration = performance.now() - global.__vite_start_time\n            info(`\\n  ${chalk.cyan(`ready in ${Math.ceil(startupDuration)}ms.`)}\\n`)\n        }\n    } catch (e) {\n        createLogger(options.logLevel).error(\n            chalk.red(`error when starting dev server:\\n${e.stack}`), {\n                error: e\n            }\n        )\n        // \n        process.exit(1)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n dev server server \n\n * vite build \n\naction \n\nasync (root: string, options: BuildOptions & GlobalCLIOptions) => {\n    const {\n        build\n    } = await import('./build')\n    const buildOptions: BuildOptions = cleanOptions(options)\n    // build project\n    try {\n        await build({\n            root,\n            base: options.base,\n            mode: options.mode,\n            configFile: options.config,\n            logLevel: options.logLevel,\n            clearScreen: options.clearScreen,\n            build: buildOptions\n        })\n    } catch (e) {\n        createLogger(options.logLevel).error(\n            chalk.red(`error during build:\\n${e.stack}`), {\n                error: e\n            }\n        )\n        process.exit(1)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n build \n\n * vite optimize: \n\naction \n\nasync (root: string, options: {\n    force ? : boolean\n} & GlobalCLIOptions) => {\n    const {\n        optimizeDeps\n    } = await import('./optimizer')\n    try {\n        //  config\n        const config = await resolveConfig({\n                root,\n                base: options.base,\n                configFile: options.config,\n                logLevel: options.logLevel\n            },\n            'build',\n            'development'\n        )\n        // \n        await optimizeDeps(config, options.force, true)\n    } catch (e) {\n        createLogger(options.logLevel).error(\n            chalk.red(`error when optimizing deps:\\n${e.stack}`), {\n                error: e\n            }\n        )\n        process.exit(1)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nvite \n\n * vite preview: production \n\naction \n\nasync (\n    root: string,\n    options: {\n        host ? : string | boolean\n        port ? : number\n        https ? : boolean\n        open ? : boolean | string\n        strictPort ? : boolean\n    } & GlobalCLIOptions\n) => {\n    //  server  buildDir  serve \n    try {\n        const server = await preview({\n            root,\n            base: options.base,\n            configFile: options.config,\n            logLevel: options.logLevel,\n            preview: {\n                port: options.port,\n                strictPort: options.strictPort,\n                host: options.host,\n                https: options.https,\n                open: options.open\n            }\n        })\n        server.printUrls()\n    } catch (e) {\n        createLogger(options.logLevel).error(\n            chalk.red(`error when starting preview server:\\n${e.stack}`), {\n                error: e\n            }\n        )\n        process.exit(1)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n dist  server \n\n 3. cli.help(): Display help message when -h or --help appears.\n 4. cli.version(): Display version number when -v or --version appears.\n 5. cli.parse(): Parse CLI args.\n\n\n# \n\n * cacjs/cac:Simple yet powerful framework for building command-line apps.\n * chalk/chalk: Terminal string styling done right.",normalizedContent:"# \n\n\n\n * \n * start\n * cli\n * \n\n\n\n\n# start\n\n vite  vite  npm  vite  bin  vite  package.json  bin  bin/vite.js  vite.js \n\n vite.js  cli  debugprofile  process.env  global  start \n\nfunction start() {\n  require('../dist/node/cli')\n}\n\n\n1\n2\n3\n\n\n src/node/cli.ts  cli \n\n\n# cli\n\n 1.  cli.option\n\n// cli.option(name, description, config?)\ncli.option('-c, --config <file>', `[string] use specified config file`)\n\n\n1\n2\n\n * \n * \n\n 2.  command \n\n * vite serve (dev)  dev server\n\naction \n\nasync (root: string, options: serveroptions & globalclioptions) => {\n    // output structure is preserved even after bundling so require()\n    // is ok here\n    const {\n        createserver\n    } = await import('./server')\n    try {\n        //  dev server\n        const server = await createserver({\n            root,\n            base: options.base,\n            mode: options.mode,\n            configfile: options.config,\n            loglevel: options.loglevel,\n            clearscreen: options.clearscreen,\n            server: cleanoptions(options)\n        })\n        //  http server\n        if (!server.httpserver) {\n            throw new error('http server not available')\n        }\n        //  dev server \n        await server.listen()\n        //   info logger\n        const info = server.config.logger.info\n\n        info(\n            chalk.cyan(`\\n  vite v${require('vite/package.json').version}`) +\n            chalk.green(` dev server running at:\\n`), {\n                clear: !server.config.logger.haswarned\n            }\n        )\n        //  server url\n        server.printurls()\n        // \n        // @ts-ignore\n        if (global.__vite_start_time) {\n            // @ts-ignore\n            const startupduration = performance.now() - global.__vite_start_time\n            info(`\\n  ${chalk.cyan(`ready in ${math.ceil(startupduration)}ms.`)}\\n`)\n        }\n    } catch (e) {\n        createlogger(options.loglevel).error(\n            chalk.red(`error when starting dev server:\\n${e.stack}`), {\n                error: e\n            }\n        )\n        // \n        process.exit(1)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n dev server server \n\n * vite build \n\naction \n\nasync (root: string, options: buildoptions & globalclioptions) => {\n    const {\n        build\n    } = await import('./build')\n    const buildoptions: buildoptions = cleanoptions(options)\n    // build project\n    try {\n        await build({\n            root,\n            base: options.base,\n            mode: options.mode,\n            configfile: options.config,\n            loglevel: options.loglevel,\n            clearscreen: options.clearscreen,\n            build: buildoptions\n        })\n    } catch (e) {\n        createlogger(options.loglevel).error(\n            chalk.red(`error during build:\\n${e.stack}`), {\n                error: e\n            }\n        )\n        process.exit(1)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n build \n\n * vite optimize: \n\naction \n\nasync (root: string, options: {\n    force ? : boolean\n} & globalclioptions) => {\n    const {\n        optimizedeps\n    } = await import('./optimizer')\n    try {\n        //  config\n        const config = await resolveconfig({\n                root,\n                base: options.base,\n                configfile: options.config,\n                loglevel: options.loglevel\n            },\n            'build',\n            'development'\n        )\n        // \n        await optimizedeps(config, options.force, true)\n    } catch (e) {\n        createlogger(options.loglevel).error(\n            chalk.red(`error when optimizing deps:\\n${e.stack}`), {\n                error: e\n            }\n        )\n        process.exit(1)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nvite \n\n * vite preview: production \n\naction \n\nasync (\n    root: string,\n    options: {\n        host ? : string | boolean\n        port ? : number\n        https ? : boolean\n        open ? : boolean | string\n        strictport ? : boolean\n    } & globalclioptions\n) => {\n    //  server  builddir  serve \n    try {\n        const server = await preview({\n            root,\n            base: options.base,\n            configfile: options.config,\n            loglevel: options.loglevel,\n            preview: {\n                port: options.port,\n                strictport: options.strictport,\n                host: options.host,\n                https: options.https,\n                open: options.open\n            }\n        })\n        server.printurls()\n    } catch (e) {\n        createlogger(options.loglevel).error(\n            chalk.red(`error when starting preview server:\\n${e.stack}`), {\n                error: e\n            }\n        )\n        process.exit(1)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n dist  server \n\n 3. cli.help(): display help message when -h or --help appears.\n 4. cli.version(): display version number when -v or --version appears.\n 5. cli.parse(): parse cli args.\n\n\n# \n\n * cacjs/cac:simple yet powerful framework for building command-line apps.\n * chalk/chalk: terminal string styling done right.",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"server dev server ",frontmatter:{title:"server dev server ",date:"2022-04-14T22:02:21.000Z",permalink:"/vite/core/server/",categories:["vite","vite"],tags:[null]},regularPath:"/30.web/10.vite%E6%BA%90%E7%A0%81/20.vite/20.server.html",relativePath:"30.web/10.vite/20.vite/20.server.md",key:"v-18766245",path:"/vite/core/server/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"createServer",slug:"createserver",normalizedTitle:"createserver",charIndex:17}],readingTime:{text:"1 min read",minutes:.095,time:5700,words:19},headersStr:" createServer",content:"# \n\n\n\n * \n * createServer\n\n\n\n\n# createServer\n\npackages/vite/src/node/server/index.ts\n\n cli  vite dev  createServer  dev server ",normalizedContent:"# \n\n\n\n * \n * createserver\n\n\n\n\n# createserver\n\npackages/vite/src/node/server/index.ts\n\n cli  vite dev  createserver  dev server ",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"",frontmatter:{title:"",date:"2022-04-25T10:24:16.000Z",permalink:"/express/index/",categories:["express"],tags:[null]},regularPath:"/30.web/160.express/0.index.html",relativePath:"30.web/160.express/0.index.md",key:"v-53f20ec6",path:"/express/index/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2}],excerpt:"",readingTime:{text:"1 min read",minutes:.065,time:3900.0000000000005,words:13},headersStr:"",content:"# \n\n * Node.js API \n * Node.js v18.0.0 Documentation",normalizedContent:"# \n\n * node.js api \n * node.js v18.0.0 documentation",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"",frontmatter:{title:"",date:"2022-04-26T11:33:53.000Z",permalink:"/acorn/index/",categories:["acorn"],tags:[null]},regularPath:"/30.web/170.acorn%E6%BA%90%E7%A0%81/0.index.html",relativePath:"30.web/170.acorn/0.index.md",key:"v-4bc33869",path:"/acorn/index/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2}],readingTime:{text:"1 min read",minutes:.05,time:3e3,words:10},headersStr:"",content:"# \n\n * estree/estree: The ESTree Spec\n * AST explorer",normalizedContent:"# \n\n * estree/estree: the estree spec\n * ast explorer",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"",frontmatter:{title:"",date:"2022-04-29T10:32:57.000Z",permalink:"/immutable/index/",categories:["web","immutable.js"],tags:[null]},regularPath:"/30.web/180.immutable.js%E6%BA%90%E7%A0%81/0.index.html",relativePath:"30.web/180.immutable.js/0.index.md",key:"v-687541db",path:"/immutable/index/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2}],readingTime:{text:"1 min read",minutes:.095,time:5700,words:19},headersStr:"",content:"# \n\n * Immutable.js  React \n * Immutable.js\n * immutable-js/immutable-js: Immutable persistent data collections for Javascript which increase efficiency and simplicity.",normalizedContent:"# \n\n * immutable.js  react \n * immutable.js\n * immutable-js/immutable-js: immutable persistent data collections for javascript which increase efficiency and simplicity.",charsets:{cjk:!0},lastUpdated:"2022/05/01, 10:17:14",lastUpdatedTimestamp:1651371434e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/index/",categories:["typescript-utility"],tags:[null]},regularPath:"/30.web/4.typescript-utility/0.index.html",relativePath:"30.web/4.typescript-utility/0.index.md",key:"v-6414adc6",path:"/ts/index/",readingTime:{text:"0 min read",minutes:0,time:0,words:0},headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/basic/index/",categories:["typescript-utility","basic"],tags:[null]},regularPath:"/30.web/4.typescript-utility/10.%E5%9F%BA%E7%A1%80/0.index.html",relativePath:"30.web/4.typescript-utility/10./0.index.md",key:"v-2985970b",path:"/ts/basic/index/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:23}],readingTime:{text:"1 min read",minutes:.095,time:5700,words:19},headersStr:"  ",content:"# \n\n\n\n * \n * \n * \n\n\n\n\n# \n\nTypescript  typescript  typescript utility \n\n\n# \n\n * Typescript ",normalizedContent:"# \n\n\n\n * \n * \n * \n\n\n\n\n# \n\ntypescript  typescript  typescript utility \n\n\n# \n\n * typescript ",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"basic-types ",frontmatter:{title:"basic-types ",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/basic/basic-types/",categories:["typescript-utility","basic"],tags:[null]},regularPath:"/30.web/4.typescript-utility/10.%E5%9F%BA%E7%A1%80/10.basic-types.html",relativePath:"30.web/4.typescript-utility/10./10.basic-types.md",key:"v-aef55d32",path:"/ts/basic/basic-types/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"The Basics",slug:"the-basics",normalizedTitle:"the basics",charIndex:17},{level:2,title:"Everyday Types ",slug:"everyday-types-",normalizedTitle:"everyday types ",charIndex:31},{level:2,title:"Narrowing ",slug:"narrowing-",normalizedTitle:"narrowing ",charIndex:54},{level:2,title:"More on Functions",slug:"more-on-functions",normalizedTitle:"more on functions",charIndex:72},{level:2,title:"Object Types ",slug:"object-types-",normalizedTitle:"object types ",charIndex:93},{level:2,title:"modules ",slug:"modules-",normalizedTitle:"modules ",charIndex:114},{level:3,title:"Non-modules ",slug:"non-modules-",normalizedTitle:"non-modules ",charIndex:130},{level:3,title:"CommonJS and ES Modules interop  ES ",slug:"commonjs-and-es-modules-interop--es-",normalizedTitle:"commonjs and es modules interop  es ",charIndex:151}],readingTime:{text:"13 min read",minutes:12.14,time:728400.0000000001,words:2428},headersStr:" The Basics Everyday Types  Narrowing  More on Functions Object Types  modules  Non-modules  CommonJS and ES Modules interop  ES ",content:'# \n\n\n\n * \n * The Basics\n * Everyday Types \n * Narrowing \n * More on Functions\n * Object Types \n * modules \n   * Non-modules \n   * CommonJS and ES Modules interop  ES \n\n\n\n\n# The Basics\n\n * Static type-checking \n\nStatic types systems describe the shapes and behaviors of what our values will be when we run our programs. A type-checker like TypeScript uses that information and tells us when things might be going off the rails. \n\n * Non-exception Failures \n\nA static type system has to make the call over what code should be flagged as an error in its system, even if its valid JavaScript that wont immediately throw an error.   JavaScript\n\n * Types for Tooling \n\nThe type-checker has information to check things like whether were accessing the right properties on variables and other properties. Once it has that information, it can also start suggesting which properties you might want to use. \n\n * tsc, the TypeScript compiler \n\n * Explicit Types \n\n * Erased Types \n\nType annotations arent part of JavaScript (or ECMAScript to be pedantic), so there really arent any browsers or other runtimes that can just run TypeScript unmodified. Thats why TypeScript needs a compiler in the first place - it needs some way to strip out or transform any TypeScript-specific code so that you can run it.  JavaScript  ( ECMAScript )   \n\n * Downleveling \n\nTypeScript has the ability to rewrite code from newer versions of ECMAScript to older ones such as ECMAScript 3 or ECMAScript 5 (a.k.a. ES3 and ES5). This process of moving from a newer or higher version of ECMAScript down to an older or lower one is sometimes called downleveling.  ECMAScript  ECMAScript 3  ECMAScript 5 ( es3  ES5)   ECMAScript   \n\nBy default TypeScript targets ES3, an extremely old version of ECMAScript. We could have chosen something a little bit more recent by using the target option. Running with --target es2015 changes TypeScript to target ECMAScript 2015, meaning code should be able to run wherever ECMAScript 2015 is supported.  ES3 ECMAScript  target  -- target es2015  ECMAScript 2015 ECMAScript 2015 \n\nWhile the default target is ES3, the great majority of current browsers support ES2015. Most developers can therefore safely specify ES2015 or above as a target, unless compatibility with certain ancient browsers is important.  ES3 ES2015 es2015 \n\n * Strictness \n\nIn contrast, a lot of users prefer to have TypeScript validate as much as it can straight away, and thats why the language provides strictness settings as well. These strictness settings turn static type-checking from a switch (either your code is checked or not) into something closer to a dial. The further you turn this dial up, the more TypeScript will check for you. This can require a little extra work, but generally speaking it pays for itself in the long run, and enables more thorough checks and more accurate tooling. When possible, a new codebase should always turn these strictness checks on.  TypeScript  () \n\nThe strict flag in the CLI, or "strict": true in a tsconfig.json toggles them all on simultaneously, but we can opt out of them individually. The two biggest ones you should know about are noImplicitAny and strictNullChecks. CLI  strict:  tsconfig.json  true noImplicitAny  strictnullcheck\n\n\n# Everyday Types \n\n * The primitives: string,number, and boolean\n * Arrays \n * any\n * Functions\n * Anonymous Functions \n * Object Types \n * Optional Properties \n * Union Types \n * Type Aliases \n * Interfaces \n * Type Assertions \n\nTypeScript only allows type assertions which convert to a more specific or less specific version of a type. \n\nSometimes this rule can be too conservative and will disallow more complex coercions that might be valid. If this happens, you can use two assertions, first to any (or unknown, which well introduce later), then to the desired type.  any ( unknown) \n\n * Literal Types \n * Literal Inference \n\nThe as const suffix acts like const but for the type system, ensuring that all properties are assigned the literal type instead of a more general version like string or number. As const  const\n\n * null and undefined\n * Enums\n * Less Common Primitives technique bigintsymbol\n\n\n# Narrowing \n\n * typeof type guards\n\n"string""number""bigint""boolean""symbol""undefined""object""function"\n\n * Truthiness narrowing\n * Equality narrowing\n * The in operator narrowing\n * instanceof narrowing\n * Assignments \n * Control flow analysis \n * Using type predicates \n\nA predicate takes the form parameterName is Type, where parameterName must be the name of a parameter from the current function signature.  parameterName is Type parameterName \n\nclasses can use this is Type to narrow their type.  this is Type \n\n * Discriminated unions \n\n * The never type\n\nWhen narrowing, you can reduce the options of a union to a point where you have removed all possibilities and have nothing left. In those cases, TypeScript will use a never type to represent a state which shouldnt exist. TypeScript  never \n\n * Exhaustiveness checking \n\nThe never type is assignable to every type; however, no type is assignable to never (except never itself). This means you can use narrowing and rely on never turning up to do exhaustive checking in a switch statement. Never  never () switch \n\n\n# More on Functions\n\n * Function Type Expressions \n * Call Signatures \n\nIn JavaScript, functions can have properties in addition to being callable. However, the function type expression syntax doesnt allow for declaring properties. If we want to describe something callable with properties, we can write a call signature in an object type.  JavaScript .\n\ntype DescribableFunction = {\n  description: string;\n  (someArg: number): boolean;\n};\nfunction doSomething(fn: DescribableFunction) {\n  console.log(fn.description + " returned " + fn(6));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * Construct Signatures \n\nJavaScript functions can also be invoked with the new operator. TypeScript refers to these as constructors because they usually create a new object. You can write a construct signature by adding the new keyword in front of a call signature:  new :\n\ntype SomeConstructor = {\n  new (s: string): SomeObject;\n};\nfunction fn(ctor: SomeConstructor) {\n  return new ctor("hello");\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nSome objects, like JavaScripts Date object, can be called with or without new. You can combine call and construct signatures in the same type arbitrarily:  JavaScript  Date  new :\n\ninterface CallOrConstruct {\n  new (s: string): Date;\n  (n?: number): number;\n}\n\n\n1\n2\n3\n4\n\n * Generic Functions \n\nIn TypeScript, generics are used when we want to describe a correspondence between two values.  TypeScript \n\n * Inference \n * Constraints \n\nSometimes we want to relate two values, but can only operate on a certain subset of values. In this case, we can use a constraint to limit the kinds of types that a type parameter can accept. \n\nfunction longest<Type extends { length: number }>(a: Type, b: Type) {\n  if (a.length >= b.length) {\n    return a;\n  } else {\n    return b;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n * Working with Constrained Values \n\n * Specifying Type Arguments \n\n * Guidelines for Writing Good Generic Functions \n\nPush Type Parameters Down \n\nRule: When possible, use the type parameter itself rather than constraining it \n\nUse Fewer Type Parameters \n\nRule: Always use as few type parameters as possible \n\nType Parameters Should Appear Twice \n\nRule: If a type parameter only appears in one location, strongly reconsider if you actually need it \n\n * Optional Parameters \n\n * Function Overloads \n\nIn TypeScript, we can specify a function that can be called in different ways by writing overload signatures. To do this, write some number of function signatures (usually two or more), followed by the body of the function:  () :\n\nfunction makeDate(timestamp: number): Date;\nfunction makeDate(m: number, d: number, y: number): Date;\nfunction makeDate(mOrTimestamp: number, d?: number, y?: number): Date {\n  if (d !== undefined && y !== undefined) {\n    return new Date(y, mOrTimestamp, d);\n  } else {\n    return new Date(mOrTimestamp);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * Writing Good Overloads \n\nAlways prefer parameters with union types instead of overloads when possible \n\n * Other Types to Know About \n\nvoid\n\nIn JavaScript, a function that doesnt return any value will implicitly return the value undefined. However, void and undefined are not the same thing in TypeScript.  JavaScript void  undefined \n\nobject\n\nThe special type object refers to any value that isnt a primitive (string, number, bigint, boolean, symbol, null, or undefined). This is different from the empty object type { }, and also different from the global type Object. Its very likely you will never use Object.  (string number bigint boolean symbol null  undefined) {}  Object Object\n\nobject is not Object. Always use object! \n\nunknown\n\nThe unknown type represents any value. This is similar to the any type, but is safer because its not legal to do anything with an unknown value. \n\nnever\n\nThe never type represents values which are never observed. In a return type, this means that the function throws an exception or terminates execution of the program. Never \n\nnever also appears when TypeScript determines theres nothing left in a union. \n\nFunction\n\nThe global type Function describes properties like bind, call, apply, and others present on all function values in JavaScript. It also has the special property that values of type Function can always be called; these calls return any.  Function  bind call apply  JavaScript  Function \n\nThis is an untyped function call and is generally best avoided because of the unsafe any return type. \n\nIf you need to accept an arbitrary function but dont intend to call it, the type () => void is generally safer.  type () => void \n\n * Rest Parameters and Arguments\n\n * Parameter Destructuring \n\nAssignability of Functions \n\nReturn type void:\n\nContextual typing with a return type of void does not force functions to not return something. Another way to say this is a contextual function type with a void return type (type vf = () => void), when implemented, can return any other value, but it will be ignored.  void  void  (type vf = () = > void) \n\nAnd when the return value of one of these functions is assigned to another variable, it will retain the type of void.  void \n\nThere is one other special case to be aware of, when a literal function definition has a void return type, that function must not return anything.  void \n\n\n# Object Types \n\n * Property Modifiers \n\n * Optional Properties \n\nNote that there is currently no way to place type annotations within destructuring patterns. This is because the following syntax already means something different in JavaScript.  JavaScript \n\n * readonly Properties\n\nProperties can also be marked as readonly for TypeScript. While it wont change any behavior at runtime, a property marked as readonly cant be written to during type-checking.  TypeScript  readonly \n\nUsing the readonly modifier doesnt necessarily imply that a value is totally immutable - or in other words, that its internal contents cant be changed. It just means the property itself cant be re-written to.  readonly \n\n * Index Signatures \n\nAn index signature property type must be either string or number.  string   number\n\nWhile string index signatures are a powerful way to describe the dictionary pattern, they also enforce that all properties match their return type. This is because a string index declares that obj.property is also available as obj["property"] .    obj.property  obj [ property] \n\nyou can make index signatures readonly in order to prevent assignment to their indices. \n\ninterface ReadonlyStringArray {\n  readonly [index: number]: string;\n}\n\n\n1\n2\n3\n\n\n * Extending Types \n\n * Intersection Types \n\n * Interfaces vs. Intersections\n\nWe just looked at two ways to combine types which are similar, but are actually subtly different. With interfaces, we could use an extends clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias. The principle difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why youd pick one over the other between an interface and a type alias of an intersection type.  extends \n\n * Generic Object Types \n\n * The Array Type\n\n * The ReadonlyArray Type\n\nThe ReadonlyArray is a special type that describes arrays that shouldnt be changed. ReadonlyArray \n\nMuch like the readonly modifier for properties, its mainly a tool we can use for intent. When we see a function that returns ReadonlyArrays, it tells us were not meant to change the contents at all, and when we see a function that consumes ReadonlyArrays, it tells us that we can pass any array into that function without worrying that it will change its contents.  readonly  ReadonlyArrays  ReadonlyArrays \n\nJust as TypeScript provides a shorthand syntax for Array<Type> with Type[], it also provides a shorthand syntax for ReadonlyArray<Type> with readonly Type[].  TypeScript  Array <Type>  Type []  ReadonlyArray < Type >  readonly Type []\n\n * Tuple Types \n\nA tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions. Tuple  Array \n\nAnother thing you may be interested in is that tuples can have optional properties by writing out a question mark (? after an elements type). Optional tuple elements can only come at the end, and also affect the type of length.  () tuple \n\nTuples can also have rest elements, which have to be an array/tuple type.  rest  / \n\ntype Either2dOr3d = [number, number, number?];\ntype StringNumberBooleans = [string, number, ...boolean[]];\ntype StringBooleansNumber = [string, ...boolean[], number];\ntype BooleansStringNumber = [...boolean[], string, number];\n\n\n1\n2\n3\n4\n\n\nA tuple with a rest element has no set length - it only has a set of well-known elements in different positions.  rest  tuple   \n\n * readonly Tuple Types \n\n\n# modules \n\n\n# Non-modules \n\nThe JavaScript specification declares that any JavaScript files without an export or top-level await should be considered a script and not a module. JavaScript  JavaScript \n\n\n# CommonJS and ES Modules interop  ES \n\nThere is a mis-match in features between CommonJS and ES Modules regarding the distinction between a default import and a module namespace object import. TypeScript has a compiler flag to reduce the friction between the two different sets of constraints with esModuleInterop.\n\nCommonJS  ES Modules TypeScript  esModuleInterop ',normalizedContent:'# \n\n\n\n * \n * the basics\n * everyday types \n * narrowing \n * more on functions\n * object types \n * modules \n   * non-modules \n   * commonjs and es modules interop  es \n\n\n\n\n# the basics\n\n * static type-checking \n\nstatic types systems describe the shapes and behaviors of what our values will be when we run our programs. a type-checker like typescript uses that information and tells us when things might be going off the rails. \n\n * non-exception failures \n\na static type system has to make the call over what code should be flagged as an error in its system, even if its valid javascript that wont immediately throw an error.   javascript\n\n * types for tooling \n\nthe type-checker has information to check things like whether were accessing the right properties on variables and other properties. once it has that information, it can also start suggesting which properties you might want to use. \n\n * tsc, the typescript compiler \n\n * explicit types \n\n * erased types \n\ntype annotations arent part of javascript (or ecmascript to be pedantic), so there really arent any browsers or other runtimes that can just run typescript unmodified. thats why typescript needs a compiler in the first place - it needs some way to strip out or transform any typescript-specific code so that you can run it.  javascript  ( ecmascript )   \n\n * downleveling \n\ntypescript has the ability to rewrite code from newer versions of ecmascript to older ones such as ecmascript 3 or ecmascript 5 (a.k.a. es3 and es5). this process of moving from a newer or higher version of ecmascript down to an older or lower one is sometimes called downleveling.  ecmascript  ecmascript 3  ecmascript 5 ( es3  es5)   ecmascript   \n\nby default typescript targets es3, an extremely old version of ecmascript. we could have chosen something a little bit more recent by using the target option. running with --target es2015 changes typescript to target ecmascript 2015, meaning code should be able to run wherever ecmascript 2015 is supported.  es3 ecmascript  target  -- target es2015  ecmascript 2015 ecmascript 2015 \n\nwhile the default target is es3, the great majority of current browsers support es2015. most developers can therefore safely specify es2015 or above as a target, unless compatibility with certain ancient browsers is important.  es3 es2015 es2015 \n\n * strictness \n\nin contrast, a lot of users prefer to have typescript validate as much as it can straight away, and thats why the language provides strictness settings as well. these strictness settings turn static type-checking from a switch (either your code is checked or not) into something closer to a dial. the further you turn this dial up, the more typescript will check for you. this can require a little extra work, but generally speaking it pays for itself in the long run, and enables more thorough checks and more accurate tooling. when possible, a new codebase should always turn these strictness checks on.  typescript  () \n\nthe strict flag in the cli, or "strict": true in a tsconfig.json toggles them all on simultaneously, but we can opt out of them individually. the two biggest ones you should know about are noimplicitany and strictnullchecks. cli  strict:  tsconfig.json  true noimplicitany  strictnullcheck\n\n\n# everyday types \n\n * the primitives: string,number, and boolean\n * arrays \n * any\n * functions\n * anonymous functions \n * object types \n * optional properties \n * union types \n * type aliases \n * interfaces \n * type assertions \n\ntypescript only allows type assertions which convert to a more specific or less specific version of a type. \n\nsometimes this rule can be too conservative and will disallow more complex coercions that might be valid. if this happens, you can use two assertions, first to any (or unknown, which well introduce later), then to the desired type.  any ( unknown) \n\n * literal types \n * literal inference \n\nthe as const suffix acts like const but for the type system, ensuring that all properties are assigned the literal type instead of a more general version like string or number. as const  const\n\n * null and undefined\n * enums\n * less common primitives technique bigintsymbol\n\n\n# narrowing \n\n * typeof type guards\n\n"string""number""bigint""boolean""symbol""undefined""object""function"\n\n * truthiness narrowing\n * equality narrowing\n * the in operator narrowing\n * instanceof narrowing\n * assignments \n * control flow analysis \n * using type predicates \n\na predicate takes the form parametername is type, where parametername must be the name of a parameter from the current function signature.  parametername is type parametername \n\nclasses can use this is type to narrow their type.  this is type \n\n * discriminated unions \n\n * the never type\n\nwhen narrowing, you can reduce the options of a union to a point where you have removed all possibilities and have nothing left. in those cases, typescript will use a never type to represent a state which shouldnt exist. typescript  never \n\n * exhaustiveness checking \n\nthe never type is assignable to every type; however, no type is assignable to never (except never itself). this means you can use narrowing and rely on never turning up to do exhaustive checking in a switch statement. never  never () switch \n\n\n# more on functions\n\n * function type expressions \n * call signatures \n\nin javascript, functions can have properties in addition to being callable. however, the function type expression syntax doesnt allow for declaring properties. if we want to describe something callable with properties, we can write a call signature in an object type.  javascript .\n\ntype describablefunction = {\n  description: string;\n  (somearg: number): boolean;\n};\nfunction dosomething(fn: describablefunction) {\n  console.log(fn.description + " returned " + fn(6));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * construct signatures \n\njavascript functions can also be invoked with the new operator. typescript refers to these as constructors because they usually create a new object. you can write a construct signature by adding the new keyword in front of a call signature:  new :\n\ntype someconstructor = {\n  new (s: string): someobject;\n};\nfunction fn(ctor: someconstructor) {\n  return new ctor("hello");\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nsome objects, like javascripts date object, can be called with or without new. you can combine call and construct signatures in the same type arbitrarily:  javascript  date  new :\n\ninterface callorconstruct {\n  new (s: string): date;\n  (n?: number): number;\n}\n\n\n1\n2\n3\n4\n\n * generic functions \n\nin typescript, generics are used when we want to describe a correspondence between two values.  typescript \n\n * inference \n * constraints \n\nsometimes we want to relate two values, but can only operate on a certain subset of values. in this case, we can use a constraint to limit the kinds of types that a type parameter can accept. \n\nfunction longest<type extends { length: number }>(a: type, b: type) {\n  if (a.length >= b.length) {\n    return a;\n  } else {\n    return b;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n * working with constrained values \n\n * specifying type arguments \n\n * guidelines for writing good generic functions \n\npush type parameters down \n\nrule: when possible, use the type parameter itself rather than constraining it \n\nuse fewer type parameters \n\nrule: always use as few type parameters as possible \n\ntype parameters should appear twice \n\nrule: if a type parameter only appears in one location, strongly reconsider if you actually need it \n\n * optional parameters \n\n * function overloads \n\nin typescript, we can specify a function that can be called in different ways by writing overload signatures. to do this, write some number of function signatures (usually two or more), followed by the body of the function:  () :\n\nfunction makedate(timestamp: number): date;\nfunction makedate(m: number, d: number, y: number): date;\nfunction makedate(mortimestamp: number, d?: number, y?: number): date {\n  if (d !== undefined && y !== undefined) {\n    return new date(y, mortimestamp, d);\n  } else {\n    return new date(mortimestamp);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * writing good overloads \n\nalways prefer parameters with union types instead of overloads when possible \n\n * other types to know about \n\nvoid\n\nin javascript, a function that doesnt return any value will implicitly return the value undefined. however, void and undefined are not the same thing in typescript.  javascript void  undefined \n\nobject\n\nthe special type object refers to any value that isnt a primitive (string, number, bigint, boolean, symbol, null, or undefined). this is different from the empty object type { }, and also different from the global type object. its very likely you will never use object.  (string number bigint boolean symbol null  undefined) {}  object object\n\nobject is not object. always use object! \n\nunknown\n\nthe unknown type represents any value. this is similar to the any type, but is safer because its not legal to do anything with an unknown value. \n\nnever\n\nthe never type represents values which are never observed. in a return type, this means that the function throws an exception or terminates execution of the program. never \n\nnever also appears when typescript determines theres nothing left in a union. \n\nfunction\n\nthe global type function describes properties like bind, call, apply, and others present on all function values in javascript. it also has the special property that values of type function can always be called; these calls return any.  function  bind call apply  javascript  function \n\nthis is an untyped function call and is generally best avoided because of the unsafe any return type. \n\nif you need to accept an arbitrary function but dont intend to call it, the type () => void is generally safer.  type () => void \n\n * rest parameters and arguments\n\n * parameter destructuring \n\nassignability of functions \n\nreturn type void:\n\ncontextual typing with a return type of void does not force functions to not return something. another way to say this is a contextual function type with a void return type (type vf = () => void), when implemented, can return any other value, but it will be ignored.  void  void  (type vf = () = > void) \n\nand when the return value of one of these functions is assigned to another variable, it will retain the type of void.  void \n\nthere is one other special case to be aware of, when a literal function definition has a void return type, that function must not return anything.  void \n\n\n# object types \n\n * property modifiers \n\n * optional properties \n\nnote that there is currently no way to place type annotations within destructuring patterns. this is because the following syntax already means something different in javascript.  javascript \n\n * readonly properties\n\nproperties can also be marked as readonly for typescript. while it wont change any behavior at runtime, a property marked as readonly cant be written to during type-checking.  typescript  readonly \n\nusing the readonly modifier doesnt necessarily imply that a value is totally immutable - or in other words, that its internal contents cant be changed. it just means the property itself cant be re-written to.  readonly \n\n * index signatures \n\nan index signature property type must be either string or number.  string   number\n\nwhile string index signatures are a powerful way to describe the dictionary pattern, they also enforce that all properties match their return type. this is because a string index declares that obj.property is also available as obj["property"] .    obj.property  obj [ property] \n\nyou can make index signatures readonly in order to prevent assignment to their indices. \n\ninterface readonlystringarray {\n  readonly [index: number]: string;\n}\n\n\n1\n2\n3\n\n\n * extending types \n\n * intersection types \n\n * interfaces vs. intersections\n\nwe just looked at two ways to combine types which are similar, but are actually subtly different. with interfaces, we could use an extends clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias. the principle difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why youd pick one over the other between an interface and a type alias of an intersection type.  extends \n\n * generic object types \n\n * the array type\n\n * the readonlyarray type\n\nthe readonlyarray is a special type that describes arrays that shouldnt be changed. readonlyarray \n\nmuch like the readonly modifier for properties, its mainly a tool we can use for intent. when we see a function that returns readonlyarrays, it tells us were not meant to change the contents at all, and when we see a function that consumes readonlyarrays, it tells us that we can pass any array into that function without worrying that it will change its contents.  readonly  readonlyarrays  readonlyarrays \n\njust as typescript provides a shorthand syntax for array<type> with type[], it also provides a shorthand syntax for readonlyarray<type> with readonly type[].  typescript  array <type>  type []  readonlyarray < type >  readonly type []\n\n * tuple types \n\na tuple type is another sort of array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions. tuple  array \n\nanother thing you may be interested in is that tuples can have optional properties by writing out a question mark (? after an elements type). optional tuple elements can only come at the end, and also affect the type of length.  () tuple \n\ntuples can also have rest elements, which have to be an array/tuple type.  rest  / \n\ntype either2dor3d = [number, number, number?];\ntype stringnumberbooleans = [string, number, ...boolean[]];\ntype stringbooleansnumber = [string, ...boolean[], number];\ntype booleansstringnumber = [...boolean[], string, number];\n\n\n1\n2\n3\n4\n\n\na tuple with a rest element has no set length - it only has a set of well-known elements in different positions.  rest  tuple   \n\n * readonly tuple types \n\n\n# modules \n\n\n# non-modules \n\nthe javascript specification declares that any javascript files without an export or top-level await should be considered a script and not a module. javascript  javascript \n\n\n# commonjs and es modules interop  es \n\nthere is a mis-match in features between commonjs and es modules regarding the distinction between a default import and a module namespace object import. typescript has a compiler flag to reduce the friction between the two different sets of constraints with esmoduleinterop.\n\ncommonjs  es modules typescript  esmoduleinterop ',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"type-manipulation ",frontmatter:{title:"type-manipulation ",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/basic/type-manipulation/",categories:["typescript-utility","basic"],tags:[null]},regularPath:"/30.web/4.typescript-utility/10.%E5%9F%BA%E7%A1%80/20.type-manipulation.html",relativePath:"30.web/4.typescript-utility/10./20.type-manipulation.md",key:"v-25439586",path:"/ts/basic/type-manipulation/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"Generics ",slug:"generics-",normalizedTitle:"generics ",charIndex:17},{level:2,title:"Keyof Type Operator ",slug:"keyof-type-operator-",normalizedTitle:"keyof type operator ",charIndex:32},{level:2,title:"Typeof Type Operator",slug:"typeof-type-operator",normalizedTitle:"typeof type operator",charIndex:63},{level:2,title:"Indexed Access Types",slug:"indexed-access-types",normalizedTitle:"indexed access types",charIndex:87},{level:2,title:"Conditional Types ",slug:"conditional-types-",normalizedTitle:"conditional types ",charIndex:111},{level:2,title:"Mapped Types ",slug:"mapped-types-",normalizedTitle:"mapped types ",charIndex:137},{level:2,title:"Template Literal Types ",slug:"template-literal-types-",normalizedTitle:"template literal types ",charIndex:158}],readingTime:{text:"5 min read",minutes:4.84,time:290400,words:968},headersStr:" Generics  Keyof Type Operator  Typeof Type Operator Indexed Access Types Conditional Types  Mapped Types  Template Literal Types ",content:'# \n\n\n\n * \n * Generics \n * Keyof Type Operator \n * Typeof Type Operator\n * Indexed Access Types\n * Conditional Types \n * Mapped Types \n * Template Literal Types \n\n\n\n\n# Generics \n\n * Generic Types\n\nWe can also write the generic type as a call signature of an object literal type: :\n\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n \nlet myIdentity: { <Type>(arg: Type): Type } = identity;\n\n\n1\n2\n3\n4\n5\n\n * Generic Classes: \n\nA class has two sides to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the classs type parameter. \n\n * Generic Constraints: \n\n * Using Type Parameters in Generic Constraints\n\n * Using Class Types in Generics\n\n\n# Keyof Type Operator \n\nIf the type has a string or number index signature, keyof will return those types instead: keyof :\n\ntype Arrayish = { [n: number]: unknown };\ntype A = keyof Arrayish;\n \ntype Mapish = { [k: string]: boolean };\ntype M = keyof Mapish;\n\n\n1\n2\n3\n4\n5\n\n\n\n# Typeof Type Operator\n\nits only legal to use typeof on identifiers (i.e. variable names) or their properties.  typeof on  () \n\n\n# Indexed Access Types\n\nThe indexing type is itself a type, so we can use unions, keyof, or other types entirely: :\n\ntype I1 = Person["age" | "name"];\ntype I2 = Person[keyof Person];\n\n\n1\n2\n\n\nAnother example of indexing with an arbitrary type is using number to get the type of an arrays elements. We can combine this with typeof to conveniently capture the element type of an array literal:  number  typeof :\n\nconst MyArray = [\n  { name: "Alice", age: 15 },\n  { name: "Bob", age: 23 },\n  { name: "Eve", age: 38 },\n];\ntype Age = typeof MyArray[number]["age"];\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# Conditional Types \n\ntype NameOrId<T extends number | string> = T extends number\n  ? IdLabel\n  : NameLabel;\n\n\n1\n2\n3\n\n * Conditional Type Constraints \n\ntype MessageOf<T extends { message: unknown }> = T["message"];\ntype Flatten<T> = T extends any[] ? T[number] : T;\n\n\n1\n2\n\n * Inferring Within Conditional Types \n\ntype Flatten<Type> = Type extends Array<infer Item> ? Item : Type;\n\ntype GetReturnType<Type> = Type extends (...args: never[]) => infer Return\n  ? Return\n  : never;\n\n\n1\n2\n3\n4\n5\n\n * Distributive Conditional Types: \n\nWhen conditional types act on a generic type, they become distributive when given a union type. \n\ntype ToArray<Type> = Type extends any ? Type[] : never;\n \ntype StrArrOrNumArr = ToArray<string | number>; // type StrArrOrNumArr = string[] | number[]\n\n\n1\n2\n3\n\n\nTypically, distributivity is the desired behavior. To avoid that behavior, you can surround each side of the extends keyword with square brackets.  extends \n\ntype ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;\n \n// \'StrArrOrNumArr\' is no longer a union.\ntype StrArrOrNumArr = ToArrayNonDist<string | number>; //type StrArrOrNumArr = (string | number)[]\n\n\n1\n2\n3\n4\n\n\n\n# Mapped Types \n\nMapped types build on the syntax for index signatures, which are used to declare the types of properties which have not been declared ahead of time: :\n\ntype OnlyBoolsAndHorses = {\n  [key: string]: boolean | Horse;\n};\n\ntype OptionsFlags<Type> = {\n  [Property in keyof Type]: boolean;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * Mapping Modifiers: \n\nThere are two additional modifiers which can be applied during mapping: readonly and ? which affect mutability and optionality respectively. : readonly \n\nYou can remove or add these modifiers by prefixing with - or +. If you dont add a prefix, then + is assumed.  -  +  + \n\ntype CreateMutable<Type> = {\n  -readonly [Property in keyof Type]: Type[Property];\n};\ntype Concrete<Type> = {\n  [Property in keyof Type]-?: Type[Property];\n};\n\n\n1\n2\n3\n4\n5\n6\n\n * Key Remapping via as\n\nIn TypeScript 4.1 and onwards, you can re-map keys in mapped types with an as clause in a mapped type:  TypeScript 4.1  as :\n\ntype Getters<Type> = {\n    [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]\n};\n \ninterface Person {\n    name: string;\n    age: number;\n    location: string;\n}\n// type LazyPerson = {\n//     getName: () => string;\n//     getAge: () => number;\n//     getLocation: () => string;\n// }\ntype LazyPerson = Getters<Person>;\n\ntype RemoveKindField<Type> = {\n    [Property in keyof Type as Exclude<Property, "kind">]: Type[Property]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nYou can map over arbitrary unions, not just unions of string | number | symbol, but unions of any type:  |  | :\n\ntype EventConfig<Events extends { kind: string }> = {\n    [E in Events as E["kind"]]: (event: E) => void;\n}\n \ntype SquareEvent = { kind: "square", x: number, y: number };\ntype CircleEvent = { kind: "circle", radius: number };\n// type Config = {\n//     square: (event: SquareEvent) => void;\n//     circle: (event: CircleEvent) => void;\n// }\ntype Config = EventConfig<SquareEvent | CircleEvent>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Template Literal Types \n\n * String Unions in Types \n\ntype PropEventSource<Type> = {\n    on(eventName: `${string & keyof Type}Changed`, callback: (newValue: any) => void): void;\n};\n \n/// Create a "watched object" with an \'on\' method\n/// so that you can watch for changes to properties.\ndeclare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * Inference with Template Literals: \n\ntype PropEventSource<Type> = {\n    on<Key extends string & keyof Type>\n        (eventName: `${Key}Changed`, callback: (newValue: Type[Key]) => void ): void;\n};\n\n\n1\n2\n3\n4\n\n * Intrinsic String Manipulation Types: \n\nTo help with string manipulation, TypeScript includes a set of types which can be used in string manipulation. These types come built-in to the compiler for performance and cant be found in the .d.ts files included with TypeScript.\n\nTypeScript  d.ts \n\nUppercase<StringType> : Converts each character in the string to the uppercase version. \n\nLowercase<StringType> : Converts each character in the string to the lowercase equivalent. \n\nCapitalize<StringType> : Converts the first character in the string to an uppercase equivalent. \n\nUncapitalize<StringType> : Converts the first character in the string to a lowercase equivalent. ',normalizedContent:'# \n\n\n\n * \n * generics \n * keyof type operator \n * typeof type operator\n * indexed access types\n * conditional types \n * mapped types \n * template literal types \n\n\n\n\n# generics \n\n * generic types\n\nwe can also write the generic type as a call signature of an object literal type: :\n\nfunction identity<type>(arg: type): type {\n  return arg;\n}\n \nlet myidentity: { <type>(arg: type): type } = identity;\n\n\n1\n2\n3\n4\n5\n\n * generic classes: \n\na class has two sides to its type: the static side and the instance side. generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the classs type parameter. \n\n * generic constraints: \n\n * using type parameters in generic constraints\n\n * using class types in generics\n\n\n# keyof type operator \n\nif the type has a string or number index signature, keyof will return those types instead: keyof :\n\ntype arrayish = { [n: number]: unknown };\ntype a = keyof arrayish;\n \ntype mapish = { [k: string]: boolean };\ntype m = keyof mapish;\n\n\n1\n2\n3\n4\n5\n\n\n\n# typeof type operator\n\nits only legal to use typeof on identifiers (i.e. variable names) or their properties.  typeof on  () \n\n\n# indexed access types\n\nthe indexing type is itself a type, so we can use unions, keyof, or other types entirely: :\n\ntype i1 = person["age" | "name"];\ntype i2 = person[keyof person];\n\n\n1\n2\n\n\nanother example of indexing with an arbitrary type is using number to get the type of an arrays elements. we can combine this with typeof to conveniently capture the element type of an array literal:  number  typeof :\n\nconst myarray = [\n  { name: "alice", age: 15 },\n  { name: "bob", age: 23 },\n  { name: "eve", age: 38 },\n];\ntype age = typeof myarray[number]["age"];\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# conditional types \n\ntype nameorid<t extends number | string> = t extends number\n  ? idlabel\n  : namelabel;\n\n\n1\n2\n3\n\n * conditional type constraints \n\ntype messageof<t extends { message: unknown }> = t["message"];\ntype flatten<t> = t extends any[] ? t[number] : t;\n\n\n1\n2\n\n * inferring within conditional types \n\ntype flatten<type> = type extends array<infer item> ? item : type;\n\ntype getreturntype<type> = type extends (...args: never[]) => infer return\n  ? return\n  : never;\n\n\n1\n2\n3\n4\n5\n\n * distributive conditional types: \n\nwhen conditional types act on a generic type, they become distributive when given a union type. \n\ntype toarray<type> = type extends any ? type[] : never;\n \ntype strarrornumarr = toarray<string | number>; // type strarrornumarr = string[] | number[]\n\n\n1\n2\n3\n\n\ntypically, distributivity is the desired behavior. to avoid that behavior, you can surround each side of the extends keyword with square brackets.  extends \n\ntype toarraynondist<type> = [type] extends [any] ? type[] : never;\n \n// \'strarrornumarr\' is no longer a union.\ntype strarrornumarr = toarraynondist<string | number>; //type strarrornumarr = (string | number)[]\n\n\n1\n2\n3\n4\n\n\n\n# mapped types \n\nmapped types build on the syntax for index signatures, which are used to declare the types of properties which have not been declared ahead of time: :\n\ntype onlyboolsandhorses = {\n  [key: string]: boolean | horse;\n};\n\ntype optionsflags<type> = {\n  [property in keyof type]: boolean;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * mapping modifiers: \n\nthere are two additional modifiers which can be applied during mapping: readonly and ? which affect mutability and optionality respectively. : readonly \n\nyou can remove or add these modifiers by prefixing with - or +. if you dont add a prefix, then + is assumed.  -  +  + \n\ntype createmutable<type> = {\n  -readonly [property in keyof type]: type[property];\n};\ntype concrete<type> = {\n  [property in keyof type]-?: type[property];\n};\n\n\n1\n2\n3\n4\n5\n6\n\n * key remapping via as\n\nin typescript 4.1 and onwards, you can re-map keys in mapped types with an as clause in a mapped type:  typescript 4.1  as :\n\ntype getters<type> = {\n    [property in keyof type as `get${capitalize<string & property>}`]: () => type[property]\n};\n \ninterface person {\n    name: string;\n    age: number;\n    location: string;\n}\n// type lazyperson = {\n//     getname: () => string;\n//     getage: () => number;\n//     getlocation: () => string;\n// }\ntype lazyperson = getters<person>;\n\ntype removekindfield<type> = {\n    [property in keyof type as exclude<property, "kind">]: type[property]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nyou can map over arbitrary unions, not just unions of string | number | symbol, but unions of any type:  |  | :\n\ntype eventconfig<events extends { kind: string }> = {\n    [e in events as e["kind"]]: (event: e) => void;\n}\n \ntype squareevent = { kind: "square", x: number, y: number };\ntype circleevent = { kind: "circle", radius: number };\n// type config = {\n//     square: (event: squareevent) => void;\n//     circle: (event: circleevent) => void;\n// }\ntype config = eventconfig<squareevent | circleevent>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# template literal types \n\n * string unions in types \n\ntype propeventsource<type> = {\n    on(eventname: `${string & keyof type}changed`, callback: (newvalue: any) => void): void;\n};\n \n/// create a "watched object" with an \'on\' method\n/// so that you can watch for changes to properties.\ndeclare function makewatchedobject<type>(obj: type): type & propeventsource<type>;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * inference with template literals: \n\ntype propeventsource<type> = {\n    on<key extends string & keyof type>\n        (eventname: `${key}changed`, callback: (newvalue: type[key]) => void ): void;\n};\n\n\n1\n2\n3\n4\n\n * intrinsic string manipulation types: \n\nto help with string manipulation, typescript includes a set of types which can be used in string manipulation. these types come built-in to the compiler for performance and cant be found in the .d.ts files included with typescript.\n\ntypescript  d.ts \n\nuppercase<stringtype> : converts each character in the string to the uppercase version. \n\nlowercase<stringtype> : converts each character in the string to the lowercase equivalent. \n\ncapitalize<stringtype> : converts the first character in the string to an uppercase equivalent. \n\nuncapitalize<stringtype> : converts the first character in the string to a lowercase equivalent. ',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"classes ",frontmatter:{title:"classes ",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/basic/classes/",categories:["typescript-utility","basic"],tags:[null]},regularPath:"/30.web/4.typescript-utility/10.%E5%9F%BA%E7%A1%80/30.classes.html",relativePath:"30.web/4.typescript-utility/10./30.classes.md",key:"v-27eebe53",path:"/ts/basic/classes/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"Class Members ",slug:"class-members-",normalizedTitle:"class members ",charIndex:17},{level:3,title:"--strictPropertyInitialization",slug:"strictpropertyinitialization",normalizedTitle:"--strictpropertyinitialization",charIndex:40},{level:2,title:"readonly",slug:"readonly",normalizedTitle:"readonly",charIndex:74},{level:2,title:"Constructors ",slug:"constructors-",normalizedTitle:"constructors ",charIndex:86},{level:2,title:"Super Calls ",slug:"super-calls-",normalizedTitle:"super calls ",charIndex:106},{level:2,title:"Methods ",slug:"methods-",normalizedTitle:"methods ",charIndex:129},{level:2,title:"Getters / Setters",slug:"getters-setters",normalizedTitle:"getters / setters",charIndex:143},{level:2,title:"Index Signatures ",slug:"index-signatures-",normalizedTitle:"index signatures ",charIndex:164},{level:2,title:"Class Heritage ",slug:"class-heritage-",normalizedTitle:"class heritage ",charIndex:189},{level:2,title:"Member Visibility ",slug:"member-visibility-",normalizedTitle:"member visibility ",charIndex:211},{level:2,title:"Static Members ",slug:"static-members-",normalizedTitle:"static members ",charIndex:238},{level:2,title:"Special Static Names ",slug:"special-static-names-",normalizedTitle:"special static names ",charIndex:261},{level:2,title:"Why No Static Classes? ",slug:"why-no-static-classes-",normalizedTitle:"why no static classes? ",charIndex:292},{level:2,title:"static Blocks in Classes ",slug:"static-blocks-in-classes-",normalizedTitle:"static blocks in classes ",charIndex:328},{level:2,title:"Generic Classes ",slug:"generic-classes-",normalizedTitle:"generic classes ",charIndex:361},{level:2,title:"Type Parameters in Static Members ",slug:"type-parameters-in-static-members-",normalizedTitle:"type parameters in static members ",charIndex:384},{level:2,title:"this at Runtime in Classes",slug:"this-at-runtime-in-classes",normalizedTitle:"this at runtime in classes ",charIndex:9053},{level:2,title:"Arrow Functions ",slug:"arrow-functions-",normalizedTitle:"arrow functions ",charIndex:469},{level:2,title:"this parameters ",slug:"this-parameters-",normalizedTitle:"this parameters ",charIndex:493},{level:2,title:"this Types ",slug:"this-types-",normalizedTitle:"this types ",charIndex:515},{level:2,title:"this-based type guards ",slug:"this-based-type-guards-",normalizedTitle:"this-based type guards ",charIndex:533},{level:2,title:"Parameter Properties ",slug:"parameter-properties-",normalizedTitle:"parameter properties ",charIndex:567},{level:2,title:"Class Expressions ",slug:"class-expressions-",normalizedTitle:"class expressions ",charIndex:596},{level:2,title:"abstract Classes and Members ",slug:"abstract-classes-and-members-",normalizedTitle:"abstract classes and members ",charIndex:623},{level:2,title:"Abstract Construct Signatures ",slug:"abstract-construct-signatures-",normalizedTitle:"abstract construct signatures ",charIndex:661},{level:2,title:"Relationships Between Classes ",slug:"relationships-between-classes-",normalizedTitle:"relationships between classes ",charIndex:701}],readingTime:{text:"10 min read",minutes:9.535,time:572100,words:1907},headersStr:" Class Members  --strictPropertyInitialization readonly Constructors  Super Calls  Methods  Getters / Setters Index Signatures  Class Heritage  Member Visibility  Static Members  Special Static Names  Why No Static Classes?  static Blocks in Classes  Generic Classes  Type Parameters in Static Members  this at Runtime in Classes Arrow Functions  this parameters  this Types  this-based type guards  Parameter Properties  Class Expressions  abstract Classes and Members  Abstract Construct Signatures  Relationships Between Classes ",content:'# \n\n\n\n * \n * Class Members \n   * --strictPropertyInitialization\n * readonly\n * Constructors \n * Super Calls \n * Methods \n * Getters / Setters\n * Index Signatures \n * Class Heritage \n * Member Visibility \n * Static Members \n * Special Static Names \n * Why No Static Classes? \n * static Blocks in Classes \n * Generic Classes \n * Type Parameters in Static Members \n * this at Runtime in Classes\n * Arrow Functions \n * this parameters \n * this Types \n * this-based type guards \n * Parameter Properties \n * Class Expressions \n * abstract Classes and Members \n * Abstract Construct Signatures \n * Relationships Between Classes \n\n\n\n\n# Class Members \n\n\n# --strictPropertyInitialization\n\nThe strictPropertyInitialization setting controls whether class fields need to be initialized in the constructor. strictPropertyInitialization \n\nIf you intend to definitely initialize a field through means other than the constructor (for example, maybe an external library is filling in part of your class for you), you can use the definite assignment assertion operator, !:  () \n\n\n# readonly\n\nFields may be prefixed with the readonly modifier. This prevents assignments to the field outside of the constructor.  readonly \n\n\n# Constructors \n\nClass constructors are very similar to functions. You can add parameters with type annotations, default values, and overloads. \n\nThere are just a few differences between class constructor signatures and function signatures: :\n\n * Constructors cant have type parameters - these belong on the outer class declaration.   \n * onstructors cant have return type annotations - the class instance type is always whats returned   \n\n\n# Super Calls \n\n\n# Methods \n\n\n# Getters / Setters\n\nTypeScript has some special inference rules for accessors: :\n\n * If get exists but no set, the property is automatically readonly.  get \n * If the type of the setter parameter is not specified, it is inferred from the return type of the getter.  setter  getter \n * Getters and setters must have the same Member Visibility. Getters  setter  Visibility\n\n\n# Index Signatures \n\nclass MyClass {\n  [s: string]: boolean | ((s: string) => boolean);\n \n  check(s: string) {\n    return this[s] as boolean;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Class Heritage \n\n * implements Classes may also implement multiple interfaces, e.g. class C implements A, B {}.\n * extendsA derived class has all the properties and methods of its base class, and also define additional members. \n * Overriding Methods A derived class can also override a base class field or property. You can use the super. syntax to access base class methods. \n * Initialization Order \n * Inheriting Built-in Types \n\nIn ES2015, constructors which return an object implicitly substitute the value of this for any callers of super(...). It is necessary for generated constructor code to capture any potential return value of super(...) and replace it with this.  es2015  super (...)  super (...) \n\nAs a result, subclassing Error, Array, and others may no longer work as expected. This is due to the fact that constructor functions for Error, Array, and the like use ECMAScript 6s new.target to adjust the prototype chain; however, there is no way to ensure a value for new.target when invoking a constructor in ECMAScript 5. Other downlevel compilers generally have the same limitation by default.  Error Array  ErrorArray  ECMAScript 6  new.target  ECMAScript 5  new.target \n\nAs a recommendation, you can manually adjust the prototype immediately after any super(...) calls.  super (...) \n\nclass MsgError extends Error {\n  constructor(m: string) {\n    super(m);\n \n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, MsgError.prototype);\n  }\n \n  sayHello() {\n    return "hello " + this.message;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nHowever, any subclass of MsgError will have to manually set the prototype as well. For runtimes that dont support Object.setPrototypeOf, you may instead be able to use proto. MsgError  Object.setPrototypeOf  _ proto _\n\nUnfortunately, these workarounds will not work on Internet Explorer 10 and prior. One can manually copy methods from the prototype onto the instance itself (i.e. MsgError.prototype onto this), but the prototype chain itself cannot be fixed.  Internet Explorer 10  (MsgError.prototype ) \n\n\n# Member Visibility \n\n * public: A public member can be accessed anywhere. public \n * protected protected members are only visible to subclasses of the class theyre declared in. \n * exposure of  protected members Derived classes need to follow their base class contracts, but may choose to expose a subtype of base class with more capabilities. This includes making protected members public\n * privateprivate is like protected, but doesnt allow access to the member even from subclasses.Private  protected\n * Cross-instance  private access \n\nDifferent OOP languages disagree about whether different instances of the same class may access each others private members. While languages like Java, C#, C++, Swift, and PHP allow this, Ruby does not.  OOP  Java c #  c + +  Swift  PHP  Ruby TypeScript does allow cross-instance private access.TypeScript \n\nprivate and protected are only enforced during type checking.private  protected \n\nprivate also allows access using bracket notation during type checking. This makes private-declared fields potentially easier to access for things like unit tests, with the drawback that these fields are soft private and dont strictly enforce privacy. Private \n\nUnlike TypeScriptss private, JavaScripts private fields (#) remain private after compilation and do not provide the previously mentioned escape hatches like bracket notation access, making them hard private.  TypeScripts JavaScript  (#) \n\nWhen compiling to ES2021 or less, TypeScript will use WeakMaps in place of #.  es2021  WeakMaps  # \n\nIf you need to protect values in your class from malicious actors, you should use mechanisms that offer hard runtime privacy, such as closures, WeakMaps, or private fields. Note that these added privacy checks during runtime could affect performance.  WeakMaps \n\n\n# Static Members \n\nClasses may have static members. These members arent associated with a particular instance of the class. They can be accessed through the class constructor object itself\n\nStatic members can also use the same public, protected, and private visibility modifiers  public protected  private \n\nStatic members are also inherited \n\n\n# Special Static Names \n\nIts generally not safe/possible to overwrite properties from the Function prototype. Because classes are themselves functions that can be invoked with new, certain static names cant be used. Function properties like name, length, and call arent valid to define as static members  / \n\n\n# Why No Static Classes? \n\nwe dont need a static class syntax in TypeScript because a regular object (or even top-level function) will do the job just as well.    () \n\n\n# static Blocks in Classes \n\nStatic blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. This means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our classs internals. \n\n\n# Generic Classes \n\nClasses can use generic constraints and defaults the same way as interfaces. \n\n\n# Type Parameters in Static Members \n\nThe static members of a generic class can never refer to the classs type parameters. \n\n\n# this at Runtime in Classes \n\nLong story short, by default, the value of this inside a function depends on how the function was called. In this example, because the function was called through the obj reference, its value of this was obj rather than the class instance.  obj  obj \n\n\n# Arrow Functions \n\nIf you have a function that will often be called in a way that loses its this context, it can make sense to use an arrow function property instead of a method definition: :\n\nclass MyClass {\n  name = "MyClass";\n  getName = () => {\n    return this.name;\n  };\n}\nconst c = new MyClass();\nconst g = c.getName;\n// Prints "MyClass" instead of crashing\nconsole.log(g());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nThis has some trade-offs: :\n\n * The this value is guaranteed to be correct at runtime, even for code not checked with TypeScript \n\n * This will use more memory, because each class instance will have its own copy of each function defined this way \n\n * You cant use super.getName in a derived class, because theres no entry in the prototype chain to fetch the base class method from  super.getName\n\n\n# this parameters \n\nIn a method or function definition, an initial parameter named this has special meaning in TypeScript. These parameters are erased during compilation  this \n\nTypeScript checks that calling a function with a this parameter is done so with a correct context. Instead of using an arrow function, we can add a this parameter to method definitions to statically enforce that the method is called correctly.  this  this \n\nThis method makes the opposite trade-offs of the arrow function approach: :\n\n * JavaScript callers might still use the class method incorrectly without realizing it JavaScript \n\n * Only one function per class definition gets allocated, rather than one per class instance \n\n * Base method definitions can still be called via super.  super \n\n\n# this Types \n\nIn classes, a special type called this refers dynamically to the type of the current class.  this \n\n\n# this-based type guards \n\nYou can use this is Type in the return position for methods in classes and interfaces. When mixed with a type narrowing (e.g. if statements) the type of the target object would be narrowed to the specified Type.  Type ( if )  Type\n\nA common use-case for a this-based type guard is to allow for lazy validation of a particular field. \n\nclass Box<T> {\n  value?: T;\n \n  hasValue(): this is { value: T } {\n    return this.value !== undefined;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Parameter Properties \n\nTypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value. These are called parameter properties and are created by prefixing a constructor argument with one of the visibility modifiers public, private, protected, or readonly. The resulting field gets those modifier(s):  public private protected  readonly :\n\nclass Params {\n  constructor(\n    public readonly x: number,\n    protected y: number,\n    private z: number\n  ) {\n    // No body necessary\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Class Expressions \n\nClass expressions are very similar to class declarations. The only real difference is that class expressions dont need a name, though we can refer to them via whatever identifier they ended up bound to: .\n\nconst someClass = class<Type> {\n  content: Type;\n  constructor(value: Type) {\n    this.content = value;\n  }\n};\n \nconst m = new someClass("Hello, world");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# abstract Classes and Members \n\nClasses, methods, and fields in TypeScript may be abstract. \n\nAn abstract method or abstract field is one that hasnt had an implementation provided. These members must exist inside an abstract class, which cannot be directly instantiated. \n\nThe role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members. When a class doesnt have any abstract members, it is said to be concrete. \n\n\n# Abstract Construct Signatures \n\nfunction greet(ctor: new () => Base) {\n  const instance = new ctor();\n  instance.printName();\n}\n\n\n1\n2\n3\n4\n\n\n\n# Relationships Between Classes \n\nIn most cases, classes in TypeScript are compared structurally, the same as other types. TypeScript \n\nclass Point1 {\n  x = 0;\n  y = 0;\n}\n \nclass Point2 {\n  x = 0;\n  y = 0;\n}\n \n// OK\nconst p: Point1 = new Point2();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nSimilarly, subtype relationships between classes exist even if theres no explicit inheritance: :\n\nclass Person {\n  name: string;\n  age: number;\n}\n \nclass Employee {\n  name: string;\n  age: number;\n  salary: number;\n}\n \n// OK\nconst p: Person = new Employee();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nEmpty classes have no members. In a structural type system, a type with no members is generally a supertype of anything else. So if you write an empty class (dont!), anything can be used in place of it.  () .',normalizedContent:'# \n\n\n\n * \n * class members \n   * --strictpropertyinitialization\n * readonly\n * constructors \n * super calls \n * methods \n * getters / setters\n * index signatures \n * class heritage \n * member visibility \n * static members \n * special static names \n * why no static classes? \n * static blocks in classes \n * generic classes \n * type parameters in static members \n * this at runtime in classes\n * arrow functions \n * this parameters \n * this types \n * this-based type guards \n * parameter properties \n * class expressions \n * abstract classes and members \n * abstract construct signatures \n * relationships between classes \n\n\n\n\n# class members \n\n\n# --strictpropertyinitialization\n\nthe strictpropertyinitialization setting controls whether class fields need to be initialized in the constructor. strictpropertyinitialization \n\nif you intend to definitely initialize a field through means other than the constructor (for example, maybe an external library is filling in part of your class for you), you can use the definite assignment assertion operator, !:  () \n\n\n# readonly\n\nfields may be prefixed with the readonly modifier. this prevents assignments to the field outside of the constructor.  readonly \n\n\n# constructors \n\nclass constructors are very similar to functions. you can add parameters with type annotations, default values, and overloads. \n\nthere are just a few differences between class constructor signatures and function signatures: :\n\n * constructors cant have type parameters - these belong on the outer class declaration.   \n * onstructors cant have return type annotations - the class instance type is always whats returned   \n\n\n# super calls \n\n\n# methods \n\n\n# getters / setters\n\ntypescript has some special inference rules for accessors: :\n\n * if get exists but no set, the property is automatically readonly.  get \n * if the type of the setter parameter is not specified, it is inferred from the return type of the getter.  setter  getter \n * getters and setters must have the same member visibility. getters  setter  visibility\n\n\n# index signatures \n\nclass myclass {\n  [s: string]: boolean | ((s: string) => boolean);\n \n  check(s: string) {\n    return this[s] as boolean;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# class heritage \n\n * implements classes may also implement multiple interfaces, e.g. class c implements a, b {}.\n * extendsa derived class has all the properties and methods of its base class, and also define additional members. \n * overriding methods a derived class can also override a base class field or property. you can use the super. syntax to access base class methods. \n * initialization order \n * inheriting built-in types \n\nin es2015, constructors which return an object implicitly substitute the value of this for any callers of super(...). it is necessary for generated constructor code to capture any potential return value of super(...) and replace it with this.  es2015  super (...)  super (...) \n\nas a result, subclassing error, array, and others may no longer work as expected. this is due to the fact that constructor functions for error, array, and the like use ecmascript 6s new.target to adjust the prototype chain; however, there is no way to ensure a value for new.target when invoking a constructor in ecmascript 5. other downlevel compilers generally have the same limitation by default.  error array  errorarray  ecmascript 6  new.target  ecmascript 5  new.target \n\nas a recommendation, you can manually adjust the prototype immediately after any super(...) calls.  super (...) \n\nclass msgerror extends error {\n  constructor(m: string) {\n    super(m);\n \n    // set the prototype explicitly.\n    object.setprototypeof(this, msgerror.prototype);\n  }\n \n  sayhello() {\n    return "hello " + this.message;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nhowever, any subclass of msgerror will have to manually set the prototype as well. for runtimes that dont support object.setprototypeof, you may instead be able to use proto. msgerror  object.setprototypeof  _ proto _\n\nunfortunately, these workarounds will not work on internet explorer 10 and prior. one can manually copy methods from the prototype onto the instance itself (i.e. msgerror.prototype onto this), but the prototype chain itself cannot be fixed.  internet explorer 10  (msgerror.prototype ) \n\n\n# member visibility \n\n * public: a public member can be accessed anywhere. public \n * protected protected members are only visible to subclasses of the class theyre declared in. \n * exposure of  protected members derived classes need to follow their base class contracts, but may choose to expose a subtype of base class with more capabilities. this includes making protected members public\n * privateprivate is like protected, but doesnt allow access to the member even from subclasses.private  protected\n * cross-instance  private access \n\ndifferent oop languages disagree about whether different instances of the same class may access each others private members. while languages like java, c#, c++, swift, and php allow this, ruby does not.  oop  java c #  c + +  swift  php  ruby typescript does allow cross-instance private access.typescript \n\nprivate and protected are only enforced during type checking.private  protected \n\nprivate also allows access using bracket notation during type checking. this makes private-declared fields potentially easier to access for things like unit tests, with the drawback that these fields are soft private and dont strictly enforce privacy. private \n\nunlike typescriptss private, javascripts private fields (#) remain private after compilation and do not provide the previously mentioned escape hatches like bracket notation access, making them hard private.  typescripts javascript  (#) \n\nwhen compiling to es2021 or less, typescript will use weakmaps in place of #.  es2021  weakmaps  # \n\nif you need to protect values in your class from malicious actors, you should use mechanisms that offer hard runtime privacy, such as closures, weakmaps, or private fields. note that these added privacy checks during runtime could affect performance.  weakmaps \n\n\n# static members \n\nclasses may have static members. these members arent associated with a particular instance of the class. they can be accessed through the class constructor object itself\n\nstatic members can also use the same public, protected, and private visibility modifiers  public protected  private \n\nstatic members are also inherited \n\n\n# special static names \n\nits generally not safe/possible to overwrite properties from the function prototype. because classes are themselves functions that can be invoked with new, certain static names cant be used. function properties like name, length, and call arent valid to define as static members  / \n\n\n# why no static classes? \n\nwe dont need a static class syntax in typescript because a regular object (or even top-level function) will do the job just as well.    () \n\n\n# static blocks in classes \n\nstatic blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. this means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our classs internals. \n\n\n# generic classes \n\nclasses can use generic constraints and defaults the same way as interfaces. \n\n\n# type parameters in static members \n\nthe static members of a generic class can never refer to the classs type parameters. \n\n\n# this at runtime in classes \n\nlong story short, by default, the value of this inside a function depends on how the function was called. in this example, because the function was called through the obj reference, its value of this was obj rather than the class instance.  obj  obj \n\n\n# arrow functions \n\nif you have a function that will often be called in a way that loses its this context, it can make sense to use an arrow function property instead of a method definition: :\n\nclass myclass {\n  name = "myclass";\n  getname = () => {\n    return this.name;\n  };\n}\nconst c = new myclass();\nconst g = c.getname;\n// prints "myclass" instead of crashing\nconsole.log(g());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nthis has some trade-offs: :\n\n * the this value is guaranteed to be correct at runtime, even for code not checked with typescript \n\n * this will use more memory, because each class instance will have its own copy of each function defined this way \n\n * you cant use super.getname in a derived class, because theres no entry in the prototype chain to fetch the base class method from  super.getname\n\n\n# this parameters \n\nin a method or function definition, an initial parameter named this has special meaning in typescript. these parameters are erased during compilation  this \n\ntypescript checks that calling a function with a this parameter is done so with a correct context. instead of using an arrow function, we can add a this parameter to method definitions to statically enforce that the method is called correctly.  this  this \n\nthis method makes the opposite trade-offs of the arrow function approach: :\n\n * javascript callers might still use the class method incorrectly without realizing it javascript \n\n * only one function per class definition gets allocated, rather than one per class instance \n\n * base method definitions can still be called via super.  super \n\n\n# this types \n\nin classes, a special type called this refers dynamically to the type of the current class.  this \n\n\n# this-based type guards \n\nyou can use this is type in the return position for methods in classes and interfaces. when mixed with a type narrowing (e.g. if statements) the type of the target object would be narrowed to the specified type.  type ( if )  type\n\na common use-case for a this-based type guard is to allow for lazy validation of a particular field. \n\nclass box<t> {\n  value?: t;\n \n  hasvalue(): this is { value: t } {\n    return this.value !== undefined;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# parameter properties \n\ntypescript offers special syntax for turning a constructor parameter into a class property with the same name and value. these are called parameter properties and are created by prefixing a constructor argument with one of the visibility modifiers public, private, protected, or readonly. the resulting field gets those modifier(s):  public private protected  readonly :\n\nclass params {\n  constructor(\n    public readonly x: number,\n    protected y: number,\n    private z: number\n  ) {\n    // no body necessary\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# class expressions \n\nclass expressions are very similar to class declarations. the only real difference is that class expressions dont need a name, though we can refer to them via whatever identifier they ended up bound to: .\n\nconst someclass = class<type> {\n  content: type;\n  constructor(value: type) {\n    this.content = value;\n  }\n};\n \nconst m = new someclass("hello, world");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# abstract classes and members \n\nclasses, methods, and fields in typescript may be abstract. \n\nan abstract method or abstract field is one that hasnt had an implementation provided. these members must exist inside an abstract class, which cannot be directly instantiated. \n\nthe role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members. when a class doesnt have any abstract members, it is said to be concrete. \n\n\n# abstract construct signatures \n\nfunction greet(ctor: new () => base) {\n  const instance = new ctor();\n  instance.printname();\n}\n\n\n1\n2\n3\n4\n\n\n\n# relationships between classes \n\nin most cases, classes in typescript are compared structurally, the same as other types. typescript \n\nclass point1 {\n  x = 0;\n  y = 0;\n}\n \nclass point2 {\n  x = 0;\n  y = 0;\n}\n \n// ok\nconst p: point1 = new point2();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nsimilarly, subtype relationships between classes exist even if theres no explicit inheritance: :\n\nclass person {\n  name: string;\n  age: number;\n}\n \nclass employee {\n  name: string;\n  age: number;\n  salary: number;\n}\n \n// ok\nconst p: person = new employee();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nempty classes have no members. in a structural type system, a type with no members is generally a supertype of anything else. so if you write an empty class (dont!), anything can be used in place of it.  () .',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"reference ",frontmatter:{title:"reference ",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/basic/reference/",categories:["typescript-utility","basic"],tags:[null]},regularPath:"/30.web/4.typescript-utility/10.%E5%9F%BA%E7%A1%80/40.reference.html",relativePath:"30.web/4.typescript-utility/10./40.reference.md",key:"v-2080504b",path:"/ts/basic/reference/",headers:[{level:2,title:"Utility Types ",slug:"utility-types-",normalizedTitle:"utility types ",charIndex:2}],readingTime:{text:"3 min read",minutes:2.41,time:144600.00000000003,words:482},headersStr:"Utility Types ",content:"# Utility Types \n\n * Partial<Type>\n\nConstructs a type with all properties of Type set to optional. This utility will return a type that represents all subsets of a given type.  Type \n\n * Required<Type>\n\nConstructs a type consisting of all properties of Type set to required. The opposite of Partial.  Type  required  Partial \n\n * Readonly<Type>\n\nConstructs a type with all properties of Type set to readonly, meaning the properties of the constructed type cannot be reassigned.  Type \n\n * Record<Keys, Type>\n\nConstructs an object type whose property keys are Keys and whose property values are Type. This utility can be used to map the properties of a type to another type.  Keys Type \n\n * Pick<Type, Keys>\n\nConstructs a type by picking the set of properties Keys (string literal or union of string literals) from Type.  Type  Keys () \n\n * Omit<Type, Keys>\n\nConstructs a type by picking all properties from Type and then removing Keys (string literal or union of string literals).  Type  Keys () \n\n * Exclude<Type, ExcludedUnion>\n\nConstructs a type by excluding from Type all union members that are assignable to ExcludedUnion.  ExcludedUnion \n\n * Extract<Type, Union>\n\nConstructs a type by extracting from Type all union members that are assignable to Union.  Type  Union \n\n * NonNullable<Type>\n\nConstructs a type by excluding null and undefined from Type.  Type  null  undefined \n\n * Parameters<Type>\n\nConstructs a tuple type from the types used in the parameters of a function type Type. \n\n * ConstructorParameters<Type>\n\nConstructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the type never if Type is not a function).  ( Type  never )\n\n * ReturnType<Type>\n\nConstructs a type consisting of the return type of function Type.  Type \n\n * InstanceType<Type>\n\nConstructs a type consisting of the instance type of a constructor function in Type.  Type \n\n * ThisParameterType<Type>\n\nExtracts the type of the this parameter for a function type, or unknown if the function type has no this parameter. \n\n * OmitThisParameter<Type>\n\nRemoves the this parameter from Type. If Type has no explicitly declared this parameter, the result is simply Type. Otherwise, a new function type with no this parameter is created from Type. Generics are erased and only the last overload signature is propagated into the new function type.  Type  Type  Type Type \n\nfunction toHex(this: Number) {\n  return this.toString(16);\n}\n \nconst fiveToHex: OmitThisParameter<typeof toHex> = toHex.bind(5);\n \nconsole.log(fiveToHex());\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * ThisType<Type>\n\nThis utility does not return a transformed type. Instead, it serves as a marker for a contextual this type. Note that the noImplicitThis flag must be enabled to use this utility.  noImplicitThis \n\n * Intrinsic String Manipulation Types\n\n 1. Uppercase<StringType>\n 2. Lowercase<StringType>\n 3. Capitalize<StringType>\n 4. Uncapitalize<StringType>",normalizedContent:"# utility types \n\n * partial<type>\n\nconstructs a type with all properties of type set to optional. this utility will return a type that represents all subsets of a given type.  type \n\n * required<type>\n\nconstructs a type consisting of all properties of type set to required. the opposite of partial.  type  required  partial \n\n * readonly<type>\n\nconstructs a type with all properties of type set to readonly, meaning the properties of the constructed type cannot be reassigned.  type \n\n * record<keys, type>\n\nconstructs an object type whose property keys are keys and whose property values are type. this utility can be used to map the properties of a type to another type.  keys type \n\n * pick<type, keys>\n\nconstructs a type by picking the set of properties keys (string literal or union of string literals) from type.  type  keys () \n\n * omit<type, keys>\n\nconstructs a type by picking all properties from type and then removing keys (string literal or union of string literals).  type  keys () \n\n * exclude<type, excludedunion>\n\nconstructs a type by excluding from type all union members that are assignable to excludedunion.  excludedunion \n\n * extract<type, union>\n\nconstructs a type by extracting from type all union members that are assignable to union.  type  union \n\n * nonnullable<type>\n\nconstructs a type by excluding null and undefined from type.  type  null  undefined \n\n * parameters<type>\n\nconstructs a tuple type from the types used in the parameters of a function type type. \n\n * constructorparameters<type>\n\nconstructs a tuple or array type from the types of a constructor function type. it produces a tuple type with all the parameter types (or the type never if type is not a function).  ( type  never )\n\n * returntype<type>\n\nconstructs a type consisting of the return type of function type.  type \n\n * instancetype<type>\n\nconstructs a type consisting of the instance type of a constructor function in type.  type \n\n * thisparametertype<type>\n\nextracts the type of the this parameter for a function type, or unknown if the function type has no this parameter. \n\n * omitthisparameter<type>\n\nremoves the this parameter from type. if type has no explicitly declared this parameter, the result is simply type. otherwise, a new function type with no this parameter is created from type. generics are erased and only the last overload signature is propagated into the new function type.  type  type  type type \n\nfunction tohex(this: number) {\n  return this.tostring(16);\n}\n \nconst fivetohex: omitthisparameter<typeof tohex> = tohex.bind(5);\n \nconsole.log(fivetohex());\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * thistype<type>\n\nthis utility does not return a transformed type. instead, it serves as a marker for a contextual this type. note that the noimplicitthis flag must be enabled to use this utility.  noimplicitthis \n\n * intrinsic string manipulation types\n\n 1. uppercase<stringtype>\n 2. lowercase<stringtype>\n 3. capitalize<stringtype>\n 4. uncapitalize<stringtype>",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"type-zoo",frontmatter:{title:"type-zoo",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/basic/type-zoo/",categories:["typescript-utility","basic"],tags:[null]},regularPath:"/30.web/4.typescript-utility/10.%E5%9F%BA%E7%A1%80/50.type-zoo.html",relativePath:"30.web/4.typescript-utility/10./50.type-zoo.md",key:"v-057781cb",path:"/ts/basic/type-zoo/",readingTime:{text:"5 min read",minutes:4.19,time:251400.00000000003,words:838},headersStr:null,content:"/**\n * Extract from `T` those types that are assignable to `U`, where `U` must exist in `T`.\n *\n * Similar to `Extract` but requires the extraction list to be composed of valid members of `T`.\n *\n * @see https://github.com/pelotom/type-zoo/issues/37\n */\nexport type ExtractStrict<T, U extends T> = T extends U ? T : never;\n\n/**\n * Exclude from `T` those types that are assignable to `U`, where `U` must exist in `T`.\n *\n * Similar to `Exclude` but requires the exclusion list to be composed of valid members of `T`.\n *\n * @see https://github.com/pelotom/type-zoo/issues/37\n */\nexport type ExcludeStrict<T, U extends T> = T extends U ? never : T;\n\n/**\n * Drop keys `K` from `T` if they are present.\n *\n * @see https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-377567046\n */\nexport type Omit<T, K extends keyof any> = T extends any ? Pick<T, Exclude<keyof T, K>> : never;\n\n/**\n * Drop keys `K` from `T`, where `K` must exist in `T`.\n *\n * @see https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-377567046\n */\nexport type OmitStrict<T, K extends keyof T> = T extends any ? Pick<T, Exclude<keyof T, K>> : never;\n\n/**\n * Like `T & U`, but where there are overlapping properties using the\n * type from U only.\n *\n * @see Old: https://github.com/pelotom/type-zoo/issues/2\n * @see Old: https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458\n * @see New: https://github.com/pelotom/type-zoo/pull/14#discussion_r183527882\n */\nexport type Overwrite<T, U> = Omit<T, keyof T & keyof U> & U;\n\n/**\n * Use to prevent a usage of type `T` from being inferred in other generics.\n *\n * Example:\n * declare function assertEqual<T>(actual: T, expected: NoInfer<T>): boolean;\n *\n * Type `T` will now only be inferred based on the type of the `actual` param, and\n * the `expected` param is required to be assignable to the type of `actual`.\n * This allows you to give one particular usage of type `T` full control over how the\n * compiler infers type `T`.\n *\n * @see https://github.com/Microsoft/TypeScript/issues/14829#issuecomment-322267089\n */\nexport type NoInfer<T> = T & { [K in keyof T]: T[K] };\n\n/**\n * Forgets contextual knowledge of partiality of keys.\n */\nexport type Purify<T extends string> = { [P in T]: T }[T];\n\n/**\n * Get the public interface of a type. This is useful for working with classes that have private members.\n *\n * export class Foo {\n *   private priv: string;\n *\n *   bar(): number {\n *     // ...\n *   }\n * }\n *\n * export type IFoo = Public<Foo>;\n *\n * // Can mock or fake\n * const fakeFoo: IFoo = {\n *   bar(): { return 1;}\n * }\n */\nexport type Public<T> = { [P in keyof T]: T[P] };\n\n/**\n * Selects the type of the 0th parameter in a function-type\n */\nexport type Param0<Func> = Func extends (a: infer T, ...args: any[]) => any ? T : never;\n/**\n * Selects the type of the 1st parameter in a function-type\n */\nexport type Param1<Func> = Func extends (a: any, b: infer T, ...args: any[]) => any ? T : never;\n/**\n * Selects the type of the 2nd parameter in a function-type\n */\nexport type Param2<Func> = Func extends (a: any, b: any, c: infer T, ...args: any[]) => any\n  ? T\n  : never;\n/**\n * Selects the type of the 3rd parameter in a function-type\n */\nexport type Param3<Func> = Func extends (a: any, b: any, c: any, d: infer T, ...args: any[]) => any\n  ? T\n  : never;\n/**\n * Selects the types of all the parameters in a function-type.\n * Warnings:\n *  - This is probably less performant if you're only looking up a single param! {@see Param0-Param# }\n *  - This omits rest parameters (...args:any[])\n */\nexport type ParamTypes<F extends Function> = F extends () => any // tslint:disable-line\n  ? {}\n  : F extends (p0: infer P0) => any\n    ? [P0]\n    : F extends (p0: infer P0, p1: infer P1) => any\n      ? [P0, P1]\n      : F extends (p0: infer P0, p1: infer P1, p2: infer P2) => any\n        ? [P0, P1, P2]\n        : F extends (p0: infer P0, p1: infer P1, p2: infer P2, p3: infer P3) => any\n          ? [P0, P1, P2, P3] // ... -- extend this at your own risk, this could be bad for compilation performance!\n          : never;\n\n/**\n * Picks 2 levels deep into a nested object!\n *\n * @see https://gist.github.com/staltz/368866ea6b8a167fbdac58cddf79c1bf\n */\nexport type Pick2<T, K1 extends keyof T, K2 extends keyof T[K1]> = {\n  [P1 in K1]: { [P2 in K2]: (T[K1])[P2] }\n};\n\n/**\n * Picks 3 levels deep into a nested object!\n *\n * @see https://gist.github.com/staltz/368866ea6b8a167fbdac58cddf79c1bf\n */\nexport type Pick3<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]> = {\n  [P1 in K1]: { [P2 in K2]: { [P3 in K3]: ((T[K1])[K2])[P3] } }\n};\n\n/**\n * Picks 4 levels deep into a nested object!\n */\nexport type Pick4<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3]\n> = { [P1 in K1]: { [P2 in K2]: { [P3 in K3]: { [P4 in K4]: (((T[K1])[K2])[K3])[P4] } } } };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n",normalizedContent:"/**\n * extract from `t` those types that are assignable to `u`, where `u` must exist in `t`.\n *\n * similar to `extract` but requires the extraction list to be composed of valid members of `t`.\n *\n * @see https://github.com/pelotom/type-zoo/issues/37\n */\nexport type extractstrict<t, u extends t> = t extends u ? t : never;\n\n/**\n * exclude from `t` those types that are assignable to `u`, where `u` must exist in `t`.\n *\n * similar to `exclude` but requires the exclusion list to be composed of valid members of `t`.\n *\n * @see https://github.com/pelotom/type-zoo/issues/37\n */\nexport type excludestrict<t, u extends t> = t extends u ? never : t;\n\n/**\n * drop keys `k` from `t` if they are present.\n *\n * @see https://github.com/microsoft/typescript/issues/12215#issuecomment-377567046\n */\nexport type omit<t, k extends keyof any> = t extends any ? pick<t, exclude<keyof t, k>> : never;\n\n/**\n * drop keys `k` from `t`, where `k` must exist in `t`.\n *\n * @see https://github.com/microsoft/typescript/issues/12215#issuecomment-377567046\n */\nexport type omitstrict<t, k extends keyof t> = t extends any ? pick<t, exclude<keyof t, k>> : never;\n\n/**\n * like `t & u`, but where there are overlapping properties using the\n * type from u only.\n *\n * @see old: https://github.com/pelotom/type-zoo/issues/2\n * @see old: https://github.com/microsoft/typescript/issues/12215#issuecomment-307871458\n * @see new: https://github.com/pelotom/type-zoo/pull/14#discussion_r183527882\n */\nexport type overwrite<t, u> = omit<t, keyof t & keyof u> & u;\n\n/**\n * use to prevent a usage of type `t` from being inferred in other generics.\n *\n * example:\n * declare function assertequal<t>(actual: t, expected: noinfer<t>): boolean;\n *\n * type `t` will now only be inferred based on the type of the `actual` param, and\n * the `expected` param is required to be assignable to the type of `actual`.\n * this allows you to give one particular usage of type `t` full control over how the\n * compiler infers type `t`.\n *\n * @see https://github.com/microsoft/typescript/issues/14829#issuecomment-322267089\n */\nexport type noinfer<t> = t & { [k in keyof t]: t[k] };\n\n/**\n * forgets contextual knowledge of partiality of keys.\n */\nexport type purify<t extends string> = { [p in t]: t }[t];\n\n/**\n * get the public interface of a type. this is useful for working with classes that have private members.\n *\n * export class foo {\n *   private priv: string;\n *\n *   bar(): number {\n *     // ...\n *   }\n * }\n *\n * export type ifoo = public<foo>;\n *\n * // can mock or fake\n * const fakefoo: ifoo = {\n *   bar(): { return 1;}\n * }\n */\nexport type public<t> = { [p in keyof t]: t[p] };\n\n/**\n * selects the type of the 0th parameter in a function-type\n */\nexport type param0<func> = func extends (a: infer t, ...args: any[]) => any ? t : never;\n/**\n * selects the type of the 1st parameter in a function-type\n */\nexport type param1<func> = func extends (a: any, b: infer t, ...args: any[]) => any ? t : never;\n/**\n * selects the type of the 2nd parameter in a function-type\n */\nexport type param2<func> = func extends (a: any, b: any, c: infer t, ...args: any[]) => any\n  ? t\n  : never;\n/**\n * selects the type of the 3rd parameter in a function-type\n */\nexport type param3<func> = func extends (a: any, b: any, c: any, d: infer t, ...args: any[]) => any\n  ? t\n  : never;\n/**\n * selects the types of all the parameters in a function-type.\n * warnings:\n *  - this is probably less performant if you're only looking up a single param! {@see param0-param# }\n *  - this omits rest parameters (...args:any[])\n */\nexport type paramtypes<f extends function> = f extends () => any // tslint:disable-line\n  ? {}\n  : f extends (p0: infer p0) => any\n    ? [p0]\n    : f extends (p0: infer p0, p1: infer p1) => any\n      ? [p0, p1]\n      : f extends (p0: infer p0, p1: infer p1, p2: infer p2) => any\n        ? [p0, p1, p2]\n        : f extends (p0: infer p0, p1: infer p1, p2: infer p2, p3: infer p3) => any\n          ? [p0, p1, p2, p3] // ... -- extend this at your own risk, this could be bad for compilation performance!\n          : never;\n\n/**\n * picks 2 levels deep into a nested object!\n *\n * @see https://gist.github.com/staltz/368866ea6b8a167fbdac58cddf79c1bf\n */\nexport type pick2<t, k1 extends keyof t, k2 extends keyof t[k1]> = {\n  [p1 in k1]: { [p2 in k2]: (t[k1])[p2] }\n};\n\n/**\n * picks 3 levels deep into a nested object!\n *\n * @see https://gist.github.com/staltz/368866ea6b8a167fbdac58cddf79c1bf\n */\nexport type pick3<t, k1 extends keyof t, k2 extends keyof t[k1], k3 extends keyof t[k1][k2]> = {\n  [p1 in k1]: { [p2 in k2]: { [p3 in k3]: ((t[k1])[k2])[p3] } }\n};\n\n/**\n * picks 4 levels deep into a nested object!\n */\nexport type pick4<\n  t,\n  k1 extends keyof t,\n  k2 extends keyof t[k1],\n  k3 extends keyof t[k1][k2],\n  k4 extends keyof t[k1][k2][k3]\n> = { [p1 in k1]: { [p2 in k2]: { [p3 in k3]: { [p4 in k4]: (((t[k1])[k2])[k3])[p4] } } } };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/utility/index/",categories:["typescript-utility","utility-types"],tags:[null]},regularPath:"/30.web/4.typescript-utility/20.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7/0.index.html",relativePath:"30.web/4.typescript-utility/20./0.index.md",key:"v-2af34dca",path:"/ts/utility/index/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2}],readingTime:{text:"1 min read",minutes:.025,time:1500,words:5},headersStr:"",content:"# \n\n\n\n * \n\n",normalizedContent:"# \n\n\n\n * \n\n",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"Basic Utility Types",frontmatter:{title:"Basic Utility Types",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/utility/basic/",categories:["typescript-utility","utility-types"],tags:[null]},regularPath:"/30.web/4.typescript-utility/20.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7/10.basic.html",relativePath:"30.web/4.typescript-utility/20./10.basic.md",key:"v-f790ca6e",path:"/ts/utility/basic/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"$Keys",slug:"keys",normalizedTitle:"$keys",charIndex:17},{level:2,title:"$Values",slug:"values",normalizedTitle:"$values",charIndex:26},{level:2,title:"$ReadOnly",slug:"readonly",normalizedTitle:"$readonly",charIndex:37},{level:2,title:"$Diff",slug:"diff",normalizedTitle:"$diff",charIndex:50},{level:2,title:"$PropertyType",slug:"propertytype",normalizedTitle:"$propertytype",charIndex:59},{level:2,title:"$ElementType",slug:"elementtype",normalizedTitle:"$elementtype",charIndex:76},{level:2,title:"$Call",slug:"call",normalizedTitle:"$call",charIndex:92},{level:2,title:"$Shape",slug:"shape",normalizedTitle:"$shape",charIndex:101},{level:2,title:"$NonMaybeType",slug:"nonmaybetype",normalizedTitle:"$nonmaybetype",charIndex:111},{level:2,title:"Class",slug:"class",normalizedTitle:"class",charIndex:128}],readingTime:{text:"5 min read",minutes:4.32,time:259200.00000000006,words:864},headersStr:" $Keys $Values $ReadOnly $Diff $PropertyType $ElementType $Call $Shape $NonMaybeType Class",content:"# \n\n\n\n * \n * $Keys\n * $Values\n * $ReadOnly\n * $Diff\n * $PropertyType\n * $ElementType\n * $Call\n * $Shape\n * $NonMaybeType\n * Class\n\n\n\n Flow \n\n\n# $Keys\n\n object  keys\n\n/**\n * $Keys\n * @desc Get the union type of all the keys in an object type `T`\n * @see https://flow.org/en/docs/types/utilities/#toc-keys\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *\n *   // Expect: \"name\" | \"age\" | \"visible\"\n *   type PropsKeys = $Keys<Props>;\n */\nexport type $Keys<T extends object> = keyof T;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# $Values\n\n object  values types\n\n/**\n * $Values\n * @desc Get the union type of all the values in an object type `T`\n * @see https://flow.org/en/docs/types/utilities/#toc-values\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *\n *   // Expect: string | number | boolean\n *   type PropsValues = $Values<Props>;\n */\nexport type $Values<T extends object> = T[keyof T];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# $ReadOnly\n\n deep readonly object type\n\n/**\n * $ReadOnly\n * @desc Get the read-only version of a given object type `T` (it works on nested data structure)\n * @see https://flow.org/en/docs/types/utilities/#toc-readonly\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *\n *   // Expect: Readonly<{ name: string; age: number; visible: boolean; }>\n *   type ReadOnlyProps = $ReadOnly<Props>;\n */\nexport type $ReadOnly<T extends object> = DeepReadonly<T>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * DeepReadonlyobject deep readonly type.\n\n\n# $Diff\n\n object \n\n/**\n * $Diff\n * @desc Get the set difference of a given object types `T` and `U` (`T \\ U`)\n * @see https://flow.org/en/docs/types/utilities/#toc-diff\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *   type DefaultProps = { age: number };\n *\n *   // Expect: { name: string; visible: boolean; }\n *   type RequiredProps = Diff<Props, DefaultProps>;\n */\nexport type $Diff<T extends U, U extends object> = Pick<\n  T,\n  SetComplement<keyof T, keyof U>\n>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * SetComplement\n\n\n# $PropertyType\n\n object  key  type\n\n/**\n * $PropertyType\n * @desc Get the type of property of an object at a given key `K`\n * @see https://flow.org/en/docs/types/utilities/#toc-propertytype\n * @example\n *   // Expect: string;\n *   type Props = { name: string; age: number; visible: boolean };\n *   type NameType = $PropertyType<Props, 'name'>;\n *\n *   // Expect: boolean\n *   type Tuple = [boolean, number];\n *   type A = $PropertyType<Tuple, '0'>;\n *   // Expect: number\n *   type B = $PropertyType<Tuple, '1'>;\n */\nexport type $PropertyType<T extends object, K extends keyof T> = T[K];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# $ElementType\n\n index  objectarraytuple \n\n/**\n * $ElementType\n * @desc Get the type of elements inside of array, tuple or object of type `T`, that matches the given index type `K`\n * @see https://flow.org/en/docs/types/utilities/#toc-elementtype\n * @example\n *   // Expect: string;\n *   type Props = { name: string; age: number; visible: boolean };\n *   type NameType = $ElementType<Props, 'name'>;\n *\n *   // Expect: boolean\n *   type Tuple = [boolean, number];\n *   type A = $ElementType<Tuple, '0'>;\n *   // Expect: number\n *   type B = $ElementType<Tuple, '1'>;\n *\n *   // Expect: boolean\n *   type Arr = boolean[];\n *   type ItemsType = $ElementType<Arr, number>;\n *\n *   // Expect: number\n *   type Obj = { [key: string]: number };\n *   type ValuesType = $ElementType<Obj, string>;\n */\nexport type $ElementType<\n  T extends { [P in K & any]: any },\n  K extends keyof T | number\n> = T[K];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# $Call\n\n\n\n/**\n * $Call\n * @desc Get the return type from a given typeof expression\n * @see https://flow.org/en/docs/types/utilities/#toc-call\n * @example\n *   // Common use-case\n *   const add = (amount: number) => ({ type: 'ADD' as 'ADD', payload: amount });\n *   type AddAction = $Call<typeof returnOfIncrement>; // { type: 'ADD'; payload: number }\n *\n *   // Examples migrated from Flow docs\n *   type ExtractPropType<T extends { prop: any }> = (arg: T) => T['prop'];\n *   type Obj = { prop: number };\n *   type PropType = $Call<ExtractPropType<Obj>>; // number\n *\n *   type ExtractReturnType<T extends () => any> = (arg: T) => ReturnType<T>;\n *   type Fn = () => number;\n *   type FnReturnType = $Call<ExtractReturnType<Fn>>; // number\n */\nexport type $Call<Fn extends (...args: any[]) => any> = Fn extends (\n  arg: any\n) => infer RT\n  ? RT\n  : never;\n\ntype ReturnType<T> = T extends (...args: any[]) => infer P ? P : any;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * infer:  extends \n\n\n# $Shape\n\n object  property \n\n/**\n * $Shape\n * @desc Copies the shape of the type supplied, but marks every field optional.\n * @see https://flow.org/en/docs/types/utilities/#toc-shape\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *\n *   // Expect: Partial<Props>\n *   type PartialProps = $Shape<Props>;\n */\nexport type $Shape<T extends object> = Partial<T>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# $NonMaybeType\n\n null undefined \n\n/**\n * $NonMaybeType\n * @desc Excludes null and undefined from T\n * @see https://flow.org/en/docs/types/utilities/#toc-nonmaybe\n * @example\n *   type MaybeName = string | null;\n *\n *   // Expect: string\n *   type Name = $NonMaybeType<MaybeName>;\n */\nexport type $NonMaybeType<T> = NonNullable<T>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Class\n\n class \n\n/**\n * Class\n * @desc Represents constructor of type T\n * @see https://flow.org/en/docs/types/utilities/#toc-class\n * @example\n *   class Store {}\n *   function makeStore(storeClass: Class<Store>): Store {\n *     return new storeClass();\n *   }\n */\nexport type Class<T> = new (...args: any[]) => T;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",normalizedContent:"# \n\n\n\n * \n * $keys\n * $values\n * $readonly\n * $diff\n * $propertytype\n * $elementtype\n * $call\n * $shape\n * $nonmaybetype\n * class\n\n\n\n flow \n\n\n# $keys\n\n object  keys\n\n/**\n * $keys\n * @desc get the union type of all the keys in an object type `t`\n * @see https://flow.org/en/docs/types/utilities/#toc-keys\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *\n *   // expect: \"name\" | \"age\" | \"visible\"\n *   type propskeys = $keys<props>;\n */\nexport type $keys<t extends object> = keyof t;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# $values\n\n object  values types\n\n/**\n * $values\n * @desc get the union type of all the values in an object type `t`\n * @see https://flow.org/en/docs/types/utilities/#toc-values\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *\n *   // expect: string | number | boolean\n *   type propsvalues = $values<props>;\n */\nexport type $values<t extends object> = t[keyof t];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# $readonly\n\n deep readonly object type\n\n/**\n * $readonly\n * @desc get the read-only version of a given object type `t` (it works on nested data structure)\n * @see https://flow.org/en/docs/types/utilities/#toc-readonly\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *\n *   // expect: readonly<{ name: string; age: number; visible: boolean; }>\n *   type readonlyprops = $readonly<props>;\n */\nexport type $readonly<t extends object> = deepreadonly<t>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * deepreadonlyobject deep readonly type.\n\n\n# $diff\n\n object \n\n/**\n * $diff\n * @desc get the set difference of a given object types `t` and `u` (`t \\ u`)\n * @see https://flow.org/en/docs/types/utilities/#toc-diff\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *   type defaultprops = { age: number };\n *\n *   // expect: { name: string; visible: boolean; }\n *   type requiredprops = diff<props, defaultprops>;\n */\nexport type $diff<t extends u, u extends object> = pick<\n  t,\n  setcomplement<keyof t, keyof u>\n>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * setcomplement\n\n\n# $propertytype\n\n object  key  type\n\n/**\n * $propertytype\n * @desc get the type of property of an object at a given key `k`\n * @see https://flow.org/en/docs/types/utilities/#toc-propertytype\n * @example\n *   // expect: string;\n *   type props = { name: string; age: number; visible: boolean };\n *   type nametype = $propertytype<props, 'name'>;\n *\n *   // expect: boolean\n *   type tuple = [boolean, number];\n *   type a = $propertytype<tuple, '0'>;\n *   // expect: number\n *   type b = $propertytype<tuple, '1'>;\n */\nexport type $propertytype<t extends object, k extends keyof t> = t[k];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# $elementtype\n\n index  objectarraytuple \n\n/**\n * $elementtype\n * @desc get the type of elements inside of array, tuple or object of type `t`, that matches the given index type `k`\n * @see https://flow.org/en/docs/types/utilities/#toc-elementtype\n * @example\n *   // expect: string;\n *   type props = { name: string; age: number; visible: boolean };\n *   type nametype = $elementtype<props, 'name'>;\n *\n *   // expect: boolean\n *   type tuple = [boolean, number];\n *   type a = $elementtype<tuple, '0'>;\n *   // expect: number\n *   type b = $elementtype<tuple, '1'>;\n *\n *   // expect: boolean\n *   type arr = boolean[];\n *   type itemstype = $elementtype<arr, number>;\n *\n *   // expect: number\n *   type obj = { [key: string]: number };\n *   type valuestype = $elementtype<obj, string>;\n */\nexport type $elementtype<\n  t extends { [p in k & any]: any },\n  k extends keyof t | number\n> = t[k];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# $call\n\n\n\n/**\n * $call\n * @desc get the return type from a given typeof expression\n * @see https://flow.org/en/docs/types/utilities/#toc-call\n * @example\n *   // common use-case\n *   const add = (amount: number) => ({ type: 'add' as 'add', payload: amount });\n *   type addaction = $call<typeof returnofincrement>; // { type: 'add'; payload: number }\n *\n *   // examples migrated from flow docs\n *   type extractproptype<t extends { prop: any }> = (arg: t) => t['prop'];\n *   type obj = { prop: number };\n *   type proptype = $call<extractproptype<obj>>; // number\n *\n *   type extractreturntype<t extends () => any> = (arg: t) => returntype<t>;\n *   type fn = () => number;\n *   type fnreturntype = $call<extractreturntype<fn>>; // number\n */\nexport type $call<fn extends (...args: any[]) => any> = fn extends (\n  arg: any\n) => infer rt\n  ? rt\n  : never;\n\ntype returntype<t> = t extends (...args: any[]) => infer p ? p : any;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * infer:  extends \n\n\n# $shape\n\n object  property \n\n/**\n * $shape\n * @desc copies the shape of the type supplied, but marks every field optional.\n * @see https://flow.org/en/docs/types/utilities/#toc-shape\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *\n *   // expect: partial<props>\n *   type partialprops = $shape<props>;\n */\nexport type $shape<t extends object> = partial<t>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# $nonmaybetype\n\n null undefined \n\n/**\n * $nonmaybetype\n * @desc excludes null and undefined from t\n * @see https://flow.org/en/docs/types/utilities/#toc-nonmaybe\n * @example\n *   type maybename = string | null;\n *\n *   // expect: string\n *   type name = $nonmaybetype<maybename>;\n */\nexport type $nonmaybetype<t> = nonnullable<t>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# class\n\n class \n\n/**\n * class\n * @desc represents constructor of type t\n * @see https://flow.org/en/docs/types/utilities/#toc-class\n * @example\n *   class store {}\n *   function makestore(storeclass: class<store>): store {\n *     return new storeclass();\n *   }\n */\nexport type class<t> = new (...args: any[]) => t;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"Mapped Types",frontmatter:{title:"Mapped Types",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/utility/mapped/",categories:["typescript-utility","utility-types"],tags:[null]},regularPath:"/30.web/4.typescript-utility/20.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7/20.mapped-types.html",relativePath:"30.web/4.typescript-utility/20./20.mapped-types.md",key:"v-1061317b",path:"/ts/utility/mapped/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2}],readingTime:{text:"15 min read",minutes:14.3,time:858e3,words:2860},headersStr:"",content:"# \n\n\n\n * \n\n\n\n/**\n * SetIntersection (same as Extract)\n * @desc Set intersection of given union types `A` and `B`\n * @example\n *   // Expect: \"2\" | \"3\"\n *   SetIntersection<'1' | '2' | '3', '2' | '3' | '4'>;\n *\n *   // Expect: () => void\n *   SetIntersection<string | number | (() => void), Function>;\n */\nexport type SetIntersection<A, B> = A extends B ? A : never;\n\n/**\n * SetDifference (same as Exclude)\n * @desc Set difference of given union types `A` and `B`\n * @example\n *   // Expect: \"1\"\n *   SetDifference<'1' | '2' | '3', '2' | '3' | '4'>;\n *\n *   // Expect: string | number\n *   SetDifference<string | number | (() => void), Function>;\n */\nexport type SetDifference<A, B> = A extends B ? never : A;\n\n/**\n * SetComplement\n * @desc Set complement of given union types `A` and (it's subset) `A1`\n * @example\n *   // Expect: \"1\"\n *   SetComplement<'1' | '2' | '3', '2' | '3'>;\n */\nexport type SetComplement<A, A1 extends A> = SetDifference<A, A1>;\n\n/**\n * SymmetricDifference\n * @desc Set difference of union and intersection of given union types `A` and `B`\n * @example\n *   // Expect: \"1\" | \"4\"\n *   SymmetricDifference<'1' | '2' | '3', '2' | '3' | '4'>;\n */\nexport type SymmetricDifference<A, B> = SetDifference<A | B, A & B>;\n\n/**\n * NonUndefined\n * @desc Exclude undefined from set `A`\n * @example\n *   // Expect: \"string | null\"\n *   SymmetricDifference<string | null | undefined>;\n */\nexport type NonUndefined<A> = A extends undefined ? never : A;\n\n/**\n * NonNullable\n * @desc Exclude undefined and null from set `A`\n * @example\n *   // Expect: \"string\"\n *   SymmetricDifference<string | null | undefined>;\n */\n// type NonNullable - built-in\n\n/**\n * FunctionKeys\n * @desc Get union type of keys that are functions in object type `T`\n * @example\n *  type MixedProps = {name: string; setName: (name: string) => void; someKeys?: string; someFn?: (...args: any) => any;};\n *\n *   // Expect: \"setName | someFn\"\n *   type Keys = FunctionKeys<MixedProps>;\n */\nexport type FunctionKeys<T extends object> = {\n  [K in keyof T]-?: NonUndefined<T[K]> extends Function ? K : never;\n}[keyof T];\n\n/**\n * NonFunctionKeys\n * @desc Get union type of keys that are non-functions in object type `T`\n * @example\n *   type MixedProps = {name: string; setName: (name: string) => void; someKeys?: string; someFn?: (...args: any) => any;};\n *\n *   // Expect: \"name | someKey\"\n *   type Keys = NonFunctionKeys<MixedProps>;\n */\nexport type NonFunctionKeys<T extends object> = {\n  [K in keyof T]-?: NonUndefined<T[K]> extends Function ? never : K;\n}[keyof T];\n\n/**\n * MutableKeys\n * @desc Get union type of keys that are mutable in object type `T`\n * Credit: Matt McCutchen\n * https://stackoverflow.com/questions/52443276/how-to-exclude-getter-only-properties-from-type-in-typescript\n * @example\n *   type Props = { readonly foo: string; bar: number };\n *\n *   // Expect: \"bar\"\n *   type Keys = MutableKeys<Props>;\n */\nexport type MutableKeys<T extends object> = {\n  [P in keyof T]-?: IfEquals<\n    { [Q in P]: T[P] },\n    { -readonly [Q in P]: T[P] },\n    P\n  >;\n}[keyof T];\nexport type WritableKeys<T extends object> = MutableKeys<T>;\n\n/**\n * ReadonlyKeys\n * @desc Get union type of keys that are readonly in object type `T`\n * Credit: Matt McCutchen\n * https://stackoverflow.com/questions/52443276/how-to-exclude-getter-only-properties-from-type-in-typescript\n * @example\n *   type Props = { readonly foo: string; bar: number };\n *\n *   // Expect: \"foo\"\n *   type Keys = ReadonlyKeys<Props>;\n */\nexport type ReadonlyKeys<T extends object> = {\n  [P in keyof T]-?: IfEquals<\n    { [Q in P]: T[P] },\n    { -readonly [Q in P]: T[P] },\n    never,\n    P\n  >;\n}[keyof T];\n\ntype IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <\n  T\n>() => T extends Y ? 1 : 2\n  ? A\n  : B;\n\n/**\n * RequiredKeys\n * @desc Get union type of keys that are required in object type `T`\n * @see https://stackoverflow.com/questions/52984808/is-there-a-way-to-get-all-required-properties-of-a-typescript-object\n * @example\n *   type Props = { req: number; reqUndef: number | undefined; opt?: string; optUndef?: number | undefined; };\n *\n *   // Expect: \"req\" | \"reqUndef\"\n *   type Keys = RequiredKeys<Props>;\n */\nexport type RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K;\n}[keyof T];\n\n/**\n * OptionalKeys\n * @desc Get union type of keys that are optional in object type `T`\n * @see https://stackoverflow.com/questions/52984808/is-there-a-way-to-get-all-required-properties-of-a-typescript-object\n * @example\n *   type Props = { req: number; reqUndef: number | undefined; opt?: string; optUndef?: number | undefined; };\n *\n *   // Expect: \"opt\" | \"optUndef\"\n *   type Keys = OptionalKeys<Props>;\n */\nexport type OptionalKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? K : never;\n}[keyof T];\n\n/**\n * Pick (complements Omit)\n * @desc From `T` pick a set of properties by key `K`\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *\n *   // Expect: { age: number; }\n *   type Props = Pick<Props, 'age'>;\n */\nnamespace Pick {}\n\n/**\n * PickByValue\n * @desc From `T` pick a set of properties by value matching `ValueType`.\n * Credit: [Piotr Lewandowski](https://medium.com/dailyjs/typescript-create-a-condition-based-subset-types-9d902cea5b8c)\n * @example\n *   type Props = { req: number; reqUndef: number | undefined; opt?: string; };\n *\n *   // Expect: { req: number }\n *   type Props = PickByValue<Props, number>;\n *   // Expect: { req: number; reqUndef: number | undefined; }\n *   type Props = PickByValue<Props, number | undefined>;\n */\nexport type PickByValue<T, ValueType> = Pick<\n  T,\n  { [Key in keyof T]-?: T[Key] extends ValueType ? Key : never }[keyof T]\n>;\n\n/**\n * PickByValueExact\n * @desc From `T` pick a set of properties by value matching exact `ValueType`.\n * @example\n *   type Props = { req: number; reqUndef: number | undefined; opt?: string; };\n *\n *   // Expect: { req: number }\n *   type Props = PickByValueExact<Props, number>;\n *   // Expect: { reqUndef: number | undefined; }\n *   type Props = PickByValueExact<Props, number | undefined>;\n */\nexport type PickByValueExact<T, ValueType> = Pick<\n  T,\n  {\n    [Key in keyof T]-?: [ValueType] extends [T[Key]]\n      ? [T[Key]] extends [ValueType]\n        ? Key\n        : never\n      : never;\n  }[keyof T]\n>;\n\n/**\n * Omit (complements Pick)\n * @desc From `T` remove a set of properties by key `K`\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *\n *   // Expect: { name: string; visible: boolean; }\n *   type Props = Omit<Props, 'age'>;\n */\nexport type Omit<T, K extends keyof any> = Pick<T, SetDifference<keyof T, K>>;\n\n/**\n * OmitByValue\n * @desc From `T` remove a set of properties by value matching `ValueType`.\n * Credit: [Piotr Lewandowski](https://medium.com/dailyjs/typescript-create-a-condition-based-subset-types-9d902cea5b8c)\n * @example\n *   type Props = { req: number; reqUndef: number | undefined; opt?: string; };\n *\n *   // Expect: { reqUndef: number | undefined; opt?: string; }\n *   type Props = OmitByValue<Props, number>;\n *   // Expect: { opt?: string; }\n *   type Props = OmitByValue<Props, number | undefined>;\n */\nexport type OmitByValue<T, ValueType> = Pick<\n  T,\n  { [Key in keyof T]-?: T[Key] extends ValueType ? never : Key }[keyof T]\n>;\n\n/**\n * OmitByValueExact\n * @desc From `T` remove a set of properties by value matching exact `ValueType`.\n * @example\n *   type Props = { req: number; reqUndef: number | undefined; opt?: string; };\n *\n *   // Expect: { reqUndef: number | undefined; opt?: string; }\n *   type Props = OmitByValueExact<Props, number>;\n *   // Expect: { req: number; opt?: string }\n *   type Props = OmitByValueExact<Props, number | undefined>;\n */\nexport type OmitByValueExact<T, ValueType> = Pick<\n  T,\n  {\n    [Key in keyof T]-?: [ValueType] extends [T[Key]]\n      ? [T[Key]] extends [ValueType]\n        ? never\n        : Key\n      : Key;\n  }[keyof T]\n>;\n\n/**\n * Intersection\n * @desc From `T` pick properties that exist in `U`\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *   type DefaultProps = { age: number };\n *\n *   // Expect: { age: number; }\n *   type DuplicateProps = Intersection<Props, DefaultProps>;\n */\nexport type Intersection<T extends object, U extends object> = Pick<\n  T,\n  Extract<keyof T, keyof U> & Extract<keyof U, keyof T>\n>;\n\n/**\n * Diff\n * @desc From `T` remove properties that exist in `U`\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *   type DefaultProps = { age: number };\n *\n *   // Expect: { name: string; visible: boolean; }\n *   type DiffProps = Diff<Props, DefaultProps>;\n */\nexport type Diff<T extends object, U extends object> = Pick<\n  T,\n  SetDifference<keyof T, keyof U>\n>;\n\n/**\n * Subtract\n * @desc From `T` remove properties that exist in `T1` (`T1` has a subset of the properties of `T`)\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *   type DefaultProps = { age: number };\n *\n *   // Expect: { name: string; visible: boolean; }\n *   type RestProps = Subtract<Props, DefaultProps>;\n */\nexport type Subtract<T extends T1, T1 extends object> = Pick<\n  T,\n  SetComplement<keyof T, keyof T1>\n>;\n\n/**\n * Overwrite\n * @desc From `U` overwrite properties to `T`\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *   type NewProps = { age: string; other: string };\n *\n *   // Expect: { name: string; age: string; visible: boolean; }\n *   type ReplacedProps = Overwrite<Props, NewProps>;\n */\nexport type Overwrite<\n  T extends object,\n  U extends object,\n  I = Diff<T, U> & Intersection<U, T>\n> = Pick<I, keyof I>;\n\n/**\n * Assign\n * @desc From `U` assign properties to `T` (just like object assign)\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *   type NewProps = { age: string; other: string };\n *\n *   // Expect: { name: string; age: number; visible: boolean; other: string; }\n *   type ExtendedProps = Assign<Props, NewProps>;\n */\nexport type Assign<\n  T extends object,\n  U extends object,\n  I = Diff<T, U> & Intersection<U, T> & Diff<U, T>\n> = Pick<I, keyof I>;\n\n/**\n * Exact\n * @desc Create branded object type for exact type matching\n */\nexport type Exact<A extends object> = A & { __brand: keyof A };\n\n/**\n * Unionize\n * @desc Disjoin object to form union of objects, each with single property\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *\n *   // Expect: { name: string; } | { age: number; } | { visible: boolean; }\n *   type UnionizedType = Unionize<Props>;\n */\nexport type Unionize<T extends object> = {\n  [P in keyof T]: { [Q in P]: T[P] };\n}[keyof T];\n\n/**\n * PromiseType\n * @desc Obtain Promise resolve type\n * @example\n *   // Expect: string;\n *   type Response = PromiseType<Promise<string>>;\n */\nexport type PromiseType<T extends Promise<any>> = T extends Promise<infer U>\n  ? U\n  : never;\n\n// TODO: inline _DeepReadonlyArray with infer in DeepReadonly, same for all other deep types\n/**\n * DeepReadonly\n * @desc Readonly that works for deeply nested structure\n * @example\n *   // Expect: {\n *   //   readonly first: {\n *   //     readonly second: {\n *   //       readonly name: string;\n *   //     };\n *   //   };\n *   // }\n *   type NestedProps = {\n *     first: {\n *       second: {\n *         name: string;\n *       };\n *     };\n *   };\n *   type ReadonlyNestedProps = DeepReadonly<NestedProps>;\n */\nexport type DeepReadonly<T> = T extends ((...args: any[]) => any) | Primitive\n  ? T\n  : T extends _DeepReadonlyArray<infer U>\n  ? _DeepReadonlyArray<U>\n  : T extends _DeepReadonlyObject<infer V>\n  ? _DeepReadonlyObject<V>\n  : T;\n/** @private */\n// tslint:disable-next-line:class-name\nexport interface _DeepReadonlyArray<T> extends ReadonlyArray<DeepReadonly<T>> {}\n/** @private */\nexport type _DeepReadonlyObject<T> = {\n  readonly [P in keyof T]: DeepReadonly<T[P]>;\n};\n\n/**\n * DeepRequired\n * @desc Required that works for deeply nested structure\n * @example\n *   // Expect: {\n *   //   first: {\n *   //     second: {\n *   //       name: string;\n *   //     };\n *   //   };\n *   // }\n *   type NestedProps = {\n *     first?: {\n *       second?: {\n *         name?: string;\n *       };\n *     };\n *   };\n *   type RequiredNestedProps = DeepRequired<NestedProps>;\n */\nexport type DeepRequired<T> = T extends (...args: any[]) => any\n  ? T\n  : T extends any[]\n  ? _DeepRequiredArray<T[number]>\n  : T extends object\n  ? _DeepRequiredObject<T>\n  : T;\n/** @private */\n// tslint:disable-next-line:class-name\nexport interface _DeepRequiredArray<T>\n  extends Array<DeepRequired<NonUndefined<T>>> {}\n/** @private */\nexport type _DeepRequiredObject<T> = {\n  [P in keyof T]-?: DeepRequired<NonUndefined<T[P]>>;\n};\n\n/**\n * DeepNonNullable\n * @desc NonNullable that works for deeply nested structure\n * @example\n *   // Expect: {\n *   //   first: {\n *   //     second: {\n *   //       name: string;\n *   //     };\n *   //   };\n *   // }\n *   type NestedProps = {\n *     first?: null | {\n *       second?: null | {\n *         name?: string | null |\n *         undefined;\n *       };\n *     };\n *   };\n *   type RequiredNestedProps = DeepNonNullable<NestedProps>;\n */\nexport type DeepNonNullable<T> = T extends (...args: any[]) => any\n  ? T\n  : T extends any[]\n  ? _DeepNonNullableArray<T[number]>\n  : T extends object\n  ? _DeepNonNullableObject<T>\n  : T;\n/** @private */\n// tslint:disable-next-line:class-name\nexport interface _DeepNonNullableArray<T>\n  extends Array<DeepNonNullable<NonNullable<T>>> {}\n/** @private */\nexport type _DeepNonNullableObject<T> = {\n  [P in keyof T]-?: DeepNonNullable<NonNullable<T[P]>>;\n};\n\n/**\n * DeepPartial\n * @desc Partial that works for deeply nested structure\n * @example\n *   // Expect: {\n *   //   first?: {\n *   //     second?: {\n *   //       name?: string;\n *   //     };\n *   //   };\n *   // }\n *   type NestedProps = {\n *     first: {\n *       second: {\n *         name: string;\n *       };\n *     };\n *   };\n *   type PartialNestedProps = DeepPartial<NestedProps>;\n */\nexport type DeepPartial<T> = T extends Function\n  ? T\n  : T extends Array<infer U>\n  ? _DeepPartialArray<U>\n  : T extends object\n  ? _DeepPartialObject<T>\n  : T | undefined;\n/** @private */\n// tslint:disable-next-line:class-name\nexport interface _DeepPartialArray<T> extends Array<DeepPartial<T>> {}\n/** @private */\nexport type _DeepPartialObject<T> = { [P in keyof T]?: DeepPartial<T[P]> };\n\n/**\n * Brand\n * @desc Define nominal type of U based on type of T. Similar to Opaque types in Flow.\n * @example\n *   type USD = Brand<number, \"USD\">\n *   type EUR = Brand<number, \"EUR\">\n *\n *   const tax = 5 as USD;\n *   const usd = 10 as USD;\n *   const eur = 10 as EUR;\n *\n *   function gross(net: USD): USD {\n *     return (net + tax) as USD;\n *   }\n *\n *   // Expect: No compile error\n *   gross(usd);\n *   // Expect: Compile error (Type '\"EUR\"' is not assignable to type '\"USD\"'.)\n *   gross(eur);\n */\nexport type Brand<T, U> = T & { __brand: U };\n\n/**\n * Optional\n * @desc From `T` make a set of properties by key `K` become optional\n * @example\n *    type Props = {\n *      name: string;\n *      age: number;\n *      visible: boolean;\n *    };\n *\n *    // Expect: { name?: string; age?: number; visible?: boolean; }\n *    type Props = Optional<Props>;\n *\n *    // Expect: { name: string; age?: number; visible?: boolean; }\n *    type Props = Optional<Props, 'age' | 'visible'>;\n */\nexport type Optional<T extends object, K extends keyof T = keyof T> = Omit<\n  T,\n  K\n> &\n  Partial<Pick<T, K>>;\n\n/**\n * ValuesType\n * @desc Get the union type of all the values in an object, array or array-like type `T`\n * @example\n *    type Props = { name: string; age: number; visible: boolean };\n *    // Expect: string | number | boolean\n *    type PropsValues = ValuesType<Props>;\n *\n *    type NumberArray = number[];\n *    // Expect: number\n *    type NumberItems = ValuesType<NumberArray>;\n *\n *    type ReadonlySymbolArray = readonly symbol[];\n *    // Expect: symbol\n *    type SymbolItems = ValuesType<ReadonlySymbolArray>;\n *\n *    type NumberTuple = [1, 2];\n *    // Expect: 1 | 2\n *    type NumberUnion = ValuesType<NumberTuple>;\n *\n *    type ReadonlyNumberTuple = readonly [1, 2];\n *    // Expect: 1 | 2\n *    type AnotherNumberUnion = ValuesType<NumberTuple>;\n *\n *    type BinaryArray = Uint8Array;\n *    // Expect: number\n *    type BinaryItems = ValuesType<BinaryArray>;\n */\nexport type ValuesType<\n  T extends ReadonlyArray<any> | ArrayLike<any> | Record<any, any>\n> = T extends ReadonlyArray<any>\n  ? T[number]\n  : T extends ArrayLike<any>\n  ? T[number]\n  : T extends object\n  ? T[keyof T]\n  : never;\n\n/**\n * Required\n * @desc From `T` make a set of properties by key `K` become required\n * @example\n *    type Props = {\n *      name?: string;\n *      age?: number;\n *      visible?: boolean;\n *    };\n *\n *    // Expect: { name: string; age: number; visible: boolean; }\n *    type Props = Required<Props>;\n *\n *    // Expect: { name?: string; age: number; visible: boolean; }\n *    type Props = Required<Props, 'age' | 'visible'>;\n */\nexport type AugmentedRequired<\n  T extends object,\n  K extends keyof T = keyof T\n> = Omit<T, K> & Required<Pick<T, K>>;\n\n/**\n * UnionToIntersection\n * @desc Get intersection type given union type `U`\n * Credit: jcalz\n * @see https://stackoverflow.com/a/50375286/7381355\n * @example\n *   // Expect: { name: string } & { age: number } & { visible: boolean }\n *   UnionToIntersection<{ name: string } | { age: number } | { visible: boolean }>\n */\nexport type UnionToIntersection<U> = (U extends any\n? (k: U) => void\n: never) extends (k: infer I) => void\n  ? I\n  : never;\n\n/**\n * Mutable\n * @desc From `T` make all properties become mutable\n * @example\n *    type Props = {\n *      readonly name: string;\n *      readonly age: number;\n *      readonly visible: boolean;\n *    };\n *\n *    // Expect: { name: string; age: number; visible: boolean; }\n *    Mutable<Props>;\n */\nexport type Mutable<T> = { -readonly [P in keyof T]: T[P] };\nexport type Writable<T> = Mutable<T>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n",normalizedContent:"# \n\n\n\n * \n\n\n\n/**\n * setintersection (same as extract)\n * @desc set intersection of given union types `a` and `b`\n * @example\n *   // expect: \"2\" | \"3\"\n *   setintersection<'1' | '2' | '3', '2' | '3' | '4'>;\n *\n *   // expect: () => void\n *   setintersection<string | number | (() => void), function>;\n */\nexport type setintersection<a, b> = a extends b ? a : never;\n\n/**\n * setdifference (same as exclude)\n * @desc set difference of given union types `a` and `b`\n * @example\n *   // expect: \"1\"\n *   setdifference<'1' | '2' | '3', '2' | '3' | '4'>;\n *\n *   // expect: string | number\n *   setdifference<string | number | (() => void), function>;\n */\nexport type setdifference<a, b> = a extends b ? never : a;\n\n/**\n * setcomplement\n * @desc set complement of given union types `a` and (it's subset) `a1`\n * @example\n *   // expect: \"1\"\n *   setcomplement<'1' | '2' | '3', '2' | '3'>;\n */\nexport type setcomplement<a, a1 extends a> = setdifference<a, a1>;\n\n/**\n * symmetricdifference\n * @desc set difference of union and intersection of given union types `a` and `b`\n * @example\n *   // expect: \"1\" | \"4\"\n *   symmetricdifference<'1' | '2' | '3', '2' | '3' | '4'>;\n */\nexport type symmetricdifference<a, b> = setdifference<a | b, a & b>;\n\n/**\n * nonundefined\n * @desc exclude undefined from set `a`\n * @example\n *   // expect: \"string | null\"\n *   symmetricdifference<string | null | undefined>;\n */\nexport type nonundefined<a> = a extends undefined ? never : a;\n\n/**\n * nonnullable\n * @desc exclude undefined and null from set `a`\n * @example\n *   // expect: \"string\"\n *   symmetricdifference<string | null | undefined>;\n */\n// type nonnullable - built-in\n\n/**\n * functionkeys\n * @desc get union type of keys that are functions in object type `t`\n * @example\n *  type mixedprops = {name: string; setname: (name: string) => void; somekeys?: string; somefn?: (...args: any) => any;};\n *\n *   // expect: \"setname | somefn\"\n *   type keys = functionkeys<mixedprops>;\n */\nexport type functionkeys<t extends object> = {\n  [k in keyof t]-?: nonundefined<t[k]> extends function ? k : never;\n}[keyof t];\n\n/**\n * nonfunctionkeys\n * @desc get union type of keys that are non-functions in object type `t`\n * @example\n *   type mixedprops = {name: string; setname: (name: string) => void; somekeys?: string; somefn?: (...args: any) => any;};\n *\n *   // expect: \"name | somekey\"\n *   type keys = nonfunctionkeys<mixedprops>;\n */\nexport type nonfunctionkeys<t extends object> = {\n  [k in keyof t]-?: nonundefined<t[k]> extends function ? never : k;\n}[keyof t];\n\n/**\n * mutablekeys\n * @desc get union type of keys that are mutable in object type `t`\n * credit: matt mccutchen\n * https://stackoverflow.com/questions/52443276/how-to-exclude-getter-only-properties-from-type-in-typescript\n * @example\n *   type props = { readonly foo: string; bar: number };\n *\n *   // expect: \"bar\"\n *   type keys = mutablekeys<props>;\n */\nexport type mutablekeys<t extends object> = {\n  [p in keyof t]-?: ifequals<\n    { [q in p]: t[p] },\n    { -readonly [q in p]: t[p] },\n    p\n  >;\n}[keyof t];\nexport type writablekeys<t extends object> = mutablekeys<t>;\n\n/**\n * readonlykeys\n * @desc get union type of keys that are readonly in object type `t`\n * credit: matt mccutchen\n * https://stackoverflow.com/questions/52443276/how-to-exclude-getter-only-properties-from-type-in-typescript\n * @example\n *   type props = { readonly foo: string; bar: number };\n *\n *   // expect: \"foo\"\n *   type keys = readonlykeys<props>;\n */\nexport type readonlykeys<t extends object> = {\n  [p in keyof t]-?: ifequals<\n    { [q in p]: t[p] },\n    { -readonly [q in p]: t[p] },\n    never,\n    p\n  >;\n}[keyof t];\n\ntype ifequals<x, y, a = x, b = never> = (<t>() => t extends x ? 1 : 2) extends <\n  t\n>() => t extends y ? 1 : 2\n  ? a\n  : b;\n\n/**\n * requiredkeys\n * @desc get union type of keys that are required in object type `t`\n * @see https://stackoverflow.com/questions/52984808/is-there-a-way-to-get-all-required-properties-of-a-typescript-object\n * @example\n *   type props = { req: number; requndef: number | undefined; opt?: string; optundef?: number | undefined; };\n *\n *   // expect: \"req\" | \"requndef\"\n *   type keys = requiredkeys<props>;\n */\nexport type requiredkeys<t> = {\n  [k in keyof t]-?: {} extends pick<t, k> ? never : k;\n}[keyof t];\n\n/**\n * optionalkeys\n * @desc get union type of keys that are optional in object type `t`\n * @see https://stackoverflow.com/questions/52984808/is-there-a-way-to-get-all-required-properties-of-a-typescript-object\n * @example\n *   type props = { req: number; requndef: number | undefined; opt?: string; optundef?: number | undefined; };\n *\n *   // expect: \"opt\" | \"optundef\"\n *   type keys = optionalkeys<props>;\n */\nexport type optionalkeys<t> = {\n  [k in keyof t]-?: {} extends pick<t, k> ? k : never;\n}[keyof t];\n\n/**\n * pick (complements omit)\n * @desc from `t` pick a set of properties by key `k`\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *\n *   // expect: { age: number; }\n *   type props = pick<props, 'age'>;\n */\nnamespace pick {}\n\n/**\n * pickbyvalue\n * @desc from `t` pick a set of properties by value matching `valuetype`.\n * credit: [piotr lewandowski](https://medium.com/dailyjs/typescript-create-a-condition-based-subset-types-9d902cea5b8c)\n * @example\n *   type props = { req: number; requndef: number | undefined; opt?: string; };\n *\n *   // expect: { req: number }\n *   type props = pickbyvalue<props, number>;\n *   // expect: { req: number; requndef: number | undefined; }\n *   type props = pickbyvalue<props, number | undefined>;\n */\nexport type pickbyvalue<t, valuetype> = pick<\n  t,\n  { [key in keyof t]-?: t[key] extends valuetype ? key : never }[keyof t]\n>;\n\n/**\n * pickbyvalueexact\n * @desc from `t` pick a set of properties by value matching exact `valuetype`.\n * @example\n *   type props = { req: number; requndef: number | undefined; opt?: string; };\n *\n *   // expect: { req: number }\n *   type props = pickbyvalueexact<props, number>;\n *   // expect: { requndef: number | undefined; }\n *   type props = pickbyvalueexact<props, number | undefined>;\n */\nexport type pickbyvalueexact<t, valuetype> = pick<\n  t,\n  {\n    [key in keyof t]-?: [valuetype] extends [t[key]]\n      ? [t[key]] extends [valuetype]\n        ? key\n        : never\n      : never;\n  }[keyof t]\n>;\n\n/**\n * omit (complements pick)\n * @desc from `t` remove a set of properties by key `k`\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *\n *   // expect: { name: string; visible: boolean; }\n *   type props = omit<props, 'age'>;\n */\nexport type omit<t, k extends keyof any> = pick<t, setdifference<keyof t, k>>;\n\n/**\n * omitbyvalue\n * @desc from `t` remove a set of properties by value matching `valuetype`.\n * credit: [piotr lewandowski](https://medium.com/dailyjs/typescript-create-a-condition-based-subset-types-9d902cea5b8c)\n * @example\n *   type props = { req: number; requndef: number | undefined; opt?: string; };\n *\n *   // expect: { requndef: number | undefined; opt?: string; }\n *   type props = omitbyvalue<props, number>;\n *   // expect: { opt?: string; }\n *   type props = omitbyvalue<props, number | undefined>;\n */\nexport type omitbyvalue<t, valuetype> = pick<\n  t,\n  { [key in keyof t]-?: t[key] extends valuetype ? never : key }[keyof t]\n>;\n\n/**\n * omitbyvalueexact\n * @desc from `t` remove a set of properties by value matching exact `valuetype`.\n * @example\n *   type props = { req: number; requndef: number | undefined; opt?: string; };\n *\n *   // expect: { requndef: number | undefined; opt?: string; }\n *   type props = omitbyvalueexact<props, number>;\n *   // expect: { req: number; opt?: string }\n *   type props = omitbyvalueexact<props, number | undefined>;\n */\nexport type omitbyvalueexact<t, valuetype> = pick<\n  t,\n  {\n    [key in keyof t]-?: [valuetype] extends [t[key]]\n      ? [t[key]] extends [valuetype]\n        ? never\n        : key\n      : key;\n  }[keyof t]\n>;\n\n/**\n * intersection\n * @desc from `t` pick properties that exist in `u`\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *   type defaultprops = { age: number };\n *\n *   // expect: { age: number; }\n *   type duplicateprops = intersection<props, defaultprops>;\n */\nexport type intersection<t extends object, u extends object> = pick<\n  t,\n  extract<keyof t, keyof u> & extract<keyof u, keyof t>\n>;\n\n/**\n * diff\n * @desc from `t` remove properties that exist in `u`\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *   type defaultprops = { age: number };\n *\n *   // expect: { name: string; visible: boolean; }\n *   type diffprops = diff<props, defaultprops>;\n */\nexport type diff<t extends object, u extends object> = pick<\n  t,\n  setdifference<keyof t, keyof u>\n>;\n\n/**\n * subtract\n * @desc from `t` remove properties that exist in `t1` (`t1` has a subset of the properties of `t`)\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *   type defaultprops = { age: number };\n *\n *   // expect: { name: string; visible: boolean; }\n *   type restprops = subtract<props, defaultprops>;\n */\nexport type subtract<t extends t1, t1 extends object> = pick<\n  t,\n  setcomplement<keyof t, keyof t1>\n>;\n\n/**\n * overwrite\n * @desc from `u` overwrite properties to `t`\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *   type newprops = { age: string; other: string };\n *\n *   // expect: { name: string; age: string; visible: boolean; }\n *   type replacedprops = overwrite<props, newprops>;\n */\nexport type overwrite<\n  t extends object,\n  u extends object,\n  i = diff<t, u> & intersection<u, t>\n> = pick<i, keyof i>;\n\n/**\n * assign\n * @desc from `u` assign properties to `t` (just like object assign)\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *   type newprops = { age: string; other: string };\n *\n *   // expect: { name: string; age: number; visible: boolean; other: string; }\n *   type extendedprops = assign<props, newprops>;\n */\nexport type assign<\n  t extends object,\n  u extends object,\n  i = diff<t, u> & intersection<u, t> & diff<u, t>\n> = pick<i, keyof i>;\n\n/**\n * exact\n * @desc create branded object type for exact type matching\n */\nexport type exact<a extends object> = a & { __brand: keyof a };\n\n/**\n * unionize\n * @desc disjoin object to form union of objects, each with single property\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *\n *   // expect: { name: string; } | { age: number; } | { visible: boolean; }\n *   type unionizedtype = unionize<props>;\n */\nexport type unionize<t extends object> = {\n  [p in keyof t]: { [q in p]: t[p] };\n}[keyof t];\n\n/**\n * promisetype\n * @desc obtain promise resolve type\n * @example\n *   // expect: string;\n *   type response = promisetype<promise<string>>;\n */\nexport type promisetype<t extends promise<any>> = t extends promise<infer u>\n  ? u\n  : never;\n\n// todo: inline _deepreadonlyarray with infer in deepreadonly, same for all other deep types\n/**\n * deepreadonly\n * @desc readonly that works for deeply nested structure\n * @example\n *   // expect: {\n *   //   readonly first: {\n *   //     readonly second: {\n *   //       readonly name: string;\n *   //     };\n *   //   };\n *   // }\n *   type nestedprops = {\n *     first: {\n *       second: {\n *         name: string;\n *       };\n *     };\n *   };\n *   type readonlynestedprops = deepreadonly<nestedprops>;\n */\nexport type deepreadonly<t> = t extends ((...args: any[]) => any) | primitive\n  ? t\n  : t extends _deepreadonlyarray<infer u>\n  ? _deepreadonlyarray<u>\n  : t extends _deepreadonlyobject<infer v>\n  ? _deepreadonlyobject<v>\n  : t;\n/** @private */\n// tslint:disable-next-line:class-name\nexport interface _deepreadonlyarray<t> extends readonlyarray<deepreadonly<t>> {}\n/** @private */\nexport type _deepreadonlyobject<t> = {\n  readonly [p in keyof t]: deepreadonly<t[p]>;\n};\n\n/**\n * deeprequired\n * @desc required that works for deeply nested structure\n * @example\n *   // expect: {\n *   //   first: {\n *   //     second: {\n *   //       name: string;\n *   //     };\n *   //   };\n *   // }\n *   type nestedprops = {\n *     first?: {\n *       second?: {\n *         name?: string;\n *       };\n *     };\n *   };\n *   type requirednestedprops = deeprequired<nestedprops>;\n */\nexport type deeprequired<t> = t extends (...args: any[]) => any\n  ? t\n  : t extends any[]\n  ? _deeprequiredarray<t[number]>\n  : t extends object\n  ? _deeprequiredobject<t>\n  : t;\n/** @private */\n// tslint:disable-next-line:class-name\nexport interface _deeprequiredarray<t>\n  extends array<deeprequired<nonundefined<t>>> {}\n/** @private */\nexport type _deeprequiredobject<t> = {\n  [p in keyof t]-?: deeprequired<nonundefined<t[p]>>;\n};\n\n/**\n * deepnonnullable\n * @desc nonnullable that works for deeply nested structure\n * @example\n *   // expect: {\n *   //   first: {\n *   //     second: {\n *   //       name: string;\n *   //     };\n *   //   };\n *   // }\n *   type nestedprops = {\n *     first?: null | {\n *       second?: null | {\n *         name?: string | null |\n *         undefined;\n *       };\n *     };\n *   };\n *   type requirednestedprops = deepnonnullable<nestedprops>;\n */\nexport type deepnonnullable<t> = t extends (...args: any[]) => any\n  ? t\n  : t extends any[]\n  ? _deepnonnullablearray<t[number]>\n  : t extends object\n  ? _deepnonnullableobject<t>\n  : t;\n/** @private */\n// tslint:disable-next-line:class-name\nexport interface _deepnonnullablearray<t>\n  extends array<deepnonnullable<nonnullable<t>>> {}\n/** @private */\nexport type _deepnonnullableobject<t> = {\n  [p in keyof t]-?: deepnonnullable<nonnullable<t[p]>>;\n};\n\n/**\n * deeppartial\n * @desc partial that works for deeply nested structure\n * @example\n *   // expect: {\n *   //   first?: {\n *   //     second?: {\n *   //       name?: string;\n *   //     };\n *   //   };\n *   // }\n *   type nestedprops = {\n *     first: {\n *       second: {\n *         name: string;\n *       };\n *     };\n *   };\n *   type partialnestedprops = deeppartial<nestedprops>;\n */\nexport type deeppartial<t> = t extends function\n  ? t\n  : t extends array<infer u>\n  ? _deeppartialarray<u>\n  : t extends object\n  ? _deeppartialobject<t>\n  : t | undefined;\n/** @private */\n// tslint:disable-next-line:class-name\nexport interface _deeppartialarray<t> extends array<deeppartial<t>> {}\n/** @private */\nexport type _deeppartialobject<t> = { [p in keyof t]?: deeppartial<t[p]> };\n\n/**\n * brand\n * @desc define nominal type of u based on type of t. similar to opaque types in flow.\n * @example\n *   type usd = brand<number, \"usd\">\n *   type eur = brand<number, \"eur\">\n *\n *   const tax = 5 as usd;\n *   const usd = 10 as usd;\n *   const eur = 10 as eur;\n *\n *   function gross(net: usd): usd {\n *     return (net + tax) as usd;\n *   }\n *\n *   // expect: no compile error\n *   gross(usd);\n *   // expect: compile error (type '\"eur\"' is not assignable to type '\"usd\"'.)\n *   gross(eur);\n */\nexport type brand<t, u> = t & { __brand: u };\n\n/**\n * optional\n * @desc from `t` make a set of properties by key `k` become optional\n * @example\n *    type props = {\n *      name: string;\n *      age: number;\n *      visible: boolean;\n *    };\n *\n *    // expect: { name?: string; age?: number; visible?: boolean; }\n *    type props = optional<props>;\n *\n *    // expect: { name: string; age?: number; visible?: boolean; }\n *    type props = optional<props, 'age' | 'visible'>;\n */\nexport type optional<t extends object, k extends keyof t = keyof t> = omit<\n  t,\n  k\n> &\n  partial<pick<t, k>>;\n\n/**\n * valuestype\n * @desc get the union type of all the values in an object, array or array-like type `t`\n * @example\n *    type props = { name: string; age: number; visible: boolean };\n *    // expect: string | number | boolean\n *    type propsvalues = valuestype<props>;\n *\n *    type numberarray = number[];\n *    // expect: number\n *    type numberitems = valuestype<numberarray>;\n *\n *    type readonlysymbolarray = readonly symbol[];\n *    // expect: symbol\n *    type symbolitems = valuestype<readonlysymbolarray>;\n *\n *    type numbertuple = [1, 2];\n *    // expect: 1 | 2\n *    type numberunion = valuestype<numbertuple>;\n *\n *    type readonlynumbertuple = readonly [1, 2];\n *    // expect: 1 | 2\n *    type anothernumberunion = valuestype<numbertuple>;\n *\n *    type binaryarray = uint8array;\n *    // expect: number\n *    type binaryitems = valuestype<binaryarray>;\n */\nexport type valuestype<\n  t extends readonlyarray<any> | arraylike<any> | record<any, any>\n> = t extends readonlyarray<any>\n  ? t[number]\n  : t extends arraylike<any>\n  ? t[number]\n  : t extends object\n  ? t[keyof t]\n  : never;\n\n/**\n * required\n * @desc from `t` make a set of properties by key `k` become required\n * @example\n *    type props = {\n *      name?: string;\n *      age?: number;\n *      visible?: boolean;\n *    };\n *\n *    // expect: { name: string; age: number; visible: boolean; }\n *    type props = required<props>;\n *\n *    // expect: { name?: string; age: number; visible: boolean; }\n *    type props = required<props, 'age' | 'visible'>;\n */\nexport type augmentedrequired<\n  t extends object,\n  k extends keyof t = keyof t\n> = omit<t, k> & required<pick<t, k>>;\n\n/**\n * uniontointersection\n * @desc get intersection type given union type `u`\n * credit: jcalz\n * @see https://stackoverflow.com/a/50375286/7381355\n * @example\n *   // expect: { name: string } & { age: number } & { visible: boolean }\n *   uniontointersection<{ name: string } | { age: number } | { visible: boolean }>\n */\nexport type uniontointersection<u> = (u extends any\n? (k: u) => void\n: never) extends (k: infer i) => void\n  ? i\n  : never;\n\n/**\n * mutable\n * @desc from `t` make all properties become mutable\n * @example\n *    type props = {\n *      readonly name: string;\n *      readonly age: number;\n *      readonly visible: boolean;\n *    };\n *\n *    // expect: { name: string; age: number; visible: boolean; }\n *    mutable<props>;\n */\nexport type mutable<t> = { -readonly [p in keyof t]: t[p] };\nexport type writable<t> = mutable<t>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/single-spa/index/",categories:["single-spa"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/0.index.html",relativePath:"30.web/5.single-spa/0.index.md",key:"v-1ba4b31b",path:"/single-spa/index/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:234},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:634},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:849},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:50},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:938},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:1167}],readingTime:{text:"1 min read",minutes:.705,time:42300,words:141},headersStr:"      ",content:"# \n\nSingle-spa  JavaScript   single-spa :\n\n *   (React, AngularJS, Angular, Ember, )\n * \n * \n * \n\n\n# \n\nsingle-spa \n\n * \n * \n * \n\nqiankun  single-spa \n\n * \n * JavaScript \n *  JavaScript  vanillaJSJQuery \n * CSS \n *  prefetch globalState \n\nsingle-spa  single-spa \n\n\n# \n\n\n\n                 \nsingle-spa   s-spa   single-spa \n                \n     /       \n\n\n\n qiankun  single-spa \n\n\n# \n\n\n\n * single-spa | s-spa \n\n\n# \n\n\n\n\n# \n\n single-spa \n\n 1. single-spa applications: \n\n 2. single-spa parcels: \n\n 3. utility modules:  javascript \n\n web \n\n\n# \n\nGetting Started with single-spa | single-spa",normalizedContent:"# \n\nsingle-spa  javascript   single-spa :\n\n *   (react, angularjs, angular, ember, )\n * \n * \n * \n\n\n# \n\nsingle-spa \n\n * \n * \n * \n\nqiankun  single-spa \n\n * \n * javascript \n *  javascript  vanillajsjquery \n * css \n *  prefetch globalstate \n\nsingle-spa  single-spa \n\n\n# \n\n\n\n                 \nsingle-spa   s-spa   single-spa \n                \n     /       \n\n\n\n qiankun  single-spa \n\n\n# \n\n\n\n * single-spa | s-spa \n\n\n# \n\n\n\n\n# \n\n single-spa \n\n 1. single-spa applications: \n\n 2. single-spa parcels: \n\n 3. utility modules:  javascript \n\n web \n\n\n# \n\ngetting started with single-spa | single-spa",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/single-spa/app/index/",categories:["single-spa","app"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/10.app%E4%B8%8E%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/0.index.html",relativePath:"30.web/5.single-spa/10.app/0.index.md",key:"v-6b7f390c",path:"/single-spa/app/index/",readingTime:{text:"0 min read",minutes:0,time:0,words:0},headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"Apps",frontmatter:{title:"Apps",date:"2022-04-14T22:02:21.000Z",permalink:"/single-spa/app/apps/",categories:["single-spa","app"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/10.app%E4%B8%8E%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/10.apps.html",relativePath:"30.web/5.single-spa/10.app/10.apps.md",key:"v-3bded94c",path:"/single-spa/app/apps/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:125},{level:2,title:"registerApplication",slug:"registerapplication",normalizedTitle:"registerapplication",charIndex:140},{level:2,title:"unregisterApplication",slug:"unregisterapplication",normalizedTitle:"unregisterapplication",charIndex:163},{level:2,title:"unloadApplication",slug:"unloadapplication",normalizedTitle:"unloadapplication",charIndex:188},{level:2,title:"immediatelyUnloadApp",slug:"immediatelyunloadapp",normalizedTitle:"immediatelyunloadapp",charIndex:209},{level:2,title:"getAppNames",slug:"getappnames",normalizedTitle:"getappnames",charIndex:233},{level:2,title:"getMountedApps",slug:"getmountedapps",normalizedTitle:"getmountedapps",charIndex:248},{level:2,title:"getAppStatus",slug:"getappstatus",normalizedTitle:"getappstatus",charIndex:266},{level:2,title:"checkActivityFunctions",slug:"checkactivityfunctions",normalizedTitle:"checkactivityfunctions",charIndex:282},{level:2,title:"pathToActiveWhen",slug:"pathtoactivewhen",normalizedTitle:"pathtoactivewhen",charIndex:308},{level:2,title:"toDynamicPathValidatorRegex",slug:"todynamicpathvalidatorregex",normalizedTitle:"todynamicpathvalidatorregex",charIndex:328},{level:2,title:"getAppChanges",slug:"getappchanges",normalizedTitle:"getappchanges",charIndex:359},{level:2,title:"globalTimeoutConfig",slug:"globaltimeoutconfig",normalizedTitle:"globaltimeoutconfig",charIndex:376},{level:2,title:"start",slug:"start",normalizedTitle:"start",charIndex:399}],excerpt:'<Badges :content="[]" />\n<TimeToRead />\n<p> single-spa  API API s-spa  registerunregisterunload  s-spa </p>\n',readingTime:{text:"8 min read",minutes:7.155,time:429300,words:1431},headersStr:" registerApplication unregisterApplication unloadApplication immediatelyUnloadApp getAppNames getMountedApps getAppStatus checkActivityFunctions pathToActiveWhen toDynamicPathValidatorRegex getAppChanges globalTimeoutConfig start",content:' single-spa  API API s-spa  registerunregisterunload  s-spa \n\n\n# \n\n\n\n * \n * registerApplication\n * unregisterApplication\n * unloadApplication\n * immediatelyUnloadApp\n * getAppNames\n * getMountedApps\n * getAppStatus\n * checkActivityFunctions\n * pathToActiveWhen\n * toDynamicPathValidatorRegex\n * getAppChanges\n * globalTimeoutConfig\n * start\n\n\n\n src/applications/apps.js\n\n\n# registerApplication\n\nregisterApplication \n\n// src/applications/apps.js\nconst apps = [];\nexport const isInBrowser = typeof window !== "undefined";\nexport function registerApplication(\n  appNameOrConfig,\n  appOrLoadApp,\n  activeWhen,\n  customProps\n) {\n  // \n  const registration = sanitizeArguments(\n    appNameOrConfig,\n    appOrLoadApp,\n    activeWhen,\n    customProps\n  );\n  // \n  if (getAppNames().indexOf(registration.name) !== -1)\n    throw Error(\n      formatErrorMessage(\n        21,\n        __DEV__ &&\n          `There is already an app registered with name ${registration.name}`,\n        registration.name\n      )\n    );\n  // \n  apps.push(\n    assign(\n      {\n        loadErrorTime: null,\n        status: NOT_LOADED,\n        parcels: {},\n        devtools: {\n          overlays: {\n            options: {},\n            selectors: [],\n          },\n        },\n      },\n      registration\n    )\n  );\n\n  if (isInBrowser) {\n    //  jq \n    ensureJQuerySupport();\n    // \n    reroute();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n 1. \n\nsanitizeArguments  API \n\n 2. map  mapper\n\nexport function getAppNames() {\n  return apps.map(toName);\n}\nexport function toName(app) {\n  return app.name;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n mapforEach  mapper \n\n 3. formatErrorMessage\n\nexport function formatErrorMessage(code, msg, ...args) {\n  return `single-spa minified message #${code}: ${\n    msg ? msg + " " : ""\n  }See https://single-spa.js.org/error/?code=${code}${\n    args.length ? `&arg=${args.join("&arg=")}` : ""\n  }`;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n code \n\n\n# unregisterApplication\n\nunregisterApplication \n\nexport function unregisterApplication(appName) {\n  // \n  if (apps.filter((app) => toName(app) === appName).length === 0) {\n    // ......\n  }\n\n  return unloadApplication(appName).then(() => {\n    // \n    const appIndex = apps.map(toName).indexOf(appName);\n    apps.splice(appIndex, 1);\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# unloadApplication\n\nunloadApplication unload \n\nexport function unloadApplication(appName, opts = { waitForUnmount: false }) {\n  // ......\n\n  const appUnloadInfo = getAppUnloadInfo(toName(app));\n  //  unload  unmount unmount  unload\n  if (opts && opts.waitForUnmount) {\n    // We need to wait for unmount before unloading the app\n    if (appUnloadInfo) {\n      // Someone else is already waiting for this, too\n      //  unload promise\n      return appUnloadInfo.promise;\n    } else {\n      // We\'re the first ones wanting the app to be resolved.\n      //  unload  promisepromise  unload  resolve\n      const promise = new Promise((resolve, reject) => {\n        addAppToUnload(app, () => promise, resolve, reject);\n      });\n      return promise;\n    }\n  } else {\n    /* We should unmount the app, unload it, and remount it immediately.*/\n    let resultPromise;\n    //  unmount unload \n    if (appUnloadInfo) {\n      // Someone else is already waiting for this app to unload\n      resultPromise = appUnloadInfo.promise;\n      //   unload  unload unload promise.resolve \n      immediatelyUnloadApp(app, appUnloadInfo.resolve, appUnloadInfo.reject);\n    } else {\n      // We\'re the first ones wanting the app to be resolved.\n      //  promise promise  unload  unload \n      resultPromise = new Promise((resolve, reject) => {\n        addAppToUnload(app, () => resultPromise, resolve, reject);\n        immediatelyUnloadApp(app, resolve, reject);\n      });\n    }\n    //  unload promise\n    return resultPromise;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n *  unmount  unload \n *  unload  unmount unload  unload  promise unload  promise  resolve unmount  unmount  unmount  unload \n *  unmount  unload\n\n\n# immediatelyUnloadApp\n\n unload \n\n unloadApplication  waitForUnmount  false  unload  unmount\n\nfunction immediatelyUnloadApp(app, resolve, reject) {\n  toUnmountPromise(app)\n    .then(toUnloadPromise)\n    .then(() => {\n      resolve();\n      setTimeout(() => {\n        // reroute, but the unload promise is done\n        //  unload \n        reroute();\n      });\n    })\n    .catch(reject);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n *  unload  unmount unload promise toUnmountPromise unmount  promise toUnloadPromise unload  promiseunload  resolve  unload  promise  async/await\n * toUnloadPromise  toUnmountPromise \n\n\n# getAppNames\n\n\n\nexport function getAppNames() {\n  return apps.map(toName);\n}\n\n\n1\n2\n3\n\n\n\n# getMountedApps\n\ngetMountedApps  mount \n\nexport function isActive(app) {\n  return app.status === MOUNTED;\n}\nexport function getMountedApps() {\n  return apps.filter(isActive).map(toName);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# getAppStatus\n\n\n\nexport function getAppStatus(appName) {\n  const app = find(apps, (app) => toName(app) === appName);\n  return app ? app.status : null;\n}\n\n\n1\n2\n3\n4\n\n\n\n# checkActivityFunctions\n\n\n\nexport function checkActivityFunctions(location = window.location) {\n  return apps.filter((app) => app.activeWhen(location)).map(toName);\n}\n\n\n1\n2\n3\n\n\n\n# pathToActiveWhen\n\n path string  activity functionActiveWhen\n\nActiveWhen  ActivityFunction path path Activity Function\n\nexport function pathToActiveWhen(path, exactMatch) {\n  //  path \n  const regex = toDynamicPathValidatorRegex(path, exactMatch);\n  //  Activity function\n  return (location) => {\n    // compatible with IE10\n    let origin = location.origin;\n    if (!origin) {\n      origin = `${location.protocol}//${location.host}`;\n    }\n    //  originsearch string\n    const route = location.href\n      .replace(origin, "")\n      .replace(location.search, "")\n      .split("?")[0];\n    return regex.test(route);\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n path \n\n\n# toDynamicPathValidatorRegex\n\nfunction toDynamicPathValidatorRegex(path, exactMatch) {\n  let lastIndex = 0,\n    inDynamic = false,\n    regexStr = "^";\n  // string  / \n  if (path[0] !== "/") {\n    path = "/" + path;\n  }\n  //  path\n  for (let charIndex = 0; charIndex < path.length; charIndex++) {\n    const char = path[charIndex];\n    const startOfDynamic = !inDynamic && char === ":";\n    const endOfDynamic = inDynamic && char === "/";\n    if (startOfDynamic || endOfDynamic) {\n      appendToRegex(charIndex);\n    }\n  }\n\n  appendToRegex(path.length);\n  return new RegExp(regexStr, "i");\n\n  function appendToRegex(index) {\n    const anyCharMaybeTrailingSlashRegex = "[^/]+/?";\n    const commonStringSubPath = escapeStrRegex(path.slice(lastIndex, index));\n\n    regexStr += inDynamic\n      ? anyCharMaybeTrailingSlashRegex\n      : commonStringSubPath;\n    // path  exactMatch \n    if (index === path.length) {\n      if (inDynamic) {\n        if (exactMatch) {\n          // Ensure exact match paths that end in a dynamic portion don\'t match\n          // urls with characters after a slash after the dynamic portion.\n          regexStr += "$";\n        }\n      } else {\n        // For exact matches, expect no more characters. Otherwise, allow\n        // any characters.\n        const suffix = exactMatch ? "" : ".*";\n\n        regexStr =\n          // use charAt instead as we could not use es6 method endsWith\n          regexStr.charAt(regexStr.length - 1) === "/"\n            ? `${regexStr}${suffix}$`\n            : `${regexStr}(/${suffix})?(#.*)?$`;\n      }\n    }\n\n    inDynamic = !inDynamic;\n    lastIndex = index;\n  }\n  // escape \n  function escapeStrRegex(str) {\n    // borrowed from https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js\n    return str.replace(/[|\\\\{}()[\\]^$+*?.]/g, "\\\\$&");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n string  path \n\n\n# getAppChanges\n\ngetAppChanges getAppChanges  appsToUnload , appsToUnmount , appsToLoad , appsToMount \n\nexport function getAppChanges() {\n  const appsToUnload = [],\n    appsToUnmount = [],\n    appsToLoad = [],\n    appsToMount = [];\n\n  // We re-attempt to download applications in LOAD_ERROR after a timeout of 200 milliseconds\n  const currentTime = new Date().getTime();\n  // \n  apps.forEach((app) => {\n    //  active\n    const appShouldBeActive =\n      app.status !== SKIP_BECAUSE_BROKEN && shouldBeActive(app);\n\n    switch (app.status) {\n      case LOAD_ERROR:\n        //  load  200 ms load \n        if (appShouldBeActive && currentTime - app.loadErrorTime >= 200) {\n          appsToLoad.push(app);\n        }\n        break;\n      case NOT_LOADED:\n      case LOADING_SOURCE_CODE:\n        //  load  load  load \n        if (appShouldBeActive) {\n          appsToLoad.push(app);\n        }\n        break;\n      case NOT_BOOTSTRAPPED:\n      case NOT_MOUNTED:\n        //  bootstrap  mount unload unload \n        if (!appShouldBeActive && getAppUnloadInfo(toName(app))) {\n          appsToUnload.push(app);\n        } else if (appShouldBeActive) {\n          //  bootstrap  mount mount \n          appsToMount.push(app);\n        }\n        break;\n      case MOUNTED:\n        //  mount unmount \n        if (!appShouldBeActive) {\n          appsToUnmount.push(app);\n        }\n        break;\n      // all other statuses are ignored\n    }\n  });\n\n  return { appsToUnload, appsToUnmount, appsToLoad, appsToMount };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n reroute load  load  load unmount  unload unmount   unmount\n\n\n\n// registered\nexport const NOT_LOADED = "NOT_LOADED";\n// load\nexport const LOADING_SOURCE_CODE = "LOADING_SOURCE_CODE";\nexport const NOT_BOOTSTRAPPED = "NOT_BOOTSTRAPPED";\n// bootstrap\nexport const BOOTSTRAPPING = "BOOTSTRAPPING";\nexport const NOT_MOUNTED = "NOT_MOUNTED";\n// mount\nexport const MOUNTING = "MOUNTING";\nexport const MOUNTED = "MOUNTED";\n// update\nexport const UPDATING = "UPDATING";\n// unmount\nexport const UNMOUNTING = "UNMOUNTING";\n// unload\nexport const UNLOADING = "UNLOADING";\n// error\nexport const LOAD_ERROR = "LOAD_ERROR";\nexport const SKIP_BECAUSE_BROKEN = "SKIP_BECAUSE_BROKEN";\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n\n\n# globalTimeoutConfig\n\nglobalTimeoutConfig \n\n// src/applications/timeouts.js\nconst globalTimeoutConfig = {\n  bootstrap: {\n    millis: 4000, // \n    dieOnTimeout: false, //  timeout \n    warningMillis: defaultWarningMillis, //  warning\n  },\n  mount: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis,\n  },\n  unmount: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis,\n  },\n  unload: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis,\n  },\n  update: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis,\n  },\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nsspa  timeout \n\nexport function setBootstrapMaxTime(time, dieOnTimeout, warningMillis) {\n  // \n  if (typeof time !== "number" || time <= 0) {\n    // ......\n  }\n\n  globalTimeoutConfig.bootstrap = {\n    millis: time,\n    dieOnTimeout,\n    warningMillis: warningMillis || defaultWarningMillis,\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n timeout  timeout \n\n\n# start\n\n               \nurlRerouteOnly   A boolean that defaults to false. If set to true, calls to\n                 history.pushState () and history.replaceState () will not\n                 trigger a single-spa reroute unless the client side route\n                 was changed. Setting this to true can be better for\n                 performance in some situations.  true history.pushState\n                  history.replaceState  reroute\n\n// src/start.js\nlet started = false;\nexport function start(opts) {\n  started = true;\n  if (opts && opts.urlRerouteOnly) {\n    //  urlRerouteOnly\n    setUrlRerouteOnly(opts.urlRerouteOnly);\n  }\n  if (isInBrowser) {\n    // \n    reroute();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n start \n\nMust be called by your single spa config. Before start is called, applications will be loaded, but will never be bootstrapped, mounted or unmounted. The reason for start is to give you control over the performance of your single page application.  Applications API | single-spa',normalizedContent:' single-spa  api api s-spa  registerunregisterunload  s-spa \n\n\n# \n\n\n\n * \n * registerapplication\n * unregisterapplication\n * unloadapplication\n * immediatelyunloadapp\n * getappnames\n * getmountedapps\n * getappstatus\n * checkactivityfunctions\n * pathtoactivewhen\n * todynamicpathvalidatorregex\n * getappchanges\n * globaltimeoutconfig\n * start\n\n\n\n src/applications/apps.js\n\n\n# registerapplication\n\nregisterapplication \n\n// src/applications/apps.js\nconst apps = [];\nexport const isinbrowser = typeof window !== "undefined";\nexport function registerapplication(\n  appnameorconfig,\n  apporloadapp,\n  activewhen,\n  customprops\n) {\n  // \n  const registration = sanitizearguments(\n    appnameorconfig,\n    apporloadapp,\n    activewhen,\n    customprops\n  );\n  // \n  if (getappnames().indexof(registration.name) !== -1)\n    throw error(\n      formaterrormessage(\n        21,\n        __dev__ &&\n          `there is already an app registered with name ${registration.name}`,\n        registration.name\n      )\n    );\n  // \n  apps.push(\n    assign(\n      {\n        loaderrortime: null,\n        status: not_loaded,\n        parcels: {},\n        devtools: {\n          overlays: {\n            options: {},\n            selectors: [],\n          },\n        },\n      },\n      registration\n    )\n  );\n\n  if (isinbrowser) {\n    //  jq \n    ensurejquerysupport();\n    // \n    reroute();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n 1. \n\nsanitizearguments  api \n\n 2. map  mapper\n\nexport function getappnames() {\n  return apps.map(toname);\n}\nexport function toname(app) {\n  return app.name;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n mapforeach  mapper \n\n 3. formaterrormessage\n\nexport function formaterrormessage(code, msg, ...args) {\n  return `single-spa minified message #${code}: ${\n    msg ? msg + " " : ""\n  }see https://single-spa.js.org/error/?code=${code}${\n    args.length ? `&arg=${args.join("&arg=")}` : ""\n  }`;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n code \n\n\n# unregisterapplication\n\nunregisterapplication \n\nexport function unregisterapplication(appname) {\n  // \n  if (apps.filter((app) => toname(app) === appname).length === 0) {\n    // ......\n  }\n\n  return unloadapplication(appname).then(() => {\n    // \n    const appindex = apps.map(toname).indexof(appname);\n    apps.splice(appindex, 1);\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# unloadapplication\n\nunloadapplication unload \n\nexport function unloadapplication(appname, opts = { waitforunmount: false }) {\n  // ......\n\n  const appunloadinfo = getappunloadinfo(toname(app));\n  //  unload  unmount unmount  unload\n  if (opts && opts.waitforunmount) {\n    // we need to wait for unmount before unloading the app\n    if (appunloadinfo) {\n      // someone else is already waiting for this, too\n      //  unload promise\n      return appunloadinfo.promise;\n    } else {\n      // we\'re the first ones wanting the app to be resolved.\n      //  unload  promisepromise  unload  resolve\n      const promise = new promise((resolve, reject) => {\n        addapptounload(app, () => promise, resolve, reject);\n      });\n      return promise;\n    }\n  } else {\n    /* we should unmount the app, unload it, and remount it immediately.*/\n    let resultpromise;\n    //  unmount unload \n    if (appunloadinfo) {\n      // someone else is already waiting for this app to unload\n      resultpromise = appunloadinfo.promise;\n      //   unload  unload unload promise.resolve \n      immediatelyunloadapp(app, appunloadinfo.resolve, appunloadinfo.reject);\n    } else {\n      // we\'re the first ones wanting the app to be resolved.\n      //  promise promise  unload  unload \n      resultpromise = new promise((resolve, reject) => {\n        addapptounload(app, () => resultpromise, resolve, reject);\n        immediatelyunloadapp(app, resolve, reject);\n      });\n    }\n    //  unload promise\n    return resultpromise;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n *  unmount  unload \n *  unload  unmount unload  unload  promise unload  promise  resolve unmount  unmount  unmount  unload \n *  unmount  unload\n\n\n# immediatelyunloadapp\n\n unload \n\n unloadapplication  waitforunmount  false  unload  unmount\n\nfunction immediatelyunloadapp(app, resolve, reject) {\n  tounmountpromise(app)\n    .then(tounloadpromise)\n    .then(() => {\n      resolve();\n      settimeout(() => {\n        // reroute, but the unload promise is done\n        //  unload \n        reroute();\n      });\n    })\n    .catch(reject);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n *  unload  unmount unload promise tounmountpromise unmount  promise tounloadpromise unload  promiseunload  resolve  unload  promise  async/await\n * tounloadpromise  tounmountpromise \n\n\n# getappnames\n\n\n\nexport function getappnames() {\n  return apps.map(toname);\n}\n\n\n1\n2\n3\n\n\n\n# getmountedapps\n\ngetmountedapps  mount \n\nexport function isactive(app) {\n  return app.status === mounted;\n}\nexport function getmountedapps() {\n  return apps.filter(isactive).map(toname);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# getappstatus\n\n\n\nexport function getappstatus(appname) {\n  const app = find(apps, (app) => toname(app) === appname);\n  return app ? app.status : null;\n}\n\n\n1\n2\n3\n4\n\n\n\n# checkactivityfunctions\n\n\n\nexport function checkactivityfunctions(location = window.location) {\n  return apps.filter((app) => app.activewhen(location)).map(toname);\n}\n\n\n1\n2\n3\n\n\n\n# pathtoactivewhen\n\n path string  activity functionactivewhen\n\nactivewhen  activityfunction path path activity function\n\nexport function pathtoactivewhen(path, exactmatch) {\n  //  path \n  const regex = todynamicpathvalidatorregex(path, exactmatch);\n  //  activity function\n  return (location) => {\n    // compatible with ie10\n    let origin = location.origin;\n    if (!origin) {\n      origin = `${location.protocol}//${location.host}`;\n    }\n    //  originsearch string\n    const route = location.href\n      .replace(origin, "")\n      .replace(location.search, "")\n      .split("?")[0];\n    return regex.test(route);\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n path \n\n\n# todynamicpathvalidatorregex\n\nfunction todynamicpathvalidatorregex(path, exactmatch) {\n  let lastindex = 0,\n    indynamic = false,\n    regexstr = "^";\n  // string  / \n  if (path[0] !== "/") {\n    path = "/" + path;\n  }\n  //  path\n  for (let charindex = 0; charindex < path.length; charindex++) {\n    const char = path[charindex];\n    const startofdynamic = !indynamic && char === ":";\n    const endofdynamic = indynamic && char === "/";\n    if (startofdynamic || endofdynamic) {\n      appendtoregex(charindex);\n    }\n  }\n\n  appendtoregex(path.length);\n  return new regexp(regexstr, "i");\n\n  function appendtoregex(index) {\n    const anycharmaybetrailingslashregex = "[^/]+/?";\n    const commonstringsubpath = escapestrregex(path.slice(lastindex, index));\n\n    regexstr += indynamic\n      ? anycharmaybetrailingslashregex\n      : commonstringsubpath;\n    // path  exactmatch \n    if (index === path.length) {\n      if (indynamic) {\n        if (exactmatch) {\n          // ensure exact match paths that end in a dynamic portion don\'t match\n          // urls with characters after a slash after the dynamic portion.\n          regexstr += "$";\n        }\n      } else {\n        // for exact matches, expect no more characters. otherwise, allow\n        // any characters.\n        const suffix = exactmatch ? "" : ".*";\n\n        regexstr =\n          // use charat instead as we could not use es6 method endswith\n          regexstr.charat(regexstr.length - 1) === "/"\n            ? `${regexstr}${suffix}$`\n            : `${regexstr}(/${suffix})?(#.*)?$`;\n      }\n    }\n\n    indynamic = !indynamic;\n    lastindex = index;\n  }\n  // escape \n  function escapestrregex(str) {\n    // borrowed from https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js\n    return str.replace(/[|\\\\{}()[\\]^$+*?.]/g, "\\\\$&");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n string  path \n\n\n# getappchanges\n\ngetappchanges getappchanges  appstounload , appstounmount , appstoload , appstomount \n\nexport function getappchanges() {\n  const appstounload = [],\n    appstounmount = [],\n    appstoload = [],\n    appstomount = [];\n\n  // we re-attempt to download applications in load_error after a timeout of 200 milliseconds\n  const currenttime = new date().gettime();\n  // \n  apps.foreach((app) => {\n    //  active\n    const appshouldbeactive =\n      app.status !== skip_because_broken && shouldbeactive(app);\n\n    switch (app.status) {\n      case load_error:\n        //  load  200 ms load \n        if (appshouldbeactive && currenttime - app.loaderrortime >= 200) {\n          appstoload.push(app);\n        }\n        break;\n      case not_loaded:\n      case loading_source_code:\n        //  load  load  load \n        if (appshouldbeactive) {\n          appstoload.push(app);\n        }\n        break;\n      case not_bootstrapped:\n      case not_mounted:\n        //  bootstrap  mount unload unload \n        if (!appshouldbeactive && getappunloadinfo(toname(app))) {\n          appstounload.push(app);\n        } else if (appshouldbeactive) {\n          //  bootstrap  mount mount \n          appstomount.push(app);\n        }\n        break;\n      case mounted:\n        //  mount unmount \n        if (!appshouldbeactive) {\n          appstounmount.push(app);\n        }\n        break;\n      // all other statuses are ignored\n    }\n  });\n\n  return { appstounload, appstounmount, appstoload, appstomount };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n reroute load  load  load unmount  unload unmount   unmount\n\n\n\n// registered\nexport const not_loaded = "not_loaded";\n// load\nexport const loading_source_code = "loading_source_code";\nexport const not_bootstrapped = "not_bootstrapped";\n// bootstrap\nexport const bootstrapping = "bootstrapping";\nexport const not_mounted = "not_mounted";\n// mount\nexport const mounting = "mounting";\nexport const mounted = "mounted";\n// update\nexport const updating = "updating";\n// unmount\nexport const unmounting = "unmounting";\n// unload\nexport const unloading = "unloading";\n// error\nexport const load_error = "load_error";\nexport const skip_because_broken = "skip_because_broken";\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n\n\n# globaltimeoutconfig\n\nglobaltimeoutconfig \n\n// src/applications/timeouts.js\nconst globaltimeoutconfig = {\n  bootstrap: {\n    millis: 4000, // \n    dieontimeout: false, //  timeout \n    warningmillis: defaultwarningmillis, //  warning\n  },\n  mount: {\n    millis: 3000,\n    dieontimeout: false,\n    warningmillis: defaultwarningmillis,\n  },\n  unmount: {\n    millis: 3000,\n    dieontimeout: false,\n    warningmillis: defaultwarningmillis,\n  },\n  unload: {\n    millis: 3000,\n    dieontimeout: false,\n    warningmillis: defaultwarningmillis,\n  },\n  update: {\n    millis: 3000,\n    dieontimeout: false,\n    warningmillis: defaultwarningmillis,\n  },\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nsspa  timeout \n\nexport function setbootstrapmaxtime(time, dieontimeout, warningmillis) {\n  // \n  if (typeof time !== "number" || time <= 0) {\n    // ......\n  }\n\n  globaltimeoutconfig.bootstrap = {\n    millis: time,\n    dieontimeout,\n    warningmillis: warningmillis || defaultwarningmillis,\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n timeout  timeout \n\n\n# start\n\n               \nurlrerouteonly   a boolean that defaults to false. if set to true, calls to\n                 history.pushstate () and history.replacestate () will not\n                 trigger a single-spa reroute unless the client side route\n                 was changed. setting this to true can be better for\n                 performance in some situations.  true history.pushstate\n                  history.replacestate  reroute\n\n// src/start.js\nlet started = false;\nexport function start(opts) {\n  started = true;\n  if (opts && opts.urlrerouteonly) {\n    //  urlrerouteonly\n    seturlrerouteonly(opts.urlrerouteonly);\n  }\n  if (isinbrowser) {\n    // \n    reroute();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n start \n\nmust be called by your single spa config. before start is called, applications will be loaded, but will never be bootstrapped, mounted or unmounted. the reason for start is to give you control over the performance of your single page application.  applications api | single-spa',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/single-spa/lifecycle/index/",categories:["single-spa"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/20.lifecycles%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/0.index.html",relativePath:"30.web/5.single-spa/20.lifecycles/0.index.md",key:"v-0b29f556",path:"/single-spa/lifecycle/index/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:118},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:245},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:496},{level:2,title:"Q&A",slug:"q-a",normalizedTitle:"q&amp;a",charIndex:null}],excerpt:"<p> single-spa  APIdevtool  API API   <code>registerApplication</code>   <code>unregisterApplication</code>  </p>\n<p> loadbootstrapmountupdateunmountunload  single-spa </p>\n",readingTime:{text:"1 min read",minutes:.205,time:12299.999999999998,words:41},headersStr:"   Q&A",content:" single-spa  APIdevtool  API API  registerApplication  unregisterApplication \n\n loadbootstrapmountupdateunmountunload  single-spa \n\n\n# \n\n\n# \n\ns-spa  s-spa qianKun \n\n qianKun  qiqnKun  JavaScript css prefech hooks \n\n\n# \n\n\n# Q&A",normalizedContent:" single-spa  apidevtool  api api  registerapplication  unregisterapplication \n\n loadbootstrapmountupdateunmountunload  single-spa \n\n\n# \n\n\n# \n\ns-spa  s-spa qiankun \n\n qiankun  qiqnkun  javascript css prefech hooks \n\n\n# \n\n\n# q&a",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"load  unload",frontmatter:{title:"load  unload",date:"2022-04-15T13:41:48.000Z",permalink:"/single-spa/lifecycle/load/",categories:["single-spa","lifecycles"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/20.lifecycles%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/10.load.html",relativePath:"30.web/5.single-spa/20.lifecycles/10.load.md",key:"v-70bd8ed4",path:"/single-spa/lifecycle/load/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:180},{level:2,title:"app ",slug:"app-",normalizedTitle:"app ",charIndex:195},{level:2,title:"toLoadPromise",slug:"toloadpromise",normalizedTitle:"toloadpromise",charIndex:207},{level:2,title:"smellsLikeAPromise",slug:"smellslikeapromise",normalizedTitle:"smellslikeapromise",charIndex:224},{level:2,title:"flattenFnArray",slug:"flattenfnarray",normalizedTitle:"flattenfnarray",charIndex:246},{level:2,title:"toUnloadPromise",slug:"tounloadpromise",normalizedTitle:"tounloadpromise",charIndex:264}],excerpt:"<TimeToRead />\n<p> single-spa  load  unload  single-spa  load  bootstrapmount  load unload  unmount  unregister </p>\n",readingTime:{text:"6 min read",minutes:5.39,time:323400,words:1078},headersStr:" app  toLoadPromise smellsLikeAPromise flattenFnArray toUnloadPromise",content:' single-spa  load  unload  single-spa  load  bootstrapmount  load unload  unmount  unregister \n\n\n# \n\n\n\n * \n * app \n * toLoadPromise\n * smellsLikeAPromise\n * flattenFnArray\n * toUnloadPromise\n\n\n\n\n# app \n\n object  toLoadPromise  app  s-spa  typescript  app \n\n              \nname            App name that single-spa will register and reference this\n                application with, and will be labelled with in dev tools.\nloadApp         Application object or a function that returns the resolved\n                application (Promise or not)\nactiveWhen      Can be a path prefix which will match every URL starting\n                with this path, an activity function (as described in the\n                simple arguments) or an array containing both of them.\ncustomProps     Will be passed to the application during each lifecycle\n                method.\nloadErrorTime    load \nloadPromise      load  promise\nstatus          \nparcels         \ndevtools        devtools \n\n\n\n\n\n\n# toLoadPromise\n\n:\n\nfunction toLoadPromise(app) {\n  // P0\n  return Promise.resolve().then(() => {\n    // ......\n    // P1\n    return (app.loadPromise = Promise.resolve().then(() => {\n      // ......\n      // P2\n      return app;\n    })).catch(err => {\n      // ......\n      // P3\n      return app;\n    } )\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nPromise qiankun: loadApp \n\n * P0 Promise.resolve().then  return Promise<app> \n * P1P1  P0 \n * P2/P3P2/P3  Promise<app> \n\nMDNPromise.resolve()\n\nThis function flattens nested layers of promise-like objects (e.g. a promise that resolves to a promise that resolves to something) into a single layer.\n\nPromise.resolve()  Promise  flat Promise.resolve  Promise<app>  toLoadPromise Promise<app>  Promise Promise 30  React \n\n reroute  performAppChanges \n\n\n\nexport function toLoadPromise(app) {\n  // load app  loadPromisePromise.resolve()  promise \n  return Promise.resolve().then(() => {\n    //  loadPromise  loadPromise load \n    if (app.loadPromise) {\n      return app.loadPromise;\n    }\n    // app.status  NOT_LOADED  LOAD_ERROR\n    if (app.status !== NOT_LOADED && app.status !== LOAD_ERROR) {\n      return app;\n    }\n    //  LOADING_SOURCE_CODE LOADING_SOURCE_CODE \n    //  load \n    //  qiankun  prefecth  \n    app.status = LOADING_SOURCE_CODE;\n\n    let appOpts, isUserErr;\n    //  loadPromise  app \n    return (app.loadPromise = Promise.resolve()\n      .then(() => {\n        // load app promise loadApp \n        const loadPromise = app.loadApp(getProps(app));\n        //  promise promise \n        //  registerMicroApps  app   async \n        if (!smellsLikeAPromise(loadPromise)) {\n          isUserErr = true;\n          // throw Error() ......\n        }\n        return loadPromise.then((val) => {\n          app.loadErrorTime = null;\n\n          appOpts = val;\n\n          let validationErrMessage, validationErrCode;\n          // loadPromise  object\n          if (typeof appOpts !== "object") {\n            validationErrCode = 34;\n          }\n          //  bootstrap \n          if (\n            // ES Modules don\'t have the Object prototype\n            Object.prototype.hasOwnProperty.call(appOpts, "bootstrap") &&\n            !validLifecycleFn(appOpts.bootstrap)\n          ) {\n            validationErrCode = 35;\n          }\n          // mount \n          if (!validLifecycleFn(appOpts.mount)) {\n            validationErrCode = 36;\n          }\n          // unmount \n          if (!validLifecycleFn(appOpts.unmount)) {\n            validationErrCode = 37;\n          }\n          //  app  parcel  application appOpts.unmountThisParcel \n          const type = objectType(appOpts);\n\n          if (validationErrCode) {\n            // ......\n            handleAppError(validationErrMessage, app, SKIP_BECAUSE_BROKEN);\n            return app;\n          }\n\n          //  LOADING_SOURCE_CODE  NOT_BOOTSTRAPPED\n          app.status = NOT_BOOTSTRAPPED;\n          //  bootstrap   promise reduce pipeline\n          //  promise reduce pipeline\n          app.bootstrap = flattenFnArray(appOpts, "bootstrap");\n          app.mount = flattenFnArray(appOpts, "mount");\n          app.unmount = flattenFnArray(appOpts, "unmount");\n          app.unload = flattenFnArray(appOpts, "unload");\n          //  timeouts \n          app.timeouts = ensureValidAppTimeouts(appOpts.timeouts);\n          // load  app.loadPromise  app.loadPromise \n          delete app.loadPromise;\n\n          return app;\n        });\n      })\n      .catch((err) => {\n        delete app.loadPromise;\n\n        let newStatus;\n        //  SKIP_BECAUSE_BROKEN LOAD_ERROR\n        if (isUserErr) {\n          newStatus = SKIP_BECAUSE_BROKEN;\n        } else {\n          newStatus = LOAD_ERROR;\n          app.loadErrorTime = new Date().getTime();\n        }\n        // \n        handleAppError(err, app, newStatus);\n\n        return app;\n      }));\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n\n\n\n\n *  loadPromise  Promise<app> mount  load \n * load  app.loadApp  load  reduce pipeline\n *  LOADING_SOURCE_CODE  app.loadPromise  app.status   NOT_BOOTSTRAPPED \n\n\n\n * Applications API | single-spa | registerApplication\n * Promise.resolve() - JavaScript | MDN\n\n\n# smellsLikeAPromise\n\n Promise\n\nexport function smellsLikeAPromise(promise) {\n  return (\n    promise &&\n    typeof promise.then === "function" &&\n    typeof promise.catch === "function"\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n p instanceof Promise Vue3  promise instanceof  instanceof  ES6  Promise Promise polyfill  Promise ES \n\n\n# flattenFnArray\n\nexport function flattenFnArray(appOrParcel, lifecycle) {\n  let fns = appOrParcel[lifecycle] || [];\n  fns = Array.isArray(fns) ? fns : [fns];\n  if (fns.length === 0) {\n    fns = [() => Promise.resolve()];\n  }\n\n  const type = objectType(appOrParcel);\n  const name = toName(appOrParcel);\n\n  return function (props) {\n    // promise reduce pipeline\n    //  promise \n    return fns.reduce((resultPromise, fn, index) => {\n      return resultPromise.then(() => {\n        const thisPromise = fn(props);\n        return smellsLikeAPromise(thisPromise)\n          ? thisPromise\n          : Promise.reject(/** ...... **/)\n      });\n    }, Promise.resolve());\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n promise\n\n reduce pipeline qiankun: loadApp \n\n\n# toUnloadPromise\n\ntoUnloadPromise \n\nexport function toUnloadPromise(app) {\n  return Promise.resolve().then(() => {\n    const unloadInfo = appsToUnload[toName(app)];\n    //  unload  unloadApplication \n    if (!unloadInfo) {\n      /* No one has called unloadApplication for this app,\n       */\n      return app;\n    }\n    //  NOT_LOADED finishUnloadingApp\n    if (app.status === NOT_LOADED) {\n      /* This app is already unloaded. We just need to clean up\n       * anything that still thinks we need to unload the app.\n       */\n      finishUnloadingApp(app, unloadInfo);\n      return app;\n    }\n    //  unloadApplication  reroute  unload \n    //  unload \n    if (app.status === UNLOADING) {\n      /* Both unloadApplication and reroute want to unload this app.\n       * It only needs to be done once, though.\n       */\n      return unloadInfo.promise.then(() => app);\n    }\n    //  NOT_MOUNTED  LOAD_ERROR unload\n    //  unmount  NOT_MOUNTED  unload \n    if (app.status !== NOT_MOUNTED && app.status !== LOAD_ERROR) {\n      /* The app cannot be unloaded until it is unmounted.\n       */\n      return app;\n    }\n\n    const unloadPromise =\n      app.status === LOAD_ERROR\n        ? Promise.resolve()\n        : reasonableTime(app, "unload");\n\n    app.status = UNLOADING;\n    //  LOAD_ERROR  unload \n    return unloadPromise\n      .then(() => {\n        //  finishUnloadingApp\n        finishUnloadingApp(app, unloadInfo);\n        return app;\n      })\n      .catch((err) => {\n        errorUnloadingApp(app, unloadInfo, err);\n        return app;\n      });\n  });\n}\n\nfunction finishUnloadingApp(app, unloadInfo) {\n  //  unload \n  delete appsToUnload[toName(app)];\n  // \n  // Unloaded apps don\'t have lifecycles\n  delete app.bootstrap;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n  //  NOT_LOADED\n  app.status = NOT_LOADED;\n  //  resolve unloadInfo promise unload \n  /* resolve the promise of whoever called unloadApplication.\n   * This should be done after all other cleanup/bookkeeping\n   */\n  unloadInfo.resolve();\n}\n\nfunction errorUnloadingApp(app, unloadInfo, err) {\n  delete appsToUnload[toName(app)];\n\n  // Unloaded apps don\'t have lifecycles\n  delete app.bootstrap;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n\n  handleAppError(err, app, SKIP_BECAUSE_BROKEN);\n  //  reject \n  unloadInfo.reject(err);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n\n\n unload  unloadApplication  reroute  unload \n\n:\n\n *  unload  unload\n *  unload  promise  resolve  reject',normalizedContent:' single-spa  load  unload  single-spa  load  bootstrapmount  load unload  unmount  unregister \n\n\n# \n\n\n\n * \n * app \n * toloadpromise\n * smellslikeapromise\n * flattenfnarray\n * tounloadpromise\n\n\n\n\n# app \n\n object  toloadpromise  app  s-spa  typescript  app \n\n              \nname            app name that single-spa will register and reference this\n                application with, and will be labelled with in dev tools.\nloadapp         application object or a function that returns the resolved\n                application (promise or not)\nactivewhen      can be a path prefix which will match every url starting\n                with this path, an activity function (as described in the\n                simple arguments) or an array containing both of them.\ncustomprops     will be passed to the application during each lifecycle\n                method.\nloaderrortime    load \nloadpromise      load  promise\nstatus          \nparcels         \ndevtools        devtools \n\n\n\n\n\n\n# toloadpromise\n\n:\n\nfunction toloadpromise(app) {\n  // p0\n  return promise.resolve().then(() => {\n    // ......\n    // p1\n    return (app.loadpromise = promise.resolve().then(() => {\n      // ......\n      // p2\n      return app;\n    })).catch(err => {\n      // ......\n      // p3\n      return app;\n    } )\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\npromise qiankun: loadapp \n\n * p0 promise.resolve().then  return promise<app> \n * p1p1  p0 \n * p2/p3p2/p3  promise<app> \n\nmdnpromise.resolve()\n\nthis function flattens nested layers of promise-like objects (e.g. a promise that resolves to a promise that resolves to something) into a single layer.\n\npromise.resolve()  promise  flat promise.resolve  promise<app>  toloadpromise promise<app>  promise promise 30  react \n\n reroute  performappchanges \n\n\n\nexport function toloadpromise(app) {\n  // load app  loadpromisepromise.resolve()  promise \n  return promise.resolve().then(() => {\n    //  loadpromise  loadpromise load \n    if (app.loadpromise) {\n      return app.loadpromise;\n    }\n    // app.status  not_loaded  load_error\n    if (app.status !== not_loaded && app.status !== load_error) {\n      return app;\n    }\n    //  loading_source_code loading_source_code \n    //  load \n    //  qiankun  prefecth  \n    app.status = loading_source_code;\n\n    let appopts, isusererr;\n    //  loadpromise  app \n    return (app.loadpromise = promise.resolve()\n      .then(() => {\n        // load app promise loadapp \n        const loadpromise = app.loadapp(getprops(app));\n        //  promise promise \n        //  registermicroapps  app   async \n        if (!smellslikeapromise(loadpromise)) {\n          isusererr = true;\n          // throw error() ......\n        }\n        return loadpromise.then((val) => {\n          app.loaderrortime = null;\n\n          appopts = val;\n\n          let validationerrmessage, validationerrcode;\n          // loadpromise  object\n          if (typeof appopts !== "object") {\n            validationerrcode = 34;\n          }\n          //  bootstrap \n          if (\n            // es modules don\'t have the object prototype\n            object.prototype.hasownproperty.call(appopts, "bootstrap") &&\n            !validlifecyclefn(appopts.bootstrap)\n          ) {\n            validationerrcode = 35;\n          }\n          // mount \n          if (!validlifecyclefn(appopts.mount)) {\n            validationerrcode = 36;\n          }\n          // unmount \n          if (!validlifecyclefn(appopts.unmount)) {\n            validationerrcode = 37;\n          }\n          //  app  parcel  application appopts.unmountthisparcel \n          const type = objecttype(appopts);\n\n          if (validationerrcode) {\n            // ......\n            handleapperror(validationerrmessage, app, skip_because_broken);\n            return app;\n          }\n\n          //  loading_source_code  not_bootstrapped\n          app.status = not_bootstrapped;\n          //  bootstrap   promise reduce pipeline\n          //  promise reduce pipeline\n          app.bootstrap = flattenfnarray(appopts, "bootstrap");\n          app.mount = flattenfnarray(appopts, "mount");\n          app.unmount = flattenfnarray(appopts, "unmount");\n          app.unload = flattenfnarray(appopts, "unload");\n          //  timeouts \n          app.timeouts = ensurevalidapptimeouts(appopts.timeouts);\n          // load  app.loadpromise  app.loadpromise \n          delete app.loadpromise;\n\n          return app;\n        });\n      })\n      .catch((err) => {\n        delete app.loadpromise;\n\n        let newstatus;\n        //  skip_because_broken load_error\n        if (isusererr) {\n          newstatus = skip_because_broken;\n        } else {\n          newstatus = load_error;\n          app.loaderrortime = new date().gettime();\n        }\n        // \n        handleapperror(err, app, newstatus);\n\n        return app;\n      }));\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n\n\n\n\n *  loadpromise  promise<app> mount  load \n * load  app.loadapp  load  reduce pipeline\n *  loading_source_code  app.loadpromise  app.status   not_bootstrapped \n\n\n\n * applications api | single-spa | registerapplication\n * promise.resolve() - javascript | mdn\n\n\n# smellslikeapromise\n\n promise\n\nexport function smellslikeapromise(promise) {\n  return (\n    promise &&\n    typeof promise.then === "function" &&\n    typeof promise.catch === "function"\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n p instanceof promise vue3  promise instanceof  instanceof  es6  promise promise polyfill  promise es \n\n\n# flattenfnarray\n\nexport function flattenfnarray(apporparcel, lifecycle) {\n  let fns = apporparcel[lifecycle] || [];\n  fns = array.isarray(fns) ? fns : [fns];\n  if (fns.length === 0) {\n    fns = [() => promise.resolve()];\n  }\n\n  const type = objecttype(apporparcel);\n  const name = toname(apporparcel);\n\n  return function (props) {\n    // promise reduce pipeline\n    //  promise \n    return fns.reduce((resultpromise, fn, index) => {\n      return resultpromise.then(() => {\n        const thispromise = fn(props);\n        return smellslikeapromise(thispromise)\n          ? thispromise\n          : promise.reject(/** ...... **/)\n      });\n    }, promise.resolve());\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n promise\n\n reduce pipeline qiankun: loadapp \n\n\n# tounloadpromise\n\ntounloadpromise \n\nexport function tounloadpromise(app) {\n  return promise.resolve().then(() => {\n    const unloadinfo = appstounload[toname(app)];\n    //  unload  unloadapplication \n    if (!unloadinfo) {\n      /* no one has called unloadapplication for this app,\n       */\n      return app;\n    }\n    //  not_loaded finishunloadingapp\n    if (app.status === not_loaded) {\n      /* this app is already unloaded. we just need to clean up\n       * anything that still thinks we need to unload the app.\n       */\n      finishunloadingapp(app, unloadinfo);\n      return app;\n    }\n    //  unloadapplication  reroute  unload \n    //  unload \n    if (app.status === unloading) {\n      /* both unloadapplication and reroute want to unload this app.\n       * it only needs to be done once, though.\n       */\n      return unloadinfo.promise.then(() => app);\n    }\n    //  not_mounted  load_error unload\n    //  unmount  not_mounted  unload \n    if (app.status !== not_mounted && app.status !== load_error) {\n      /* the app cannot be unloaded until it is unmounted.\n       */\n      return app;\n    }\n\n    const unloadpromise =\n      app.status === load_error\n        ? promise.resolve()\n        : reasonabletime(app, "unload");\n\n    app.status = unloading;\n    //  load_error  unload \n    return unloadpromise\n      .then(() => {\n        //  finishunloadingapp\n        finishunloadingapp(app, unloadinfo);\n        return app;\n      })\n      .catch((err) => {\n        errorunloadingapp(app, unloadinfo, err);\n        return app;\n      });\n  });\n}\n\nfunction finishunloadingapp(app, unloadinfo) {\n  //  unload \n  delete appstounload[toname(app)];\n  // \n  // unloaded apps don\'t have lifecycles\n  delete app.bootstrap;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n  //  not_loaded\n  app.status = not_loaded;\n  //  resolve unloadinfo promise unload \n  /* resolve the promise of whoever called unloadapplication.\n   * this should be done after all other cleanup/bookkeeping\n   */\n  unloadinfo.resolve();\n}\n\nfunction errorunloadingapp(app, unloadinfo, err) {\n  delete appstounload[toname(app)];\n\n  // unloaded apps don\'t have lifecycles\n  delete app.bootstrap;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n\n  handleapperror(err, app, skip_because_broken);\n  //  reject \n  unloadinfo.reject(err);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n\n\n unload  unloadapplication  reroute  unload \n\n:\n\n *  unload  unload\n *  unload  promise  resolve  reject',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"bootstrap",frontmatter:{title:"bootstrap",date:"2022-04-18T14:20:39.000Z",permalink:"/single-spa/lifecycle/bootstrap/",categories:["single-spa","lifecycles"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/20.lifecycles%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/20.bootstrap.html",relativePath:"30.web/5.single-spa/20.lifecycles/20.bootstrap.md",key:"v-5cc090d4",path:"/single-spa/lifecycle/bootstrap/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:167},{level:2,title:"toBootstrapPromise",slug:"tobootstrappromise",normalizedTitle:"tobootstrappromise",charIndex:182},{level:2,title:"reasonableTime",slug:"reasonabletime",normalizedTitle:"reasonabletime",charIndex:204}],excerpt:"<TimeToRead />\n<p> single-spa  bootstrap  single-spa  bootstrap  load mount bootstrap  bootstrap bootstrap   <code>beforeMount</code>  </p>\n",readingTime:{text:"2 min read",minutes:1.66,time:99600,words:332},headersStr:" toBootstrapPromise reasonableTime",content:" single-spa  bootstrap  single-spa  bootstrap  load mount bootstrap  bootstrap bootstrap  beforeMount \n\n\n# \n\n\n\n * \n * toBootstrapPromise\n * reasonableTime\n\n\n\n\n# toBootstrapPromise\n\n\n\nexport function toBootstrapPromise(appOrParcel, hardFail) {\n  return Promise.resolve().then(() => {\n    if (appOrParcel.status !== NOT_BOOTSTRAPPED) {\n      return appOrParcel;\n    }\n    //  BOOTSTRAPPING\n    appOrParcel.status = BOOTSTRAPPING;\n    //  bootstrap \n    if (!appOrParcel.bootstrap) {\n      // Default implementation of bootstrap\n      return Promise.resolve().then(successfulBootstrap);\n    }\n    //  timeout \n    return reasonableTime(appOrParcel, \"bootstrap\")\n      .then(successfulBootstrap)\n      .catch((err) => {\n        if (hardFail) {\n          throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n        } else {\n          handleAppError(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n          return appOrParcel;\n        }\n      });\n  });\n\n  function successfulBootstrap() {\n    appOrParcel.status = NOT_MOUNTED;\n    return appOrParcel;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\ntoBootstrapPromise \n\n *  bootstrap \n *  app.status  BOOTSTRAPPING SKIP_BECAUSE_BROKEN NOT_MOUNTED\n\n\n# reasonableTime\n\n timeout  promise\n\napp.timeouts  load \n\nexport function reasonableTime(appOrParcel, lifecycle) {\n  //  timeouts \n  const timeoutConfig = appOrParcel.timeouts[lifecycle];\n  const warningPeriod = timeoutConfig.warningMillis;\n  // \n  const type = objectType(appOrParcel);\n\n  return new Promise((resolve, reject) => {\n    let finished = false;\n    let errored = false;\n    //  load  reduce pipeline\n    //  setTimeout \n    //  warningPeriod  timeoutConfig.millis\n    appOrParcel[lifecycle](getProps(appOrParcel))\n      .then((val) => {\n        //  resolve\n        finished = true;\n        resolve(val);\n      })\n      .catch((val) => {\n        finished = true;\n        reject(val);\n      });\n    //  warningPeriod  warning\n    setTimeout(() => maybeTimingOut(1), warningPeriod);\n    //  timeoutConfig.millis \n    setTimeout(() => maybeTimingOut(true), timeoutConfig.millis);\n\n    const errMsg = formatErrorMessage(\n      // ......\n    );\n\n    function maybeTimingOut(shouldError) {\n      //  finished  warning  stop\n      if (!finished) {\n        if (shouldError === true) {\n          errored = true;\n          //  dieOnTimeout reject \n          if (timeoutConfig.dieOnTimeout) {\n            reject(Error(errMsg));\n          } else {\n            // \n            console.error(errMsg);\n            //don't resolve or reject, we're waiting this one out\n          }\n        } else if (!errored) {\n          // shouldError  waning \n          const numWarnings = shouldError;\n          // \n          const numMillis = numWarnings * warningPeriod;\n          console.warn(errMsg);\n          //  waning finished\n          if (numMillis + warningPeriod < timeoutConfig.millis) {\n            setTimeout(() => maybeTimingOut(numWarnings + 1), warningPeriod);\n          }\n        }\n      }\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n\n promise  React \n\n promise \n\nmaybeTimingOut ",normalizedContent:" single-spa  bootstrap  single-spa  bootstrap  load mount bootstrap  bootstrap bootstrap  beforemount \n\n\n# \n\n\n\n * \n * tobootstrappromise\n * reasonabletime\n\n\n\n\n# tobootstrappromise\n\n\n\nexport function tobootstrappromise(apporparcel, hardfail) {\n  return promise.resolve().then(() => {\n    if (apporparcel.status !== not_bootstrapped) {\n      return apporparcel;\n    }\n    //  bootstrapping\n    apporparcel.status = bootstrapping;\n    //  bootstrap \n    if (!apporparcel.bootstrap) {\n      // default implementation of bootstrap\n      return promise.resolve().then(successfulbootstrap);\n    }\n    //  timeout \n    return reasonabletime(apporparcel, \"bootstrap\")\n      .then(successfulbootstrap)\n      .catch((err) => {\n        if (hardfail) {\n          throw transformerr(err, apporparcel, skip_because_broken);\n        } else {\n          handleapperror(err, apporparcel, skip_because_broken);\n          return apporparcel;\n        }\n      });\n  });\n\n  function successfulbootstrap() {\n    apporparcel.status = not_mounted;\n    return apporparcel;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\ntobootstrappromise \n\n *  bootstrap \n *  app.status  bootstrapping skip_because_broken not_mounted\n\n\n# reasonabletime\n\n timeout  promise\n\napp.timeouts  load \n\nexport function reasonabletime(apporparcel, lifecycle) {\n  //  timeouts \n  const timeoutconfig = apporparcel.timeouts[lifecycle];\n  const warningperiod = timeoutconfig.warningmillis;\n  // \n  const type = objecttype(apporparcel);\n\n  return new promise((resolve, reject) => {\n    let finished = false;\n    let errored = false;\n    //  load  reduce pipeline\n    //  settimeout \n    //  warningperiod  timeoutconfig.millis\n    apporparcel[lifecycle](getprops(apporparcel))\n      .then((val) => {\n        //  resolve\n        finished = true;\n        resolve(val);\n      })\n      .catch((val) => {\n        finished = true;\n        reject(val);\n      });\n    //  warningperiod  warning\n    settimeout(() => maybetimingout(1), warningperiod);\n    //  timeoutconfig.millis \n    settimeout(() => maybetimingout(true), timeoutconfig.millis);\n\n    const errmsg = formaterrormessage(\n      // ......\n    );\n\n    function maybetimingout(shoulderror) {\n      //  finished  warning  stop\n      if (!finished) {\n        if (shoulderror === true) {\n          errored = true;\n          //  dieontimeout reject \n          if (timeoutconfig.dieontimeout) {\n            reject(error(errmsg));\n          } else {\n            // \n            console.error(errmsg);\n            //don't resolve or reject, we're waiting this one out\n          }\n        } else if (!errored) {\n          // shoulderror  waning \n          const numwarnings = shoulderror;\n          // \n          const nummillis = numwarnings * warningperiod;\n          console.warn(errmsg);\n          //  waning finished\n          if (nummillis + warningperiod < timeoutconfig.millis) {\n            settimeout(() => maybetimingout(numwarnings + 1), warningperiod);\n          }\n        }\n      }\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n\n promise  react \n\n promise \n\nmaybetimingout ",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"mount  unmount",frontmatter:{title:"mount  unmount",date:"2022-04-18T15:22:01.000Z",permalink:"/single-spa/lifecycle/mount/",categories:["single-spa","lifecycles"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/20.lifecycles%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/30.mount.html",relativePath:"30.web/5.single-spa/20.lifecycles/30.mount.md",key:"v-4dfd12d8",path:"/single-spa/lifecycle/mount/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:172},{level:2,title:"toMountPromise",slug:"tomountpromise",normalizedTitle:"tomountpromise",charIndex:187},{level:2,title:"toUnmountPromise",slug:"tounmountpromise",normalizedTitle:"tounmountpromise",charIndex:205}],excerpt:"<TimeToRead />\n<p> single-spa  mount  unmount  single-spa  mount  update bootstrap mount  mount unmount  unmount app  app.parcels</p>\n",readingTime:{text:"3 min read",minutes:2.53,time:151799.99999999997,words:506},headersStr:" toMountPromise toUnmountPromise",content:' single-spa  mount  unmount  single-spa  mount  update bootstrap mount  mount unmount  unmount app  app.parcels\n\n\n# \n\n\n\n * \n * toMountPromise\n * toUnmountPromise\n\n\n\n\n# toMountPromise\n\ntoMountPromise  mount \n\nexport function toMountPromise(appOrParcel, hardFail) {\n  return Promise.resolve().then(() => {\n    //  NOT_MOUNTED\n    if (appOrParcel.status !== NOT_MOUNTED) {\n      return appOrParcel;\n    }\n    //  mount dispatch before-first-mount \n    if (!beforeFirstMountFired) {\n      window.dispatchEvent(new CustomEvent("single-spa:before-first-mount"));\n      beforeFirstMountFired = true;\n    }\n\n    return reasonableTime(appOrParcel, "mount")\n      .then(() => {\n        // mount  MOUNTED\n        appOrParcel.status = MOUNTED;\n        //  mount dispatch first-mount \n        if (!firstMountFired) {\n          window.dispatchEvent(new CustomEvent("single-spa:first-mount"));\n          firstMountFired = true;\n        }\n\n        return appOrParcel;\n      })\n      .catch((err) => {\n        // If we fail to mount the appOrParcel, we should attempt to unmount it before putting in SKIP_BECAUSE_BROKEN\n        // We temporarily put the appOrParcel into MOUNTED status so that toUnmountPromise actually attempts to unmount it\n        // instead of just doing a no-op.\n        //  mount  unmount\n        //  MOUNTED toUnmountPromise  unmount\n        appOrParcel.status = MOUNTED;\n        return toUnmountPromise(appOrParcel, true).then(\n          setSkipBecauseBroken,\n          setSkipBecauseBroken\n        );\n\n        function setSkipBecauseBroken() {\n          if (!hardFail) {\n            handleAppError(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n            return appOrParcel;\n          } else {\n            throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n          }\n        }\n      });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n\n *  mount  MOUNTED\n *  mount  unmount \n * dispatch before-first-mount  first-mount \n\n\n\ndescribe(`single-spa:first-mount events`, () => {\n  it(`fires first-mount exactly once when the first app is mounted`, () => {\n    singleSpa.registerApplication("firstMount", dummyApp, () => {\n      return window.location.hash.indexOf("#/firstMount") === 0;\n    });\n    singleSpa.start();\n    let numFirstMounts = 0,\n      numBeforeFirstMounts = 0;\n\n    window.addEventListener("single-spa:first-mount", () => {\n      numBeforeFirstMounts++;\n    });\n\n    window.addEventListener("single-spa:first-mount", () => {\n      numFirstMounts++;\n    });\n\n    window.location.hash = `#/firstMount`;\n\n    return singleSpa\n      .triggerAppChange()\n      .then(() => {\n        // Unmount\n        window.location.hash = `#/`;\n        return singleSpa.triggerAppChange();\n      })\n      .then(() => {\n        // Remount (shouldn\'t trigger an event)\n        window.location.hash = `#/firstMount`;\n        return singleSpa.triggerAppChange();\n      })\n      .then(() => {\n        expect(numBeforeFirstMounts).toBe(1);\n        expect(numFirstMounts).toBe(1);\n      });\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# toUnmountPromise\n\ntoUnmountPromise  unmount \n\nexport function toUnmountPromise(appOrParcel, hardFail) {\n  return Promise.resolve().then(() => {\n    // app.status  MOUNTED\n    if (appOrParcel.status !== MOUNTED) {\n      return appOrParcel;\n    }\n    //  app.status  UNMOUNTING\n    appOrParcel.status = UNMOUNTING;\n    //  parcel parcel  unmount  parcel  unmount \n    const unmountChildrenParcels = Object.keys(\n      appOrParcel.parcels\n    ).map((parcelId) => appOrParcel.parcels[parcelId].unmountThisParcel());\n\n    let parcelError;\n\n    return Promise.all(unmountChildrenParcels)\n      .then(unmountAppOrParcel, (parcelError) => {\n        // There is a parcel unmount error\n        return unmountAppOrParcel().then(() => {\n          // Unmounting the app/parcel succeeded, but unmounting its children parcels did not\n          const parentError = Error(parcelError.message);\n          if (hardFail) {\n            throw transformErr(parentError, appOrParcel, SKIP_BECAUSE_BROKEN);\n          } else {\n            handleAppError(parentError, appOrParcel, SKIP_BECAUSE_BROKEN);\n          }\n        });\n      })\n      .then(() => appOrParcel);\n    //  app unmount \n    function unmountAppOrParcel() {\n      // We always try to unmount the appOrParcel, even if the children parcels failed to unmount.\n      return reasonableTime(appOrParcel, "unmount")\n        .then(() => {\n          // The appOrParcel needs to stay in a broken status if its children parcels fail to unmount\n          if (!parcelError) {\n            //  app  app.parcels  unmount NOT_MOUNTED\n            appOrParcel.status = NOT_MOUNTED;\n          }\n        })\n        .catch((err) => {\n          if (hardFail) {\n            throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n          } else {\n            handleAppError(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n          }\n        });\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n * unmount  UNMOUNTING NOT_MOUNTED SKIP_BECAUSE_BROKEN\n * unmount application  parcel  umount',normalizedContent:' single-spa  mount  unmount  single-spa  mount  update bootstrap mount  mount unmount  unmount app  app.parcels\n\n\n# \n\n\n\n * \n * tomountpromise\n * tounmountpromise\n\n\n\n\n# tomountpromise\n\ntomountpromise  mount \n\nexport function tomountpromise(apporparcel, hardfail) {\n  return promise.resolve().then(() => {\n    //  not_mounted\n    if (apporparcel.status !== not_mounted) {\n      return apporparcel;\n    }\n    //  mount dispatch before-first-mount \n    if (!beforefirstmountfired) {\n      window.dispatchevent(new customevent("single-spa:before-first-mount"));\n      beforefirstmountfired = true;\n    }\n\n    return reasonabletime(apporparcel, "mount")\n      .then(() => {\n        // mount  mounted\n        apporparcel.status = mounted;\n        //  mount dispatch first-mount \n        if (!firstmountfired) {\n          window.dispatchevent(new customevent("single-spa:first-mount"));\n          firstmountfired = true;\n        }\n\n        return apporparcel;\n      })\n      .catch((err) => {\n        // if we fail to mount the apporparcel, we should attempt to unmount it before putting in skip_because_broken\n        // we temporarily put the apporparcel into mounted status so that tounmountpromise actually attempts to unmount it\n        // instead of just doing a no-op.\n        //  mount  unmount\n        //  mounted tounmountpromise  unmount\n        apporparcel.status = mounted;\n        return tounmountpromise(apporparcel, true).then(\n          setskipbecausebroken,\n          setskipbecausebroken\n        );\n\n        function setskipbecausebroken() {\n          if (!hardfail) {\n            handleapperror(err, apporparcel, skip_because_broken);\n            return apporparcel;\n          } else {\n            throw transformerr(err, apporparcel, skip_because_broken);\n          }\n        }\n      });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n\n *  mount  mounted\n *  mount  unmount \n * dispatch before-first-mount  first-mount \n\n\n\ndescribe(`single-spa:first-mount events`, () => {\n  it(`fires first-mount exactly once when the first app is mounted`, () => {\n    singlespa.registerapplication("firstmount", dummyapp, () => {\n      return window.location.hash.indexof("#/firstmount") === 0;\n    });\n    singlespa.start();\n    let numfirstmounts = 0,\n      numbeforefirstmounts = 0;\n\n    window.addeventlistener("single-spa:first-mount", () => {\n      numbeforefirstmounts++;\n    });\n\n    window.addeventlistener("single-spa:first-mount", () => {\n      numfirstmounts++;\n    });\n\n    window.location.hash = `#/firstmount`;\n\n    return singlespa\n      .triggerappchange()\n      .then(() => {\n        // unmount\n        window.location.hash = `#/`;\n        return singlespa.triggerappchange();\n      })\n      .then(() => {\n        // remount (shouldn\'t trigger an event)\n        window.location.hash = `#/firstmount`;\n        return singlespa.triggerappchange();\n      })\n      .then(() => {\n        expect(numbeforefirstmounts).tobe(1);\n        expect(numfirstmounts).tobe(1);\n      });\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# tounmountpromise\n\ntounmountpromise  unmount \n\nexport function tounmountpromise(apporparcel, hardfail) {\n  return promise.resolve().then(() => {\n    // app.status  mounted\n    if (apporparcel.status !== mounted) {\n      return apporparcel;\n    }\n    //  app.status  unmounting\n    apporparcel.status = unmounting;\n    //  parcel parcel  unmount  parcel  unmount \n    const unmountchildrenparcels = object.keys(\n      apporparcel.parcels\n    ).map((parcelid) => apporparcel.parcels[parcelid].unmountthisparcel());\n\n    let parcelerror;\n\n    return promise.all(unmountchildrenparcels)\n      .then(unmountapporparcel, (parcelerror) => {\n        // there is a parcel unmount error\n        return unmountapporparcel().then(() => {\n          // unmounting the app/parcel succeeded, but unmounting its children parcels did not\n          const parenterror = error(parcelerror.message);\n          if (hardfail) {\n            throw transformerr(parenterror, apporparcel, skip_because_broken);\n          } else {\n            handleapperror(parenterror, apporparcel, skip_because_broken);\n          }\n        });\n      })\n      .then(() => apporparcel);\n    //  app unmount \n    function unmountapporparcel() {\n      // we always try to unmount the apporparcel, even if the children parcels failed to unmount.\n      return reasonabletime(apporparcel, "unmount")\n        .then(() => {\n          // the apporparcel needs to stay in a broken status if its children parcels fail to unmount\n          if (!parcelerror) {\n            //  app  app.parcels  unmount not_mounted\n            apporparcel.status = not_mounted;\n          }\n        })\n        .catch((err) => {\n          if (hardfail) {\n            throw transformerr(err, apporparcel, skip_because_broken);\n          } else {\n            handleapperror(err, apporparcel, skip_because_broken);\n          }\n        });\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n * unmount  unmounting not_mounted skip_because_broken\n * unmount application  parcel  umount',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"update",frontmatter:{title:"update",date:"2022-04-18T16:06:26.000Z",permalink:"/single-spa/lifecycle/update/",categories:["single-spa","lifecycles"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/20.lifecycles%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/40.update.html",relativePath:"30.web/5.single-spa/20.lifecycles/40.update.md",key:"v-3336f808",path:"/single-spa/lifecycle/update/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:84},{level:2,title:"toUpdatePromise",slug:"toupdatepromise",normalizedTitle:"toupdatepromise",charIndex:99}],excerpt:"<TimeToRead />\n<p> single-spa  update  single-spa  update  mount </p>\n",readingTime:{text:"1 min read",minutes:.395,time:23700.000000000004,words:79},headersStr:" toUpdatePromise",content:' single-spa  update  single-spa  update  mount \n\n\n# \n\n\n\n * \n * toUpdatePromise\n\n\n\n\n# toUpdatePromise\n\nexport function toUpdatePromise(parcel) {\n  return Promise.resolve().then(() => {\n    if (parcel.status !== MOUNTED) {\n      throw Error(\n        // ......\n      );\n    }\n\n    parcel.status = UPDATING;\n\n    return reasonableTime(parcel, "update")\n      .then(() => {\n        //  MOUNTED\n        parcel.status = MOUNTED;\n        return parcel;\n      })\n      .catch((err) => {\n        throw transformErr(err, parcel, SKIP_BECAUSE_BROKEN);\n      });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n *  UPDATING MOUNTED\n * update  parcel ',normalizedContent:' single-spa  update  single-spa  update  mount \n\n\n# \n\n\n\n * \n * toupdatepromise\n\n\n\n\n# toupdatepromise\n\nexport function toupdatepromise(parcel) {\n  return promise.resolve().then(() => {\n    if (parcel.status !== mounted) {\n      throw error(\n        // ......\n      );\n    }\n\n    parcel.status = updating;\n\n    return reasonabletime(parcel, "update")\n      .then(() => {\n        //  mounted\n        parcel.status = mounted;\n        return parcel;\n      })\n      .catch((err) => {\n        throw transformerr(err, parcel, skip_because_broken);\n      });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n *  updating mounted\n * update  parcel ',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-04-18T17:06:55.000Z",permalink:"/single-spa/nav/index/",categories:["single-spa","navigation"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/30.navigation%E4%B8%8E%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86/0.index.html",relativePath:"30.web/5.single-spa/30.navigation/0.index.md",key:"v-3bd3e459",path:"/single-spa/nav/index/",excerpt:"<p>  <code>lifecycles</code>   single-spa  bootstrap mount  unmountload  unloadupdate  s-spa </p>\n<p> single-spa   <code>navigateToUrl</code>    <code>triggerAppChange</code>   API</p>\n",readingTime:{text:"1 min read",minutes:.125,time:7500,words:25},headersStr:null,content:" lifecycles  single-spa  bootstrap mount  unmountload  unloadupdate  s-spa \n\n single-spa  navigateToUrl  triggerAppChange  API",normalizedContent:" lifecycles  single-spa  bootstrap mount  unmountload  unloadupdate  s-spa \n\n single-spa  navigatetourl  triggerappchange  api",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"navigation-events ",frontmatter:{title:"navigation-events ",date:"2022-04-18T17:28:37.000Z",permalink:"/single-spa/nav/events/",categories:["single-spa","navigation"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/30.navigation%E4%B8%8E%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86/10.navigation-events.html",relativePath:"30.web/5.single-spa/30.navigation/10.navigation-events.md",key:"v-3bb59422",path:"/single-spa/nav/events/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:164},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:95},{level:2,title:"urlReroute",slug:"urlreroute",normalizedTitle:"urlreroute",charIndex:187},{level:2,title:"patchedUpdateState",slug:"patchedupdatestate",normalizedTitle:"patchedupdatestate",charIndex:201},{level:2,title:"navigateToUrl",slug:"navigatetourl",normalizedTitle:"navigatetourl",charIndex:223},{level:2,title:"createPopStateEvent",slug:"createpopstateevent",normalizedTitle:"createpopstateevent",charIndex:240}],excerpt:"<p> single s-spa mount  unmount s-spa </p>\n",readingTime:{text:"5 min read",minutes:4.105,time:246300,words:821},headersStr:"  urlReroute patchedUpdateState navigateToUrl createPopStateEvent",content:' single s-spa mount  unmount s-spa \n\n\n# \n\n\n\n * \n * \n * urlReroute\n * patchedUpdateState\n * navigateToUrl\n * createPopStateEvent\n\n\n\n\n\n * hash  history \n * url  history  url \n\n\n# \n\n window  hashchange  popstate  url hash  popstate  history.pushState  history.replaceState url  url  reroute\n\nif (isInBrowser) {\n  //  hashchange  popstate \n  //  addEventListener \n  // We will trigger an app change for any routing events.\n  window.addEventListener("hashchange", urlReroute);\n  window.addEventListener("popstate", urlReroute);\n\n  // Monkeypatch addEventListener so that we can ensure correct timing\n  const originalAddEventListener = window.addEventListener;\n  const originalRemoveEventListener = window.removeEventListener;\n  //  addEventListener  removeEventListener\n  window.addEventListener = function (eventName, fn) {\n    //  addEventListener  listener \n    if (typeof fn === "function") {\n      //  capturedEventListeners[eventName] \n      if (\n        routingEventsListeningTo.indexOf(eventName) >= 0 &&\n        !find(capturedEventListeners[eventName], (listener) => listener === fn)\n      ) {\n        //  listener  capturedEventListeners\n        capturedEventListeners[eventName].push(fn);\n        //  listeners  s-spa  listeners \n        return;\n      }\n    }\n\n    return originalAddEventListener.apply(this, arguments);\n  };\n\n  window.removeEventListener = function (eventName, listenerFn) {\n    if (typeof listenerFn === "function") {\n      //  capturedEventListeners  listener\n      if (routingEventsListeningTo.indexOf(eventName) >= 0) {\n        capturedEventListeners[eventName] = capturedEventListeners[\n          eventName\n        ].filter((fn) => fn !== listenerFn);\n        return;\n      }\n    }\n\n    return originalRemoveEventListener.apply(this, arguments);\n  };\n  //  history.pushState  history.replaceState\n  // patchedUpdateState  url \n  window.history.pushState = patchedUpdateState(\n    window.history.pushState,\n    "pushState"\n  );\n  window.history.replaceState = patchedUpdateState(\n    window.history.replaceState,\n    "replaceState"\n  );\n  // \n  if (window.singleSpaNavigate) {\n    console.warn(\n      formatErrorMessage(\n        41,\n        __DEV__ &&\n          "single-spa has been loaded twice on the page. This can result in unexpected behavior."\n      )\n    );\n  } else {\n    /* For convenience in `onclick` attributes, we expose a global function for navigating to\n     * whatever an <a> tag\'s href is.\n     */\n    //  navigateToUrl \n    window.singleSpaNavigate = navigateToUrl;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n\n * hashchangepopstatehistory.pushState  history.replaceState\n *  window.addEventListener  window.removeEventListener  hashchange  popstate  listener\n *  singleSpaNavigate  window.singleSpaNavigate\n\n\n# urlReroute\n\n hashchange  popstate  url  reroute\n\nfunction urlReroute() {\n  // url  reroute\n  reroute([], arguments);\n}\n\n\n1\n2\n3\n4\n\n\n\n# patchedUpdateState\n\n history.pushState  history.replaceState  state  url  reroute\n\nfunction patchedUpdateState(updateState, methodName) {\n  //  history.pushState  replace.replaceState url \n  return function () {\n    const urlBefore = window.location.href;\n    // \n    const result = updateState.apply(this, arguments);\n    const urlAfter = window.location.href;\n    //  urlRerouteOnly url \n    if (!urlRerouteOnly || urlBefore !== urlAfter) {\n      if (isStarted()) {\n        // fire an artificial popstate event once single-spa is started,\n        // so that single-spa applications know about routing that\n        // occurs in a different application\n        //  popsState  reroute\n        window.dispatchEvent(\n          createPopStateEvent(window.history.state, methodName)\n        );\n      } else {\n        // do not fire an artificial popstate event before single-spa is started,\n        // since no single-spa applications need to know about routing events\n        // outside of their own router.\n        // s-spa  start reroute\n        //  start reroute reroute  start \n        reroute([]);\n      }\n    }\n\n    return result;\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n\n start reroute createPopStateEvent  popState \n\n\n# navigateToUrl\n\n> Use this utility function to easily perform url navigation between registered applications without needing to deal with event.preventDefault(), pushState, triggerAppChange(), etc.\n\n/**\n * see https://single-spa.js.org/docs/api/#navigatetourl\n *  url triggerAppChange\n */\nexport function navigateToUrl(obj) {\n  let url;\n  // obj  url\n  if (typeof obj === "string") {\n    url = obj;\n  } else if (this && this.href) {\n    // obj  a \n    url = this.href;\n  } else if (\n    // object  ClickEvent\n    obj &&\n    obj.currentTarget &&\n    obj.currentTarget.href &&\n    obj.preventDefault\n  ) {\n    url = obj.currentTarget.href;\n    obj.preventDefault();\n  } else {\n    throw Error(\n      // ......\n    );\n  }\n  //  currentUrl  url  a \n  const current = parseUri(window.location.href);\n  const destination = parseUri(url);\n \n  if (url.indexOf("#") === 0) {\n    // url  hash \n    window.location.hash = destination.hash;\n  } else if (current.host !== destination.host && destination.host) {\n    if (process.env.BABEL_ENV === "test") {\n      return { wouldHaveReloadedThePage: true };\n    } else {\n      //  host\n      window.location.href = url;\n    }\n  } else if (\n    destination.pathname === current.pathname &&\n    destination.search === current.search\n  ) {\n    // pathname  search \n    window.location.hash = destination.hash;\n  } else {\n    // different path, host, or query params\n    window.history.pushState(null, null, url);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\nnavigateToUrl  reroute\n\n\n# createPopStateEvent\n\ncreatePopStateEvent  popState  history.pushState  history.replaceState  url  popState \n\nfunction createPopStateEvent(state, originalMethodName) {\n  // https://github.com/single-spa/single-spa/issues/224 and https://github.com/single-spa/single-spa-angular/issues/49\n  // We need a popstate event even though the browser doesn\'t do one by default when you call replaceState, so that\n  // all the applications can reroute. We explicitly identify this extraneous event by setting singleSpa=true and\n  // singleSpaTrigger=<pushState|replaceState> on the event instance.\n  let evt;\n  try {\n    // IE  PopStateEvent() see https://caniuse.com/mdn-api_popstateevent_popstateevent\n    evt = new PopStateEvent("popstate", { state });\n  } catch (err) {\n    // IE 11 compatibility https://github.com/single-spa/single-spa/issues/299\n    // https://docs.microsoft.com/en-us/openspecs/ie_standards/ms-html5e/bd560f47-b349-4d2c-baa8-f1560fb489dd\n    evt = document.createEvent("PopStateEvent");\n    // nitializes the properties of a PopStateEvent object.Available only in IE10, IE11, and EdgeHTML Mode (All Versions).\n    evt.initPopStateEvent("popstate", false, false, state);\n  }\n  //  popState \n  evt.singleSpa = true;\n  evt.singleSpaTrigger = originalMethodName;\n  return evt;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n hashchange  popState  url  history.pushState  history.replaceState \n\n\n\n * Events | single-spa',normalizedContent:' single s-spa mount  unmount s-spa \n\n\n# \n\n\n\n * \n * \n * urlreroute\n * patchedupdatestate\n * navigatetourl\n * createpopstateevent\n\n\n\n\n\n * hash  history \n * url  history  url \n\n\n# \n\n window  hashchange  popstate  url hash  popstate  history.pushstate  history.replacestate url  url  reroute\n\nif (isinbrowser) {\n  //  hashchange  popstate \n  //  addeventlistener \n  // we will trigger an app change for any routing events.\n  window.addeventlistener("hashchange", urlreroute);\n  window.addeventlistener("popstate", urlreroute);\n\n  // monkeypatch addeventlistener so that we can ensure correct timing\n  const originaladdeventlistener = window.addeventlistener;\n  const originalremoveeventlistener = window.removeeventlistener;\n  //  addeventlistener  removeeventlistener\n  window.addeventlistener = function (eventname, fn) {\n    //  addeventlistener  listener \n    if (typeof fn === "function") {\n      //  capturedeventlisteners[eventname] \n      if (\n        routingeventslisteningto.indexof(eventname) >= 0 &&\n        !find(capturedeventlisteners[eventname], (listener) => listener === fn)\n      ) {\n        //  listener  capturedeventlisteners\n        capturedeventlisteners[eventname].push(fn);\n        //  listeners  s-spa  listeners \n        return;\n      }\n    }\n\n    return originaladdeventlistener.apply(this, arguments);\n  };\n\n  window.removeeventlistener = function (eventname, listenerfn) {\n    if (typeof listenerfn === "function") {\n      //  capturedeventlisteners  listener\n      if (routingeventslisteningto.indexof(eventname) >= 0) {\n        capturedeventlisteners[eventname] = capturedeventlisteners[\n          eventname\n        ].filter((fn) => fn !== listenerfn);\n        return;\n      }\n    }\n\n    return originalremoveeventlistener.apply(this, arguments);\n  };\n  //  history.pushstate  history.replacestate\n  // patchedupdatestate  url \n  window.history.pushstate = patchedupdatestate(\n    window.history.pushstate,\n    "pushstate"\n  );\n  window.history.replacestate = patchedupdatestate(\n    window.history.replacestate,\n    "replacestate"\n  );\n  // \n  if (window.singlespanavigate) {\n    console.warn(\n      formaterrormessage(\n        41,\n        __dev__ &&\n          "single-spa has been loaded twice on the page. this can result in unexpected behavior."\n      )\n    );\n  } else {\n    /* for convenience in `onclick` attributes, we expose a global function for navigating to\n     * whatever an <a> tag\'s href is.\n     */\n    //  navigatetourl \n    window.singlespanavigate = navigatetourl;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n\n * hashchangepopstatehistory.pushstate  history.replacestate\n *  window.addeventlistener  window.removeeventlistener  hashchange  popstate  listener\n *  singlespanavigate  window.singlespanavigate\n\n\n# urlreroute\n\n hashchange  popstate  url  reroute\n\nfunction urlreroute() {\n  // url  reroute\n  reroute([], arguments);\n}\n\n\n1\n2\n3\n4\n\n\n\n# patchedupdatestate\n\n history.pushstate  history.replacestate  state  url  reroute\n\nfunction patchedupdatestate(updatestate, methodname) {\n  //  history.pushstate  replace.replacestate url \n  return function () {\n    const urlbefore = window.location.href;\n    // \n    const result = updatestate.apply(this, arguments);\n    const urlafter = window.location.href;\n    //  urlrerouteonly url \n    if (!urlrerouteonly || urlbefore !== urlafter) {\n      if (isstarted()) {\n        // fire an artificial popstate event once single-spa is started,\n        // so that single-spa applications know about routing that\n        // occurs in a different application\n        //  popsstate  reroute\n        window.dispatchevent(\n          createpopstateevent(window.history.state, methodname)\n        );\n      } else {\n        // do not fire an artificial popstate event before single-spa is started,\n        // since no single-spa applications need to know about routing events\n        // outside of their own router.\n        // s-spa  start reroute\n        //  start reroute reroute  start \n        reroute([]);\n      }\n    }\n\n    return result;\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n\n start reroute createpopstateevent  popstate \n\n\n# navigatetourl\n\n> use this utility function to easily perform url navigation between registered applications without needing to deal with event.preventdefault(), pushstate, triggerappchange(), etc.\n\n/**\n * see https://single-spa.js.org/docs/api/#navigatetourl\n *  url triggerappchange\n */\nexport function navigatetourl(obj) {\n  let url;\n  // obj  url\n  if (typeof obj === "string") {\n    url = obj;\n  } else if (this && this.href) {\n    // obj  a \n    url = this.href;\n  } else if (\n    // object  clickevent\n    obj &&\n    obj.currenttarget &&\n    obj.currenttarget.href &&\n    obj.preventdefault\n  ) {\n    url = obj.currenttarget.href;\n    obj.preventdefault();\n  } else {\n    throw error(\n      // ......\n    );\n  }\n  //  currenturl  url  a \n  const current = parseuri(window.location.href);\n  const destination = parseuri(url);\n \n  if (url.indexof("#") === 0) {\n    // url  hash \n    window.location.hash = destination.hash;\n  } else if (current.host !== destination.host && destination.host) {\n    if (process.env.babel_env === "test") {\n      return { wouldhavereloadedthepage: true };\n    } else {\n      //  host\n      window.location.href = url;\n    }\n  } else if (\n    destination.pathname === current.pathname &&\n    destination.search === current.search\n  ) {\n    // pathname  search \n    window.location.hash = destination.hash;\n  } else {\n    // different path, host, or query params\n    window.history.pushstate(null, null, url);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\nnavigatetourl  reroute\n\n\n# createpopstateevent\n\ncreatepopstateevent  popstate  history.pushstate  history.replacestate  url  popstate \n\nfunction createpopstateevent(state, originalmethodname) {\n  // https://github.com/single-spa/single-spa/issues/224 and https://github.com/single-spa/single-spa-angular/issues/49\n  // we need a popstate event even though the browser doesn\'t do one by default when you call replacestate, so that\n  // all the applications can reroute. we explicitly identify this extraneous event by setting singlespa=true and\n  // singlespatrigger=<pushstate|replacestate> on the event instance.\n  let evt;\n  try {\n    // ie  popstateevent() see https://caniuse.com/mdn-api_popstateevent_popstateevent\n    evt = new popstateevent("popstate", { state });\n  } catch (err) {\n    // ie 11 compatibility https://github.com/single-spa/single-spa/issues/299\n    // https://docs.microsoft.com/en-us/openspecs/ie_standards/ms-html5e/bd560f47-b349-4d2c-baa8-f1560fb489dd\n    evt = document.createevent("popstateevent");\n    // nitializes the properties of a popstateevent object.available only in ie10, ie11, and edgehtml mode (all versions).\n    evt.initpopstateevent("popstate", false, false, state);\n  }\n  //  popstate \n  evt.singlespa = true;\n  evt.singlespatrigger = originalmethodname;\n  return evt;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n hashchange  popstate  url  history.pushstate  history.replacestate \n\n\n\n * events | single-spa',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"reroute ",frontmatter:{title:"reroute ",date:"2022-04-18T17:25:22.000Z",permalink:"/single-spa/nav/reroute/",categories:["single-spa","navigation"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/30.navigation%E4%B8%8E%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86/20.reroute.html",relativePath:"30.web/5.single-spa/30.navigation/20.reroute.md",key:"v-44bace4f",path:"/single-spa/nav/reroute/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:375},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:390},{level:2,title:"reroute",slug:"reroute",normalizedTitle:"reroute",charIndex:103},{level:3,title:" hashchange  popstate  listeners?",slug:"-hashchange--popstate--listeners",normalizedTitle:" hashchange  popstate  listeners?",charIndex:411},{level:3,title:" cancelNavigation ",slug:"-cancelnavigation-",normalizedTitle:" cancelnavigation ",charIndex:457},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:491},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:507},{level:2,title:"tryToBootstrapAndMount",slug:"trytobootstrapandmount",normalizedTitle:"trytobootstrapandmount",charIndex:521},{level:2,title:"callCapturedEventListeners",slug:"callcapturedeventlisteners",normalizedTitle:"callcapturedeventlisteners",charIndex:547},{level:2,title:"triggerAppChange",slug:"triggerappchange",normalizedTitle:"triggerappchange",charIndex:577}],excerpt:"<TimeToRead />\n<p> s-spa  url  <code>history.pushState</code>    <code>history.replaceState</code>   reroute reroute </p>\n<p> s-spa applications   <code></code>  applications   <code></code>   parcel s-spa </p>\n<p> reroute  reroute </p>\n",readingTime:{text:"9 min read",minutes:8.485,time:509099.99999999994,words:1697},headersStr:"  reroute  hashchange  popstate  listeners?  cancelNavigation    tryToBootstrapAndMount callCapturedEventListeners triggerAppChange",content:' s-spa  url  history.pushState  history.replaceState  reroute reroute \n\n s-spa applications    applications    parcel s-spa \n\n reroute  reroute \n\n\n# \n\n\n\n * \n * \n * reroute\n   *  hashchange  popstate  listeners?\n   *  cancelNavigation \n   * \n   * \n * tryToBootstrapAndMount\n * callCapturedEventListeners\n * triggerAppChange\n\n\n\n\n# \n\n *  reroute \n * \n\n\n# reroute\n\n single-spa  reroute  reroute  Promise \n\n//  reroute\nlet appChangeUnderway = false,\n  //  reroute \n  peopleWaitingOnAppChange = [],\n  //  url\n  currentUrl = isInBrowser && window.location.href;\n\n// pendingPromises resolve  pending  reroute eventArguments listener \nexport function reroute(pendingPromises = [], eventArguments) {\n  if (appChangeUnderway) {\n    //  reroute  reroute \n    return new Promise((resolve, reject) => {\n      //  reject, reject  promise promise\n      // promise  then  catch \n      peopleWaitingOnAppChange.push({\n        resolve,\n        reject,\n        eventArguments,\n      });\n    });\n  }\n  // \n  //  unloadunmountloadmount reroute \n  const {\n    appsToUnload,\n    appsToUnmount,\n    appsToLoad,\n    appsToMount,\n  } = getAppChanges();\n  // \n  let appsThatChanged,\n    // \n    navigationIsCanceled = false,\n    //  oldUrl  newUrl\n    oldUrl = currentUrl,\n    newUrl = (currentUrl = window.location.href);\n\n  if (isStarted()) {\n    // s-spa  reroute \n    appChangeUnderway = true;\n    // \n    appsThatChanged = appsToUnload.concat(\n      appsToLoad,\n      appsToUnmount,\n      appsToMount\n    );\n    // \n    return performAppChanges();\n  } else {\n    //  s-spa  load \n    appsThatChanged = appsToLoad;\n    //  mount []\n    return loadApps();\n  }\n\n  function cancelNavigation() {\n    navigationIsCanceled = true;\n  }\n\n  function loadApps() {\n    return Promise.resolve().then(() => {\n      // load appsToLoad loadPromises  Promise[]\n      const loadPromises = appsToLoad.map(toLoadPromise);\n\n      return (\n        Promise.all(loadPromises)\n          //  load  listeners\n          .then(callAllEventListeners)\n          // there are no mounted apps, before start() is called, so we always return []\n          //  start  mount  []\n          .then(() => [])\n          .catch((err) => {\n            //  listeners\n            callAllEventListeners();\n            throw err;\n          })\n      );\n    });\n  }\n\n  function performAppChanges() {\n    return Promise.resolve().then(() => {\n      // https://github.com/single-spa/single-spa/issues/545\n      window.dispatchEvent(\n        new CustomEvent(\n          appsThatChanged.length === 0\n            ? "single-spa:before-no-app-change"\n            : "single-spa:before-app-change",\n          getCustomEventDetail(true)\n        )\n      );\n      //  cancelNavigation \n      // see https://single-spa.js.org/docs/api/#canceling-navigation\n      window.dispatchEvent(\n        new CustomEvent(\n          "single-spa:before-routing-event",\n          getCustomEventDetail(true, { cancelNavigation })\n        )\n      );\n      //  oldUrl before-mount-routing-event\n      // see https://single-spa.js.org/docs/api#canceling-navigation\n      if (navigationIsCanceled) {\n        window.dispatchEvent(\n          new CustomEvent(\n            "single-spa:before-mount-routing-event",\n            getCustomEventDetail(true)\n          )\n        );\n        finishUpAndReturn();\n        navigateToUrl(oldUrl);\n        return;\n      }\n      // unload apps promises\n      const unloadPromises = appsToUnload.map(toUnloadPromise);\n      // appsToUnmount  unmount unload\n      const unmountUnloadPromises = appsToUnmount\n        .map(toUnmountPromise)\n        .map((unmountPromise) => unmountPromise.then(toUnloadPromise));\n      //  unload  promises unload\n      const allUnmountPromises = unmountUnloadPromises.concat(unloadPromises);\n      //  unload  promises\n      const unmountAllPromise = Promise.all(allUnmountPromises);\n\n      unmountAllPromise.then(() => {\n        // unload  before-mount-routing-event \n        window.dispatchEvent(\n          new CustomEvent(\n            "single-spa:before-mount-routing-event",\n            getCustomEventDetail(true)\n          )\n        );\n      });\n\n      /* We load and bootstrap apps while other apps are unmounting, but we\n       * wait to mount the app until all apps are finishing unmounting\n       */\n      //  unmounting  appsToLoad  bootstrap  load\n      //  unmounting  appsToLoad  appsToMount  mount\n      const loadThenMountPromises = appsToLoad.map((app) => {\n        return toLoadPromise(app).then((app) =>\n          tryToBootstrapAndMount(app, unmountAllPromise)\n        );\n      });\n\n      /* These are the apps that are already bootstrapped and just need\n       * to be mounted. They each wait for all unmounting apps to finish up\n       * before they mount.\n       */\n      //  appsToLoad  tryToBootstrapAndMount\n      // mount load => bootstrap => mount\n      const mountPromises = appsToMount\n        .filter((appToMount) => appsToLoad.indexOf(appToMount) < 0)\n        .map((appToMount) => {\n          return tryToBootstrapAndMount(appToMount, unmountAllPromise);\n        });\n\n      return unmountAllPromise\n        .catch((err) => {\n          //  unmount  listeners\n          callAllEventListeners();\n          throw err;\n        })\n        .then(() => {\n          /* Now that the apps that needed to be unmounted are unmounted, their DOM navigation\n           * events (like hashchange or popstate) should have been cleaned up. So it\'s safe\n           * to let the remaining captured event listeners to handle about the DOM event.\n           */\n          //  unmount  unmount\n          callAllEventListeners();\n          //  loadThenMountPromises  mountPromises  appsToLoad  appsToMount\n          return Promise.all(loadThenMountPromises.concat(mountPromises))\n            .catch((err) => {\n              //  pending  reroute  reject\n              pendingPromises.forEach((promise) => promise.reject(err));\n              throw err;\n            })\n            //  finish  mount \n            .then(finishUpAndReturn);\n        });\n    });\n  }\n\n  function finishUpAndReturn() {\n    //  mount \n    const returnValue = getMountedApps();\n    //  pending  reroute  resolve\n    pendingPromises.forEach((promise) => promise.resolve(returnValue));\n    // dispatch app-change  no-app-change \n    try {\n      const appChangeEventName =\n        appsThatChanged.length === 0\n          ? "single-spa:no-app-change"\n          : "single-spa:app-change";\n      window.dispatchEvent(\n        new CustomEvent(appChangeEventName, getCustomEventDetail())\n      );\n      // dispatch routing-event \n      window.dispatchEvent(\n        new CustomEvent("single-spa:routing-event", getCustomEventDetail())\n      );\n    } catch (err) {\n      /* We use a setTimeout because if someone else\'s event handler throws an error, single-spa\n       * needs to carry on. If a listener to the event throws an error, it\'s their own fault, not\n       * single-spa\'s.\n       */\n      // \n      setTimeout(() => {\n        throw err;\n      });\n    }\n\n    /* Setting this allows for subsequent calls to reroute() to actually perform\n     * a reroute instead of just getting queued behind the current reroute call.\n     * We want to do this after the mounting/unmounting is done but before we\n     * resolve the promise for the `reroute` function.\n     */\n    //  mount/unmount reroute  resolve \n    appChangeUnderway = false;\n    //  reroute \n    if (peopleWaitingOnAppChange.length > 0) {\n      /* While we were rerouting, someone else triggered another reroute that got queued.\n       * So we need reroute again.\n       */\n      // Array<{resolve: any; reject: any; eventArguments: any[]}>\n      const nextPendingPromises = peopleWaitingOnAppChange;\n      // \n      peopleWaitingOnAppChange = [];\n      //  reroute promise \n      // resolve \n      reroute(nextPendingPromises);\n    }\n\n    return returnValue;\n  }\n\n  /* We need to call all event listeners that have been delayed because they were\n   * waiting on single-spa. This includes haschange and popstate events for both\n   * the current run of performAppChanges(), but also all of the queued event listeners.\n   * We want to call the listeners in the same order as if they had not been delayed by\n   * single-spa, which means queued ones first and then the most recent one.\n   */\n  //  listeners \n  function callAllEventListeners() {\n    //  listener  reroute \n    pendingPromises.forEach((pendingPromise) => {\n      //  listener \n      callCapturedEventListeners(pendingPromise.eventArguments);\n    });\n    //  listener \n    callCapturedEventListeners(eventArguments);\n  }\n\n  //  customEvent \n  // CustomEvent  https://github.com/webmodules/custom-event/blob/master/index.js\n  function getCustomEventDetail(isBeforeChanges = false, extraProperties) {\n    const newAppStatuses = {};\n    const appsByNewStatus = {\n      // for apps that were mounted\n      [MOUNTED]: [],\n      // for apps that were unmounted\n      [NOT_MOUNTED]: [],\n      // apps that were forcibly unloaded\n      [NOT_LOADED]: [],\n      // apps that attempted to do something but are broken now\n      [SKIP_BECAUSE_BROKEN]: [],\n    };\n    // \n    if (isBeforeChanges) {\n      appsToLoad.concat(appsToMount).forEach((app, index) => {\n        addApp(app, MOUNTED);\n      });\n      appsToUnload.forEach((app) => {\n        addApp(app, NOT_LOADED);\n      });\n      appsToUnmount.forEach((app) => {\n        addApp(app, NOT_MOUNTED);\n      });\n    } else {\n      //  appsThatChanged \n      appsThatChanged.forEach((app) => {\n        addApp(app);\n      });\n    }\n\n    const result = {\n      detail: {\n        newAppStatuses,\n        appsByNewStatus,\n        totalAppChanges: appsThatChanged.length,\n        originalEvent: eventArguments?.[0],\n        oldUrl,\n        newUrl,\n        navigationIsCanceled,\n      },\n    };\n    // \n    if (extraProperties) {\n      assign(result.detail, extraProperties);\n    }\n\n    return result;\n\n    function addApp(app, status) {\n      const appName = toName(app);\n      status = status || getAppStatus(appName);\n      //  app  newAppStatuses\n      newAppStatuses[appName] = status;\n      const statusArr = (appsByNewStatus[status] =\n        appsByNewStatus[status] || []);\n      //  app  statusArr \n      statusArr.push(appName);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n\n\n\n#  hashchange  popstate  listeners?\n\n hashchange  popstate  listeners DOM  url  DOM  listener loadmount listeners\n\n\n#  cancelNavigation \n\nMDN: dispatchEvent\n\nThe dispatchEvent() method of the EventTarget sends an Event to the object, (synchronously) invoking the affected EventListeners in the appropriate order.\n\n before-routing-event  dispatch  listener  cancelNavigation  navigationIsCanceled  falsedispatchEvent \n\ndispatchEvent \n\n> false if event is cancelable, and at least one of the event handlers which received event called Event.preventDefault(). Otherwise true.\n\ndispatchEvent  emitter  listener  dispatchEvent \n\n\n\n * EventTarget.dispatchEvent() - Web APIs | MDN\n * javascript - Is dispatchEvent a sync or an async function - Stack Overflow\n\n\n# \n\n// \nlet appChangeUnderway = false,\n // \n  peopleWaitingOnAppChange = [];\n\n// pendingPromises  pending  promise\nfunction reroute(pendingPromises = []) {\n  if (appChangeUnderway) {\n    // \n    return new Promise((resolve, reject) => {\n      peopleWaitingOnAppChange.push({\n        resolve,\n        reject,\n        eventArguments,\n      });\n    });\n  }\n  // ......\n  // \n  appChangeUnderway = true;\n  // ......\n \n  //  promise\n  // ......\n  //  pending  reject\n  pendingPromises.forEach((promise) => promise.reject(err));\n  // \n  let returnValue;\n  //  pending  resolve resolve  returnValue\n  pendingPromises.forEach((promise) => promise.resolve(returnValue));\n  // \n  appChangeUnderway = false;\n  // \n  if (peopleWaitingOnAppChange.length > 0) {\n    const nextPendingPromises = peopleWaitingOnAppChange;\n    // \n    peopleWaitingOnAppChange = [];\n    //  pending  promise \n    reroute(nextPendingPromises);\n  }\n\n  return returnValue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n\n * \n * \n * \n\n\n\n * \n\n\n# \n\n\n\nEVENT ORDER   EVENT NAME                                          CONDITION FOR FIRING                                  \n1             single-spa:before-app-change or                     Will any applications change status?                   reroute \n              single-spa:before-no-app-change\n2             single-spa:before-routing-event                                                                           cancelNavigation \n3             single-spa:before-mount-routing-event                                                                     unmountinactive   mountactive  \n4             single-spa:before-first-mount                       Is this the first time any application is mounting?    mount \n5             single-spa:first-mount                              Is this the first time any application was mounted?    mount \n6             single-spa:app-change or single-spa:no-app-change   Did any applications change status?                    reroute \n7             single-spa:routing-event                                                                                  reroute \n\n\n\n * Applications API | single-spa\n\n\n# tryToBootstrapAndMount\n\ntryToBootstrapAndMount  bootstrap  inactive  unmounting  mount active \n\n/**\n * Let\'s imagine that some kind of delay occurred during application loading.\n * The user without waiting for the application to load switched to another route,\n * this means that we shouldn\'t bootstrap and mount that application, thus we check\n * twice if that application should be active before bootstrapping and mounting.\n * https://github.com/single-spa/single-spa/issues/524\n */\nfunction tryToBootstrapAndMount(app, unmountAllPromise) {\n  // \n  if (shouldBeActive(app)) {\n    //  bootstrap  unmount \n    return toBootstrapPromise(app).then((app) =>\n      //  unmount  mount \n      //  unmount  unmount \n      unmountAllPromise.then(() =>\n        shouldBeActive(app) ? toMountPromise(app) : app\n      )\n    );\n  } else {\n    return unmountAllPromise.then(() => app);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# callCapturedEventListeners\n\ncallCapturedEventListeners  reroute  hashchange  popstate  liseners\n\nexport function callCapturedEventListeners(eventArguments) {\n  if (eventArguments) {\n    const eventType = eventArguments[0].type;\n    // \n    if (routingEventsListeningTo.indexOf(eventType) >= 0) {\n      //  listener\n      capturedEventListeners[eventType].forEach((listener) => {\n        //  listener \n        try {\n          // The error thrown by application event listener should not break single-spa down.\n          // Just like https://github.com/single-spa/single-spa/blob/85f5042dff960e40936f3a5069d56fc9477fac04/src/navigation/reroute.js#L140-L146 did\n          listener.apply(this, eventArguments);\n        } catch (e) {\n          setTimeout(() => {\n            throw e;\n          });\n        }\n      });\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# triggerAppChange\n\nexport function triggerAppChange() {\n  // Call reroute with no arguments, intentionally\n  return reroute();\n}\n\n\n1\n2\n3\n4\n\n\ns-spa ',normalizedContent:' s-spa  url  history.pushstate  history.replacestate  reroute reroute \n\n s-spa applications    applications    parcel s-spa \n\n reroute  reroute \n\n\n# \n\n\n\n * \n * \n * reroute\n   *  hashchange  popstate  listeners?\n   *  cancelnavigation \n   * \n   * \n * trytobootstrapandmount\n * callcapturedeventlisteners\n * triggerappchange\n\n\n\n\n# \n\n *  reroute \n * \n\n\n# reroute\n\n single-spa  reroute  reroute  promise \n\n//  reroute\nlet appchangeunderway = false,\n  //  reroute \n  peoplewaitingonappchange = [],\n  //  url\n  currenturl = isinbrowser && window.location.href;\n\n// pendingpromises resolve  pending  reroute eventarguments listener \nexport function reroute(pendingpromises = [], eventarguments) {\n  if (appchangeunderway) {\n    //  reroute  reroute \n    return new promise((resolve, reject) => {\n      //  reject, reject  promise promise\n      // promise  then  catch \n      peoplewaitingonappchange.push({\n        resolve,\n        reject,\n        eventarguments,\n      });\n    });\n  }\n  // \n  //  unloadunmountloadmount reroute \n  const {\n    appstounload,\n    appstounmount,\n    appstoload,\n    appstomount,\n  } = getappchanges();\n  // \n  let appsthatchanged,\n    // \n    navigationiscanceled = false,\n    //  oldurl  newurl\n    oldurl = currenturl,\n    newurl = (currenturl = window.location.href);\n\n  if (isstarted()) {\n    // s-spa  reroute \n    appchangeunderway = true;\n    // \n    appsthatchanged = appstounload.concat(\n      appstoload,\n      appstounmount,\n      appstomount\n    );\n    // \n    return performappchanges();\n  } else {\n    //  s-spa  load \n    appsthatchanged = appstoload;\n    //  mount []\n    return loadapps();\n  }\n\n  function cancelnavigation() {\n    navigationiscanceled = true;\n  }\n\n  function loadapps() {\n    return promise.resolve().then(() => {\n      // load appstoload loadpromises  promise[]\n      const loadpromises = appstoload.map(toloadpromise);\n\n      return (\n        promise.all(loadpromises)\n          //  load  listeners\n          .then(callalleventlisteners)\n          // there are no mounted apps, before start() is called, so we always return []\n          //  start  mount  []\n          .then(() => [])\n          .catch((err) => {\n            //  listeners\n            callalleventlisteners();\n            throw err;\n          })\n      );\n    });\n  }\n\n  function performappchanges() {\n    return promise.resolve().then(() => {\n      // https://github.com/single-spa/single-spa/issues/545\n      window.dispatchevent(\n        new customevent(\n          appsthatchanged.length === 0\n            ? "single-spa:before-no-app-change"\n            : "single-spa:before-app-change",\n          getcustomeventdetail(true)\n        )\n      );\n      //  cancelnavigation \n      // see https://single-spa.js.org/docs/api/#canceling-navigation\n      window.dispatchevent(\n        new customevent(\n          "single-spa:before-routing-event",\n          getcustomeventdetail(true, { cancelnavigation })\n        )\n      );\n      //  oldurl before-mount-routing-event\n      // see https://single-spa.js.org/docs/api#canceling-navigation\n      if (navigationiscanceled) {\n        window.dispatchevent(\n          new customevent(\n            "single-spa:before-mount-routing-event",\n            getcustomeventdetail(true)\n          )\n        );\n        finishupandreturn();\n        navigatetourl(oldurl);\n        return;\n      }\n      // unload apps promises\n      const unloadpromises = appstounload.map(tounloadpromise);\n      // appstounmount  unmount unload\n      const unmountunloadpromises = appstounmount\n        .map(tounmountpromise)\n        .map((unmountpromise) => unmountpromise.then(tounloadpromise));\n      //  unload  promises unload\n      const allunmountpromises = unmountunloadpromises.concat(unloadpromises);\n      //  unload  promises\n      const unmountallpromise = promise.all(allunmountpromises);\n\n      unmountallpromise.then(() => {\n        // unload  before-mount-routing-event \n        window.dispatchevent(\n          new customevent(\n            "single-spa:before-mount-routing-event",\n            getcustomeventdetail(true)\n          )\n        );\n      });\n\n      /* we load and bootstrap apps while other apps are unmounting, but we\n       * wait to mount the app until all apps are finishing unmounting\n       */\n      //  unmounting  appstoload  bootstrap  load\n      //  unmounting  appstoload  appstomount  mount\n      const loadthenmountpromises = appstoload.map((app) => {\n        return toloadpromise(app).then((app) =>\n          trytobootstrapandmount(app, unmountallpromise)\n        );\n      });\n\n      /* these are the apps that are already bootstrapped and just need\n       * to be mounted. they each wait for all unmounting apps to finish up\n       * before they mount.\n       */\n      //  appstoload  trytobootstrapandmount\n      // mount load => bootstrap => mount\n      const mountpromises = appstomount\n        .filter((apptomount) => appstoload.indexof(apptomount) < 0)\n        .map((apptomount) => {\n          return trytobootstrapandmount(apptomount, unmountallpromise);\n        });\n\n      return unmountallpromise\n        .catch((err) => {\n          //  unmount  listeners\n          callalleventlisteners();\n          throw err;\n        })\n        .then(() => {\n          /* now that the apps that needed to be unmounted are unmounted, their dom navigation\n           * events (like hashchange or popstate) should have been cleaned up. so it\'s safe\n           * to let the remaining captured event listeners to handle about the dom event.\n           */\n          //  unmount  unmount\n          callalleventlisteners();\n          //  loadthenmountpromises  mountpromises  appstoload  appstomount\n          return promise.all(loadthenmountpromises.concat(mountpromises))\n            .catch((err) => {\n              //  pending  reroute  reject\n              pendingpromises.foreach((promise) => promise.reject(err));\n              throw err;\n            })\n            //  finish  mount \n            .then(finishupandreturn);\n        });\n    });\n  }\n\n  function finishupandreturn() {\n    //  mount \n    const returnvalue = getmountedapps();\n    //  pending  reroute  resolve\n    pendingpromises.foreach((promise) => promise.resolve(returnvalue));\n    // dispatch app-change  no-app-change \n    try {\n      const appchangeeventname =\n        appsthatchanged.length === 0\n          ? "single-spa:no-app-change"\n          : "single-spa:app-change";\n      window.dispatchevent(\n        new customevent(appchangeeventname, getcustomeventdetail())\n      );\n      // dispatch routing-event \n      window.dispatchevent(\n        new customevent("single-spa:routing-event", getcustomeventdetail())\n      );\n    } catch (err) {\n      /* we use a settimeout because if someone else\'s event handler throws an error, single-spa\n       * needs to carry on. if a listener to the event throws an error, it\'s their own fault, not\n       * single-spa\'s.\n       */\n      // \n      settimeout(() => {\n        throw err;\n      });\n    }\n\n    /* setting this allows for subsequent calls to reroute() to actually perform\n     * a reroute instead of just getting queued behind the current reroute call.\n     * we want to do this after the mounting/unmounting is done but before we\n     * resolve the promise for the `reroute` function.\n     */\n    //  mount/unmount reroute  resolve \n    appchangeunderway = false;\n    //  reroute \n    if (peoplewaitingonappchange.length > 0) {\n      /* while we were rerouting, someone else triggered another reroute that got queued.\n       * so we need reroute again.\n       */\n      // array<{resolve: any; reject: any; eventarguments: any[]}>\n      const nextpendingpromises = peoplewaitingonappchange;\n      // \n      peoplewaitingonappchange = [];\n      //  reroute promise \n      // resolve \n      reroute(nextpendingpromises);\n    }\n\n    return returnvalue;\n  }\n\n  /* we need to call all event listeners that have been delayed because they were\n   * waiting on single-spa. this includes haschange and popstate events for both\n   * the current run of performappchanges(), but also all of the queued event listeners.\n   * we want to call the listeners in the same order as if they had not been delayed by\n   * single-spa, which means queued ones first and then the most recent one.\n   */\n  //  listeners \n  function callalleventlisteners() {\n    //  listener  reroute \n    pendingpromises.foreach((pendingpromise) => {\n      //  listener \n      callcapturedeventlisteners(pendingpromise.eventarguments);\n    });\n    //  listener \n    callcapturedeventlisteners(eventarguments);\n  }\n\n  //  customevent \n  // customevent  https://github.com/webmodules/custom-event/blob/master/index.js\n  function getcustomeventdetail(isbeforechanges = false, extraproperties) {\n    const newappstatuses = {};\n    const appsbynewstatus = {\n      // for apps that were mounted\n      [mounted]: [],\n      // for apps that were unmounted\n      [not_mounted]: [],\n      // apps that were forcibly unloaded\n      [not_loaded]: [],\n      // apps that attempted to do something but are broken now\n      [skip_because_broken]: [],\n    };\n    // \n    if (isbeforechanges) {\n      appstoload.concat(appstomount).foreach((app, index) => {\n        addapp(app, mounted);\n      });\n      appstounload.foreach((app) => {\n        addapp(app, not_loaded);\n      });\n      appstounmount.foreach((app) => {\n        addapp(app, not_mounted);\n      });\n    } else {\n      //  appsthatchanged \n      appsthatchanged.foreach((app) => {\n        addapp(app);\n      });\n    }\n\n    const result = {\n      detail: {\n        newappstatuses,\n        appsbynewstatus,\n        totalappchanges: appsthatchanged.length,\n        originalevent: eventarguments?.[0],\n        oldurl,\n        newurl,\n        navigationiscanceled,\n      },\n    };\n    // \n    if (extraproperties) {\n      assign(result.detail, extraproperties);\n    }\n\n    return result;\n\n    function addapp(app, status) {\n      const appname = toname(app);\n      status = status || getappstatus(appname);\n      //  app  newappstatuses\n      newappstatuses[appname] = status;\n      const statusarr = (appsbynewstatus[status] =\n        appsbynewstatus[status] || []);\n      //  app  statusarr \n      statusarr.push(appname);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n\n\n\n#  hashchange  popstate  listeners?\n\n hashchange  popstate  listeners dom  url  dom  listener loadmount listeners\n\n\n#  cancelnavigation \n\nmdn: dispatchevent\n\nthe dispatchevent() method of the eventtarget sends an event to the object, (synchronously) invoking the affected eventlisteners in the appropriate order.\n\n before-routing-event  dispatch  listener  cancelnavigation  navigationiscanceled  falsedispatchevent \n\ndispatchevent \n\n> false if event is cancelable, and at least one of the event handlers which received event called event.preventdefault(). otherwise true.\n\ndispatchevent  emitter  listener  dispatchevent \n\n\n\n * eventtarget.dispatchevent() - web apis | mdn\n * javascript - is dispatchevent a sync or an async function - stack overflow\n\n\n# \n\n// \nlet appchangeunderway = false,\n // \n  peoplewaitingonappchange = [];\n\n// pendingpromises  pending  promise\nfunction reroute(pendingpromises = []) {\n  if (appchangeunderway) {\n    // \n    return new promise((resolve, reject) => {\n      peoplewaitingonappchange.push({\n        resolve,\n        reject,\n        eventarguments,\n      });\n    });\n  }\n  // ......\n  // \n  appchangeunderway = true;\n  // ......\n \n  //  promise\n  // ......\n  //  pending  reject\n  pendingpromises.foreach((promise) => promise.reject(err));\n  // \n  let returnvalue;\n  //  pending  resolve resolve  returnvalue\n  pendingpromises.foreach((promise) => promise.resolve(returnvalue));\n  // \n  appchangeunderway = false;\n  // \n  if (peoplewaitingonappchange.length > 0) {\n    const nextpendingpromises = peoplewaitingonappchange;\n    // \n    peoplewaitingonappchange = [];\n    //  pending  promise \n    reroute(nextpendingpromises);\n  }\n\n  return returnvalue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n\n * \n * \n * \n\n\n\n * \n\n\n# \n\n\n\nevent order   event name                                          condition for firing                                  \n1             single-spa:before-app-change or                     will any applications change status?                   reroute \n              single-spa:before-no-app-change\n2             single-spa:before-routing-event                                                                           cancelnavigation \n3             single-spa:before-mount-routing-event                                                                     unmountinactive   mountactive  \n4             single-spa:before-first-mount                       is this the first time any application is mounting?    mount \n5             single-spa:first-mount                              is this the first time any application was mounted?    mount \n6             single-spa:app-change or single-spa:no-app-change   did any applications change status?                    reroute \n7             single-spa:routing-event                                                                                  reroute \n\n\n\n * applications api | single-spa\n\n\n# trytobootstrapandmount\n\ntrytobootstrapandmount  bootstrap  inactive  unmounting  mount active \n\n/**\n * let\'s imagine that some kind of delay occurred during application loading.\n * the user without waiting for the application to load switched to another route,\n * this means that we shouldn\'t bootstrap and mount that application, thus we check\n * twice if that application should be active before bootstrapping and mounting.\n * https://github.com/single-spa/single-spa/issues/524\n */\nfunction trytobootstrapandmount(app, unmountallpromise) {\n  // \n  if (shouldbeactive(app)) {\n    //  bootstrap  unmount \n    return tobootstrappromise(app).then((app) =>\n      //  unmount  mount \n      //  unmount  unmount \n      unmountallpromise.then(() =>\n        shouldbeactive(app) ? tomountpromise(app) : app\n      )\n    );\n  } else {\n    return unmountallpromise.then(() => app);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# callcapturedeventlisteners\n\ncallcapturedeventlisteners  reroute  hashchange  popstate  liseners\n\nexport function callcapturedeventlisteners(eventarguments) {\n  if (eventarguments) {\n    const eventtype = eventarguments[0].type;\n    // \n    if (routingeventslisteningto.indexof(eventtype) >= 0) {\n      //  listener\n      capturedeventlisteners[eventtype].foreach((listener) => {\n        //  listener \n        try {\n          // the error thrown by application event listener should not break single-spa down.\n          // just like https://github.com/single-spa/single-spa/blob/85f5042dff960e40936f3a5069d56fc9477fac04/src/navigation/reroute.js#l140-l146 did\n          listener.apply(this, eventarguments);\n        } catch (e) {\n          settimeout(() => {\n            throw e;\n          });\n        }\n      });\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# triggerappchange\n\nexport function triggerappchange() {\n  // call reroute with no arguments, intentionally\n  return reroute();\n}\n\n\n1\n2\n3\n4\n\n\ns-spa ',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-04-18T20:18:20.000Z",permalink:"/single-spa/nav/parcel/",categories:["single-spa","parcel"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/40.parcel%E7%BB%84%E4%BB%B6/0.index.html",relativePath:"30.web/5.single-spa/40.parcel/0.index.md",key:"v-73517018",path:"/single-spa/nav/parcel/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:133}],readingTime:{text:"1 min read",minutes:.07,time:4200,words:14},headersStr:"",content:" single-spa  parcel Parcels  api  parcel \n\n\n# \n\n\n\n * \n\n\n\n\n\n * Parcels ",normalizedContent:" single-spa  parcel parcels  api  parcel \n\n\n# \n\n\n\n * \n\n\n\n\n\n * parcels ",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-04-19T17:32:50.000Z",permalink:"/single-spa/other/index/",categories:["single-spa",""],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/50.%E5%85%B6%E4%BB%96/0.index.html",relativePath:"30.web/5.single-spa/50./0.index.md",key:"v-db70af54",path:"/single-spa/other/index/",excerpt:"<p> single-spa </p>\n",readingTime:{text:"1 min read",minutes:.03,time:1799.9999999999998,words:6},headersStr:null,content:" single-spa ",normalizedContent:" single-spa ",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"customEvent",frontmatter:{title:"customEvent",date:"2022-04-19T17:35:52.000Z",permalink:"/single-spa/other/customEvent/",categories:["more","single-spa",""],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/50.%E5%85%B6%E4%BB%96/10.customEvent.html",relativePath:"30.web/5.single-spa/50./10.customEvent.md",key:"v-e148fee0",path:"/single-spa/other/customEvent/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"EventTarget",slug:"eventtarget",normalizedTitle:"eventtarget",charIndex:17},{level:3,title:" EventTarget?",slug:"-eventtarget",normalizedTitle:" eventtarget?",charIndex:34},{level:3,title:"Methods",slug:"methods",normalizedTitle:"methods",charIndex:57},{level:2,title:"CustomEvent",slug:"customevent",normalizedTitle:"customevent",charIndex:68}],excerpt:"<TimeToRead />\n",readingTime:{text:"2 min read",minutes:1.72,time:103200,words:344},headersStr:" EventTarget  EventTarget? Methods CustomEvent",content:"# \n\n\n\n * \n * EventTarget\n   *  EventTarget?\n   * Methods\n * CustomEvent\n\n\n\n\n\n 1.  emitter  emitter  (OOP)\n 2.  emitter  emitter \n 3.  EventTarget API \n 4.  webpack \n\n single-spa  EventTarget API \n\n EventTarget API\n\n\n# EventTarget\n\n> The EventTarget interface is implemented by objects that can receive events and may have listeners for them. In other words, any target of events implements the three methods associated with this interface.\n\n\n#  EventTarget?\n\nElement , and its children, as well as Document and Window , are the most common event targets, but other objects can be event targets, too. For example XMLHttpRequest , AudioNode , and AudioContext are also event targets.\n\n\n# Methods\n\n * EventTarget.addEventListener(): Registers an event handler of a specific event type on the EventTarget.\n * EventTarget.removeEventListener():Removes an event listener from the EventTarget.\n * EventTarget.dispatchEvent():Dispatches an event to this EventTarget.\n\n\n\n * EventTarget - Web APIs | MDN\n\n\n# CustomEvent\n\n CustomEvent\n\n * modern browserglobal.CustomEvent\n * ie9+document.createEventdocument.initCustomEvent\n * ie8-document.createEventObject\n\n// https://github.com/webmodules/custom-event/blob/master/index.js\n// global  nodejs\nvar NativeCustomEvent = global.CustomEvent;\n\n//  CustomEvent\nfunction useNative () {\n  try {\n    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });\n    return  'cat' === p.type && 'bar' === p.detail.foo;\n  } catch (e) {\n  }\n  return false;\n}\n\n/**\n * Cross-browser `CustomEvent` constructor.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent\n *\n * @public\n */\n\nmodule.exports = useNative() ? NativeCustomEvent :\n\n// IE >= 9\n'undefined' !== typeof document && 'function' === typeof document.createEvent ? function CustomEvent (type, params) {\n  //  ie9  document \n  // ie9+  createEvent  initCustomEvent\n  var e = document.createEvent('CustomEvent');\n  if (params) {\n    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);\n  } else {\n    e.initCustomEvent(type, false, false, void 0);\n  }\n  return e;\n} :\n\n// IE <= 8\nfunction CustomEvent (type, params) {\n  // ie 8-  createEventObject\n  var e = document.createEventObject();\n  e.type = type;\n  if (params) {\n    e.bubbles = Boolean(params.bubbles);\n    e.cancelable = Boolean(params.cancelable);\n    e.detail = params.detail;\n  } else {\n    e.bubbles = false;\n    e.cancelable = false;\n    e.detail = void 0;\n  }\n  return e;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n\n * CustomEvent() - Web APIs | MDN",normalizedContent:"# \n\n\n\n * \n * eventtarget\n   *  eventtarget?\n   * methods\n * customevent\n\n\n\n\n\n 1.  emitter  emitter  (oop)\n 2.  emitter  emitter \n 3.  eventtarget api \n 4.  webpack \n\n single-spa  eventtarget api \n\n eventtarget api\n\n\n# eventtarget\n\n> the eventtarget interface is implemented by objects that can receive events and may have listeners for them. in other words, any target of events implements the three methods associated with this interface.\n\n\n#  eventtarget?\n\nelement , and its children, as well as document and window , are the most common event targets, but other objects can be event targets, too. for example xmlhttprequest , audionode , and audiocontext are also event targets.\n\n\n# methods\n\n * eventtarget.addeventlistener(): registers an event handler of a specific event type on the eventtarget.\n * eventtarget.removeeventlistener():removes an event listener from the eventtarget.\n * eventtarget.dispatchevent():dispatches an event to this eventtarget.\n\n\n\n * eventtarget - web apis | mdn\n\n\n# customevent\n\n customevent\n\n * modern browserglobal.customevent\n * ie9+document.createeventdocument.initcustomevent\n * ie8-document.createeventobject\n\n// https://github.com/webmodules/custom-event/blob/master/index.js\n// global  nodejs\nvar nativecustomevent = global.customevent;\n\n//  customevent\nfunction usenative () {\n  try {\n    var p = new nativecustomevent('cat', { detail: { foo: 'bar' } });\n    return  'cat' === p.type && 'bar' === p.detail.foo;\n  } catch (e) {\n  }\n  return false;\n}\n\n/**\n * cross-browser `customevent` constructor.\n *\n * https://developer.mozilla.org/en-us/docs/web/api/customevent.customevent\n *\n * @public\n */\n\nmodule.exports = usenative() ? nativecustomevent :\n\n// ie >= 9\n'undefined' !== typeof document && 'function' === typeof document.createevent ? function customevent (type, params) {\n  //  ie9  document \n  // ie9+  createevent  initcustomevent\n  var e = document.createevent('customevent');\n  if (params) {\n    e.initcustomevent(type, params.bubbles, params.cancelable, params.detail);\n  } else {\n    e.initcustomevent(type, false, false, void 0);\n  }\n  return e;\n} :\n\n// ie <= 8\nfunction customevent (type, params) {\n  // ie 8-  createeventobject\n  var e = document.createeventobject();\n  e.type = type;\n  if (params) {\n    e.bubbles = boolean(params.bubbles);\n    e.cancelable = boolean(params.cancelable);\n    e.detail = params.detail;\n  } else {\n    e.bubbles = false;\n    e.cancelable = false;\n    e.detail = void 0;\n  }\n  return e;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n\n * customevent() - web apis | mdn",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-04-19T18:09:17.000Z",permalink:"/single-spa/other/error/",categories:["single-spa",""],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/50.%E5%85%B6%E4%BB%96/20.error.html",relativePath:"30.web/5.single-spa/50./20.error.md",key:"v-6644dbd4",path:"/single-spa/other/error/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-04-18T20:28:19.000Z",permalink:"/single-spa/spa-react/index/",categories:["single-spa","single-spa-react"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/60.single-spa-react/0.index.html",relativePath:"30.web/5.single-spa/60.single-spa-react/0.index.md",key:"v-1bd41a5b",path:"/single-spa/spa-react/index/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2}],readingTime:{text:"1 min read",minutes:.05,time:3e3,words:10},headersStr:"",content:"# \n\n * single-spa/single-spa-react: a single-spa plugin for react applications",normalizedContent:"# \n\n * single-spa/single-spa-react: a single-spa plugin for react applications",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"JQuery ",frontmatter:{title:"JQuery ",date:"2022-04-14T22:02:20.000Z",permalink:"/jquery/jq-book/",categories:["jquery"],tags:[null]},regularPath:"/30.web/50.jquery%E6%BA%90%E7%A0%81/10.jq-book.html",relativePath:"30.web/50.jquery/10.jq-book.md",key:"v-82122182",path:"/jquery/jq-book/",readingTime:{text:"1 min read",minutes:.02,time:1200,words:4},headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/25, 18:09:57",lastUpdatedTimestamp:1656151797e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:20.000Z",permalink:"/jquery/index/",categories:["jquery"],tags:[null]},regularPath:"/30.web/50.jquery%E6%BA%90%E7%A0%81/0.index.html",relativePath:"30.web/50.jquery/0.index.md",key:"v-1401de91",path:"/jquery/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"JQuery ",frontmatter:{title:"JQuery ",date:"2022-04-14T22:02:20.000Z",permalink:"/jquery/jq-source/",categories:["jquery"],tags:[null]},regularPath:"/30.web/50.jquery%E6%BA%90%E7%A0%81/20.jq-source.html",relativePath:"30.web/50.jquery/20.jq-source.md",key:"v-1ff4e09f",path:"/jquery/jq-source/",readingTime:{text:"1 min read",minutes:.02,time:1200,words:4},headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"jQuery ",frontmatter:{title:"jQuery ",date:"2022-04-14T22:02:20.000Z",permalink:"/jquery/extend/",categories:["jquery"],tags:[null]},regularPath:"/30.web/50.jquery%E6%BA%90%E7%A0%81/30.extend.html",relativePath:"30.web/50.jquery/30.extend.md",key:"v-f54ae5ba",path:"/jquery/extend/",headers:[{level:2,title:"IEOperanameID",slug:"ieoperanameid",normalizedTitle:"ie  opera  name  id ",charIndex:2}],readingTime:{text:"2 min read",minutes:1.475,time:88500,words:295},headersStr:"IEOperanameID",content:"# IE  Opera  name  ID \n\nIE works correctly on elements that CAN'T have a name attribute. It works incorrectly, however, on elements that can.\n\nAs I researched this, I found a function in JavaScript I've never used before:\n\n> HTMLCollection.namedItem( String name )\n> \n> This function seeks for any element within the collection whose id attribute value matches the name specified in the call. If it doesn't find one, it searches for any element whose name attribute matches the name specified in the call. The function returns the first element object it finds that meets the criteria, or null if it can't find one.\n\nMy first thought was, Microsoft has their document.getElementById calling their namedItem() function. But then I stepped back and realized through my experiment that IE seems to be matching against both name and id at the same time to match the value.\n\nAs you'll notice below, I have two elements for each part of the experiment. The first has the name attribute filled with the id value \"my[Element]\" I'm wanting to look for. I fill the second element's id attribute with the same value. IE, parsing from the top of the document down, finds the element with the name=\"my[Element]\" first and automatically takes it... it doesn't even wait to see if it can find one with an id that matches first.\n\nI can only assume this was done for optimizing this \"convenience feature\", but makes for some serious puzzlement and aggravation in troubleshooting why the element a developer can't get to who happens to name/id things in a way similar to what happens in my experiment. Whatever reason, they did it, it's wrong. Please be careful in how you name/id things\n\njQuery  $().find(selector) \n\n\n\n * Internet Explorer (IE) JavaScript document.getElementById whackedness demo",normalizedContent:"# ie  opera  name  id \n\nie works correctly on elements that can't have a name attribute. it works incorrectly, however, on elements that can.\n\nas i researched this, i found a function in javascript i've never used before:\n\n> htmlcollection.nameditem( string name )\n> \n> this function seeks for any element within the collection whose id attribute value matches the name specified in the call. if it doesn't find one, it searches for any element whose name attribute matches the name specified in the call. the function returns the first element object it finds that meets the criteria, or null if it can't find one.\n\nmy first thought was, microsoft has their document.getelementbyid calling their nameditem() function. but then i stepped back and realized through my experiment that ie seems to be matching against both name and id at the same time to match the value.\n\nas you'll notice below, i have two elements for each part of the experiment. the first has the name attribute filled with the id value \"my[element]\" i'm wanting to look for. i fill the second element's id attribute with the same value. ie, parsing from the top of the document down, finds the element with the name=\"my[element]\" first and automatically takes it... it doesn't even wait to see if it can find one with an id that matches first.\n\ni can only assume this was done for optimizing this \"convenience feature\", but makes for some serious puzzlement and aggravation in troubleshooting why the element a developer can't get to who happens to name/id things in a way similar to what happens in my experiment. whatever reason, they did it, it's wrong. please be careful in how you name/id things\n\njquery  $().find(selector) \n\n\n\n * internet explorer (ie) javascript document.getelementbyid whackedness demo",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/index/",categories:["qiankun"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/0.index.html",relativePath:"30.web/6.qiankun/0.index.md",key:"v-52bd35e5",path:"/qiankun/index/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:11},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:54}],readingTime:{text:"1 min read",minutes:.325,time:19500,words:65},headersStr:"  ",content:"# \n\n\n# \n\n           \nqiankun    2.7.0\n\n\n# \n\nqiankun  single-spa \n\n\n\n * \n *   iframe \n\n \n\n>  \n\n:\n\n * \n *  JS \n\n\n\n single-spa \n\nsingle-spa\n\n\n\n *  6/7 - qiankun \n * github: qiankun repo",normalizedContent:"# \n\n\n# \n\n           \nqiankun    2.7.0\n\n\n# \n\nqiankun  single-spa \n\n\n\n * \n *   iframe \n\n \n\n>  \n\n:\n\n * \n *  js \n\n\n\n single-spa \n\nsingle-spa\n\n\n\n *  6/7 - qiankun \n * github: qiankun repo",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/core/index/",categories:["qiankun","core"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/10.core/0.index.html",relativePath:"30.web/6.qiankun/10.core/0.index.md",key:"v-7c668ae7",path:"/qiankun/core/index/",readingTime:{text:"1 min read",minutes:.535,time:32100,words:107},headersStr:null,content:"\n\n.\n addons\n    engineFlag.ts\n    index.ts\n    runtimePublicPath.ts\n apis.ts\n effects.ts\n error.ts\n errorHandler.ts\n globalState.ts\n index.ts\n interfaces.ts\n loader.ts\n prefetch.ts\n sandbox\n    common.ts\n    index.ts\n    legacy\n       sandbox.ts\n    patchers\n       css.ts\n       dynamicAppend\n          common.ts\n          forLooseSandbox.ts\n          forStrictSandbox.ts\n          index.ts\n       historyListener.ts\n       index.ts\n       interval.ts\n       windowListener.ts\n    proxySandbox.ts\n    snapshotSandbox.ts\n utils.ts\n version.ts\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n api",normalizedContent:"\n\n.\n addons\n    engineflag.ts\n    index.ts\n    runtimepublicpath.ts\n apis.ts\n effects.ts\n error.ts\n errorhandler.ts\n globalstate.ts\n index.ts\n interfaces.ts\n loader.ts\n prefetch.ts\n sandbox\n    common.ts\n    index.ts\n    legacy\n       sandbox.ts\n    patchers\n       css.ts\n       dynamicappend\n          common.ts\n          forloosesandbox.ts\n          forstrictsandbox.ts\n          index.ts\n       historylistener.ts\n       index.ts\n       interval.ts\n       windowlistener.ts\n    proxysandbox.ts\n    snapshotsandbox.ts\n utils.ts\n version.ts\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n api",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:" API",frontmatter:{title:" API",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/core/apis/",categories:["qiankun","core"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/10.core/10.apis.html",relativePath:"30.web/6.qiankun/10.core/10.apis.md",key:"v-6e596402",path:"/qiankun/core/apis/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"registerMicroApps",slug:"registermicroapps",normalizedTitle:"registermicroapps",charIndex:17},{level:2,title:"start",slug:"start",normalizedTitle:"start",charIndex:38},{level:2,title:"loadMicroApp",slug:"loadmicroapp",normalizedTitle:"loadmicroapp",charIndex:47},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:63},{level:3,title:"TS ",slug:"ts--",normalizedTitle:"ts ",charIndex:73},{level:3,title:" DOM  XPath ",slug:"-dom--xpath-",normalizedTitle:" dom  xpath ",charIndex:94}],readingTime:{text:"8 min read",minutes:7.22,time:433200,words:1444},headersStr:" registerMicroApps start loadMicroApp  TS   DOM  XPath ",content:"# \n\n\n\n * \n * registerMicroApps\n * start\n * loadMicroApp\n * \n   * TS \n   *  DOM  XPath \n\n\n\n\n\n * s-spa single-spa \n * \n * \n * src/apis.ts\n\n\n# registerMicroApps\n\n\n\n// \nlet microApps: Array<RegistrableApp<Record<string, unknown>>> = [];\n\n//  S-Spa.registerApplication  loader\n// https://qiankun.umijs.org/zh/api#registermicroappsapps-lifecycles\nexport function registerMicroApps<T extends ObjectType>(\n  apps: Array<RegistrableApp<T>>,\n  lifeCycles?: FrameworkLifeCycles<T>,\n) {\n  // Each app only needs to be registered once\n  // registeredApp name  registeredApp\n  const unregisteredApps = apps.filter((app) => !microApps.some((registeredApp) => registeredApp.name === app.name));\n\n  microApps = [...microApps, ...unregisteredApps];\n\n  unregisteredApps.forEach((app) => {\n    const { name, activeRule, loader = noop, props, ...appConfig } = app;\n    //  single-spa\n    registerApplication({\n      name,\n      // app  Loading Function or Application\n      // see https://single-spa.js.org/docs/configuration#registering-applications\n      app: async () => {\n        loader(true);\n        //  frameworkStartedDefer.promise  resolve\n        await frameworkStartedDefer.promise;\n        // \n        // loadApp start  s-spa \n        const {\n          mount,\n          ...otherMicroAppConfigs\n        } = // frameworkConfiguration  start  merge \n          (await loadApp({ name, props, ...appConfig }, frameworkConfiguration, lifeCycles))();\n\n        return {\n          //  single-spa  single-spa \n          //  loader  mount \n          mount: [async () => loader(true), ...toArray(mount), async () => loader(false)],\n          ...otherMicroAppConfigs,\n        };\n      },\n      // Activity function\n      activeWhen: activeRule,\n      // Custom props\n      customProps: props,\n    });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n loadApp  start () \n\nconst frameworkStartedDefer = new Deferred<void>();\n\nexport class Deferred<T> {\n  promise: Promise<T>;\n\n  resolve!: (value: T | PromiseLike<T>) => void;\n\n  reject!: (reason?: any) => void;\n\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n Promise  promise.then \n\n\n# start\n\nregisterMicroApps  start single-spa \n\n> The start() api must be called by your single spa config in order for applications to actually be mounted. Before start is called, applications will be loaded, but not bootstrapped/mounted/unmounted. The reason for start is to give you control over performance.\n\nCalling singleSpa.start()\n\n// \nexport let frameworkConfiguration: FrameworkConfiguration = {};\n\n//  s-spa  startSingleSpa  prefetchsingularsandbox importEntry \n// see https://qiankun.umijs.org/zh/api#startopts\n// FrameworkConfiguration  qiankun s-spa import-html-entry \nexport function start(opts: FrameworkConfiguration = {}) {\n  // \n  // singular\n  // frameworkConfiguration \n  frameworkConfiguration = { prefetch: true, singular: true, sandbox: true, ...opts };\n  const {\n    prefetch,\n    sandbox,\n    singular,\n    urlRerouteOnly = defaultUrlRerouteOnly,\n    //  html \n    ...importEntryOpts\n  } = frameworkConfiguration;\n  // \n  if (prefetch) {\n    // \n    doPrefetchStrategy(microApps, prefetch, importEntryOpts);\n  }\n  // \n  frameworkConfiguration = autoDowngradeForLowVersionBrowser(frameworkConfiguration);\n\n  startSingleSpa({ urlRerouteOnly });\n  // \n  started = true;\n  //  s-spa prefetch \n  frameworkStartedDefer.resolve();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nstart  s-spa  startSingleSpa  prefetchsingularsandbox importEntry \n\ndoPrefetchStrategy \n\nautoDowngradeForLowVersionBrowser \n\n// \nconst autoDowngradeForLowVersionBrowser = (configuration: FrameworkConfiguration): FrameworkConfiguration => {\n  const { sandbox, singular } = configuration;\n  if (sandbox) {\n    //  window.Proxy window  window loose\n    if (!window.Proxy) {\n      console.warn('[qiankun] Miss window.Proxy, proxySandbox will degenerate into snapshotSandbox');\n      // singular \n      //  window.Proxy \n      if (singular === false) {\n        console.warn(\n          '[qiankun] Setting singular as false may cause unexpected behavior while your browser not support window.Proxy',\n        );\n      }\n\n      return { ...configuration, sandbox: typeof sandbox === 'object' ? { ...sandbox, loose: true } : { loose: true } };\n    }\n  }\n\n  return configuration;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n window.Proxy\n\n> The Proxy object enables you to create a proxy for another object, which can intercept and redefine fundamental operations for that object. Proxy \n\n Vue3  API\n\nMDN: Proxy\n\n\n# loadMicroApp\n\n start  loadMicroApp \n\n//  Map<appContainerXPathKey, Promise<(container) => parcelConfig>>\nconst appConfigPromiseGetterMap = new Map<string, Promise<ParcelConfigObjectGetter>>();\n// \nconst containerMicroAppsMap = new Map<string, MicroApp[]>();\n\n// \n// see https://qiankun.umijs.org/zh/api#loadmicroappapp-configuration\n// see https://single-spa.js.org/docs/module-types\nexport function loadMicroApp<T extends ObjectType>(\n  app: LoadableApp<T>,\n  configuration?: FrameworkConfiguration & { autoStart?: boolean },\n  lifeCycles?: FrameworkLifeCycles<T>,\n): MicroApp {\n  const { props, name } = app;\n\n  const container = 'container' in app ? app.container : undefined;\n  // Must compute the container xpath at beginning to keep it consist around app running\n  // If we compute it every time, the container dom structure most probably been changed and result in a different xpath value\n  //  container  XPath \n  //  DOM \n  //  name + XPath \n  const containerXPath = getContainerXPath(container);\n  const appContainerXPathKey = `${name}-${containerXPath}`;\n\n  let microApp: MicroApp;\n  // \n  //  unmount \n  const wrapParcelConfigForRemount = (config: ParcelConfigObject): ParcelConfigObject => {\n    let microAppConfig = config;\n    if (container) {\n      if (containerXPath) {\n        //  container \n        const containerMicroApps = containerMicroAppsMap.get(appContainerXPathKey);\n        if (containerMicroApps?.length) {\n          //  mount \n          const mount = [\n            async () => {\n              // While there are multiple micro apps mounted on the same container, we must wait until the prev instances all had unmounted\n              // Otherwise it will lead some concurrent issues\n              // \n              const prevLoadMicroApps = containerMicroApps.slice(0, containerMicroApps.indexOf(microApp));\n              // \n              const prevLoadMicroAppsWhichNotBroken = prevLoadMicroApps.filter(\n                (v) => v.getStatus() !== 'LOAD_ERROR' && v.getStatus() !== 'SKIP_BECAUSE_BROKEN',\n              );\n              //  prevLoadMicroAppsWhichNotBroken  unmountPromise  unmountPromise  resolve\n              await Promise.all(prevLoadMicroAppsWhichNotBroken.map((v) => v.unmountPromise));\n            },\n            ...toArray(microAppConfig.mount),\n          ];\n\n          microAppConfig = {\n            ...config,\n            mount,\n          };\n        }\n      }\n    }\n\n    return {\n      ...microAppConfig,\n      // empty bootstrap hook which should not run twice while it calling from cached micro app\n      bootstrap: () => Promise.resolve(),\n    };\n  };\n\n  /**\n   * using name + container xpath as the micro app instance id,\n   * it means if you rendering a micro app to a dom which have been rendered before,\n   * the micro app would not load and evaluate its lifecycles again\n   */\n  const memorizedLoadingFn = async (): Promise<ParcelConfigObject> => {\n    // \n    const userConfiguration = autoDowngradeForLowVersionBrowser(\n      configuration ?? { ...frameworkConfiguration, singular: false },\n    );\n    // $$cacheLifecycleByAppName  false\n    const { $$cacheLifecycleByAppName } = userConfiguration;\n\n    if (container) {\n      // using appName as cache for internal experimental scenario\n      if ($$cacheLifecycleByAppName) {\n        const parcelConfigGetterPromise = appConfigPromiseGetterMap.get(name);\n        if (parcelConfigGetterPromise) return wrapParcelConfigForRemount((await parcelConfigGetterPromise)(container));\n      }\n\n      if (containerXPath) {\n        // \n        const parcelConfigGetterPromise = appConfigPromiseGetterMap.get(appContainerXPathKey);\n        // \n        if (parcelConfigGetterPromise) return wrapParcelConfigForRemount((await parcelConfigGetterPromise)(container));\n      }\n    }\n    // loadApp  async parcelConfigObjectGetterPromise  Promise\n    const parcelConfigObjectGetterPromise = loadApp(app, userConfiguration, lifeCycles);\n\n    if (container) {\n      if ($$cacheLifecycleByAppName) {\n        appConfigPromiseGetterMap.set(name, parcelConfigObjectGetterPromise);\n      } else if (containerXPath)\n        // \n        appConfigPromiseGetterMap.set(appContainerXPathKey, parcelConfigObjectGetterPromise);\n    }\n    // (await parcelConfigGetterPromise)(container)  parcelConfig s-spa \n    return (await parcelConfigObjectGetterPromise)(container);\n  };\n  //  loadMicroApp \n  // \n  if (!started && configuration?.autoStart !== false) {\n    // We need to invoke start method of single-spa as the popstate event should be dispatched while the main app calling pushState/replaceState automatically,\n    // but in single-spa it will check the start status before it dispatch popstate\n    // github \n    // see https://github.com/single-spa/single-spa/blob/f28b5963be1484583a072c8145ac0b5a28d91235/src/navigation/navigation-events.js#L101\n    // ref https://github.com/umijs/qiankun/pull/1071\n    //  startSingleSpa  single-spa  popstate  start\n    //  parcel  popState \n    startSingleSpa({ urlRerouteOnly: frameworkConfiguration.urlRerouteOnly ?? defaultUrlRerouteOnly });\n  }\n  //  parcel  s-spa.mountRootParcel\n  // see https://single-spa.js.org/docs/parcels-api#mountrootparcel\n  // microApp  Parcel object\n  microApp = mountRootParcel(memorizedLoadingFn, { domElement: document.createElement('div'), ...props });\n\n  //  mount  unmount \n  if (container) {\n    if (containerXPath) {\n      // Store the microApps which they mounted on the same container\n      //  container \n      const microAppsRef = containerMicroAppsMap.get(appContainerXPathKey) || [];\n      // \n      microAppsRef.push(microApp);\n      containerMicroAppsMap.set(appContainerXPathKey, microAppsRef);\n\n      const cleanup = () => {\n        // \n        const index = microAppsRef.indexOf(microApp);\n        microAppsRef.splice(index, 1);\n        // @ts-ignore\n        microApp = null;\n      };\n\n      // gc after unmount\n      //  GC \n      microApp.unmountPromise.then(cleanup).catch(cleanup);\n    }\n  }\n\n  return microApp;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n\n\nloadMicroApp  mountRootParcel  s-spa  AppLoading  autoStart  startSingleSpa \n\n\n# \n\n\n# TS \n\nts  render  container \n\n// just for manual loaded apps, in single-spa it called parcel\nexport type LoadableApp<T extends ObjectType> = AppMetadata & {\n  /* props pass through to app */ props?: T;\n} & (\n    | {\n        // legacy mode, the render function all handled by user\n        render: HTMLContentRender;\n      }\n    | {\n        // where the app mount to, mutual exclusive with the legacy custom render function\n        container: string | HTMLElement;\n      }\n  );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n#  DOM  XPath \n\nexport function getContainer(container: string | HTMLElement): HTMLElement | null {\n  return typeof container === 'string' ? document.querySelector(container) : container;\n}\n\nexport function getContainerXPath(container?: string | HTMLElement): string | void {\n  if (container) {\n    //  DOM \n    const containerElement = getContainer(container);\n    if (containerElement) {\n      return getXPathForElement(containerElement, document);\n    }\n  }\n\n  return undefined;\n}\n\n/**\n *  DOM  XPath \n * copy from https://developer.mozilla.org/zh-CN/docs/Using_XPath\n * @param el\n * @param document\n */\nexport function getXPathForElement(el: Node, document: Document): string | void {\n  // not support that if el not existed in document yet(such as it not append to document before it mounted)\n  //  document \n  if (!document.body.contains(el)) {\n    return undefined;\n  }\n\n  let xpath = '';\n  let pos;\n  let tmpEle;\n  let element = el;\n\n  while (element !== document.documentElement) {\n    pos = 0;\n    tmpEle = element;\n    while (tmpEle) {\n      if (tmpEle.nodeType === 1 && tmpEle.nodeName === element.nodeName) {\n        // If it is ELEMENT_NODE of the same name\n        pos += 1;\n      }\n      tmpEle = tmpEle.previousSibling;\n    }\n\n    xpath = `*[name()='${element.nodeName}'][${pos}]/${xpath}`;\n\n    element = element.parentNode!;\n  }\n\n  xpath = `/*[name()='${document.documentElement.nodeName}']/${xpath}`;\n  xpath = xpath.replace(/\\/$/, '');\n\n  return xpath;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n",normalizedContent:"# \n\n\n\n * \n * registermicroapps\n * start\n * loadmicroapp\n * \n   * ts \n   *  dom  xpath \n\n\n\n\n\n * s-spa single-spa \n * \n * \n * src/apis.ts\n\n\n# registermicroapps\n\n\n\n// \nlet microapps: array<registrableapp<record<string, unknown>>> = [];\n\n//  s-spa.registerapplication  loader\n// https://qiankun.umijs.org/zh/api#registermicroappsapps-lifecycles\nexport function registermicroapps<t extends objecttype>(\n  apps: array<registrableapp<t>>,\n  lifecycles?: frameworklifecycles<t>,\n) {\n  // each app only needs to be registered once\n  // registeredapp name  registeredapp\n  const unregisteredapps = apps.filter((app) => !microapps.some((registeredapp) => registeredapp.name === app.name));\n\n  microapps = [...microapps, ...unregisteredapps];\n\n  unregisteredapps.foreach((app) => {\n    const { name, activerule, loader = noop, props, ...appconfig } = app;\n    //  single-spa\n    registerapplication({\n      name,\n      // app  loading function or application\n      // see https://single-spa.js.org/docs/configuration#registering-applications\n      app: async () => {\n        loader(true);\n        //  frameworkstarteddefer.promise  resolve\n        await frameworkstarteddefer.promise;\n        // \n        // loadapp start  s-spa \n        const {\n          mount,\n          ...othermicroappconfigs\n        } = // frameworkconfiguration  start  merge \n          (await loadapp({ name, props, ...appconfig }, frameworkconfiguration, lifecycles))();\n\n        return {\n          //  single-spa  single-spa \n          //  loader  mount \n          mount: [async () => loader(true), ...toarray(mount), async () => loader(false)],\n          ...othermicroappconfigs,\n        };\n      },\n      // activity function\n      activewhen: activerule,\n      // custom props\n      customprops: props,\n    });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n loadapp  start () \n\nconst frameworkstarteddefer = new deferred<void>();\n\nexport class deferred<t> {\n  promise: promise<t>;\n\n  resolve!: (value: t | promiselike<t>) => void;\n\n  reject!: (reason?: any) => void;\n\n  constructor() {\n    this.promise = new promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n promise  promise.then \n\n\n# start\n\nregistermicroapps  start single-spa \n\n> the start() api must be called by your single spa config in order for applications to actually be mounted. before start is called, applications will be loaded, but not bootstrapped/mounted/unmounted. the reason for start is to give you control over performance.\n\ncalling singlespa.start()\n\n// \nexport let frameworkconfiguration: frameworkconfiguration = {};\n\n//  s-spa  startsinglespa  prefetchsingularsandbox importentry \n// see https://qiankun.umijs.org/zh/api#startopts\n// frameworkconfiguration  qiankun s-spa import-html-entry \nexport function start(opts: frameworkconfiguration = {}) {\n  // \n  // singular\n  // frameworkconfiguration \n  frameworkconfiguration = { prefetch: true, singular: true, sandbox: true, ...opts };\n  const {\n    prefetch,\n    sandbox,\n    singular,\n    urlrerouteonly = defaulturlrerouteonly,\n    //  html \n    ...importentryopts\n  } = frameworkconfiguration;\n  // \n  if (prefetch) {\n    // \n    doprefetchstrategy(microapps, prefetch, importentryopts);\n  }\n  // \n  frameworkconfiguration = autodowngradeforlowversionbrowser(frameworkconfiguration);\n\n  startsinglespa({ urlrerouteonly });\n  // \n  started = true;\n  //  s-spa prefetch \n  frameworkstarteddefer.resolve();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nstart  s-spa  startsinglespa  prefetchsingularsandbox importentry \n\ndoprefetchstrategy \n\nautodowngradeforlowversionbrowser \n\n// \nconst autodowngradeforlowversionbrowser = (configuration: frameworkconfiguration): frameworkconfiguration => {\n  const { sandbox, singular } = configuration;\n  if (sandbox) {\n    //  window.proxy window  window loose\n    if (!window.proxy) {\n      console.warn('[qiankun] miss window.proxy, proxysandbox will degenerate into snapshotsandbox');\n      // singular \n      //  window.proxy \n      if (singular === false) {\n        console.warn(\n          '[qiankun] setting singular as false may cause unexpected behavior while your browser not support window.proxy',\n        );\n      }\n\n      return { ...configuration, sandbox: typeof sandbox === 'object' ? { ...sandbox, loose: true } : { loose: true } };\n    }\n  }\n\n  return configuration;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n window.proxy\n\n> the proxy object enables you to create a proxy for another object, which can intercept and redefine fundamental operations for that object. proxy \n\n vue3  api\n\nmdn: proxy\n\n\n# loadmicroapp\n\n start  loadmicroapp \n\n//  map<appcontainerxpathkey, promise<(container) => parcelconfig>>\nconst appconfigpromisegettermap = new map<string, promise<parcelconfigobjectgetter>>();\n// \nconst containermicroappsmap = new map<string, microapp[]>();\n\n// \n// see https://qiankun.umijs.org/zh/api#loadmicroappapp-configuration\n// see https://single-spa.js.org/docs/module-types\nexport function loadmicroapp<t extends objecttype>(\n  app: loadableapp<t>,\n  configuration?: frameworkconfiguration & { autostart?: boolean },\n  lifecycles?: frameworklifecycles<t>,\n): microapp {\n  const { props, name } = app;\n\n  const container = 'container' in app ? app.container : undefined;\n  // must compute the container xpath at beginning to keep it consist around app running\n  // if we compute it every time, the container dom structure most probably been changed and result in a different xpath value\n  //  container  xpath \n  //  dom \n  //  name + xpath \n  const containerxpath = getcontainerxpath(container);\n  const appcontainerxpathkey = `${name}-${containerxpath}`;\n\n  let microapp: microapp;\n  // \n  //  unmount \n  const wrapparcelconfigforremount = (config: parcelconfigobject): parcelconfigobject => {\n    let microappconfig = config;\n    if (container) {\n      if (containerxpath) {\n        //  container \n        const containermicroapps = containermicroappsmap.get(appcontainerxpathkey);\n        if (containermicroapps?.length) {\n          //  mount \n          const mount = [\n            async () => {\n              // while there are multiple micro apps mounted on the same container, we must wait until the prev instances all had unmounted\n              // otherwise it will lead some concurrent issues\n              // \n              const prevloadmicroapps = containermicroapps.slice(0, containermicroapps.indexof(microapp));\n              // \n              const prevloadmicroappswhichnotbroken = prevloadmicroapps.filter(\n                (v) => v.getstatus() !== 'load_error' && v.getstatus() !== 'skip_because_broken',\n              );\n              //  prevloadmicroappswhichnotbroken  unmountpromise  unmountpromise  resolve\n              await promise.all(prevloadmicroappswhichnotbroken.map((v) => v.unmountpromise));\n            },\n            ...toarray(microappconfig.mount),\n          ];\n\n          microappconfig = {\n            ...config,\n            mount,\n          };\n        }\n      }\n    }\n\n    return {\n      ...microappconfig,\n      // empty bootstrap hook which should not run twice while it calling from cached micro app\n      bootstrap: () => promise.resolve(),\n    };\n  };\n\n  /**\n   * using name + container xpath as the micro app instance id,\n   * it means if you rendering a micro app to a dom which have been rendered before,\n   * the micro app would not load and evaluate its lifecycles again\n   */\n  const memorizedloadingfn = async (): promise<parcelconfigobject> => {\n    // \n    const userconfiguration = autodowngradeforlowversionbrowser(\n      configuration ?? { ...frameworkconfiguration, singular: false },\n    );\n    // $$cachelifecyclebyappname  false\n    const { $$cachelifecyclebyappname } = userconfiguration;\n\n    if (container) {\n      // using appname as cache for internal experimental scenario\n      if ($$cachelifecyclebyappname) {\n        const parcelconfiggetterpromise = appconfigpromisegettermap.get(name);\n        if (parcelconfiggetterpromise) return wrapparcelconfigforremount((await parcelconfiggetterpromise)(container));\n      }\n\n      if (containerxpath) {\n        // \n        const parcelconfiggetterpromise = appconfigpromisegettermap.get(appcontainerxpathkey);\n        // \n        if (parcelconfiggetterpromise) return wrapparcelconfigforremount((await parcelconfiggetterpromise)(container));\n      }\n    }\n    // loadapp  async parcelconfigobjectgetterpromise  promise\n    const parcelconfigobjectgetterpromise = loadapp(app, userconfiguration, lifecycles);\n\n    if (container) {\n      if ($$cachelifecyclebyappname) {\n        appconfigpromisegettermap.set(name, parcelconfigobjectgetterpromise);\n      } else if (containerxpath)\n        // \n        appconfigpromisegettermap.set(appcontainerxpathkey, parcelconfigobjectgetterpromise);\n    }\n    // (await parcelconfiggetterpromise)(container)  parcelconfig s-spa \n    return (await parcelconfigobjectgetterpromise)(container);\n  };\n  //  loadmicroapp \n  // \n  if (!started && configuration?.autostart !== false) {\n    // we need to invoke start method of single-spa as the popstate event should be dispatched while the main app calling pushstate/replacestate automatically,\n    // but in single-spa it will check the start status before it dispatch popstate\n    // github \n    // see https://github.com/single-spa/single-spa/blob/f28b5963be1484583a072c8145ac0b5a28d91235/src/navigation/navigation-events.js#l101\n    // ref https://github.com/umijs/qiankun/pull/1071\n    //  startsinglespa  single-spa  popstate  start\n    //  parcel  popstate \n    startsinglespa({ urlrerouteonly: frameworkconfiguration.urlrerouteonly ?? defaulturlrerouteonly });\n  }\n  //  parcel  s-spa.mountrootparcel\n  // see https://single-spa.js.org/docs/parcels-api#mountrootparcel\n  // microapp  parcel object\n  microapp = mountrootparcel(memorizedloadingfn, { domelement: document.createelement('div'), ...props });\n\n  //  mount  unmount \n  if (container) {\n    if (containerxpath) {\n      // store the microapps which they mounted on the same container\n      //  container \n      const microappsref = containermicroappsmap.get(appcontainerxpathkey) || [];\n      // \n      microappsref.push(microapp);\n      containermicroappsmap.set(appcontainerxpathkey, microappsref);\n\n      const cleanup = () => {\n        // \n        const index = microappsref.indexof(microapp);\n        microappsref.splice(index, 1);\n        // @ts-ignore\n        microapp = null;\n      };\n\n      // gc after unmount\n      //  gc \n      microapp.unmountpromise.then(cleanup).catch(cleanup);\n    }\n  }\n\n  return microapp;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n\n\nloadmicroapp  mountrootparcel  s-spa  apploading  autostart  startsinglespa \n\n\n# \n\n\n# ts \n\nts  render  container \n\n// just for manual loaded apps, in single-spa it called parcel\nexport type loadableapp<t extends objecttype> = appmetadata & {\n  /* props pass through to app */ props?: t;\n} & (\n    | {\n        // legacy mode, the render function all handled by user\n        render: htmlcontentrender;\n      }\n    | {\n        // where the app mount to, mutual exclusive with the legacy custom render function\n        container: string | htmlelement;\n      }\n  );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n#  dom  xpath \n\nexport function getcontainer(container: string | htmlelement): htmlelement | null {\n  return typeof container === 'string' ? document.queryselector(container) : container;\n}\n\nexport function getcontainerxpath(container?: string | htmlelement): string | void {\n  if (container) {\n    //  dom \n    const containerelement = getcontainer(container);\n    if (containerelement) {\n      return getxpathforelement(containerelement, document);\n    }\n  }\n\n  return undefined;\n}\n\n/**\n *  dom  xpath \n * copy from https://developer.mozilla.org/zh-cn/docs/using_xpath\n * @param el\n * @param document\n */\nexport function getxpathforelement(el: node, document: document): string | void {\n  // not support that if el not existed in document yet(such as it not append to document before it mounted)\n  //  document \n  if (!document.body.contains(el)) {\n    return undefined;\n  }\n\n  let xpath = '';\n  let pos;\n  let tmpele;\n  let element = el;\n\n  while (element !== document.documentelement) {\n    pos = 0;\n    tmpele = element;\n    while (tmpele) {\n      if (tmpele.nodetype === 1 && tmpele.nodename === element.nodename) {\n        // if it is element_node of the same name\n        pos += 1;\n      }\n      tmpele = tmpele.previoussibling;\n    }\n\n    xpath = `*[name()='${element.nodename}'][${pos}]/${xpath}`;\n\n    element = element.parentnode!;\n  }\n\n  xpath = `/*[name()='${document.documentelement.nodename}']/${xpath}`;\n  xpath = xpath.replace(/\\/$/, '');\n\n  return xpath;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"globalState",frontmatter:{title:"globalState",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/core/globalState/",categories:["qiankun","core"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/10.core/50.globalState.html",relativePath:"30.web/6.qiankun/10.core/50.globalState.md",key:"v-263cdfff",path:"/qiankun/core/globalState/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"loadApp ",frontmatter:{title:"loadApp ",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/core/loader/",categories:["qiankun","core"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/10.core/20.loader.html",relativePath:"30.web/6.qiankun/10.core/20.loader.md",key:"v-6646936e",path:"/qiankun/core/loader/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"loadApp",slug:"loadapp",normalizedTitle:"loadapp",charIndex:17},{level:3,title:"createElement",slug:"createelement",normalizedTitle:"createelement",charIndex:30},{level:3,title:"execHooksChain",slug:"exechookschain",normalizedTitle:"exechookschain",charIndex:49},{level:3,title:"getRender",slug:"getrender",normalizedTitle:"getrender",charIndex:69},{level:3,title:"getLifecyclesFromExports",slug:"getlifecyclesfromexports",normalizedTitle:"getlifecyclesfromexports",charIndex:84},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:112},{level:3,title:"UMD",slug:"umd",normalizedTitle:"umd",charIndex:120},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:127},{level:3,title:" id ",slug:"-id-",normalizedTitle:" id ",charIndex:137},{level:2,title:" window",slug:"-window",normalizedTitle:" window",charIndex:152}],readingTime:{text:"11 min read",minutes:10.945,time:656700,words:2189},headersStr:" loadApp createElement execHooksChain getRender getLifecyclesFromExports  UMD   id   window",content:"# \n\n\n\n * \n * loadApp\n   * createElement\n   * execHooksChain\n   * getRender\n   * getLifecyclesFromExports\n * \n   * UMD\n * \n   *  id \n *  window\n\n\n\n\n# loadApp\n\n  API loadApp  registerMicroAppsloadMicroApp  loadApp  start  s-spa  startSingleSpa  start  start  start  loadMicroApp \n\n// src/loader.ts\n\nexport async function loadApp<T extends ObjectType>(\n  // \n  app: LoadableApp<T>,\n  // \n  configuration: FrameworkConfiguration = {},\n  // \n  lifeCycles?: FrameworkLifeCycles<T>,\n): Promise<ParcelConfigObjectGetter> {\n  const { entry, name: appName } = app;\n  //  id\n  const appInstanceId = genAppInstanceIdByName(appName);\n\n  const {\n    singular = false,\n    sandbox = true,\n    excludeAssetFilter,\n    globalContext = window,\n    ...importEntryOpts\n  } = configuration;\n  //  import-html-entry.importEntry entry importEntryOpts \n  // get the entry html content and script executor\n  // template Processed HTML template.\n  // execScripts(sandbox?: object, strictGlobal?: boolean, execScriptsHooks?: ExecScriptsHooks): Promise<unknown> - the return value is the last property on window or proxy window which set by the entry script.\n  // assetPublicPathPublic path for assets.\n  // see https://github.com/kuitos/import-html-entry#execscriptsentry-scripts-proxy-opts\n  const { template, execScripts, assetPublicPath } = await importEntry(entry, importEntryOpts);\n\n  // as single-spa load and bootstrap new app parallel with other apps unmounting\n  // (see https://github.com/CanopyTax/single-spa/blob/master/src/navigation/reroute.js#L74)\n  // we need wait to load the app until all apps are finishing unmount in singular mode\n  // singular  singular\n  if (await validateSingularMode(singular, app)) {\n    // singular s-spa \n    await (prevAppUnmountedDeferred && prevAppUnmountedDeferred.promise);\n  }\n\n  //  Curry Function\n  // see https://jonsam.site/2021/09/01/js-tricks1/  Curry Function\n  const appContent = getDefaultTplWrapper(appInstanceId)(template);\n\n  //  strictStyleIsolation true ShadowDOM\n  // see https://qiankun.umijs.org/zh/api#startopts sandbox\n  const strictStyleIsolation = typeof sandbox === 'object' && !!sandbox.strictStyleIsolation;\n\n  //  experimentalStyleIsolation shadowDOM \n  const scopedCSS = isEnableScopedCSS(sandbox);\n  // DOM\n  let initialAppWrapperElement: HTMLElement | null = createElement(\n    appContent,\n    strictStyleIsolation,\n    scopedCSS,\n    appInstanceId,\n  );\n\n  const initialContainer = 'container' in app ? app.container : undefined;\n  const legacyRender = 'render' in app ? app.render : undefined;\n  // \n  const render = getRender(appInstanceId, appContent, legacyRender);\n\n  //  dom \n  //  dom \n  //  DOM \n  render({ element: initialAppWrapperElement, loading: true, container: initialContainer }, 'loading');\n  // \n  const initialAppWrapperGetter = getAppWrapperGetter(\n    appInstanceId,\n    !!legacyRender,\n    strictStyleIsolation,\n    scopedCSS,\n    () => initialAppWrapperElement,\n  );\n  //  globalContext window\n  let global = globalContext;\n  let mountSandbox = () => Promise.resolve();\n  let unmountSandbox = () => Promise.resolve();\n  //  loose \n  const useLooseSandbox = typeof sandbox === 'object' && !!sandbox.loose;\n  let sandboxContainer;\n  if (sandbox) {\n    // \n    sandboxContainer = createSandboxContainer(\n      appInstanceId,\n      // FIXME should use a strict sandbox logic while remount, see https://github.com/umijs/qiankun/issues/518\n      initialAppWrapperGetter,\n      scopedCSS,\n      useLooseSandbox,\n      // \n      excludeAssetFilter,\n      global,\n    );\n    // mount  unmount \n    // \n    global = sandboxContainer.instance.proxy as typeof window;\n    mountSandbox = sandboxContainer.mount;\n    unmountSandbox = sandboxContainer.unmount;\n  }\n\n  const { beforeUnmount = [], afterUnmount = [], afterMount = [], beforeMount = [], beforeLoad = [] } =\n    // mergeWith This method is like _.merge except that it accepts customizer which is invoked to produce the merged values of the destination and source properties. If customizer returns undefined merging is handled by the method instead.\n    // see https://lodash.com/docs/4.17.15#mergeWith\n    // concat Creates a new array concatenating array with any additional arrays and/or values.\n    // \n    mergeWith({}, getAddOns(global, assetPublicPath), lifeCycles, (v1, v2) => concat(v1 ?? [], v2 ?? []));\n  //  beforeLoad  beforeLoad \n  await execHooksChain(toArray(beforeLoad), app, global);\n\n  // get the lifecycle hooks from module exports\n  //  js  js  global lose  js \n  // scriptExports  js  js  umd\n  // \n  const scriptExports: any = await execScripts(global, sandbox && !useLooseSandbox);\n  // \n  const { bootstrap, mount, unmount, update } = getLifecyclesFromExports(\n    scriptExports,\n    appName,\n    global,\n    //  latestSetProp execScripts  global  instance?.latestSetProp  UMD \n    sandboxContainer?.instance?.latestSetProp,\n  );\n  //  globalState  deps \n  //  appInstanceId  appInstanceId global id\n  const { onGlobalStateChange, setGlobalState, offGlobalStateChange }: Record<string, CallableFunction> =\n    getMicroAppStateActions(appInstanceId);\n\n  // FIXME temporary way\n  const syncAppWrapperElement2Sandbox = (element: HTMLElement | null) => (initialAppWrapperElement = element);\n\n  // container \n  // loadApp  parcelConfigGetter container  s-spa \n  //  curry function \n  const parcelConfigGetter: ParcelConfigObjectGetter = (remountContainer = initialContainer) => {\n    let appWrapperElement: HTMLElement | null;\n    let appWrapperGetter: ReturnType<typeof getAppWrapperGetter>;\n\n    //  s-spa.mountRootParcel \n    const parcelConfig: ParcelConfigObject = {\n      name: appInstanceId,\n      // bootstrap, mount, unmount, update \n      bootstrap,\n      //  mount async s-spa await\n      mount: [\n        //  singular \n        async () => {\n          if ((await validateSingularMode(singular, app)) && prevAppUnmountedDeferred) {\n            return prevAppUnmountedDeferred.promise;\n          }\n\n          return undefined;\n        },\n        // initial wrapper element before app mount/remount\n        //  getter \n        async () => {\n          appWrapperElement = initialAppWrapperElement;\n          appWrapperGetter = getAppWrapperGetter(\n            appInstanceId,\n            !!legacyRender,\n            strictStyleIsolation,\n            scopedCSS,\n            () => appWrapperElement,\n          );\n        },\n        //  mount hook,  dom \n        async () => {\n          const useNewContainer = remountContainer !== initialContainer;\n          //  initialAppWrapperElement\n          if (useNewContainer || !appWrapperElement) {\n            // element will be destroyed after unmounted, we need to recreate it if it not exist\n            // or we try to remount into a new container\n            appWrapperElement = createElement(appContent, strictStyleIsolation, scopedCSS, appInstanceId);\n            syncAppWrapperElement2Sandbox(appWrapperElement);\n          }\n          //  dom  mounting\n          render({ element: appWrapperElement, loading: true, container: remountContainer }, 'mounting');\n        },\n        //  mount \n        mountSandbox,\n        //  beforeMount\n        // exec the chain after rendering to keep the behavior with beforeLoad\n        async () => execHooksChain(toArray(beforeMount), app, global),\n        //  s-spa  mount  mount  setGlobalState  onGlobalStateChange \n        async (props) => mount({ ...props, container: appWrapperGetter(), setGlobalState, onGlobalStateChange }),\n        // finish loading after app mounted\n        //  DOM  mounted\n        async () => render({ element: appWrapperElement, loading: false, container: remountContainer }, 'mounted'),\n        //  afterMount\n        async () => execHooksChain(toArray(afterMount), app, global),\n        // initialize the unmount defer after app mounted and resolve the defer after it unmounted\n        async () => {\n          if (await validateSingularMode(singular, app)) {\n            //  mount prevAppUnmountedDeferred\n            prevAppUnmountedDeferred = new Deferred<void>();\n          }\n        },\n      ],\n      unmount: [\n        //  beforeUnmount\n        async () => execHooksChain(toArray(beforeUnmount), app, global),\n        //  unmount\n        async (props) => unmount({ ...props, container: appWrapperGetter() }),\n        // \n        unmountSandbox,\n        //  afterUnmount\n        async () => execHooksChain(toArray(afterUnmount), app, global),\n        async () => {\n          //  unmounted\n          render({ element: null, loading: false, container: remountContainer }, 'unmounted');\n          // effect\n          offGlobalStateChange(appInstanceId);\n          //  appWrapperElement  initialAppWrapperElement\n          // for gc\n          appWrapperElement = null;\n          syncAppWrapperElement2Sandbox(appWrapperElement);\n        },\n        async () => {\n          if ((await validateSingularMode(singular, app)) && prevAppUnmountedDeferred) {\n            // unmount resolve prevAppUnmountedDeferred\n            prevAppUnmountedDeferred.resolve();\n          }\n        },\n      ],\n    };\n    //  update  entry  update \n    if (typeof update === 'function') {\n      parcelConfig.update = update;\n    }\n\n    return parcelConfig;\n  };\n\n  return parcelConfigGetter;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n\n\n\n\n *  s-spa \n *  mount  unmount \n * \n *  effect\n\n\n# createElement\n\ncreateElement \n\nconst supportShadowDOM = document.head.attachShadow || document.head.createShadowRoot;\n\nfunction createElement(\n  appContent: string,\n  strictStyleIsolation: boolean,\n  scopedCSS: boolean,\n  appInstanceId: string,\n): HTMLElement {\n  const containerElement = document.createElement('div');\n  containerElement.innerHTML = appContent;\n  // appContent always wrapped with a singular div\n  const appElement = containerElement.firstChild as HTMLElement;\n  if (strictStyleIsolation) {\n    if (!supportShadowDOM) {\n      console.warn(\n        '[qiankun]: As current browser not support shadow dom, your strictStyleIsolation configuration will be ignored!',\n      );\n    } else {\n      const { innerHTML } = appElement;\n      appElement.innerHTML = '';\n      let shadow: ShadowRoot;\n      // attachShadow  shadowDOM v1 \n      if (appElement.attachShadow) {\n        //  shadowDOM\n        shadow = appElement.attachShadow({ mode: 'open' });\n      } else {\n        // createShadowRoot  shadowDOM v0 \n        // createShadowRoot was proposed in initial spec, which has then been deprecated\n        shadow = (appElement as any).createShadowRoot();\n      }\n      shadow.innerHTML = innerHTML;\n    }\n  }\n\n  if (scopedCSS) {\n    const attr = appElement.getAttribute(css.QiankunCSSRewriteAttr);\n    if (!attr) {\n      appElement.setAttribute(css.QiankunCSSRewriteAttr, appInstanceId);\n    }\n    //  scopedCSS appElement \n    const styleNodes = appElement.querySelectorAll('style') || [];\n    forEach(styleNodes, (stylesheetElement: HTMLStyleElement) => {\n      css.process(appElement!, stylesheetElement, appInstanceId);\n    });\n  }\n\n  return appElement;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n *  strictStyleIsolation shadowDOM \n *  scopedCSS\n\n\n# execHooksChain\n\nexecHooksChain \n\nfunction execHooksChain<T extends ObjectType>(\n  hooks: Array<LifeCycleFn<T>>,\n  app: LoadableApp<T>,\n  global = window,\n): Promise<any> {\n  if (hooks.length) {\n    return hooks.reduce((chain, hook) => chain.then(() => hook(app, global)), Promise.resolve());\n  }\n\n  return Promise.resolve();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nexecHooksChain  Promise  Promise Promise.then  hook Promise.resolve().then(() => {})  Promise reduce  hook  hook  promise\n\n/**\n * Represents the completion of an asynchronous operation\n */\ninterface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n     /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T | TResult>\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n Promise thencatchfinally  Promise\n\n\n# getRender\n\n DOM \n\n\nconst rawAppendChild = HTMLElement.prototype.appendChild;\nconst rawRemoveChild = HTMLElement.prototype.removeChild;\n/**\n * Get the render function\n * If the legacy render function is provide, used as it, otherwise we will insert the app element to target container by qiankun\n * @param appInstanceId\n * @param appContent\n * @param legacyRender\n */\nfunction getRender(appInstanceId: string, appContent: string, legacyRender?: HTMLContentRender) {\n  const render: ElementRender = ({ element, loading, container }, phase) => {\n    if (legacyRender) {\n      return legacyRender({ loading, appContent: element ? appContent : '' });\n    }\n    // \n    const containerElement = getContainer(container!);\n\n    // The container might have be removed after micro app unmounted.\n    // Such as the micro app unmount lifecycle called by a react componentWillUnmount lifecycle, after micro app unmounted, the react component might also be removed\n    if (phase !== 'unmounted') {\n      // \n      const errorMsg = (() => {\n        switch (phase) {\n          case 'loading':\n          case 'mounting':\n            return `Target container with ${container} not existed while ${appInstanceId} ${phase}!`;\n\n          case 'mounted':\n            return `Target container with ${container} not existed after ${appInstanceId} ${phase}!`;\n\n          default:\n            return `Target container with ${container} not existed while ${appInstanceId} rendering!`;\n        }\n      })();\n      assertElementExist(containerElement, errorMsg);\n    }\n\n    if (containerElement && !containerElement.contains(element)) {\n      // \n      // clear the container\n      while (containerElement!.firstChild) {\n        rawRemoveChild.call(containerElement, containerElement!.firstChild);\n      }\n      // \n      // append the element to container if it exist\n      if (element) {\n        rawAppendChild.call(containerElement, element);\n      }\n    }\n\n    return undefined;\n  };\n\n  return render;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# getLifecyclesFromExports\n\ngetLifecyclesFromExports  js \n\n/**    */\nexport function validateExportLifecycle(exports: any) {\n  const { bootstrap, mount, unmount } = exports ?? {};\n  return isFunction(bootstrap) && isFunction(mount) && isFunction(unmount);\n}\n\nfunction getLifecyclesFromExports(\n  scriptExports: LifeCycles<any>,\n  appName: string,\n  global: WindowProxy,\n  globalLatestSetProp?: PropertyKey | null,\n) {\n  if (validateExportLifecycle(scriptExports)) {\n    return scriptExports;\n  }\n\n  // fallback to sandbox latest set property if it had\n  if (globalLatestSetProp) {\n    const lifecycles = (<any>global)[globalLatestSetProp];\n    if (validateExportLifecycle(lifecycles)) {\n      return lifecycles;\n    }\n  }\n\n  // fallback to global variable who named with ${appName} while module exports not found\n  const globalVariableExports = (global as any)[appName];\n\n  if (validateExportLifecycle(globalVariableExports)) {\n    return globalVariableExports;\n  }\n\n  throw new QiankunError(`You need to export lifecycle functions in ${appName} entry`);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n scriptExports global[sandboxContainer?.instance?.latestSetProp]  global[appName] \n\n\n# \n\n\n# UMD\n\n getLifecyclesFromExports  qiankun  js   k  mountunmount  React  ReactDOM.render  Vue3  createApp().mount  js  UMD \n\n> UMD (Universal Module Definition),  ( AMD  CommonJS )\n\n:\n\n *  Node.js exports  Node.js \n *  AMDdefine  AMD \n * window  global\n\n UMD  github jQuery :\n\n// if the module has no dependencies, the above pattern can be simplified to\n(function (root, factory) {\n    // AMD\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n        // CJS\n    } else if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n      // Global\n        // Browser globals (root is window)\n        root.returnExports = factory();\n  }\n}(this, function () {\n\n    // Just return a value to define the module export.\n    // This example returns an object, but the module\n    // can return a function as the exported value.\n    return {};\n}));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n DI\n\n\n\n * [JavaScript] Javascript \n * Dependency Injection\n\n\n# \n\n\n#  id \n\n id UUID\n\n//  window\nexport const nativeGlobal = new Function('return this')();\n\n//  nativeGlobal   __app_instance_name_map__,  __app_instance_name_map__\n// once: Creates a function that is restricted to invoking func once. Repeat calls to the function return the value of the first call. The func is invoked with the this binding and arguments of the created function.\n// see https://www.lodashjs.com/docs/lodash.once\n// app instance id generator compatible with nested sandbox\n// genAppInstanceIdByName \nconst getGlobalAppInstanceMap = once<() => Record<string, number>>(() => {\n  if (!nativeGlobal.hasOwnProperty('__app_instance_name_map__')) {\n    Object.defineProperty(nativeGlobal, '__app_instance_name_map__', {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: {},\n    });\n  }\n\n  return nativeGlobal.__app_instance_name_map__;\n});\n/**\n *  id\n * Get app instance name with the auto-increment approach\n * @param appName\n */\nexport const genAppInstanceIdByName = (appName: string): string => {\n  //  map\n  const globalAppInstanceMap = getGlobalAppInstanceMap();\n  if (!(appName in globalAppInstanceMap)) {\n    nativeGlobal.__app_instance_name_map__[appName] = 0;\n    return appName;\n  }\n\n  globalAppInstanceMap[appName]++;\n  return `${appName}_${globalAppInstanceMap[appName]}`;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n#  window\n\nconst window = new Function('return this')();  window Function \n\n>  Function  Function  eval () \n\n\n\n * MDN: Function ",normalizedContent:"# \n\n\n\n * \n * loadapp\n   * createelement\n   * exechookschain\n   * getrender\n   * getlifecyclesfromexports\n * \n   * umd\n * \n   *  id \n *  window\n\n\n\n\n# loadapp\n\n  api loadapp  registermicroappsloadmicroapp  loadapp  start  s-spa  startsinglespa  start  start  start  loadmicroapp \n\n// src/loader.ts\n\nexport async function loadapp<t extends objecttype>(\n  // \n  app: loadableapp<t>,\n  // \n  configuration: frameworkconfiguration = {},\n  // \n  lifecycles?: frameworklifecycles<t>,\n): promise<parcelconfigobjectgetter> {\n  const { entry, name: appname } = app;\n  //  id\n  const appinstanceid = genappinstanceidbyname(appname);\n\n  const {\n    singular = false,\n    sandbox = true,\n    excludeassetfilter,\n    globalcontext = window,\n    ...importentryopts\n  } = configuration;\n  //  import-html-entry.importentry entry importentryopts \n  // get the entry html content and script executor\n  // template processed html template.\n  // execscripts(sandbox?: object, strictglobal?: boolean, execscriptshooks?: execscriptshooks): promise<unknown> - the return value is the last property on window or proxy window which set by the entry script.\n  // assetpublicpathpublic path for assets.\n  // see https://github.com/kuitos/import-html-entry#execscriptsentry-scripts-proxy-opts\n  const { template, execscripts, assetpublicpath } = await importentry(entry, importentryopts);\n\n  // as single-spa load and bootstrap new app parallel with other apps unmounting\n  // (see https://github.com/canopytax/single-spa/blob/master/src/navigation/reroute.js#l74)\n  // we need wait to load the app until all apps are finishing unmount in singular mode\n  // singular  singular\n  if (await validatesingularmode(singular, app)) {\n    // singular s-spa \n    await (prevappunmounteddeferred && prevappunmounteddeferred.promise);\n  }\n\n  //  curry function\n  // see https://jonsam.site/2021/09/01/js-tricks1/  curry function\n  const appcontent = getdefaulttplwrapper(appinstanceid)(template);\n\n  //  strictstyleisolation true shadowdom\n  // see https://qiankun.umijs.org/zh/api#startopts sandbox\n  const strictstyleisolation = typeof sandbox === 'object' && !!sandbox.strictstyleisolation;\n\n  //  experimentalstyleisolation shadowdom \n  const scopedcss = isenablescopedcss(sandbox);\n  // dom\n  let initialappwrapperelement: htmlelement | null = createelement(\n    appcontent,\n    strictstyleisolation,\n    scopedcss,\n    appinstanceid,\n  );\n\n  const initialcontainer = 'container' in app ? app.container : undefined;\n  const legacyrender = 'render' in app ? app.render : undefined;\n  // \n  const render = getrender(appinstanceid, appcontent, legacyrender);\n\n  //  dom \n  //  dom \n  //  dom \n  render({ element: initialappwrapperelement, loading: true, container: initialcontainer }, 'loading');\n  // \n  const initialappwrappergetter = getappwrappergetter(\n    appinstanceid,\n    !!legacyrender,\n    strictstyleisolation,\n    scopedcss,\n    () => initialappwrapperelement,\n  );\n  //  globalcontext window\n  let global = globalcontext;\n  let mountsandbox = () => promise.resolve();\n  let unmountsandbox = () => promise.resolve();\n  //  loose \n  const useloosesandbox = typeof sandbox === 'object' && !!sandbox.loose;\n  let sandboxcontainer;\n  if (sandbox) {\n    // \n    sandboxcontainer = createsandboxcontainer(\n      appinstanceid,\n      // fixme should use a strict sandbox logic while remount, see https://github.com/umijs/qiankun/issues/518\n      initialappwrappergetter,\n      scopedcss,\n      useloosesandbox,\n      // \n      excludeassetfilter,\n      global,\n    );\n    // mount  unmount \n    // \n    global = sandboxcontainer.instance.proxy as typeof window;\n    mountsandbox = sandboxcontainer.mount;\n    unmountsandbox = sandboxcontainer.unmount;\n  }\n\n  const { beforeunmount = [], afterunmount = [], aftermount = [], beforemount = [], beforeload = [] } =\n    // mergewith this method is like _.merge except that it accepts customizer which is invoked to produce the merged values of the destination and source properties. if customizer returns undefined merging is handled by the method instead.\n    // see https://lodash.com/docs/4.17.15#mergewith\n    // concat creates a new array concatenating array with any additional arrays and/or values.\n    // \n    mergewith({}, getaddons(global, assetpublicpath), lifecycles, (v1, v2) => concat(v1 ?? [], v2 ?? []));\n  //  beforeload  beforeload \n  await exechookschain(toarray(beforeload), app, global);\n\n  // get the lifecycle hooks from module exports\n  //  js  js  global lose  js \n  // scriptexports  js  js  umd\n  // \n  const scriptexports: any = await execscripts(global, sandbox && !useloosesandbox);\n  // \n  const { bootstrap, mount, unmount, update } = getlifecyclesfromexports(\n    scriptexports,\n    appname,\n    global,\n    //  latestsetprop execscripts  global  instance?.latestsetprop  umd \n    sandboxcontainer?.instance?.latestsetprop,\n  );\n  //  globalstate  deps \n  //  appinstanceid  appinstanceid global id\n  const { onglobalstatechange, setglobalstate, offglobalstatechange }: record<string, callablefunction> =\n    getmicroappstateactions(appinstanceid);\n\n  // fixme temporary way\n  const syncappwrapperelement2sandbox = (element: htmlelement | null) => (initialappwrapperelement = element);\n\n  // container \n  // loadapp  parcelconfiggetter container  s-spa \n  //  curry function \n  const parcelconfiggetter: parcelconfigobjectgetter = (remountcontainer = initialcontainer) => {\n    let appwrapperelement: htmlelement | null;\n    let appwrappergetter: returntype<typeof getappwrappergetter>;\n\n    //  s-spa.mountrootparcel \n    const parcelconfig: parcelconfigobject = {\n      name: appinstanceid,\n      // bootstrap, mount, unmount, update \n      bootstrap,\n      //  mount async s-spa await\n      mount: [\n        //  singular \n        async () => {\n          if ((await validatesingularmode(singular, app)) && prevappunmounteddeferred) {\n            return prevappunmounteddeferred.promise;\n          }\n\n          return undefined;\n        },\n        // initial wrapper element before app mount/remount\n        //  getter \n        async () => {\n          appwrapperelement = initialappwrapperelement;\n          appwrappergetter = getappwrappergetter(\n            appinstanceid,\n            !!legacyrender,\n            strictstyleisolation,\n            scopedcss,\n            () => appwrapperelement,\n          );\n        },\n        //  mount hook,  dom \n        async () => {\n          const usenewcontainer = remountcontainer !== initialcontainer;\n          //  initialappwrapperelement\n          if (usenewcontainer || !appwrapperelement) {\n            // element will be destroyed after unmounted, we need to recreate it if it not exist\n            // or we try to remount into a new container\n            appwrapperelement = createelement(appcontent, strictstyleisolation, scopedcss, appinstanceid);\n            syncappwrapperelement2sandbox(appwrapperelement);\n          }\n          //  dom  mounting\n          render({ element: appwrapperelement, loading: true, container: remountcontainer }, 'mounting');\n        },\n        //  mount \n        mountsandbox,\n        //  beforemount\n        // exec the chain after rendering to keep the behavior with beforeload\n        async () => exechookschain(toarray(beforemount), app, global),\n        //  s-spa  mount  mount  setglobalstate  onglobalstatechange \n        async (props) => mount({ ...props, container: appwrappergetter(), setglobalstate, onglobalstatechange }),\n        // finish loading after app mounted\n        //  dom  mounted\n        async () => render({ element: appwrapperelement, loading: false, container: remountcontainer }, 'mounted'),\n        //  aftermount\n        async () => exechookschain(toarray(aftermount), app, global),\n        // initialize the unmount defer after app mounted and resolve the defer after it unmounted\n        async () => {\n          if (await validatesingularmode(singular, app)) {\n            //  mount prevappunmounteddeferred\n            prevappunmounteddeferred = new deferred<void>();\n          }\n        },\n      ],\n      unmount: [\n        //  beforeunmount\n        async () => exechookschain(toarray(beforeunmount), app, global),\n        //  unmount\n        async (props) => unmount({ ...props, container: appwrappergetter() }),\n        // \n        unmountsandbox,\n        //  afterunmount\n        async () => exechookschain(toarray(afterunmount), app, global),\n        async () => {\n          //  unmounted\n          render({ element: null, loading: false, container: remountcontainer }, 'unmounted');\n          // effect\n          offglobalstatechange(appinstanceid);\n          //  appwrapperelement  initialappwrapperelement\n          // for gc\n          appwrapperelement = null;\n          syncappwrapperelement2sandbox(appwrapperelement);\n        },\n        async () => {\n          if ((await validatesingularmode(singular, app)) && prevappunmounteddeferred) {\n            // unmount resolve prevappunmounteddeferred\n            prevappunmounteddeferred.resolve();\n          }\n        },\n      ],\n    };\n    //  update  entry  update \n    if (typeof update === 'function') {\n      parcelconfig.update = update;\n    }\n\n    return parcelconfig;\n  };\n\n  return parcelconfiggetter;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n\n\n\n\n *  s-spa \n *  mount  unmount \n * \n *  effect\n\n\n# createelement\n\ncreateelement \n\nconst supportshadowdom = document.head.attachshadow || document.head.createshadowroot;\n\nfunction createelement(\n  appcontent: string,\n  strictstyleisolation: boolean,\n  scopedcss: boolean,\n  appinstanceid: string,\n): htmlelement {\n  const containerelement = document.createelement('div');\n  containerelement.innerhtml = appcontent;\n  // appcontent always wrapped with a singular div\n  const appelement = containerelement.firstchild as htmlelement;\n  if (strictstyleisolation) {\n    if (!supportshadowdom) {\n      console.warn(\n        '[qiankun]: as current browser not support shadow dom, your strictstyleisolation configuration will be ignored!',\n      );\n    } else {\n      const { innerhtml } = appelement;\n      appelement.innerhtml = '';\n      let shadow: shadowroot;\n      // attachshadow  shadowdom v1 \n      if (appelement.attachshadow) {\n        //  shadowdom\n        shadow = appelement.attachshadow({ mode: 'open' });\n      } else {\n        // createshadowroot  shadowdom v0 \n        // createshadowroot was proposed in initial spec, which has then been deprecated\n        shadow = (appelement as any).createshadowroot();\n      }\n      shadow.innerhtml = innerhtml;\n    }\n  }\n\n  if (scopedcss) {\n    const attr = appelement.getattribute(css.qiankuncssrewriteattr);\n    if (!attr) {\n      appelement.setattribute(css.qiankuncssrewriteattr, appinstanceid);\n    }\n    //  scopedcss appelement \n    const stylenodes = appelement.queryselectorall('style') || [];\n    foreach(stylenodes, (stylesheetelement: htmlstyleelement) => {\n      css.process(appelement!, stylesheetelement, appinstanceid);\n    });\n  }\n\n  return appelement;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n *  strictstyleisolation shadowdom \n *  scopedcss\n\n\n# exechookschain\n\nexechookschain \n\nfunction exechookschain<t extends objecttype>(\n  hooks: array<lifecyclefn<t>>,\n  app: loadableapp<t>,\n  global = window,\n): promise<any> {\n  if (hooks.length) {\n    return hooks.reduce((chain, hook) => chain.then(() => hook(app, global)), promise.resolve());\n  }\n\n  return promise.resolve();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nexechookschain  promise  promise promise.then  hook promise.resolve().then(() => {})  promise reduce  hook  hook  promise\n\n/**\n * represents the completion of an asynchronous operation\n */\ninterface promise<t> {\n    /**\n     * attaches callbacks for the resolution and/or rejection of the promise.\n     * @param onfulfilled the callback to execute when the promise is resolved.\n     * @param onrejected the callback to execute when the promise is rejected.\n     * @returns a promise for the completion of which ever callback is executed.\n     */\n    then<tresult1 = t, tresult2 = never>(onfulfilled?: ((value: t) => tresult1 | promiselike<tresult1>) | undefined | null, onrejected?: ((reason: any) => tresult2 | promiselike<tresult2>) | undefined | null): promise<tresult1 | tresult2>;\n\n    /**\n     * attaches a callback for only the rejection of the promise.\n     * @param onrejected the callback to execute when the promise is rejected.\n     * @returns a promise for the completion of the callback.\n     */\n    catch<tresult = never>(onrejected?: ((reason: any) => tresult | promiselike<tresult>) | undefined | null): promise<t | tresult>;\n     /**\n     * attaches a callback that is invoked when the promise is settled (fulfilled or rejected). the\n     * resolved value cannot be modified from the callback.\n     * @param onfinally the callback to execute when the promise is settled (fulfilled or rejected).\n     * @returns a promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): promise<t | tresult>\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n promise thencatchfinally  promise\n\n\n# getrender\n\n dom \n\n\nconst rawappendchild = htmlelement.prototype.appendchild;\nconst rawremovechild = htmlelement.prototype.removechild;\n/**\n * get the render function\n * if the legacy render function is provide, used as it, otherwise we will insert the app element to target container by qiankun\n * @param appinstanceid\n * @param appcontent\n * @param legacyrender\n */\nfunction getrender(appinstanceid: string, appcontent: string, legacyrender?: htmlcontentrender) {\n  const render: elementrender = ({ element, loading, container }, phase) => {\n    if (legacyrender) {\n      return legacyrender({ loading, appcontent: element ? appcontent : '' });\n    }\n    // \n    const containerelement = getcontainer(container!);\n\n    // the container might have be removed after micro app unmounted.\n    // such as the micro app unmount lifecycle called by a react componentwillunmount lifecycle, after micro app unmounted, the react component might also be removed\n    if (phase !== 'unmounted') {\n      // \n      const errormsg = (() => {\n        switch (phase) {\n          case 'loading':\n          case 'mounting':\n            return `target container with ${container} not existed while ${appinstanceid} ${phase}!`;\n\n          case 'mounted':\n            return `target container with ${container} not existed after ${appinstanceid} ${phase}!`;\n\n          default:\n            return `target container with ${container} not existed while ${appinstanceid} rendering!`;\n        }\n      })();\n      assertelementexist(containerelement, errormsg);\n    }\n\n    if (containerelement && !containerelement.contains(element)) {\n      // \n      // clear the container\n      while (containerelement!.firstchild) {\n        rawremovechild.call(containerelement, containerelement!.firstchild);\n      }\n      // \n      // append the element to container if it exist\n      if (element) {\n        rawappendchild.call(containerelement, element);\n      }\n    }\n\n    return undefined;\n  };\n\n  return render;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# getlifecyclesfromexports\n\ngetlifecyclesfromexports  js \n\n/**    */\nexport function validateexportlifecycle(exports: any) {\n  const { bootstrap, mount, unmount } = exports ?? {};\n  return isfunction(bootstrap) && isfunction(mount) && isfunction(unmount);\n}\n\nfunction getlifecyclesfromexports(\n  scriptexports: lifecycles<any>,\n  appname: string,\n  global: windowproxy,\n  globallatestsetprop?: propertykey | null,\n) {\n  if (validateexportlifecycle(scriptexports)) {\n    return scriptexports;\n  }\n\n  // fallback to sandbox latest set property if it had\n  if (globallatestsetprop) {\n    const lifecycles = (<any>global)[globallatestsetprop];\n    if (validateexportlifecycle(lifecycles)) {\n      return lifecycles;\n    }\n  }\n\n  // fallback to global variable who named with ${appname} while module exports not found\n  const globalvariableexports = (global as any)[appname];\n\n  if (validateexportlifecycle(globalvariableexports)) {\n    return globalvariableexports;\n  }\n\n  throw new qiankunerror(`you need to export lifecycle functions in ${appname} entry`);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n scriptexports global[sandboxcontainer?.instance?.latestsetprop]  global[appname] \n\n\n# \n\n\n# umd\n\n getlifecyclesfromexports  qiankun  js   k  mountunmount  react  reactdom.render  vue3  createapp().mount  js  umd \n\n> umd (universal module definition),  ( amd  commonjs )\n\n:\n\n *  node.js exports  node.js \n *  amddefine  amd \n * window  global\n\n umd  github jquery :\n\n// if the module has no dependencies, the above pattern can be simplified to\n(function (root, factory) {\n    // amd\n    if (typeof define === 'function' && define.amd) {\n        // amd. register as an anonymous module.\n        define([], factory);\n        // cjs\n    } else if (typeof exports === 'object') {\n        // node. does not work with strict commonjs, but\n        // only commonjs-like environments that support module.exports,\n        // like node.\n        module.exports = factory();\n    } else {\n      // global\n        // browser globals (root is window)\n        root.returnexports = factory();\n  }\n}(this, function () {\n\n    // just return a value to define the module export.\n    // this example returns an object, but the module\n    // can return a function as the exported value.\n    return {};\n}));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n di\n\n\n\n * [javascript] javascript \n * dependency injection\n\n\n# \n\n\n#  id \n\n id uuid\n\n//  window\nexport const nativeglobal = new function('return this')();\n\n//  nativeglobal   __app_instance_name_map__,  __app_instance_name_map__\n// once: creates a function that is restricted to invoking func once. repeat calls to the function return the value of the first call. the func is invoked with the this binding and arguments of the created function.\n// see https://www.lodashjs.com/docs/lodash.once\n// app instance id generator compatible with nested sandbox\n// genappinstanceidbyname \nconst getglobalappinstancemap = once<() => record<string, number>>(() => {\n  if (!nativeglobal.hasownproperty('__app_instance_name_map__')) {\n    object.defineproperty(nativeglobal, '__app_instance_name_map__', {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: {},\n    });\n  }\n\n  return nativeglobal.__app_instance_name_map__;\n});\n/**\n *  id\n * get app instance name with the auto-increment approach\n * @param appname\n */\nexport const genappinstanceidbyname = (appname: string): string => {\n  //  map\n  const globalappinstancemap = getglobalappinstancemap();\n  if (!(appname in globalappinstancemap)) {\n    nativeglobal.__app_instance_name_map__[appname] = 0;\n    return appname;\n  }\n\n  globalappinstancemap[appname]++;\n  return `${appname}_${globalappinstancemap[appname]}`;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n#  window\n\nconst window = new function('return this')();  window function \n\n>  function  function  eval () \n\n\n\n * mdn: function ",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"addon",frontmatter:{title:"addon",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/core/addon/",categories:["qiankun","core"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/10.core/60.addon.html",relativePath:"30.web/6.qiankun/10.core/60.addon.md",key:"v-4956ba5f",path:"/qiankun/core/addon/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/sandbox/index/",categories:["qiankun","sandbox"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/20.sandbox/0.index.html",relativePath:"30.web/6.qiankun/20.sandbox/0.index.md",key:"v-a0fcd902",path:"/qiankun/sandbox/index/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:3,title:"CSS ",slug:"css-",normalizedTitle:"css ",charIndex:25},{level:3,title:"JS ",slug:"js-",normalizedTitle:"js ",charIndex:37},{level:2,title:"Shadow DOM",slug:"shadow-dom",normalizedTitle:"shadow dom",charIndex:46},{level:2,title:"WindowProxy",slug:"windowproxy",normalizedTitle:"windowproxy",charIndex:60},{level:2,title:"Object.getOwnPropertyDescriptor()",slug:"object-getownpropertydescriptor",normalizedTitle:"object.getownpropertydescriptor()",charIndex:75},{level:2,title:"Window.top/parent/self/window",slug:"window-top-parent-self-window",normalizedTitle:"window.top/parent/self/window",charIndex:112}],readingTime:{text:"2 min read",minutes:1.37,time:82200,words:274},headersStr:"  CSS  JS  Shadow DOM WindowProxy Object.getOwnPropertyDescriptor() Window.top/parent/self/window",content:"# \n\n\n\n * \n * \n   * CSS \n   * JS \n * Shadow DOM\n * WindowProxy\n * Object.getOwnPropertyDescriptor()\n * Window.top/parent/self/window\n\n\n\n\n# \n\n CSS  JS  JS  CSS  JS \n\n\n# CSS \n\n CSS \n\n * BEM CSS CSS class \n * Module CSS CSS  CSS  scope \n * CSS In JSCSS-in-JS  CSS Unique Selector VS Inline Styles CSS CSS in JS \n * ShadowDOM\n * namespace\n * Dynamic StyleSheet\n\n\n# JS \n\n * ProxySandbox\n * SnapshotSandbox\n\n\n# Shadow DOM\n\n> Method of establishing and maintaining functional boundaries between DOM trees and how these trees interact with each other within a document, thus enabling better functional encapsulation within the DOM & CSS.\n\nWeb components   Shadow DOM  DOM \n\n\n\nShadow DOM  IE  polyfill \n\n\n\n * Using shadow DOM\n *  Shadow DOM v1\n\n\n\n * 15  qiankun  js \n\n\n# WindowProxy\n\n> A WindowProxy object is a wrapper for a Window object. A WindowProxy object exists in every browsing context. All operations performed on a WindowProxy object will also be applied to the underlying Window object it currently wraps. Therefore, interacting with a WindowProxy object is almost identical to directly interacting with a Window object. When a browsing context is navigated, the Window object its WindowProxy wraps is changed.\n\n\n\n * WIKIWindowProxy\n\n\n# Object.getOwnPropertyDescriptor()\n\n> Object.getOwnPropertyDescriptor () \n\n Javascript    name property descriptorObject.defineProperty.\n\n * MDN: Object.getOwnPropertyDescriptor()\n\nObject.defineProperty(obj, prop, descriptor)\n\n\n1\n\n\n\n# Window.top/parent/self/window\n\n * Window.top: Returns a reference to the topmost window in the window hierarchy. This property is read only.\n * Window.parent\n * Window.self: Returns an object reference to the window object itself.\n * Window.window: Returns a reference to the current window.\n\n\n\n * MDNWindow",normalizedContent:"# \n\n\n\n * \n * \n   * css \n   * js \n * shadow dom\n * windowproxy\n * object.getownpropertydescriptor()\n * window.top/parent/self/window\n\n\n\n\n# \n\n css  js  js  css  js \n\n\n# css \n\n css \n\n * bem css css class \n * module css css  css  scope \n * css in jscss-in-js  css unique selector vs inline styles css css in js \n * shadowdom\n * namespace\n * dynamic stylesheet\n\n\n# js \n\n * proxysandbox\n * snapshotsandbox\n\n\n# shadow dom\n\n> method of establishing and maintaining functional boundaries between dom trees and how these trees interact with each other within a document, thus enabling better functional encapsulation within the dom & css.\n\nweb components   shadow dom  dom \n\n\n\nshadow dom  ie  polyfill \n\n\n\n * using shadow dom\n *  shadow dom v1\n\n\n\n * 15  qiankun  js \n\n\n# windowproxy\n\n> a windowproxy object is a wrapper for a window object. a windowproxy object exists in every browsing context. all operations performed on a windowproxy object will also be applied to the underlying window object it currently wraps. therefore, interacting with a windowproxy object is almost identical to directly interacting with a window object. when a browsing context is navigated, the window object its windowproxy wraps is changed.\n\n\n\n * wikiwindowproxy\n\n\n# object.getownpropertydescriptor()\n\n> object.getownpropertydescriptor () \n\n javascript    name property descriptorobject.defineproperty.\n\n * mdn: object.getownpropertydescriptor()\n\nobject.defineproperty(obj, prop, descriptor)\n\n\n1\n\n\n\n# window.top/parent/self/window\n\n * window.top: returns a reference to the topmost window in the window hierarchy. this property is read only.\n * window.parent\n * window.self: returns an object reference to the window object itself.\n * window.window: returns a reference to the current window.\n\n\n\n * mdnwindow",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"createSandboxContainer ",frontmatter:{title:"createSandboxContainer ",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/sandbox/sandbox/",categories:["qiankun","sandbox"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/20.sandbox/10.sandbox.html",relativePath:"30.web/6.qiankun/20.sandbox/10.sandbox.md",key:"v-b7416126",path:"/qiankun/sandbox/sandbox/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"createSandboxContainer",slug:"createsandboxcontainer",normalizedTitle:"createsandboxcontainer",charIndex:17}],readingTime:{text:"3 min read",minutes:2.4,time:144e3,words:480},headersStr:" createSandboxContainer",content:"# \n\n\n\n * \n * createSandboxContainer\n\n\n\n\n# createSandboxContainer\n\ncreateSandboxContainer  patch \n\n// src/sandbox/index.ts\n/**\n * \n *\n * \n * 1. app \n *  app  bootstrap \n *   app \n * 2. render \n *   app mount render \n *\n *  bootstrap \n *\n * @param appName\n * @param elementGetter\n * @param scopedCSS\n * @param useLooseSandbox\n * @param excludeAssetFilter\n * @param globalContext\n */\nexport function createSandboxContainer(\n  appName: string,\n  // \n  elementGetter: () => HTMLElement | ShadowRoot,\n  //  scopedCSS\n  scopedCSS: boolean,\n  //  lose mode sandbox\n  useLooseSandbox?: boolean,\n  // \n  excludeAssetFilter?: (url: string) => boolean,\n  // global env\n  globalContext?: typeof window,\n) {\n  let sandbox: SandBox;\n  // \n  if (window.Proxy) {\n    // lose mode \n    sandbox = useLooseSandbox ? new LegacySandbox(appName, globalContext) : new ProxySandbox(appName, globalContext);\n  } else {\n    //  Proxy API \n    sandbox = new SnapshotSandbox(appName);\n  }\n\n  // some side effect could be be invoked while bootstrapping, such as dynamic stylesheet injection with style-loader, especially during the development phase\n  // bootstrap \n  const bootstrappingFreers = patchAtBootstrapping(appName, elementGetter, sandbox, scopedCSS, excludeAssetFilter);\n  // mounting freers are one-off and should be re-init at every mounting time\n  let mountingFreers: Freer[] = [];\n\n  let sideEffectsRebuilders: Rebuilder[] = [];\n\n  return {\n    // sandbox \n    instance: sandbox,\n\n    /**\n     *  mount\n     *  bootstrap  mount\n     *  unmount  mount\n     */\n    async mount() {\n      /* ------------------------------------------ window ------------------------------------------ */\n\n      /* ------------------------------------------ 1. / ------------------------------------------ */\n      sandbox.active();\n      //  bootstrapping  mounting  bootstrappingFreers.length  sideEffectsRebuilders  bootstrappingFreers \n      const sideEffectsRebuildersAtBootstrapping = sideEffectsRebuilders.slice(0, bootstrappingFreers.length);\n      const sideEffectsRebuildersAtMounting = sideEffectsRebuilders.slice(bootstrappingFreers.length);\n\n      // must rebuild the side effects which added at bootstrapping firstly to recovery to nature state\n      //  bootstrapping \n      if (sideEffectsRebuildersAtBootstrapping.length) {\n        sideEffectsRebuildersAtBootstrapping.forEach((rebuild) => rebuild());\n      }\n\n      /* ------------------------------------------ 2.  ------------------------------------------*/\n      // render  / \n      // mount  patch \n      mountingFreers = patchAtMounting(appName, elementGetter, sandbox, scopedCSS, excludeAssetFilter);\n\n      /* ------------------------------------------ 3.  ------------------------------------------*/\n      //  rebuilder \n      //  mounting \n      if (sideEffectsRebuildersAtMounting.length) {\n        sideEffectsRebuildersAtMounting.forEach((rebuild) => rebuild());\n      }\n\n      // clean up rebuilders\n      //  mounting  bootstrapping  sideEffectsRebuilders\n      sideEffectsRebuilders = [];\n    },\n\n    /**\n     *  global \n     */\n    async unmount() {\n      // record the rebuilders of window side effects (event listeners or timers)\n      // note that the frees of mounting phase are one-off as it will be re-init at next mounting\n      //  bootstrapping  mounting  rebuild \n      //  rebuild  bootstrapping  mounting  patch  freer()\n      //  mount  createSandboxContainer sandbox  sandbox  mount \n      sideEffectsRebuilders = [...bootstrappingFreers, ...mountingFreers].map((free) => free());\n      // \n      sandbox.inactive();\n    },\n  };\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n\n\n\n * lose  LegacySandbox Proxy API  ProxySandbox SnapshotSandbox\n *  patch \n *  bootstrapping  mounting patch  mount  patch  patch unmount  patch patch ",normalizedContent:"# \n\n\n\n * \n * createsandboxcontainer\n\n\n\n\n# createsandboxcontainer\n\ncreatesandboxcontainer  patch \n\n// src/sandbox/index.ts\n/**\n * \n *\n * \n * 1. app \n *  app  bootstrap \n *   app \n * 2. render \n *   app mount render \n *\n *  bootstrap \n *\n * @param appname\n * @param elementgetter\n * @param scopedcss\n * @param useloosesandbox\n * @param excludeassetfilter\n * @param globalcontext\n */\nexport function createsandboxcontainer(\n  appname: string,\n  // \n  elementgetter: () => htmlelement | shadowroot,\n  //  scopedcss\n  scopedcss: boolean,\n  //  lose mode sandbox\n  useloosesandbox?: boolean,\n  // \n  excludeassetfilter?: (url: string) => boolean,\n  // global env\n  globalcontext?: typeof window,\n) {\n  let sandbox: sandbox;\n  // \n  if (window.proxy) {\n    // lose mode \n    sandbox = useloosesandbox ? new legacysandbox(appname, globalcontext) : new proxysandbox(appname, globalcontext);\n  } else {\n    //  proxy api \n    sandbox = new snapshotsandbox(appname);\n  }\n\n  // some side effect could be be invoked while bootstrapping, such as dynamic stylesheet injection with style-loader, especially during the development phase\n  // bootstrap \n  const bootstrappingfreers = patchatbootstrapping(appname, elementgetter, sandbox, scopedcss, excludeassetfilter);\n  // mounting freers are one-off and should be re-init at every mounting time\n  let mountingfreers: freer[] = [];\n\n  let sideeffectsrebuilders: rebuilder[] = [];\n\n  return {\n    // sandbox \n    instance: sandbox,\n\n    /**\n     *  mount\n     *  bootstrap  mount\n     *  unmount  mount\n     */\n    async mount() {\n      /* ------------------------------------------ window ------------------------------------------ */\n\n      /* ------------------------------------------ 1. / ------------------------------------------ */\n      sandbox.active();\n      //  bootstrapping  mounting  bootstrappingfreers.length  sideeffectsrebuilders  bootstrappingfreers \n      const sideeffectsrebuildersatbootstrapping = sideeffectsrebuilders.slice(0, bootstrappingfreers.length);\n      const sideeffectsrebuildersatmounting = sideeffectsrebuilders.slice(bootstrappingfreers.length);\n\n      // must rebuild the side effects which added at bootstrapping firstly to recovery to nature state\n      //  bootstrapping \n      if (sideeffectsrebuildersatbootstrapping.length) {\n        sideeffectsrebuildersatbootstrapping.foreach((rebuild) => rebuild());\n      }\n\n      /* ------------------------------------------ 2.  ------------------------------------------*/\n      // render  / \n      // mount  patch \n      mountingfreers = patchatmounting(appname, elementgetter, sandbox, scopedcss, excludeassetfilter);\n\n      /* ------------------------------------------ 3.  ------------------------------------------*/\n      //  rebuilder \n      //  mounting \n      if (sideeffectsrebuildersatmounting.length) {\n        sideeffectsrebuildersatmounting.foreach((rebuild) => rebuild());\n      }\n\n      // clean up rebuilders\n      //  mounting  bootstrapping  sideeffectsrebuilders\n      sideeffectsrebuilders = [];\n    },\n\n    /**\n     *  global \n     */\n    async unmount() {\n      // record the rebuilders of window side effects (event listeners or timers)\n      // note that the frees of mounting phase are one-off as it will be re-init at next mounting\n      //  bootstrapping  mounting  rebuild \n      //  rebuild  bootstrapping  mounting  patch  freer()\n      //  mount  createsandboxcontainer sandbox  sandbox  mount \n      sideeffectsrebuilders = [...bootstrappingfreers, ...mountingfreers].map((free) => free());\n      // \n      sandbox.inactive();\n    },\n  };\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n\n\n\n * lose  legacysandbox proxy api  proxysandbox snapshotsandbox\n *  patch \n *  bootstrapping  mounting patch  mount  patch  patch unmount  patch patch ",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"proxySandbox",frontmatter:{title:"proxySandbox",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/sandbox/proxySandbox/",categories:["qiankun","sandbox"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/20.sandbox/20.proxySandbox.html",relativePath:"30.web/6.qiankun/20.sandbox/20.proxySandbox.md",key:"v-353fcddf",path:"/qiankun/sandbox/proxySandbox/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"ProxySandbox",slug:"proxysandbox",normalizedTitle:"proxysandbox",charIndex:17},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:33},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:43},{level:2,title:" JS",slug:"-js",normalizedTitle:" js",charIndex:60},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:76},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:91},{level:2,title:"createFakeWindow",slug:"createfakewindow",normalizedTitle:"createfakewindow",charIndex:106},{level:2,title:"Proxy Handlers",slug:"proxy-handlers",normalizedTitle:"proxy handlers",charIndex:126},{level:2,title:"getTargetValue",slug:"gettargetvalue",normalizedTitle:"gettargetvalue",charIndex:144}],readingTime:{text:"10 min read",minutes:9.3,time:558e3,words:1860},headersStr:" ProxySandbox    JS   createFakeWindow Proxy Handlers getTargetValue",content:"# \n\n\n\n * \n * ProxySandbox\n * \n * \n *  JS\n * \n * \n * createFakeWindow\n * Proxy Handlers\n * getTargetValue\n\n\n\n\n# ProxySandbox\n\n JS  ProxySandbox \n\ntype FakeWindow = Window & Record<PropertyKey, any>;\n\n/**\n * fastest(at most time) unique array method\n * @see https://jsperf.com/array-filter-unique/30\n */\nfunction uniq(array: Array<string | symbol>) {\n  return array.filter(function filter(this: PropertyKey[], element) {\n    return element in this ? false : ((this as any)[element] = true);\n  }, Object.create(null));\n}\n\n// zone.js will overwrite Object.defineProperty\nconst rawObjectDefineProperty = Object.defineProperty;\n\n// who could escape the sandbox\n//  globalContext \nconst variableWhiteList: PropertyKey[] = [\n  // FIXME System.js used a indirect call with eval, which would make it scope escape to global\n  // To make System.js works well, we write it back to global window temporary\n  // see https://github.com/systemjs/systemjs/blob/457f5b7e8af6bd120a279540477552a07d5de086/src/evaluate.js#L106\n  'System',\n\n  // see https://github.com/systemjs/systemjs/blob/457f5b7e8af6bd120a279540477552a07d5de086/src/instantiate.js#L357\n  '__cjsWrapper',\n];\n\n/*\n variables who are impossible to be overwrite need to be escaped from proxy sandbox for performance reasons\n ProxyWindow\n */\nconst unscopables = {\n  undefined: true,\n  Array: true,\n  Object: true,\n  String: true,\n  Boolean: true,\n  Math: true,\n  Number: true,\n  Symbol: true,\n  parseFloat: true,\n  Float32Array: true,\n  isNaN: true,\n  Infinity: true,\n  Reflect: true,\n  Float64Array: true,\n  Function: true,\n  Map: true,\n  NaN: true,\n  Promise: true,\n  Proxy: true,\n  Set: true,\n  parseInt: true,\n  requestAnimationFrame: true,\n};\n\nconst useNativeWindowForBindingsProps = new Map<PropertyKey, boolean>([\n  ['fetch', true],\n  ['mockDomAPIInBlackList', process.env.NODE_ENV === 'test'],\n]);\n\nfunction createFakeWindow(globalContext: Window) {\n  // map always has the fastest performance in has check scenario\n  // see https://jsperf.com/array-indexof-vs-set-has/23\n  //  get Map \n  const propertiesWithGetter = new Map<PropertyKey, boolean>();\n  const fakeWindow = {} as FakeWindow;\n\n  /*\n   copy the non-configurable property of global to fakeWindow\n    global  fakeWindow\n   see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor\n   > A property cannot be reported as non-configurable, if it does not exists as an own property of the target object or if it exists as a configurable own property of the target object.\n  //  \n   */\n  Object.getOwnPropertyNames(globalContext)\n    //  global \n    .filter((p) => {\n      const descriptor = Object.getOwnPropertyDescriptor(globalContext, p);\n      return !descriptor?.configurable;\n    })\n    // \n    .forEach((p) => {\n      const descriptor = Object.getOwnPropertyDescriptor(globalContext, p);\n      if (descriptor) {\n        //  get\n        const hasGetter = Object.prototype.hasOwnProperty.call(descriptor, 'get');\n\n        /*\n         make top/self/window property configurable and writable, otherwise it will cause TypeError while get trap return.\n         see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/get\n         > The value reported for a property must be the same as the value of the corresponding target object property if the target object property is a non-writable, non-configurable data property.\n        //  \n        //  Window \n         */\n        if (\n          p === 'top' ||\n          p === 'parent' ||\n          p === 'self' ||\n          p === 'window' ||\n          (process.env.NODE_ENV === 'test' && (p === 'mockTop' || p === 'mockSafariTop'))\n        ) {\n          descriptor.configurable = true;\n          /*\n           The descriptor of window.window/window.top/window.self in Safari/FF are accessor descriptors, we need to avoid adding a data descriptor while it was\n           Example:\n            Safari/FF: Object.getOwnPropertyDescriptor(window, 'top') -> {get: function, set: undefined, enumerable: true, configurable: false}\n            Chrome: Object.getOwnPropertyDescriptor(window, 'top') -> {value: Window, writable: false, enumerable: true, configurable: false}\n           */\n          if (!hasGetter) {\n            descriptor.writable = true;\n          }\n        }\n\n        if (hasGetter) propertiesWithGetter.set(p, true);\n\n        // freeze the descriptor to avoid being modified by zone.js\n        // see https://github.com/angular/zone.js/blob/a5fe09b0fac27ac5df1fa746042f96f05ccb6a00/lib/browser/define-property.ts#L71\n        //  fakeWindow \n        rawObjectDefineProperty(fakeWindow, p, Object.freeze(descriptor));\n      }\n    });\n\n  return {\n    fakeWindow,\n    propertiesWithGetter,\n  };\n}\n\n// count  ProxySandbox \nlet activeSandboxCount = 0;\n\n/**\n *  Proxy \n */\nexport default class ProxySandbox implements SandBox {\n  /** window  */\n  private updatedValueSet = new Set<PropertyKey>();\n\n  name: string;\n\n  type: SandBoxType;\n\n  proxy: WindowProxy;\n\n  globalContext: typeof window;\n  // running  true running inactive \n  sandboxRunning = true;\n\n  latestSetProp: PropertyKey | null = null;\n\n  // \n  private registerRunningApp(name: string, proxy: Window) {\n    if (this.sandboxRunning) {\n      const currentRunningApp = getCurrentRunningApp();\n      if (!currentRunningApp || currentRunningApp.name !== name) {\n        setCurrentRunningApp({ name, window: proxy });\n      }\n      // FIXME if you have any other good ideas\n      // remove the mark in next tick, thus we can identify whether it in micro app or not\n      // this approach is just a workaround, it could not cover all complex cases, such as the micro app runs in the same task context with master in some case\n      // TODO \n      nextTask(() => {\n        setCurrentRunningApp(null);\n      });\n    }\n  }\n\n  active() {\n    //  1 (inactive) 1\n    if (!this.sandboxRunning) activeSandboxCount++;\n    this.sandboxRunning = true;\n  }\n\n  inactive() {\n    if (process.env.NODE_ENV === 'development') {\n      console.info(`[qiankun:sandbox] ${this.name} modified global properties restore...`, [\n        ...this.updatedValueSet.keys(),\n      ]);\n    }\n    // activeSandboxCount  1 proxyWindow \n    if (--activeSandboxCount === 0) {\n      variableWhiteList.forEach((p) => {\n        if (this.proxy.hasOwnProperty(p)) {\n          // @ts-ignore\n          delete this.globalContext[p];\n        }\n      });\n    }\n\n    this.sandboxRunning = false;\n  }\n\n  constructor(name: string, globalContext = window) {\n    this.name = name;\n    this.globalContext = globalContext;\n    //  Proxy\n    this.type = SandBoxType.Proxy;\n    const { updatedValueSet } = this;\n    //  globalContext  FakeWindow\n    const { fakeWindow, propertiesWithGetter } = createFakeWindow(globalContext);\n\n    const descriptorTargetMap = new Map<PropertyKey, SymbolTarget>();\n    const hasOwnProperty = (key: PropertyKey) => fakeWindow.hasOwnProperty(key) || globalContext.hasOwnProperty(key);\n    //  fakeWindow  proxyWindow\n    const proxy = new Proxy(fakeWindow, {\n      //  setter\n      set: (target: FakeWindow, p: PropertyKey, value: any): boolean => {\n        // unmount \n        if (this.sandboxRunning) {\n          //  nestTick \n          this.registerRunningApp(name, proxy);\n          // We must kept its description while the property existed in globalContext before\n          //  globalContext  target \n          //  globalContext \n          if (!target.hasOwnProperty(p) && globalContext.hasOwnProperty(p)) {\n            //  globalContext \n            const descriptor = Object.getOwnPropertyDescriptor(globalContext, p);\n            const { writable, configurable, enumerable } = descriptor!;\n            // \n            if (writable) {\n              Object.defineProperty(target, p, {\n                configurable,\n                enumerable,\n                writable,\n                value,\n              });\n            }\n          } else {\n            // @ts-ignore\n            // globalContext  target \n            target[p] = value;\n          }\n          //  globalContext\n          if (variableWhiteList.indexOf(p) !== -1) {\n            // @ts-ignore\n            globalContext[p] = value;\n          }\n          //  updatedValueSet \n          updatedValueSet.add(p);\n          // \n          this.latestSetProp = p;\n\n          return true;\n        }\n\n        if (process.env.NODE_ENV === 'development') {\n          console.warn(`[qiankun] Set window.${p.toString()} while sandbox destroyed or inactive in ${name}!`);\n        }\n\n        //  strict-mode Proxy  handler.set  false  TypeError\n        return true;\n      },\n      //  getter\n      get: (target: FakeWindow, p: PropertyKey): any => {\n        //  nestTick \n        this.registerRunningApp(name, proxy);\n        // see https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/unscopables\n        // Symbol.unscopables  with \n        if (p === Symbol.unscopables) return unscopables;\n        // avoid who using window.window or window.self to escape the sandbox environment to touch the really window\n        // see https://github.com/eligrey/FileSaver.js/blob/master/src/FileSaver.js#L13\n        //  proxyWindow  window \n        if (p === 'window' || p === 'self') {\n          return proxy;\n        }\n\n        // hijack globalWindow accessing with globalThis keyword\n        //  globalThis \n        if (p === 'globalThis') {\n          return proxy;\n        }\n\n        if (\n          p === 'top' ||\n          p === 'parent' ||\n          (process.env.NODE_ENV === 'test' && (p === 'mockTop' || p === 'mockSafariTop'))\n        ) {\n          // if your master app in an iframe context, allow these props escape the sandbox\n          if (globalContext === globalContext.parent) {\n            return proxy;\n          }\n          //  top  parent  globalContext \n          return (globalContext as any)[p];\n        }\n\n        // proxy.hasOwnProperty would invoke getter firstly, then its value represented as globalContext.hasOwnProperty\n        if (p === 'hasOwnProperty') {\n          return hasOwnProperty;\n        }\n\n        if (p === 'document') {\n          return document;\n        }\n\n        if (p === 'eval') {\n          return eval;\n        }\n        //  get  globalContext  ProxyWindow  globalContext \n        const value = propertiesWithGetter.has(p)\n          ? (globalContext as any)[p]\n          : p in target\n          ? (target as any)[p]\n          : (globalContext as any)[p];\n        /* Some dom api must be bound to native window, otherwise it would cause exception like 'TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation'\n           See this code:\n             const proxy = new Proxy(window, {});\n             const proxyFetch = fetch.bind(proxy);\n             proxyFetch('https://qiankun.com');\n        */\n        //   DOM API  window\n        const boundTarget = useNativeWindowForBindingsProps.get(p) ? nativeGlobal : globalContext;\n        //  boundTarget scope  value \n        return getTargetValue(boundTarget, value);\n      },\n\n      // trap in operator\n      // see https://github.com/styled-components/styled-components/blob/master/packages/styled-components/src/constants.js#L12\n      has(target: FakeWindow, p: string | number | symbol): boolean {\n        return p in unscopables || p in target || p in globalContext;\n      },\n\n      getOwnPropertyDescriptor(target: FakeWindow, p: string | number | symbol): PropertyDescriptor | undefined {\n        /*\n         as the descriptor of top/self/window/mockTop in raw window are configurable but not in proxy target, we need to get it from target to avoid TypeError\n         see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor\n         > A property cannot be reported as non-configurable, if it does not exists as an own property of the target object or if it exists as a configurable own property of the target object.\n         */\n        if (target.hasOwnProperty(p)) {\n          const descriptor = Object.getOwnPropertyDescriptor(target, p);\n          descriptorTargetMap.set(p, 'target');\n          return descriptor;\n        }\n\n        if (globalContext.hasOwnProperty(p)) {\n          const descriptor = Object.getOwnPropertyDescriptor(globalContext, p);\n          descriptorTargetMap.set(p, 'globalContext');\n          // A property cannot be reported as non-configurable, if it does not exists as an own property of the target object\n          if (descriptor && !descriptor.configurable) {\n            descriptor.configurable = true;\n          }\n          return descriptor;\n        }\n\n        return undefined;\n      },\n\n      // trap to support iterator with sandbox\n      ownKeys(target: FakeWindow): ArrayLike<string | symbol> {\n        //  target  globalContext  keys \n        return uniq(Reflect.ownKeys(globalContext).concat(Reflect.ownKeys(target)));\n      },\n      // the defineProperty and getOwnPropertyDescriptor proxy traps are called when either setting or getting a property descriptor of an object.\n      defineProperty(target: Window, p: PropertyKey, attributes: PropertyDescriptor): boolean {\n        const from = descriptorTargetMap.get(p);\n        /*\n         Descriptor must be defined to native window while it comes from native window via Object.getOwnPropertyDescriptor(window, p),\n         otherwise it would cause a TypeError with illegal invocation.\n         */\n        switch (from) {\n          case 'globalContext':\n            //  globalContext  globalContext \n            return Reflect.defineProperty(globalContext, p, attributes);\n          default:\n            return Reflect.defineProperty(target, p, attributes);\n        }\n      },\n\n      deleteProperty: (target: FakeWindow, p: string | number | symbol): boolean => {\n        this.registerRunningApp(name, proxy);\n        if (target.hasOwnProperty(p)) {\n          // @ts-ignore\n          delete target[p];\n          // \n          updatedValueSet.delete(p);\n\n          return true;\n        }\n\n        return true;\n      },\n\n      // makes sure `window instanceof Window` returns truthy in micro app\n      getPrototypeOf() {\n        //  ProxyWindow  globalContext  Window\n        return Reflect.getPrototypeOf(globalContext);\n      },\n    });\n\n    this.proxy = proxy;\n    //  active \n    activeSandboxCount++;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n\n\n\n\n\n# \n\n>  Sandboxie ()  \n\n\n\n * \n * \n * \n\nJS \n\nJS  DI  JS \n\nSandBox \n\nexport type SandBox = {\n  /**  */\n  name: string;\n  /**  */\n  type: SandBoxType;\n  /**  */\n  proxy: WindowProxy;\n  /**  */\n  sandboxRunning: boolean;\n  /** latest set property */\n  latestSetProp?: PropertyKey | null;\n  /**  */\n  active: () => void;\n  /**  */\n  inactive: () => void;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# \n\n\n\n * inactiveactivevariableWhiteList  set  globalContext globalContext \n * ProxySandbox  createFakeWindow  globalContext  fakeWindow Proxy API  fakeWindow  ProxyWindow\n\n\n\n * createFakeWindow Window \n * ProxyWindow ProxyWindow  Window \n\nProxyWindow  Proxy Handlers \n\nJS  ProxyWindow  Handler  VUE3  Proxy  effect  effect  ProxyWindow  Proxy Handlers :\n\n * \n * \n * \n\n\n#  JS\n\n globalContext  ProxyWindow  js  globalContext   loadApp \n\nglobal = sandboxContainer.instance.proxy as typeof window;\n\n\n1\n\n\n global  loadApp : getAddOnsexecHooksChainexecScriptsgetLifecyclesFromExports loadApp \n\ngetAddOnsexecHooksChain \n\nexecScripts  js \n\nconst scriptExports: any = await execScripts(global, sandbox && !useLooseSandbox);\n\n\n1\n\n\nexecScripts  global  import-html-entry  window.proxy getLifecyclesFromExports  global  mount/unmount/update/bootstrap \n\n> proxy - Window - required, Window or proxy window.\n\n// https://github.com/kuitos/import-html-entry/blob/master/src/index.js#L54\n\nfunction getExecutableScript(scriptSrc, scriptText, proxy, strictGlobal) {\n  const sourceUrl = isInlineCode(scriptSrc)\n    ? \"\"\n    : `//# sourceURL=${scriptSrc}\\n`;\n\n  //  window script  window.proxy  window \n  //  window.proxy  window window.proxy  proxy\n  const globalWindow = (0, eval)(\"window\");\n  globalWindow.proxy = proxy;\n  // TODO  strictGlobal  with  with \n  return strictGlobal\n    ? `;(function(window, self, globalThis){with(window){;${scriptText}\\n${sourceUrl}}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`\n    : `;(function(window, self, globalThis){;${scriptText}\\n${sourceUrl}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# \n\n\n\n * \n\n\n# \n\n\n\n *  Proxy API\n\n ProxySandbox \n\n\n# createFakeWindow\n\n\n# Proxy Handlers\n\n\n# getTargetValue",normalizedContent:"# \n\n\n\n * \n * proxysandbox\n * \n * \n *  js\n * \n * \n * createfakewindow\n * proxy handlers\n * gettargetvalue\n\n\n\n\n# proxysandbox\n\n js  proxysandbox \n\ntype fakewindow = window & record<propertykey, any>;\n\n/**\n * fastest(at most time) unique array method\n * @see https://jsperf.com/array-filter-unique/30\n */\nfunction uniq(array: array<string | symbol>) {\n  return array.filter(function filter(this: propertykey[], element) {\n    return element in this ? false : ((this as any)[element] = true);\n  }, object.create(null));\n}\n\n// zone.js will overwrite object.defineproperty\nconst rawobjectdefineproperty = object.defineproperty;\n\n// who could escape the sandbox\n//  globalcontext \nconst variablewhitelist: propertykey[] = [\n  // fixme system.js used a indirect call with eval, which would make it scope escape to global\n  // to make system.js works well, we write it back to global window temporary\n  // see https://github.com/systemjs/systemjs/blob/457f5b7e8af6bd120a279540477552a07d5de086/src/evaluate.js#l106\n  'system',\n\n  // see https://github.com/systemjs/systemjs/blob/457f5b7e8af6bd120a279540477552a07d5de086/src/instantiate.js#l357\n  '__cjswrapper',\n];\n\n/*\n variables who are impossible to be overwrite need to be escaped from proxy sandbox for performance reasons\n proxywindow\n */\nconst unscopables = {\n  undefined: true,\n  array: true,\n  object: true,\n  string: true,\n  boolean: true,\n  math: true,\n  number: true,\n  symbol: true,\n  parsefloat: true,\n  float32array: true,\n  isnan: true,\n  infinity: true,\n  reflect: true,\n  float64array: true,\n  function: true,\n  map: true,\n  nan: true,\n  promise: true,\n  proxy: true,\n  set: true,\n  parseint: true,\n  requestanimationframe: true,\n};\n\nconst usenativewindowforbindingsprops = new map<propertykey, boolean>([\n  ['fetch', true],\n  ['mockdomapiinblacklist', process.env.node_env === 'test'],\n]);\n\nfunction createfakewindow(globalcontext: window) {\n  // map always has the fastest performance in has check scenario\n  // see https://jsperf.com/array-indexof-vs-set-has/23\n  //  get map \n  const propertieswithgetter = new map<propertykey, boolean>();\n  const fakewindow = {} as fakewindow;\n\n  /*\n   copy the non-configurable property of global to fakewindow\n    global  fakewindow\n   see https://developer.mozilla.org/en-us/docs/web/javascript/reference/global_objects/proxy/handler/getownpropertydescriptor\n   > a property cannot be reported as non-configurable, if it does not exists as an own property of the target object or if it exists as a configurable own property of the target object.\n  //  \n   */\n  object.getownpropertynames(globalcontext)\n    //  global \n    .filter((p) => {\n      const descriptor = object.getownpropertydescriptor(globalcontext, p);\n      return !descriptor?.configurable;\n    })\n    // \n    .foreach((p) => {\n      const descriptor = object.getownpropertydescriptor(globalcontext, p);\n      if (descriptor) {\n        //  get\n        const hasgetter = object.prototype.hasownproperty.call(descriptor, 'get');\n\n        /*\n         make top/self/window property configurable and writable, otherwise it will cause typeerror while get trap return.\n         see https://developer.mozilla.org/en-us/docs/web/javascript/reference/global_objects/proxy/handler/get\n         > the value reported for a property must be the same as the value of the corresponding target object property if the target object property is a non-writable, non-configurable data property.\n        //  \n        //  window \n         */\n        if (\n          p === 'top' ||\n          p === 'parent' ||\n          p === 'self' ||\n          p === 'window' ||\n          (process.env.node_env === 'test' && (p === 'mocktop' || p === 'mocksafaritop'))\n        ) {\n          descriptor.configurable = true;\n          /*\n           the descriptor of window.window/window.top/window.self in safari/ff are accessor descriptors, we need to avoid adding a data descriptor while it was\n           example:\n            safari/ff: object.getownpropertydescriptor(window, 'top') -> {get: function, set: undefined, enumerable: true, configurable: false}\n            chrome: object.getownpropertydescriptor(window, 'top') -> {value: window, writable: false, enumerable: true, configurable: false}\n           */\n          if (!hasgetter) {\n            descriptor.writable = true;\n          }\n        }\n\n        if (hasgetter) propertieswithgetter.set(p, true);\n\n        // freeze the descriptor to avoid being modified by zone.js\n        // see https://github.com/angular/zone.js/blob/a5fe09b0fac27ac5df1fa746042f96f05ccb6a00/lib/browser/define-property.ts#l71\n        //  fakewindow \n        rawobjectdefineproperty(fakewindow, p, object.freeze(descriptor));\n      }\n    });\n\n  return {\n    fakewindow,\n    propertieswithgetter,\n  };\n}\n\n// count  proxysandbox \nlet activesandboxcount = 0;\n\n/**\n *  proxy \n */\nexport default class proxysandbox implements sandbox {\n  /** window  */\n  private updatedvalueset = new set<propertykey>();\n\n  name: string;\n\n  type: sandboxtype;\n\n  proxy: windowproxy;\n\n  globalcontext: typeof window;\n  // running  true running inactive \n  sandboxrunning = true;\n\n  latestsetprop: propertykey | null = null;\n\n  // \n  private registerrunningapp(name: string, proxy: window) {\n    if (this.sandboxrunning) {\n      const currentrunningapp = getcurrentrunningapp();\n      if (!currentrunningapp || currentrunningapp.name !== name) {\n        setcurrentrunningapp({ name, window: proxy });\n      }\n      // fixme if you have any other good ideas\n      // remove the mark in next tick, thus we can identify whether it in micro app or not\n      // this approach is just a workaround, it could not cover all complex cases, such as the micro app runs in the same task context with master in some case\n      // todo \n      nexttask(() => {\n        setcurrentrunningapp(null);\n      });\n    }\n  }\n\n  active() {\n    //  1 (inactive) 1\n    if (!this.sandboxrunning) activesandboxcount++;\n    this.sandboxrunning = true;\n  }\n\n  inactive() {\n    if (process.env.node_env === 'development') {\n      console.info(`[qiankun:sandbox] ${this.name} modified global properties restore...`, [\n        ...this.updatedvalueset.keys(),\n      ]);\n    }\n    // activesandboxcount  1 proxywindow \n    if (--activesandboxcount === 0) {\n      variablewhitelist.foreach((p) => {\n        if (this.proxy.hasownproperty(p)) {\n          // @ts-ignore\n          delete this.globalcontext[p];\n        }\n      });\n    }\n\n    this.sandboxrunning = false;\n  }\n\n  constructor(name: string, globalcontext = window) {\n    this.name = name;\n    this.globalcontext = globalcontext;\n    //  proxy\n    this.type = sandboxtype.proxy;\n    const { updatedvalueset } = this;\n    //  globalcontext  fakewindow\n    const { fakewindow, propertieswithgetter } = createfakewindow(globalcontext);\n\n    const descriptortargetmap = new map<propertykey, symboltarget>();\n    const hasownproperty = (key: propertykey) => fakewindow.hasownproperty(key) || globalcontext.hasownproperty(key);\n    //  fakewindow  proxywindow\n    const proxy = new proxy(fakewindow, {\n      //  setter\n      set: (target: fakewindow, p: propertykey, value: any): boolean => {\n        // unmount \n        if (this.sandboxrunning) {\n          //  nesttick \n          this.registerrunningapp(name, proxy);\n          // we must kept its description while the property existed in globalcontext before\n          //  globalcontext  target \n          //  globalcontext \n          if (!target.hasownproperty(p) && globalcontext.hasownproperty(p)) {\n            //  globalcontext \n            const descriptor = object.getownpropertydescriptor(globalcontext, p);\n            const { writable, configurable, enumerable } = descriptor!;\n            // \n            if (writable) {\n              object.defineproperty(target, p, {\n                configurable,\n                enumerable,\n                writable,\n                value,\n              });\n            }\n          } else {\n            // @ts-ignore\n            // globalcontext  target \n            target[p] = value;\n          }\n          //  globalcontext\n          if (variablewhitelist.indexof(p) !== -1) {\n            // @ts-ignore\n            globalcontext[p] = value;\n          }\n          //  updatedvalueset \n          updatedvalueset.add(p);\n          // \n          this.latestsetprop = p;\n\n          return true;\n        }\n\n        if (process.env.node_env === 'development') {\n          console.warn(`[qiankun] set window.${p.tostring()} while sandbox destroyed or inactive in ${name}!`);\n        }\n\n        //  strict-mode proxy  handler.set  false  typeerror\n        return true;\n      },\n      //  getter\n      get: (target: fakewindow, p: propertykey): any => {\n        //  nesttick \n        this.registerrunningapp(name, proxy);\n        // see https://developer.mozilla.org/zh-cn/docs/web/javascript/reference/global_objects/symbol/unscopables\n        // symbol.unscopables  with \n        if (p === symbol.unscopables) return unscopables;\n        // avoid who using window.window or window.self to escape the sandbox environment to touch the really window\n        // see https://github.com/eligrey/filesaver.js/blob/master/src/filesaver.js#l13\n        //  proxywindow  window \n        if (p === 'window' || p === 'self') {\n          return proxy;\n        }\n\n        // hijack globalwindow accessing with globalthis keyword\n        //  globalthis \n        if (p === 'globalthis') {\n          return proxy;\n        }\n\n        if (\n          p === 'top' ||\n          p === 'parent' ||\n          (process.env.node_env === 'test' && (p === 'mocktop' || p === 'mocksafaritop'))\n        ) {\n          // if your master app in an iframe context, allow these props escape the sandbox\n          if (globalcontext === globalcontext.parent) {\n            return proxy;\n          }\n          //  top  parent  globalcontext \n          return (globalcontext as any)[p];\n        }\n\n        // proxy.hasownproperty would invoke getter firstly, then its value represented as globalcontext.hasownproperty\n        if (p === 'hasownproperty') {\n          return hasownproperty;\n        }\n\n        if (p === 'document') {\n          return document;\n        }\n\n        if (p === 'eval') {\n          return eval;\n        }\n        //  get  globalcontext  proxywindow  globalcontext \n        const value = propertieswithgetter.has(p)\n          ? (globalcontext as any)[p]\n          : p in target\n          ? (target as any)[p]\n          : (globalcontext as any)[p];\n        /* some dom api must be bound to native window, otherwise it would cause exception like 'typeerror: failed to execute 'fetch' on 'window': illegal invocation'\n           see this code:\n             const proxy = new proxy(window, {});\n             const proxyfetch = fetch.bind(proxy);\n             proxyfetch('https://qiankun.com');\n        */\n        //   dom api  window\n        const boundtarget = usenativewindowforbindingsprops.get(p) ? nativeglobal : globalcontext;\n        //  boundtarget scope  value \n        return gettargetvalue(boundtarget, value);\n      },\n\n      // trap in operator\n      // see https://github.com/styled-components/styled-components/blob/master/packages/styled-components/src/constants.js#l12\n      has(target: fakewindow, p: string | number | symbol): boolean {\n        return p in unscopables || p in target || p in globalcontext;\n      },\n\n      getownpropertydescriptor(target: fakewindow, p: string | number | symbol): propertydescriptor | undefined {\n        /*\n         as the descriptor of top/self/window/mocktop in raw window are configurable but not in proxy target, we need to get it from target to avoid typeerror\n         see https://developer.mozilla.org/en-us/docs/web/javascript/reference/global_objects/proxy/handler/getownpropertydescriptor\n         > a property cannot be reported as non-configurable, if it does not exists as an own property of the target object or if it exists as a configurable own property of the target object.\n         */\n        if (target.hasownproperty(p)) {\n          const descriptor = object.getownpropertydescriptor(target, p);\n          descriptortargetmap.set(p, 'target');\n          return descriptor;\n        }\n\n        if (globalcontext.hasownproperty(p)) {\n          const descriptor = object.getownpropertydescriptor(globalcontext, p);\n          descriptortargetmap.set(p, 'globalcontext');\n          // a property cannot be reported as non-configurable, if it does not exists as an own property of the target object\n          if (descriptor && !descriptor.configurable) {\n            descriptor.configurable = true;\n          }\n          return descriptor;\n        }\n\n        return undefined;\n      },\n\n      // trap to support iterator with sandbox\n      ownkeys(target: fakewindow): arraylike<string | symbol> {\n        //  target  globalcontext  keys \n        return uniq(reflect.ownkeys(globalcontext).concat(reflect.ownkeys(target)));\n      },\n      // the defineproperty and getownpropertydescriptor proxy traps are called when either setting or getting a property descriptor of an object.\n      defineproperty(target: window, p: propertykey, attributes: propertydescriptor): boolean {\n        const from = descriptortargetmap.get(p);\n        /*\n         descriptor must be defined to native window while it comes from native window via object.getownpropertydescriptor(window, p),\n         otherwise it would cause a typeerror with illegal invocation.\n         */\n        switch (from) {\n          case 'globalcontext':\n            //  globalcontext  globalcontext \n            return reflect.defineproperty(globalcontext, p, attributes);\n          default:\n            return reflect.defineproperty(target, p, attributes);\n        }\n      },\n\n      deleteproperty: (target: fakewindow, p: string | number | symbol): boolean => {\n        this.registerrunningapp(name, proxy);\n        if (target.hasownproperty(p)) {\n          // @ts-ignore\n          delete target[p];\n          // \n          updatedvalueset.delete(p);\n\n          return true;\n        }\n\n        return true;\n      },\n\n      // makes sure `window instanceof window` returns truthy in micro app\n      getprototypeof() {\n        //  proxywindow  globalcontext  window\n        return reflect.getprototypeof(globalcontext);\n      },\n    });\n\n    this.proxy = proxy;\n    //  active \n    activesandboxcount++;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n\n\n\n\n\n# \n\n>  sandboxie ()  \n\n\n\n * \n * \n * \n\njs \n\njs  di  js \n\nsandbox \n\nexport type sandbox = {\n  /**  */\n  name: string;\n  /**  */\n  type: sandboxtype;\n  /**  */\n  proxy: windowproxy;\n  /**  */\n  sandboxrunning: boolean;\n  /** latest set property */\n  latestsetprop?: propertykey | null;\n  /**  */\n  active: () => void;\n  /**  */\n  inactive: () => void;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# \n\n\n\n * inactiveactivevariablewhitelist  set  globalcontext globalcontext \n * proxysandbox  createfakewindow  globalcontext  fakewindow proxy api  fakewindow  proxywindow\n\n\n\n * createfakewindow window \n * proxywindow proxywindow  window \n\nproxywindow  proxy handlers \n\njs  proxywindow  handler  vue3  proxy  effect  effect  proxywindow  proxy handlers :\n\n * \n * \n * \n\n\n#  js\n\n globalcontext  proxywindow  js  globalcontext   loadapp \n\nglobal = sandboxcontainer.instance.proxy as typeof window;\n\n\n1\n\n\n global  loadapp : getaddonsexechookschainexecscriptsgetlifecyclesfromexports loadapp \n\ngetaddonsexechookschain \n\nexecscripts  js \n\nconst scriptexports: any = await execscripts(global, sandbox && !useloosesandbox);\n\n\n1\n\n\nexecscripts  global  import-html-entry  window.proxy getlifecyclesfromexports  global  mount/unmount/update/bootstrap \n\n> proxy - window - required, window or proxy window.\n\n// https://github.com/kuitos/import-html-entry/blob/master/src/index.js#l54\n\nfunction getexecutablescript(scriptsrc, scripttext, proxy, strictglobal) {\n  const sourceurl = isinlinecode(scriptsrc)\n    ? \"\"\n    : `//# sourceurl=${scriptsrc}\\n`;\n\n  //  window script  window.proxy  window \n  //  window.proxy  window window.proxy  proxy\n  const globalwindow = (0, eval)(\"window\");\n  globalwindow.proxy = proxy;\n  // todo  strictglobal  with  with \n  return strictglobal\n    ? `;(function(window, self, globalthis){with(window){;${scripttext}\\n${sourceurl}}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`\n    : `;(function(window, self, globalthis){;${scripttext}\\n${sourceurl}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# \n\n\n\n * \n\n\n# \n\n\n\n *  proxy api\n\n proxysandbox \n\n\n# createfakewindow\n\n\n# proxy handlers\n\n\n# gettargetvalue",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"snapshotSandbox",frontmatter:{title:"snapshotSandbox",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/sandbox/snapshotSandbox/",categories:["qiankun","sandbox"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/20.sandbox/30.snapshotSandbox.html",relativePath:"30.web/6.qiankun/20.sandbox/30.snapshotSandbox.md",key:"v-33490a39",path:"/qiankun/sandbox/snapshotSandbox/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"SnapshotSandbox",slug:"snapshotsandbox",normalizedTitle:"snapshotsandbox",charIndex:17},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:36},{level:2,title:" JS",slug:"-js",normalizedTitle:" js",charIndex:53},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:69},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:75}],readingTime:{text:"2 min read",minutes:1.14,time:68399.99999999999,words:228},headersStr:" SnapshotSandbox   JS  ",content:"# \n\n\n\n * \n * SnapshotSandbox\n * \n *  JS\n * \n * \n\n\n\n\n# SnapshotSandbox\n\n window \n\nfunction iter(obj: typeof window, callbackFn: (prop: any) => void) {\n  // eslint-disable-next-line guard-for-in, no-restricted-syntax\n  for (const prop in obj) {\n    // patch for clearInterval for compatible reason, see #1490\n    if (obj.hasOwnProperty(prop) || prop === 'clearInterval') {\n      callbackFn(prop);\n    }\n  }\n}\n\n/**\n *  diff  Proxy \n */\nexport default class SnapshotSandbox implements SandBox {\n  proxy: WindowProxy;\n\n  name: string;\n\n  type: SandBoxType;\n\n  sandboxRunning = true;\n\n  private windowSnapshot!: Window;\n\n  private modifyPropsMap: Record<any, any> = {};\n\n  constructor(name: string) {\n    this.name = name;\n    //  window\n    this.proxy = window;\n    this.type = SandBoxType.Snapshot;\n  }\n\n  active() {\n    // \n    this.windowSnapshot = {} as Window;\n    //  window  windowSnapshot\n    iter(window, (prop) => {\n      this.windowSnapshot[prop] = window[prop];\n    });\n\n    // \n    Object.keys(this.modifyPropsMap).forEach((p: any) => {\n      window[p] = this.modifyPropsMap[p];\n    });\n\n    this.sandboxRunning = true;\n  }\n\n  inactive() {\n    //  modifyPropsMap active \n    this.modifyPropsMap = {};\n    //  window  modifyPropsMap  window \n    iter(window, (prop) => {\n      if (window[prop] !== this.windowSnapshot[prop]) {\n        // \n        this.modifyPropsMap[prop] = window[prop];\n        window[prop] = this.windowSnapshot[prop];\n      }\n    });\n\n    this.sandboxRunning = false;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n\n# \n\n window \n\n *  window \n * \n\n\n#  JS\n\n window  diff window\n\n\n# \n\n\n\n * \n * \n\n\n# \n\n\n\n * \n *  active  inactive \n *  window window js ",normalizedContent:"# \n\n\n\n * \n * snapshotsandbox\n * \n *  js\n * \n * \n\n\n\n\n# snapshotsandbox\n\n window \n\nfunction iter(obj: typeof window, callbackfn: (prop: any) => void) {\n  // eslint-disable-next-line guard-for-in, no-restricted-syntax\n  for (const prop in obj) {\n    // patch for clearinterval for compatible reason, see #1490\n    if (obj.hasownproperty(prop) || prop === 'clearinterval') {\n      callbackfn(prop);\n    }\n  }\n}\n\n/**\n *  diff  proxy \n */\nexport default class snapshotsandbox implements sandbox {\n  proxy: windowproxy;\n\n  name: string;\n\n  type: sandboxtype;\n\n  sandboxrunning = true;\n\n  private windowsnapshot!: window;\n\n  private modifypropsmap: record<any, any> = {};\n\n  constructor(name: string) {\n    this.name = name;\n    //  window\n    this.proxy = window;\n    this.type = sandboxtype.snapshot;\n  }\n\n  active() {\n    // \n    this.windowsnapshot = {} as window;\n    //  window  windowsnapshot\n    iter(window, (prop) => {\n      this.windowsnapshot[prop] = window[prop];\n    });\n\n    // \n    object.keys(this.modifypropsmap).foreach((p: any) => {\n      window[p] = this.modifypropsmap[p];\n    });\n\n    this.sandboxrunning = true;\n  }\n\n  inactive() {\n    //  modifypropsmap active \n    this.modifypropsmap = {};\n    //  window  modifypropsmap  window \n    iter(window, (prop) => {\n      if (window[prop] !== this.windowsnapshot[prop]) {\n        // \n        this.modifypropsmap[prop] = window[prop];\n        window[prop] = this.windowsnapshot[prop];\n      }\n    });\n\n    this.sandboxrunning = false;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n\n# \n\n window \n\n *  window \n * \n\n\n#  js\n\n window  diff window\n\n\n# \n\n\n\n * \n * \n\n\n# \n\n\n\n * \n *  active  inactive \n *  window window js ",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"import-html-entry ",frontmatter:{title:"import-html-entry ",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/import-html-entry/",categories:["qiankun"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/999.import-html-entry.html",relativePath:"30.web/6.qiankun/999.import-html-entry.md",key:"v-51af4a72",path:"/qiankun/import-html-entry/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:2,title:"importEntry",slug:"importentry",normalizedTitle:"importentry",charIndex:23},{level:3,title:"html  style  script ",slug:"html--style--script-",normalizedTitle:"html  style  script ",charIndex:40},{level:2,title:"importHTML",slug:"importhtml",normalizedTitle:"importhtml",charIndex:74},{level:2,title:"getEmbedHTML",slug:"getembedhtml",normalizedTitle:"getembedhtml",charIndex:88},{level:2,title:"getExternalScripts",slug:"getexternalscripts",normalizedTitle:"getexternalscripts",charIndex:104},{level:2,title:"getExternalStyleSheets",slug:"getexternalstylesheets",normalizedTitle:"getexternalstylesheets",charIndex:126},{level:2,title:"execScripts",slug:"execscripts",normalizedTitle:"execscripts",charIndex:152},{level:2,title:"processTpl",slug:"processtpl",normalizedTitle:"processtpl",charIndex:167},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:181}],readingTime:{text:"10 min read",minutes:9.225,time:553500,words:1845},headersStr:"  importEntry html  style  script  importHTML getEmbedHTML getExternalScripts getExternalStyleSheets execScripts processTpl ",content:'# \n\n\n\n * \n * \n * importEntry\n   * html  style  script \n * importHTML\n * getEmbedHTML\n * getExternalScripts\n * getExternalStyleSheets\n * execScripts\n * processTpl\n * \n\n\n\n\n# \n\n> Treats the index html as manifest and loads the assets(css,js), get the exports from entry script.\n\n\n# importEntry\n\nexport function defaultGetPublicPath(entry) {\n if (typeof entry === "object") {\n  return "/";\n }\n try {\n  // new URL(\'https://example.org/foo\', \'https://example.org/\')  new URL(\'/foo\', \'https://example.org/\') \n  const { origin, pathname } = new URL(entry, location.href);\n  const paths = pathname.split("/");\n  // \n  paths.pop();\n  return `${origin}${paths.join("/")}/`;\n } catch (e) {\n  console.warn(e);\n  return "";\n }\n}\n\nexport function importEntry(entry, opts = {}) {\n const {\n  fetch = defaultFetch,\n  getTemplate = defaultGetTemplate,\n  postProcessTemplate,\n } = opts;\n const getPublicPath =\n  opts.getPublicPath || opts.getDomain || defaultGetPublicPath;\n\n if (!entry) {\n  throw new SyntaxError("entry should not be empty!");\n }\n\n // html entry\n if (typeof entry === "string") {\n  return importHTML(entry, {\n   fetch,\n   getPublicPath,\n   getTemplate,\n   postProcessTemplate,\n  });\n }\n\n // config entry\n if (Array.isArray(entry.scripts) || Array.isArray(entry.styles)) {\n  const { scripts = [], styles = [], html = "" } = entry;\n  //  styles \n  const getHTMLWithStylePlaceholder = (tpl) =>\n   // reduceRight  ie reduceRight \n   // see https://caniuse.com/?search=reduceRight\n   styles.reduceRight(\n    (html, styleSrc) => `${genLinkReplaceSymbol(styleSrc)}${html}`,\n    tpl\n   );\n  //  scripts \n  const getHTMLWithScriptPlaceholder = (tpl) =>\n   scripts.reduce(\n    (html, scriptSrc) => `${html}${genScriptReplaceSymbol(scriptSrc)}`,\n    tpl\n   );\n\n  return getEmbedHTML(\n   //  template\n   getTemplate(\n    //   script  styles \n    //  html \n    getHTMLWithScriptPlaceholder(getHTMLWithStylePlaceholder(html))\n   ),\n   styles,\n   { fetch }\n  ).then((embedHTML) => ({\n   template: embedHTML,\n   assetPublicPath: getPublicPath(entry),\n   getExternalScripts: () => getExternalScripts(scripts, fetch),\n   getExternalStyleSheets: () => getExternalStyleSheets(styles, fetch),\n   execScripts: (proxy, strictGlobal, execScriptsHooks = {}) => {\n    if (!scripts.length) {\n     return Promise.resolve();\n    }\n    return execScripts(scripts[scripts.length - 1], scripts, proxy, {\n     fetch,\n     strictGlobal,\n     beforeExec: execScriptsHooks.beforeExec,\n     afterExec: execScriptsHooks.afterExec,\n    });\n   },\n  }));\n } else {\n  throw new SyntaxError("entry scripts or styles should be array!");\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# html  style  script \n\n\x3c!-- html  --\x3e\n<style>\n  #root {\n    width: 100px;\n    height: 100px;\n    background: red;\n  }\n</style>\n\n<!DOCTYPE html>\n<head>\n  <meta charset="UTF-8">\n</head>\n<body>\n  <div id="root"></div>\n</body>\n</html>\n\n\x3c!-- html  --\x3e\n<script src="./index.js"><\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n html html \n\n\n# importHTML\n\n importEntry \n\n//  fetch \nexport function readResAsString(response, autoDetectCharset) {\n // \n if (!autoDetectCharset) {\n  return response.text();\n }\n\n // headerstestmock\n if (!response.headers) {\n  return response.text();\n }\n\n // content-type\n const contentType = response.headers.get("Content-Type");\n if (!contentType) {\n  return response.text();\n }\n\n // content-typecharset\n // Content-Type: text/html; charset=utf-8\n // Content-Type: multipart/form-data; boundary=something\n // GETcontent-type\n let charset = "utf-8";\n const parts = contentType.split(";");\n if (parts.length === 2) {\n  const [, value] = parts[1].split("=");\n  const encoding = value && value.trim();\n  if (encoding) {\n   charset = encoding;\n  }\n }\n\n // utf-8\n if (charset.toUpperCase() === "UTF-8") {\n  return response.text();\n }\n\n // gbkgb2312sofa 3gbk\n return response.blob().then(\n  (file) =>\n   new Promise((resolve, reject) => {\n    const reader = new window.FileReader();\n    reader.onload = () => {\n     resolve(reader.result);\n    };\n    reader.onerror = reject;\n    reader.readAsText(file, charset);\n   })\n );\n}\n\nexport function defaultGetPublicPath(entry) {\n if (typeof entry === "object") {\n  return "/";\n }\n try {\n  // new URL(\'https://example.org/foo\', \'https://example.org/\')  new URL(\'/foo\', \'https://example.org/\') \n  const { origin, pathname } = new URL(entry, location.href);\n  const paths = pathname.split("/");\n  // \n  paths.pop();\n  return `${origin}${paths.join("/")}/`;\n } catch (e) {\n  console.warn(e);\n  return "";\n }\n}\n\nexport default function importHTML(url, opts = {}) {\n let fetch = defaultFetch;\n let autoDecodeResponse = false;\n let getPublicPath = defaultGetPublicPath;\n let getTemplate = defaultGetTemplate;\n const { postProcessTemplate } = opts;\n\n // compatible with the legacy importHTML api\n if (typeof opts === "function") {\n  fetch = opts;\n } else {\n  // fetch option is availble\n  if (opts.fetch) {\n   // fetch is a funciton\n   if (typeof opts.fetch === "function") {\n    fetch = opts.fetch;\n   } else {\n    // configuration\n    fetch = opts.fetch.fn || defaultFetch;\n    autoDecodeResponse = !!opts.fetch.autoDecodeResponse;\n   }\n  }\n  getPublicPath =\n   opts.getPublicPath || opts.getDomain || defaultGetPublicPath;\n  getTemplate = opts.getTemplate || defaultGetTemplate;\n }\n\n return (\n  // \n  embedHTMLCache[url] ||\n  (embedHTMLCache[url] = fetch(url)\n   .then((response) => readResAsString(response, autoDecodeResponse))\n   .then((html) => {\n    const assetPublicPath = getPublicPath(url);\n    //  template, scripts, entry, styles\n    const { template, scripts, entry, styles } = processTpl(\n     getTemplate(html),\n     assetPublicPath,\n     postProcessTemplate\n    );\n\n    return getEmbedHTML(template, styles, { fetch }).then((embedHTML) => ({\n     template: embedHTML,\n     assetPublicPath,\n     getExternalScripts: () => getExternalScripts(scripts, fetch),\n     getExternalStyleSheets: () => getExternalStyleSheets(styles, fetch),\n     execScripts: (proxy, strictGlobal, execScriptsHooks = {}) => {\n      if (!scripts.length) {\n       return Promise.resolve();\n      }\n      return execScripts(entry, scripts, proxy, {\n       fetch,\n       strictGlobal,\n       beforeExec: execScriptsHooks.beforeExec,\n       afterExec: execScriptsHooks.afterExec,\n      });\n     },\n    }));\n   }))\n );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n\n\n\n# getEmbedHTML\n\n\n\n/**\n * convert external css link to inline style for performance optimization\n * \n * ? \n *  template  style \n * @param template\n * @param styles\n * @param opts\n * @return embedHTML\n */\nfunction getEmbedHTML(template, styles, opts = {}) {\n const { fetch = defaultFetch } = opts;\n let embedHTML = template;\n\n return getExternalStyleSheets(styles, fetch).then((styleSheets) => {\n  // \n  embedHTML = styles.reduce((html, styleSrc, i) => {\n   html = html.replace(\n    genLinkReplaceSymbol(styleSrc),\n    `<style>/* ${styleSrc} */${styleSheets[i]}</style>`\n   );\n   return html;\n  }, embedHTML);\n  return embedHTML;\n });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# getExternalScripts\n\n\n\n// \nconst isInlineCode = (code) => code.startsWith("<");\n// \nexport function getInlineCode(match) {\n const start = match.indexOf(">") + 1;\n const end = match.lastIndexOf("<");\n return match.substring(start, end);\n}\n// RIC and shim for browsers setTimeout() without it\nexport const requestIdleCallback =\n window.requestIdleCallback ||\n function requestIdleCallback(cb) {\n  //  requestIdleCallback \n  return setTimeout(() => {\n   cb();\n  }, 1);\n };\n\n// for prefetch\nexport function getExternalScripts(\n scripts,\n fetch = defaultFetch,\n errorCallback = () => {}\n) {\n const fetchScript = (scriptUrl) =>\n  // \n  scriptCache[scriptUrl] ||\n  (scriptCache[scriptUrl] = fetch(scriptUrl)\n   .then((response) => {\n    // usually browser treats 4xx and 5xx response of script loading as an error and will fire a script error event\n    // https://stackoverflow.com/questions/5625420/what-http-headers-responses-trigger-the-onerror-handler-on-a-script-tag/5625603\n    // 400 \n    if (response.status >= 400) {\n     errorCallback();\n     throw new Error(\n      `${scriptUrl} load failed with status ${response.status}`\n     );\n    }\n\n    return response.text();\n   })\n   .catch((e) => {\n    errorCallback();\n    throw e;\n   }));\n\n return Promise.all(\n  scripts.map((script) => {\n   if (typeof script === "string") {\n    if (isInlineCode(script)) {\n     // if it is inline script\n     return getInlineCode(script);\n    } else {\n     // \n     // external script\n     return fetchScript(script);\n    }\n   } else {\n    // processTpl \n    // use idle time to load async script\n    const { src, async } = script;\n    //  content  IDLE \n    if (async) {\n     return {\n      src,\n      async: true,\n      content: new Promise((resolve, reject) =>\n       //  resolve, reject \n       requestIdleCallback(() => fetchScript(src).then(resolve, reject))\n      ),\n     };\n    }\n    // \n    return fetchScript(src);\n   }\n  })\n );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n# getExternalStyleSheets\n\n getExternalScripts \n\n// for prefetch\nexport function getExternalStyleSheets(styles, fetch = defaultFetch) {\n return Promise.all(\n  styles.map((styleLink) => {\n   if (isInlineCode(styleLink)) {\n    // if it is inline style\n    return getInlineCode(styleLink);\n   } else {\n    // external styles\n    return (\n     styleCache[styleLink] ||\n     (styleCache[styleLink] = fetch(styleLink).then((response) =>\n      response.text()\n     ))\n    );\n   }\n  })\n );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# execScripts\n\n js  (entry) entry \n\n\nconst evalCache = {};\n//  window \nexport function evalCode(scriptSrc, code) {\n const key = scriptSrc;\n if (!evalCache[key]) {\n  // \n  const functionWrappedCode = `window.__TEMP_EVAL_FUNC__ = function(){${code}}`;\n  //  window  window.__TEMP_EVAL_FUNC__ \n  // (0, eval)(\'console.log(this)\')  Window\n  (0, eval)(functionWrappedCode);\n  // \n  evalCache[key] = window.__TEMP_EVAL_FUNC__;\n  // code\n  delete window.__TEMP_EVAL_FUNC__;\n }\n // \n const evalFunc = evalCache[key];\n evalFunc.call(window);\n}\n\n// \nfunction getExecutableScript(scriptSrc, scriptText, proxy, strictGlobal) {\n  // \n const sourceUrl = isInlineCode(scriptSrc)\n  ? ""\n  : `//# sourceURL=${scriptSrc}\\n`;\n\n //  window script  window.proxy  window \n //  window.proxy  window window.proxy  proxy\n const globalWindow = (0, eval)("window");\n globalWindow.proxy = proxy;\n // TODO  strictGlobal  with  with \n return strictGlobal\n  ? `;(function(window, self, globalThis){with(window){;${scriptText}\\n${sourceUrl}}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`\n  : `;(function(window, self, globalThis){;${scriptText}\\n${sourceUrl}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`;\n}\n\n/**\n * FIXME to consistent with browser behavior, we should only provide callback way to invoke success and error event\n * @param entry\n * @param scripts\n * @param proxy\n * @param opts\n * @returns {Promise<unknown>}\n */\nexport function execScripts(entry, scripts, proxy = window, opts = {}) {\n const {\n  fetch = defaultFetch,\n  strictGlobal = false,\n  success,\n  error = () => {},\n  beforeExec = () => {},\n  afterExec = () => {},\n } = opts;\n\n return getExternalScripts(scripts, fetch, error).then((scriptsText) => {\n  const geval = (scriptSrc, inlineScript) => {\n      //  beforeExec \n   const rawCode = beforeExec(inlineScript, scriptSrc) || inlineScript;\n      // \n   const code = getExecutableScript(scriptSrc, rawCode, proxy, strictGlobal);\n      // \n   evalCode(scriptSrc, code);\n      //  afterExec \n   afterExec(inlineScript, scriptSrc);\n  };\n\n  function exec(scriptSrc, inlineScript, resolve) {\n   // \n   if (scriptSrc === entry) {\n    noteGlobalProps(strictGlobal ? proxy : window);\n\n    try {\n     // bind window.proxy to change `this` reference in script\n     geval(scriptSrc, inlineScript);\n     const exports =\n      proxy[getGlobalProp(strictGlobal ? proxy : window)] || {};\n     // resolve \n     resolve(exports);\n    } catch (e) {\n     // entry error must be thrown to make the promise settled\n     console.error(\n      `[import-html-entry]: error occurs while executing entry script ${scriptSrc}`\n     );\n     throw e;\n    }\n   } else {\n    if (typeof inlineScript === "string") {\n     try {\n      // bind window.proxy to change `this` reference in script\n      // \n      geval(scriptSrc, inlineScript);\n     } catch (e) {\n      // consistent with browser behavior, any independent script evaluation error should not block the others\n      throwNonBlockingError(\n       e,\n       `[import-html-entry]: error occurs while executing normal script ${scriptSrc}`\n      );\n     }\n    } else {\n     // external script marked with async\n     // \n     inlineScript.async &&\n      inlineScript?.content\n       .then((downloadedScriptText) =>\n        //  content \n        geval(inlineScript.src, downloadedScriptText)\n       )\n       .catch((e) => {\n        throwNonBlockingError(\n         e,\n         `[import-html-entry]: error occurs while executing async script ${inlineScript.src}`\n        );\n       });\n    }\n   }\n  }\n  //  i  i \n  function schedule(i, resolvePromise) {\n   if (i < scripts.length) {\n    const scriptSrc = scripts[i];\n    const inlineScript = scriptsText[i];\n    // \n    //  entry  resolvePromise \n    exec(scriptSrc, inlineScript, resolvePromise);\n    // resolve the promise while the last script executed and entry not provided\n    //  resolve\n    if (!entry && i === scripts.length - 1) {\n     resolvePromise();\n    } else {\n     // \n     schedule(i + 1, resolvePromise);\n    }\n   }\n  }\n  //  success  success  Promise.then \n  return new Promise((resolve) => schedule(0, success || resolve));\n });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n\n\n\n\nnoteGlobalProps  getGlobalProp \n\nconst isIE11 =\n typeof navigator !== "undefined" &&\n navigator.userAgent.indexOf("Trident") !== -1;\n\n// \nfunction shouldSkipProperty(global, p) {\n if (!global.hasOwnProperty(p) || (!isNaN(p) && p < global.length))\n  return true;\n\n if (isIE11) {\n  // https://github.com/kuitos/import-html-entry/pull/32 try \n  try {\n   return (\n    global[p] &&\n    typeof window !== "undefined" &&\n    global[p].parent === window\n   );\n  } catch (err) {\n   return true;\n  }\n } else {\n  return false;\n }\n}\n\n// safari unpredictably lists some new globals first or second in object order\nlet firstGlobalProp, secondGlobalProp, lastGlobalProp;\n\nexport function getGlobalProp(global) {\n let cnt = 0;\n let lastProp;\n let hasIframe = false;\n\n for (let p in global) {\n  if (shouldSkipProperty(global, p)) continue;\n\n  //  iframe window  iframe first  second \n  for (let i = 0; i < window.frames.length && !hasIframe; i++) {\n   const frame = window.frames[i];\n   if (frame === global[p]) {\n    hasIframe = true;\n    break;\n   }\n  }\n\n  if (\n   !hasIframe &&\n   ((cnt === 0 && p !== firstGlobalProp) ||\n    (cnt === 1 && p !== secondGlobalProp))\n  )\n   return p;\n  cnt++;\n  lastProp = p;\n }\n\n if (lastProp !== lastGlobalProp) return lastProp;\n}\n\nexport function noteGlobalProps(global) {\n //  global \n // alternatively Object.keys(global).pop()\n // but this may be faster (pending benchmarks)\n firstGlobalProp = secondGlobalProp = undefined;\n\n for (let p in global) {\n  if (shouldSkipProperty(global, p)) continue;\n  if (!firstGlobalProp) firstGlobalProp = p;\n  else if (!secondGlobalProp) secondGlobalProp = p;\n  lastGlobalProp = p;\n }\n return lastGlobalProp;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# processTpl\n\n\n# \n\n * Github: import-html-entry',normalizedContent:'# \n\n\n\n * \n * \n * importentry\n   * html  style  script \n * importhtml\n * getembedhtml\n * getexternalscripts\n * getexternalstylesheets\n * execscripts\n * processtpl\n * \n\n\n\n\n# \n\n> treats the index html as manifest and loads the assets(css,js), get the exports from entry script.\n\n\n# importentry\n\nexport function defaultgetpublicpath(entry) {\n if (typeof entry === "object") {\n  return "/";\n }\n try {\n  // new url(\'https://example.org/foo\', \'https://example.org/\')  new url(\'/foo\', \'https://example.org/\') \n  const { origin, pathname } = new url(entry, location.href);\n  const paths = pathname.split("/");\n  // \n  paths.pop();\n  return `${origin}${paths.join("/")}/`;\n } catch (e) {\n  console.warn(e);\n  return "";\n }\n}\n\nexport function importentry(entry, opts = {}) {\n const {\n  fetch = defaultfetch,\n  gettemplate = defaultgettemplate,\n  postprocesstemplate,\n } = opts;\n const getpublicpath =\n  opts.getpublicpath || opts.getdomain || defaultgetpublicpath;\n\n if (!entry) {\n  throw new syntaxerror("entry should not be empty!");\n }\n\n // html entry\n if (typeof entry === "string") {\n  return importhtml(entry, {\n   fetch,\n   getpublicpath,\n   gettemplate,\n   postprocesstemplate,\n  });\n }\n\n // config entry\n if (array.isarray(entry.scripts) || array.isarray(entry.styles)) {\n  const { scripts = [], styles = [], html = "" } = entry;\n  //  styles \n  const gethtmlwithstyleplaceholder = (tpl) =>\n   // reduceright  ie reduceright \n   // see https://caniuse.com/?search=reduceright\n   styles.reduceright(\n    (html, stylesrc) => `${genlinkreplacesymbol(stylesrc)}${html}`,\n    tpl\n   );\n  //  scripts \n  const gethtmlwithscriptplaceholder = (tpl) =>\n   scripts.reduce(\n    (html, scriptsrc) => `${html}${genscriptreplacesymbol(scriptsrc)}`,\n    tpl\n   );\n\n  return getembedhtml(\n   //  template\n   gettemplate(\n    //   script  styles \n    //  html \n    gethtmlwithscriptplaceholder(gethtmlwithstyleplaceholder(html))\n   ),\n   styles,\n   { fetch }\n  ).then((embedhtml) => ({\n   template: embedhtml,\n   assetpublicpath: getpublicpath(entry),\n   getexternalscripts: () => getexternalscripts(scripts, fetch),\n   getexternalstylesheets: () => getexternalstylesheets(styles, fetch),\n   execscripts: (proxy, strictglobal, execscriptshooks = {}) => {\n    if (!scripts.length) {\n     return promise.resolve();\n    }\n    return execscripts(scripts[scripts.length - 1], scripts, proxy, {\n     fetch,\n     strictglobal,\n     beforeexec: execscriptshooks.beforeexec,\n     afterexec: execscriptshooks.afterexec,\n    });\n   },\n  }));\n } else {\n  throw new syntaxerror("entry scripts or styles should be array!");\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# html  style  script \n\n\x3c!-- html  --\x3e\n<style>\n  #root {\n    width: 100px;\n    height: 100px;\n    background: red;\n  }\n</style>\n\n<!doctype html>\n<head>\n  <meta charset="utf-8">\n</head>\n<body>\n  <div id="root"></div>\n</body>\n</html>\n\n\x3c!-- html  --\x3e\n<script src="./index.js"><\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n html html \n\n\n# importhtml\n\n importentry \n\n//  fetch \nexport function readresasstring(response, autodetectcharset) {\n // \n if (!autodetectcharset) {\n  return response.text();\n }\n\n // headerstestmock\n if (!response.headers) {\n  return response.text();\n }\n\n // content-type\n const contenttype = response.headers.get("content-type");\n if (!contenttype) {\n  return response.text();\n }\n\n // content-typecharset\n // content-type: text/html; charset=utf-8\n // content-type: multipart/form-data; boundary=something\n // getcontent-type\n let charset = "utf-8";\n const parts = contenttype.split(";");\n if (parts.length === 2) {\n  const [, value] = parts[1].split("=");\n  const encoding = value && value.trim();\n  if (encoding) {\n   charset = encoding;\n  }\n }\n\n // utf-8\n if (charset.touppercase() === "utf-8") {\n  return response.text();\n }\n\n // gbkgb2312sofa 3gbk\n return response.blob().then(\n  (file) =>\n   new promise((resolve, reject) => {\n    const reader = new window.filereader();\n    reader.onload = () => {\n     resolve(reader.result);\n    };\n    reader.onerror = reject;\n    reader.readastext(file, charset);\n   })\n );\n}\n\nexport function defaultgetpublicpath(entry) {\n if (typeof entry === "object") {\n  return "/";\n }\n try {\n  // new url(\'https://example.org/foo\', \'https://example.org/\')  new url(\'/foo\', \'https://example.org/\') \n  const { origin, pathname } = new url(entry, location.href);\n  const paths = pathname.split("/");\n  // \n  paths.pop();\n  return `${origin}${paths.join("/")}/`;\n } catch (e) {\n  console.warn(e);\n  return "";\n }\n}\n\nexport default function importhtml(url, opts = {}) {\n let fetch = defaultfetch;\n let autodecoderesponse = false;\n let getpublicpath = defaultgetpublicpath;\n let gettemplate = defaultgettemplate;\n const { postprocesstemplate } = opts;\n\n // compatible with the legacy importhtml api\n if (typeof opts === "function") {\n  fetch = opts;\n } else {\n  // fetch option is availble\n  if (opts.fetch) {\n   // fetch is a funciton\n   if (typeof opts.fetch === "function") {\n    fetch = opts.fetch;\n   } else {\n    // configuration\n    fetch = opts.fetch.fn || defaultfetch;\n    autodecoderesponse = !!opts.fetch.autodecoderesponse;\n   }\n  }\n  getpublicpath =\n   opts.getpublicpath || opts.getdomain || defaultgetpublicpath;\n  gettemplate = opts.gettemplate || defaultgettemplate;\n }\n\n return (\n  // \n  embedhtmlcache[url] ||\n  (embedhtmlcache[url] = fetch(url)\n   .then((response) => readresasstring(response, autodecoderesponse))\n   .then((html) => {\n    const assetpublicpath = getpublicpath(url);\n    //  template, scripts, entry, styles\n    const { template, scripts, entry, styles } = processtpl(\n     gettemplate(html),\n     assetpublicpath,\n     postprocesstemplate\n    );\n\n    return getembedhtml(template, styles, { fetch }).then((embedhtml) => ({\n     template: embedhtml,\n     assetpublicpath,\n     getexternalscripts: () => getexternalscripts(scripts, fetch),\n     getexternalstylesheets: () => getexternalstylesheets(styles, fetch),\n     execscripts: (proxy, strictglobal, execscriptshooks = {}) => {\n      if (!scripts.length) {\n       return promise.resolve();\n      }\n      return execscripts(entry, scripts, proxy, {\n       fetch,\n       strictglobal,\n       beforeexec: execscriptshooks.beforeexec,\n       afterexec: execscriptshooks.afterexec,\n      });\n     },\n    }));\n   }))\n );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n\n\n\n# getembedhtml\n\n\n\n/**\n * convert external css link to inline style for performance optimization\n * \n * ? \n *  template  style \n * @param template\n * @param styles\n * @param opts\n * @return embedhtml\n */\nfunction getembedhtml(template, styles, opts = {}) {\n const { fetch = defaultfetch } = opts;\n let embedhtml = template;\n\n return getexternalstylesheets(styles, fetch).then((stylesheets) => {\n  // \n  embedhtml = styles.reduce((html, stylesrc, i) => {\n   html = html.replace(\n    genlinkreplacesymbol(stylesrc),\n    `<style>/* ${stylesrc} */${stylesheets[i]}</style>`\n   );\n   return html;\n  }, embedhtml);\n  return embedhtml;\n });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# getexternalscripts\n\n\n\n// \nconst isinlinecode = (code) => code.startswith("<");\n// \nexport function getinlinecode(match) {\n const start = match.indexof(">") + 1;\n const end = match.lastindexof("<");\n return match.substring(start, end);\n}\n// ric and shim for browsers settimeout() without it\nexport const requestidlecallback =\n window.requestidlecallback ||\n function requestidlecallback(cb) {\n  //  requestidlecallback \n  return settimeout(() => {\n   cb();\n  }, 1);\n };\n\n// for prefetch\nexport function getexternalscripts(\n scripts,\n fetch = defaultfetch,\n errorcallback = () => {}\n) {\n const fetchscript = (scripturl) =>\n  // \n  scriptcache[scripturl] ||\n  (scriptcache[scripturl] = fetch(scripturl)\n   .then((response) => {\n    // usually browser treats 4xx and 5xx response of script loading as an error and will fire a script error event\n    // https://stackoverflow.com/questions/5625420/what-http-headers-responses-trigger-the-onerror-handler-on-a-script-tag/5625603\n    // 400 \n    if (response.status >= 400) {\n     errorcallback();\n     throw new error(\n      `${scripturl} load failed with status ${response.status}`\n     );\n    }\n\n    return response.text();\n   })\n   .catch((e) => {\n    errorcallback();\n    throw e;\n   }));\n\n return promise.all(\n  scripts.map((script) => {\n   if (typeof script === "string") {\n    if (isinlinecode(script)) {\n     // if it is inline script\n     return getinlinecode(script);\n    } else {\n     // \n     // external script\n     return fetchscript(script);\n    }\n   } else {\n    // processtpl \n    // use idle time to load async script\n    const { src, async } = script;\n    //  content  idle \n    if (async) {\n     return {\n      src,\n      async: true,\n      content: new promise((resolve, reject) =>\n       //  resolve, reject \n       requestidlecallback(() => fetchscript(src).then(resolve, reject))\n      ),\n     };\n    }\n    // \n    return fetchscript(src);\n   }\n  })\n );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n# getexternalstylesheets\n\n getexternalscripts \n\n// for prefetch\nexport function getexternalstylesheets(styles, fetch = defaultfetch) {\n return promise.all(\n  styles.map((stylelink) => {\n   if (isinlinecode(stylelink)) {\n    // if it is inline style\n    return getinlinecode(stylelink);\n   } else {\n    // external styles\n    return (\n     stylecache[stylelink] ||\n     (stylecache[stylelink] = fetch(stylelink).then((response) =>\n      response.text()\n     ))\n    );\n   }\n  })\n );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# execscripts\n\n js  (entry) entry \n\n\nconst evalcache = {};\n//  window \nexport function evalcode(scriptsrc, code) {\n const key = scriptsrc;\n if (!evalcache[key]) {\n  // \n  const functionwrappedcode = `window.__temp_eval_func__ = function(){${code}}`;\n  //  window  window.__temp_eval_func__ \n  // (0, eval)(\'console.log(this)\')  window\n  (0, eval)(functionwrappedcode);\n  // \n  evalcache[key] = window.__temp_eval_func__;\n  // code\n  delete window.__temp_eval_func__;\n }\n // \n const evalfunc = evalcache[key];\n evalfunc.call(window);\n}\n\n// \nfunction getexecutablescript(scriptsrc, scripttext, proxy, strictglobal) {\n  // \n const sourceurl = isinlinecode(scriptsrc)\n  ? ""\n  : `//# sourceurl=${scriptsrc}\\n`;\n\n //  window script  window.proxy  window \n //  window.proxy  window window.proxy  proxy\n const globalwindow = (0, eval)("window");\n globalwindow.proxy = proxy;\n // todo  strictglobal  with  with \n return strictglobal\n  ? `;(function(window, self, globalthis){with(window){;${scripttext}\\n${sourceurl}}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`\n  : `;(function(window, self, globalthis){;${scripttext}\\n${sourceurl}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`;\n}\n\n/**\n * fixme to consistent with browser behavior, we should only provide callback way to invoke success and error event\n * @param entry\n * @param scripts\n * @param proxy\n * @param opts\n * @returns {promise<unknown>}\n */\nexport function execscripts(entry, scripts, proxy = window, opts = {}) {\n const {\n  fetch = defaultfetch,\n  strictglobal = false,\n  success,\n  error = () => {},\n  beforeexec = () => {},\n  afterexec = () => {},\n } = opts;\n\n return getexternalscripts(scripts, fetch, error).then((scriptstext) => {\n  const geval = (scriptsrc, inlinescript) => {\n      //  beforeexec \n   const rawcode = beforeexec(inlinescript, scriptsrc) || inlinescript;\n      // \n   const code = getexecutablescript(scriptsrc, rawcode, proxy, strictglobal);\n      // \n   evalcode(scriptsrc, code);\n      //  afterexec \n   afterexec(inlinescript, scriptsrc);\n  };\n\n  function exec(scriptsrc, inlinescript, resolve) {\n   // \n   if (scriptsrc === entry) {\n    noteglobalprops(strictglobal ? proxy : window);\n\n    try {\n     // bind window.proxy to change `this` reference in script\n     geval(scriptsrc, inlinescript);\n     const exports =\n      proxy[getglobalprop(strictglobal ? proxy : window)] || {};\n     // resolve \n     resolve(exports);\n    } catch (e) {\n     // entry error must be thrown to make the promise settled\n     console.error(\n      `[import-html-entry]: error occurs while executing entry script ${scriptsrc}`\n     );\n     throw e;\n    }\n   } else {\n    if (typeof inlinescript === "string") {\n     try {\n      // bind window.proxy to change `this` reference in script\n      // \n      geval(scriptsrc, inlinescript);\n     } catch (e) {\n      // consistent with browser behavior, any independent script evaluation error should not block the others\n      thrownonblockingerror(\n       e,\n       `[import-html-entry]: error occurs while executing normal script ${scriptsrc}`\n      );\n     }\n    } else {\n     // external script marked with async\n     // \n     inlinescript.async &&\n      inlinescript?.content\n       .then((downloadedscripttext) =>\n        //  content \n        geval(inlinescript.src, downloadedscripttext)\n       )\n       .catch((e) => {\n        thrownonblockingerror(\n         e,\n         `[import-html-entry]: error occurs while executing async script ${inlinescript.src}`\n        );\n       });\n    }\n   }\n  }\n  //  i  i \n  function schedule(i, resolvepromise) {\n   if (i < scripts.length) {\n    const scriptsrc = scripts[i];\n    const inlinescript = scriptstext[i];\n    // \n    //  entry  resolvepromise \n    exec(scriptsrc, inlinescript, resolvepromise);\n    // resolve the promise while the last script executed and entry not provided\n    //  resolve\n    if (!entry && i === scripts.length - 1) {\n     resolvepromise();\n    } else {\n     // \n     schedule(i + 1, resolvepromise);\n    }\n   }\n  }\n  //  success  success  promise.then \n  return new promise((resolve) => schedule(0, success || resolve));\n });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n\n\n\n\nnoteglobalprops  getglobalprop \n\nconst isie11 =\n typeof navigator !== "undefined" &&\n navigator.useragent.indexof("trident") !== -1;\n\n// \nfunction shouldskipproperty(global, p) {\n if (!global.hasownproperty(p) || (!isnan(p) && p < global.length))\n  return true;\n\n if (isie11) {\n  // https://github.com/kuitos/import-html-entry/pull/32 try \n  try {\n   return (\n    global[p] &&\n    typeof window !== "undefined" &&\n    global[p].parent === window\n   );\n  } catch (err) {\n   return true;\n  }\n } else {\n  return false;\n }\n}\n\n// safari unpredictably lists some new globals first or second in object order\nlet firstglobalprop, secondglobalprop, lastglobalprop;\n\nexport function getglobalprop(global) {\n let cnt = 0;\n let lastprop;\n let hasiframe = false;\n\n for (let p in global) {\n  if (shouldskipproperty(global, p)) continue;\n\n  //  iframe window  iframe first  second \n  for (let i = 0; i < window.frames.length && !hasiframe; i++) {\n   const frame = window.frames[i];\n   if (frame === global[p]) {\n    hasiframe = true;\n    break;\n   }\n  }\n\n  if (\n   !hasiframe &&\n   ((cnt === 0 && p !== firstglobalprop) ||\n    (cnt === 1 && p !== secondglobalprop))\n  )\n   return p;\n  cnt++;\n  lastprop = p;\n }\n\n if (lastprop !== lastglobalprop) return lastprop;\n}\n\nexport function noteglobalprops(global) {\n //  global \n // alternatively object.keys(global).pop()\n // but this may be faster (pending benchmarks)\n firstglobalprop = secondglobalprop = undefined;\n\n for (let p in global) {\n  if (shouldskipproperty(global, p)) continue;\n  if (!firstglobalprop) firstglobalprop = p;\n  else if (!secondglobalprop) secondglobalprop = p;\n  lastglobalprop = p;\n }\n return lastglobalprop;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# processtpl\n\n\n# \n\n * github: import-html-entry',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:21.000Z",permalink:"/pages/ba82e2/",categories:["snabbdom"],tags:[null]},regularPath:"/30.web/60.snabbdom/0.index.html",relativePath:"30.web/60.snabbdom/0.index.md",key:"v-07fff7d7",path:"/pages/ba82e2/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:17},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:23},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:29}],readingTime:{text:"1 min read",minutes:.95,time:57e3,words:190},headersStr:"   ",content:'# \n\n\n\n * \n * \n * \n * \n\n\n\n\n# \n\n DOM \n\nGithub: Snabbdom README\n\n:\n\n * Vue 2.x  Virtual DOM  Snabbdom\n *  200 \n * \n *  TypeScript \n *  Virtual DOM \n\n\n# \n\nsnabbdom \n\nimport {\n  init,\n  classModule,\n  propsModule,\n  styleModule,\n  eventListenersModule,\n  h,\n} from "snabbdom";\n\nconst patch = init([\n  //  patch \n  classModule, //  classes \n  propsModule, //  props\n  styleModule, // \n  eventListenersModule, // \n]);\n\nconst container = document.getElementById("container");\n\nconst vnode = h("div#container.two.classes", { on: { click: someFn } }, [\n  h("span", { style: { fontWeight: "bold" } }, "This is bold"),\n  " and this is just normal text",\n  h("a", { props: { href: "/foo" } }, "I\'ll take you places!"),\n]);\n//  - \npatch(container, vnode);\n\nconst newVnode = h(\n  "div#container.two.classes",\n  { on: { click: anotherEventHandler } },\n  [\n    h(\n      "span",\n      { style: { fontWeight: "normal", fontStyle: "italic" } },\n      "This is now italic type"\n    ),\n    " and this is still just normal text",\n    h("a", { props: { href: "/bar" } }, "I\'ll take you places!"),\n  ]\n);\n//  `patch`\npatch(vnode, newVnode); // \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# \n\n *  API \n * module  helper',normalizedContent:'# \n\n\n\n * \n * \n * \n * \n\n\n\n\n# \n\n dom \n\ngithub: snabbdom readme\n\n:\n\n * vue 2.x  virtual dom  snabbdom\n *  200 \n * \n *  typescript \n *  virtual dom \n\n\n# \n\nsnabbdom \n\nimport {\n  init,\n  classmodule,\n  propsmodule,\n  stylemodule,\n  eventlistenersmodule,\n  h,\n} from "snabbdom";\n\nconst patch = init([\n  //  patch \n  classmodule, //  classes \n  propsmodule, //  props\n  stylemodule, // \n  eventlistenersmodule, // \n]);\n\nconst container = document.getelementbyid("container");\n\nconst vnode = h("div#container.two.classes", { on: { click: somefn } }, [\n  h("span", { style: { fontweight: "bold" } }, "this is bold"),\n  " and this is just normal text",\n  h("a", { props: { href: "/foo" } }, "i\'ll take you places!"),\n]);\n//  - \npatch(container, vnode);\n\nconst newvnode = h(\n  "div#container.two.classes",\n  { on: { click: anothereventhandler } },\n  [\n    h(\n      "span",\n      { style: { fontweight: "normal", fontstyle: "italic" } },\n      "this is now italic type"\n    ),\n    " and this is still just normal text",\n    h("a", { props: { href: "/bar" } }, "i\'ll take you places!"),\n  ]\n);\n//  `patch`\npatch(vnode, newvnode); // \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# \n\n *  api \n * module  helper',charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"init",frontmatter:{title:"init",date:"2022-04-14T22:02:21.000Z",permalink:"/pages/cf8075/",categories:["snabbdom","core"],tags:[null]},regularPath:"/30.web/60.snabbdom/10.core/10.init.html",relativePath:"30.web/60.snabbdom/10.core/10.init.md",key:"v-725a2703",path:"/pages/cf8075/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:11}],readingTime:{text:"1 min read",minutes:.065,time:3900.0000000000005,words:13},headersStr:"",content:"# init\n\n\n# \n\n\n\n * \n\n",normalizedContent:"# init\n\n\n# \n\n\n\n * \n\n",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"h",frontmatter:{title:"h",date:"2022-04-14T22:02:21.000Z",permalink:"/pages/69bbdd/",categories:["snabbdom","core"],tags:[null]},regularPath:"/30.web/60.snabbdom/10.core/20.h.html",relativePath:"30.web/60.snabbdom/10.core/20.h.md",key:"v-ca971886",path:"/pages/69bbdd/",readingTime:{text:"1 min read",minutes:.01,time:600,words:2},headersStr:null,content:"# h",normalizedContent:"# h",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"jsx",frontmatter:{title:"jsx",date:"2022-04-14T22:02:21.000Z",permalink:"/pages/fa7d5d/",categories:["snabbdom","core"],tags:[null]},regularPath:"/30.web/60.snabbdom/10.core/30.jsx.html",relativePath:"30.web/60.snabbdom/10.core/30.jsx.md",key:"v-6892877d",path:"/pages/fa7d5d/",readingTime:{text:"1 min read",minutes:.01,time:600,words:2},headersStr:null,content:"# jsx",normalizedContent:"# jsx",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"vnode",frontmatter:{title:"vnode",date:"2022-04-14T22:02:21.000Z",permalink:"/pages/3f1101/",categories:["snabbdom","core"],tags:[null]},regularPath:"/30.web/60.snabbdom/10.core/40.vnode.html",relativePath:"30.web/60.snabbdom/10.core/40.vnode.md",key:"v-d23fd306",path:"/pages/3f1101/",readingTime:{text:"1 min read",minutes:.01,time:600,words:2},headersStr:null,content:"# vnode",normalizedContent:"# vnode",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"thunk",frontmatter:{title:"thunk",date:"2022-04-14T22:02:21.000Z",permalink:"/pages/d02874/",categories:["snabbdom","core"],tags:[null]},regularPath:"/30.web/60.snabbdom/10.core/50.thunk.html",relativePath:"30.web/60.snabbdom/10.core/50.thunk.md",key:"v-210aaa1d",path:"/pages/d02874/",readingTime:{text:"1 min read",minutes:.01,time:600,words:2},headersStr:null,content:"# thunk",normalizedContent:"# thunk",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"attachto",frontmatter:{title:"attachto",date:"2022-04-14T22:02:21.000Z",permalink:"/pages/903ddd/",categories:["snabbdom","helper"],tags:[null]},regularPath:"/30.web/60.snabbdom/30.helper/10.attachto.html",relativePath:"30.web/60.snabbdom/30.helper/10.attachto.md",key:"v-377700fe",path:"/pages/903ddd/",readingTime:{text:"1 min read",minutes:.01,time:600,words:2},headersStr:null,content:"# attachto",normalizedContent:"# attachto",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"",frontmatter:{title:"",date:"2022-04-20T11:18:30.000Z",permalink:"/webpack/init/",categories:["more","webpack"],tags:[null]},regularPath:"/30.web/7.webpack/0.index.html",relativePath:"30.web/7.webpack/0.index.md",key:"v-405fbd6a",path:"/webpack/init/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:149},{level:2,title:"V5 VS V4",slug:"v5-vs-v4",normalizedTitle:"v5 vs v4",charIndex:301},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:314},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:527},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:1057},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:548},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:1551},{level:2,title:"RoadMap",slug:"roadmap",normalizedTitle:"roadmap",charIndex:1812},{level:2,title:" RoadMap",slug:"-roadmap",normalizedTitle:" roadmap",charIndex:1871},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:1958},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:1891},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2136},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2295}],excerpt:"<p>webpack  react  vue  webpack   <code></code>    <code></code>  </p>\n",readingTime:{text:"2 min read",minutes:1.88,time:112800,words:376},headersStr:" V5 VS V4      RoadMap  RoadMap    ",content:"webpack  react  vue  webpack     \n\n\n# \n\n *  webpack \n *  tapable  hook \n\n\n# V5 VS V4\n\n\n# \n\n *   \n *     \n *  Tree Shaking \n * \n *  v4 \n *  v5 \n\n\n# \n\n *  Node.js   Polyfills web \n *  Chunk ID \n * \n *  ID\n * \n * JSON \n * import.meta\n * \n *  Worker \n * URIs\n * \n * \n *  (target)\n * Stats\n * \n * \n * \n * Typescript \n *  tree-shaking\n *  tree-shaking\n * CommonJs Tree Shaking\n * \n * \n * \n *  Tree Shaking \n * \n * \n *  target \n * \n * \n * \n * \n * \n * \n *  JS \n * \n *  Node.js \n\n\n# \n\n *   \n * \n * \n * \n * \n * Tapable \n * Stage \n * Main/Chunk/ModuleTemplate JavascriptModulesPlugin  JS \n * \n *  ID ID ID \n * \n * \n * Logging\n *  chunk \n * Init Fragments\n *  Source Types\n * Stats \n * \n * SizeOnlySource after emit\n * ExportsInfo\n * \n\n\n\n * Webpack 5  (2020-10-10) | webpack \n\n\n# \n\nwebpack  webpack \n\n *  init make seal emit loader \n * loader  webpack loader  loader  JavaScript \n * plugin  webpack \n\n\n# \n\n * init \n * make \n * seal \n * emit \n\n\n# RoadMap\n\nWebpack 5  - GitMind\n\n\n\n\n\n\n#  RoadMap\n\n\n\n\n\n\n\n RoadMap RoadMap    Webpack \n\n\n# \n\n *  Parse   ASTAST   acorn Babel \n *  webpack  Webpack  \n\n\n# \n\n *  webpack \n\n\n# \n\n * []  Webpack  - \n * diving-into-webpack/README.md at master  lihongxun945/diving-into-webpack\n * Webpack   vue-loader  - \n\n\n# \n\n * webpack \n * webpack \n * webpack/tapable: Just a little module for plugins.\n * webpack/loader-runner: Runs (webpack) loaders\n * acornjs/acorn: A small, fast, JavaScript-based JavaScript parser",normalizedContent:"webpack  react  vue  webpack     \n\n\n# \n\n *  webpack \n *  tapable  hook \n\n\n# v5 vs v4\n\n\n# \n\n *   \n *     \n *  tree shaking \n * \n *  v4 \n *  v5 \n\n\n# \n\n *  node.js   polyfills web \n *  chunk id \n * \n *  id\n * \n * json \n * import.meta\n * \n *  worker \n * uris\n * \n * \n *  (target)\n * stats\n * \n * \n * \n * typescript \n *  tree-shaking\n *  tree-shaking\n * commonjs tree shaking\n * \n * \n * \n *  tree shaking \n * \n * \n *  target \n * \n * \n * \n * \n * \n * \n *  js \n * \n *  node.js \n\n\n# \n\n *   \n * \n * \n * \n * \n * tapable \n * stage \n * main/chunk/moduletemplate javascriptmodulesplugin  js \n * \n *  id id id \n * \n * \n * logging\n *  chunk \n * init fragments\n *  source types\n * stats \n * \n * sizeonlysource after emit\n * exportsinfo\n * \n\n\n\n * webpack 5  (2020-10-10) | webpack \n\n\n# \n\nwebpack  webpack \n\n *  init make seal emit loader \n * loader  webpack loader  loader  javascript \n * plugin  webpack \n\n\n# \n\n * init \n * make \n * seal \n * emit \n\n\n# roadmap\n\nwebpack 5  - gitmind\n\n\n\n\n\n\n#  roadmap\n\n\n\n\n\n\n\n roadmap roadmap    webpack \n\n\n# \n\n *  parse   astast   acorn babel \n *  webpack  webpack  \n\n\n# \n\n *  webpack \n\n\n# \n\n * []  webpack  - \n * diving-into-webpack/readme.md at master  lihongxun945/diving-into-webpack\n * webpack   vue-loader  - \n\n\n# \n\n * webpack \n * webpack \n * webpack/tapable: just a little module for plugins.\n * webpack/loader-runner: runs (webpack) loaders\n * acornjs/acorn: a small, fast, javascript-based javascript parser",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-04-20T14:10:55.000Z",permalink:"/webpack/tapable/index",categories:["webpack","tapable"],tags:[null]},regularPath:"/30.web/7.webpack/10.tapable%E6%BA%90%E7%A0%81/0.index.html",relativePath:"30.web/7.webpack/10.tapable/0.index.md",key:"v-761f238a",path:"/webpack/tapable/index/",headers:[{level:2,title:" tapable?",slug:"-tapable",normalizedTitle:" tapable?",charIndex:218},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:313},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:937}],excerpt:"<p>webpack  optionscompilationmoduleloader-runner loader-runner JavascriptParser acorn   loader  plugin  webpack </p>\n<p> webpack tapable </p>\n",readingTime:{text:"1 min read",minutes:.81,time:48600,words:162},headersStr:" tapable?  ",content:"webpack  optionscompilationmoduleloader-runner loader-runner JavascriptParser acorn   loader  plugin  webpack \n\n webpack tapable \n\n\n#  tapable?\n\nTapable  webpack  webpack    Hook \n\n\n# \n\n::: rem MDNPublishsubscribe pattern In software architecture, publishsubscribe is a messaging pattern where senders of messages, called publishers, do not program the messages to be sent directly to specific receivers, called subscribers, but instead categorize published messages into classes without knowledge of which subscribers, if any, there may be. Similarly, subscribers express interest in one or more classes and only receive messages that are of interest, without knowledge of which publishers, if any, there are. :::\n\n\n\n * \n * \n * \n\n\n\n *  - \n\n\n\n * Redux  subscribe  dispatch\n * Vue  effectstrack  trigger\n * Node.js  EventEmitter \n\n\n# \n\n * webpack/tapable: Just a little module for plugins.\n * webpack  tapable  - _ - \n * tapable _ - CSDN _tapable\n * [] Webpack ",normalizedContent:"webpack  optionscompilationmoduleloader-runner loader-runner javascriptparser acorn   loader  plugin  webpack \n\n webpack tapable \n\n\n#  tapable?\n\ntapable  webpack  webpack    hook \n\n\n# \n\n::: rem mdnpublishsubscribe pattern in software architecture, publishsubscribe is a messaging pattern where senders of messages, called publishers, do not program the messages to be sent directly to specific receivers, called subscribers, but instead categorize published messages into classes without knowledge of which subscribers, if any, there may be. similarly, subscribers express interest in one or more classes and only receive messages that are of interest, without knowledge of which publishers, if any, there are. :::\n\n\n\n * \n * \n * \n\n\n\n *  - \n\n\n\n * redux  subscribe  dispatch\n * vue  effectstrack  trigger\n * node.js  eventemitter \n\n\n# \n\n * webpack/tapable: just a little module for plugins.\n * webpack  tapable  - _ - \n * tapable _ - csdn _tapable\n * [] webpack ",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"Api",frontmatter:{title:"Api",date:"2022-04-20T14:49:32.000Z",permalink:"/webpack/tapable/api/",categories:["more","webpack","tapable"],tags:[null]},regularPath:"/30.web/7.webpack/10.tapable%E6%BA%90%E7%A0%81/10.api.html",relativePath:"30.web/7.webpack/10.tapable/10.api.md",key:"v-c3847a42",path:"/webpack/tapable/api/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:67},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:21},{level:2,title:"API ",slug:"api-",normalizedTitle:"api ",charIndex:88},{level:2,title:"API ",slug:"api-",normalizedTitle:"api ",charIndex:98},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:108}],excerpt:"<TimeToRead />\n<p> tapable Hook Hook API </p>\n",readingTime:{text:"3 min read",minutes:2.135,time:128100,words:427},headersStr:"  API  API  ",content:" tapable Hook Hook API \n\n\n# \n\n\n\n * \n * \n * API \n * API \n * \n\n\n\n\n# \n\n\n\n                                   \nHook                               callback  webpack  new SyncHook()\nCallbackhookfunctiontap ()    Hook  webpack  plugin\nTap                            Callback  Hook \nCall                            Hook  Callback \n\n            \n\n\n# API \n\n Hook \n\n                                                                                                                                                                              \nBasic hook (without Waterfall, Bail or Loop in its   This hook simply calls every function it tapped in a row.       Hook  Callback                                   \nname)\nWaterfall                                                  A waterfall hook also calls each tapped function in a row.      Hook  Callback Callback  Callback   Waterfall  \n                                                           Unlike the basic hook, it passes a return value from each                                                                    \n                                                           function to the next function.\nBail                                                       A bail hook allows exiting early. When any of the tapped        Callback Hook  Callback            Bail   \n                                                           function returns anything, the bail hook will stop executing\n                                                           the remaining ones.\nLoop                                                       When a plugin in a loop hook returns a non-undefined value      Hook  Callback  non-undefined         Loop    undefined\n                                                           the hook will restart from the first plugin. It will loop      Callback  undefined                                        undefined \n                                                           until all plugins return undefined.\n\n Hook \n\n                                                                                                                                   \nSync            A sync hook can only be tapped with synchronous functions      Hook  Callback Hook.tap()                        \n                (using myHook.tap()).\nAsyncSeries     An async-series hook can be tapped with synchronous,          async-series  Hook  Callback Promise         Series   \n                callback-based and promise-based functions (using             Callback Hook.tap()  Hook.tapAsync()  Hook.tapPromise()\n                myHook.tap(), myHook.tapAsync() and myHook.tapPromise()).      Callback\n                They call each async method in a row.\nAsyncParallel   An async-parallel hook can also be tapped with synchronous,   async-parallel  Hook  Promise  Callback      Parallel    Promise.all\n                callback-based and promise-based functions (using             Hook.tap()  Hook.tapAsync()  Hook.tapPromise() \n                myHook.tap(), myHook.tapAsync() and myHook.tapPromise()).     Callback Callback \n                However, they run each async method in parallel.\n\nAsyncSeries  AsyncParallel  Hook Hook \n\n\n# API \n\n * SyncHook\n * SyncBailHook\n * SyncWaterfallHook\n * SyncLoopHook\n * AsyncParallelHook\n * AsyncParallelBailHook\n * AsyncSeriesHook\n * AsyncSeriesBailHook\n * AsyncSeriesLoopHook\n * AsyncSeriesWaterfallHook\n * HookMap\n * MultiHook\n\n\n# \n\n * webpack/tapable: Just a little module for plugins.",normalizedContent:" tapable hook hook api \n\n\n# \n\n\n\n * \n * \n * api \n * api \n * \n\n\n\n\n# \n\n\n\n                                   \nhook                               callback  webpack  new synchook()\ncallbackhookfunctiontap ()    hook  webpack  plugin\ntap                            callback  hook \ncall                            hook  callback \n\n            \n\n\n# api \n\n hook \n\n                                                                                                                                                                              \nbasic hook (without waterfall, bail or loop in its   this hook simply calls every function it tapped in a row.       hook  callback                                   \nname)\nwaterfall                                                  a waterfall hook also calls each tapped function in a row.      hook  callback callback  callback   waterfall  \n                                                           unlike the basic hook, it passes a return value from each                                                                    \n                                                           function to the next function.\nbail                                                       a bail hook allows exiting early. when any of the tapped        callback hook  callback            bail   \n                                                           function returns anything, the bail hook will stop executing\n                                                           the remaining ones.\nloop                                                       when a plugin in a loop hook returns a non-undefined value      hook  callback  non-undefined         loop    undefined\n                                                           the hook will restart from the first plugin. it will loop      callback  undefined                                        undefined \n                                                           until all plugins return undefined.\n\n hook \n\n                                                                                                                                   \nsync            a sync hook can only be tapped with synchronous functions      hook  callback hook.tap()                        \n                (using myhook.tap()).\nasyncseries     an async-series hook can be tapped with synchronous,          async-series  hook  callback promise         series   \n                callback-based and promise-based functions (using             callback hook.tap()  hook.tapasync()  hook.tappromise()\n                myhook.tap(), myhook.tapasync() and myhook.tappromise()).      callback\n                they call each async method in a row.\nasyncparallel   an async-parallel hook can also be tapped with synchronous,   async-parallel  hook  promise  callback      parallel    promise.all\n                callback-based and promise-based functions (using             hook.tap()  hook.tapasync()  hook.tappromise() \n                myhook.tap(), myhook.tapasync() and myhook.tappromise()).     callback callback \n                however, they run each async method in parallel.\n\nasyncseries  asyncparallel  hook hook \n\n\n# api \n\n * synchook\n * syncbailhook\n * syncwaterfallhook\n * syncloophook\n * asyncparallelhook\n * asyncparallelbailhook\n * asyncserieshook\n * asyncseriesbailhook\n * asyncseriesloophook\n * asyncserieswaterfallhook\n * hookmap\n * multihook\n\n\n# \n\n * webpack/tapable: just a little module for plugins.",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"Hook",frontmatter:{title:"Hook",date:"2022-04-20T15:44:58.000Z",permalink:"/webpack/tapable/hook/",categories:["webpack","tapable"],tags:[null]},regularPath:"/30.web/7.webpack/10.tapable%E6%BA%90%E7%A0%81/20.Hook.html",relativePath:"30.web/7.webpack/10.tapable/20.Hook.md",key:"v-87d0754a",path:"/webpack/tapable/hook/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:90},{level:2,title:"Hook",slug:"hook",normalizedTitle:"hook",charIndex:34},{level:2,title:"Object.setPrototypeOf()",slug:"object-setprototypeof",normalizedTitle:"object.setprototypeof()",charIndex:113}],excerpt:"<TimeToRead />\n<p> tapable  API  Hook  Hook Hook </p>\n",readingTime:{text:"4 min read",minutes:3.31,time:198600,words:662},headersStr:" Hook Object.setPrototypeOf()",content:' tapable  API  Hook  Hook Hook \n\n\n# \n\n\n\n * \n * Hook\n * Object.setPrototypeOf()\n\n\n\n\n# Hook\n\n\n\nconst CALL_DELEGATE = function(...args) {\n  //  _createCall  this.call \n  //  _resetCompilation \n this.call = this._createCall("sync");\n return this.call(...args);\n};\nconst CALL_ASYNC_DELEGATE = function(...args) {\n this.callAsync = this._createCall("async");\n return this.callAsync(...args);\n};\nconst PROMISE_DELEGATE = function(...args) {\n this.promise = this._createCall("promise");\n return this.promise(...args);\n};\n\nclass Hook {\n constructor(args = [], name = undefined) {\n  this._args = args;\n  this.name = name;\n  this.taps = [];\n  this.interceptors = [];\n  this._call = CALL_DELEGATE;\n  this.call = CALL_DELEGATE;\n  this._callAsync = CALL_ASYNC_DELEGATE;\n  this.callAsync = CALL_ASYNC_DELEGATE;\n  this._promise = PROMISE_DELEGATE;\n  this.promise = PROMISE_DELEGATE;\n  this._x = undefined;\n\n  this.compile = this.compile;\n  this.tap = this.tap;\n  this.tapAsync = this.tapAsync;\n  this.tapPromise = this.tapPromise;\n }\n\n compile(options) {\n  throw new Error("Abstract: should be overridden");\n }\n  // Hook  _createCall _createCall  compile \n _createCall(type) {\n  return this.compile({\n   taps: this.taps,\n   interceptors: this.interceptors,\n   args: this._args,\n   type: type\n  });\n }\n\n _tap(type, options, fn) {\n    // \n  if (typeof options === "string") {\n   options = {\n    name: options.trim()\n   };\n  } else if (typeof options !== "object" || options === null) {\n   throw new Error("Invalid tap options");\n  }\n  if (typeof options.name !== "string" || options.name === "") {\n   throw new Error("Missing name for tap");\n  }\n  if (typeof options.context !== "undefined") {\n   deprecateContext();\n  }\n    // merge optionstype  fn  options\n  options = Object.assign({ type, fn }, options);\n    //  register \n  options = this._runRegisterInterceptors(options);\n    //  Callback  taps\n  this._insert(options);\n }\n\n tap(options, fn) {\n  this._tap("sync", options, fn);\n }\n\n tapAsync(options, fn) {\n  this._tap("async", options, fn);\n }\n\n tapPromise(options, fn) {\n  this._tap("promise", options, fn);\n }\n\n _runRegisterInterceptors(options) {\n  for (const interceptor of this.interceptors) {\n      //  register  options\n   if (interceptor.register) {\n    const newOptions = interceptor.register(options);\n    if (newOptions !== undefined) {\n     options = newOptions;\n    }\n   }\n  }\n  return options;\n }\n\n withOptions(options) {\n  const mergeOptions = opt =>\n   Object.assign({}, options, typeof opt === "string" ? { name: opt } : opt);\n\n  return {\n   name: this.name,\n   tap: (opt, fn) => this.tap(mergeOptions(opt), fn),\n   tapAsync: (opt, fn) => this.tapAsync(mergeOptions(opt), fn),\n   tapPromise: (opt, fn) => this.tapPromise(mergeOptions(opt), fn),\n   intercept: interceptor => this.intercept(interceptor),\n   isUsed: () => this.isUsed(),\n   withOptions: opt => this.withOptions(mergeOptions(opt))\n  };\n }\n\n isUsed() {\n  return this.taps.length > 0 || this.interceptors.length > 0;\n }\n\n intercept(interceptor) {\n  this._resetCompilation();\n  this.interceptors.push(Object.assign({}, interceptor));\n  if (interceptor.register) {\n   for (let i = 0; i < this.taps.length; i++) {\n    this.taps[i] = interceptor.register(this.taps[i]);\n   }\n  }\n }\n  // Hook _createCall\n  //  Hook \n _resetCompilation() {\n  this.call = this._call;\n  this.callAsync = this._callAsync;\n  this.promise = this._promise;\n }\n\n _insert(item) {\n    // \n  this._resetCompilation();\n  let before;\n    // item.before  string  string[] Set\n  if (typeof item.before === "string") {\n   before = new Set([item.before]);\n  } else if (Array.isArray(item.before)) {\n   before = new Set(item.before);\n  }\n  let stage = 0;\n  if (typeof item.stage === "number") {\n   stage = item.stage;\n  }\n  let i = this.taps.length;\n    //  items\n  while (i > 0) {\n   i--;\n   const x = this.taps[i];\n      //  item  linked-list\n      //  linked-list \n   this.taps[i + 1] = x;\n   const xStage = x.stage || 0;\n   if (before) {\n        //  before \n    if (before.has(x.name)) {\n     before.delete(x.name);\n     continue;\n    }\n    if (before.size > 0) {\n     continue;\n    }\n   }\n   if (xStage > stage) {\n    continue;\n   }\n      //  before  >=   break  i++ \n   i++;\n   break;\n  }\n    // item  >= i  item  item  i  i++\n  this.taps[i] = item;\n }\n}\n\nObject.setPrototypeOf(Hook.prototype, null);\n\nmodule.exports = Hook;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n\n\n\n\n * Hook  compile  compile  Hook  _resetCompilation  Tap  intercept  Callback \n * taps before  before stage \n * Hook  null Hook \n *  compile  - \n\n\n# Object.setPrototypeOf()\n\nThe Object.setPrototypeOf() method sets the prototype (i.e., the internal [[Prototype]] property) of a specified object to another object or null. All JavaScript objects inherit properties and methods from a prototype . It is generally considered the proper way to set the prototype of an object.\n\n\n\n * What is object null prototype?  QuickAdviser\n * Javascript Object setPrototypeOf() Method - javatpoint\n * Object.setPrototypeOf() - JavaScript | MDN',normalizedContent:' tapable  api  hook  hook hook \n\n\n# \n\n\n\n * \n * hook\n * object.setprototypeof()\n\n\n\n\n# hook\n\n\n\nconst call_delegate = function(...args) {\n  //  _createcall  this.call \n  //  _resetcompilation \n this.call = this._createcall("sync");\n return this.call(...args);\n};\nconst call_async_delegate = function(...args) {\n this.callasync = this._createcall("async");\n return this.callasync(...args);\n};\nconst promise_delegate = function(...args) {\n this.promise = this._createcall("promise");\n return this.promise(...args);\n};\n\nclass hook {\n constructor(args = [], name = undefined) {\n  this._args = args;\n  this.name = name;\n  this.taps = [];\n  this.interceptors = [];\n  this._call = call_delegate;\n  this.call = call_delegate;\n  this._callasync = call_async_delegate;\n  this.callasync = call_async_delegate;\n  this._promise = promise_delegate;\n  this.promise = promise_delegate;\n  this._x = undefined;\n\n  this.compile = this.compile;\n  this.tap = this.tap;\n  this.tapasync = this.tapasync;\n  this.tappromise = this.tappromise;\n }\n\n compile(options) {\n  throw new error("abstract: should be overridden");\n }\n  // hook  _createcall _createcall  compile \n _createcall(type) {\n  return this.compile({\n   taps: this.taps,\n   interceptors: this.interceptors,\n   args: this._args,\n   type: type\n  });\n }\n\n _tap(type, options, fn) {\n    // \n  if (typeof options === "string") {\n   options = {\n    name: options.trim()\n   };\n  } else if (typeof options !== "object" || options === null) {\n   throw new error("invalid tap options");\n  }\n  if (typeof options.name !== "string" || options.name === "") {\n   throw new error("missing name for tap");\n  }\n  if (typeof options.context !== "undefined") {\n   deprecatecontext();\n  }\n    // merge optionstype  fn  options\n  options = object.assign({ type, fn }, options);\n    //  register \n  options = this._runregisterinterceptors(options);\n    //  callback  taps\n  this._insert(options);\n }\n\n tap(options, fn) {\n  this._tap("sync", options, fn);\n }\n\n tapasync(options, fn) {\n  this._tap("async", options, fn);\n }\n\n tappromise(options, fn) {\n  this._tap("promise", options, fn);\n }\n\n _runregisterinterceptors(options) {\n  for (const interceptor of this.interceptors) {\n      //  register  options\n   if (interceptor.register) {\n    const newoptions = interceptor.register(options);\n    if (newoptions !== undefined) {\n     options = newoptions;\n    }\n   }\n  }\n  return options;\n }\n\n withoptions(options) {\n  const mergeoptions = opt =>\n   object.assign({}, options, typeof opt === "string" ? { name: opt } : opt);\n\n  return {\n   name: this.name,\n   tap: (opt, fn) => this.tap(mergeoptions(opt), fn),\n   tapasync: (opt, fn) => this.tapasync(mergeoptions(opt), fn),\n   tappromise: (opt, fn) => this.tappromise(mergeoptions(opt), fn),\n   intercept: interceptor => this.intercept(interceptor),\n   isused: () => this.isused(),\n   withoptions: opt => this.withoptions(mergeoptions(opt))\n  };\n }\n\n isused() {\n  return this.taps.length > 0 || this.interceptors.length > 0;\n }\n\n intercept(interceptor) {\n  this._resetcompilation();\n  this.interceptors.push(object.assign({}, interceptor));\n  if (interceptor.register) {\n   for (let i = 0; i < this.taps.length; i++) {\n    this.taps[i] = interceptor.register(this.taps[i]);\n   }\n  }\n }\n  // hook _createcall\n  //  hook \n _resetcompilation() {\n  this.call = this._call;\n  this.callasync = this._callasync;\n  this.promise = this._promise;\n }\n\n _insert(item) {\n    // \n  this._resetcompilation();\n  let before;\n    // item.before  string  string[] set\n  if (typeof item.before === "string") {\n   before = new set([item.before]);\n  } else if (array.isarray(item.before)) {\n   before = new set(item.before);\n  }\n  let stage = 0;\n  if (typeof item.stage === "number") {\n   stage = item.stage;\n  }\n  let i = this.taps.length;\n    //  items\n  while (i > 0) {\n   i--;\n   const x = this.taps[i];\n      //  item  linked-list\n      //  linked-list \n   this.taps[i + 1] = x;\n   const xstage = x.stage || 0;\n   if (before) {\n        //  before \n    if (before.has(x.name)) {\n     before.delete(x.name);\n     continue;\n    }\n    if (before.size > 0) {\n     continue;\n    }\n   }\n   if (xstage > stage) {\n    continue;\n   }\n      //  before  >=   break  i++ \n   i++;\n   break;\n  }\n    // item  >= i  item  item  i  i++\n  this.taps[i] = item;\n }\n}\n\nobject.setprototypeof(hook.prototype, null);\n\nmodule.exports = hook;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n\n\n\n\n * hook  compile  compile  hook  _resetcompilation  tap  intercept  callback \n * taps before  before stage \n * hook  null hook \n *  compile  - \n\n\n# object.setprototypeof()\n\nthe object.setprototypeof() method sets the prototype (i.e., the internal [[prototype]] property) of a specified object to another object or null. all javascript objects inherit properties and methods from a prototype . it is generally considered the proper way to set the prototype of an object.\n\n\n\n * what is object null prototype?  quickadviser\n * javascript object setprototypeof() method - javatpoint\n * object.setprototypeof() - javascript | mdn',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"HookCodeFactory",frontmatter:{title:"HookCodeFactory",date:"2022-04-20T17:46:43.000Z",permalink:"/webpack/tapable/factory/",categories:["webpack","tapable"],tags:[null]},regularPath:"/30.web/7.webpack/10.tapable%E6%BA%90%E7%A0%81/30.HookCodeFactory.html",relativePath:"30.web/7.webpack/10.tapable/30.HookCodeFactory.md",key:"v-2da3183a",path:"/webpack/tapable/factory/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:177},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:192},{level:2,title:"HookCodeFactory",slug:"hookcodefactory",normalizedTitle:"hookcodefactory",charIndex:133}],excerpt:"<TimeToRead />\n<p> Hook  compile  hook compile  tapable Hook  HookCodeFactory  compile </p>\n",readingTime:{text:"1 min read",minutes:.56,time:33600,words:112},headersStr:"  HookCodeFactory",content:" Hook  compile  hook compile  tapable Hook  HookCodeFactory  compile \n\n\n# \n\n\n\n * \n * \n * HookCodeFactory\n\n\n\n\n# \n\n HookCodeFactory  \n\n *  eval \n *  new Function()  new Function()  n \n\n\n\n                                                            \neval              window.eval ()  global.eval ()     import-html-entry   evalCode \nnew Function                                               Vue _h \n\n\n\n * eval  new Function  - SegmentFault \n * javascript - Are eval() and new Function() the same thing? - Stack Overflow\n\n\n# HookCodeFactory",normalizedContent:" hook  compile  hook compile  tapable hook  hookcodefactory  compile \n\n\n# \n\n\n\n * \n * \n * hookcodefactory\n\n\n\n\n# \n\n hookcodefactory  \n\n *  eval \n *  new function()  new function()  n \n\n\n\n                                                            \neval              window.eval ()  global.eval ()     import-html-entry   evalcode \nnew function                                               vue _h \n\n\n\n * eval  new function  - segmentfault \n * javascript - are eval() and new function() the same thing? - stack overflow\n\n\n# hookcodefactory",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"Webpack",frontmatter:{title:"Webpack",date:"2022-04-26T11:01:52.000Z",permalink:"/webpack/summary/dp/",categories:["webpack"],tags:[""]},regularPath:"/30.web/7.webpack/100.%E6%80%BB%E7%BB%93/10.dp.html",relativePath:"30.web/7.webpack/100./10.dp.md",key:"v-53a11582",path:"/webpack/summary/dp/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"Webpack ",frontmatter:{title:"Webpack ",date:"2022-04-26T11:14:17.000Z",permalink:"/webpack/summary/ds/",categories:["webpack",""],tags:[""]},regularPath:"/30.web/7.webpack/100.%E6%80%BB%E7%BB%93/20.ds.html",relativePath:"30.web/7.webpack/100./20.ds.md",key:"v-4c8845fc",path:"/webpack/summary/ds/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-04-20T19:34:55.000Z",permalink:"/webpack/init/index/",categories:["more","webpack","init"],tags:[null]},regularPath:"/30.web/7.webpack/20.init%E9%98%B6%E6%AE%B5/0.index.html",relativePath:"30.web/7.webpack/20.init/0.index.md",key:"v-df747cda",path:"/webpack/init/index/",headers:[{level:2,title:"RoadMap",slug:"roadmap",normalizedTitle:"roadmap",charIndex:46},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:60}],excerpt:"<TimeToRead />\n<p> webpack  init </p>\n",readingTime:{text:"1 min read",minutes:.135,time:8100.000000000002,words:27},headersStr:"RoadMap ",content:" webpack  init \n\n\n# RoadMap\n\n\n\n\n# \n\n * Webpack Init RoadMap   []  Webpack  - ",normalizedContent:" webpack  init \n\n\n# roadmap\n\n\n\n\n# \n\n * webpack init roadmap   []  webpack  - ",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"init compiler",frontmatter:{title:"init compiler",date:"2022-04-21T10:16:49.000Z",permalink:"/webpack/init/compiler/",categories:["webpack","init"],tags:[null]},regularPath:"/30.web/7.webpack/20.init%E9%98%B6%E6%AE%B5/10.compiler.html",relativePath:"30.web/7.webpack/20.init/10.compiler.md",key:"v-c36c87c2",path:"/webpack/init/compiler/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:97},{level:2,title:"webpack",slug:"webpack",normalizedTitle:"webpack",charIndex:6},{level:2,title:"createCompiler",slug:"createcompiler",normalizedTitle:"createcompiler",charIndex:123},{level:2,title:"compiler.run",slug:"compiler-run",normalizedTitle:"compiler.run",charIndex:80},{level:2,title:"compiler.compile",slug:"compiler-compile",normalizedTitle:"compiler.compile",charIndex:157},{level:3,title:"newCompilationParams",slug:"newcompilationparams",normalizedTitle:"newcompilationparams",charIndex:179},{level:3,title:"newCompilation",slug:"newcompilation",normalizedTitle:"newcompilation",charIndex:179},{level:2,title:"compilation.addEntry",slug:"compilation-addentry",normalizedTitle:"compilation.addentry",charIndex:223},{level:2,title:"compiler.Hook",slug:"compiler-hook",normalizedTitle:"compiler.hook",charIndex:247},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:264}],excerpt:"<TimeToRead />\n<p> webpack  init </p>\n<ul>\n<li>options </li>\n<li>compiler </li>\n<li></li>\n<li>compiler.run</li>\n</ul>\n",readingTime:{text:"7 min read",minutes:7.005,time:420300,words:1401},headersStr:" webpack createCompiler compiler.run compiler.compile newCompilationParams newCompilation compilation.addEntry compiler.Hook ",content:' webpack  init \n\n * options \n * compiler \n * \n * compiler.run\n\n\n# \n\n\n\n * \n * webpack\n * createCompiler\n * compiler.run\n * compiler.compile\n   * newCompilationParams\n   * newCompilation\n * compilation.addEntry\n * compiler.Hook\n * \n\n\n\n\n# webpack\n\n// lib/webpack.js\nconst webpack = (options, callback) => {\n  const create = () => {\n      //  options\n   if (!asArray(options).every(webpackOptionsSchemaCheck)) {\n    getValidateSchema()(webpackOptionsSchema, options);\n   }\n   let compiler;\n   let watch = false;\n   let watchOptions;\n   //  options  MultiCompiler\n   if (Array.isArray(options)) {\n    compiler = createMultiCompiler(\n     options,\n    );\n    //  watch  watchOptions\n    watch = options.some(options => options.watch);\n    watchOptions = options.map(options => options.watchOptions || {});\n   } else {\n    const webpackOptions = (options);\n    //  compiler\n    compiler = createCompiler(webpackOptions);\n    watch = webpackOptions.watch;\n    watchOptions = webpackOptions.watchOptions || {};\n   }\n   return { compiler, watch, watchOptions };\n  };\n  if (callback) {\n   try {\n    const { compiler, watch, watchOptions } = create();\n    if (watch) {\n      //  watch Watching\n     compiler.watch(watchOptions, callback);\n    } else {\n     //  compiler\n     compiler.run((err, stats) => {\n      // compile  compiler\n      compiler.close(err2 => {\n       callback(err || err2, stats);\n      });\n     });\n    }\n    return compiler;\n   } catch (err) {\n    process.nextTick(() => callback(err));\n    return null;\n   }\n  } else {\n   const { compiler, watch } = create();\n   //  ......\n   return compiler;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n\nconst webpack = (options, callback) => {\n //  options\n if (!asArray(options).every(webpackOptionsSchemaCheck)) {\n  getValidateSchema()(webpackOptionsSchema, options);\n }\n\n //  compiler\n const compiler = createCompiler(options);\n\n //  compiler\n compiler.run((err, stats) => {\n  // compile  compiler\n  compiler.close((err2) => {\n   callback(err || err2, stats);\n  });\n });\n\n return compiler;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n\n *  options\n *  options  compiler\n\n\n# createCompiler\n\n// lib/webpack.js\nconst createCompiler = rawOptions => {\n  // options \n const options = getNormalizedWebpackOptions(rawOptions);\n  // merge webpack  optionscontextinfrastructureLogging\n applyWebpackOptionsBaseDefaults(options);\n  //  Compiler\n const compiler = new Compiler(options.context, options);\n  // ==========  ========== //\n  //  NodeEnvironmentPluginbeforeRun =>  Node  \n new NodeEnvironmentPlugin({\n  infrastructureLogging: options.infrastructureLogging\n }).apply(compiler);\n  //  options.plugins\n if (Array.isArray(options.plugins)) {\n  for (const plugin of options.plugins) {\n   if (typeof plugin === "function") {\n    plugin.call(compiler, compiler);\n   } else {\n    plugin.apply(compiler);\n   }\n  }\n }\n  // merge webpack  options: contexttargetdevtool\n applyWebpackOptionsDefaults(options);\n  //  Hook.environment => call\n compiler.hooks.environment.call();\n  //  Hook.afterEnvironment => call\n compiler.hooks.afterEnvironment.call();\n  // WebpackOptionsApply  options \n new WebpackOptionsApply().process(options, compiler);\n  //  Hook.initialize => call\n compiler.hooks.initialize.call();\n  //  compiler\n return compiler;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n\n * options merge  options\n *  compiler \n *  NodeEnvironmentPluginoptions.plugins options \n *  Hook.environmentHook.afterEnvironmentHook.initialize\n\n\n# compiler.run\n\nrun(callback) {\n  //  compiler \n  if (this.running) {\n    return callback(new ConcurrentCompilationError());\n  }\n\n  //  err \n  const finalCallback = (err, stats) => {\n    //  compiler  idle\n    this.idle = true;\n    //  CacheHook.beginIdle => call\n    this.cache.beginIdle();\n    this.idle = true;\n    //  compiler running  false\n    this.running = false;\n    if (err) {\n      //  Hook.failed => call\n      this.hooks.failed.call(err);\n    }\n    if (callback !== undefined) callback(err, stats);\n    //  Hook.afterDone => call\n    this.hooks.afterDone.call(stats);\n  };\n\n  //  running  true\n  this.running = true;\n\n  const run = () => {\n    //  Hook.beforeRun: callAsync \n    this.hooks.beforeRun.callAsync(this, err => {\n      if (err) return finalCallback(err);\n      //  Hook.run: callAsync\n      this.hooks.run.callAsync(this, err => {\n        if (err) return finalCallback(err);\n        //  records \n        this.readRecords(err => {\n          if (err) return finalCallback(err);\n          //  compile\n          this.compile(onCompiled);\n        });\n      });\n    });\n  };\n  //  false\n  if (this.idle) {\n    //  CacheHook.endIdle\n    this.cache.endIdle(err => {\n      if (err) return finalCallback(err);\n      \n      this.idle = false;\n      run();\n    });\n  } else {\n    run();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n\n *  compiler  idle  CacheHook.endIdle run run\n * compiler.run  Hook.beforeRunHook.run recordscompiler   compilecompile  onCompiled compiler  running\n *  finalCallback callback compile  idle CacheHook.beginIdleHook.failed  Hook.afterDone compiler  running \n\n\n# compiler.compile\n\n// lib/Compiler.js\ncompile(callback) {\n    //  compilationParams\n  const params = this.newCompilationParams();\n    //  Hook.beforeCompile => callAsync\n  this.hooks.beforeCompile.callAsync(params, err => {\n   if (err) return callback(err);\n      //  Hook.compile => call\n   this.hooks.compile.call(params);\n      //  compilation \n   const compilation = this.newCompilation(params);\n\n   //  Hook.make => callAsync\n   this.hooks.make.callAsync(compilation, err => {\n    if (err) return callback(err);\n    \n    //  Hook.finishMake => callAsync\n    this.hooks.finishMake.callAsync(compilation, err => {\n     if (err) return callback(err);\n\n     process.nextTick(() => {\n      // compilation.finish\n      compilation.finish(err => {\n       if (err) return callback(err);\n\n       // compilation.seal\n       compilation.seal(err => {\n        if (err) return callback(err);\n\n        //  Hook.afterCompile => callAsync\n        this.hooks.afterCompile.callAsync(compilation, err => {\n         if (err) return callback(err);\n\n         return callback(null, compilation);\n        });\n       });\n      });\n     });\n    });\n   });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\ncompile \n\n\n\n *  Hook.beforeCompileHook.compileHook.makeHook.finishMakeHook.afterCompile\n * compilation compilation  Hook.makeHook.finishMake compilation.finishcompilation.seal Hook.afterCompile\n\n\n# newCompilationParams\n\n normalModuleFactory  contextModuleFactory\n\nnewCompilationParams() {\nconst params = {\n  // new NormalModuleFactory()\n  normalModuleFactory: this.createNormalModuleFactory(),\n  // new ContextModuleFactory()\n  contextModuleFactory: this.createContextModuleFactory()\n};\nreturn params;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# newCompilation\n\n// lib/Compiler.js\ncreateCompilation(params) {\n  //  _cleanupLastCompilation  _lastCompilation \n this._cleanupLastCompilation();\n return (this._lastCompilation = new Compilation(this, params));\n}\nnewCompilation(params) {\n  //  compilation \n const compilation = this.createCompilation(params);\n compilation.name = this.name;\n compilation.records = this.records;\n  //  Hook.thisCompilation => call\n this.hooks.thisCompilation.call(compilation, params);\n  //  Hook.compilation => call\n this.hooks.compilation.call(compilation, params);\n return compilation;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n\n *  compilation\n *  Hook.thisCompilationHook.compilation\n\n\n# compilation.addEntry\n\n createCompiler  new WebpackOptionsApply().process(options, compiler)  options \n\n// lib/WebpackOptionsApply.js\nnew EntryOptionPlugin().apply(compiler);\n//  Hook.entryOption => call\ncompiler.hooks.entryOption.call(options.context, options.entry);\n\n\n1\n2\n3\n4\n\n\n EntryOptionPlugin \n\n// lib/EntryOptionPlugin.js\nclass EntryOptionPlugin {\n // ......\n apply(compiler) {\n  //  Callback: Hook.entryOption Hook.entryOption  applyEntryOption\n  // Hook.entryOption \n  compiler.hooks.entryOption.tap("EntryOptionPlugin", (context, entry) => {\n   EntryOptionPlugin.applyEntryOption(compiler, context, entry);\n   return true;\n  });\n }\n\n static applyEntryOption(compiler, context, entry) {\n  // entry  DynamicEntryPlugin\n  if (typeof entry === "function") {\n   const DynamicEntryPlugin = require("./DynamicEntryPlugin");\n   new DynamicEntryPlugin(context, entry).apply(compiler);\n  } else {\n   // entry  object EntryPlugin\n   const EntryPlugin = require("./EntryPlugin");\n   //  entries  entry  options\n   //  entry: {\n   //   b2: {\n   //     dependOn: \'a2\',\n   //     import: \'./src/app.js\',\n   //   },\n   // },\n   for (const name of Object.keys(entry)) {\n    const desc = entry[name];\n    const options = EntryOptionPlugin.entryDescriptionToOptions(\n     compiler,\n     name,\n     desc\n    );\n    //  entry  EntryPlugin\n    for (const entry of desc.import) {\n     new EntryPlugin(context, entry, options).apply(compiler);\n    }\n   }\n  }\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n\n * createCompiler  WebpackOptionsApply  EntryOptionPlugin  Hook.entryOption  Entry  import  EntryPlugin \n *  Entry.import  EntryPlugin \n\n EntryPlugin \n\nclass EntryPlugin {\n apply(compiler) {\n  //  CallbackHook.compilation\n  // Hook.compilation   compiler.compile \n  compiler.hooks.compilation.tap(\n   "EntryPlugin",\n   (compilation, { normalModuleFactory }) => {\n    // dependencyFactories  Dependency  ModuleFactory\n    //  EntryDependency  normalModuleFactory\n    compilation.dependencyFactories.set(\n     EntryDependency,\n     normalModuleFactory\n    );\n   }\n  );\n\n  const { entry, options, context } = this;\n  //  EntryDependency\n  const dep = EntryPlugin.createDependency(entry, options);\n  //  Callback Hook.make => tapAsync\n  // Hook.make   compiler.compile \n  compiler.hooks.make.tapAsync("EntryPlugin", (compilation, callback) => {\n   // compilation.addEntry  Entry EntryDependency\n   compilation.addEntry(context, dep, options, (err) => {\n    callback(err);\n   });\n  });\n }\n\n static createDependency(entry, options) {\n  //  EntryDependency \n  const dep = new EntryDependency(entry);\n  // TODO webpack 6 remove string option\n  dep.loc = { name: typeof options === "object" ? options.name : options };\n  return dep;\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n\n *  Hook.compilation  EntryDependency  normalModuleFactory EntryDependency Hook.make  compilation.addEntry \n\n\n# compiler.Hook\n\ncompiler  Hook\n\nthis.hooks = Object.freeze({\n  /** @type {SyncHook<[]>} */\n  initialize: new SyncHook([]),\n\n  /** @type {SyncBailHook<[Compilation], boolean>} */\n  shouldEmit: new SyncBailHook(["compilation"]),\n  /** @type {AsyncSeriesHook<[Stats]>} */\n  done: new AsyncSeriesHook(["stats"]),\n  /** @type {SyncHook<[Stats]>} */\n  afterDone: new SyncHook(["stats"]),\n  /** @type {AsyncSeriesHook<[]>} */\n  additionalPass: new AsyncSeriesHook([]),\n  /** @type {AsyncSeriesHook<[Compiler]>} */\n  beforeRun: new AsyncSeriesHook(["compiler"]),\n  /** @type {AsyncSeriesHook<[Compiler]>} */\n  run: new AsyncSeriesHook(["compiler"]),\n  /** @type {AsyncSeriesHook<[Compilation]>} */\n  emit: new AsyncSeriesHook(["compilation"]),\n  /** @type {AsyncSeriesHook<[string, AssetEmittedInfo]>} */\n  assetEmitted: new AsyncSeriesHook(["file", "info"]),\n  /** @type {AsyncSeriesHook<[Compilation]>} */\n  afterEmit: new AsyncSeriesHook(["compilation"]),\n\n  /** @type {SyncHook<[Compilation, CompilationParams]>} */\n  thisCompilation: new SyncHook(["compilation", "params"]),\n  /** @type {SyncHook<[Compilation, CompilationParams]>} */\n  compilation: new SyncHook(["compilation", "params"]),\n  /** @type {SyncHook<[NormalModuleFactory]>} */\n  normalModuleFactory: new SyncHook(["normalModuleFactory"]),\n  /** @type {SyncHook<[ContextModuleFactory]>}  */\n  contextModuleFactory: new SyncHook(["contextModuleFactory"]),\n\n  /** @type {AsyncSeriesHook<[CompilationParams]>} */\n  beforeCompile: new AsyncSeriesHook(["params"]),\n  /** @type {SyncHook<[CompilationParams]>} */\n  compile: new SyncHook(["params"]),\n  /** @type {AsyncParallelHook<[Compilation]>} */\n  make: new AsyncParallelHook(["compilation"]),\n  /** @type {AsyncParallelHook<[Compilation]>} */\n  finishMake: new AsyncSeriesHook(["compilation"]),\n  /** @type {AsyncSeriesHook<[Compilation]>} */\n  afterCompile: new AsyncSeriesHook(["compilation"]),\n\n  /** @type {AsyncSeriesHook<[]>} */\n  readRecords: new AsyncSeriesHook([]),\n  /** @type {AsyncSeriesHook<[]>} */\n  emitRecords: new AsyncSeriesHook([]),\n\n  /** @type {AsyncSeriesHook<[Compiler]>} */\n  watchRun: new AsyncSeriesHook(["compiler"]),\n  /** @type {SyncHook<[Error]>} */\n  failed: new SyncHook(["error"]),\n  /** @type {SyncHook<[string | null, number]>} */\n  invalid: new SyncHook(["filename", "changeTime"]),\n  /** @type {SyncHook<[]>} */\n  watchClose: new SyncHook([]),\n  /** @type {AsyncSeriesHook<[]>} */\n  shutdown: new AsyncSeriesHook([]),\n\n  /** @type {SyncBailHook<[string, string, any[]], true>} */\n  infrastructureLog: new SyncBailHook(["origin", "type", "args"]),\n\n  /** @type {SyncHook<[]>} */\n  environment: new SyncHook([]),\n  /** @type {SyncHook<[]>} */\n  afterEnvironment: new SyncHook([]),\n  /** @type {SyncHook<[Compiler]>} */\n  afterPlugins: new SyncHook(["compiler"]),\n  /** @type {SyncHook<[Compiler]>} */\n  afterResolvers: new SyncHook(["compiler"]),\n  /** @type {SyncBailHook<[string, Entry], boolean>} */\n  entryOption: new SyncBailHook(["context", "entry"])\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n\nObject.freeze Callbacks \n\n\n# \n\n * suguru03/neo-async: Neo-Async is thought to be used as a drop-in replacement for Async, it almost fully covers its functionality and runs faster\n * compiler  | webpack ',normalizedContent:' webpack  init \n\n * options \n * compiler \n * \n * compiler.run\n\n\n# \n\n\n\n * \n * webpack\n * createcompiler\n * compiler.run\n * compiler.compile\n   * newcompilationparams\n   * newcompilation\n * compilation.addentry\n * compiler.hook\n * \n\n\n\n\n# webpack\n\n// lib/webpack.js\nconst webpack = (options, callback) => {\n  const create = () => {\n      //  options\n   if (!asarray(options).every(webpackoptionsschemacheck)) {\n    getvalidateschema()(webpackoptionsschema, options);\n   }\n   let compiler;\n   let watch = false;\n   let watchoptions;\n   //  options  multicompiler\n   if (array.isarray(options)) {\n    compiler = createmulticompiler(\n     options,\n    );\n    //  watch  watchoptions\n    watch = options.some(options => options.watch);\n    watchoptions = options.map(options => options.watchoptions || {});\n   } else {\n    const webpackoptions = (options);\n    //  compiler\n    compiler = createcompiler(webpackoptions);\n    watch = webpackoptions.watch;\n    watchoptions = webpackoptions.watchoptions || {};\n   }\n   return { compiler, watch, watchoptions };\n  };\n  if (callback) {\n   try {\n    const { compiler, watch, watchoptions } = create();\n    if (watch) {\n      //  watch watching\n     compiler.watch(watchoptions, callback);\n    } else {\n     //  compiler\n     compiler.run((err, stats) => {\n      // compile  compiler\n      compiler.close(err2 => {\n       callback(err || err2, stats);\n      });\n     });\n    }\n    return compiler;\n   } catch (err) {\n    process.nexttick(() => callback(err));\n    return null;\n   }\n  } else {\n   const { compiler, watch } = create();\n   //  ......\n   return compiler;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n\nconst webpack = (options, callback) => {\n //  options\n if (!asarray(options).every(webpackoptionsschemacheck)) {\n  getvalidateschema()(webpackoptionsschema, options);\n }\n\n //  compiler\n const compiler = createcompiler(options);\n\n //  compiler\n compiler.run((err, stats) => {\n  // compile  compiler\n  compiler.close((err2) => {\n   callback(err || err2, stats);\n  });\n });\n\n return compiler;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n\n *  options\n *  options  compiler\n\n\n# createcompiler\n\n// lib/webpack.js\nconst createcompiler = rawoptions => {\n  // options \n const options = getnormalizedwebpackoptions(rawoptions);\n  // merge webpack  optionscontextinfrastructurelogging\n applywebpackoptionsbasedefaults(options);\n  //  compiler\n const compiler = new compiler(options.context, options);\n  // ==========  ========== //\n  //  nodeenvironmentpluginbeforerun =>  node  \n new nodeenvironmentplugin({\n  infrastructurelogging: options.infrastructurelogging\n }).apply(compiler);\n  //  options.plugins\n if (array.isarray(options.plugins)) {\n  for (const plugin of options.plugins) {\n   if (typeof plugin === "function") {\n    plugin.call(compiler, compiler);\n   } else {\n    plugin.apply(compiler);\n   }\n  }\n }\n  // merge webpack  options: contexttargetdevtool\n applywebpackoptionsdefaults(options);\n  //  hook.environment => call\n compiler.hooks.environment.call();\n  //  hook.afterenvironment => call\n compiler.hooks.afterenvironment.call();\n  // webpackoptionsapply  options \n new webpackoptionsapply().process(options, compiler);\n  //  hook.initialize => call\n compiler.hooks.initialize.call();\n  //  compiler\n return compiler;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n\n * options merge  options\n *  compiler \n *  nodeenvironmentpluginoptions.plugins options \n *  hook.environmenthook.afterenvironmenthook.initialize\n\n\n# compiler.run\n\nrun(callback) {\n  //  compiler \n  if (this.running) {\n    return callback(new concurrentcompilationerror());\n  }\n\n  //  err \n  const finalcallback = (err, stats) => {\n    //  compiler  idle\n    this.idle = true;\n    //  cachehook.beginidle => call\n    this.cache.beginidle();\n    this.idle = true;\n    //  compiler running  false\n    this.running = false;\n    if (err) {\n      //  hook.failed => call\n      this.hooks.failed.call(err);\n    }\n    if (callback !== undefined) callback(err, stats);\n    //  hook.afterdone => call\n    this.hooks.afterdone.call(stats);\n  };\n\n  //  running  true\n  this.running = true;\n\n  const run = () => {\n    //  hook.beforerun: callasync \n    this.hooks.beforerun.callasync(this, err => {\n      if (err) return finalcallback(err);\n      //  hook.run: callasync\n      this.hooks.run.callasync(this, err => {\n        if (err) return finalcallback(err);\n        //  records \n        this.readrecords(err => {\n          if (err) return finalcallback(err);\n          //  compile\n          this.compile(oncompiled);\n        });\n      });\n    });\n  };\n  //  false\n  if (this.idle) {\n    //  cachehook.endidle\n    this.cache.endidle(err => {\n      if (err) return finalcallback(err);\n      \n      this.idle = false;\n      run();\n    });\n  } else {\n    run();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n\n *  compiler  idle  cachehook.endidle run run\n * compiler.run  hook.beforerunhook.run recordscompiler   compilecompile  oncompiled compiler  running\n *  finalcallback callback compile  idle cachehook.beginidlehook.failed  hook.afterdone compiler  running \n\n\n# compiler.compile\n\n// lib/compiler.js\ncompile(callback) {\n    //  compilationparams\n  const params = this.newcompilationparams();\n    //  hook.beforecompile => callasync\n  this.hooks.beforecompile.callasync(params, err => {\n   if (err) return callback(err);\n      //  hook.compile => call\n   this.hooks.compile.call(params);\n      //  compilation \n   const compilation = this.newcompilation(params);\n\n   //  hook.make => callasync\n   this.hooks.make.callasync(compilation, err => {\n    if (err) return callback(err);\n    \n    //  hook.finishmake => callasync\n    this.hooks.finishmake.callasync(compilation, err => {\n     if (err) return callback(err);\n\n     process.nexttick(() => {\n      // compilation.finish\n      compilation.finish(err => {\n       if (err) return callback(err);\n\n       // compilation.seal\n       compilation.seal(err => {\n        if (err) return callback(err);\n\n        //  hook.aftercompile => callasync\n        this.hooks.aftercompile.callasync(compilation, err => {\n         if (err) return callback(err);\n\n         return callback(null, compilation);\n        });\n       });\n      });\n     });\n    });\n   });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\ncompile \n\n\n\n *  hook.beforecompilehook.compilehook.makehook.finishmakehook.aftercompile\n * compilation compilation  hook.makehook.finishmake compilation.finishcompilation.seal hook.aftercompile\n\n\n# newcompilationparams\n\n normalmodulefactory  contextmodulefactory\n\nnewcompilationparams() {\nconst params = {\n  // new normalmodulefactory()\n  normalmodulefactory: this.createnormalmodulefactory(),\n  // new contextmodulefactory()\n  contextmodulefactory: this.createcontextmodulefactory()\n};\nreturn params;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# newcompilation\n\n// lib/compiler.js\ncreatecompilation(params) {\n  //  _cleanuplastcompilation  _lastcompilation \n this._cleanuplastcompilation();\n return (this._lastcompilation = new compilation(this, params));\n}\nnewcompilation(params) {\n  //  compilation \n const compilation = this.createcompilation(params);\n compilation.name = this.name;\n compilation.records = this.records;\n  //  hook.thiscompilation => call\n this.hooks.thiscompilation.call(compilation, params);\n  //  hook.compilation => call\n this.hooks.compilation.call(compilation, params);\n return compilation;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n\n *  compilation\n *  hook.thiscompilationhook.compilation\n\n\n# compilation.addentry\n\n createcompiler  new webpackoptionsapply().process(options, compiler)  options \n\n// lib/webpackoptionsapply.js\nnew entryoptionplugin().apply(compiler);\n//  hook.entryoption => call\ncompiler.hooks.entryoption.call(options.context, options.entry);\n\n\n1\n2\n3\n4\n\n\n entryoptionplugin \n\n// lib/entryoptionplugin.js\nclass entryoptionplugin {\n // ......\n apply(compiler) {\n  //  callback: hook.entryoption hook.entryoption  applyentryoption\n  // hook.entryoption \n  compiler.hooks.entryoption.tap("entryoptionplugin", (context, entry) => {\n   entryoptionplugin.applyentryoption(compiler, context, entry);\n   return true;\n  });\n }\n\n static applyentryoption(compiler, context, entry) {\n  // entry  dynamicentryplugin\n  if (typeof entry === "function") {\n   const dynamicentryplugin = require("./dynamicentryplugin");\n   new dynamicentryplugin(context, entry).apply(compiler);\n  } else {\n   // entry  object entryplugin\n   const entryplugin = require("./entryplugin");\n   //  entries  entry  options\n   //  entry: {\n   //   b2: {\n   //     dependon: \'a2\',\n   //     import: \'./src/app.js\',\n   //   },\n   // },\n   for (const name of object.keys(entry)) {\n    const desc = entry[name];\n    const options = entryoptionplugin.entrydescriptiontooptions(\n     compiler,\n     name,\n     desc\n    );\n    //  entry  entryplugin\n    for (const entry of desc.import) {\n     new entryplugin(context, entry, options).apply(compiler);\n    }\n   }\n  }\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n\n * createcompiler  webpackoptionsapply  entryoptionplugin  hook.entryoption  entry  import  entryplugin \n *  entry.import  entryplugin \n\n entryplugin \n\nclass entryplugin {\n apply(compiler) {\n  //  callbackhook.compilation\n  // hook.compilation   compiler.compile \n  compiler.hooks.compilation.tap(\n   "entryplugin",\n   (compilation, { normalmodulefactory }) => {\n    // dependencyfactories  dependency  modulefactory\n    //  entrydependency  normalmodulefactory\n    compilation.dependencyfactories.set(\n     entrydependency,\n     normalmodulefactory\n    );\n   }\n  );\n\n  const { entry, options, context } = this;\n  //  entrydependency\n  const dep = entryplugin.createdependency(entry, options);\n  //  callback hook.make => tapasync\n  // hook.make   compiler.compile \n  compiler.hooks.make.tapasync("entryplugin", (compilation, callback) => {\n   // compilation.addentry  entry entrydependency\n   compilation.addentry(context, dep, options, (err) => {\n    callback(err);\n   });\n  });\n }\n\n static createdependency(entry, options) {\n  //  entrydependency \n  const dep = new entrydependency(entry);\n  // todo webpack 6 remove string option\n  dep.loc = { name: typeof options === "object" ? options.name : options };\n  return dep;\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n\n *  hook.compilation  entrydependency  normalmodulefactory entrydependency hook.make  compilation.addentry \n\n\n# compiler.hook\n\ncompiler  hook\n\nthis.hooks = object.freeze({\n  /** @type {synchook<[]>} */\n  initialize: new synchook([]),\n\n  /** @type {syncbailhook<[compilation], boolean>} */\n  shouldemit: new syncbailhook(["compilation"]),\n  /** @type {asyncserieshook<[stats]>} */\n  done: new asyncserieshook(["stats"]),\n  /** @type {synchook<[stats]>} */\n  afterdone: new synchook(["stats"]),\n  /** @type {asyncserieshook<[]>} */\n  additionalpass: new asyncserieshook([]),\n  /** @type {asyncserieshook<[compiler]>} */\n  beforerun: new asyncserieshook(["compiler"]),\n  /** @type {asyncserieshook<[compiler]>} */\n  run: new asyncserieshook(["compiler"]),\n  /** @type {asyncserieshook<[compilation]>} */\n  emit: new asyncserieshook(["compilation"]),\n  /** @type {asyncserieshook<[string, assetemittedinfo]>} */\n  assetemitted: new asyncserieshook(["file", "info"]),\n  /** @type {asyncserieshook<[compilation]>} */\n  afteremit: new asyncserieshook(["compilation"]),\n\n  /** @type {synchook<[compilation, compilationparams]>} */\n  thiscompilation: new synchook(["compilation", "params"]),\n  /** @type {synchook<[compilation, compilationparams]>} */\n  compilation: new synchook(["compilation", "params"]),\n  /** @type {synchook<[normalmodulefactory]>} */\n  normalmodulefactory: new synchook(["normalmodulefactory"]),\n  /** @type {synchook<[contextmodulefactory]>}  */\n  contextmodulefactory: new synchook(["contextmodulefactory"]),\n\n  /** @type {asyncserieshook<[compilationparams]>} */\n  beforecompile: new asyncserieshook(["params"]),\n  /** @type {synchook<[compilationparams]>} */\n  compile: new synchook(["params"]),\n  /** @type {asyncparallelhook<[compilation]>} */\n  make: new asyncparallelhook(["compilation"]),\n  /** @type {asyncparallelhook<[compilation]>} */\n  finishmake: new asyncserieshook(["compilation"]),\n  /** @type {asyncserieshook<[compilation]>} */\n  aftercompile: new asyncserieshook(["compilation"]),\n\n  /** @type {asyncserieshook<[]>} */\n  readrecords: new asyncserieshook([]),\n  /** @type {asyncserieshook<[]>} */\n  emitrecords: new asyncserieshook([]),\n\n  /** @type {asyncserieshook<[compiler]>} */\n  watchrun: new asyncserieshook(["compiler"]),\n  /** @type {synchook<[error]>} */\n  failed: new synchook(["error"]),\n  /** @type {synchook<[string | null, number]>} */\n  invalid: new synchook(["filename", "changetime"]),\n  /** @type {synchook<[]>} */\n  watchclose: new synchook([]),\n  /** @type {asyncserieshook<[]>} */\n  shutdown: new asyncserieshook([]),\n\n  /** @type {syncbailhook<[string, string, any[]], true>} */\n  infrastructurelog: new syncbailhook(["origin", "type", "args"]),\n\n  /** @type {synchook<[]>} */\n  environment: new synchook([]),\n  /** @type {synchook<[]>} */\n  afterenvironment: new synchook([]),\n  /** @type {synchook<[compiler]>} */\n  afterplugins: new synchook(["compiler"]),\n  /** @type {synchook<[compiler]>} */\n  afterresolvers: new synchook(["compiler"]),\n  /** @type {syncbailhook<[string, entry], boolean>} */\n  entryoption: new syncbailhook(["context", "entry"])\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n\nobject.freeze callbacks \n\n\n# \n\n * suguru03/neo-async: neo-async is thought to be used as a drop-in replacement for async, it almost fully covers its functionality and runs faster\n * compiler  | webpack ',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"init options",frontmatter:{title:"init options",date:"2022-04-22T15:26:43.000Z",permalink:"/webpack/init/options/",categories:["webpack","init"],tags:[null]},regularPath:"/30.web/7.webpack/20.init%E9%98%B6%E6%AE%B5/20.options.html",relativePath:"30.web/7.webpack/20.init/20.options.md",key:"v-397f75f5",path:"/webpack/init/options/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:91},{level:2,title:"getNormalizedWebpackOptions",slug:"getnormalizedwebpackoptions",normalizedTitle:"getnormalizedwebpackoptions",charIndex:106},{level:2,title:" option",slug:"-option",normalizedTitle:" option",charIndex:137},{level:2,title:"applyWebpackOptionsBaseDefaults  applyWebpackOptionsDefaults",slug:"applywebpackoptionsbasedefaults--applywebpackoptionsdefaults",normalizedTitle:"applywebpackoptionsbasedefaults  applywebpackoptionsdefaults",charIndex:150},{level:2,title:"NodeEnvironmentPlugin",slug:"nodeenvironmentplugin",normalizedTitle:"nodeenvironmentplugin",charIndex:215},{level:2,title:"WebpackOptionsApply",slug:"webpackoptionsapply",normalizedTitle:"webpackoptionsapply",charIndex:240},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:263}],excerpt:"<TimeToRead />\n<p> compiler  webpack  init  init  options </p>\n",readingTime:{text:"7 min read",minutes:6.83,time:409800,words:1366},headersStr:" getNormalizedWebpackOptions  option applyWebpackOptionsBaseDefaults  applyWebpackOptionsDefaults NodeEnvironmentPlugin WebpackOptionsApply ",content:' compiler  webpack  init  init  options \n\n\n# \n\n\n\n * \n * getNormalizedWebpackOptions\n *  option\n * applyWebpackOptionsBaseDefaults  applyWebpackOptionsDefaults\n * NodeEnvironmentPlugin\n * WebpackOptionsApply\n * \n\n\n\n\n# getNormalizedWebpackOptions\n\n// lib/config/normalization.js\nconst getNormalizedWebpackOptions = configs => {\n  // ......\n  return normalizedConfigs;\n};\n\n\n1\n2\n3\n4\n5\n\n\nnormalizeoptions option \n\n webpack  options \n\n\n#  option\n\nwebpack  option\n\nOPTION                  \namd                      require.amd  define.amd  amd  false  webpack \n                        AMD \nbail                     webpack \ncache                    webpack  chunk  \ncontext                  (entry point)   (loader)\n                        Node.js \ndependencies             name sibling\ndevServer                webpack-dev-server\ndevtool                  source map\nentry                    HTML\n                         (SPA) (MPA)\nexperiments             experiments  webpack 5 \nexternals                import  (package)  bundle  (runtime)\n                         (external dependencies)\nexternalsPresets         target  externals  preset\nexternalsType            externals  external  amdumdsystem  jsonp\n                        output.libraryTarget \nignoreWarnings           webpack \ninfrastructureLogging   \nloader                   loader  \nmode                     mode  webpack \nmodule                  \n                        \nname                    \nnode                     polyfill  mock  Node.js  webpack \n                        NodeStuffPlugin \noptimization             webpack 4  mode  \noutput                  output  (key) webpack\n                        bundleasset  webpack \nparallelism             \nperformance              webpack  (asset) \nplugins                 plugins  webpack webpack \n                        webpack.[plugin-name] \nprofile                  "" Analyze \nrecordsInputPath        \nrecordsOutputPath       \nresolve                 webpack \nresolveLoader            resolve   webpack  loader \nsnapshot                snapshot \nstats                   stats  bundle   quiet  noInfo\n                         bundle  stats\n                        \ntarget                  webpack  target  webpack  (target)\n                         "browserslist" browserslist \n                        "web"\nwatch                    Watch webpack \nwatchOptions             watch \n\n\n\n * Why AMD?\n * Plugins | webpack \n\n\n# applyWebpackOptionsBaseDefaults  applyWebpackOptionsDefaults\n\n webpack  options  options\n\n applyWebpackOptionsDefaults \n\ncontext/target/devtool/watch/profile/parallelism/recordsInputPath/recordsOutputPath => cache => applySnapshotDefaults => applyModuleDefaults => applyOutputDefaults => applyExternalsPresetsDefaults => applyLoaderDefaults => externalsType => applyNodeDefaults => performance => applyPerformanceDefaults => applyOptimizationDefaults ......\n\n\n1\n\n\n\n\n// Sets a constant default value when undefined\nconst D = (obj, prop, value) => {\n if (obj[prop] === undefined) {\n  obj[prop] = value;\n }\n};\n// Sets a dynamic default value when undefined, by calling the factory function\nconst F = (obj, prop, factory) => {\n if (obj[prop] === undefined) {\n  obj[prop] = factory();\n }\n};\n// \nconst A = (obj, prop, factory) => {\n const value = obj[prop];\n if (value === undefined) {\n  obj[prop] = factory();\n } else if (Array.isArray(value)) {\n  let newArray = undefined;\n  for (let i = 0; i < value.length; i++) {\n   const item = value[i];\n   if (item === "...") {\n    if (newArray === undefined) {\n     newArray = value.slice(0, i);\n     //  newArray  newArray \n     obj[prop] = newArray;\n    }\n    const items = factory();\n    if (items !== undefined) {\n     for (const item of items) {\n      newArray.push(item);\n     }\n    }\n   } else if (newArray !== undefined) {\n    newArray.push(item);\n   }\n  }\n }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# NodeEnvironmentPlugin\n\n Node  infrastructureLogger io  inputFileSystem watch  watchFileSystem\n\nclass NodeEnvironmentPlugin {\n apply(compiler) {\n  const { infrastructureLogging } = this.options;\n  //  infrastructureLogger\n  compiler.infrastructureLogger = createConsoleLogger(/** ...... */);\n  // inputFileSystem  watchFileSystem\n  compiler.inputFileSystem = new CachedInputFileSystem(fs, 60000);\n  const inputFileSystem = compiler.inputFileSystem;\n  compiler.outputFileSystem = fs;\n  compiler.intermediateFileSystem = fs;\n  // this.watcher = new Watchpack(this.watcherOptions);\n  compiler.watchFileSystem = new NodeWatchFileSystem(\n   compiler.inputFileSystem\n  );\n  //  CallbackHook.beforeRun\n  compiler.hooks.beforeRun.tap("NodeEnvironmentPlugin", (compiler) => {\n   if (compiler.inputFileSystem === inputFileSystem) {\n    compiler.fsStartTime = Date.now();\n    inputFileSystem.purge();\n   }\n  });\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * inputFileSystem  watchFileSystem  enhanced-resolve  watchpack \n\n\n# WebpackOptionsApply\n\n apply  webpack   options \n\nlib/WebpackOptionsApply.js\n\nOPTION                                                                                                                                                                                                                                                 \nexternals                             ExternalsPlugin                                                                                                                                        bundle                                               CompilerHook.compile => ExternalModuleFactoryPlugin =>\n                                                                                                                                                                                                                                                           NormalModuleFactoryHook.factorize => handleExternals =>\n                                                                                                                                                                                                                                                           handleExternal\nexternalsPresets.node                 NodeTargetPlugin                                                                                                                                       node.js  external  fspath  vm require    ExternalsPlugin("node-commonjs", builtins)\n                                                                                                                                                                                            () \nexternalsPresets.electronMain         ElectronTargetPlugin("main")                                                                                                                           main  electron  external  appipc-main       ExternalsPlugin\n                                                                                                                                                                                            shell require () \nexternalsPresets.electronPreload      ElectronTargetPlugin("preload")                                                                                                                        electron  external                          ExternalsPlugin\n                                                                                                                                                                                            web-frameipc-renderer  shell require () \nexternalsPresets.electronRenderer     ElectronTargetPlugin("renderer")                                                                                                                       renderer  electron  external                   ExternalsPlugin\n                                                                                                                                                                                            web-frameipc-renderer  shell require () \nexternalsPresets.electron             ElectronTargetPlugin                                                                                                                                   main  electron  external                ExternalsPlugin\n                                                                                                                                                                                            electronipc  shell require () \nexternalsPresets.nwjs                 ExternalsPlugin("node-commonjs", "nw.gui")                                                                                                             NW.js  nw.gui  external  require ()        ExternalsPlugin\nexternalsPresets.webAsync             ExternalsPlugin("import")                                                                                                                              \'http (s)/...\' \'std:...\'  external  async   ExternalsPlugin\n                                                                                                                                                                                            import ()  external  async \nexternalsPresets.web                  ExternalsPlugin("module")                                                                                                                              http (s)/...  std:...  external  import        ExternalsPlugin\n                                                                                                                                                                                             external \n                                      ChunkPrefetchPreloadPlugin                                                                                                                                                                                           CompilerHook.compilation => ......\noutput.chunkFormat                    ArrayPushCallbackChunkFormatPluginCommonJsChunkFormatPluginModuleChunkFormatPlugin                                                                  chunk formats  \'array-push\'                            \n                                                                                                                                                                                            (web/WebWorker)\'commonjs\' (node.js)\'module\' (ESM))\noutput.enabledChunkLoadingTypes       EnableChunkLoadingPlugin                                                                                                                                                                                             \noutput.enabledWasmLoadingTypes        EnableWasmLoadingPlugin                                                                                                                                                                                              \noutput.enabledLibraryTypes            EnableLibraryPlugin                                                                                                                                                                                                  \noutput.pathinfo                       ModuleInfoHeaderPlugin                                                                                                                                                                                               \noutput.clean                          CleanPlugin                                                                                                                                                                                                          \ndevtool                               EvalSourceMapDevToolPluginSourceMapDevToolPluginEvalDevToolModulePluginEvalDevToolModulePlugin                                                                                                                    \n                                                                                                                                                                                                                                                           \n                                      JavascriptModulesPlugin                                                                                                                                                                                              \n                                      JsonModulesPlugin                                                                                                                                                                                                    \n                                      AssetModulesPlugin                                                                                                                                                                                                   \nexperiments.syncWebAssembly           WebAssemblyModulesPlugin                                                                                                                                                                                             \nexperiments.asyncWebAssembly          AsyncWebAssemblyModulesPlugin                                                                                                                                                                                        \nexperiments.css                       CssModulesPlugin                                                                                                                                                                                                     \nexperiments.lazyCompilation           LazyCompilationPlugin                                                                                                                                                                                                \nexperiments.buildHttp                 HttpUriPlugin                                                                                                                                                                                                        \n                                      EntryOptionPlugin                                                                                                                                                                                                    \n                                      RuntimePlugin                                                                                                                                                                                                        \n                                      InferAsyncModulesPlugin                                                                                                                                                                                              \n                                      DataUriPlugin                                                                                                                                                                                                        \n                                      FileUriPlugin                                                                                                                                                                                                        \n                                      CompatibilityPlugin                                                                                                                                   Currently useless. Ensures compatibility with other module     \n                                                                                                                                                                                            loaders.\n                                      HarmonyModulesPlugin                                                                                                                                                                                                 \noptions.amd                           AMDPluginRequireJsStuffPlugin                                                                                                                                                                                       \n                                      CommonJsPlugin                                                                                                                                                                                                       \n                                      LoaderPlugin                                                                                                                                                                                                         \n                                      APIPlugin                                                                                                                                                                                                            \n                                      ExportsInfoApiPlugin                                                                                                                                                                                                 \n                                      WebpackIsIncludedPlugin                                                                                                                                                                                              \n                                      ConstPlugin                                                                                                                                                                                                          \n                                      UseStrictPlugin                                                                                                                                                                                                      \n                                      RequireIncludePlugin                                                                                                                                                                                                 \n                                      RequireEnsurePlugin                                                                                                                                                                                                  \n                                      RequireContextPlugin                                                                                                                                                                                                 \n                                      ImportPlugin                                                                                                                                                                                                         \n                                      ImportMetaContextPlugin                                                                                                                                                                                              \n                                      SystemPlugin                                                                                                                                                                                                         \n                                      ImportMetaPlugin                                                                                                                                                                                                     \n                                      URLPlugin                                                                                                                                                                                                            \n                                      SystemPlugin                                                                                                                                                                                                         \n                                      WorkerPlugin                                                                                                                                                                                                         \n                                      DefaultStatsFactoryPlugin                                                                                                                                                                                            \n                                      JavascriptMetaInfoPlugin                                                                                                                                                                                             \noptions.mode                          WarnNoModeSetPlugin                                                                                                                                                                                                  \n                                      EnsureChunkConditionsPlugin                                                                                                                                                                                          \noptimization.removeAvailableModules   RemoveParentModulesPlugin                                                                                                                                                                                            \noptimization.removeEmptyChunks        RemoveEmptyChunksPlugin                                                                                                                                                                                              \noptimization.mergeDuplicateChunks     MergeDuplicateChunksPlugin                                                                                                                                                                                           \noptimization.flagIncludedChunks       FlagIncludedChunksPlugin                                                                                                                                                                                             \noptimization.sideEffects              SideEffectsFlagPlugin                                                                                                                                                                                                \noptimization.providedExports          FlagDependencyExportsPlugin                                                                                                                                                                                          \noptimization.usedExports              FlagDependencyUsagePlugin                                                                                                                                                                                            \noptimization.innerGraph               InnerGraphPlugin                                                                                                                                                                                                     \noptimization.mangleExports            MangleExportsPlugin                                                                                                                                                                                                  \noptimization.concatenateModules       ModuleConcatenationPlugin                                                                                                                                                                                            \noptimization.splitChunks              SplitChunksPlugin                                                                                                                                                                                                    \noptimization.emitOnErrors             NoEmitOnErrorsPlugin                                                                                                                                                                                                 \noptimization.realContentHash          RealContentHashPlugin                                                                                                                                                                                                \noptimization.checkWasmTypes           WasmFinalizeExportsPlugin                                                                                                                                                                                            \noptimization.moduleIds                NaturalModuleIdsPluginNamedModuleIdsPluginWarnDeprecatedOptionPluginHashedModuleIdsPluginDeterministicModuleIdsPluginOccurrenceModuleIdsPlugin                                                                  \noptimization.chunkIds                 NaturalChunkIdsPluginNamedChunkIdsPluginDeterministicChunkIdsPluginOccurrenceChunkIdsPlugin                                                                                                                       \noptimization.nodeEnv                  DefinePlugin                                                                                                                                          DefinePlugin                                             \n                                                                                                                                                                                            \noptimization.performance              SizeLimitsPlugin                                                                                                                                                                                                     \n                                      TemplatedPathPlugin                                                                                                                                                                                                  \n                                      RecordIdsPlugin                                                                                                                                                                                                      \n                                      WarnCaseSensitiveModulesPlugin                                                                                                                                                                                       \n                                      AddManagedPathsPlugin                                                                                                                                                                                                \ncache                                 MemoryWithGcCachePluginMemoryCachePluginAddBuildDependenciesPluginIdleFileCachePluginPackFileCacheStrategy                                                                                                       \n                                      ResolverCachePlugin                                                                                                                                                                                                  \nignoreWarnings                        IgnoreWarningsPlugin                                                                                                                                                                                                 \n\n\n# \n\n * webpack/enhanced-resolve: Offers an async require.resolve function. It\'s highly configurable.\n * webpack/watchpack: Wrapper library for directory and file watching.\n * Plugins | webpack ',normalizedContent:' compiler  webpack  init  init  options \n\n\n# \n\n\n\n * \n * getnormalizedwebpackoptions\n *  option\n * applywebpackoptionsbasedefaults  applywebpackoptionsdefaults\n * nodeenvironmentplugin\n * webpackoptionsapply\n * \n\n\n\n\n# getnormalizedwebpackoptions\n\n// lib/config/normalization.js\nconst getnormalizedwebpackoptions = configs => {\n  // ......\n  return normalizedconfigs;\n};\n\n\n1\n2\n3\n4\n5\n\n\nnormalizeoptions option \n\n webpack  options \n\n\n#  option\n\nwebpack  option\n\noption                  \namd                      require.amd  define.amd  amd  false  webpack \n                        amd \nbail                     webpack \ncache                    webpack  chunk  \ncontext                  (entry point)   (loader)\n                        node.js \ndependencies             name sibling\ndevserver                webpack-dev-server\ndevtool                  source map\nentry                    html\n                         (spa) (mpa)\nexperiments             experiments  webpack 5 \nexternals                import  (package)  bundle  (runtime)\n                         (external dependencies)\nexternalspresets         target  externals  preset\nexternalstype            externals  external  amdumdsystem  jsonp\n                        output.librarytarget \nignorewarnings           webpack \ninfrastructurelogging   \nloader                   loader  \nmode                     mode  webpack \nmodule                  \n                        \nname                    \nnode                     polyfill  mock  node.js  webpack \n                        nodestuffplugin \noptimization             webpack 4  mode  \noutput                  output  (key) webpack\n                        bundleasset  webpack \nparallelism             \nperformance              webpack  (asset) \nplugins                 plugins  webpack webpack \n                        webpack.[plugin-name] \nprofile                  "" analyze \nrecordsinputpath        \nrecordsoutputpath       \nresolve                 webpack \nresolveloader            resolve   webpack  loader \nsnapshot                snapshot \nstats                   stats  bundle   quiet  noinfo\n                         bundle  stats\n                        \ntarget                  webpack  target  webpack  (target)\n                         "browserslist" browserslist \n                        "web"\nwatch                    watch webpack \nwatchoptions             watch \n\n\n\n * why amd?\n * plugins | webpack \n\n\n# applywebpackoptionsbasedefaults  applywebpackoptionsdefaults\n\n webpack  options  options\n\n applywebpackoptionsdefaults \n\ncontext/target/devtool/watch/profile/parallelism/recordsinputpath/recordsoutputpath => cache => applysnapshotdefaults => applymoduledefaults => applyoutputdefaults => applyexternalspresetsdefaults => applyloaderdefaults => externalstype => applynodedefaults => performance => applyperformancedefaults => applyoptimizationdefaults ......\n\n\n1\n\n\n\n\n// sets a constant default value when undefined\nconst d = (obj, prop, value) => {\n if (obj[prop] === undefined) {\n  obj[prop] = value;\n }\n};\n// sets a dynamic default value when undefined, by calling the factory function\nconst f = (obj, prop, factory) => {\n if (obj[prop] === undefined) {\n  obj[prop] = factory();\n }\n};\n// \nconst a = (obj, prop, factory) => {\n const value = obj[prop];\n if (value === undefined) {\n  obj[prop] = factory();\n } else if (array.isarray(value)) {\n  let newarray = undefined;\n  for (let i = 0; i < value.length; i++) {\n   const item = value[i];\n   if (item === "...") {\n    if (newarray === undefined) {\n     newarray = value.slice(0, i);\n     //  newarray  newarray \n     obj[prop] = newarray;\n    }\n    const items = factory();\n    if (items !== undefined) {\n     for (const item of items) {\n      newarray.push(item);\n     }\n    }\n   } else if (newarray !== undefined) {\n    newarray.push(item);\n   }\n  }\n }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# nodeenvironmentplugin\n\n node  infrastructurelogger io  inputfilesystem watch  watchfilesystem\n\nclass nodeenvironmentplugin {\n apply(compiler) {\n  const { infrastructurelogging } = this.options;\n  //  infrastructurelogger\n  compiler.infrastructurelogger = createconsolelogger(/** ...... */);\n  // inputfilesystem  watchfilesystem\n  compiler.inputfilesystem = new cachedinputfilesystem(fs, 60000);\n  const inputfilesystem = compiler.inputfilesystem;\n  compiler.outputfilesystem = fs;\n  compiler.intermediatefilesystem = fs;\n  // this.watcher = new watchpack(this.watcheroptions);\n  compiler.watchfilesystem = new nodewatchfilesystem(\n   compiler.inputfilesystem\n  );\n  //  callbackhook.beforerun\n  compiler.hooks.beforerun.tap("nodeenvironmentplugin", (compiler) => {\n   if (compiler.inputfilesystem === inputfilesystem) {\n    compiler.fsstarttime = date.now();\n    inputfilesystem.purge();\n   }\n  });\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * inputfilesystem  watchfilesystem  enhanced-resolve  watchpack \n\n\n# webpackoptionsapply\n\n apply  webpack   options \n\nlib/webpackoptionsapply.js\n\noption                                                                                                                                                                                                                                                 \nexternals                             externalsplugin                                                                                                                                        bundle                                               compilerhook.compile => externalmodulefactoryplugin =>\n                                                                                                                                                                                                                                                           normalmodulefactoryhook.factorize => handleexternals =>\n                                                                                                                                                                                                                                                           handleexternal\nexternalspresets.node                 nodetargetplugin                                                                                                                                       node.js  external  fspath  vm require    externalsplugin("node-commonjs", builtins)\n                                                                                                                                                                                            () \nexternalspresets.electronmain         electrontargetplugin("main")                                                                                                                           main  electron  external  appipc-main       externalsplugin\n                                                                                                                                                                                            shell require () \nexternalspresets.electronpreload      electrontargetplugin("preload")                                                                                                                        electron  external                          externalsplugin\n                                                                                                                                                                                            web-frameipc-renderer  shell require () \nexternalspresets.electronrenderer     electrontargetplugin("renderer")                                                                                                                       renderer  electron  external                   externalsplugin\n                                                                                                                                                                                            web-frameipc-renderer  shell require () \nexternalspresets.electron             electrontargetplugin                                                                                                                                   main  electron  external                externalsplugin\n                                                                                                                                                                                            electronipc  shell require () \nexternalspresets.nwjs                 externalsplugin("node-commonjs", "nw.gui")                                                                                                             nw.js  nw.gui  external  require ()        externalsplugin\nexternalspresets.webasync             externalsplugin("import")                                                                                                                              \'http (s)/...\' \'std:...\'  external  async   externalsplugin\n                                                                                                                                                                                            import ()  external  async \nexternalspresets.web                  externalsplugin("module")                                                                                                                              http (s)/...  std:...  external  import        externalsplugin\n                                                                                                                                                                                             external \n                                      chunkprefetchpreloadplugin                                                                                                                                                                                           compilerhook.compilation => ......\noutput.chunkformat                    arraypushcallbackchunkformatplugincommonjschunkformatpluginmodulechunkformatplugin                                                                  chunk formats  \'array-push\'                            \n                                                                                                                                                                                            (web/webworker)\'commonjs\' (node.js)\'module\' (esm))\noutput.enabledchunkloadingtypes       enablechunkloadingplugin                                                                                                                                                                                             \noutput.enabledwasmloadingtypes        enablewasmloadingplugin                                                                                                                                                                                              \noutput.enabledlibrarytypes            enablelibraryplugin                                                                                                                                                                                                  \noutput.pathinfo                       moduleinfoheaderplugin                                                                                                                                                                                               \noutput.clean                          cleanplugin                                                                                                                                                                                                          \ndevtool                               evalsourcemapdevtoolpluginsourcemapdevtoolpluginevaldevtoolmodulepluginevaldevtoolmoduleplugin                                                                                                                    \n                                                                                                                                                                                                                                                           \n                                      javascriptmodulesplugin                                                                                                                                                                                              \n                                      jsonmodulesplugin                                                                                                                                                                                                    \n                                      assetmodulesplugin                                                                                                                                                                                                   \nexperiments.syncwebassembly           webassemblymodulesplugin                                                                                                                                                                                             \nexperiments.asyncwebassembly          asyncwebassemblymodulesplugin                                                                                                                                                                                        \nexperiments.css                       cssmodulesplugin                                                                                                                                                                                                     \nexperiments.lazycompilation           lazycompilationplugin                                                                                                                                                                                                \nexperiments.buildhttp                 httpuriplugin                                                                                                                                                                                                        \n                                      entryoptionplugin                                                                                                                                                                                                    \n                                      runtimeplugin                                                                                                                                                                                                        \n                                      inferasyncmodulesplugin                                                                                                                                                                                              \n                                      datauriplugin                                                                                                                                                                                                        \n                                      fileuriplugin                                                                                                                                                                                                        \n                                      compatibilityplugin                                                                                                                                   currently useless. ensures compatibility with other module     \n                                                                                                                                                                                            loaders.\n                                      harmonymodulesplugin                                                                                                                                                                                                 \noptions.amd                           amdpluginrequirejsstuffplugin                                                                                                                                                                                       \n                                      commonjsplugin                                                                                                                                                                                                       \n                                      loaderplugin                                                                                                                                                                                                         \n                                      apiplugin                                                                                                                                                                                                            \n                                      exportsinfoapiplugin                                                                                                                                                                                                 \n                                      webpackisincludedplugin                                                                                                                                                                                              \n                                      constplugin                                                                                                                                                                                                          \n                                      usestrictplugin                                                                                                                                                                                                      \n                                      requireincludeplugin                                                                                                                                                                                                 \n                                      requireensureplugin                                                                                                                                                                                                  \n                                      requirecontextplugin                                                                                                                                                                                                 \n                                      importplugin                                                                                                                                                                                                         \n                                      importmetacontextplugin                                                                                                                                                                                              \n                                      systemplugin                                                                                                                                                                                                         \n                                      importmetaplugin                                                                                                                                                                                                     \n                                      urlplugin                                                                                                                                                                                                            \n                                      systemplugin                                                                                                                                                                                                         \n                                      workerplugin                                                                                                                                                                                                         \n                                      defaultstatsfactoryplugin                                                                                                                                                                                            \n                                      javascriptmetainfoplugin                                                                                                                                                                                             \noptions.mode                          warnnomodesetplugin                                                                                                                                                                                                  \n                                      ensurechunkconditionsplugin                                                                                                                                                                                          \noptimization.removeavailablemodules   removeparentmodulesplugin                                                                                                                                                                                            \noptimization.removeemptychunks        removeemptychunksplugin                                                                                                                                                                                              \noptimization.mergeduplicatechunks     mergeduplicatechunksplugin                                                                                                                                                                                           \noptimization.flagincludedchunks       flagincludedchunksplugin                                                                                                                                                                                             \noptimization.sideeffects              sideeffectsflagplugin                                                                                                                                                                                                \noptimization.providedexports          flagdependencyexportsplugin                                                                                                                                                                                          \noptimization.usedexports              flagdependencyusageplugin                                                                                                                                                                                            \noptimization.innergraph               innergraphplugin                                                                                                                                                                                                     \noptimization.mangleexports            mangleexportsplugin                                                                                                                                                                                                  \noptimization.concatenatemodules       moduleconcatenationplugin                                                                                                                                                                                            \noptimization.splitchunks              splitchunksplugin                                                                                                                                                                                                    \noptimization.emitonerrors             noemitonerrorsplugin                                                                                                                                                                                                 \noptimization.realcontenthash          realcontenthashplugin                                                                                                                                                                                                \noptimization.checkwasmtypes           wasmfinalizeexportsplugin                                                                                                                                                                                            \noptimization.moduleids                naturalmoduleidspluginnamedmoduleidspluginwarndeprecatedoptionpluginhashedmoduleidsplugindeterministicmoduleidspluginoccurrencemoduleidsplugin                                                                  \noptimization.chunkids                 naturalchunkidspluginnamedchunkidsplugindeterministicchunkidspluginoccurrencechunkidsplugin                                                                                                                       \noptimization.nodeenv                  defineplugin                                                                                                                                          defineplugin                                             \n                                                                                                                                                                                            \noptimization.performance              sizelimitsplugin                                                                                                                                                                                                     \n                                      templatedpathplugin                                                                                                                                                                                                  \n                                      recordidsplugin                                                                                                                                                                                                      \n                                      warncasesensitivemodulesplugin                                                                                                                                                                                       \n                                      addmanagedpathsplugin                                                                                                                                                                                                \ncache                                 memorywithgccachepluginmemorycachepluginaddbuilddependenciespluginidlefilecachepluginpackfilecachestrategy                                                                                                       \n                                      resolvercacheplugin                                                                                                                                                                                                  \nignorewarnings                        ignorewarningsplugin                                                                                                                                                                                                 \n\n\n# \n\n * webpack/enhanced-resolve: offers an async require.resolve function. it\'s highly configurable.\n * webpack/watchpack: wrapper library for directory and file watching.\n * plugins | webpack ',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-04-22T15:21:45.000Z",permalink:"/webpack/make/index/",categories:["more","webpack","make"],tags:[null]},regularPath:"/30.web/7.webpack/30.make%E9%98%B6%E6%AE%B5/0.index.html",relativePath:"30.web/7.webpack/30.make/0.index.md",key:"v-b6310e56",path:"/webpack/make/index/",headers:[{level:2,title:"RoadMap",slug:"roadmap",normalizedTitle:"roadmap",charIndex:154},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:168}],excerpt:"<p> webpack init  options compiler ( Hook)compiler.runcompiler.compile  webpack make </p>\n",readingTime:{text:"1 min read",minutes:.15,time:9e3,words:30},headersStr:"RoadMap ",content:" webpack init  options compiler ( Hook)compiler.runcompiler.compile  webpack make \n\n\n# RoadMap\n\n\n\n\n# \n\nWebpack Make Roadmap   []  Webpack  - ",normalizedContent:" webpack init  options compiler ( hook)compiler.runcompiler.compile  webpack make \n\n\n# roadmap\n\n\n\n\n# \n\nwebpack make roadmap   []  webpack  - ",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"make compilation",frontmatter:{title:"make compilation",date:"2022-04-22T14:39:35.000Z",permalink:"/webpack/make/compilation/",categories:["webpack","init"],tags:[null]},regularPath:"/30.web/7.webpack/30.make%E9%98%B6%E6%AE%B5/10.compilation.html",relativePath:"30.web/7.webpack/30.make/10.compilation.md",key:"v-0d9c3a15",path:"/webpack/make/compilation/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"compilation.addEntry",slug:"compilation-addentry",normalizedTitle:"compilation.addentry",charIndex:17},{level:2,title:"addModuleTree",slug:"addmoduletree",normalizedTitle:"addmoduletree",charIndex:41},{level:2,title:"handleModuleCreation",slug:"handlemodulecreation",normalizedTitle:"handlemodulecreation",charIndex:58},{level:3,title:"factorizeModule",slug:"factorizemodule",normalizedTitle:"factorizemodule",charIndex:84},{level:3,title:"addModule",slug:"addmodule",normalizedTitle:"addmodule",charIndex:41},{level:2,title:"moduleGraph",slug:"modulegraph",normalizedTitle:"modulegraph",charIndex:118},{level:2,title:"AsyncQueue",slug:"asyncqueue",normalizedTitle:"asyncqueue",charIndex:133},{level:2,title:"compilation.Hook",slug:"compilation-hook",normalizedTitle:"compilation.hook",charIndex:147}],excerpt:'<TimeToRead />\n<h2 id=""><a class="header-anchor" href="#">#</a> </h2>\n<p><div class="table-of-contents"><ul><li><a href="#"></a></li></ul></div></p>\n<p> compiler.compile  compilation CompilerHook.make   <code>compilation.addEntry</code>   <code>EntryDependency</code>  </p>\n<p> CompilerHook.make   <code>make</code>  </p>\n<p> webpack  make </p>\n<ul>\n<li>compilation.addEntry</li>\n</ul>\n',readingTime:{text:"8 min read",minutes:7.5,time:45e4,words:1500},headersStr:" compilation.addEntry addModuleTree handleModuleCreation factorizeModule addModule moduleGraph AsyncQueue compilation.Hook",content:'# \n\n\n\n * \n * compilation.addEntry\n * addModuleTree\n * handleModuleCreation\n   * factorizeModule\n   * addModule\n * moduleGraph\n * AsyncQueue\n * compilation.Hook\n\n\n\n compiler.compile  compilation CompilerHook.make  compilation.addEntry  EntryDependency \n\n CompilerHook.make  make \n\n webpack  make \n\n * compilation.addEntry\n\n\n# compilation.addEntry\n\n _addEntryItem  _addEntryItem  addEntry  addInclude \n\n// lib/Compilation.js\n_addEntryItem(context, entry, target, options, callback) {\n  const { name } = options;\n  //  entryData name  globalEntry\n  let entryData =\n    name !== undefined ? this.entries.get(name) : this.globalEntry;\n  if (entryData === undefined) {\n    //  entryData dependencies  includeDependencies\n    entryData = {\n      dependencies: [],\n      includeDependencies: [],\n      options: {\n        name: undefined,\n        ...options\n      }\n    };\n    // target  dependencies  includeDependencies\n    //  entry  entryData \n    entryData[target].push(entry);\n    //  entryData  entriesentries<name, entryData>\n    this.entries.set(name, entryData);\n  } else {\n    entryData[target].push(entry);\n    //  options  entryData.options\n    for (const key of Object.keys(options)) {\n      if (options[key] === undefined) continue;\n      if (entryData.options[key] === options[key]) continue;\n      if (\n        Array.isArray(entryData.options[key]) &&\n        Array.isArray(options[key]) &&\n        arrayEquals(entryData.options[key], options[key])\n      ) {\n        continue;\n      }\n      if (entryData.options[key] === undefined) {\n        entryData.options[key] = options[key];\n      } else {\n        return callback(\n          new WebpackError(\n            `Conflicting entry option ${key} = ${entryData.options[key]} vs ${options[key]}`\n          )\n        );\n      }\n    }\n  }\n  //  CompilationHook.addEntry => call\n  this.hooks.addEntry.call(entry, options);\n  //  compilation.addModuleTree  moduleTree\n  this.addModuleTree(\n    {\n      context,\n      dependency: entry,\n      contextInfo: entryData.options.layer\n        ? { issuerLayer: entryData.options.layer }\n        : undefined\n    },\n    // finished callback\n    (err, module) => {\n      if (err) {\n        //  CompilationHook.failedEntry => call\n        this.hooks.failedEntry.call(entry, options, err);\n        return callback(err);\n      }\n      //  CompilationHook.succeedEntry => call\n      this.hooks.succeedEntry.call(entry, options, module);\n      return callback(null, module);\n    }\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n * entries  Map<name, {dependencies: [],includeDependencies: []}> , entry  EntryDependency \n *  addModuleTree  Dependence  Module  Module  moduleGraph\n\n\n# addModuleTree\n\n moduleFactory handleModuleCreation  Module\n\n// lib/Compilation.js\naddModuleTree({ context, dependency, contextInfo }, callback) {\n  const Dep = /** @type {DepConstructor} */ (dependency.constructor);\n  //  Dependency  moduleFactory\n  const moduleFactory = this.dependencyFactories.get(Dep);\n\n  this.handleModuleCreation(\n    {\n      factory: moduleFactory,\n      dependencies: [dependency],\n      originModule: null,\n      contextInfo,\n      context\n    },\n    // ......\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# handleModuleCreation\n\n// lib/Compilation.js\nhandleModuleCreation = () => {\n  // this.moduleGraph = new ModuleGraph();\n  const moduleGraph = this.moduleGraph;\n  // factorizeModule  ModuleFactory  Module\n  this.factorizeModule(\n   {\n    currentProfile,\n    factory,\n    dependencies,\n    factoryResult: true,\n    originModule,\n    contextInfo,\n    context\n   }, (err, factoryResult) => {\n   //  Entry   fileDependenciescontextDependenciesmissingDependencies \n  const applyFactoryResultDependencies = () => {\n   const { fileDependencies, contextDependencies, missingDependencies } =\n    factoryResult;\n   if (fileDependencies) {\n    this.fileDependencies.addAll(fileDependencies);\n   }\n   if (contextDependencies) {\n    this.contextDependencies.addAll(contextDependencies);\n   }\n   if (missingDependencies) {\n    this.missingDependencies.addAll(missingDependencies);\n   }\n  };\n\n  //   Module\n  const newModule = factoryResult.module;\n    //  module  addModuleQueue \n    this.addModule(newModule, (err, module) => {\n      applyFactoryResultDependencies();\n      //  dependencies dependency  moduleGraph\n      for (let i = 0; i < dependencies.length; i++) {\n       const dependency = dependencies[i];\n       moduleGraph.setResolvedModule(\n        connectOrigin ? originModule : null,\n        dependency,\n        module\n       );\n      }\n      this._handleModuleBuildAndDependencies(\n        originModule,\n        module,\n        recursive,\n        callback\n       );\n    })\n })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n\n * factorizeModule  ModuleFactory  Module  ModuleDependencies\n * addModule  Module  moduleGraph ModuleDependencies  fileDependencies  contextDependencies  missingDependencies \n\n\n# factorizeModule\n\nfunction (options, callback) {\n  this.factorizeQueue.add(options, callback);\n}\n\n\n1\n2\n3\n\n\nfactorizeModule  factorizeModule  factorizeQueue processor  _factorizeModule\n\n_factorizeModule() {\n  factory.create(/*......*/, (err, result) => {\n    callback(null, factoryResult ? result : result.module);\n  })\n}\n\n\n1\n2\n3\n4\n5\n\n\n_factorizeModule  factory  EntryPlugin ()  Dependence  ModuleFactory  Module  normalModuleFactory \n\ncreate(data, callback) {\n  const resolveData = {\n   contextInfo,\n   resolveOptions,\n   context,\n   request,\n   assertions,\n   dependencies,\n   dependencyType,\n   fileDependencies,\n   missingDependencies,\n   contextDependencies,\n   createData: {},\n   cacheable: true\n  };\n  //  CompilationHook.beforeResolve => callAsync\n  this.hooks.beforeResolve.callAsync(resolveData, (err, result) => {\n    //  CompilationHook.factorize => callAsync\n    this.hooks.factorize.callAsync(resolveData, (err, module) => {}\n  )})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# addModule\n\naddModule  module  addModuleQueue processor  _addModule \n\naddModule(module, callback) {\n this.addModuleQueue.add(module, callback);\n}\n_addModule(module, callback) {\n const identifier = module.identifier();\n //  modules  _modules callback\n const alreadyAddedModule = this._modules.get(identifier);\n if (alreadyAddedModule) {\n  return callback(null, alreadyAddedModule);\n }\n// ......\n\n //  identifier  module\n this._modulesCache.get(identifier, null, (err, cacheModule) => {\n    // ......\n  //  cacheModule \n  if (cacheModule) {\n   cacheModule.updateCacheModule(module);\n   //  cacheModule  module\n   module = cacheModule;\n  }\n  //  module  _modules\n  this._modules.set(identifier, module);\n  //  module  modules _modules  Mapmodules  Set\n  this.modules.add(module);\n  // ......\n  callback(null, module);\n });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n_addModule  module  _modules  module \n\n\n# moduleGraph\n\n\n# AsyncQueue\n\ncompilation  AsyncQueue processDependenciesQueueaddModuleQueuefactorizeQueuebuildQueuerebuildQueue\n\n/** @type {AsyncQueue<Module, Module, Module>} */\nthis.processDependenciesQueue = new AsyncQueue({\n name: "processDependencies",\n parallelism: options.parallelism || 100,\n processor: this._processModuleDependencies.bind(this),\n});\n/** @type {AsyncQueue<Module, string, Module>} */\nthis.addModuleQueue = new AsyncQueue({\n name: "addModule",\n parent: this.processDependenciesQueue,\n getKey: (module) => module.identifier(),\n processor: this._addModule.bind(this),\n});\n/** @type {AsyncQueue<FactorizeModuleOptions, string, Module | ModuleFactoryResult>} */\nthis.factorizeQueue = new AsyncQueue({\n name: "factorize",\n parent: this.addModuleQueue,\n processor: this._factorizeModule.bind(this),\n});\n/** @type {AsyncQueue<Module, Module, Module>} */\nthis.buildQueue = new AsyncQueue({\n name: "build",\n parent: this.factorizeQueue,\n processor: this._buildModule.bind(this),\n});\n/** @type {AsyncQueue<Module, Module, Module>} */\nthis.rebuildQueue = new AsyncQueue({\n name: "rebuild",\n parallelism: options.parallelism || 100,\n processor: this._rebuildModule.bind(this),\n});\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# compilation.Hook\n\nthis.hooks = Object.freeze({\n  /** @type {SyncHook<[Module]>} */\n  buildModule: new SyncHook(["module"]),\n  /** @type {SyncHook<[Module]>} */\n  rebuildModule: new SyncHook(["module"]),\n  /** @type {SyncHook<[Module, WebpackError]>} */\n  failedModule: new SyncHook(["module", "error"]),\n  /** @type {SyncHook<[Module]>} */\n  succeedModule: new SyncHook(["module"]),\n  /** @type {SyncHook<[Module]>} */\n  stillValidModule: new SyncHook(["module"]),\n\n  /** @type {SyncHook<[Dependency, EntryOptions]>} */\n  addEntry: new SyncHook(["entry", "options"]),\n  /** @type {SyncHook<[Dependency, EntryOptions, Error]>} */\n  failedEntry: new SyncHook(["entry", "options", "error"]),\n  /** @type {SyncHook<[Dependency, EntryOptions, Module]>} */\n  succeedEntry: new SyncHook(["entry", "options", "module"]),\n\n  /** @type {SyncWaterfallHook<[(string[] | ReferencedExport)[], Dependency, RuntimeSpec]>} */\n  dependencyReferencedExports: new SyncWaterfallHook([\n    "referencedExports",\n    "dependency",\n    "runtime"\n  ]),\n\n  /** @type {SyncHook<[ExecuteModuleArgument, ExecuteModuleContext]>} */\n  executeModule: new SyncHook(["options", "context"]),\n  /** @type {AsyncParallelHook<[ExecuteModuleArgument, ExecuteModuleContext]>} */\n  prepareModuleExecution: new AsyncParallelHook(["options", "context"]),\n\n  /** @type {AsyncSeriesHook<[Iterable<Module>]>} */\n  finishModules: new AsyncSeriesHook(["modules"]),\n  /** @type {AsyncSeriesHook<[Module]>} */\n  finishRebuildingModule: new AsyncSeriesHook(["module"]),\n  /** @type {SyncHook<[]>} */\n  unseal: new SyncHook([]),\n  /** @type {SyncHook<[]>} */\n  seal: new SyncHook([]),\n\n  /** @type {SyncHook<[]>} */\n  beforeChunks: new SyncHook([]),\n  /** @type {SyncHook<[Iterable<Chunk>]>} */\n  afterChunks: new SyncHook(["chunks"]),\n\n  /** @type {SyncBailHook<[Iterable<Module>]>} */\n  optimizeDependencies: new SyncBailHook(["modules"]),\n  /** @type {SyncHook<[Iterable<Module>]>} */\n  afterOptimizeDependencies: new SyncHook(["modules"]),\n\n  /** @type {SyncHook<[]>} */\n  optimize: new SyncHook([]),\n  /** @type {SyncBailHook<[Iterable<Module>]>} */\n  optimizeModules: new SyncBailHook(["modules"]),\n  /** @type {SyncHook<[Iterable<Module>]>} */\n  afterOptimizeModules: new SyncHook(["modules"]),\n\n  /** @type {SyncBailHook<[Iterable<Chunk>, ChunkGroup[]]>} */\n  optimizeChunks: new SyncBailHook(["chunks", "chunkGroups"]),\n  /** @type {SyncHook<[Iterable<Chunk>, ChunkGroup[]]>} */\n  afterOptimizeChunks: new SyncHook(["chunks", "chunkGroups"]),\n\n  /** @type {AsyncSeriesHook<[Iterable<Chunk>, Iterable<Module>]>} */\n  optimizeTree: new AsyncSeriesHook(["chunks", "modules"]),\n  /** @type {SyncHook<[Iterable<Chunk>, Iterable<Module>]>} */\n  afterOptimizeTree: new SyncHook(["chunks", "modules"]),\n\n  /** @type {AsyncSeriesBailHook<[Iterable<Chunk>, Iterable<Module>]>} */\n  optimizeChunkModules: new AsyncSeriesBailHook(["chunks", "modules"]),\n  /** @type {SyncHook<[Iterable<Chunk>, Iterable<Module>]>} */\n  afterOptimizeChunkModules: new SyncHook(["chunks", "modules"]),\n  /** @type {SyncBailHook<[], boolean>} */\n  shouldRecord: new SyncBailHook([]),\n\n  /** @type {SyncHook<[Chunk, Set<string>, RuntimeRequirementsContext]>} */\n  additionalChunkRuntimeRequirements: new SyncHook([\n    "chunk",\n    "runtimeRequirements",\n    "context"\n  ]),\n  /** @type {HookMap<SyncBailHook<[Chunk, Set<string>, RuntimeRequirementsContext]>>} */\n  runtimeRequirementInChunk: new HookMap(\n    () => new SyncBailHook(["chunk", "runtimeRequirements", "context"])\n  ),\n  /** @type {SyncHook<[Module, Set<string>, RuntimeRequirementsContext]>} */\n  additionalModuleRuntimeRequirements: new SyncHook([\n    "module",\n    "runtimeRequirements",\n    "context"\n  ]),\n  /** @type {HookMap<SyncBailHook<[Module, Set<string>, RuntimeRequirementsContext]>>} */\n  runtimeRequirementInModule: new HookMap(\n    () => new SyncBailHook(["module", "runtimeRequirements", "context"])\n  ),\n  /** @type {SyncHook<[Chunk, Set<string>, RuntimeRequirementsContext]>} */\n  additionalTreeRuntimeRequirements: new SyncHook([\n    "chunk",\n    "runtimeRequirements",\n    "context"\n  ]),\n  /** @type {HookMap<SyncBailHook<[Chunk, Set<string>, RuntimeRequirementsContext]>>} */\n  runtimeRequirementInTree: new HookMap(\n    () => new SyncBailHook(["chunk", "runtimeRequirements", "context"])\n  ),\n\n  /** @type {SyncHook<[RuntimeModule, Chunk]>} */\n  runtimeModule: new SyncHook(["module", "chunk"]),\n\n  /** @type {SyncHook<[Iterable<Module>, any]>} */\n  reviveModules: new SyncHook(["modules", "records"]),\n  /** @type {SyncHook<[Iterable<Module>]>} */\n  beforeModuleIds: new SyncHook(["modules"]),\n  /** @type {SyncHook<[Iterable<Module>]>} */\n  moduleIds: new SyncHook(["modules"]),\n  /** @type {SyncHook<[Iterable<Module>]>} */\n  optimizeModuleIds: new SyncHook(["modules"]),\n  /** @type {SyncHook<[Iterable<Module>]>} */\n  afterOptimizeModuleIds: new SyncHook(["modules"]),\n\n  /** @type {SyncHook<[Iterable<Chunk>, any]>} */\n  reviveChunks: new SyncHook(["chunks", "records"]),\n  /** @type {SyncHook<[Iterable<Chunk>]>} */\n  beforeChunkIds: new SyncHook(["chunks"]),\n  /** @type {SyncHook<[Iterable<Chunk>]>} */\n  chunkIds: new SyncHook(["chunks"]),\n  /** @type {SyncHook<[Iterable<Chunk>]>} */\n  optimizeChunkIds: new SyncHook(["chunks"]),\n  /** @type {SyncHook<[Iterable<Chunk>]>} */\n  afterOptimizeChunkIds: new SyncHook(["chunks"]),\n\n  /** @type {SyncHook<[Iterable<Module>, any]>} */\n  recordModules: new SyncHook(["modules", "records"]),\n  /** @type {SyncHook<[Iterable<Chunk>, any]>} */\n  recordChunks: new SyncHook(["chunks", "records"]),\n\n  /** @type {SyncHook<[Iterable<Module>]>} */\n  optimizeCodeGeneration: new SyncHook(["modules"]),\n\n  /** @type {SyncHook<[]>} */\n  beforeModuleHash: new SyncHook([]),\n  /** @type {SyncHook<[]>} */\n  afterModuleHash: new SyncHook([]),\n\n  /** @type {SyncHook<[]>} */\n  beforeCodeGeneration: new SyncHook([]),\n  /** @type {SyncHook<[]>} */\n  afterCodeGeneration: new SyncHook([]),\n\n  /** @type {SyncHook<[]>} */\n  beforeRuntimeRequirements: new SyncHook([]),\n  /** @type {SyncHook<[]>} */\n  afterRuntimeRequirements: new SyncHook([]),\n\n  /** @type {SyncHook<[]>} */\n  beforeHash: new SyncHook([]),\n  /** @type {SyncHook<[Chunk]>} */\n  contentHash: new SyncHook(["chunk"]),\n  /** @type {SyncHook<[]>} */\n  afterHash: new SyncHook([]),\n  /** @type {SyncHook<[any]>} */\n  recordHash: new SyncHook(["records"]),\n  /** @type {SyncHook<[Compilation, any]>} */\n  record: new SyncHook(["compilation", "records"]),\n\n  /** @type {SyncHook<[]>} */\n  beforeModuleAssets: new SyncHook([]),\n  /** @type {SyncBailHook<[], boolean>} */\n  shouldGenerateChunkAssets: new SyncBailHook([]),\n  /** @type {SyncHook<[]>} */\n  beforeChunkAssets: new SyncHook([]),\n  /** @type {AsyncSeriesHook<[CompilationAssets]>} */\n  processAdditionalAssets: new AsyncSeriesHook(["assets"]),\n\n  /** @type {SyncBailHook<[], boolean>} */\n  needAdditionalSeal: new SyncBailHook([]),\n  /** @type {AsyncSeriesHook<[]>} */\n  afterSeal: new AsyncSeriesHook([]),\n\n  /** @type {SyncWaterfallHook<[RenderManifestEntry[], RenderManifestOptions]>} */\n  renderManifest: new SyncWaterfallHook(["result", "options"]),\n\n  /** @type {SyncHook<[Hash]>} */\n  fullHash: new SyncHook(["hash"]),\n  /** @type {SyncHook<[Chunk, Hash, ChunkHashContext]>} */\n  chunkHash: new SyncHook(["chunk", "chunkHash", "ChunkHashContext"]),\n\n  /** @type {SyncHook<[Module, string]>} */\n  moduleAsset: new SyncHook(["module", "filename"]),\n  /** @type {SyncHook<[Chunk, string]>} */\n  chunkAsset: new SyncHook(["chunk", "filename"]),\n\n  /** @type {SyncWaterfallHook<[string, object, AssetInfo]>} */\n  assetPath: new SyncWaterfallHook(["path", "options", "assetInfo"]),\n\n  /** @type {SyncBailHook<[], boolean>} */\n  needAdditionalPass: new SyncBailHook([]),\n\n  /** @type {SyncHook<[Compiler, string, number]>} */\n  childCompiler: new SyncHook([\n    "childCompiler",\n    "compilerName",\n    "compilerIndex"\n  ]),\n\n  /** @type {SyncBailHook<[string, LogEntry], true>} */\n  log: new SyncBailHook(["origin", "logEntry"]),\n\n  /** @type {SyncWaterfallHook<[WebpackError[]]>} */\n  processWarnings: new SyncWaterfallHook(["warnings"]),\n  /** @type {SyncWaterfallHook<[WebpackError[]]>} */\n  processErrors: new SyncWaterfallHook(["errors"]),\n\n  /** @type {HookMap<SyncHook<[Partial<NormalizedStatsOptions>, CreateStatsOptionsContext]>>} */\n  statsPreset: new HookMap(() => new SyncHook(["options", "context"])),\n  /** @type {SyncHook<[Partial<NormalizedStatsOptions>, CreateStatsOptionsContext]>} */\n  statsNormalize: new SyncHook(["options", "context"]),\n  /** @type {SyncHook<[StatsFactory, NormalizedStatsOptions]>} */\n  statsFactory: new SyncHook(["statsFactory", "options"]),\n  /** @type {SyncHook<[StatsPrinter, NormalizedStatsOptions]>} */\n  statsPrinter: new SyncHook(["statsPrinter", "options"]),\n\n  get normalModuleLoader() {\n    return getNormalModuleLoader();\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n',normalizedContent:'# \n\n\n\n * \n * compilation.addentry\n * addmoduletree\n * handlemodulecreation\n   * factorizemodule\n   * addmodule\n * modulegraph\n * asyncqueue\n * compilation.hook\n\n\n\n compiler.compile  compilation compilerhook.make  compilation.addentry  entrydependency \n\n compilerhook.make  make \n\n webpack  make \n\n * compilation.addentry\n\n\n# compilation.addentry\n\n _addentryitem  _addentryitem  addentry  addinclude \n\n// lib/compilation.js\n_addentryitem(context, entry, target, options, callback) {\n  const { name } = options;\n  //  entrydata name  globalentry\n  let entrydata =\n    name !== undefined ? this.entries.get(name) : this.globalentry;\n  if (entrydata === undefined) {\n    //  entrydata dependencies  includedependencies\n    entrydata = {\n      dependencies: [],\n      includedependencies: [],\n      options: {\n        name: undefined,\n        ...options\n      }\n    };\n    // target  dependencies  includedependencies\n    //  entry  entrydata \n    entrydata[target].push(entry);\n    //  entrydata  entriesentries<name, entrydata>\n    this.entries.set(name, entrydata);\n  } else {\n    entrydata[target].push(entry);\n    //  options  entrydata.options\n    for (const key of object.keys(options)) {\n      if (options[key] === undefined) continue;\n      if (entrydata.options[key] === options[key]) continue;\n      if (\n        array.isarray(entrydata.options[key]) &&\n        array.isarray(options[key]) &&\n        arrayequals(entrydata.options[key], options[key])\n      ) {\n        continue;\n      }\n      if (entrydata.options[key] === undefined) {\n        entrydata.options[key] = options[key];\n      } else {\n        return callback(\n          new webpackerror(\n            `conflicting entry option ${key} = ${entrydata.options[key]} vs ${options[key]}`\n          )\n        );\n      }\n    }\n  }\n  //  compilationhook.addentry => call\n  this.hooks.addentry.call(entry, options);\n  //  compilation.addmoduletree  moduletree\n  this.addmoduletree(\n    {\n      context,\n      dependency: entry,\n      contextinfo: entrydata.options.layer\n        ? { issuerlayer: entrydata.options.layer }\n        : undefined\n    },\n    // finished callback\n    (err, module) => {\n      if (err) {\n        //  compilationhook.failedentry => call\n        this.hooks.failedentry.call(entry, options, err);\n        return callback(err);\n      }\n      //  compilationhook.succeedentry => call\n      this.hooks.succeedentry.call(entry, options, module);\n      return callback(null, module);\n    }\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n * entries  map<name, {dependencies: [],includedependencies: []}> , entry  entrydependency \n *  addmoduletree  dependence  module  module  modulegraph\n\n\n# addmoduletree\n\n modulefactory handlemodulecreation  module\n\n// lib/compilation.js\naddmoduletree({ context, dependency, contextinfo }, callback) {\n  const dep = /** @type {depconstructor} */ (dependency.constructor);\n  //  dependency  modulefactory\n  const modulefactory = this.dependencyfactories.get(dep);\n\n  this.handlemodulecreation(\n    {\n      factory: modulefactory,\n      dependencies: [dependency],\n      originmodule: null,\n      contextinfo,\n      context\n    },\n    // ......\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# handlemodulecreation\n\n// lib/compilation.js\nhandlemodulecreation = () => {\n  // this.modulegraph = new modulegraph();\n  const modulegraph = this.modulegraph;\n  // factorizemodule  modulefactory  module\n  this.factorizemodule(\n   {\n    currentprofile,\n    factory,\n    dependencies,\n    factoryresult: true,\n    originmodule,\n    contextinfo,\n    context\n   }, (err, factoryresult) => {\n   //  entry   filedependenciescontextdependenciesmissingdependencies \n  const applyfactoryresultdependencies = () => {\n   const { filedependencies, contextdependencies, missingdependencies } =\n    factoryresult;\n   if (filedependencies) {\n    this.filedependencies.addall(filedependencies);\n   }\n   if (contextdependencies) {\n    this.contextdependencies.addall(contextdependencies);\n   }\n   if (missingdependencies) {\n    this.missingdependencies.addall(missingdependencies);\n   }\n  };\n\n  //   module\n  const newmodule = factoryresult.module;\n    //  module  addmodulequeue \n    this.addmodule(newmodule, (err, module) => {\n      applyfactoryresultdependencies();\n      //  dependencies dependency  modulegraph\n      for (let i = 0; i < dependencies.length; i++) {\n       const dependency = dependencies[i];\n       modulegraph.setresolvedmodule(\n        connectorigin ? originmodule : null,\n        dependency,\n        module\n       );\n      }\n      this._handlemodulebuildanddependencies(\n        originmodule,\n        module,\n        recursive,\n        callback\n       );\n    })\n })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n\n * factorizemodule  modulefactory  module  moduledependencies\n * addmodule  module  modulegraph moduledependencies  filedependencies  contextdependencies  missingdependencies \n\n\n# factorizemodule\n\nfunction (options, callback) {\n  this.factorizequeue.add(options, callback);\n}\n\n\n1\n2\n3\n\n\nfactorizemodule  factorizemodule  factorizequeue processor  _factorizemodule\n\n_factorizemodule() {\n  factory.create(/*......*/, (err, result) => {\n    callback(null, factoryresult ? result : result.module);\n  })\n}\n\n\n1\n2\n3\n4\n5\n\n\n_factorizemodule  factory  entryplugin ()  dependence  modulefactory  module  normalmodulefactory \n\ncreate(data, callback) {\n  const resolvedata = {\n   contextinfo,\n   resolveoptions,\n   context,\n   request,\n   assertions,\n   dependencies,\n   dependencytype,\n   filedependencies,\n   missingdependencies,\n   contextdependencies,\n   createdata: {},\n   cacheable: true\n  };\n  //  compilationhook.beforeresolve => callasync\n  this.hooks.beforeresolve.callasync(resolvedata, (err, result) => {\n    //  compilationhook.factorize => callasync\n    this.hooks.factorize.callasync(resolvedata, (err, module) => {}\n  )})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# addmodule\n\naddmodule  module  addmodulequeue processor  _addmodule \n\naddmodule(module, callback) {\n this.addmodulequeue.add(module, callback);\n}\n_addmodule(module, callback) {\n const identifier = module.identifier();\n //  modules  _modules callback\n const alreadyaddedmodule = this._modules.get(identifier);\n if (alreadyaddedmodule) {\n  return callback(null, alreadyaddedmodule);\n }\n// ......\n\n //  identifier  module\n this._modulescache.get(identifier, null, (err, cachemodule) => {\n    // ......\n  //  cachemodule \n  if (cachemodule) {\n   cachemodule.updatecachemodule(module);\n   //  cachemodule  module\n   module = cachemodule;\n  }\n  //  module  _modules\n  this._modules.set(identifier, module);\n  //  module  modules _modules  mapmodules  set\n  this.modules.add(module);\n  // ......\n  callback(null, module);\n });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n_addmodule  module  _modules  module \n\n\n# modulegraph\n\n\n# asyncqueue\n\ncompilation  asyncqueue processdependenciesqueueaddmodulequeuefactorizequeuebuildqueuerebuildqueue\n\n/** @type {asyncqueue<module, module, module>} */\nthis.processdependenciesqueue = new asyncqueue({\n name: "processdependencies",\n parallelism: options.parallelism || 100,\n processor: this._processmoduledependencies.bind(this),\n});\n/** @type {asyncqueue<module, string, module>} */\nthis.addmodulequeue = new asyncqueue({\n name: "addmodule",\n parent: this.processdependenciesqueue,\n getkey: (module) => module.identifier(),\n processor: this._addmodule.bind(this),\n});\n/** @type {asyncqueue<factorizemoduleoptions, string, module | modulefactoryresult>} */\nthis.factorizequeue = new asyncqueue({\n name: "factorize",\n parent: this.addmodulequeue,\n processor: this._factorizemodule.bind(this),\n});\n/** @type {asyncqueue<module, module, module>} */\nthis.buildqueue = new asyncqueue({\n name: "build",\n parent: this.factorizequeue,\n processor: this._buildmodule.bind(this),\n});\n/** @type {asyncqueue<module, module, module>} */\nthis.rebuildqueue = new asyncqueue({\n name: "rebuild",\n parallelism: options.parallelism || 100,\n processor: this._rebuildmodule.bind(this),\n});\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# compilation.hook\n\nthis.hooks = object.freeze({\n  /** @type {synchook<[module]>} */\n  buildmodule: new synchook(["module"]),\n  /** @type {synchook<[module]>} */\n  rebuildmodule: new synchook(["module"]),\n  /** @type {synchook<[module, webpackerror]>} */\n  failedmodule: new synchook(["module", "error"]),\n  /** @type {synchook<[module]>} */\n  succeedmodule: new synchook(["module"]),\n  /** @type {synchook<[module]>} */\n  stillvalidmodule: new synchook(["module"]),\n\n  /** @type {synchook<[dependency, entryoptions]>} */\n  addentry: new synchook(["entry", "options"]),\n  /** @type {synchook<[dependency, entryoptions, error]>} */\n  failedentry: new synchook(["entry", "options", "error"]),\n  /** @type {synchook<[dependency, entryoptions, module]>} */\n  succeedentry: new synchook(["entry", "options", "module"]),\n\n  /** @type {syncwaterfallhook<[(string[] | referencedexport)[], dependency, runtimespec]>} */\n  dependencyreferencedexports: new syncwaterfallhook([\n    "referencedexports",\n    "dependency",\n    "runtime"\n  ]),\n\n  /** @type {synchook<[executemoduleargument, executemodulecontext]>} */\n  executemodule: new synchook(["options", "context"]),\n  /** @type {asyncparallelhook<[executemoduleargument, executemodulecontext]>} */\n  preparemoduleexecution: new asyncparallelhook(["options", "context"]),\n\n  /** @type {asyncserieshook<[iterable<module>]>} */\n  finishmodules: new asyncserieshook(["modules"]),\n  /** @type {asyncserieshook<[module]>} */\n  finishrebuildingmodule: new asyncserieshook(["module"]),\n  /** @type {synchook<[]>} */\n  unseal: new synchook([]),\n  /** @type {synchook<[]>} */\n  seal: new synchook([]),\n\n  /** @type {synchook<[]>} */\n  beforechunks: new synchook([]),\n  /** @type {synchook<[iterable<chunk>]>} */\n  afterchunks: new synchook(["chunks"]),\n\n  /** @type {syncbailhook<[iterable<module>]>} */\n  optimizedependencies: new syncbailhook(["modules"]),\n  /** @type {synchook<[iterable<module>]>} */\n  afteroptimizedependencies: new synchook(["modules"]),\n\n  /** @type {synchook<[]>} */\n  optimize: new synchook([]),\n  /** @type {syncbailhook<[iterable<module>]>} */\n  optimizemodules: new syncbailhook(["modules"]),\n  /** @type {synchook<[iterable<module>]>} */\n  afteroptimizemodules: new synchook(["modules"]),\n\n  /** @type {syncbailhook<[iterable<chunk>, chunkgroup[]]>} */\n  optimizechunks: new syncbailhook(["chunks", "chunkgroups"]),\n  /** @type {synchook<[iterable<chunk>, chunkgroup[]]>} */\n  afteroptimizechunks: new synchook(["chunks", "chunkgroups"]),\n\n  /** @type {asyncserieshook<[iterable<chunk>, iterable<module>]>} */\n  optimizetree: new asyncserieshook(["chunks", "modules"]),\n  /** @type {synchook<[iterable<chunk>, iterable<module>]>} */\n  afteroptimizetree: new synchook(["chunks", "modules"]),\n\n  /** @type {asyncseriesbailhook<[iterable<chunk>, iterable<module>]>} */\n  optimizechunkmodules: new asyncseriesbailhook(["chunks", "modules"]),\n  /** @type {synchook<[iterable<chunk>, iterable<module>]>} */\n  afteroptimizechunkmodules: new synchook(["chunks", "modules"]),\n  /** @type {syncbailhook<[], boolean>} */\n  shouldrecord: new syncbailhook([]),\n\n  /** @type {synchook<[chunk, set<string>, runtimerequirementscontext]>} */\n  additionalchunkruntimerequirements: new synchook([\n    "chunk",\n    "runtimerequirements",\n    "context"\n  ]),\n  /** @type {hookmap<syncbailhook<[chunk, set<string>, runtimerequirementscontext]>>} */\n  runtimerequirementinchunk: new hookmap(\n    () => new syncbailhook(["chunk", "runtimerequirements", "context"])\n  ),\n  /** @type {synchook<[module, set<string>, runtimerequirementscontext]>} */\n  additionalmoduleruntimerequirements: new synchook([\n    "module",\n    "runtimerequirements",\n    "context"\n  ]),\n  /** @type {hookmap<syncbailhook<[module, set<string>, runtimerequirementscontext]>>} */\n  runtimerequirementinmodule: new hookmap(\n    () => new syncbailhook(["module", "runtimerequirements", "context"])\n  ),\n  /** @type {synchook<[chunk, set<string>, runtimerequirementscontext]>} */\n  additionaltreeruntimerequirements: new synchook([\n    "chunk",\n    "runtimerequirements",\n    "context"\n  ]),\n  /** @type {hookmap<syncbailhook<[chunk, set<string>, runtimerequirementscontext]>>} */\n  runtimerequirementintree: new hookmap(\n    () => new syncbailhook(["chunk", "runtimerequirements", "context"])\n  ),\n\n  /** @type {synchook<[runtimemodule, chunk]>} */\n  runtimemodule: new synchook(["module", "chunk"]),\n\n  /** @type {synchook<[iterable<module>, any]>} */\n  revivemodules: new synchook(["modules", "records"]),\n  /** @type {synchook<[iterable<module>]>} */\n  beforemoduleids: new synchook(["modules"]),\n  /** @type {synchook<[iterable<module>]>} */\n  moduleids: new synchook(["modules"]),\n  /** @type {synchook<[iterable<module>]>} */\n  optimizemoduleids: new synchook(["modules"]),\n  /** @type {synchook<[iterable<module>]>} */\n  afteroptimizemoduleids: new synchook(["modules"]),\n\n  /** @type {synchook<[iterable<chunk>, any]>} */\n  revivechunks: new synchook(["chunks", "records"]),\n  /** @type {synchook<[iterable<chunk>]>} */\n  beforechunkids: new synchook(["chunks"]),\n  /** @type {synchook<[iterable<chunk>]>} */\n  chunkids: new synchook(["chunks"]),\n  /** @type {synchook<[iterable<chunk>]>} */\n  optimizechunkids: new synchook(["chunks"]),\n  /** @type {synchook<[iterable<chunk>]>} */\n  afteroptimizechunkids: new synchook(["chunks"]),\n\n  /** @type {synchook<[iterable<module>, any]>} */\n  recordmodules: new synchook(["modules", "records"]),\n  /** @type {synchook<[iterable<chunk>, any]>} */\n  recordchunks: new synchook(["chunks", "records"]),\n\n  /** @type {synchook<[iterable<module>]>} */\n  optimizecodegeneration: new synchook(["modules"]),\n\n  /** @type {synchook<[]>} */\n  beforemodulehash: new synchook([]),\n  /** @type {synchook<[]>} */\n  aftermodulehash: new synchook([]),\n\n  /** @type {synchook<[]>} */\n  beforecodegeneration: new synchook([]),\n  /** @type {synchook<[]>} */\n  aftercodegeneration: new synchook([]),\n\n  /** @type {synchook<[]>} */\n  beforeruntimerequirements: new synchook([]),\n  /** @type {synchook<[]>} */\n  afterruntimerequirements: new synchook([]),\n\n  /** @type {synchook<[]>} */\n  beforehash: new synchook([]),\n  /** @type {synchook<[chunk]>} */\n  contenthash: new synchook(["chunk"]),\n  /** @type {synchook<[]>} */\n  afterhash: new synchook([]),\n  /** @type {synchook<[any]>} */\n  recordhash: new synchook(["records"]),\n  /** @type {synchook<[compilation, any]>} */\n  record: new synchook(["compilation", "records"]),\n\n  /** @type {synchook<[]>} */\n  beforemoduleassets: new synchook([]),\n  /** @type {syncbailhook<[], boolean>} */\n  shouldgeneratechunkassets: new syncbailhook([]),\n  /** @type {synchook<[]>} */\n  beforechunkassets: new synchook([]),\n  /** @type {asyncserieshook<[compilationassets]>} */\n  processadditionalassets: new asyncserieshook(["assets"]),\n\n  /** @type {syncbailhook<[], boolean>} */\n  needadditionalseal: new syncbailhook([]),\n  /** @type {asyncserieshook<[]>} */\n  afterseal: new asyncserieshook([]),\n\n  /** @type {syncwaterfallhook<[rendermanifestentry[], rendermanifestoptions]>} */\n  rendermanifest: new syncwaterfallhook(["result", "options"]),\n\n  /** @type {synchook<[hash]>} */\n  fullhash: new synchook(["hash"]),\n  /** @type {synchook<[chunk, hash, chunkhashcontext]>} */\n  chunkhash: new synchook(["chunk", "chunkhash", "chunkhashcontext"]),\n\n  /** @type {synchook<[module, string]>} */\n  moduleasset: new synchook(["module", "filename"]),\n  /** @type {synchook<[chunk, string]>} */\n  chunkasset: new synchook(["chunk", "filename"]),\n\n  /** @type {syncwaterfallhook<[string, object, assetinfo]>} */\n  assetpath: new syncwaterfallhook(["path", "options", "assetinfo"]),\n\n  /** @type {syncbailhook<[], boolean>} */\n  needadditionalpass: new syncbailhook([]),\n\n  /** @type {synchook<[compiler, string, number]>} */\n  childcompiler: new synchook([\n    "childcompiler",\n    "compilername",\n    "compilerindex"\n  ]),\n\n  /** @type {syncbailhook<[string, logentry], true>} */\n  log: new syncbailhook(["origin", "logentry"]),\n\n  /** @type {syncwaterfallhook<[webpackerror[]]>} */\n  processwarnings: new syncwaterfallhook(["warnings"]),\n  /** @type {syncwaterfallhook<[webpackerror[]]>} */\n  processerrors: new syncwaterfallhook(["errors"]),\n\n  /** @type {hookmap<synchook<[partial<normalizedstatsoptions>, createstatsoptionscontext]>>} */\n  statspreset: new hookmap(() => new synchook(["options", "context"])),\n  /** @type {synchook<[partial<normalizedstatsoptions>, createstatsoptionscontext]>} */\n  statsnormalize: new synchook(["options", "context"]),\n  /** @type {synchook<[statsfactory, normalizedstatsoptions]>} */\n  statsfactory: new synchook(["statsfactory", "options"]),\n  /** @type {synchook<[statsprinter, normalizedstatsoptions]>} */\n  statsprinter: new synchook(["statsprinter", "options"]),\n\n  get normalmoduleloader() {\n    return getnormalmoduleloader();\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"make module",frontmatter:{title:"make module",date:"2022-04-25T15:52:15.000Z",permalink:"/webpack/make/module/",categories:["webpack","make"],tags:[null]},regularPath:"/30.web/7.webpack/30.make%E9%98%B6%E6%AE%B5/20.module.html",relativePath:"30.web/7.webpack/30.make/20.module.md",key:"v-8da47476",path:"/webpack/make/module/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:102},{level:2,title:"_handleModuleBuildAndDependencies",slug:"handlemodulebuildanddependencies",normalizedTitle:"_handlemodulebuildanddependencies",charIndex:117},{level:2,title:"buildModule",slug:"buildmodule",normalizedTitle:"buildmodule",charIndex:154},{level:2,title:"build",slug:"build",normalizedTitle:"build",charIndex:154},{level:3,title:"Build",slug:"build-2",normalizedTitle:"build",charIndex:130},{level:3,title:"Parse",slug:"parse",normalizedTitle:"parse",charIndex:191},{level:2,title:"JavascriptParser",slug:"javascriptparser",normalizedTitle:"javascriptparser",charIndex:200},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:220}],excerpt:"<TimeToRead />\n<p> compilation.addEntry  compilation  Module  module </p>\n",readingTime:{text:"6 min read",minutes:5.55,time:333e3,words:1110},headersStr:" _handleModuleBuildAndDependencies buildModule build Build Parse JavascriptParser ",content:' compilation.addEntry  compilation  Module  module \n\n\n# \n\n\n\n * \n * _handleModuleBuildAndDependencies\n * buildModule\n * build\n   * Build\n   * Parse\n * JavascriptParser\n * \n\n\n\n\n# _handleModuleBuildAndDependencies\n\nthis.buildModule(module, (err) => {\n // ......\n // Module  processDependenciesQueue  callback\n // This avoids deadlocks for circular dependencies\n if (this.processDependenciesQueue.isProcessing(module)) {\n  return callback();\n }\n //  processModuleDependencies \n this.processModuleDependencies(module, (err) => {\n  // ......\n  callback(null, module);\n });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n buildModule  processModuleDependencies \n\n\n# buildModule\n\nbuildModule(module, callback) {\n  this.buildQueue.add(module, callback);\n}\n\n\n1\n2\n3\n\n\nbuildModule  module  buildQueue buildQueue  processor  _buildModule  processor  module\n\n _buildModule \n\nfunction _buildModule(module, callback) {\n //  module  build\n module.needBuild(\n  {\n   compilation: this,\n   fileSystemInfo: this.fileSystemInfo,\n   valueCacheVersions: this.valueCacheVersions,\n  },\n  (err, needBuild) => {\n   // ......\n\n   if (!needBuild) {\n    //  build,  CompilationHook.stillValidModule => call\n    this.hooks.stillValidModule.call(module);\n    return callback();\n   }\n   //  CompilationHook.buildModule => call\n   this.hooks.buildModule.call(module);\n   //  module  builtModules\n   // this.builtModules = new WeakSet();\n   this.builtModules.add(module);\n   //  build\n   module.build(\n    this.options,\n    this,\n    this.resolverFactory.get("normal", module.resolveOptions),\n    this.inputFileSystem,\n    (err) => {\n     // ......\n    }\n   );\n  }\n );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n module  module.needBuild  module.build  NormalModule \n\nfunction needBuild(context, callback) {\n const { fileSystemInfo, compilation, valueCacheVersions } = context;\n // build if enforced\n if (this._forceBuild) return callback(null, true);\n\n // always try to build in case of an error\n if (this.error) return callback(null, true);\n //  cacheable  snapshot  build\n // always build when module is not cacheable\n if (!this.buildInfo.cacheable) return callback(null, true);\n\n // build when there is no snapshot to check\n if (!this.buildInfo.snapshot) return callback(null, true);\n\n // build when valueDependencies have changed\n /** @type {Map<string, string | Set<string>>} */\n const valueDependencies = this.buildInfo.valueDependencies;\n if (valueDependencies) {\n  if (!valueCacheVersions) return callback(null, true);\n  //  buildInfo.valueDependencies context.valueCacheVersions \n  for (const [key, value] of valueDependencies) {\n   if (value === undefined) return callback(null, true);\n   const current = valueCacheVersions.get(key);\n   if (\n    value !== current &&\n    (typeof value === "string" ||\n     typeof current === "string" ||\n     current === undefined ||\n     !isSubset(value, current))\n   ) {\n    return callback(null, true);\n   }\n  }\n }\n\n // check snapshot for validity\n fileSystemInfo.checkSnapshotValid(this.buildInfo.snapshot, (err, valid) => {\n  if (err) return callback(err);\n  if (!valid) return callback(null, true);\n  const hooks = NormalModule.getCompilationHooks(compilation);\n  //  buildInfo.snapshot  CompilationHook.needBuild => callAsync\n  hooks.needBuild.callAsync(this, context, (err, needBuild) => {\n   // ......\n   callback(null, !!needBuild);\n  });\n });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\nmodule.needBuild  build \n\n\n# build\n\n\n# Build\n\nbuild  _doBuild  Build \n\n// lib/NormalModule.js\n_doBuild(options, compilation, resolver, fs, hooks, callback) {\n //  loaderContext loader  context()\n const loaderContext = this._createLoaderContext(\n  resolver,\n  options,\n  compilation,\n  fs,\n  hooks\n );\n //  fileDependenciescontextDependenciesmissingDependencies \n this.buildInfo.fileDependencies = new LazySet();\n this.buildInfo.contextDependencies = new LazySet();\n this.buildInfo.missingDependencies = new LazySet();\n this.buildInfo.cacheable = true;\n\n //  CompilationHook.beforeLoaders => call\n hooks.beforeLoaders.call(this.loaders, this, loaderContext);\n // ......\n if (this.loaders.length > 0) {\n  //  buildDependencies\n  this.buildInfo.buildDependencies = new LazySet();\n }\n //  loader-runner.runLoaders \n runLoaders(\n  {\n   // resource path\n   resource: this.resource,\n   // module loaders\n   loaders: this.loaders,\n   // module loader context\n   context: loaderContext,\n   // \n   processResource: (loaderContext, resourcePath, callback) => {\n    const resource = loaderContext.resource;\n    //  resource  scheme\n    const scheme = getScheme(resource);\n    // CompilationHook.readResource  HookMap .for\n    //  scheme  HookMap  Hook\n    hooks.readResource\n     .for(scheme)\n     //   CompilationHook.readResource.scheme => callAsync\n     .callAsync(loaderContext, (err, result) => {\n      // ......\n      return callback(null, result);\n     });\n   },\n  },\n  (err, result) => {\n   // ......\n   //  fileDependenciescontextDependencies  missingDependencies\n   this.buildInfo.fileDependencies.addAll(result.fileDependencies);\n   this.buildInfo.contextDependencies.addAll(result.contextDependencies);\n   this.buildInfo.missingDependencies.addAll(result.missingDependencies);\n   //  loader\n   for (const loader of this.loaders) {\n    this.buildInfo.buildDependencies.add(loader.loader);\n   }\n   this.buildInfo.cacheable = this.buildInfo.cacheable && result.cacheable;\n   //  loader \n   processResult(err, result.result);\n  }\n );\n}\n\nconst processResult = (err, result) => {\n // ......\n //  sourcesourceMap  extraInfo\n const source = result[0];\n const sourceMap = result.length >= 1 ? result[1] : null;\n const extraInfo = result.length >= 2 ? result[2] : null;\n\n // ......\n //  RawSource \n this._source = this.createSource(\n  options.context,\n  this.binary ? asBuffer(source) : asString(source),\n  sourceMap,\n  compilation.compiler.root\n );\n // ......\n //  extraInfo  AST\n this._ast =\n  typeof extraInfo === "object" &&\n  extraInfo !== null &&\n  extraInfo.webpackAST !== undefined\n   ? extraInfo.webpackAST\n   : null;\n return callback();\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n\n\n\n\n * runLoaders  loader-runner  webpack  JavaScript  loaderContext  loader \n * loader  Dependencies  contentDependencies  fileDependenciescontextDependencies  missingDependenciescontent  RawSource content  string  buffer\n\n\n# Parse\n\nbuild(options, compilation, resolver, fs, callback) {\n // ......\n //  _doBuild  Build  Parse \n return this._doBuild(options, compilation, resolver, fs, hooks, (err) => {\n  //  CompilationHook.beforeParse => call\n  hooks.beforeParse.call(this);\n  //  module.noParse parse\n  const noParseRule = options.module && options.module.noParse;\n  if (this.shouldPreventParsing(noParseRule, this.request)) {\n   // We assume that we need module and exports\n   this.buildInfo.parsed = false;\n   this._initBuildHash(compilation);\n   return handleBuildDone();\n  }\n\n  let result;\n  // (string | buffer)\n  const source = this._source.source();\n  //  Parser parse  AST\n  // result  AST  stateAST  JavaScriptParser parse   JavaScriptParserHook.finish\n  result = this.parser.parse(this._ast || source, {\n   source,\n   current: this,\n   module: this,\n   compilation: compilation,\n   options: options,\n  });\n  handleParseResult(result);\n });\n}\n\nconst handleParseResult = (result) => {\n // \n this.dependencies.sort(\n  concatComparators(\n   compareSelect((a) => a.loc, compareLocations),\n   keepOriginalOrder(this.dependencies)\n  )\n );\n //  build hash\n this._initBuildHash(compilation);\n this._lastSuccessfulBuildMeta = this.buildMeta;\n //  build\n return handleBuildDone();\n};\n\nconst handleBuildDone = () => {\n //  CompilationHook.beforeSnapshot => call\n hooks.beforeSnapshot.call(this);\n\n //  options\n const snapshotOptions = compilation.options.snapshot.module;\n //  cacheable  snapshotOptions  callback\n if (!this.buildInfo.cacheable || !snapshotOptions) {\n  return callback();\n }\n // ......\n // \n checkDependencies(this.buildInfo.fileDependencies);\n checkDependencies(this.buildInfo.missingDependencies);\n checkDependencies(this.buildInfo.contextDependencies);\n //  ......\n // file/context/missingDependencies filesystem\n // convert file/context/missingDependencies into filesystem snapshot\n compilation.fileSystemInfo.createSnapshot(\n  startTime,\n  this.buildInfo.fileDependencies,\n  this.buildInfo.contextDependencies,\n  this.buildInfo.missingDependencies,\n  snapshotOptions,\n  (err, snapshot) => {\n   // ......\n   // \n   this.buildInfo.fileDependencies = undefined;\n   this.buildInfo.contextDependencies = undefined;\n   this.buildInfo.missingDependencies = undefined;\n   this.buildInfo.snapshot = snapshot;\n   return callback();\n  }\n );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n build \n\n *  _doBuild  Build  Parse Build  Loader  sourceParse  AST\n *  module.noParse Parse \n * Parser.parse  source  AST\n * NormalModule  NormalModuleFactory  compiler.compile  newCompilationParams  normalModuleFactoryNormalModule  NormalModuleFactoryHook.factorize  NormalModuleFactoryHook.resolve getParser NormalModuleFactory.create  _factorizeModule  factory.create \n * parser  generator  JavascriptModulesPlugin  CompilerHook.compilation  normalModuleFactoryHook.createParser  normalModuleFactoryHook.createGenerator  JavascriptParser  JavascriptGenerator  lib/javascript/JavascriptModulesPlugin.js  lib/NormalModuleFactory.js \n\n\n# JavascriptParser\n\n// lib/javascript/JavascriptParser.js\nconst { Parser: AcornParser } = require("acorn");\nconst { importAssertions } = require("acorn-import-assertions");\nconst parser = AcornParser.extend(importAssertions);\n\nparse(source, state) {\n  // ......\n  const ast = JavascriptParser._parse(source, {\n    sourceType: this.sourceType,\n    onComment: comments,\n    onInsertedSemicolon: pos => semicolons.add(pos)\n  });\n  // ......\n  // JavaScriptParserHook.program  SyncBailHook \n  if (this.hooks.program.call(ast, comments) === undefined) {\n   //  isStrictisAsmJs\n   this.detectMode(ast.body);\n   // preWalk AST\n   this.preWalkStatements(ast.body);\n   //  prevStatement\n   this.prevStatement = undefined;\n   // blockPreWalk\n   this.blockPreWalkStatements(ast.body);\n   //  prevStatement\n   this.prevStatement = undefined;\n   // Walk AST\n   this.walkStatements(ast.body);\n  }\n\n  //  JavaScriptParserHook.finish => call\n  this.hooks.finish.call(ast, comments);\n  return state;\n}\n\n_parse(code, options) {\n // ......\n const ast = parser.parse(code, parserOptions);\n // ......\n return ast;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n Module  Build  Parse  ASTBuild  loader-runner  Parse  acorn  AST  acorn \n\n\n# \n\n * xtuc/acorn-import-assertions: Support for import assertions in acorn',normalizedContent:' compilation.addentry  compilation  module  module \n\n\n# \n\n\n\n * \n * _handlemodulebuildanddependencies\n * buildmodule\n * build\n   * build\n   * parse\n * javascriptparser\n * \n\n\n\n\n# _handlemodulebuildanddependencies\n\nthis.buildmodule(module, (err) => {\n // ......\n // module  processdependenciesqueue  callback\n // this avoids deadlocks for circular dependencies\n if (this.processdependenciesqueue.isprocessing(module)) {\n  return callback();\n }\n //  processmoduledependencies \n this.processmoduledependencies(module, (err) => {\n  // ......\n  callback(null, module);\n });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n buildmodule  processmoduledependencies \n\n\n# buildmodule\n\nbuildmodule(module, callback) {\n  this.buildqueue.add(module, callback);\n}\n\n\n1\n2\n3\n\n\nbuildmodule  module  buildqueue buildqueue  processor  _buildmodule  processor  module\n\n _buildmodule \n\nfunction _buildmodule(module, callback) {\n //  module  build\n module.needbuild(\n  {\n   compilation: this,\n   filesysteminfo: this.filesysteminfo,\n   valuecacheversions: this.valuecacheversions,\n  },\n  (err, needbuild) => {\n   // ......\n\n   if (!needbuild) {\n    //  build,  compilationhook.stillvalidmodule => call\n    this.hooks.stillvalidmodule.call(module);\n    return callback();\n   }\n   //  compilationhook.buildmodule => call\n   this.hooks.buildmodule.call(module);\n   //  module  builtmodules\n   // this.builtmodules = new weakset();\n   this.builtmodules.add(module);\n   //  build\n   module.build(\n    this.options,\n    this,\n    this.resolverfactory.get("normal", module.resolveoptions),\n    this.inputfilesystem,\n    (err) => {\n     // ......\n    }\n   );\n  }\n );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n module  module.needbuild  module.build  normalmodule \n\nfunction needbuild(context, callback) {\n const { filesysteminfo, compilation, valuecacheversions } = context;\n // build if enforced\n if (this._forcebuild) return callback(null, true);\n\n // always try to build in case of an error\n if (this.error) return callback(null, true);\n //  cacheable  snapshot  build\n // always build when module is not cacheable\n if (!this.buildinfo.cacheable) return callback(null, true);\n\n // build when there is no snapshot to check\n if (!this.buildinfo.snapshot) return callback(null, true);\n\n // build when valuedependencies have changed\n /** @type {map<string, string | set<string>>} */\n const valuedependencies = this.buildinfo.valuedependencies;\n if (valuedependencies) {\n  if (!valuecacheversions) return callback(null, true);\n  //  buildinfo.valuedependencies context.valuecacheversions \n  for (const [key, value] of valuedependencies) {\n   if (value === undefined) return callback(null, true);\n   const current = valuecacheversions.get(key);\n   if (\n    value !== current &&\n    (typeof value === "string" ||\n     typeof current === "string" ||\n     current === undefined ||\n     !issubset(value, current))\n   ) {\n    return callback(null, true);\n   }\n  }\n }\n\n // check snapshot for validity\n filesysteminfo.checksnapshotvalid(this.buildinfo.snapshot, (err, valid) => {\n  if (err) return callback(err);\n  if (!valid) return callback(null, true);\n  const hooks = normalmodule.getcompilationhooks(compilation);\n  //  buildinfo.snapshot  compilationhook.needbuild => callasync\n  hooks.needbuild.callasync(this, context, (err, needbuild) => {\n   // ......\n   callback(null, !!needbuild);\n  });\n });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\nmodule.needbuild  build \n\n\n# build\n\n\n# build\n\nbuild  _dobuild  build \n\n// lib/normalmodule.js\n_dobuild(options, compilation, resolver, fs, hooks, callback) {\n //  loadercontext loader  context()\n const loadercontext = this._createloadercontext(\n  resolver,\n  options,\n  compilation,\n  fs,\n  hooks\n );\n //  filedependenciescontextdependenciesmissingdependencies \n this.buildinfo.filedependencies = new lazyset();\n this.buildinfo.contextdependencies = new lazyset();\n this.buildinfo.missingdependencies = new lazyset();\n this.buildinfo.cacheable = true;\n\n //  compilationhook.beforeloaders => call\n hooks.beforeloaders.call(this.loaders, this, loadercontext);\n // ......\n if (this.loaders.length > 0) {\n  //  builddependencies\n  this.buildinfo.builddependencies = new lazyset();\n }\n //  loader-runner.runloaders \n runloaders(\n  {\n   // resource path\n   resource: this.resource,\n   // module loaders\n   loaders: this.loaders,\n   // module loader context\n   context: loadercontext,\n   // \n   processresource: (loadercontext, resourcepath, callback) => {\n    const resource = loadercontext.resource;\n    //  resource  scheme\n    const scheme = getscheme(resource);\n    // compilationhook.readresource  hookmap .for\n    //  scheme  hookmap  hook\n    hooks.readresource\n     .for(scheme)\n     //   compilationhook.readresource.scheme => callasync\n     .callasync(loadercontext, (err, result) => {\n      // ......\n      return callback(null, result);\n     });\n   },\n  },\n  (err, result) => {\n   // ......\n   //  filedependenciescontextdependencies  missingdependencies\n   this.buildinfo.filedependencies.addall(result.filedependencies);\n   this.buildinfo.contextdependencies.addall(result.contextdependencies);\n   this.buildinfo.missingdependencies.addall(result.missingdependencies);\n   //  loader\n   for (const loader of this.loaders) {\n    this.buildinfo.builddependencies.add(loader.loader);\n   }\n   this.buildinfo.cacheable = this.buildinfo.cacheable && result.cacheable;\n   //  loader \n   processresult(err, result.result);\n  }\n );\n}\n\nconst processresult = (err, result) => {\n // ......\n //  sourcesourcemap  extrainfo\n const source = result[0];\n const sourcemap = result.length >= 1 ? result[1] : null;\n const extrainfo = result.length >= 2 ? result[2] : null;\n\n // ......\n //  rawsource \n this._source = this.createsource(\n  options.context,\n  this.binary ? asbuffer(source) : asstring(source),\n  sourcemap,\n  compilation.compiler.root\n );\n // ......\n //  extrainfo  ast\n this._ast =\n  typeof extrainfo === "object" &&\n  extrainfo !== null &&\n  extrainfo.webpackast !== undefined\n   ? extrainfo.webpackast\n   : null;\n return callback();\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n\n\n\n\n * runloaders  loader-runner  webpack  javascript  loadercontext  loader \n * loader  dependencies  contentdependencies  filedependenciescontextdependencies  missingdependenciescontent  rawsource content  string  buffer\n\n\n# parse\n\nbuild(options, compilation, resolver, fs, callback) {\n // ......\n //  _dobuild  build  parse \n return this._dobuild(options, compilation, resolver, fs, hooks, (err) => {\n  //  compilationhook.beforeparse => call\n  hooks.beforeparse.call(this);\n  //  module.noparse parse\n  const noparserule = options.module && options.module.noparse;\n  if (this.shouldpreventparsing(noparserule, this.request)) {\n   // we assume that we need module and exports\n   this.buildinfo.parsed = false;\n   this._initbuildhash(compilation);\n   return handlebuilddone();\n  }\n\n  let result;\n  // (string | buffer)\n  const source = this._source.source();\n  //  parser parse  ast\n  // result  ast  stateast  javascriptparser parse   javascriptparserhook.finish\n  result = this.parser.parse(this._ast || source, {\n   source,\n   current: this,\n   module: this,\n   compilation: compilation,\n   options: options,\n  });\n  handleparseresult(result);\n });\n}\n\nconst handleparseresult = (result) => {\n // \n this.dependencies.sort(\n  concatcomparators(\n   compareselect((a) => a.loc, comparelocations),\n   keeporiginalorder(this.dependencies)\n  )\n );\n //  build hash\n this._initbuildhash(compilation);\n this._lastsuccessfulbuildmeta = this.buildmeta;\n //  build\n return handlebuilddone();\n};\n\nconst handlebuilddone = () => {\n //  compilationhook.beforesnapshot => call\n hooks.beforesnapshot.call(this);\n\n //  options\n const snapshotoptions = compilation.options.snapshot.module;\n //  cacheable  snapshotoptions  callback\n if (!this.buildinfo.cacheable || !snapshotoptions) {\n  return callback();\n }\n // ......\n // \n checkdependencies(this.buildinfo.filedependencies);\n checkdependencies(this.buildinfo.missingdependencies);\n checkdependencies(this.buildinfo.contextdependencies);\n //  ......\n // file/context/missingdependencies filesystem\n // convert file/context/missingdependencies into filesystem snapshot\n compilation.filesysteminfo.createsnapshot(\n  starttime,\n  this.buildinfo.filedependencies,\n  this.buildinfo.contextdependencies,\n  this.buildinfo.missingdependencies,\n  snapshotoptions,\n  (err, snapshot) => {\n   // ......\n   // \n   this.buildinfo.filedependencies = undefined;\n   this.buildinfo.contextdependencies = undefined;\n   this.buildinfo.missingdependencies = undefined;\n   this.buildinfo.snapshot = snapshot;\n   return callback();\n  }\n );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n build \n\n *  _dobuild  build  parse build  loader  sourceparse  ast\n *  module.noparse parse \n * parser.parse  source  ast\n * normalmodule  normalmodulefactory  compiler.compile  newcompilationparams  normalmodulefactorynormalmodule  normalmodulefactoryhook.factorize  normalmodulefactoryhook.resolve getparser normalmodulefactory.create  _factorizemodule  factory.create \n * parser  generator  javascriptmodulesplugin  compilerhook.compilation  normalmodulefactoryhook.createparser  normalmodulefactoryhook.creategenerator  javascriptparser  javascriptgenerator  lib/javascript/javascriptmodulesplugin.js  lib/normalmodulefactory.js \n\n\n# javascriptparser\n\n// lib/javascript/javascriptparser.js\nconst { parser: acornparser } = require("acorn");\nconst { importassertions } = require("acorn-import-assertions");\nconst parser = acornparser.extend(importassertions);\n\nparse(source, state) {\n  // ......\n  const ast = javascriptparser._parse(source, {\n    sourcetype: this.sourcetype,\n    oncomment: comments,\n    oninsertedsemicolon: pos => semicolons.add(pos)\n  });\n  // ......\n  // javascriptparserhook.program  syncbailhook \n  if (this.hooks.program.call(ast, comments) === undefined) {\n   //  isstrictisasmjs\n   this.detectmode(ast.body);\n   // prewalk ast\n   this.prewalkstatements(ast.body);\n   //  prevstatement\n   this.prevstatement = undefined;\n   // blockprewalk\n   this.blockprewalkstatements(ast.body);\n   //  prevstatement\n   this.prevstatement = undefined;\n   // walk ast\n   this.walkstatements(ast.body);\n  }\n\n  //  javascriptparserhook.finish => call\n  this.hooks.finish.call(ast, comments);\n  return state;\n}\n\n_parse(code, options) {\n // ......\n const ast = parser.parse(code, parseroptions);\n // ......\n return ast;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n module  build  parse  astbuild  loader-runner  parse  acorn  ast  acorn \n\n\n# \n\n * xtuc/acorn-import-assertions: support for import assertions in acorn',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"make walk",frontmatter:{title:"make walk",date:"2022-04-25T19:58:49.000Z",permalink:"/webpack/make/walk/",categories:["webpack","make"],tags:[null]},regularPath:"/30.web/7.webpack/30.make%E9%98%B6%E6%AE%B5/30.walk.html",relativePath:"30.web/7.webpack/30.make/30.walk.md",key:"v-4bc1c689",path:"/webpack/make/walk/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:205},{level:2,title:"ParserHook.program",slug:"parserhook-program",normalizedTitle:"parserhook.program",charIndex:220},{level:2,title:"UseStrictPlugin",slug:"usestrictplugin",normalizedTitle:"usestrictplugin",charIndex:242},{level:2,title:"HarmonyDetectionParserPlugin",slug:"harmonydetectionparserplugin",normalizedTitle:"harmonydetectionparserplugin",charIndex:261},{level:2,title:"preWalkStatements",slug:"prewalkstatements",normalizedTitle:"prewalkstatements",charIndex:293},{level:2,title:"defineVariable",slug:"definevariable",normalizedTitle:"definevariable",charIndex:314},{level:2,title:"blockPreWalkStatements",slug:"blockprewalkstatements",normalizedTitle:"blockprewalkstatements",charIndex:332},{level:2,title:"walkStatements",slug:"walkstatements",normalizedTitle:"walkstatements",charIndex:358},{level:2,title:"HarmonyImportDependencyParserPlugin",slug:"harmonyimportdependencyparserplugin",normalizedTitle:"harmonyimportdependencyparserplugin",charIndex:376},{level:2,title:"HarmonyExportDependencyParserPlugin",slug:"harmonyexportdependencyparserplugin",normalizedTitle:"harmonyexportdependencyparserplugin",charIndex:415},{level:2,title:"import/export",slug:"import-export",normalizedTitle:"import/export",charIndex:454},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:471}],excerpt:"<TimeToRead />\n<p> Module  Build  Parse webpack  make  EntryModule ModuleDependence  DependenceTree EntryModule  make  ModuleTree  make </p>\n",readingTime:{text:"5 min read",minutes:4.42,time:265200,words:884},headersStr:" ParserHook.program UseStrictPlugin HarmonyDetectionParserPlugin preWalkStatements defineVariable blockPreWalkStatements walkStatements HarmonyImportDependencyParserPlugin HarmonyExportDependencyParserPlugin import/export ",content:' Module  Build  Parse webpack  make  EntryModule ModuleDependence  DependenceTree EntryModule  make  ModuleTree  make \n\n\n# \n\n\n\n * \n * ParserHook.program\n * UseStrictPlugin\n * HarmonyDetectionParserPlugin\n * preWalkStatements\n * defineVariable\n * blockPreWalkStatements\n * walkStatements\n * HarmonyImportDependencyParserPlugin\n * HarmonyExportDependencyParserPlugin\n * import/export\n * \n\n\n\n JavascriptParser parser.pase  Module  AST\n\nif (this.hooks.program.call(ast, comments) === undefined) {\n  // preWalk AST\n  this.preWalkStatements(ast.body);\n  // blockPreWalk\n  this.blockPreWalkStatements(ast.body);\n  // Walk AST\n  this.walkStatements(ast.body);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n ast.body  preWalk  walk  preWalk  walk walk  AST \n\n\n# ParserHook.program\n\n Hook  program acorn  ESTree  parse  AST  Program\n\n{\n  "type": "Program",\n  "start": 0,\n  "end": 25,\n  "body": [\n    {\n      "type": "FunctionDeclaration",\n      "start": 0,\n      "end": 24,\n      "id": {\n        "type": "Identifier",\n        "start": 9,\n        "end": 18,\n        "name": "printTips"\n      },\n      "expression": false,\n      "generator": false,\n      "async": false,\n      "params": [],\n      "body": {\n        "type": "BlockStatement",\n        "start": 21,\n        "end": 24,\n        "body": []\n      }\n    }\n  ],\n  "sourceType": "module"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n\n * AST explorer\n\n ParserHook.program  Callback\n\n * CompatibilityPlugin\n * DefinePlugin\n * UseStrictPlugin\n * HarmonyDetectionParserPlugin\n * InnerGraphPlugin\n * SideEffectsFlagPlugin\n\n AST  lib/WebpackOptionsApply.js  compiler parser \n\nnormalModuleFactory.hooks.parser\n.for("javascript/auto")\n.tap("CompatibilityPlugin", handler);\nnormalModuleFactory.hooks.parser\n.for("javascript/dynamic")\n.tap("CompatibilityPlugin", handler);\nnormalModuleFactory.hooks.parser\n.for("javascript/esm")\n.tap("CompatibilityPlugin", handler);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n NormalModuleFactoryHook.parser  parser  handler  ParserHook.program \n\n\n# UseStrictPlugin\n\nparser.hooks.program.tap("UseStrictPlugin", (ast) => {\n const firstNode = ast.body[0];\n //  use strict\n if (\n  firstNode &&\n  firstNode.type === "ExpressionStatement" &&\n  firstNode.expression.type === "Literal" &&\n  firstNode.expression.value === "use strict"\n ) {\n  // Remove "use strict" expression. It will be added later by the renderer again.\n  // This is necessary in order to not break the strict mode when webpack prepends code.\n  // @see https://github.com/webpack/webpack/issues/1970\n  //  use strict  ConstDependency\n  const dep = new ConstDependency("", firstNode.range);\n  dep.loc = firstNode.loc;\n  parser.state.module.addPresentationalDependency(dep);\n  parser.state.module.buildInfo.strict = true;\n }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# HarmonyDetectionParserPlugin\n\nparser.hooks.program.tap("HarmonyDetectionParserPlugin", (ast) => {\n //  Module  javascript/esm HarmonyCompatibilityDependency\n const isStrictHarmony = parser.state.module.type === "javascript/esm";\n //  import/export  HarmonyCompatibilityDependency\n const isHarmony =\n  isStrictHarmony ||\n  ast.body.some(\n   (statement) =>\n    statement.type === "ImportDeclaration" ||\n    statement.type === "ExportDefaultDeclaration" ||\n    statement.type === "ExportNamedDeclaration" ||\n    statement.type === "ExportAllDeclaration"\n  );\n //  HarmonyCompatibilityDependency\n if (isHarmony) {\n  const module = parser.state.module;\n  const compatDep = new HarmonyCompatibilityDependency();\n  compatDep.loc = {\n   start: {\n    line: -1,\n    column: 0,\n   },\n   end: {\n    line: -1,\n    column: 0,\n   },\n   index: -3,\n  };\n  module.addPresentationalDependency(compatDep);\n  // ......\n  parser.scope.isStrict = true;\n }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nParserHook.program  AST  \'use strict\'  import/export  Module  ConstDependency  HarmonyCompatibilityDependency\n\n\n# preWalkStatements\n\nDFSAST ParserHook.preStatement scope\n\n// Pre walking iterates the scope for variable declarations\npreWalkStatements(statements) {\n  for (let index = 0, len = statements.length; index < len; index++) {\n   const statement = statements[index];\n   this.preWalkStatement(statement);\n  }\n}\n\npreWalkStatement(statement) {\n this.statementPath.push(statement);\n  //  ParserHook.preStatement => call\n if (this.hooks.preStatement.call(statement)) {\n  this.prevStatement = this.statementPath.pop();\n  return;\n }\n switch (statement.type) {\n  case "BlockStatement":\n   this.preWalkBlockStatement(statement);\n   break;\n  case "DoWhileStatement":\n   this.preWalkDoWhileStatement(statement);\n   break;\n  case "ForInStatement":\n   this.preWalkForInStatement(statement);\n   break;\n  case "ForOfStatement":\n   this.preWalkForOfStatement(statement);\n   break;\n  case "ForStatement":\n   this.preWalkForStatement(statement);\n   break;\n  case "FunctionDeclaration":\n   this.preWalkFunctionDeclaration(statement);\n   break;\n  case "IfStatement":\n   this.preWalkIfStatement(statement);\n   break;\n  case "LabeledStatement":\n   this.preWalkLabeledStatement(statement);\n   break;\n  case "SwitchStatement":\n   this.preWalkSwitchStatement(statement);\n   break;\n  case "TryStatement":\n   this.preWalkTryStatement(statement);\n   break;\n  case "VariableDeclaration":\n   this.preWalkVariableDeclaration(statement);\n   break;\n  case "WhileStatement":\n   this.preWalkWhileStatement(statement);\n   break;\n  case "WithStatement":\n   this.preWalkWithStatement(statement);\n   break;\n }\n this.prevStatement = this.statementPath.pop();\n}\n// ......\n\n_preWalkVariableDeclaration(statement, hookMap) {\n for (const declarator of statement.declarations) {\n  switch (declarator.type) {\n   case "VariableDeclarator": {\n    //   ParserHook.preDeclarator => call\n    if (!this.hooks.preDeclarator.call(declarator, statement)) {\n     this.enterPattern(declarator.id, (name, decl) => {\n      let hook = hookMap.get(name);\n      if (hook === undefined || !hook.call(decl)) {\n       hook = this.hooks.varDeclaration.get(name);\n       if (hook === undefined || !hook.call(decl)) {\n        this.defineVariable(name);\n       }\n      }\n     });\n    }\n    break;\n   }\n  }\n }\n}\n\ndefineVariable(name) {\n const oldInfo = this.scope.definitions.get(name);\n // ......\n //  scope  this.scope.definitions\n this.scope.definitions.set(name, this.scope);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# defineVariable\n\n\n# blockPreWalkStatements\n\n AST ParserHook.blockPreStatement block import/export\n\n// Block pre walking iterates the scope for block variable declarations\nblockPreWalkStatements(statements) {\n for (let index = 0, len = statements.length; index < len; index++) {\n  const statement = statements[index];\n  this.blockPreWalkStatement(statement);\n }\n}\n\nblockPreWalkStatement(statement) {\n this.statementPath.push(statement);\n //  ParserHook.blockPreStatement => call\n if (this.hooks.blockPreStatement.call(statement)) {\n  this.prevStatement = this.statementPath.pop();\n  return;\n }\n switch (statement.type) {\n  case "ImportDeclaration":\n   //  ParserHook.import\n   //  ParserHook.importSpecifier\n   this.blockPreWalkImportDeclaration(statement);\n   break;\n  case "ExportAllDeclaration":\n   //  ParserHook.exportImport\n   //  ParserHook.exportImportSpecifier\n   this.blockPreWalkExportAllDeclaration(statement);\n   break;\n  case "ExportDefaultDeclaration":\n   //  ParserHook.exportSpecifier\n   this.blockPreWalkExportDefaultDeclaration(statement);\n   break;\n  case "ExportNamedDeclaration":\n   //   ParserHook.exportImport  ParserHook.export\n   //   ParserHook.exportDeclaration\n   //   ParserHook.exportImportSpecifier  ParserHook.exportSpecifier\n   this.blockPreWalkExportNamedDeclaration(statement);\n   break;\n  case "VariableDeclaration":\n   this.blockPreWalkVariableDeclaration(statement);\n   break;\n  case "ClassDeclaration":\n   this.blockPreWalkClassDeclaration(statement);\n   break;\n }\n this.prevStatement = this.statementPath.pop();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# walkStatements\n\nwalk  AST Parser  Hook ParserHook \n\n Hook \n\n\n# HarmonyImportDependencyParserPlugin\n\n hook  parser.state.module.addDependency  lib/dependencies/HarmonyImportDependencyParserPlugin.js \n\nPARSERHOOK              ADDDEPENDENCY                               HOOK \nimport                  HarmonyImportSideEffectDependency           blockPreWalkStatement => blockPreWalkImportDeclaration\nbinaryExpression        HarmonyEvaluatedImportSpecifierDependency   walkArrayExpression...... => walkExpressions =>\n                                                                    walkExpression => walkBinaryExpression\nexpression              HarmonyImportSpecifierDependency            walkExpressions => walkExpression => walkMetaProperty\nexpressionMemberChain   HarmonyImportSpecifierDependency            walkExpressions => walkExpression => walkMemberExpression\ncallMemberChain         HarmonyImportSpecifierDependency            walkExpressions => walkExpression => walkCallExpression\n\n\n# HarmonyExportDependencyParserPlugin\n\nPARSERHOOK              ADDDEPENDENCY                                HOOK \nexportImport            HarmonyImportSideEffectDependency            blockPreWalkStatements => blockPreWalkStatement =>\n                                                                     blockPreWalkExportNamedDeclaration\nexportExpression        HarmonyExportExpressionDependency            walkStatements => walkStatement =>\n                                                                     walkExportDefaultDeclaration\nexportSpecifier         HarmonyExportImportedSpecifierDependency     blockPreWalkStatements => blockPreWalkStatement =>\n                                                                     blockPreWalkExportDefaultDeclaration\nexportImportSpecifier   HarmonyExportImportedSpecifierDependency    blockPreWalkStatements => blockPreWalkStatement =>\n                        HarmonyExportImportedSpecifierDependency     blockPreWalkExportAllDeclaration\n\n .addDependency(dep)  ParserHook  Module \n\n// lib/DependenciesBlock.js\naddDependency(dependency) {\n this.dependencies.push(dependency);\n}\n\n\n1\n2\n3\n4\n\n\n NormalModule  ModuleModule  DependenciesBlock  Module  dependencies \n\n\n# import/export\n\n\n# ',normalizedContent:' module  build  parse webpack  make  entrymodule moduledependence  dependencetree entrymodule  make  moduletree  make \n\n\n# \n\n\n\n * \n * parserhook.program\n * usestrictplugin\n * harmonydetectionparserplugin\n * prewalkstatements\n * definevariable\n * blockprewalkstatements\n * walkstatements\n * harmonyimportdependencyparserplugin\n * harmonyexportdependencyparserplugin\n * import/export\n * \n\n\n\n javascriptparser parser.pase  module  ast\n\nif (this.hooks.program.call(ast, comments) === undefined) {\n  // prewalk ast\n  this.prewalkstatements(ast.body);\n  // blockprewalk\n  this.blockprewalkstatements(ast.body);\n  // walk ast\n  this.walkstatements(ast.body);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n ast.body  prewalk  walk  prewalk  walk walk  ast \n\n\n# parserhook.program\n\n hook  program acorn  estree  parse  ast  program\n\n{\n  "type": "program",\n  "start": 0,\n  "end": 25,\n  "body": [\n    {\n      "type": "functiondeclaration",\n      "start": 0,\n      "end": 24,\n      "id": {\n        "type": "identifier",\n        "start": 9,\n        "end": 18,\n        "name": "printtips"\n      },\n      "expression": false,\n      "generator": false,\n      "async": false,\n      "params": [],\n      "body": {\n        "type": "blockstatement",\n        "start": 21,\n        "end": 24,\n        "body": []\n      }\n    }\n  ],\n  "sourcetype": "module"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n\n * ast explorer\n\n parserhook.program  callback\n\n * compatibilityplugin\n * defineplugin\n * usestrictplugin\n * harmonydetectionparserplugin\n * innergraphplugin\n * sideeffectsflagplugin\n\n ast  lib/webpackoptionsapply.js  compiler parser \n\nnormalmodulefactory.hooks.parser\n.for("javascript/auto")\n.tap("compatibilityplugin", handler);\nnormalmodulefactory.hooks.parser\n.for("javascript/dynamic")\n.tap("compatibilityplugin", handler);\nnormalmodulefactory.hooks.parser\n.for("javascript/esm")\n.tap("compatibilityplugin", handler);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n normalmodulefactoryhook.parser  parser  handler  parserhook.program \n\n\n# usestrictplugin\n\nparser.hooks.program.tap("usestrictplugin", (ast) => {\n const firstnode = ast.body[0];\n //  use strict\n if (\n  firstnode &&\n  firstnode.type === "expressionstatement" &&\n  firstnode.expression.type === "literal" &&\n  firstnode.expression.value === "use strict"\n ) {\n  // remove "use strict" expression. it will be added later by the renderer again.\n  // this is necessary in order to not break the strict mode when webpack prepends code.\n  // @see https://github.com/webpack/webpack/issues/1970\n  //  use strict  constdependency\n  const dep = new constdependency("", firstnode.range);\n  dep.loc = firstnode.loc;\n  parser.state.module.addpresentationaldependency(dep);\n  parser.state.module.buildinfo.strict = true;\n }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# harmonydetectionparserplugin\n\nparser.hooks.program.tap("harmonydetectionparserplugin", (ast) => {\n //  module  javascript/esm harmonycompatibilitydependency\n const isstrictharmony = parser.state.module.type === "javascript/esm";\n //  import/export  harmonycompatibilitydependency\n const isharmony =\n  isstrictharmony ||\n  ast.body.some(\n   (statement) =>\n    statement.type === "importdeclaration" ||\n    statement.type === "exportdefaultdeclaration" ||\n    statement.type === "exportnameddeclaration" ||\n    statement.type === "exportalldeclaration"\n  );\n //  harmonycompatibilitydependency\n if (isharmony) {\n  const module = parser.state.module;\n  const compatdep = new harmonycompatibilitydependency();\n  compatdep.loc = {\n   start: {\n    line: -1,\n    column: 0,\n   },\n   end: {\n    line: -1,\n    column: 0,\n   },\n   index: -3,\n  };\n  module.addpresentationaldependency(compatdep);\n  // ......\n  parser.scope.isstrict = true;\n }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nparserhook.program  ast  \'use strict\'  import/export  module  constdependency  harmonycompatibilitydependency\n\n\n# prewalkstatements\n\ndfsast parserhook.prestatement scope\n\n// pre walking iterates the scope for variable declarations\nprewalkstatements(statements) {\n  for (let index = 0, len = statements.length; index < len; index++) {\n   const statement = statements[index];\n   this.prewalkstatement(statement);\n  }\n}\n\nprewalkstatement(statement) {\n this.statementpath.push(statement);\n  //  parserhook.prestatement => call\n if (this.hooks.prestatement.call(statement)) {\n  this.prevstatement = this.statementpath.pop();\n  return;\n }\n switch (statement.type) {\n  case "blockstatement":\n   this.prewalkblockstatement(statement);\n   break;\n  case "dowhilestatement":\n   this.prewalkdowhilestatement(statement);\n   break;\n  case "forinstatement":\n   this.prewalkforinstatement(statement);\n   break;\n  case "forofstatement":\n   this.prewalkforofstatement(statement);\n   break;\n  case "forstatement":\n   this.prewalkforstatement(statement);\n   break;\n  case "functiondeclaration":\n   this.prewalkfunctiondeclaration(statement);\n   break;\n  case "ifstatement":\n   this.prewalkifstatement(statement);\n   break;\n  case "labeledstatement":\n   this.prewalklabeledstatement(statement);\n   break;\n  case "switchstatement":\n   this.prewalkswitchstatement(statement);\n   break;\n  case "trystatement":\n   this.prewalktrystatement(statement);\n   break;\n  case "variabledeclaration":\n   this.prewalkvariabledeclaration(statement);\n   break;\n  case "whilestatement":\n   this.prewalkwhilestatement(statement);\n   break;\n  case "withstatement":\n   this.prewalkwithstatement(statement);\n   break;\n }\n this.prevstatement = this.statementpath.pop();\n}\n// ......\n\n_prewalkvariabledeclaration(statement, hookmap) {\n for (const declarator of statement.declarations) {\n  switch (declarator.type) {\n   case "variabledeclarator": {\n    //   parserhook.predeclarator => call\n    if (!this.hooks.predeclarator.call(declarator, statement)) {\n     this.enterpattern(declarator.id, (name, decl) => {\n      let hook = hookmap.get(name);\n      if (hook === undefined || !hook.call(decl)) {\n       hook = this.hooks.vardeclaration.get(name);\n       if (hook === undefined || !hook.call(decl)) {\n        this.definevariable(name);\n       }\n      }\n     });\n    }\n    break;\n   }\n  }\n }\n}\n\ndefinevariable(name) {\n const oldinfo = this.scope.definitions.get(name);\n // ......\n //  scope  this.scope.definitions\n this.scope.definitions.set(name, this.scope);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# definevariable\n\n\n# blockprewalkstatements\n\n ast parserhook.blockprestatement block import/export\n\n// block pre walking iterates the scope for block variable declarations\nblockprewalkstatements(statements) {\n for (let index = 0, len = statements.length; index < len; index++) {\n  const statement = statements[index];\n  this.blockprewalkstatement(statement);\n }\n}\n\nblockprewalkstatement(statement) {\n this.statementpath.push(statement);\n //  parserhook.blockprestatement => call\n if (this.hooks.blockprestatement.call(statement)) {\n  this.prevstatement = this.statementpath.pop();\n  return;\n }\n switch (statement.type) {\n  case "importdeclaration":\n   //  parserhook.import\n   //  parserhook.importspecifier\n   this.blockprewalkimportdeclaration(statement);\n   break;\n  case "exportalldeclaration":\n   //  parserhook.exportimport\n   //  parserhook.exportimportspecifier\n   this.blockprewalkexportalldeclaration(statement);\n   break;\n  case "exportdefaultdeclaration":\n   //  parserhook.exportspecifier\n   this.blockprewalkexportdefaultdeclaration(statement);\n   break;\n  case "exportnameddeclaration":\n   //   parserhook.exportimport  parserhook.export\n   //   parserhook.exportdeclaration\n   //   parserhook.exportimportspecifier  parserhook.exportspecifier\n   this.blockprewalkexportnameddeclaration(statement);\n   break;\n  case "variabledeclaration":\n   this.blockprewalkvariabledeclaration(statement);\n   break;\n  case "classdeclaration":\n   this.blockprewalkclassdeclaration(statement);\n   break;\n }\n this.prevstatement = this.statementpath.pop();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# walkstatements\n\nwalk  ast parser  hook parserhook \n\n hook \n\n\n# harmonyimportdependencyparserplugin\n\n hook  parser.state.module.adddependency  lib/dependencies/harmonyimportdependencyparserplugin.js \n\nparserhook              adddependency                               hook \nimport                  harmonyimportsideeffectdependency           blockprewalkstatement => blockprewalkimportdeclaration\nbinaryexpression        harmonyevaluatedimportspecifierdependency   walkarrayexpression...... => walkexpressions =>\n                                                                    walkexpression => walkbinaryexpression\nexpression              harmonyimportspecifierdependency            walkexpressions => walkexpression => walkmetaproperty\nexpressionmemberchain   harmonyimportspecifierdependency            walkexpressions => walkexpression => walkmemberexpression\ncallmemberchain         harmonyimportspecifierdependency            walkexpressions => walkexpression => walkcallexpression\n\n\n# harmonyexportdependencyparserplugin\n\nparserhook              adddependency                                hook \nexportimport            harmonyimportsideeffectdependency            blockprewalkstatements => blockprewalkstatement =>\n                                                                     blockprewalkexportnameddeclaration\nexportexpression        harmonyexportexpressiondependency            walkstatements => walkstatement =>\n                                                                     walkexportdefaultdeclaration\nexportspecifier         harmonyexportimportedspecifierdependency     blockprewalkstatements => blockprewalkstatement =>\n                                                                     blockprewalkexportdefaultdeclaration\nexportimportspecifier   harmonyexportimportedspecifierdependency    blockprewalkstatements => blockprewalkstatement =>\n                        harmonyexportimportedspecifierdependency     blockprewalkexportalldeclaration\n\n .adddependency(dep)  parserhook  module \n\n// lib/dependenciesblock.js\nadddependency(dependency) {\n this.dependencies.push(dependency);\n}\n\n\n1\n2\n3\n4\n\n\n normalmodule  modulemodule  dependenciesblock  module  dependencies \n\n\n# import/export\n\n\n# ',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:20.000Z",permalink:"/pages/08c8a2/",categories:["am-editor"],tags:[null]},regularPath:"/30.web/70.am-editor/0.index.html",relativePath:"30.web/70.am-editor/0.index.md",key:"v-7b75117d",path:"/pages/08c8a2/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"index",frontmatter:{title:"index",date:"2022-04-14T22:02:20.000Z",permalink:"/pages/da29c0/",categories:["am-editor","engine"],tags:[null]},regularPath:"/30.web/70.am-editor/10.engine/0.index.html",relativePath:"30.web/70.am-editor/10.engine/0.index.md",key:"v-10d9c13d",path:"/pages/da29c0/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:16},{level:2,title:"EditorInterface",slug:"editorinterface",normalizedTitle:"editorinterface",charIndex:31}],readingTime:{text:"5 min read",minutes:4.64,time:278400,words:928},headersStr:" EditorInterface",content:"# Engine \n\n\n# \n\n\n\n * \n * EditorInterface\n\n\n\n\n# EditorInterface\n\nEditor \n\n * locale: \n * kind: \n * container: \n * command\n * request: \n * card: \n * plugin: \n * node:  listmark nodeinline nodeblock node \n * event:  Eventevent hooks  on/off/trigger\n * schema  conversion\n * clipboard: \n * message:  messageSuccessmessageError  messageConfirm\n\nexport interface EditorInterface {\n /**\n  * \n  */\n readonly kind: 'engine' | 'view';\n /**\n  * \n  */\n language: LanguageInterface;\n /**\n  * \n  */\n container: NodeInterface;\n /**\n  * \n  */\n readonly scrollNode: NodeInterface | null;\n /**\n  * \n  */\n root: NodeInterface;\n /**\n  * \n  */\n command: CommandInterface;\n /**\n  * \n  */\n request: RequestInterface;\n /**\n  * \n  */\n card: CardModelInterface;\n /**\n  * \n  */\n plugin: PluginModelInterface;\n /**\n  * \n  */\n node: NodeModelInterface;\n /**\n  * id\n  */\n nodeId: NodeIdInterface;\n /**\n  * List \n  */\n list: ListModelInterface;\n /**\n  * Mark \n  */\n mark: MarkModelInterface;\n /**\n  * inline \n  */\n inline: InlineModelInterface;\n /**\n  * block \n  */\n block: BlockModelInterface;\n /**\n  * \n  */\n event: EventInterface;\n /**\n  * \n  */\n schema: SchemaInterface;\n /**\n  * \n  */\n conversion: ConversionInterface;\n /**\n  * \n  */\n clipboard: ClipboardInterface;\n /**\n  * \n  * @param eventType \n  * @param listener \n  * @param rewrite \n  */\n on(eventType: string, listener: EventListener, rewrite?: boolean): void;\n /**\n  * ctrl+afalse\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:all',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(\n  eventType: 'card:minimize',\n  listener: (card: CardInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(\n  eventType: 'card:maximize',\n  listener: (card: CardInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * DOM XML \n  * @param root DOM\n  */\n on(\n  eventType: 'parse:value-before',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * DOM XMLfalse\n  * @param node \n  * @param attributes \n  * @param styles \n  * @param value xml\n  */\n on(\n  eventType: 'parse:value',\n  listener: (\n   node: NodeInterface,\n   attributes: { [key: string]: string },\n   styles: { [key: string]: string },\n   value: Array<string>,\n  ) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * DOM XMLxml\n  * @param value xml\n  */\n on(\n  eventType: 'parse:value-after',\n  listener: (value: Array<string>) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * HTML\n  * @param root \n  */\n on(\n  eventType: 'parse:html-before',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * HTML\n  * @param root \n  */\n on(\n  eventType: 'parse:html',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * HTML\n  * @param root \n  */\n on(\n  eventType: 'parse:html-after',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * DOM\n  * @param node \n  */\n on(\n  eventType: 'copy',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventType \n  * @param listener \n  */\n off(eventType: string, listener: EventListener): void;\n /**\n  * ctrl+afalse\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:all',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n off(\n  eventType: 'card:minimize',\n  listener: (card: CardInterface) => void,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n off(\n  eventType: 'card:maximize',\n  listener: (card: CardInterface) => void,\n ): void;\n /**\n  * DOM XML \n  * @param root DOM\n  */\n off(\n  eventType: 'parse:value-before',\n  listener: (root: NodeInterface) => void,\n ): void;\n /**\n  * DOM XMLfalse\n  * @param node \n  * @param attributes \n  * @param styles \n  * @param value xml\n  */\n off(\n  eventType: 'parse:value',\n  listener: (\n   node: NodeInterface,\n   attributes: { [key: string]: string },\n   styles: { [key: string]: string },\n   value: Array<string>,\n  ) => boolean | void,\n ): void;\n /**\n  * DOM XMLxml\n  * @param value xml\n  */\n off(\n  eventType: 'parse:value-after',\n  listener: (value: Array<string>) => void,\n ): void;\n /**\n  * HTML\n  * @param root \n  */\n off(\n  eventType: 'parse:html-before',\n  listener: (root: NodeInterface) => void,\n ): void;\n /**\n  * HTML\n  * @param root \n  */\n off(eventType: 'parse:html', listener: (root: NodeInterface) => void): void;\n /**\n  * HTML\n  * @param root \n  */\n off(\n  eventType: 'parse:html-after',\n  listener: (root: NodeInterface) => void,\n ): void;\n /**\n  * DOM\n  * @param node \n  */\n off(eventType: 'copy', listener: (root: NodeInterface) => void): void;\n /**\n  * \n  * @param eventType \n  * @param args \n  */\n trigger(eventType: string, ...args: any): any;\n /**\n  * ctrl+afalse\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:all', event: KeyboardEvent): boolean | void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n trigger(eventType: 'card:minimize', card: CardInterface): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n trigger(eventType: 'card:maximize', card: CardInterface): void;\n /**\n  * DOM XML \n  * @param root DOM\n  */\n trigger(eventType: 'parse:value-before', root: NodeInterface): void;\n /**\n  * DOM XMLfalse\n  * @param node \n  * @param attributes \n  * @param styles \n  * @param value xml\n  */\n trigger(\n  eventType: 'parse:value',\n  node: NodeInterface,\n  attributes: { [key: string]: string },\n  styles: { [key: string]: string },\n  value: Array<string>,\n ): boolean | void;\n /**\n  * DOM XMLxml\n  * @param value xml\n  */\n trigger(eventType: 'parse:value-after', value: Array<string>): void;\n /**\n  * HTML\n  * @param root \n  */\n trigger(eventType: 'parse:html-before', root: NodeInterface): void;\n /**\n  * HTML\n  * @param root \n  */\n trigger(eventType: 'parse:html', root: NodeInterface): void;\n /**\n  * HTML\n  * @param root \n  */\n trigger(eventType: 'parse:html-after', root: NodeInterface): void;\n /**\n  * DOM\n  * @param node \n  */\n trigger(eventType: 'copy', root: NodeInterface): void;\n /**\n  * \n  * @param message \n  */\n messageSuccess(message: string): void;\n /**\n  * \n  * @param error \n  */\n messageError(error: string): void;\n /**\n  * \n  * @param message \n  */\n messageConfirm(message: string): Promise<boolean>;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n",normalizedContent:"# engine \n\n\n# \n\n\n\n * \n * editorinterface\n\n\n\n\n# editorinterface\n\neditor \n\n * locale: \n * kind: \n * container: \n * command\n * request: \n * card: \n * plugin: \n * node:  listmark nodeinline nodeblock node \n * event:  eventevent hooks  on/off/trigger\n * schema  conversion\n * clipboard: \n * message:  messagesuccessmessageerror  messageconfirm\n\nexport interface editorinterface {\n /**\n  * \n  */\n readonly kind: 'engine' | 'view';\n /**\n  * \n  */\n language: languageinterface;\n /**\n  * \n  */\n container: nodeinterface;\n /**\n  * \n  */\n readonly scrollnode: nodeinterface | null;\n /**\n  * \n  */\n root: nodeinterface;\n /**\n  * \n  */\n command: commandinterface;\n /**\n  * \n  */\n request: requestinterface;\n /**\n  * \n  */\n card: cardmodelinterface;\n /**\n  * \n  */\n plugin: pluginmodelinterface;\n /**\n  * \n  */\n node: nodemodelinterface;\n /**\n  * id\n  */\n nodeid: nodeidinterface;\n /**\n  * list \n  */\n list: listmodelinterface;\n /**\n  * mark \n  */\n mark: markmodelinterface;\n /**\n  * inline \n  */\n inline: inlinemodelinterface;\n /**\n  * block \n  */\n block: blockmodelinterface;\n /**\n  * \n  */\n event: eventinterface;\n /**\n  * \n  */\n schema: schemainterface;\n /**\n  * \n  */\n conversion: conversioninterface;\n /**\n  * \n  */\n clipboard: clipboardinterface;\n /**\n  * \n  * @param eventtype \n  * @param listener \n  * @param rewrite \n  */\n on(eventtype: string, listener: eventlistener, rewrite?: boolean): void;\n /**\n  * ctrl+afalse\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:all',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(\n  eventtype: 'card:minimize',\n  listener: (card: cardinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(\n  eventtype: 'card:maximize',\n  listener: (card: cardinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * dom xml \n  * @param root dom\n  */\n on(\n  eventtype: 'parse:value-before',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * dom xmlfalse\n  * @param node \n  * @param attributes \n  * @param styles \n  * @param value xml\n  */\n on(\n  eventtype: 'parse:value',\n  listener: (\n   node: nodeinterface,\n   attributes: { [key: string]: string },\n   styles: { [key: string]: string },\n   value: array<string>,\n  ) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * dom xmlxml\n  * @param value xml\n  */\n on(\n  eventtype: 'parse:value-after',\n  listener: (value: array<string>) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * html\n  * @param root \n  */\n on(\n  eventtype: 'parse:html-before',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * html\n  * @param root \n  */\n on(\n  eventtype: 'parse:html',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * html\n  * @param root \n  */\n on(\n  eventtype: 'parse:html-after',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * dom\n  * @param node \n  */\n on(\n  eventtype: 'copy',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventtype \n  * @param listener \n  */\n off(eventtype: string, listener: eventlistener): void;\n /**\n  * ctrl+afalse\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:all',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n off(\n  eventtype: 'card:minimize',\n  listener: (card: cardinterface) => void,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n off(\n  eventtype: 'card:maximize',\n  listener: (card: cardinterface) => void,\n ): void;\n /**\n  * dom xml \n  * @param root dom\n  */\n off(\n  eventtype: 'parse:value-before',\n  listener: (root: nodeinterface) => void,\n ): void;\n /**\n  * dom xmlfalse\n  * @param node \n  * @param attributes \n  * @param styles \n  * @param value xml\n  */\n off(\n  eventtype: 'parse:value',\n  listener: (\n   node: nodeinterface,\n   attributes: { [key: string]: string },\n   styles: { [key: string]: string },\n   value: array<string>,\n  ) => boolean | void,\n ): void;\n /**\n  * dom xmlxml\n  * @param value xml\n  */\n off(\n  eventtype: 'parse:value-after',\n  listener: (value: array<string>) => void,\n ): void;\n /**\n  * html\n  * @param root \n  */\n off(\n  eventtype: 'parse:html-before',\n  listener: (root: nodeinterface) => void,\n ): void;\n /**\n  * html\n  * @param root \n  */\n off(eventtype: 'parse:html', listener: (root: nodeinterface) => void): void;\n /**\n  * html\n  * @param root \n  */\n off(\n  eventtype: 'parse:html-after',\n  listener: (root: nodeinterface) => void,\n ): void;\n /**\n  * dom\n  * @param node \n  */\n off(eventtype: 'copy', listener: (root: nodeinterface) => void): void;\n /**\n  * \n  * @param eventtype \n  * @param args \n  */\n trigger(eventtype: string, ...args: any): any;\n /**\n  * ctrl+afalse\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:all', event: keyboardevent): boolean | void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n trigger(eventtype: 'card:minimize', card: cardinterface): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n trigger(eventtype: 'card:maximize', card: cardinterface): void;\n /**\n  * dom xml \n  * @param root dom\n  */\n trigger(eventtype: 'parse:value-before', root: nodeinterface): void;\n /**\n  * dom xmlfalse\n  * @param node \n  * @param attributes \n  * @param styles \n  * @param value xml\n  */\n trigger(\n  eventtype: 'parse:value',\n  node: nodeinterface,\n  attributes: { [key: string]: string },\n  styles: { [key: string]: string },\n  value: array<string>,\n ): boolean | void;\n /**\n  * dom xmlxml\n  * @param value xml\n  */\n trigger(eventtype: 'parse:value-after', value: array<string>): void;\n /**\n  * html\n  * @param root \n  */\n trigger(eventtype: 'parse:html-before', root: nodeinterface): void;\n /**\n  * html\n  * @param root \n  */\n trigger(eventtype: 'parse:html', root: nodeinterface): void;\n /**\n  * html\n  * @param root \n  */\n trigger(eventtype: 'parse:html-after', root: nodeinterface): void;\n /**\n  * dom\n  * @param node \n  */\n trigger(eventtype: 'copy', root: nodeinterface): void;\n /**\n  * \n  * @param message \n  */\n messagesuccess(message: string): void;\n /**\n  * \n  * @param error \n  */\n messageerror(error: string): void;\n /**\n  * \n  * @param message \n  */\n messageconfirm(message: string): promise<boolean>;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"engine-basic",frontmatter:{title:"engine-basic",date:"2022-04-14T22:02:20.000Z",permalink:"/pages/33f539/",categories:["am-editor","engine"],tags:[null]},regularPath:"/30.web/70.am-editor/10.engine/10.engine-basic.html",relativePath:"30.web/70.am-editor/10.engine/10.engine-basic.md",key:"v-778f237d",path:"/pages/33f539/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:19},{level:2,title:"Engine ",slug:"engine-",normalizedTitle:"engine ",charIndex:34},{level:3,title:"EngineOptions",slug:"engineoptions",normalizedTitle:"engineoptions",charIndex:49},{level:3,title:"Engine",slug:"engine",normalizedTitle:"engine",charIndex:2}],readingTime:{text:"17 min read",minutes:17.005,time:1020300,words:3401},headersStr:" Engine  EngineOptions Engine",content:"# Engine Basic\n\n\n# \n\n\n\n * \n * Engine \n   * EngineOptions\n   * Engine\n\n\n\n\n# Engine \n\n\n# EngineOptions\n\n\nexport type EngineOptions = {\n /**\n  *  zh-CN\n  */\n lang?: string;\n /**\n  * \n  */\n locale?: { [key: string]: {} };\n /**\n  * \n  */\n className?: string;\n /**\n  * tab \n  */\n tabIndex?: number;\n /**\n  * \n  */\n root?: Node;\n /**\n  *  overflow  overflow-y  auto  scroll \n  */\n scrollNode?: Node | (() => Node | null);\n /**\n  * \n  */\n plugins?: Array<PluginEntry>;\n /**\n  * \n  */\n cards?: Array<CardEntry>;\n /**\n  * \n  */\n config?: { [k: string]: PluginOptions };\n /**\n  * \n  */\n placeholder?: string;\n /**\n  * \n  */\n readonly?: boolean;\n /**\n  *  lazyRender  true\n  */\n lazyRender?: boolean;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# Engine\n\nexport interface Engine {\n /**\n  * \n  */\n new (selector: Selector, options?: EngineOptions): EngineInterface;\n}\n\nexport interface EngineInterface extends EditorInterface {\n /**\n  * \n  */\n options: EngineOptions;\n /**\n  * \n  */\n readonly: boolean;\n /**\n  * \n  */\n change: ChangeInterface;\n /**\n  * \n  */\n typing: TypingInterface;\n /**\n  * \n  */\n ot: OTInterface;\n\n /**\n  * \n  */\n history: HistoryInterface;\n /**\n  * \n  */\n hotkey: HotkeyInterface;\n /**\n  * \n  */\n focus(toStart?: boolean): void;\n /**\n  * \n  */\n blur(): void;\n /**\n  * \n  */\n isFocus(): boolean;\n /**\n  * \n  */\n isEmpty(): boolean;\n /**\n  * \n  * @param node \n  */\n setScrollNode(node: HTMLElement): void;\n /**\n  * \n  * @param ignoreCursor \n  */\n getValue(ignoreCursor?: boolean): string;\n /**\n  * \n  * \n  * @param ignoreCursor \n  * @param callback  false  number \n  */\n getValueAsync(\n  ignoreCursor?: boolean,\n  callback?: (\n   name: string,\n   card?: CardInterface,\n   ...args: any\n  ) => boolean | number | void,\n ): Promise<string>;\n /**\n  * html\n  */\n getHtml(): string;\n /**\n  * \n  * @param value \n  * @param callback \n  */\n setValue(\n  value: string,\n  callback?: (count: number) => void,\n ): EngineInterface;\n /**\n  * html\n  * @param html html\n  * @param callback \n  */\n setHtml(html: string, callback?: (count: number) => void): EngineInterface;\n /**\n  * json\n  * @param callback \n  */\n setJsonValue(\n  value: Array<any>,\n  callback?: (count: number) => void,\n ): EngineInterface;\n /**\n  * JSON\n  */\n getJsonValue(): string | undefined | (string | {})[];\n /**\n  *  placeholder\n  */\n showPlaceholder(): void;\n /**\n  *  placeholder\n  */\n hidePlaceholder(): void;\n /**\n  * \n  * @param eventType \n  * @param listener \n  * @param rewrite \n  */\n on(eventType: string, listener: EventListener, rewrite?: boolean): void;\n /**\n  * ctrl+afalse\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:all',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(\n  eventType: 'card:minimize',\n  listener: (card: CardInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(\n  eventType: 'card:maximize',\n  listener: (card: CardInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * DOM XML \n  * @param root DOM\n  */\n on(\n  eventType: 'parse:value-before',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * DOM XMLfalse\n  * @param node \n  * @param attributes \n  * @param styles \n  * @param value xml\n  */\n on(\n  eventType: 'parse:value',\n  listener: (\n   node: NodeInterface,\n   attributes: { [key: string]: string },\n   styles: { [key: string]: string },\n   value: Array<string>,\n  ) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * DOM XMLxml\n  * @param value xml\n  */\n on(\n  eventType: 'parse:value-after',\n  listener: (value: Array<string>) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * HTML\n  * @param root \n  */\n on(\n  eventType: 'parse:html-before',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * HTML\n  * @param root \n  */\n on(\n  eventType: 'parse:html',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * HTML\n  * @param root \n  */\n on(\n  eventType: 'parse:html-after',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param data \n  * @param source \n  */\n on(\n  eventType: 'paste:event',\n  listener: (\n   data: ClipboardData & { isPasteText: boolean },\n   source: string,\n  ) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param schema \n  */\n on(\n  eventType: 'paste:schema',\n  listener: (schema: SchemaInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param root DOM\n  */\n on(\n  eventType: 'paste:origin',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param node \n  */\n on(\n  eventType: 'paste:each',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param node \n  */\n on(\n  eventType: 'paste:each-after',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * DOM\n  * @param fragment \n  */\n on(\n  eventType: 'paste:before',\n  listener: (fragment: DocumentFragment) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param range \n  */\n on(\n  eventType: 'paste:insert',\n  listener: (range: RangeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  */\n on(eventType: 'paste:after', listener: () => void, rewrite?: boolean): void;\n /**\n  * DOM\n  * @param node \n  */\n on(\n  eventType: 'copy',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * DOM\n  * @param eventType\n  * @param ops\n  */\n on(\n  eventType: 'ops',\n  listener: (ops: Op[]) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventType \n  * @param listener \n  */\n off(eventType: string, listener: EventListener): void;\n /**\n  * ctrl+afalse\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:all',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n off(\n  eventType: 'card:minimize',\n  listener: (card: CardInterface) => void,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n off(\n  eventType: 'card:maximize',\n  listener: (card: CardInterface) => void,\n ): void;\n /**\n  * DOM XML \n  * @param root DOM\n  */\n off(\n  eventType: 'parse:value-before',\n  listener: (root: NodeInterface) => void,\n ): void;\n /**\n  * DOM XMLfalse\n  * @param node \n  * @param attributes \n  * @param styles \n  * @param value xml\n  */\n off(\n  eventType: 'parse:value',\n  listener: (\n   node: NodeInterface,\n   attributes: { [key: string]: string },\n   styles: { [key: string]: string },\n   value: Array<string>,\n  ) => boolean | void,\n ): void;\n /**\n  * DOM XMLxml\n  * @param value xml\n  */\n off(\n  eventType: 'parse:value-after',\n  listener: (value: Array<string>) => void,\n ): void;\n /**\n  * HTML\n  * @param root \n  */\n off(\n  eventType: 'parse:html-before',\n  listener: (root: NodeInterface) => void,\n ): void;\n /**\n  * HTML\n  * @param root \n  */\n off(eventType: 'parse:html', listener: (root: NodeInterface) => void): void;\n /**\n  * HTML\n  * @param root \n  */\n off(\n  eventType: 'parse:html-after',\n  listener: (root: NodeInterface) => void,\n ): void;\n /**\n  * false\n  * @param data \n  * @param source \n  */\n off(\n  eventType: 'paste:event',\n  listener: (\n   data: ClipboardData & { isPasteText: boolean },\n   source: string,\n  ) => boolean | void,\n ): void;\n /**\n  * \n  * @param schema \n  */\n off(\n  eventType: 'paste:schema',\n  listener: (schema: SchemaInterface) => void,\n ): void;\n /**\n  * \n  * @param root DOM\n  */\n off(\n  eventType: 'paste:origin',\n  listener: (root: NodeInterface) => void,\n ): void;\n /**\n  * \n  * @param node \n  */\n off(eventType: 'paste:each', listener: (root: NodeInterface) => void): void;\n /**\n  * \n  * @param node \n  */\n off(\n  eventType: 'paste:each-after',\n  listener: (root: NodeInterface) => void,\n ): void;\n /**\n  * DOM\n  * @param fragment \n  */\n off(\n  eventType: 'paste:before',\n  listener: (fragment: DocumentFragment) => void,\n ): void;\n /**\n  * \n  * @param range \n  */\n off(\n  eventType: 'paste:insert',\n  listener: (range: RangeInterface) => void,\n ): void;\n /**\n  * \n  */\n off(eventType: 'paste:after', listener: () => void): void;\n /**\n  * DOM\n  * @param node \n  */\n off(eventType: 'copy', listener: (root: NodeInterface) => void): void;\n /**\n  * DOM\n  * @param eventType\n  * @param ops\n  */\n off(eventType: 'ops', listener: (ops: Op[]) => void): void;\n /**\n  * \n  * @param eventType \n  * @param args \n  */\n trigger(eventType: string, ...args: any): any;\n /**\n  * ctrl+afalse\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:all', event: KeyboardEvent): boolean | void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n trigger(eventType: 'card:minimize', card: CardInterface): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n trigger(eventType: 'card:maximize', card: CardInterface): void;\n /**\n  * DOM XML \n  * @param root DOM\n  */\n trigger(eventType: 'parse:value-before', root: NodeInterface): void;\n /**\n  * DOM XMLfalse\n  * @param node \n  * @param attributes \n  * @param styles \n  * @param value xml\n  */\n trigger(\n  eventType: 'parse:value',\n  node: NodeInterface,\n  attributes: { [key: string]: string },\n  styles: { [key: string]: string },\n  value: Array<string>,\n ): boolean | void;\n /**\n  * DOM XMLxml\n  * @param value xml\n  */\n trigger(eventType: 'parse:value-after', value: Array<string>): void;\n /**\n  * HTML\n  * @param root \n  */\n trigger(eventType: 'parse:html-before', root: NodeInterface): void;\n /**\n  * HTML\n  * @param root \n  */\n trigger(eventType: 'parse:html', root: NodeInterface): void;\n /**\n  * HTML\n  * @param root \n  */\n trigger(eventType: 'parse:html-after', root: NodeInterface): void;\n /**\n  * false\n  * @param data \n  * @param source \n  */\n trigger(\n  eventType: 'paste:event',\n  data: ClipboardData & { isPasteText: boolean },\n  source: string,\n ): boolean | void;\n /**\n  * \n  * @param schema \n  */\n trigger(eventType: 'paste:schema', schema: SchemaInterface): void;\n /**\n  * \n  * @param root DOM\n  */\n trigger(eventType: 'paste:origin', root: NodeInterface): void;\n /**\n  * \n  * @param node \n  */\n trigger(eventType: 'paste:each', root: NodeInterface): void;\n /**\n  * \n  * @param node \n  */\n trigger(eventType: 'paste:each-after', root: NodeInterface): void;\n /**\n  * DOM\n  * @param fragment \n  */\n trigger(eventType: 'paste:before', fragment: DocumentFragment): void;\n /**\n  * \n  * @param range \n  */\n trigger(eventType: 'paste:insert', range: RangeInterface): void;\n /**\n  * \n  */\n trigger(eventType: 'paste:after'): void;\n /**\n  * DOM\n  * @param node \n  */\n trigger(eventType: 'copy', root: NodeInterface): void;\n /**\n  * DOM\n  * @param eventType\n  * @param ops\n  */\n trigger(eventType: 'ops', ops: Op[]): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:enter',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:backspace',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * Tabfalse\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:tab',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * Shift-Tabfalse\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:shift-tab',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * @ false\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:at',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:space',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * Toolbarfalse\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:slash',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:left',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:right',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:up',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:down',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keyup:enter',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keyup:backspace',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * Tabfalse\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keyup:tab',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keyup:space',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(eventType: 'select', listener: () => void, rewrite?: boolean): void;\n /**\n  * \n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'change',\n  listener: (value: string, trigger: 'remote' | 'local' | 'both') => void,\n  rewrite?: boolean,\n ): void;\n /**\n  *  change change  change\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'realtimeChange',\n  listener: (trigger: 'remote' | 'local') => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(\n  eventType: 'beforeSetValue',\n  listener: (value: string) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'afterSetValue',\n  listener: () => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(eventType: 'focus', listener: () => void, rewrite?: boolean): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(eventType: 'blur', listener: () => void, rewrite?: boolean): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(\n  eventType: 'readonly',\n  listener: (readonly: boolean) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(\n  eventType: 'beforeCommandExecute',\n  listener: (name: string, ...args: any) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(\n  eventType: 'afterCommandExecute',\n  listener: (name: string, ...args: any) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param files \n  */\n on(\n  eventType: 'drop:files',\n  listener: (files: Array<File>) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'undo',\n  listener: () => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'redo',\n  listener: () => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:enter',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:backspace',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * Tabfalse\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:tab',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * Shift-Tabfalse\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:shift-tab',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * @ false\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:at',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:space',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * Toolbarfalse\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:slash',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:left',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:right',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:up',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:down',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keyup:enter',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keyup:backspace',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * Tabfalse\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keyup:tab',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keyup:space',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener\n  */\n off(eventType: 'select', listener: () => void): void;\n /**\n  * \n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'change',\n  listener: (value: string, trigger: 'remote' | 'local' | 'both') => void,\n ): void;\n /**\n  *  change change  change\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n off(\n  eventType: 'realtimeChange',\n  listener: (trigger: 'remote' | 'local') => void,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n off(eventType: 'beforeSetValue', listener: (value: string) => void): void;\n /**\n  * \n  * @param eventType\n  * @param listener\n  */\n off(eventType: 'afterSetValue', listener: () => void): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n off(eventType: 'focus', listener: () => void): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n off(eventType: 'blur', listener: () => void): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n off(eventType: 'readonly', listener: (readonly: boolean) => void): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n off(\n  eventType: 'beforeCommandExecute',\n  listener: (name: string, ...args: any) => void,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n off(\n  eventType: 'afterCommandExecute',\n  listener: (name: string, ...args: any) => void,\n ): void;\n /**\n  * \n  * @param files \n  */\n off(eventType: 'drop:files', listener: (files: Array<File>) => void): void;\n /**\n  * \n  * @param eventType\n  * @param listener\n  */\n off(eventType: 'undo', listener: () => boolean | void): void;\n /**\n  * \n  * @param eventType\n  * @param listener\n  */\n off(eventType: 'redo', listener: () => boolean | void): void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:enter', event: KeyboardEvent): boolean | void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n trigger(\n  eventType: 'keydown:backspace',\n  event: KeyboardEvent,\n ): boolean | void;\n /**\n  * Tabfalse\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:tab', event: KeyboardEvent): boolean | void;\n /**\n  * Shift-Tabfalse\n  * @param eventType\n  * @param listener\n  */\n trigger(\n  eventType: 'keydown:shift-tab',\n  event: KeyboardEvent,\n ): boolean | void;\n /**\n  * @ false\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:at', event: KeyboardEvent): boolean | void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:space', event: KeyboardEvent): boolean | void;\n /**\n  * Toolbarfalse\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:slash', event: KeyboardEvent): boolean | void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:left', event: KeyboardEvent): boolean | void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:right', event: KeyboardEvent): boolean | void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:up', event: KeyboardEvent): boolean | void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:down', event: KeyboardEvent): boolean | void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keyup:enter', event: KeyboardEvent): boolean | void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keyup:backspace', event: KeyboardEvent): boolean | void;\n /**\n  * Tabfalse\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keyup:tab', event: KeyboardEvent): boolean | void;\n /**\n  * false\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keyup:space', event: KeyboardEvent): boolean | void;\n /**\n  * \n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'select'): void;\n /**\n  * \n  * @param eventType\n  * @param listener\n  */\n trigger(\n  eventType: 'change',\n  value: string,\n  trigger: 'remote' | 'local' | 'both',\n ): void;\n /**\n  *  change change  change\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n trigger(\n  eventType: 'realtimeChange',\n  trigger: 'remote' | 'local' | 'both',\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n trigger(eventType: 'beforeSetValue', value: string): void;\n /**\n  * \n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'afterSetValue'): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n trigger(eventType: 'focus'): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n trigger(eventType: 'blur'): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n trigger(eventType: 'readonly', readonly: boolean): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n trigger(\n  eventType: 'beforeCommandExecute',\n  name: string,\n  ...args: any\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener name:args:\n  */\n trigger(eventType: 'afterCommandExecute', name: string, ...args: any): void;\n /**\n  * \n  * @param files \n  */\n trigger(eventType: 'drop:files', files: Array<File>): void;\n /**\n  * \n  * @param eventType\n  */\n trigger(eventType: 'undo'): void;\n /**\n  * \n  * @param eventType\n  */\n trigger(eventType: 'redo'): void;\n /**\n  * \n  */\n destroy(): void;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n726\n727\n728\n729\n730\n731\n732\n733\n734\n735\n736\n737\n738\n739\n740\n741\n742\n743\n744\n745\n746\n747\n748\n749\n750\n751\n752\n753\n754\n755\n756\n757\n758\n759\n760\n761\n762\n763\n764\n765\n766\n767\n768\n769\n770\n771\n772\n773\n774\n775\n776\n777\n778\n779\n780\n781\n782\n783\n784\n785\n786\n787\n788\n789\n790\n791\n792\n793\n794\n795\n796\n797\n798\n799\n800\n801\n802\n803\n804\n805\n806\n807\n808\n809\n810\n811\n812\n813\n814\n815\n816\n817\n818\n819\n820\n821\n822\n823\n824\n825\n826\n827\n828\n829\n830\n831\n832\n833\n834\n835\n836\n837\n838\n839\n840\n841\n842\n843\n844\n845\n846\n847\n848\n849\n850\n851\n852\n853\n854\n855\n856\n857\n858\n859\n860\n861\n862\n863\n864\n865\n866\n867\n868\n869\n870\n871\n872\n873\n874\n875\n876\n877\n878\n879\n880\n881\n882\n883\n884\n885\n886\n887\n888\n889\n890\n891\n892\n893\n894\n895\n896\n897\n898\n899\n900\n901\n902\n903\n904\n905\n906\n907\n908\n909\n910\n911\n912\n913\n914\n915\n916\n917\n918\n919\n920\n921\n922\n923\n924\n925\n926\n927\n928\n929\n930\n931\n932\n933\n934\n935\n936\n937\n938\n939\n940\n941\n942\n943\n944\n945\n946\n947\n948\n949\n950\n951\n952\n953\n954\n955\n956\n957\n958\n959\n960\n961\n962\n963\n964\n965\n966\n967\n968\n969\n970\n971\n972\n973\n974\n975\n976\n977\n978\n979\n980\n981\n982\n983\n984\n985\n986\n987\n988\n989\n990\n991\n992\n993\n994\n995\n996\n997\n998\n999\n1000\n1001\n1002\n1003\n1004\n1005\n1006\n1007\n1008\n1009\n1010\n1011\n1012\n1013\n1014\n1015\n1016\n1017\n1018\n1019\n1020\n1021\n1022\n1023\n1024\n1025\n1026\n1027\n1028\n1029\n1030\n1031\n1032\n1033\n1034\n1035\n1036\n1037\n1038\n1039\n1040\n1041\n1042\n1043\n1044\n1045\n1046\n1047\n1048\n1049\n1050\n1051\n1052\n1053\n1054\n1055\n1056\n1057\n1058\n1059\n1060\n1061\n1062\n1063\n1064\n1065\n1066\n1067\n1068\n1069\n1070\n1071\n1072\n1073\n1074\n1075\n1076\n1077\n1078\n1079\n1080\n1081\n1082\n1083\n1084\n1085\n1086\n1087\n1088\n1089\n1090\n1091\n1092\n1093\n1094\n1095\n1096\n1097\n1098\n1099\n1100\n1101\n1102\n1103\n1104\n1105\n1106\n1107\n1108\n1109\n1110\n1111\n1112\n1113\n1114\n1115\n1116\n1117\n1118\n1119\n1120\n1121\n1122\n1123\n1124\n1125\n1126\n1127\n1128\n1129\n1130\n1131\n1132\n1133\n1134\n1135\n1136\n1137\n1138\n1139\n1140\n1141\n1142\n1143\n1144\n1145\n1146\n1147\n1148\n1149\n1150\n1151\n1152\n1153\n1154\n1155\n1156\n1157\n1158\n1159\n1160\n1161\n1162\n1163\n1164\n1165\n1166\n1167\n1168\n1169\n1170\n1171\n1172\n1173\n1174\n1175\n1176\n1177\n1178\n1179\n1180\n1181\n1182\n1183\n1184\n1185\n1186\n1187\n1188\n1189\n1190\n1191\n1192\n1193\n1194\n1195\n1196\n1197\n1198\n1199\n1200\n1201\n1202\n1203\n1204\n1205\n1206\n1207\n1208\n1209\n1210\n1211\n1212\n1213\n1214\n1215\n1216\n1217\n1218\n1219\n1220\n1221\n1222\n1223\n1224\n1225\n1226\n1227\n1228\n1229\n1230\n1231\n1232\n1233\n1234\n1235\n1236\n1237\n1238\n1239\n1240\n1241\n1242\n1243\n1244\n1245\n1246\n1247\n1248\n1249\n1250\n1251\n1252\n1253\n1254\n1255\n1256\n1257\n1258\n1259\n1260\n1261\n1262\n1263\n1264\n1265\n1266\n1267\n1268\n1269\n1270\n1271\n1272\n1273\n1274\n1275\n1276\n1277\n1278\n1279\n1280\n1281\n1282\n1283\n1284\n1285\n1286\n1287\n1288\n1289\n1290\n1291\n1292\n\n\n\n\n 1.  class \n\n\n\ninterface {new(args: Args): Class}\n\n\n1\n\n 2. Engine Core \n\n * options: \n * readonly\n * change\n * typing\n * ot\n * history\n * hotkey\n * event: \n * destroy\n * value/html: ",normalizedContent:"# engine basic\n\n\n# \n\n\n\n * \n * engine \n   * engineoptions\n   * engine\n\n\n\n\n# engine \n\n\n# engineoptions\n\n\nexport type engineoptions = {\n /**\n  *  zh-cn\n  */\n lang?: string;\n /**\n  * \n  */\n locale?: { [key: string]: {} };\n /**\n  * \n  */\n classname?: string;\n /**\n  * tab \n  */\n tabindex?: number;\n /**\n  * \n  */\n root?: node;\n /**\n  *  overflow  overflow-y  auto  scroll \n  */\n scrollnode?: node | (() => node | null);\n /**\n  * \n  */\n plugins?: array<pluginentry>;\n /**\n  * \n  */\n cards?: array<cardentry>;\n /**\n  * \n  */\n config?: { [k: string]: pluginoptions };\n /**\n  * \n  */\n placeholder?: string;\n /**\n  * \n  */\n readonly?: boolean;\n /**\n  *  lazyrender  true\n  */\n lazyrender?: boolean;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# engine\n\nexport interface engine {\n /**\n  * \n  */\n new (selector: selector, options?: engineoptions): engineinterface;\n}\n\nexport interface engineinterface extends editorinterface {\n /**\n  * \n  */\n options: engineoptions;\n /**\n  * \n  */\n readonly: boolean;\n /**\n  * \n  */\n change: changeinterface;\n /**\n  * \n  */\n typing: typinginterface;\n /**\n  * \n  */\n ot: otinterface;\n\n /**\n  * \n  */\n history: historyinterface;\n /**\n  * \n  */\n hotkey: hotkeyinterface;\n /**\n  * \n  */\n focus(tostart?: boolean): void;\n /**\n  * \n  */\n blur(): void;\n /**\n  * \n  */\n isfocus(): boolean;\n /**\n  * \n  */\n isempty(): boolean;\n /**\n  * \n  * @param node \n  */\n setscrollnode(node: htmlelement): void;\n /**\n  * \n  * @param ignorecursor \n  */\n getvalue(ignorecursor?: boolean): string;\n /**\n  * \n  * \n  * @param ignorecursor \n  * @param callback  false  number \n  */\n getvalueasync(\n  ignorecursor?: boolean,\n  callback?: (\n   name: string,\n   card?: cardinterface,\n   ...args: any\n  ) => boolean | number | void,\n ): promise<string>;\n /**\n  * html\n  */\n gethtml(): string;\n /**\n  * \n  * @param value \n  * @param callback \n  */\n setvalue(\n  value: string,\n  callback?: (count: number) => void,\n ): engineinterface;\n /**\n  * html\n  * @param html html\n  * @param callback \n  */\n sethtml(html: string, callback?: (count: number) => void): engineinterface;\n /**\n  * json\n  * @param callback \n  */\n setjsonvalue(\n  value: array<any>,\n  callback?: (count: number) => void,\n ): engineinterface;\n /**\n  * json\n  */\n getjsonvalue(): string | undefined | (string | {})[];\n /**\n  *  placeholder\n  */\n showplaceholder(): void;\n /**\n  *  placeholder\n  */\n hideplaceholder(): void;\n /**\n  * \n  * @param eventtype \n  * @param listener \n  * @param rewrite \n  */\n on(eventtype: string, listener: eventlistener, rewrite?: boolean): void;\n /**\n  * ctrl+afalse\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:all',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(\n  eventtype: 'card:minimize',\n  listener: (card: cardinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(\n  eventtype: 'card:maximize',\n  listener: (card: cardinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * dom xml \n  * @param root dom\n  */\n on(\n  eventtype: 'parse:value-before',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * dom xmlfalse\n  * @param node \n  * @param attributes \n  * @param styles \n  * @param value xml\n  */\n on(\n  eventtype: 'parse:value',\n  listener: (\n   node: nodeinterface,\n   attributes: { [key: string]: string },\n   styles: { [key: string]: string },\n   value: array<string>,\n  ) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * dom xmlxml\n  * @param value xml\n  */\n on(\n  eventtype: 'parse:value-after',\n  listener: (value: array<string>) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * html\n  * @param root \n  */\n on(\n  eventtype: 'parse:html-before',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * html\n  * @param root \n  */\n on(\n  eventtype: 'parse:html',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * html\n  * @param root \n  */\n on(\n  eventtype: 'parse:html-after',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param data \n  * @param source \n  */\n on(\n  eventtype: 'paste:event',\n  listener: (\n   data: clipboarddata & { ispastetext: boolean },\n   source: string,\n  ) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param schema \n  */\n on(\n  eventtype: 'paste:schema',\n  listener: (schema: schemainterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param root dom\n  */\n on(\n  eventtype: 'paste:origin',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param node \n  */\n on(\n  eventtype: 'paste:each',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param node \n  */\n on(\n  eventtype: 'paste:each-after',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * dom\n  * @param fragment \n  */\n on(\n  eventtype: 'paste:before',\n  listener: (fragment: documentfragment) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param range \n  */\n on(\n  eventtype: 'paste:insert',\n  listener: (range: rangeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  */\n on(eventtype: 'paste:after', listener: () => void, rewrite?: boolean): void;\n /**\n  * dom\n  * @param node \n  */\n on(\n  eventtype: 'copy',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * dom\n  * @param eventtype\n  * @param ops\n  */\n on(\n  eventtype: 'ops',\n  listener: (ops: op[]) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventtype \n  * @param listener \n  */\n off(eventtype: string, listener: eventlistener): void;\n /**\n  * ctrl+afalse\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:all',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n off(\n  eventtype: 'card:minimize',\n  listener: (card: cardinterface) => void,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n off(\n  eventtype: 'card:maximize',\n  listener: (card: cardinterface) => void,\n ): void;\n /**\n  * dom xml \n  * @param root dom\n  */\n off(\n  eventtype: 'parse:value-before',\n  listener: (root: nodeinterface) => void,\n ): void;\n /**\n  * dom xmlfalse\n  * @param node \n  * @param attributes \n  * @param styles \n  * @param value xml\n  */\n off(\n  eventtype: 'parse:value',\n  listener: (\n   node: nodeinterface,\n   attributes: { [key: string]: string },\n   styles: { [key: string]: string },\n   value: array<string>,\n  ) => boolean | void,\n ): void;\n /**\n  * dom xmlxml\n  * @param value xml\n  */\n off(\n  eventtype: 'parse:value-after',\n  listener: (value: array<string>) => void,\n ): void;\n /**\n  * html\n  * @param root \n  */\n off(\n  eventtype: 'parse:html-before',\n  listener: (root: nodeinterface) => void,\n ): void;\n /**\n  * html\n  * @param root \n  */\n off(eventtype: 'parse:html', listener: (root: nodeinterface) => void): void;\n /**\n  * html\n  * @param root \n  */\n off(\n  eventtype: 'parse:html-after',\n  listener: (root: nodeinterface) => void,\n ): void;\n /**\n  * false\n  * @param data \n  * @param source \n  */\n off(\n  eventtype: 'paste:event',\n  listener: (\n   data: clipboarddata & { ispastetext: boolean },\n   source: string,\n  ) => boolean | void,\n ): void;\n /**\n  * \n  * @param schema \n  */\n off(\n  eventtype: 'paste:schema',\n  listener: (schema: schemainterface) => void,\n ): void;\n /**\n  * \n  * @param root dom\n  */\n off(\n  eventtype: 'paste:origin',\n  listener: (root: nodeinterface) => void,\n ): void;\n /**\n  * \n  * @param node \n  */\n off(eventtype: 'paste:each', listener: (root: nodeinterface) => void): void;\n /**\n  * \n  * @param node \n  */\n off(\n  eventtype: 'paste:each-after',\n  listener: (root: nodeinterface) => void,\n ): void;\n /**\n  * dom\n  * @param fragment \n  */\n off(\n  eventtype: 'paste:before',\n  listener: (fragment: documentfragment) => void,\n ): void;\n /**\n  * \n  * @param range \n  */\n off(\n  eventtype: 'paste:insert',\n  listener: (range: rangeinterface) => void,\n ): void;\n /**\n  * \n  */\n off(eventtype: 'paste:after', listener: () => void): void;\n /**\n  * dom\n  * @param node \n  */\n off(eventtype: 'copy', listener: (root: nodeinterface) => void): void;\n /**\n  * dom\n  * @param eventtype\n  * @param ops\n  */\n off(eventtype: 'ops', listener: (ops: op[]) => void): void;\n /**\n  * \n  * @param eventtype \n  * @param args \n  */\n trigger(eventtype: string, ...args: any): any;\n /**\n  * ctrl+afalse\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:all', event: keyboardevent): boolean | void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n trigger(eventtype: 'card:minimize', card: cardinterface): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n trigger(eventtype: 'card:maximize', card: cardinterface): void;\n /**\n  * dom xml \n  * @param root dom\n  */\n trigger(eventtype: 'parse:value-before', root: nodeinterface): void;\n /**\n  * dom xmlfalse\n  * @param node \n  * @param attributes \n  * @param styles \n  * @param value xml\n  */\n trigger(\n  eventtype: 'parse:value',\n  node: nodeinterface,\n  attributes: { [key: string]: string },\n  styles: { [key: string]: string },\n  value: array<string>,\n ): boolean | void;\n /**\n  * dom xmlxml\n  * @param value xml\n  */\n trigger(eventtype: 'parse:value-after', value: array<string>): void;\n /**\n  * html\n  * @param root \n  */\n trigger(eventtype: 'parse:html-before', root: nodeinterface): void;\n /**\n  * html\n  * @param root \n  */\n trigger(eventtype: 'parse:html', root: nodeinterface): void;\n /**\n  * html\n  * @param root \n  */\n trigger(eventtype: 'parse:html-after', root: nodeinterface): void;\n /**\n  * false\n  * @param data \n  * @param source \n  */\n trigger(\n  eventtype: 'paste:event',\n  data: clipboarddata & { ispastetext: boolean },\n  source: string,\n ): boolean | void;\n /**\n  * \n  * @param schema \n  */\n trigger(eventtype: 'paste:schema', schema: schemainterface): void;\n /**\n  * \n  * @param root dom\n  */\n trigger(eventtype: 'paste:origin', root: nodeinterface): void;\n /**\n  * \n  * @param node \n  */\n trigger(eventtype: 'paste:each', root: nodeinterface): void;\n /**\n  * \n  * @param node \n  */\n trigger(eventtype: 'paste:each-after', root: nodeinterface): void;\n /**\n  * dom\n  * @param fragment \n  */\n trigger(eventtype: 'paste:before', fragment: documentfragment): void;\n /**\n  * \n  * @param range \n  */\n trigger(eventtype: 'paste:insert', range: rangeinterface): void;\n /**\n  * \n  */\n trigger(eventtype: 'paste:after'): void;\n /**\n  * dom\n  * @param node \n  */\n trigger(eventtype: 'copy', root: nodeinterface): void;\n /**\n  * dom\n  * @param eventtype\n  * @param ops\n  */\n trigger(eventtype: 'ops', ops: op[]): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:enter',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:backspace',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * tabfalse\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:tab',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * shift-tabfalse\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:shift-tab',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * @ false\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:at',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:space',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * toolbarfalse\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:slash',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:left',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:right',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:up',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:down',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keyup:enter',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keyup:backspace',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * tabfalse\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keyup:tab',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keyup:space',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(eventtype: 'select', listener: () => void, rewrite?: boolean): void;\n /**\n  * \n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'change',\n  listener: (value: string, trigger: 'remote' | 'local' | 'both') => void,\n  rewrite?: boolean,\n ): void;\n /**\n  *  change change  change\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'realtimechange',\n  listener: (trigger: 'remote' | 'local') => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(\n  eventtype: 'beforesetvalue',\n  listener: (value: string) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'aftersetvalue',\n  listener: () => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(eventtype: 'focus', listener: () => void, rewrite?: boolean): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(eventtype: 'blur', listener: () => void, rewrite?: boolean): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(\n  eventtype: 'readonly',\n  listener: (readonly: boolean) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(\n  eventtype: 'beforecommandexecute',\n  listener: (name: string, ...args: any) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  * @param rewrite\n  */\n on(\n  eventtype: 'aftercommandexecute',\n  listener: (name: string, ...args: any) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param files \n  */\n on(\n  eventtype: 'drop:files',\n  listener: (files: array<file>) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'undo',\n  listener: () => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'redo',\n  listener: () => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:enter',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:backspace',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * tabfalse\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:tab',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * shift-tabfalse\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:shift-tab',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * @ false\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:at',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:space',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * toolbarfalse\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:slash',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:left',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:right',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:up',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:down',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keyup:enter',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keyup:backspace',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * tabfalse\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keyup:tab',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keyup:space',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener\n  */\n off(eventtype: 'select', listener: () => void): void;\n /**\n  * \n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'change',\n  listener: (value: string, trigger: 'remote' | 'local' | 'both') => void,\n ): void;\n /**\n  *  change change  change\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n off(\n  eventtype: 'realtimechange',\n  listener: (trigger: 'remote' | 'local') => void,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n off(eventtype: 'beforesetvalue', listener: (value: string) => void): void;\n /**\n  * \n  * @param eventtype\n  * @param listener\n  */\n off(eventtype: 'aftersetvalue', listener: () => void): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n off(eventtype: 'focus', listener: () => void): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n off(eventtype: 'blur', listener: () => void): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n off(eventtype: 'readonly', listener: (readonly: boolean) => void): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n off(\n  eventtype: 'beforecommandexecute',\n  listener: (name: string, ...args: any) => void,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n off(\n  eventtype: 'aftercommandexecute',\n  listener: (name: string, ...args: any) => void,\n ): void;\n /**\n  * \n  * @param files \n  */\n off(eventtype: 'drop:files', listener: (files: array<file>) => void): void;\n /**\n  * \n  * @param eventtype\n  * @param listener\n  */\n off(eventtype: 'undo', listener: () => boolean | void): void;\n /**\n  * \n  * @param eventtype\n  * @param listener\n  */\n off(eventtype: 'redo', listener: () => boolean | void): void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:enter', event: keyboardevent): boolean | void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n trigger(\n  eventtype: 'keydown:backspace',\n  event: keyboardevent,\n ): boolean | void;\n /**\n  * tabfalse\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:tab', event: keyboardevent): boolean | void;\n /**\n  * shift-tabfalse\n  * @param eventtype\n  * @param listener\n  */\n trigger(\n  eventtype: 'keydown:shift-tab',\n  event: keyboardevent,\n ): boolean | void;\n /**\n  * @ false\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:at', event: keyboardevent): boolean | void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:space', event: keyboardevent): boolean | void;\n /**\n  * toolbarfalse\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:slash', event: keyboardevent): boolean | void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:left', event: keyboardevent): boolean | void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:right', event: keyboardevent): boolean | void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:up', event: keyboardevent): boolean | void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:down', event: keyboardevent): boolean | void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keyup:enter', event: keyboardevent): boolean | void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keyup:backspace', event: keyboardevent): boolean | void;\n /**\n  * tabfalse\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keyup:tab', event: keyboardevent): boolean | void;\n /**\n  * false\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keyup:space', event: keyboardevent): boolean | void;\n /**\n  * \n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'select'): void;\n /**\n  * \n  * @param eventtype\n  * @param listener\n  */\n trigger(\n  eventtype: 'change',\n  value: string,\n  trigger: 'remote' | 'local' | 'both',\n ): void;\n /**\n  *  change change  change\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n trigger(\n  eventtype: 'realtimechange',\n  trigger: 'remote' | 'local' | 'both',\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n trigger(eventtype: 'beforesetvalue', value: string): void;\n /**\n  * \n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'aftersetvalue'): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n trigger(eventtype: 'focus'): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n trigger(eventtype: 'blur'): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n trigger(eventtype: 'readonly', readonly: boolean): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n trigger(\n  eventtype: 'beforecommandexecute',\n  name: string,\n  ...args: any\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener name:args:\n  */\n trigger(eventtype: 'aftercommandexecute', name: string, ...args: any): void;\n /**\n  * \n  * @param files \n  */\n trigger(eventtype: 'drop:files', files: array<file>): void;\n /**\n  * \n  * @param eventtype\n  */\n trigger(eventtype: 'undo'): void;\n /**\n  * \n  * @param eventtype\n  */\n trigger(eventtype: 'redo'): void;\n /**\n  * \n  */\n destroy(): void;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n726\n727\n728\n729\n730\n731\n732\n733\n734\n735\n736\n737\n738\n739\n740\n741\n742\n743\n744\n745\n746\n747\n748\n749\n750\n751\n752\n753\n754\n755\n756\n757\n758\n759\n760\n761\n762\n763\n764\n765\n766\n767\n768\n769\n770\n771\n772\n773\n774\n775\n776\n777\n778\n779\n780\n781\n782\n783\n784\n785\n786\n787\n788\n789\n790\n791\n792\n793\n794\n795\n796\n797\n798\n799\n800\n801\n802\n803\n804\n805\n806\n807\n808\n809\n810\n811\n812\n813\n814\n815\n816\n817\n818\n819\n820\n821\n822\n823\n824\n825\n826\n827\n828\n829\n830\n831\n832\n833\n834\n835\n836\n837\n838\n839\n840\n841\n842\n843\n844\n845\n846\n847\n848\n849\n850\n851\n852\n853\n854\n855\n856\n857\n858\n859\n860\n861\n862\n863\n864\n865\n866\n867\n868\n869\n870\n871\n872\n873\n874\n875\n876\n877\n878\n879\n880\n881\n882\n883\n884\n885\n886\n887\n888\n889\n890\n891\n892\n893\n894\n895\n896\n897\n898\n899\n900\n901\n902\n903\n904\n905\n906\n907\n908\n909\n910\n911\n912\n913\n914\n915\n916\n917\n918\n919\n920\n921\n922\n923\n924\n925\n926\n927\n928\n929\n930\n931\n932\n933\n934\n935\n936\n937\n938\n939\n940\n941\n942\n943\n944\n945\n946\n947\n948\n949\n950\n951\n952\n953\n954\n955\n956\n957\n958\n959\n960\n961\n962\n963\n964\n965\n966\n967\n968\n969\n970\n971\n972\n973\n974\n975\n976\n977\n978\n979\n980\n981\n982\n983\n984\n985\n986\n987\n988\n989\n990\n991\n992\n993\n994\n995\n996\n997\n998\n999\n1000\n1001\n1002\n1003\n1004\n1005\n1006\n1007\n1008\n1009\n1010\n1011\n1012\n1013\n1014\n1015\n1016\n1017\n1018\n1019\n1020\n1021\n1022\n1023\n1024\n1025\n1026\n1027\n1028\n1029\n1030\n1031\n1032\n1033\n1034\n1035\n1036\n1037\n1038\n1039\n1040\n1041\n1042\n1043\n1044\n1045\n1046\n1047\n1048\n1049\n1050\n1051\n1052\n1053\n1054\n1055\n1056\n1057\n1058\n1059\n1060\n1061\n1062\n1063\n1064\n1065\n1066\n1067\n1068\n1069\n1070\n1071\n1072\n1073\n1074\n1075\n1076\n1077\n1078\n1079\n1080\n1081\n1082\n1083\n1084\n1085\n1086\n1087\n1088\n1089\n1090\n1091\n1092\n1093\n1094\n1095\n1096\n1097\n1098\n1099\n1100\n1101\n1102\n1103\n1104\n1105\n1106\n1107\n1108\n1109\n1110\n1111\n1112\n1113\n1114\n1115\n1116\n1117\n1118\n1119\n1120\n1121\n1122\n1123\n1124\n1125\n1126\n1127\n1128\n1129\n1130\n1131\n1132\n1133\n1134\n1135\n1136\n1137\n1138\n1139\n1140\n1141\n1142\n1143\n1144\n1145\n1146\n1147\n1148\n1149\n1150\n1151\n1152\n1153\n1154\n1155\n1156\n1157\n1158\n1159\n1160\n1161\n1162\n1163\n1164\n1165\n1166\n1167\n1168\n1169\n1170\n1171\n1172\n1173\n1174\n1175\n1176\n1177\n1178\n1179\n1180\n1181\n1182\n1183\n1184\n1185\n1186\n1187\n1188\n1189\n1190\n1191\n1192\n1193\n1194\n1195\n1196\n1197\n1198\n1199\n1200\n1201\n1202\n1203\n1204\n1205\n1206\n1207\n1208\n1209\n1210\n1211\n1212\n1213\n1214\n1215\n1216\n1217\n1218\n1219\n1220\n1221\n1222\n1223\n1224\n1225\n1226\n1227\n1228\n1229\n1230\n1231\n1232\n1233\n1234\n1235\n1236\n1237\n1238\n1239\n1240\n1241\n1242\n1243\n1244\n1245\n1246\n1247\n1248\n1249\n1250\n1251\n1252\n1253\n1254\n1255\n1256\n1257\n1258\n1259\n1260\n1261\n1262\n1263\n1264\n1265\n1266\n1267\n1268\n1269\n1270\n1271\n1272\n1273\n1274\n1275\n1276\n1277\n1278\n1279\n1280\n1281\n1282\n1283\n1284\n1285\n1286\n1287\n1288\n1289\n1290\n1291\n1292\n\n\n\n\n 1.  class \n\n\n\ninterface {new(args: args): class}\n\n\n1\n\n 2. engine core \n\n * options: \n * readonly\n * change\n * typing\n * ot\n * history\n * hotkey\n * event: \n * destroy\n * value/html: ",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"engine",frontmatter:{title:"engine",date:"2022-04-14T22:02:20.000Z",permalink:"/pages/518dfe/",categories:["am-editor","engine"],tags:[null]},regularPath:"/30.web/70.am-editor/10.engine/20.engine.html",relativePath:"30.web/70.am-editor/10.engine/20.engine.md",key:"v-5b6dcd7d",path:"/pages/518dfe/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:18},{level:2,title:"Engine",slug:"engine",normalizedTitle:"engine",charIndex:2}],readingTime:{text:"6 min read",minutes:5.045,time:302700,words:1009},headersStr:" Engine",content:"# Engine Core\n\n\n# \n\n\n\n * \n * Engine\n\n\n\n\n# Engine\n\nclass Engine implements EngineInterface {\n private _readonly: boolean = false;\n private _container: ContainerInterface;\n readonly kind = 'engine';\n  // \n options: EngineOptions = {\n  lang: 'zh-CN',\n  locale: {},\n  plugins: [],\n  cards: [],\n  config: {},\n };\n language: LanguageInterface;\n root: NodeInterface;\n change: ChangeInterface;\n card: CardModelInterface;\n plugin: PluginModelInterface;\n node: NodeModelInterface;\n nodeId: NodeIdInterface;\n list: ListModelInterface;\n mark: MarkModelInterface;\n inline: InlineModelInterface;\n block: BlockModelInterface;\n event: EventInterface;\n typing: TypingInterface;\n ot: OTInterface;\n schema: SchemaInterface;\n conversion: ConversionInterface;\n history: HistoryInterface;\n command: CommandInterface;\n hotkey: HotkeyInterface;\n clipboard: ClipboardInterface;\n request: RequestInterface;\n #_scrollNode: NodeInterface | null = null;\n\n get container(): NodeInterface {\n  return this._container.getNode();\n }\n\n get readonly(): boolean {\n  return this._readonly;\n }\n\n get scrollNode(): NodeInterface | null {\n  if (this.#_scrollNode) return this.#_scrollNode;\n    //  _scrollNode\n  const { scrollNode } = this.options;\n  let sn = scrollNode\n   ? typeof scrollNode === 'function'\n    ? scrollNode()\n    : scrollNode\n   : null;\n  //  overflow  overflow-y  auto  scroll \n  const targetValues = ['auto', 'scroll'];\n  let parent = this.container.parent();\n    //  scrollNode\n  while (parent && parent.length > 0 && parent.name !== 'body') {\n   if (\n    targetValues.includes(parent.css('overflow')) ||\n    targetValues.includes(parent.css('overflow-y'))\n   ) {\n    sn = parent.get<HTMLElement>();\n    break;\n   } else {\n    parent = parent.parent();\n   }\n  }\n    //  documentElement\n  if (sn === null) sn = document.documentElement;\n  this.#_scrollNode = sn ? $(sn) : null;\n  return this.#_scrollNode;\n }\n\n set readonly(readonly: boolean) {\n  if (this.readonly === readonly) return;\n    //  readonly_container\n  if (readonly) {\n   this.hotkey.disable();\n   this._container.setReadonly(true);\n  } else {\n   this.hotkey.enable();\n   this._container.setReadonly(false);\n  }\n  this._readonly = readonly;\n    //  card\n  this.card.reRender();\n  // readonly\n  this.trigger('readonly', readonly);\n }\n\n constructor(selector: Selector, options?: EngineOptions) {\n    // \n  this.options = { ...this.options, ...options };\n  // \n  this.language = new Language(\n   this.options.lang || 'zh-CN',\n   merge(language, options?.locale),\n  );\n  // \n  this.event = new Event();\n  // \n  this.command = new Command(this);\n  // \n  this.schema = new Schema();\n    // \n  this.schema.add(schemaDefaultData);\n  // \n  this.conversion = new Conversion(this);\n    // \n  conversionDefault.forEach((rule) =>\n   this.conversion.add(rule.from, rule.to),\n  );\n  // \n  this.history = new History(this);\n  // \n  this.card = new CardModel(this, this.options.lazyRender);\n  // \n  this.clipboard = new Clipboard(this);\n  // http\n  this.request = new Request();\n  // \n  this.plugin = new Plugin(this);\n  // \n  this.node = new NodeModel(this);\n  this.nodeId = new NodeId(this);\n  // \n  this.list = new List(this);\n  // \n  this.mark = new Mark(this);\n  // \n  this.inline = new Inline(this);\n  // \n  this.block = new Block(this);\n  // \n  this._container = new Container(selector, {\n   engine: this,\n   lang: this.options.lang,\n   className: this.options.className,\n   tabIndex: this.options.tabIndex,\n   placeholder: this.options.placeholder,\n  });\n  // \n  this.root = $(\n   this.options.root || this.container.parent() || getDocument().body,\n  );\n    //  root position:relative\n  const rootPosition = this.root.css('position');\n  if (!rootPosition || rootPosition === 'static')\n   this.root.css('position', 'relative');\n  // \n  this._container.init();\n  // \n  this.change = new Change(this, {\n   onChange: (value, trigger) =>\n    this.trigger('change', value, trigger),\n   onSelect: () => this.trigger('select'),\n   onRealtimeChange: (trigger) => {\n    if (this.isEmpty()) {\n     this._container.showPlaceholder();\n    } else {\n     this._container.hidePlaceholder();\n    }\n    this.trigger('realtimeChange', trigger);\n   },\n   onSetValue: () => this.trigger('afterSetValue'),\n  });\n  this.change.init();\n  // \n  this.typing = new Typing(this);\n  // \n  this._readonly =\n   this.options.readonly === undefined ? false : this.options.readonly;\n  this._container.setReadonly(this._readonly);\n  // \n  this.mark.init();\n  this.inline.init();\n  this.block.init();\n  this.list.init();\n  // \n  this.hotkey = new Hotkey(this);\n  this.card.init(this.options.cards || []);\n  this.plugin.init(this.options.plugins || [], this.options.config || {});\n  this.nodeId.init();\n  // \n  this.ot = new OT(this);\n\n  if (this.isEmpty()) {\n   this._container.showPlaceholder();\n  }\n  this.ot.initLocal();\n }\n\n setScrollNode(node?: HTMLElement) {\n  this.#_scrollNode = node ? $(node) : null;\n }\n\n isFocus() {\n  return this._container.isFocus();\n }\n\n isEmpty() {\n  return this.change.isEmpty();\n }\n\n focus(toStart?: boolean) {\n  this.change.range.focus(toStart);\n }\n\n blur() {\n  this.change.range.blur();\n }\n\n on(eventType: string, listener: EventListener, rewrite?: boolean) {\n  this.event.on(eventType, listener, rewrite);\n  return this;\n }\n\n off(eventType: string, listener: EventListener) {\n  this.event.off(eventType, listener);\n  return this;\n }\n\n trigger(eventType: string, ...args: any) {\n  return this.event.trigger(eventType, ...args);\n }\n\n getValue(ignoreCursor: boolean = false) {\n  const value = this.change.getValue({});\n  return ignoreCursor ? Selection.removeTags(value) : value;\n }\n\n async getValueAsync(\n  ignoreCursor: boolean = false,\n  callback?: (\n   name: string,\n   card?: CardInterface,\n   ...args: any\n  ) => boolean | number | void,\n ): Promise<string> {\n  return new Promise(async (resolve, reject) => {\n      // \n   const pluginNames = Object.keys(this.plugin.components);\n   for (let i = 0; i < pluginNames.length; i++) {\n    const plugin = this.plugin.components[pluginNames[i]];\n    const result = await new Promise((resolve) => {\n     if (plugin.waiting) {\n      plugin\n       .waiting(callback)\n       .then(() => resolve(true))\n       .catch(resolve);\n     } else resolve(true);\n    });\n    if (typeof result === 'object') {\n     reject(result);\n     return;\n    }\n   }\n   resolve(this.getValue(ignoreCursor));\n  });\n }\n\n getHtml(): string {\n    //  container \n  const node = $(this.container[0].cloneNode(true));\n    // \n  node.removeAttributes('contenteditable');\n  node.removeAttributes('tabindex');\n  node.removeAttributes('autocorrect');\n  node.removeAttributes('autocomplete');\n  node.removeAttributes('spellcheck');\n  node.removeAttributes('data-gramm');\n  node.removeAttributes('role');\n  return new Parser(node, this).toHTML();\n }\n\n setValue(value: string, callback?: (count: number) => void) {\n  value = this.trigger('beforeSetValue', value) || value;\n  this.change.setValue(value, undefined, callback);\n  this.normalize();\n    //  data-id\n  this.nodeId.generateAll(this.container);\n    //  this \n  return this;\n }\n\n setHtml(html: string, callback?: (count: number) => void) {\n  this.change.setHtml(html, (count) => {\n   this.container.allChildren(true).forEach((child) => {\n    if (this.node.isInline(child)) {\n     this.inline.repairCursor(child);\n    } else if (this.node.isMark(child)) {\n     this.mark.repairCursor(child);\n    }\n    if (callback) callback(count);\n   });\n  });\n  this.nodeId.generateAll(this.container);\n  return this;\n }\n\n setJsonValue(value: Array<any>, callback?: (count: number) => void) {\n  const dom = $(toDOM(value));\n    //  container \n  const attributes = dom.get<Element>()?.attributes;\n  for (let i = 0; attributes && i < attributes.length; i++) {\n   const { nodeName, nodeValue } = attributes.item(i) || {};\n   if (\n    /^data-selection-/.test(nodeName || '') &&\n    nodeValue !== 'null'\n   ) {\n    this.container.attributes(nodeName, nodeValue!);\n   }\n  }\n    //  container html\n  const html = this.node.html(dom);\n  this.change.setValue(html, undefined, callback);\n    // \n  this.normalize();\n    //  data-id\n  this.nodeId.generateAll(this.container);\n  return this;\n }\n\n getJsonValue() {\n  return toJSON0(this.container);\n }\n\n private normalize() {\n  let block = $('<p />');\n  // \n  let childNodes = this.container.children();\n  childNodes.each((_, index) => {\n   const node = childNodes.eq(index);\n   if (!node) return;\n   if (this.node.isBlock(node)) {\n    if (block.get<HTMLElement>()!.childNodes.length > 0) {\n     node.before(block);\n    }\n    block = $('<p />');\n   } else if (!node.isCursor()) {\n    block.append(node);\n   }\n  });\n\n  if (block.get<HTMLElement>()!.childNodes.length > 0) {\n   this.container.append(block);\n  }\n  // \n  childNodes = this.container.children();\n  childNodes.each((_, index) => {\n   const node = childNodes.eq(index);\n   if (!node) return;\n   this.node.removeMinusStyle(node, 'text-indent');\n   if (this.node.isRootBlock(node)) {\n    const childrenLength =\n     node.get<HTMLElement>()!.childNodes.length;\n    if (childrenLength === 0) {\n     node.append($('<br />'));\n    } else {\n     const child = node.first();\n     if (\n      childrenLength === 1 &&\n      child?.name === 'span' &&\n      [CURSOR, ANCHOR, FOCUS].indexOf(\n       child.attributes(DATA_ELEMENT),\n      ) >= 0\n     ) {\n      node.prepend($('<br />'));\n     }\n    }\n   }\n  });\n }\n\n messageSuccess(message: string) {\n  console.log(`success:${message}`);\n }\n\n messageError(error: string) {\n  console.log(`error:${error}`);\n }\n\n messageConfirm(message: string): Promise<boolean> {\n  console.log(`confirm:${message}`);\n  return Promise.reject(false);\n }\n\n showPlaceholder() {\n  this._container.showPlaceholder();\n }\n\n hidePlaceholder() {\n  this._container.hidePlaceholder();\n }\n\n destroy() {\n  this._container.destroy();\n  this.change.destroy();\n  this.hotkey.destroy();\n  this.card.destroy();\n  if (this.ot) {\n   this.ot.destroy();\n  }\n }\n}\n\nexport default Engine;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n",normalizedContent:"# engine core\n\n\n# \n\n\n\n * \n * engine\n\n\n\n\n# engine\n\nclass engine implements engineinterface {\n private _readonly: boolean = false;\n private _container: containerinterface;\n readonly kind = 'engine';\n  // \n options: engineoptions = {\n  lang: 'zh-cn',\n  locale: {},\n  plugins: [],\n  cards: [],\n  config: {},\n };\n language: languageinterface;\n root: nodeinterface;\n change: changeinterface;\n card: cardmodelinterface;\n plugin: pluginmodelinterface;\n node: nodemodelinterface;\n nodeid: nodeidinterface;\n list: listmodelinterface;\n mark: markmodelinterface;\n inline: inlinemodelinterface;\n block: blockmodelinterface;\n event: eventinterface;\n typing: typinginterface;\n ot: otinterface;\n schema: schemainterface;\n conversion: conversioninterface;\n history: historyinterface;\n command: commandinterface;\n hotkey: hotkeyinterface;\n clipboard: clipboardinterface;\n request: requestinterface;\n #_scrollnode: nodeinterface | null = null;\n\n get container(): nodeinterface {\n  return this._container.getnode();\n }\n\n get readonly(): boolean {\n  return this._readonly;\n }\n\n get scrollnode(): nodeinterface | null {\n  if (this.#_scrollnode) return this.#_scrollnode;\n    //  _scrollnode\n  const { scrollnode } = this.options;\n  let sn = scrollnode\n   ? typeof scrollnode === 'function'\n    ? scrollnode()\n    : scrollnode\n   : null;\n  //  overflow  overflow-y  auto  scroll \n  const targetvalues = ['auto', 'scroll'];\n  let parent = this.container.parent();\n    //  scrollnode\n  while (parent && parent.length > 0 && parent.name !== 'body') {\n   if (\n    targetvalues.includes(parent.css('overflow')) ||\n    targetvalues.includes(parent.css('overflow-y'))\n   ) {\n    sn = parent.get<htmlelement>();\n    break;\n   } else {\n    parent = parent.parent();\n   }\n  }\n    //  documentelement\n  if (sn === null) sn = document.documentelement;\n  this.#_scrollnode = sn ? $(sn) : null;\n  return this.#_scrollnode;\n }\n\n set readonly(readonly: boolean) {\n  if (this.readonly === readonly) return;\n    //  readonly_container\n  if (readonly) {\n   this.hotkey.disable();\n   this._container.setreadonly(true);\n  } else {\n   this.hotkey.enable();\n   this._container.setreadonly(false);\n  }\n  this._readonly = readonly;\n    //  card\n  this.card.rerender();\n  // readonly\n  this.trigger('readonly', readonly);\n }\n\n constructor(selector: selector, options?: engineoptions) {\n    // \n  this.options = { ...this.options, ...options };\n  // \n  this.language = new language(\n   this.options.lang || 'zh-cn',\n   merge(language, options?.locale),\n  );\n  // \n  this.event = new event();\n  // \n  this.command = new command(this);\n  // \n  this.schema = new schema();\n    // \n  this.schema.add(schemadefaultdata);\n  // \n  this.conversion = new conversion(this);\n    // \n  conversiondefault.foreach((rule) =>\n   this.conversion.add(rule.from, rule.to),\n  );\n  // \n  this.history = new history(this);\n  // \n  this.card = new cardmodel(this, this.options.lazyrender);\n  // \n  this.clipboard = new clipboard(this);\n  // http\n  this.request = new request();\n  // \n  this.plugin = new plugin(this);\n  // \n  this.node = new nodemodel(this);\n  this.nodeid = new nodeid(this);\n  // \n  this.list = new list(this);\n  // \n  this.mark = new mark(this);\n  // \n  this.inline = new inline(this);\n  // \n  this.block = new block(this);\n  // \n  this._container = new container(selector, {\n   engine: this,\n   lang: this.options.lang,\n   classname: this.options.classname,\n   tabindex: this.options.tabindex,\n   placeholder: this.options.placeholder,\n  });\n  // \n  this.root = $(\n   this.options.root || this.container.parent() || getdocument().body,\n  );\n    //  root position:relative\n  const rootposition = this.root.css('position');\n  if (!rootposition || rootposition === 'static')\n   this.root.css('position', 'relative');\n  // \n  this._container.init();\n  // \n  this.change = new change(this, {\n   onchange: (value, trigger) =>\n    this.trigger('change', value, trigger),\n   onselect: () => this.trigger('select'),\n   onrealtimechange: (trigger) => {\n    if (this.isempty()) {\n     this._container.showplaceholder();\n    } else {\n     this._container.hideplaceholder();\n    }\n    this.trigger('realtimechange', trigger);\n   },\n   onsetvalue: () => this.trigger('aftersetvalue'),\n  });\n  this.change.init();\n  // \n  this.typing = new typing(this);\n  // \n  this._readonly =\n   this.options.readonly === undefined ? false : this.options.readonly;\n  this._container.setreadonly(this._readonly);\n  // \n  this.mark.init();\n  this.inline.init();\n  this.block.init();\n  this.list.init();\n  // \n  this.hotkey = new hotkey(this);\n  this.card.init(this.options.cards || []);\n  this.plugin.init(this.options.plugins || [], this.options.config || {});\n  this.nodeid.init();\n  // \n  this.ot = new ot(this);\n\n  if (this.isempty()) {\n   this._container.showplaceholder();\n  }\n  this.ot.initlocal();\n }\n\n setscrollnode(node?: htmlelement) {\n  this.#_scrollnode = node ? $(node) : null;\n }\n\n isfocus() {\n  return this._container.isfocus();\n }\n\n isempty() {\n  return this.change.isempty();\n }\n\n focus(tostart?: boolean) {\n  this.change.range.focus(tostart);\n }\n\n blur() {\n  this.change.range.blur();\n }\n\n on(eventtype: string, listener: eventlistener, rewrite?: boolean) {\n  this.event.on(eventtype, listener, rewrite);\n  return this;\n }\n\n off(eventtype: string, listener: eventlistener) {\n  this.event.off(eventtype, listener);\n  return this;\n }\n\n trigger(eventtype: string, ...args: any) {\n  return this.event.trigger(eventtype, ...args);\n }\n\n getvalue(ignorecursor: boolean = false) {\n  const value = this.change.getvalue({});\n  return ignorecursor ? selection.removetags(value) : value;\n }\n\n async getvalueasync(\n  ignorecursor: boolean = false,\n  callback?: (\n   name: string,\n   card?: cardinterface,\n   ...args: any\n  ) => boolean | number | void,\n ): promise<string> {\n  return new promise(async (resolve, reject) => {\n      // \n   const pluginnames = object.keys(this.plugin.components);\n   for (let i = 0; i < pluginnames.length; i++) {\n    const plugin = this.plugin.components[pluginnames[i]];\n    const result = await new promise((resolve) => {\n     if (plugin.waiting) {\n      plugin\n       .waiting(callback)\n       .then(() => resolve(true))\n       .catch(resolve);\n     } else resolve(true);\n    });\n    if (typeof result === 'object') {\n     reject(result);\n     return;\n    }\n   }\n   resolve(this.getvalue(ignorecursor));\n  });\n }\n\n gethtml(): string {\n    //  container \n  const node = $(this.container[0].clonenode(true));\n    // \n  node.removeattributes('contenteditable');\n  node.removeattributes('tabindex');\n  node.removeattributes('autocorrect');\n  node.removeattributes('autocomplete');\n  node.removeattributes('spellcheck');\n  node.removeattributes('data-gramm');\n  node.removeattributes('role');\n  return new parser(node, this).tohtml();\n }\n\n setvalue(value: string, callback?: (count: number) => void) {\n  value = this.trigger('beforesetvalue', value) || value;\n  this.change.setvalue(value, undefined, callback);\n  this.normalize();\n    //  data-id\n  this.nodeid.generateall(this.container);\n    //  this \n  return this;\n }\n\n sethtml(html: string, callback?: (count: number) => void) {\n  this.change.sethtml(html, (count) => {\n   this.container.allchildren(true).foreach((child) => {\n    if (this.node.isinline(child)) {\n     this.inline.repaircursor(child);\n    } else if (this.node.ismark(child)) {\n     this.mark.repaircursor(child);\n    }\n    if (callback) callback(count);\n   });\n  });\n  this.nodeid.generateall(this.container);\n  return this;\n }\n\n setjsonvalue(value: array<any>, callback?: (count: number) => void) {\n  const dom = $(todom(value));\n    //  container \n  const attributes = dom.get<element>()?.attributes;\n  for (let i = 0; attributes && i < attributes.length; i++) {\n   const { nodename, nodevalue } = attributes.item(i) || {};\n   if (\n    /^data-selection-/.test(nodename || '') &&\n    nodevalue !== 'null'\n   ) {\n    this.container.attributes(nodename, nodevalue!);\n   }\n  }\n    //  container html\n  const html = this.node.html(dom);\n  this.change.setvalue(html, undefined, callback);\n    // \n  this.normalize();\n    //  data-id\n  this.nodeid.generateall(this.container);\n  return this;\n }\n\n getjsonvalue() {\n  return tojson0(this.container);\n }\n\n private normalize() {\n  let block = $('<p />');\n  // \n  let childnodes = this.container.children();\n  childnodes.each((_, index) => {\n   const node = childnodes.eq(index);\n   if (!node) return;\n   if (this.node.isblock(node)) {\n    if (block.get<htmlelement>()!.childnodes.length > 0) {\n     node.before(block);\n    }\n    block = $('<p />');\n   } else if (!node.iscursor()) {\n    block.append(node);\n   }\n  });\n\n  if (block.get<htmlelement>()!.childnodes.length > 0) {\n   this.container.append(block);\n  }\n  // \n  childnodes = this.container.children();\n  childnodes.each((_, index) => {\n   const node = childnodes.eq(index);\n   if (!node) return;\n   this.node.removeminusstyle(node, 'text-indent');\n   if (this.node.isrootblock(node)) {\n    const childrenlength =\n     node.get<htmlelement>()!.childnodes.length;\n    if (childrenlength === 0) {\n     node.append($('<br />'));\n    } else {\n     const child = node.first();\n     if (\n      childrenlength === 1 &&\n      child?.name === 'span' &&\n      [cursor, anchor, focus].indexof(\n       child.attributes(data_element),\n      ) >= 0\n     ) {\n      node.prepend($('<br />'));\n     }\n    }\n   }\n  });\n }\n\n messagesuccess(message: string) {\n  console.log(`success:${message}`);\n }\n\n messageerror(error: string) {\n  console.log(`error:${error}`);\n }\n\n messageconfirm(message: string): promise<boolean> {\n  console.log(`confirm:${message}`);\n  return promise.reject(false);\n }\n\n showplaceholder() {\n  this._container.showplaceholder();\n }\n\n hideplaceholder() {\n  this._container.hideplaceholder();\n }\n\n destroy() {\n  this._container.destroy();\n  this.change.destroy();\n  this.hotkey.destroy();\n  this.card.destroy();\n  if (this.ot) {\n   this.ot.destroy();\n  }\n }\n}\n\nexport default engine;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"container",frontmatter:{title:"container",date:"2022-04-14T22:02:20.000Z",permalink:"/pages/a35554/",categories:["am-editor","engine"],tags:[null]},regularPath:"/30.web/70.am-editor/10.engine/30.container.html",relativePath:"30.web/70.am-editor/10.engine/30.container.md",key:"v-42d8aff9",path:"/pages/a35554/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:19},{level:2,title:"Container",slug:"container",normalizedTitle:"container",charIndex:2}],readingTime:{text:"3 min read",minutes:2.245,time:134700.00000000003,words:449},headersStr:" Container",content:"# Container \n\n\n# \n\n\n\n * \n * Container\n\n\n\n\n# Container\n\nclass Container {\n  // \n private options: Options;\n  // \n private node: NodeInterface;\n  //  focus\n private _focused: boolean = false;\n #styleElement?: Element;\n\n constructor(selector: Selector, options: Options) {\n  this.node = $(selector);\n  this.options = options;\n  this._init();\n    //  focus\n  this._focused =\n   document.activeElement !== null &&\n   this.node.equal(document.activeElement);\n }\n\n _init() {\n  const { lang, tabIndex, className } = this.options;\n    //  container  data-element  root\n  this.node.attributes(DATA_ELEMENT, ROOT);\n    //  container \n  this.node.attributes({\n   contenteditable: 'true',\n   role: 'textbox',\n   autocorrect: lang === 'en-US' ? 'on' : 'off',\n   autocomplete: 'off',\n   spellcheck: lang === 'en-US' ? 'true' : 'false',\n   'data-gramm': 'false',\n  });\n\n  if (tabIndex !== undefined) {\n   this.node.attributes('tabindex', tabIndex);\n  }\n\n  if (!this.node.hasClass('am-engine')) {\n   this.node.addClass('am-engine');\n  }\n\n  if (isMobile) this.node.addClass('am-engine-mobile');\n\n  // className  array  string\n    if (className !== undefined) {\n   (Array.isArray(className)\n    ? className\n    : className.split(/\\s+/)\n   ).forEach((name) => {\n    if (name.trim() !== '') this.node.addClass(name);\n   });\n  }\n }\n\n init() {\n  const { engine } = this.options;\n    //  container  input \n  this.node.on('input', (e) => {\n      // \n   if (engine.readonly) {\n    return;\n   }\n\n   // card: card model instance\n      // \n      if (engine.card.find(e.target)) {\n    return;\n   }\n   const range = engine.change.range.get();\n   range.handleBr(true);\n  });\n  // \n  this.node.on('click', (event: MouseEvent) => {\n   if (event.target && $(event.target).isEditable()) {\n    // \n    const block = this.node.last();\n    if (block) {\n     //\n     if (!block.isCard()) return;\n     //\n     if (\n      (block.get<HTMLElement>()?.offsetTop || 0) +\n       (block.get<Element>()?.clientHeight || 0) >\n      event.offsetY\n     )\n      return;\n    }\n    const node = $('<p><br /></p>');\n    this.node.append(node);\n    const range = engine.change.range.get();\n        // \n    range.select(node, true).collapse(false);\n    engine.change.apply(range);\n   }\n  });\n  let isMousedown = false;\n  this.node.on(isMobile ? 'touchstart' : 'mousedown', () => {\n   isMousedown = true;\n   setTimeout(() => {\n    if (!this._focused) {\n     this._focused = true;\n          //  focus \n     engine.trigger('focus');\n    }\n    isMousedown = false;\n   }, 10);\n  });\n  this.node.on('focus', () => {\n   isMousedown = false;\n   this._focused = true;\n   engine.trigger('focus');\n  });\n  this.node.on('blur', () => {\n   if (isMousedown) return;\n   isMousedown = false;\n   this._focused = false;\n   engine.trigger('blur');\n  });\n }\n\n isFocus() {\n  return this._focused;\n }\n\n getNode() {\n  return this.node;\n }\n\n setReadonly(readonly: boolean) {\n  this.node.attributes('contenteditable', readonly ? 'false' : 'true');\n }\n\n showPlaceholder() {\n  const { placeholder } = this.options;\n  if (placeholder) {\n   if (this.#styleElement && this.#styleElement.parentNode)\n    document.body.removeChild(this.#styleElement);\n   this.#styleElement = document.createElement('style');\n   //const left = this.node.css('padding-left');\n   //const top = this.node.css('padding-top');\n      //  placeholder \n   const styleText = document.createTextNode(`.am-engine:before {\n                content: attr(data-placeholder);\n                pointer-events: none;\n                position: absolute;\n                color: #bbbfc4;\n                height: 0;\n            }`);\n   this.#styleElement.appendChild(styleText);\n   document.body.appendChild(this.#styleElement);\n   this.node.attributes({\n    'data-placeholder': placeholder,\n   });\n  } else if (this.#styleElement && this.#styleElement.parentNode)\n   document.body.removeChild(this.#styleElement);\n }\n\n hidePlaceholder() {\n  this.node.removeAttributes('data-placeholder');\n }\n\n destroy() {\n  const { className, engine } = this.options;\n  this.node.removeAttributes(DATA_ELEMENT);\n  this.node.removeAttributes('contenteditable');\n  this.node.removeAttributes('role');\n  this.node.removeAttributes('autocorrect');\n  this.node.removeAttributes('autocomplete');\n  this.node.removeAttributes('spellcheck');\n  this.node.removeAttributes('data-gramm');\n  this.node.removeAttributes('tabindex');\n  this.node.removeAttributes('data-placeholder');\n  if (this.#styleElement) document.body.removeChild(this.#styleElement);\n  if (this.options.className) {\n   (Array.isArray(className)\n    ? className\n    : (className || '').split(/\\s+/)\n   ).forEach((name) => {\n    if (name.trim() !== '') this.node.removeClass(name);\n   });\n  }\n\n  if (engine.card.closest(this.node)) this.node.removeClass('am-engine');\n  this.node.removeAllEvents();\n }\n}\n\nexport default Container;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n",normalizedContent:"# container \n\n\n# \n\n\n\n * \n * container\n\n\n\n\n# container\n\nclass container {\n  // \n private options: options;\n  // \n private node: nodeinterface;\n  //  focus\n private _focused: boolean = false;\n #styleelement?: element;\n\n constructor(selector: selector, options: options) {\n  this.node = $(selector);\n  this.options = options;\n  this._init();\n    //  focus\n  this._focused =\n   document.activeelement !== null &&\n   this.node.equal(document.activeelement);\n }\n\n _init() {\n  const { lang, tabindex, classname } = this.options;\n    //  container  data-element  root\n  this.node.attributes(data_element, root);\n    //  container \n  this.node.attributes({\n   contenteditable: 'true',\n   role: 'textbox',\n   autocorrect: lang === 'en-us' ? 'on' : 'off',\n   autocomplete: 'off',\n   spellcheck: lang === 'en-us' ? 'true' : 'false',\n   'data-gramm': 'false',\n  });\n\n  if (tabindex !== undefined) {\n   this.node.attributes('tabindex', tabindex);\n  }\n\n  if (!this.node.hasclass('am-engine')) {\n   this.node.addclass('am-engine');\n  }\n\n  if (ismobile) this.node.addclass('am-engine-mobile');\n\n  // classname  array  string\n    if (classname !== undefined) {\n   (array.isarray(classname)\n    ? classname\n    : classname.split(/\\s+/)\n   ).foreach((name) => {\n    if (name.trim() !== '') this.node.addclass(name);\n   });\n  }\n }\n\n init() {\n  const { engine } = this.options;\n    //  container  input \n  this.node.on('input', (e) => {\n      // \n   if (engine.readonly) {\n    return;\n   }\n\n   // card: card model instance\n      // \n      if (engine.card.find(e.target)) {\n    return;\n   }\n   const range = engine.change.range.get();\n   range.handlebr(true);\n  });\n  // \n  this.node.on('click', (event: mouseevent) => {\n   if (event.target && $(event.target).iseditable()) {\n    // \n    const block = this.node.last();\n    if (block) {\n     //\n     if (!block.iscard()) return;\n     //\n     if (\n      (block.get<htmlelement>()?.offsettop || 0) +\n       (block.get<element>()?.clientheight || 0) >\n      event.offsety\n     )\n      return;\n    }\n    const node = $('<p><br /></p>');\n    this.node.append(node);\n    const range = engine.change.range.get();\n        // \n    range.select(node, true).collapse(false);\n    engine.change.apply(range);\n   }\n  });\n  let ismousedown = false;\n  this.node.on(ismobile ? 'touchstart' : 'mousedown', () => {\n   ismousedown = true;\n   settimeout(() => {\n    if (!this._focused) {\n     this._focused = true;\n          //  focus \n     engine.trigger('focus');\n    }\n    ismousedown = false;\n   }, 10);\n  });\n  this.node.on('focus', () => {\n   ismousedown = false;\n   this._focused = true;\n   engine.trigger('focus');\n  });\n  this.node.on('blur', () => {\n   if (ismousedown) return;\n   ismousedown = false;\n   this._focused = false;\n   engine.trigger('blur');\n  });\n }\n\n isfocus() {\n  return this._focused;\n }\n\n getnode() {\n  return this.node;\n }\n\n setreadonly(readonly: boolean) {\n  this.node.attributes('contenteditable', readonly ? 'false' : 'true');\n }\n\n showplaceholder() {\n  const { placeholder } = this.options;\n  if (placeholder) {\n   if (this.#styleelement && this.#styleelement.parentnode)\n    document.body.removechild(this.#styleelement);\n   this.#styleelement = document.createelement('style');\n   //const left = this.node.css('padding-left');\n   //const top = this.node.css('padding-top');\n      //  placeholder \n   const styletext = document.createtextnode(`.am-engine:before {\n                content: attr(data-placeholder);\n                pointer-events: none;\n                position: absolute;\n                color: #bbbfc4;\n                height: 0;\n            }`);\n   this.#styleelement.appendchild(styletext);\n   document.body.appendchild(this.#styleelement);\n   this.node.attributes({\n    'data-placeholder': placeholder,\n   });\n  } else if (this.#styleelement && this.#styleelement.parentnode)\n   document.body.removechild(this.#styleelement);\n }\n\n hideplaceholder() {\n  this.node.removeattributes('data-placeholder');\n }\n\n destroy() {\n  const { classname, engine } = this.options;\n  this.node.removeattributes(data_element);\n  this.node.removeattributes('contenteditable');\n  this.node.removeattributes('role');\n  this.node.removeattributes('autocorrect');\n  this.node.removeattributes('autocomplete');\n  this.node.removeattributes('spellcheck');\n  this.node.removeattributes('data-gramm');\n  this.node.removeattributes('tabindex');\n  this.node.removeattributes('data-placeholder');\n  if (this.#styleelement) document.body.removechild(this.#styleelement);\n  if (this.options.classname) {\n   (array.isarray(classname)\n    ? classname\n    : (classname || '').split(/\\s+/)\n   ).foreach((name) => {\n    if (name.trim() !== '') this.node.removeclass(name);\n   });\n  }\n\n  if (engine.card.closest(this.node)) this.node.removeclass('am-engine');\n  this.node.removeallevents();\n }\n}\n\nexport default container;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"change",frontmatter:{title:"change",date:"2022-04-14T22:02:20.000Z",permalink:"/pages/53c865/",categories:["am-editor","engine"],tags:[null]},regularPath:"/30.web/70.am-editor/10.engine/40.change.html",relativePath:"30.web/70.am-editor/10.engine/40.change.md",key:"v-7c8f5906",path:"/pages/53c865/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:13},{level:2,title:"ChangeEventInterface",slug:"changeeventinterface",normalizedTitle:"changeeventinterface",charIndex:28},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:0}],readingTime:{text:"4 min read",minutes:3.4,time:204e3,words:680},headersStr:" ChangeEventInterface ",content:"# Change\n\n\n# \n\n\n\n * \n * ChangeEventInterface\n * \n\n\n\n\n# ChangeEventInterface\n\n/**\n * Change \n */\nexport interface ChangeEventInterface {\n /**\n  * \n  */\n isComposing: boolean;\n /**\n  * \n  */\n isSelecting: boolean;\n /**\n  * \n  * @param e\n  */\n isCardInput(e: Event): boolean;\n /**\n  * \n  * @param callback\n  */\n onInput(callback: (event: InputEvent) => void): void;\n /**\n  * \n  * @param callback\n  */\n onSelect(callback: (event: Event) => void): void;\n /**\n  * \n  * @param callback\n  */\n onPaste(\n  callback: (data: ClipboardData & { isPasteText: boolean }) => void,\n ): void;\n /**\n  * \n  * @param callback\n  */\n onDrop(\n  callback: (params: {\n   event: DragEvent;\n   range?: RangeInterface;\n   card?: CardInterface;\n   files: Array<File | null>;\n  }) => void,\n ): void;\n /**\n  *  document \n  * @param eventType\n  * @param listener\n  * @param index\n  */\n onDocument(\n  eventType: string,\n  listener: EventListener,\n  index?: number,\n ): void;\n /**\n  *  window \n  * @param eventType\n  * @param listener\n  * @param index\n  */\n onWindow(eventType: string, listener: EventListener, index?: number): void;\n /**\n  * \n  * @param eventType\n  * @param listener\n  * @param index\n  */\n onContainer(\n  eventType: string,\n  listener: EventListener,\n  index?: number,\n ): void;\n /**\n  * \n  * @param eventType\n  * @param listener\n  * @param index\n  */\n onRoot(eventType: string, listener: EventListener, index?: number): void;\n /**\n  * \n  */\n destroy(): void;\n}\n\nexport type ChangeEventOptions = {\n bindInput?: () => boolean;\n bindSelect?: () => boolean;\n bindPaste?: () => boolean;\n bindDrop?: () => boolean;\n};\n\nexport type ChangeOptions = {\n /**\n  * \n  */\n onChange?: (value: string, trigger: 'remote' | 'local' | 'both') => void;\n /**\n  * \n  */\n onSelect?: () => void;\n /**\n  * \n  */\n onRealtimeChange?: (trigger: 'remote' | 'local') => void;\n /**\n  * \n  */\n onSetValue?: () => void;\n};\n\nexport interface ChangeConstructor {\n /**\n  * \n  */\n new (container: NodeInterface, options: ChangeOptions): ChangeInterface;\n}\nexport interface ChangeRangeInterface {\n /**\n  * \n  */\n get(): RangeInterface;\n /**\n  * \n  * @param range \n  */\n toTrusty(range?: RangeInterface): RangeInterface;\n /**\n  * \n  * @param range \n  * @param triggerSelect onSelect\n  */\n select(range: RangeInterface, triggerSelect?: boolean): void;\n /**\n  * \n  * @param toStart true:,false:\n  */\n focus(toStart?: boolean): void;\n /**\n  * \n  */\n blur(): void;\n}\n/**\n * Change \n */\nexport interface ChangeInterface {\n /**\n  * \n  */\n init(): void;\n /**\n  * range\n  */\n rangePathBeforeCommand?: { start: RangePath; end: RangePath };\n /**\n  * \n  */\n event: ChangeEventInterface;\n /**\n  * Range \n  */\n range: ChangeRangeInterface;\n /**\n  *  mark \n  */\n marks: Array<NodeInterface>;\n /**\n  *  block \n  */\n blocks: Array<NodeInterface>;\n /**\n  *  inline \n  */\n inlines: Array<NodeInterface>;\n /**\n  * \n  */\n onChange: (value: string, trigger: 'remote' | 'local' | 'both') => void;\n /**\n  * \n  */\n onSelect: () => void;\n /**\n  * \n  */\n onSetValue: () => void;\n /**\n  * \n  * @param isRemote \n  * @param node \n  */\n change(isRemote?: boolean, node?: Array<NodeInterface>): void;\n /**\n  * dom\n  * @param range \n  */\n apply(range?: RangeInterface): void;\n /**\n  * \n  */\n combinText(): void;\n /**\n  * \n  */\n isComposing(): boolean;\n /**\n  *\n  */\n isSelecting(): boolean;\n /**\n  * \n  * @param range\n  */\n initValue(range?: RangeInterface): void;\n /**\n  * \n  * @param value \n  * @param onParse \n  * @param callback \n  */\n setValue(\n  value: string,\n  onParse?: (node: NodeInterface) => void,\n  callback?: (count: number) => void,\n ): void;\n /**\n  * html\n  * @param html html\n  * @param callback \n  */\n setHtml(html: string, callback?: (count: number) => void): void;\n /**\n  * \n  */\n getOriginValue(): string;\n /**\n  * \n  * @param options\n  */\n getValue(options: { ignoreCursor?: boolean }): string;\n /**\n  * \n  */\n cacheRangeBeforeCommand(): void;\n /**\n  * \n  */\n getRangePathBeforeCommand():\n  | { start: RangePath; end: RangePath }\n  | undefined;\n /**\n  * \n  */\n isEmpty(): boolean;\n /**\n  * \n  * @param fragment \n  * @param callback \n  * @param followActiveMark mark\n  */\n insert(\n  fragment: DocumentFragment,\n  range?: RangeInterface,\n  callback?: (range: RangeInterface) => void,\n  followActiveMark?: boolean,\n ): void;\n /**\n  * \n  * @param range \n  * @param isDeepMerge \n  * @param followActiveMark mark\n  */\n delete(\n  range?: RangeInterface,\n  isDeepMerge?: boolean,\n  followActiveMark?: boolean,\n ): void;\n /**\n  * block\n  * @param node \n  */\n unwrap(node?: NodeInterface): void;\n /**\n  * block\n  * @param node \n  */\n mergeAfterDelete(node?: NodeInterface): void;\n /**\n  * \n  */\n destroy(): void;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n\n\n\n#",normalizedContent:"# change\n\n\n# \n\n\n\n * \n * changeeventinterface\n * \n\n\n\n\n# changeeventinterface\n\n/**\n * change \n */\nexport interface changeeventinterface {\n /**\n  * \n  */\n iscomposing: boolean;\n /**\n  * \n  */\n isselecting: boolean;\n /**\n  * \n  * @param e\n  */\n iscardinput(e: event): boolean;\n /**\n  * \n  * @param callback\n  */\n oninput(callback: (event: inputevent) => void): void;\n /**\n  * \n  * @param callback\n  */\n onselect(callback: (event: event) => void): void;\n /**\n  * \n  * @param callback\n  */\n onpaste(\n  callback: (data: clipboarddata & { ispastetext: boolean }) => void,\n ): void;\n /**\n  * \n  * @param callback\n  */\n ondrop(\n  callback: (params: {\n   event: dragevent;\n   range?: rangeinterface;\n   card?: cardinterface;\n   files: array<file | null>;\n  }) => void,\n ): void;\n /**\n  *  document \n  * @param eventtype\n  * @param listener\n  * @param index\n  */\n ondocument(\n  eventtype: string,\n  listener: eventlistener,\n  index?: number,\n ): void;\n /**\n  *  window \n  * @param eventtype\n  * @param listener\n  * @param index\n  */\n onwindow(eventtype: string, listener: eventlistener, index?: number): void;\n /**\n  * \n  * @param eventtype\n  * @param listener\n  * @param index\n  */\n oncontainer(\n  eventtype: string,\n  listener: eventlistener,\n  index?: number,\n ): void;\n /**\n  * \n  * @param eventtype\n  * @param listener\n  * @param index\n  */\n onroot(eventtype: string, listener: eventlistener, index?: number): void;\n /**\n  * \n  */\n destroy(): void;\n}\n\nexport type changeeventoptions = {\n bindinput?: () => boolean;\n bindselect?: () => boolean;\n bindpaste?: () => boolean;\n binddrop?: () => boolean;\n};\n\nexport type changeoptions = {\n /**\n  * \n  */\n onchange?: (value: string, trigger: 'remote' | 'local' | 'both') => void;\n /**\n  * \n  */\n onselect?: () => void;\n /**\n  * \n  */\n onrealtimechange?: (trigger: 'remote' | 'local') => void;\n /**\n  * \n  */\n onsetvalue?: () => void;\n};\n\nexport interface changeconstructor {\n /**\n  * \n  */\n new (container: nodeinterface, options: changeoptions): changeinterface;\n}\nexport interface changerangeinterface {\n /**\n  * \n  */\n get(): rangeinterface;\n /**\n  * \n  * @param range \n  */\n totrusty(range?: rangeinterface): rangeinterface;\n /**\n  * \n  * @param range \n  * @param triggerselect onselect\n  */\n select(range: rangeinterface, triggerselect?: boolean): void;\n /**\n  * \n  * @param tostart true:,false:\n  */\n focus(tostart?: boolean): void;\n /**\n  * \n  */\n blur(): void;\n}\n/**\n * change \n */\nexport interface changeinterface {\n /**\n  * \n  */\n init(): void;\n /**\n  * range\n  */\n rangepathbeforecommand?: { start: rangepath; end: rangepath };\n /**\n  * \n  */\n event: changeeventinterface;\n /**\n  * range \n  */\n range: changerangeinterface;\n /**\n  *  mark \n  */\n marks: array<nodeinterface>;\n /**\n  *  block \n  */\n blocks: array<nodeinterface>;\n /**\n  *  inline \n  */\n inlines: array<nodeinterface>;\n /**\n  * \n  */\n onchange: (value: string, trigger: 'remote' | 'local' | 'both') => void;\n /**\n  * \n  */\n onselect: () => void;\n /**\n  * \n  */\n onsetvalue: () => void;\n /**\n  * \n  * @param isremote \n  * @param node \n  */\n change(isremote?: boolean, node?: array<nodeinterface>): void;\n /**\n  * dom\n  * @param range \n  */\n apply(range?: rangeinterface): void;\n /**\n  * \n  */\n combintext(): void;\n /**\n  * \n  */\n iscomposing(): boolean;\n /**\n  *\n  */\n isselecting(): boolean;\n /**\n  * \n  * @param range\n  */\n initvalue(range?: rangeinterface): void;\n /**\n  * \n  * @param value \n  * @param onparse \n  * @param callback \n  */\n setvalue(\n  value: string,\n  onparse?: (node: nodeinterface) => void,\n  callback?: (count: number) => void,\n ): void;\n /**\n  * html\n  * @param html html\n  * @param callback \n  */\n sethtml(html: string, callback?: (count: number) => void): void;\n /**\n  * \n  */\n getoriginvalue(): string;\n /**\n  * \n  * @param options\n  */\n getvalue(options: { ignorecursor?: boolean }): string;\n /**\n  * \n  */\n cacherangebeforecommand(): void;\n /**\n  * \n  */\n getrangepathbeforecommand():\n  | { start: rangepath; end: rangepath }\n  | undefined;\n /**\n  * \n  */\n isempty(): boolean;\n /**\n  * \n  * @param fragment \n  * @param callback \n  * @param followactivemark mark\n  */\n insert(\n  fragment: documentfragment,\n  range?: rangeinterface,\n  callback?: (range: rangeinterface) => void,\n  followactivemark?: boolean,\n ): void;\n /**\n  * \n  * @param range \n  * @param isdeepmerge \n  * @param followactivemark mark\n  */\n delete(\n  range?: rangeinterface,\n  isdeepmerge?: boolean,\n  followactivemark?: boolean,\n ): void;\n /**\n  * block\n  * @param node \n  */\n unwrap(node?: nodeinterface): void;\n /**\n  * block\n  * @param node \n  */\n mergeafterdelete(node?: nodeinterface): void;\n /**\n  * \n  */\n destroy(): void;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n\n\n\n#",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"range",frontmatter:{title:"range",date:"2022-04-14T22:02:20.000Z",permalink:"/pages/7f2a93/",categories:["am-editor","engine"],tags:[null]},regularPath:"/30.web/70.am-editor/10.engine/50.range.html",relativePath:"30.web/70.am-editor/10.engine/50.range.md",key:"v-55778605",path:"/pages/7f2a93/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:12}],readingTime:{text:"1 min read",minutes:.035,time:2100,words:7},headersStr:"",content:"# Range\n\n\n# \n\n\n\n * \n\n",normalizedContent:"# range\n\n\n# \n\n\n\n * \n\n",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"",frontmatter:{title:"",date:"2022-06-23T16:08:30.000Z",permalink:"/axios/index/",categories:["web","axios"],tags:[null]},regularPath:"/30.web/8.axios/0.index.html",relativePath:"30.web/8.axios/0.index.md",key:"v-51bac5f7",path:"/axios/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-06-23T16:09:43.000Z",permalink:"/axios/core/index/",categories:["web","axios","core"],tags:[null]},regularPath:"/30.web/8.axios/10.core/0.index.html",relativePath:"30.web/8.axios/10.core/0.index.md",key:"v-f55aa90e",path:"/axios/core/index/",headers:[{level:2,title:"Request Config",slug:"request-config",normalizedTitle:"request config",charIndex:2}],readingTime:{text:"7 min read",minutes:6.88,time:412800,words:1376},headersStr:"Request Config",content:"# Request Config\n\nThese are the available config options for making requests. Only the url is required. Requests will default to GET if method is not specified.\n\n{\n  // `url` is the server URL that will be used for the request\n  url: '/user',\n\n  // `method` is the request method to be used when making the request\n  method: 'get', // default\n\n  // `baseURL` will be prepended to `url` unless `url` is absolute.\n  // It can be convenient to set `baseURL` for an instance of axios to pass relative URLs\n  // to methods of that instance.\n  baseURL: 'https://some-domain.com/api/',\n\n  // `transformRequest` allows changes to the request data before it is sent to the server\n  // This is only applicable for request methods 'PUT', 'POST', 'PATCH' and 'DELETE'\n  // The last function in the array must return a string or an instance of Buffer, ArrayBuffer,\n  // FormData or Stream\n  // You may modify the headers object.\n  transformRequest: [function (data, headers) {\n    // Do whatever you want to transform the data\n\n    return data;\n  }],\n\n  // `transformResponse` allows changes to the response data to be made before\n  // it is passed to then/catch\n  transformResponse: [function (data) {\n    // Do whatever you want to transform the data\n\n    return data;\n  }],\n\n  // `headers` are custom headers to be sent\n  headers: {'X-Requested-With': 'XMLHttpRequest'},\n\n  // `params` are the URL parameters to be sent with the request\n  // Must be a plain object or a URLSearchParams object\n  params: {\n    ID: 12345\n  },\n\n  // `paramsSerializer` is an optional config in charge of serializing `params`\n  paramsSerializer: {\n    indexes: null // array indexes format (null - no brackets, false - empty brackets, true - brackets with indexes)\n  },\n\n  // `data` is the data to be sent as the request body\n  // Only applicable for request methods 'PUT', 'POST', 'DELETE , and 'PATCH'\n  // When no `transformRequest` is set, must be of one of the following types:\n  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams\n  // - Browser only: FormData, File, Blob\n  // - Node only: Stream, Buffer\n  data: {\n    firstName: 'Fred'\n  },\n  \n  // syntax alternative to send data into the body\n  // method post\n  // only the value is sent, not the key\n  data: 'Country=Brasil&City=Belo Horizonte',\n\n  // `timeout` specifies the number of milliseconds before the request times out.\n  // If the request takes longer than `timeout`, the request will be aborted.\n  timeout: 1000, // default is `0` (no timeout)\n\n  // `withCredentials` indicates whether or not cross-site Access-Control requests\n  // should be made using credentials\n  withCredentials: false, // default\n\n  // `adapter` allows custom handling of requests which makes testing easier.\n  // Return a promise and supply a valid response (see lib/adapters/README.md).\n  adapter: function (config) {\n    /* ... */\n  },\n\n  // `auth` indicates that HTTP Basic auth should be used, and supplies credentials.\n  // This will set an `Authorization` header, overwriting any existing\n  // `Authorization` custom headers you have set using `headers`.\n  // Please note that only HTTP Basic auth is configurable through this parameter.\n  // For Bearer tokens and such, use `Authorization` custom headers instead.\n  auth: {\n    username: 'janedoe',\n    password: 's00pers3cret'\n  },\n\n  // `responseType` indicates the type of data that the server will respond with\n  // options are: 'arraybuffer', 'document', 'json', 'text', 'stream'\n  //   browser only: 'blob'\n  responseType: 'json', // default\n\n  // `responseEncoding` indicates encoding to use for decoding responses (Node.js only)\n  // Note: Ignored for `responseType` of 'stream' or client-side requests\n  responseEncoding: 'utf8', // default\n\n  // `xsrfCookieName` is the name of the cookie to use as a value for xsrf token\n  xsrfCookieName: 'XSRF-TOKEN', // default\n\n  // `xsrfHeaderName` is the name of the http header that carries the xsrf token value\n  xsrfHeaderName: 'X-XSRF-TOKEN', // default\n\n  // `onUploadProgress` allows handling of progress events for uploads\n  // browser only\n  onUploadProgress: function (progressEvent) {\n    // Do whatever you want with the native progress event\n  },\n\n  // `onDownloadProgress` allows handling of progress events for downloads\n  // browser only\n  onDownloadProgress: function (progressEvent) {\n    // Do whatever you want with the native progress event\n  },\n\n  // `maxContentLength` defines the max size of the http response content in bytes allowed in node.js\n  maxContentLength: 2000,\n\n  // `maxBodyLength` (Node only option) defines the max size of the http request content in bytes allowed\n  maxBodyLength: 2000,\n\n  // `validateStatus` defines whether to resolve or reject the promise for a given\n  // HTTP response status code. If `validateStatus` returns `true` (or is set to `null`\n  // or `undefined`), the promise will be resolved; otherwise, the promise will be\n  // rejected.\n  validateStatus: function (status) {\n    return status >= 200 && status < 300; // default\n  },\n\n  // `maxRedirects` defines the maximum number of redirects to follow in node.js.\n  // If set to 0, no redirects will be followed.\n  maxRedirects: 21, // default\n\n  // `beforeRedirect` defines a function that will be called before redirect.\n  // Use this to adjust the request options upon redirecting,\n  // to inspect the latest response headers,\n  // or to cancel the request by throwing an error\n  // If maxRedirects is set to 0, `beforeRedirect` is not used.\n  beforeRedirect: (options, { headers }) => {\n    if (options.hostname === \"example.com\") {\n      options.auth = \"user:password\";\n    }\n  },\n\n  // `socketPath` defines a UNIX Socket to be used in node.js.\n  // e.g. '/var/run/docker.sock' to send requests to the docker daemon.\n  // Only either `socketPath` or `proxy` can be specified.\n  // If both are specified, `socketPath` is used.\n  socketPath: null, // default\n\n  // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http\n  // and https requests, respectively, in node.js. This allows options to be added like\n  // `keepAlive` that are not enabled by default.\n  httpAgent: new http.Agent({ keepAlive: true }),\n  httpsAgent: new https.Agent({ keepAlive: true }),\n\n  // `proxy` defines the hostname, port, and protocol of the proxy server.\n  // You can also define your proxy using the conventional `http_proxy` and\n  // `https_proxy` environment variables. If you are using environment variables\n  // for your proxy configuration, you can also define a `no_proxy` environment\n  // variable as a comma-separated list of domains that should not be proxied.\n  // Use `false` to disable proxies, ignoring environment variables.\n  // `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and\n  // supplies credentials.\n  // This will set an `Proxy-Authorization` header, overwriting any existing\n  // `Proxy-Authorization` custom headers you have set using `headers`.\n  // If the proxy server uses HTTPS, then you must set the protocol to `https`. \n  proxy: {\n    protocol: 'https',\n    host: '127.0.0.1',\n    port: 9000,\n    auth: {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  },\n\n  // `cancelToken` specifies a cancel token that can be used to cancel the request\n  // (see Cancellation section below for details)\n  cancelToken: new CancelToken(function (cancel) {\n  }),\n\n  // an alternative way to cancel Axios requests using AbortController\n  signal: new AbortController().signal,\n\n  // `decompress` indicates whether or not the response body should be decompressed \n  // automatically. If set to `true` will also remove the 'content-encoding' header \n  // from the responses objects of all decompressed responses\n  // - Node only (XHR cannot turn off decompression)\n  decompress: true // default\n\n  // `insecureHTTPParser` boolean.\n  // Indicates where to use an insecure HTTP parser that accepts invalid HTTP headers.\n  // This may allow interoperability with non-conformant HTTP implementations.\n  // Using the insecure parser should be avoided.\n  // see options https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_http_request_url_options_callback\n  // see also https://nodejs.org/en/blog/vulnerability/february-2020-security-releases/#strict-http-header-parsing-none\n  insecureHTTPParser: undefined // default\n\n  // transitional options for backward compatibility that may be removed in the newer versions\n  transitional: {\n    // silent JSON parsing mode\n    // `true`  - ignore JSON parsing errors and set response.data to null if parsing failed (old behaviour)\n    // `false` - throw SyntaxError if JSON parsing failed (Note: responseType must be set to 'json')\n    silentJSONParsing: true, // default value for the current Axios version\n\n    // try to parse the response string as JSON even if `responseType` is not 'json'\n    forcedJSONParsing: true,\n    \n    // throw ETIMEDOUT error instead of generic ECONNABORTED on request timeouts\n    clarifyTimeoutError: false,\n  },\n\n  env: {\n    // The FormData class to be used to automatically serialize the payload into a FormData object\n    FormData: window?.FormData || global?.FormData\n  },\n\n  formSerializer: {\n      visitor: (value, key, path, helpers)=> {}; // custom visitor funaction to serrialize form values\n      dots: boolean; // use dots instead of brackets format\n      metaTokens: boolean; // keep special endings like {} in parameter key \n      indexes: boolean; // array indexes format null - no brackets, false - empty brackets, true - brackets with indexes\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n",normalizedContent:"# request config\n\nthese are the available config options for making requests. only the url is required. requests will default to get if method is not specified.\n\n{\n  // `url` is the server url that will be used for the request\n  url: '/user',\n\n  // `method` is the request method to be used when making the request\n  method: 'get', // default\n\n  // `baseurl` will be prepended to `url` unless `url` is absolute.\n  // it can be convenient to set `baseurl` for an instance of axios to pass relative urls\n  // to methods of that instance.\n  baseurl: 'https://some-domain.com/api/',\n\n  // `transformrequest` allows changes to the request data before it is sent to the server\n  // this is only applicable for request methods 'put', 'post', 'patch' and 'delete'\n  // the last function in the array must return a string or an instance of buffer, arraybuffer,\n  // formdata or stream\n  // you may modify the headers object.\n  transformrequest: [function (data, headers) {\n    // do whatever you want to transform the data\n\n    return data;\n  }],\n\n  // `transformresponse` allows changes to the response data to be made before\n  // it is passed to then/catch\n  transformresponse: [function (data) {\n    // do whatever you want to transform the data\n\n    return data;\n  }],\n\n  // `headers` are custom headers to be sent\n  headers: {'x-requested-with': 'xmlhttprequest'},\n\n  // `params` are the url parameters to be sent with the request\n  // must be a plain object or a urlsearchparams object\n  params: {\n    id: 12345\n  },\n\n  // `paramsserializer` is an optional config in charge of serializing `params`\n  paramsserializer: {\n    indexes: null // array indexes format (null - no brackets, false - empty brackets, true - brackets with indexes)\n  },\n\n  // `data` is the data to be sent as the request body\n  // only applicable for request methods 'put', 'post', 'delete , and 'patch'\n  // when no `transformrequest` is set, must be of one of the following types:\n  // - string, plain object, arraybuffer, arraybufferview, urlsearchparams\n  // - browser only: formdata, file, blob\n  // - node only: stream, buffer\n  data: {\n    firstname: 'fred'\n  },\n  \n  // syntax alternative to send data into the body\n  // method post\n  // only the value is sent, not the key\n  data: 'country=brasil&city=belo horizonte',\n\n  // `timeout` specifies the number of milliseconds before the request times out.\n  // if the request takes longer than `timeout`, the request will be aborted.\n  timeout: 1000, // default is `0` (no timeout)\n\n  // `withcredentials` indicates whether or not cross-site access-control requests\n  // should be made using credentials\n  withcredentials: false, // default\n\n  // `adapter` allows custom handling of requests which makes testing easier.\n  // return a promise and supply a valid response (see lib/adapters/readme.md).\n  adapter: function (config) {\n    /* ... */\n  },\n\n  // `auth` indicates that http basic auth should be used, and supplies credentials.\n  // this will set an `authorization` header, overwriting any existing\n  // `authorization` custom headers you have set using `headers`.\n  // please note that only http basic auth is configurable through this parameter.\n  // for bearer tokens and such, use `authorization` custom headers instead.\n  auth: {\n    username: 'janedoe',\n    password: 's00pers3cret'\n  },\n\n  // `responsetype` indicates the type of data that the server will respond with\n  // options are: 'arraybuffer', 'document', 'json', 'text', 'stream'\n  //   browser only: 'blob'\n  responsetype: 'json', // default\n\n  // `responseencoding` indicates encoding to use for decoding responses (node.js only)\n  // note: ignored for `responsetype` of 'stream' or client-side requests\n  responseencoding: 'utf8', // default\n\n  // `xsrfcookiename` is the name of the cookie to use as a value for xsrf token\n  xsrfcookiename: 'xsrf-token', // default\n\n  // `xsrfheadername` is the name of the http header that carries the xsrf token value\n  xsrfheadername: 'x-xsrf-token', // default\n\n  // `onuploadprogress` allows handling of progress events for uploads\n  // browser only\n  onuploadprogress: function (progressevent) {\n    // do whatever you want with the native progress event\n  },\n\n  // `ondownloadprogress` allows handling of progress events for downloads\n  // browser only\n  ondownloadprogress: function (progressevent) {\n    // do whatever you want with the native progress event\n  },\n\n  // `maxcontentlength` defines the max size of the http response content in bytes allowed in node.js\n  maxcontentlength: 2000,\n\n  // `maxbodylength` (node only option) defines the max size of the http request content in bytes allowed\n  maxbodylength: 2000,\n\n  // `validatestatus` defines whether to resolve or reject the promise for a given\n  // http response status code. if `validatestatus` returns `true` (or is set to `null`\n  // or `undefined`), the promise will be resolved; otherwise, the promise will be\n  // rejected.\n  validatestatus: function (status) {\n    return status >= 200 && status < 300; // default\n  },\n\n  // `maxredirects` defines the maximum number of redirects to follow in node.js.\n  // if set to 0, no redirects will be followed.\n  maxredirects: 21, // default\n\n  // `beforeredirect` defines a function that will be called before redirect.\n  // use this to adjust the request options upon redirecting,\n  // to inspect the latest response headers,\n  // or to cancel the request by throwing an error\n  // if maxredirects is set to 0, `beforeredirect` is not used.\n  beforeredirect: (options, { headers }) => {\n    if (options.hostname === \"example.com\") {\n      options.auth = \"user:password\";\n    }\n  },\n\n  // `socketpath` defines a unix socket to be used in node.js.\n  // e.g. '/var/run/docker.sock' to send requests to the docker daemon.\n  // only either `socketpath` or `proxy` can be specified.\n  // if both are specified, `socketpath` is used.\n  socketpath: null, // default\n\n  // `httpagent` and `httpsagent` define a custom agent to be used when performing http\n  // and https requests, respectively, in node.js. this allows options to be added like\n  // `keepalive` that are not enabled by default.\n  httpagent: new http.agent({ keepalive: true }),\n  httpsagent: new https.agent({ keepalive: true }),\n\n  // `proxy` defines the hostname, port, and protocol of the proxy server.\n  // you can also define your proxy using the conventional `http_proxy` and\n  // `https_proxy` environment variables. if you are using environment variables\n  // for your proxy configuration, you can also define a `no_proxy` environment\n  // variable as a comma-separated list of domains that should not be proxied.\n  // use `false` to disable proxies, ignoring environment variables.\n  // `auth` indicates that http basic auth should be used to connect to the proxy, and\n  // supplies credentials.\n  // this will set an `proxy-authorization` header, overwriting any existing\n  // `proxy-authorization` custom headers you have set using `headers`.\n  // if the proxy server uses https, then you must set the protocol to `https`. \n  proxy: {\n    protocol: 'https',\n    host: '127.0.0.1',\n    port: 9000,\n    auth: {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  },\n\n  // `canceltoken` specifies a cancel token that can be used to cancel the request\n  // (see cancellation section below for details)\n  canceltoken: new canceltoken(function (cancel) {\n  }),\n\n  // an alternative way to cancel axios requests using abortcontroller\n  signal: new abortcontroller().signal,\n\n  // `decompress` indicates whether or not the response body should be decompressed \n  // automatically. if set to `true` will also remove the 'content-encoding' header \n  // from the responses objects of all decompressed responses\n  // - node only (xhr cannot turn off decompression)\n  decompress: true // default\n\n  // `insecurehttpparser` boolean.\n  // indicates where to use an insecure http parser that accepts invalid http headers.\n  // this may allow interoperability with non-conformant http implementations.\n  // using the insecure parser should be avoided.\n  // see options https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_http_request_url_options_callback\n  // see also https://nodejs.org/en/blog/vulnerability/february-2020-security-releases/#strict-http-header-parsing-none\n  insecurehttpparser: undefined // default\n\n  // transitional options for backward compatibility that may be removed in the newer versions\n  transitional: {\n    // silent json parsing mode\n    // `true`  - ignore json parsing errors and set response.data to null if parsing failed (old behaviour)\n    // `false` - throw syntaxerror if json parsing failed (note: responsetype must be set to 'json')\n    silentjsonparsing: true, // default value for the current axios version\n\n    // try to parse the response string as json even if `responsetype` is not 'json'\n    forcedjsonparsing: true,\n    \n    // throw etimedout error instead of generic econnaborted on request timeouts\n    clarifytimeouterror: false,\n  },\n\n  env: {\n    // the formdata class to be used to automatically serialize the payload into a formdata object\n    formdata: window?.formdata || global?.formdata\n  },\n\n  formserializer: {\n      visitor: (value, key, path, helpers)=> {}; // custom visitor funaction to serrialize form values\n      dots: boolean; // use dots instead of brackets format\n      metatokens: boolean; // keep special endings like {} in parameter key \n      indexes: boolean; // array indexes format null - no brackets, false - empty brackets, true - brackets with indexes\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"axios ",frontmatter:{title:"axios ",date:"2022-06-23T19:53:42.000Z",permalink:"/axios/core/instance/",categories:["web","axios","core"],tags:[null]},regularPath:"/30.web/8.axios/10.core/10.axios.html",relativePath:"30.web/8.axios/10.core/10.axios.md",key:"v-ea939fc6",path:"/axios/core/instance/",headers:[{level:2,title:"Axios ",slug:"axios-",normalizedTitle:"axios ",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:1072},{level:2,title:"dispatchRequest",slug:"dispatchrequest",normalizedTitle:"dispatchrequest",charIndex:1101}],readingTime:{text:"4 min read",minutes:3.26,time:195600,words:652},headersStr:"Axios   dispatchRequest",content:'# Axios \n\nAxios  ES5 \n\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n OOP  ES6 \n\n            ES6               ES5\n         constructor     \n      super()           SuperClass.call(this)\n   static property   Class.property\n   this.property     Class.prototype.property\n         new Class()       new Class()\nthis                      \n          extends        \n\nES5 \n\n/** Inherit the prototype methods from one constructor into another */\nfunction inherits(constructor, superConstructor, props, descriptors) {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  props && Object.assign(constructor.prototype, props);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n ES5 \n\n * \n * \n * \n\n\n# \n\n axios  request dispatchRequest ()response  FIFO\n\n single-spa  transformData \n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Number} status HTTP status code\n * @param {Array|Function} fns A single function or Array of functions\n *\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, status, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(context, data, headers, status);\n  });\n\n  return data;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n Axios.prototype.request \n\n/**\n * Dispatch a request\n *\n * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n * @param {?Object} config\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nAxios.prototype.request = function request(configOrUrl, config) {\n  // ......\n  config = mergeConfig(this.defaults, config);\n  // ......\n\n  // filter out skipped interceptors\n  var requestInterceptorChain = [];\n  var synchronousRequestInterceptors = true;\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    if (typeof interceptor.runWhen === \'function\' && interceptor.runWhen(config) === false) {\n      return;\n    }\n\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var responseInterceptorChain = [];\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var promise;\n\n  if (!synchronousRequestInterceptors) {\n    var chain = [dispatchRequest, undefined];\n\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\n    chain = chain.concat(responseInterceptorChain);\n\n    promise = Promise.resolve(config);\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n\n  var newConfig = config;\n  while (requestInterceptorChain.length) {\n    var onFulfilled = requestInterceptorChain.shift();\n    var onRejected = requestInterceptorChain.shift();\n    try {\n      newConfig = onFulfilled(newConfig);\n    } catch (error) {\n      onRejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchRequest(newConfig);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  while (responseInterceptorChain.length) {\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n  }\n\n  return promise;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n\n 1.  request  interceptors.request  dispatchRequest  interceptors.response  interceptors.request \n 2.  chain  requestInterceptorChain + [dispatchRequest, undefined] + responseInterceptorChain  interceptorChain  onFulfilled  onRejected  dispatchRequest  undefined  chain  promise \n 3. Array  pushconcatspliceunshift  item \n\ninterface Array<T> {\n  push(...items: T[]): number;\n  concat(...items: ConcatArray<T>[]): T[];\n  concat(...items: (T | ConcatArray<T>)[]): T[];\n  splice(start: number, deleteCount: number, ...items: T[]): T[];\n  unshift(...items: T[]): number;\n  // ......\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# dispatchRequest\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n //  ......\n // Transform request data\n //  transformRequest  data \n config.data = transformData.call(\n  config,\n  config.data,\n  config.headers,\n  null,\n  config.transformRequest\n );\n // ......\n\n utils.forEach(\n  ["delete", "get", "head", "post", "put", "patch", "common"],\n  function cleanHeaderConfig(method) {\n   delete config.headers[method];\n  }\n );\n\n var adapter = config.adapter || defaults.adapter;\n\n return adapter(config).then(\n  function onAdapterResolution(response) {\n   throwIfCancellationRequested(config);\n\n   // Transform response data\n   response.data = transformData.call(\n    config,\n    response.data,\n    response.headers,\n    response.status,\n    config.transformResponse\n   );\n\n   return response;\n  },\n  function onAdapterRejection(reason) {\n   if (!isCancel(reason)) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    if (reason && reason.response) {\n     reason.response.data = transformData.call(\n      config,\n      reason.response.data,\n      reason.response.headers,\n      reason.response.status,\n      config.transformResponse\n     );\n    }\n   }\n\n   return Promise.reject(reason);\n  }\n );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n\n\n * 2  transformer: transformRequest  transformResponse  transformer \n * adapter axios  runtime web  Node  adapter ',normalizedContent:'# axios \n\naxios  es5 \n\nfunction axios(instanceconfig) {\n  this.defaults = instanceconfig;\n  this.interceptors = {\n    request: new interceptormanager(),\n    response: new interceptormanager()\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n oop  es6 \n\n            es6               es5\n         constructor     \n      super()           superclass.call(this)\n   static property   class.property\n   this.property     class.prototype.property\n         new class()       new class()\nthis                      \n          extends        \n\nes5 \n\n/** inherit the prototype methods from one constructor into another */\nfunction inherits(constructor, superconstructor, props, descriptors) {\n  constructor.prototype = object.create(superconstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  props && object.assign(constructor.prototype, props);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n es5 \n\n * \n * \n * \n\n\n# \n\n axios  request dispatchrequest ()response  fifo\n\n single-spa  transformdata \n\n/**\n * transform the data for a request or a response\n *\n * @param {object|string} data the data to be transformed\n * @param {array} headers the headers for the request or response\n * @param {number} status http status code\n * @param {array|function} fns a single function or array of functions\n *\n * @returns {*} the resulting transformed data\n */\nmodule.exports = function transformdata(data, headers, status, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n  utils.foreach(fns, function transform(fn) {\n    data = fn.call(context, data, headers, status);\n  });\n\n  return data;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n axios.prototype.request \n\n/**\n * dispatch a request\n *\n * @param {string|object} configorurl the config specific for this request (merged with this.defaults)\n * @param {?object} config\n *\n * @returns {promise} the promise to be fulfilled\n */\naxios.prototype.request = function request(configorurl, config) {\n  // ......\n  config = mergeconfig(this.defaults, config);\n  // ......\n\n  // filter out skipped interceptors\n  var requestinterceptorchain = [];\n  var synchronousrequestinterceptors = true;\n  this.interceptors.request.foreach(function unshiftrequestinterceptors(interceptor) {\n    if (typeof interceptor.runwhen === \'function\' && interceptor.runwhen(config) === false) {\n      return;\n    }\n\n    synchronousrequestinterceptors = synchronousrequestinterceptors && interceptor.synchronous;\n\n    requestinterceptorchain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var responseinterceptorchain = [];\n  this.interceptors.response.foreach(function pushresponseinterceptors(interceptor) {\n    responseinterceptorchain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var promise;\n\n  if (!synchronousrequestinterceptors) {\n    var chain = [dispatchrequest, undefined];\n\n    array.prototype.unshift.apply(chain, requestinterceptorchain);\n    chain = chain.concat(responseinterceptorchain);\n\n    promise = promise.resolve(config);\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n\n  var newconfig = config;\n  while (requestinterceptorchain.length) {\n    var onfulfilled = requestinterceptorchain.shift();\n    var onrejected = requestinterceptorchain.shift();\n    try {\n      newconfig = onfulfilled(newconfig);\n    } catch (error) {\n      onrejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchrequest(newconfig);\n  } catch (error) {\n    return promise.reject(error);\n  }\n\n  while (responseinterceptorchain.length) {\n    promise = promise.then(responseinterceptorchain.shift(), responseinterceptorchain.shift());\n  }\n\n  return promise;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n\n 1.  request  interceptors.request  dispatchrequest  interceptors.response  interceptors.request \n 2.  chain  requestinterceptorchain + [dispatchrequest, undefined] + responseinterceptorchain  interceptorchain  onfulfilled  onrejected  dispatchrequest  undefined  chain  promise \n 3. array  pushconcatspliceunshift  item \n\ninterface array<t> {\n  push(...items: t[]): number;\n  concat(...items: concatarray<t>[]): t[];\n  concat(...items: (t | concatarray<t>)[]): t[];\n  splice(start: number, deletecount: number, ...items: t[]): t[];\n  unshift(...items: t[]): number;\n  // ......\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# dispatchrequest\n\n/**\n * dispatch a request to the server using the configured adapter.\n *\n * @param {object} config the config that is to be used for the request\n *\n * @returns {promise} the promise to be fulfilled\n */\nmodule.exports = function dispatchrequest(config) {\n //  ......\n // transform request data\n //  transformrequest  data \n config.data = transformdata.call(\n  config,\n  config.data,\n  config.headers,\n  null,\n  config.transformrequest\n );\n // ......\n\n utils.foreach(\n  ["delete", "get", "head", "post", "put", "patch", "common"],\n  function cleanheaderconfig(method) {\n   delete config.headers[method];\n  }\n );\n\n var adapter = config.adapter || defaults.adapter;\n\n return adapter(config).then(\n  function onadapterresolution(response) {\n   throwifcancellationrequested(config);\n\n   // transform response data\n   response.data = transformdata.call(\n    config,\n    response.data,\n    response.headers,\n    response.status,\n    config.transformresponse\n   );\n\n   return response;\n  },\n  function onadapterrejection(reason) {\n   if (!iscancel(reason)) {\n    throwifcancellationrequested(config);\n\n    // transform response data\n    if (reason && reason.response) {\n     reason.response.data = transformdata.call(\n      config,\n      reason.response.data,\n      reason.response.headers,\n      reason.response.status,\n      config.transformresponse\n     );\n    }\n   }\n\n   return promise.reject(reason);\n  }\n );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n\n\n * 2  transformer: transformrequest  transformresponse  transformer \n * adapter axios  runtime web  node  adapter ',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"interceptor ",frontmatter:{title:"interceptor ",date:"2022-06-26T09:56:25.000Z",permalink:"/axios/core/interceptor/",categories:["web","axios","core"],tags:[null]},regularPath:"/30.web/8.axios/10.core/30.interceptor.html",relativePath:"30.web/8.axios/10.core/30.interceptor.md",key:"v-498b6e86",path:"/axios/core/interceptor/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"adapter ",frontmatter:{title:"adapter ",date:"2022-06-26T09:52:24.000Z",permalink:"/axios/core/adapter/",categories:["web","axios","core"],tags:[null]},regularPath:"/30.web/8.axios/10.core/20.adapter.html",relativePath:"30.web/8.axios/10.core/20.adapter.md",key:"v-c9eede46",path:"/axios/core/adapter/",headers:[{level:2,title:"getDefaultAdapter",slug:"getdefaultadapter",normalizedTitle:"getdefaultadapter",charIndex:2},{level:2,title:"XHR Adapter",slug:"xhr-adapter",normalizedTitle:"xhr adapter",charIndex:721},{level:2,title:"HTTP Adapter",slug:"http-adapter",normalizedTitle:"http adapter",charIndex:9408}],readingTime:{text:"5 min read",minutes:4.81,time:288599.99999999994,words:962},headersStr:"getDefaultAdapter XHR Adapter HTTP Adapter",content:'# getDefaultAdapter\n\naxios  adapter \n\n/**\n * If the browser has an XMLHttpRequest object, use the XHR adapter, otherwise use the HTTP\n * adapter\n *\n * @returns {Function}\n */\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== \'undefined\') {\n    // For browsers use XHR adapter\n    adapter = require(\'../adapters/xhr\');\n  } else if (typeof process !== \'undefined\' && Object.prototype.toString.call(process) === \'[object process]\') {\n    // For node use HTTP adapter\n    adapter = require(\'../adapters/http\');\n  }\n  return adapter;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n *  XMLHttpRequest XHR\n *  XHR  nodeJS  HTTP \n *  web  nodejs \n\n\n# XHR Adapter\n\nXHR Adapter  web \n\nfunction xhrAdapter(config) {\n return new Promise(function dispatchXhrRequest(resolve, reject) {\n  var requestData = config.data;\n  var requestHeaders = config.headers;\n  var responseType = config.responseType;\n  var onCanceled;\n  // cancelTokensignal\n  function done() {\n   if (config.cancelToken) {\n    config.cancelToken.unsubscribe(onCanceled);\n   }\n\n   if (config.signal) {\n    config.signal.removeEventListener("abort", onCanceled);\n   }\n  }\n\n  if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {\n   delete requestHeaders["Content-Type"]; // Let the browser set it\n  }\n\n  var request = new XMLHttpRequest();\n\n  // HTTP basic authentication\n  if (config.auth) {\n   var username = config.auth.username || "";\n   var password = config.auth.password\n    ? unescape(encodeURIComponent(config.auth.password))\n    : "";\n   requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);\n  }\n\n  var fullPath = buildFullPath(config.baseURL, config.url);\n\n  request.open(\n   config.method.toUpperCase(),\n   buildURL(fullPath, config.params, config.paramsSerializer),\n   true\n  );\n\n  // Set the request timeout in MS\n  request.timeout = config.timeout;\n\n  function onloadend() {\n   if (!request) {\n    return;\n   }\n   // Prepare the response\n   var responseHeaders =\n    "getAllResponseHeaders" in request\n     ? parseHeaders(request.getAllResponseHeaders())\n     : null;\n   var responseData =\n    !responseType || responseType === "text" || responseType === "json"\n     ? request.responseText\n     : request.response;\n   var response = {\n    data: responseData,\n    status: request.status,\n    statusText: request.statusText,\n    headers: responseHeaders,\n    config: config,\n    request: request,\n   };\n\n   settle(\n    function _resolve(value) {\n     resolve(value);\n     done();\n    },\n    function _reject(err) {\n     reject(err);\n     done();\n    },\n    response\n   );\n\n   // Clean up request\n   request = null;\n  }\n\n  if ("onloadend" in request) {\n   // Use onloadend if available\n   request.onloadend = onloadend;\n  } else {\n   // Listen for ready state to emulate onloadend\n   request.onreadystatechange = function handleLoad() {\n    if (!request || request.readyState !== 4) {\n     return;\n    }\n\n    // The request errored out and we didn\'t get a response, this will be\n    // handled by onerror instead\n    // With one exception: request that using file: protocol, most browsers\n    // will return status as 0 even though it\'s a successful request\n    if (\n     request.status === 0 &&\n     !(request.responseURL && request.responseURL.indexOf("file:") === 0)\n    ) {\n     return;\n    }\n    // readystate handler is calling before onerror or ontimeout handlers,\n    // so we should call onloadend on the next \'tick\'\n    setTimeout(onloadend);\n   };\n  }\n\n  // Handle browser request cancellation (as opposed to a manual cancellation)\n  request.onabort = function handleAbort() {\n   if (!request) {\n    return;\n   }\n\n   reject(\n    new AxiosError(\n     "Request aborted",\n     AxiosError.ECONNABORTED,\n     config,\n     request\n    )\n   );\n\n   // Clean up request\n   request = null;\n  };\n\n  // Handle low level network errors\n  request.onerror = function handleError() {\n   // Real errors are hidden from us by the browser\n   // onerror should only fire if it\'s a network error\n   reject(\n    new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request)\n   );\n\n   // Clean up request\n   request = null;\n  };\n\n  // Handle timeout\n  request.ontimeout = function handleTimeout() {\n   var timeoutErrorMessage = config.timeout\n    ? "timeout of " + config.timeout + "ms exceeded"\n    : "timeout exceeded";\n   var transitional = config.transitional || transitionalDefaults;\n   if (config.timeoutErrorMessage) {\n    timeoutErrorMessage = config.timeoutErrorMessage;\n   }\n   reject(\n    new AxiosError(\n     timeoutErrorMessage,\n     transitional.clarifyTimeoutError\n      ? AxiosError.ETIMEDOUT\n      : AxiosError.ECONNABORTED,\n     config,\n     request\n    )\n   );\n\n   // Clean up request\n   request = null;\n  };\n\n  // Add xsrf header\n  // This is only done if running in a standard browser environment.\n  // Specifically not if we\'re in a web worker, or react-native.\n  if (utils.isStandardBrowserEnv()) {\n   // Add xsrf header\n   var xsrfValue =\n    (config.withCredentials || isURLSameOrigin(fullPath)) &&\n    config.xsrfCookieName\n     ? cookies.read(config.xsrfCookieName)\n     : undefined;\n\n   if (xsrfValue) {\n    requestHeaders[config.xsrfHeaderName] = xsrfValue;\n   }\n  }\n\n  // Add headers to the request\n  if ("setRequestHeader" in request) {\n   utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n    if (\n     typeof requestData === "undefined" &&\n     key.toLowerCase() === "content-type"\n    ) {\n     // Remove Content-Type if data is undefined\n     delete requestHeaders[key];\n    } else {\n     // Otherwise add header to the request\n     request.setRequestHeader(key, val);\n    }\n   });\n  }\n\n  // Add withCredentials to request if needed\n  if (!utils.isUndefined(config.withCredentials)) {\n   request.withCredentials = !!config.withCredentials;\n  }\n\n  // Add responseType to request if needed\n  if (responseType && responseType !== "json") {\n   request.responseType = config.responseType;\n  }\n\n  // Handle progress if needed\n  if (typeof config.onDownloadProgress === "function") {\n   request.addEventListener("progress", config.onDownloadProgress);\n  }\n\n  // Not all browsers support upload events\n  if (typeof config.onUploadProgress === "function" && request.upload) {\n   request.upload.addEventListener("progress", config.onUploadProgress);\n  }\n\n  if (config.cancelToken || config.signal) {\n   // Handle cancellation\n   // eslint-disable-next-line func-names\n   onCanceled = function (cancel) {\n    if (!request) {\n     return;\n    }\n    reject(\n     !cancel || cancel.type ? new CanceledError(null, config, req) : cancel\n    );\n    request.abort();\n    request = null;\n   };\n\n   config.cancelToken && config.cancelToken.subscribe(onCanceled);\n   if (config.signal) {\n    config.signal.aborted\n     ? onCanceled()\n     : config.signal.addEventListener("abort", onCanceled);\n   }\n  }\n\n  if (!requestData) {\n   requestData = null;\n  }\n\n  var protocol = parseProtocol(fullPath);\n\n  if (protocol && platform.protocols.indexOf(protocol) === -1) {\n   reject(\n    new AxiosError(\n     "Unsupported protocol " + protocol + ":",\n     AxiosError.ERR_BAD_REQUEST,\n     config\n    )\n   );\n   return;\n  }\n\n  // Send the request\n  request.send(requestData);\n });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n\n\nxhrAdapter \n\n 1.   XMLHttpRequest \n 2.   auth  Authorization header\n 3.   url\n 4.  request.open \n 5.   request.timeout \n 6.   onloadend  request.onloadend  request.onloadend  request.onreadystatechange  request.readyState  4\n 7.   request.onabort  Request aborted  AxiosError \n 8.   request.onerror  Network Error  AxiosError \n 9.   request.ontimeout  timeout exceeded  AxiosError \n 10.  web  xsrfCookieName xsrfCookieName  header  xsrf  token\n 11.  headers\n 12.  request.withCredentials  request.responseType \n 13.  onDownloadProgress  request  progress \n 14.  cancelToken  signal  cancelToken  onCanceled  signal  abort  onCanceled  onCanceled  CanceledError  request.abort \n 15.  protocol  Unsupported protocol  AxiosError\n 16.  request.send(requestData) \n 17.  onloadend  response  status  validateStatus resolve response  reject  Request failed AxiosErrorvalidateStatus  status >= 200 && status < 300 \n 18. onloadend  done  cleanup \n\n\n# HTTP Adapter\n\nHTTP Adapter  NodeJS ',normalizedContent:'# getdefaultadapter\n\naxios  adapter \n\n/**\n * if the browser has an xmlhttprequest object, use the xhr adapter, otherwise use the http\n * adapter\n *\n * @returns {function}\n */\nfunction getdefaultadapter() {\n  var adapter;\n  if (typeof xmlhttprequest !== \'undefined\') {\n    // for browsers use xhr adapter\n    adapter = require(\'../adapters/xhr\');\n  } else if (typeof process !== \'undefined\' && object.prototype.tostring.call(process) === \'[object process]\') {\n    // for node use http adapter\n    adapter = require(\'../adapters/http\');\n  }\n  return adapter;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n *  xmlhttprequest xhr\n *  xhr  nodejs  http \n *  web  nodejs \n\n\n# xhr adapter\n\nxhr adapter  web \n\nfunction xhradapter(config) {\n return new promise(function dispatchxhrrequest(resolve, reject) {\n  var requestdata = config.data;\n  var requestheaders = config.headers;\n  var responsetype = config.responsetype;\n  var oncanceled;\n  // canceltokensignal\n  function done() {\n   if (config.canceltoken) {\n    config.canceltoken.unsubscribe(oncanceled);\n   }\n\n   if (config.signal) {\n    config.signal.removeeventlistener("abort", oncanceled);\n   }\n  }\n\n  if (utils.isformdata(requestdata) && utils.isstandardbrowserenv()) {\n   delete requestheaders["content-type"]; // let the browser set it\n  }\n\n  var request = new xmlhttprequest();\n\n  // http basic authentication\n  if (config.auth) {\n   var username = config.auth.username || "";\n   var password = config.auth.password\n    ? unescape(encodeuricomponent(config.auth.password))\n    : "";\n   requestheaders.authorization = "basic " + btoa(username + ":" + password);\n  }\n\n  var fullpath = buildfullpath(config.baseurl, config.url);\n\n  request.open(\n   config.method.touppercase(),\n   buildurl(fullpath, config.params, config.paramsserializer),\n   true\n  );\n\n  // set the request timeout in ms\n  request.timeout = config.timeout;\n\n  function onloadend() {\n   if (!request) {\n    return;\n   }\n   // prepare the response\n   var responseheaders =\n    "getallresponseheaders" in request\n     ? parseheaders(request.getallresponseheaders())\n     : null;\n   var responsedata =\n    !responsetype || responsetype === "text" || responsetype === "json"\n     ? request.responsetext\n     : request.response;\n   var response = {\n    data: responsedata,\n    status: request.status,\n    statustext: request.statustext,\n    headers: responseheaders,\n    config: config,\n    request: request,\n   };\n\n   settle(\n    function _resolve(value) {\n     resolve(value);\n     done();\n    },\n    function _reject(err) {\n     reject(err);\n     done();\n    },\n    response\n   );\n\n   // clean up request\n   request = null;\n  }\n\n  if ("onloadend" in request) {\n   // use onloadend if available\n   request.onloadend = onloadend;\n  } else {\n   // listen for ready state to emulate onloadend\n   request.onreadystatechange = function handleload() {\n    if (!request || request.readystate !== 4) {\n     return;\n    }\n\n    // the request errored out and we didn\'t get a response, this will be\n    // handled by onerror instead\n    // with one exception: request that using file: protocol, most browsers\n    // will return status as 0 even though it\'s a successful request\n    if (\n     request.status === 0 &&\n     !(request.responseurl && request.responseurl.indexof("file:") === 0)\n    ) {\n     return;\n    }\n    // readystate handler is calling before onerror or ontimeout handlers,\n    // so we should call onloadend on the next \'tick\'\n    settimeout(onloadend);\n   };\n  }\n\n  // handle browser request cancellation (as opposed to a manual cancellation)\n  request.onabort = function handleabort() {\n   if (!request) {\n    return;\n   }\n\n   reject(\n    new axioserror(\n     "request aborted",\n     axioserror.econnaborted,\n     config,\n     request\n    )\n   );\n\n   // clean up request\n   request = null;\n  };\n\n  // handle low level network errors\n  request.onerror = function handleerror() {\n   // real errors are hidden from us by the browser\n   // onerror should only fire if it\'s a network error\n   reject(\n    new axioserror("network error", axioserror.err_network, config, request)\n   );\n\n   // clean up request\n   request = null;\n  };\n\n  // handle timeout\n  request.ontimeout = function handletimeout() {\n   var timeouterrormessage = config.timeout\n    ? "timeout of " + config.timeout + "ms exceeded"\n    : "timeout exceeded";\n   var transitional = config.transitional || transitionaldefaults;\n   if (config.timeouterrormessage) {\n    timeouterrormessage = config.timeouterrormessage;\n   }\n   reject(\n    new axioserror(\n     timeouterrormessage,\n     transitional.clarifytimeouterror\n      ? axioserror.etimedout\n      : axioserror.econnaborted,\n     config,\n     request\n    )\n   );\n\n   // clean up request\n   request = null;\n  };\n\n  // add xsrf header\n  // this is only done if running in a standard browser environment.\n  // specifically not if we\'re in a web worker, or react-native.\n  if (utils.isstandardbrowserenv()) {\n   // add xsrf header\n   var xsrfvalue =\n    (config.withcredentials || isurlsameorigin(fullpath)) &&\n    config.xsrfcookiename\n     ? cookies.read(config.xsrfcookiename)\n     : undefined;\n\n   if (xsrfvalue) {\n    requestheaders[config.xsrfheadername] = xsrfvalue;\n   }\n  }\n\n  // add headers to the request\n  if ("setrequestheader" in request) {\n   utils.foreach(requestheaders, function setrequestheader(val, key) {\n    if (\n     typeof requestdata === "undefined" &&\n     key.tolowercase() === "content-type"\n    ) {\n     // remove content-type if data is undefined\n     delete requestheaders[key];\n    } else {\n     // otherwise add header to the request\n     request.setrequestheader(key, val);\n    }\n   });\n  }\n\n  // add withcredentials to request if needed\n  if (!utils.isundefined(config.withcredentials)) {\n   request.withcredentials = !!config.withcredentials;\n  }\n\n  // add responsetype to request if needed\n  if (responsetype && responsetype !== "json") {\n   request.responsetype = config.responsetype;\n  }\n\n  // handle progress if needed\n  if (typeof config.ondownloadprogress === "function") {\n   request.addeventlistener("progress", config.ondownloadprogress);\n  }\n\n  // not all browsers support upload events\n  if (typeof config.onuploadprogress === "function" && request.upload) {\n   request.upload.addeventlistener("progress", config.onuploadprogress);\n  }\n\n  if (config.canceltoken || config.signal) {\n   // handle cancellation\n   // eslint-disable-next-line func-names\n   oncanceled = function (cancel) {\n    if (!request) {\n     return;\n    }\n    reject(\n     !cancel || cancel.type ? new cancelederror(null, config, req) : cancel\n    );\n    request.abort();\n    request = null;\n   };\n\n   config.canceltoken && config.canceltoken.subscribe(oncanceled);\n   if (config.signal) {\n    config.signal.aborted\n     ? oncanceled()\n     : config.signal.addeventlistener("abort", oncanceled);\n   }\n  }\n\n  if (!requestdata) {\n   requestdata = null;\n  }\n\n  var protocol = parseprotocol(fullpath);\n\n  if (protocol && platform.protocols.indexof(protocol) === -1) {\n   reject(\n    new axioserror(\n     "unsupported protocol " + protocol + ":",\n     axioserror.err_bad_request,\n     config\n    )\n   );\n   return;\n  }\n\n  // send the request\n  request.send(requestdata);\n });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n\n\nxhradapter \n\n 1.   xmlhttprequest \n 2.   auth  authorization header\n 3.   url\n 4.  request.open \n 5.   request.timeout \n 6.   onloadend  request.onloadend  request.onloadend  request.onreadystatechange  request.readystate  4\n 7.   request.onabort  request aborted  axioserror \n 8.   request.onerror  network error  axioserror \n 9.   request.ontimeout  timeout exceeded  axioserror \n 10.  web  xsrfcookiename xsrfcookiename  header  xsrf  token\n 11.  headers\n 12.  request.withcredentials  request.responsetype \n 13.  ondownloadprogress  request  progress \n 14.  canceltoken  signal  canceltoken  oncanceled  signal  abort  oncanceled  oncanceled  cancelederror  request.abort \n 15.  protocol  unsupported protocol  axioserror\n 16.  request.send(requestdata) \n 17.  onloadend  response  status  validatestatus resolve response  reject  request failed axioserrorvalidatestatus  status >= 200 && status < 300 \n 18. onloadend  done  cleanup \n\n\n# http adapter\n\nhttp adapter  nodejs ',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"cancel ",frontmatter:{title:"cancel ",date:"2022-06-26T09:57:04.000Z",permalink:"/axios/core/cancel/",categories:["web","axios","core"],tags:[null]},regularPath:"/30.web/8.axios/10.core/40.cancel.html",relativePath:"30.web/8.axios/10.core/40.cancel.md",key:"v-3fcd21c9",path:"/axios/core/cancel/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"",frontmatter:{title:"",date:"2022-04-14T22:02:20.000Z",permalink:"/pages/b58110/",categories:["html2canvas"],tags:[null]},regularPath:"/30.web/80.html2canvas/0.index.html",relativePath:"30.web/80.html2canvas/0.index.md",key:"v-3552c17d",path:"/pages/b58110/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"",frontmatter:{title:"",date:"2022-09-06T14:04:50.000Z",permalink:"/solid/index/",categories:["web","solid"],tags:[null]},regularPath:"/30.web/9.solid/0.index.html",relativePath:"30.web/9.solid/0.index.md",key:"v-dca0dbea",path:"/solid/index/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:" solidjs",slug:"-solidjs",normalizedTitle:" solidjs",charIndex:17},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:34},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:42},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:59},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:71},{level:3,title:": ",slug:"-",normalizedTitle:"",charIndex:866},{level:2,title:"Solid ",slug:"solid-",normalizedTitle:"solid ",charIndex:116},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:128}],readingTime:{text:"1 min read",minutes:.605,time:36300,words:121},headersStr:"  solidjs     :  Solid  ",content:"# \n\n\n\n * \n *  solidjs\n   * \n   * \n   * \n   * \n   * : \n * Solid \n * \n\n\n\n\n#  solidjs\n\n JavaScript \n\n\n# \n\n *  UI \n *  JSX \n *  API \n * \n\n\n# \n\nSolid  React, Knockout  React Hooks Solid Solid  Hook \n\nSolid  React  /  DOM\n\n\n# \n\nSolid \n\n * Fragments\n * Portals\n * Context\n * Suspense\n * \n * \n * \n * \n * \n * \n * Streaming\n\n\n# \n\nSolid  JSX  JavaScript  primitive \n\nSolid  DOM  DOM \n\n\n# \n\nSolid \n\n\n# Solid \n\nSolid  Solid  Solid \n\n *  \n\n *  Solid \n\n * /  \n\n *  \n\n\n# \n\n * SolidJS  Reactive Javascript Library\n * SolidJS JavaScript ",normalizedContent:"# \n\n\n\n * \n *  solidjs\n   * \n   * \n   * \n   * \n   * : \n * solid \n * \n\n\n\n\n#  solidjs\n\n javascript \n\n\n# \n\n *  ui \n *  jsx \n *  api \n * \n\n\n# \n\nsolid  react, knockout  react hooks solid solid  hook \n\nsolid  react  /  dom\n\n\n# \n\nsolid \n\n * fragments\n * portals\n * context\n * suspense\n * \n * \n * \n * \n * \n * \n * streaming\n\n\n# \n\nsolid  jsx  javascript  primitive \n\nsolid  dom  dom \n\n\n# \n\nsolid \n\n\n# solid \n\nsolid  solid  solid \n\n *  \n\n *  solid \n\n * /  \n\n *  \n\n\n# \n\n * solidjs  reactive javascript library\n * solidjs javascript ",charsets:{cjk:!0},lastUpdated:"2022/09/14, 18:44:08",lastUpdatedTimestamp:1663152248e3},{title:"",frontmatter:{title:"",date:"2022-09-06T14:49:46.000Z",permalink:"/solid/plan/",categories:["web","solid"],tags:[null]},regularPath:"/30.web/9.solid/1.plan.html",relativePath:"30.web/9.solid/1.plan.md",key:"v-73c1945d",path:"/solid/plan/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:153},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:123},{level:2,title:"Plan",slug:"plan",normalizedTitle:"plan ",charIndex:460},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:509}],readingTime:{text:"1 min read",minutes:.31,time:18600,words:62},headersStr:"   Plan ",content:"# \n\n React  SolidJS \n\n * \n * \n * \n\n\n# \n\n SolidJS \n\n *  React \n *  VDOM\n * \n * \n *  SSR \n\n\n# \n\n React \n\n * Render\n * reactivity\n * Data Flow\n * SSR\n\n\n# Plan \n\nSolidJS \n\n *  JSX \n\n\n# \n\n * \n * ",normalizedContent:"# \n\n react  solidjs \n\n * \n * \n * \n\n\n# \n\n solidjs \n\n *  react \n *  vdom\n * \n * \n *  ssr \n\n\n# \n\n react \n\n * render\n * reactivity\n * data flow\n * ssr\n\n\n# plan \n\nsolidjs \n\n *  jsx \n\n\n# \n\n * \n * ",charsets:{cjk:!0},lastUpdated:"2022/09/14, 18:44:08",lastUpdatedTimestamp:1663152248e3},{title:" JSX ",frontmatter:{title:" JSX ",date:"2022-09-07T11:08:40.000Z",permalink:"/solid/render/render-by-jsx",categories:["web","solid",""],tags:[null]},regularPath:"/30.web/9.solid/10.%E6%B8%B2%E6%9F%93/10.render-jsx.html",relativePath:"30.web/9.solid/10./10.render-jsx.md",key:"v-074761b1",path:"/solid/render/render-by-jsx/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"JSX ",slug:"jsx-",normalizedTitle:"jsx ",charIndex:17},{level:3,title:"React  JSX",slug:"react--jsx",normalizedTitle:"react  jsx",charIndex:30},{level:3,title:"SolidJS  JSX",slug:"solidjs--jsx",normalizedTitle:"solidjs  jsx",charIndex:48},{level:3,title:" VDOM ",slug:"-vdom-",normalizedTitle:" vdom ",charIndex:68},{level:3,title:" VDOM",slug:"-vdom",normalizedTitle:" vdom",charIndex:88},{level:3,title:"VDOM ",slug:"vdom-",normalizedTitle:"vdom ",charIndex:105},{level:3,title:"VDOM ",slug:"vdom-",normalizedTitle:"vdom ",charIndex:120},{level:3,title:"SolidJS ",slug:"solidjs-",normalizedTitle:"solidjs ",charIndex:138},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:157}],readingTime:{text:"3 min read",minutes:2.855,time:171300,words:571},headersStr:" JSX  React  JSX SolidJS  JSX  VDOM   VDOM VDOM  VDOM  SolidJS  ",content:'# \n\n\n\n * \n * JSX \n   * React  JSX\n   * SolidJS  JSX\n   *  VDOM \n   *  VDOM\n   * VDOM \n   * VDOM \n   * SolidJS \n   * \n\n\n\n\n# JSX \n\n\n# React  JSX\n\nSolidJS  React  JSX JSX  React JSX  ReactElement  babel  createElement  h  JSX JSX  SFC \n\n\n# SolidJS  JSX\n\n SolidJS  JSX \n\nimport { render } from "solid-js/web";\nimport { createSignal } from "solid-js";\n\nfunction Counter() {\n  const [count, setCount] = createSignal(0);\n  const increment = () => setCount(count() + 1);\n\n  return (\n    <button type="button" onClick={increment}>\n      {count()}\n    </button>\n  );\n}\n\nrender(() => <Counter />, document.getElementById("app")!);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nSolid Playground COMPILE MODE  Client side rendering  CSR\n\nSolidJS  React SolidJS  React React SolidJS  Vue VDOM Svelte\n\n babel-preset-solid output:\n\nimport { render, createComponent, delegateEvents, insert, template } from \'solid-js/web\';\nimport { createSignal } from \'solid-js\';\n\nconst _tmpl$ = /*#__PURE__*/template(`<button type="button"></button>`, 2);\n\nfunction Counter() {\n  const [count, setCount] = createSignal(0);\n\n  const increment = () => setCount(count() + 1);\n\n  return (() => {\n    const _el$ = _tmpl$.cloneNode(true);\n\n    _el$.$$click = increment;\n\n    insert(_el$, count);\n\n    return _el$;\n  })();\n}\n\nrender(() => createComponent(Counter, {}), document.getElementById("app"));\n\ndelegateEvents(["click"]);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\nJSX  h  VDOM  DOM \n\n * DOM \n * \n * \n\nDOM  _tmpl$  DOM  document.createElement("template")  DOM template\n\n createSignal  API    DOM \n\n delegateEvents  delegateEvents document  React  React  document  FiberRoot React 17 attaches events to the root DOM container instead of the document node document  document  React  FiberRoot container React  mousemove \n\n SolidJS  VDOM  VDOM \n\n\n#  VDOM \n\n VDOM \n\n *  h \n * render \n\n h   React  createElement vue  _createElementVNode Vue SFC Playground \n\n render  render  React  Class.render vue  setup \n\n VDOM \n\n *  VNode \n * VDOM  DIFF  VDOM \n\n\n\n *  | Vue.js\n *  & JSX | Vue.js\n\n\n#  VDOM\n\n SolidJS  JSX  React  SolidJS  VDOM  SolidJS VDOM  React DIFF  VDOM  VDOM \n\n *  DIFF  DIFF DOM  VDOM  JavaScript  DIFF  DIFF  DIFF React  EffectTag  Vue \n *  Web VDOM \n *  UI  declarative, state-driven UI development  React  Vue  VDOM \n\n\n# VDOM \n\n VDOM \n\n *  DIFF  DIFF\n *  DIFF \n\n DIFF  DIFF VDOM  DOM \n\n\n\n * Svelte Blog: Virtual DOM is pure overhead\n * React vs. Svelte: The War Between Virtual and Real DOM | by Keshav Kumaresan | Bits and Pieces\n * Incremental vs Virtual DOM. Will Incremental DOM Replace Virtual | by Chameera Dulanga | Bits and Pieces\n\n\n# VDOM \n\nVDOM   VDOM  VDOM \n\n * VDOM  DIFF VDOM VNode DIFF VNode  DOM  mutation \n * VDOM   VDOM  VDOM  \n\nVDOM  tradeoff VDOM  VDOM  DOM VDOM \n\n \n\n\n# SolidJS \n\nSolidJS  VDOM  DOM  DOM  VDOM  overhead \n\n VDOM \n\n *  VDOM  DIFF \n *  Reactsolidjs  VDOM DOM  DOM \n *  \n\n SolidJS   \n\n      SolidJS JSX  VDOM  SolidJS  DOM \n\n DOM  SolidJS  DOM \n\n\n# \n\n\n\n * Sawtaytoes/reactjs-solidjs-bridge: Render Solid.js components in React.js and visa versa.\n * Solid.js feels like what I always wanted React to be | TypeOfNaN\n * SolidJS: Reactivity to Rendering - JavaScript inDepth',normalizedContent:'# \n\n\n\n * \n * jsx \n   * react  jsx\n   * solidjs  jsx\n   *  vdom \n   *  vdom\n   * vdom \n   * vdom \n   * solidjs \n   * \n\n\n\n\n# jsx \n\n\n# react  jsx\n\nsolidjs  react  jsx jsx  react jsx  reactelement  babel  createelement  h  jsx jsx  sfc \n\n\n# solidjs  jsx\n\n solidjs  jsx \n\nimport { render } from "solid-js/web";\nimport { createsignal } from "solid-js";\n\nfunction counter() {\n  const [count, setcount] = createsignal(0);\n  const increment = () => setcount(count() + 1);\n\n  return (\n    <button type="button" onclick={increment}>\n      {count()}\n    </button>\n  );\n}\n\nrender(() => <counter />, document.getelementbyid("app")!);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nsolid playground compile mode  client side rendering  csr\n\nsolidjs  react solidjs  react react solidjs  vue vdom svelte\n\n babel-preset-solid output:\n\nimport { render, createcomponent, delegateevents, insert, template } from \'solid-js/web\';\nimport { createsignal } from \'solid-js\';\n\nconst _tmpl$ = /*#__pure__*/template(`<button type="button"></button>`, 2);\n\nfunction counter() {\n  const [count, setcount] = createsignal(0);\n\n  const increment = () => setcount(count() + 1);\n\n  return (() => {\n    const _el$ = _tmpl$.clonenode(true);\n\n    _el$.$$click = increment;\n\n    insert(_el$, count);\n\n    return _el$;\n  })();\n}\n\nrender(() => createcomponent(counter, {}), document.getelementbyid("app"));\n\ndelegateevents(["click"]);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\njsx  h  vdom  dom \n\n * dom \n * \n * \n\ndom  _tmpl$  dom  document.createelement("template")  dom template\n\n createsignal  api    dom \n\n delegateevents  delegateevents document  react  react  document  fiberroot react 17 attaches events to the root dom container instead of the document node document  document  react  fiberroot container react  mousemove \n\n solidjs  vdom  vdom \n\n\n#  vdom \n\n vdom \n\n *  h \n * render \n\n h   react  createelement vue  _createelementvnode vue sfc playground \n\n render  render  react  class.render vue  setup \n\n vdom \n\n *  vnode \n * vdom  diff  vdom \n\n\n\n *  | vue.js\n *  & jsx | vue.js\n\n\n#  vdom\n\n solidjs  jsx  react  solidjs  vdom  solidjs vdom  react diff  vdom  vdom \n\n *  diff  diff dom  vdom  javascript  diff  diff  diff react  effecttag  vue \n *  web vdom \n *  ui  declarative, state-driven ui development  react  vue  vdom \n\n\n# vdom \n\n vdom \n\n *  diff  diff\n *  diff \n\n diff  diff vdom  dom \n\n\n\n * svelte blog: virtual dom is pure overhead\n * react vs. svelte: the war between virtual and real dom | by keshav kumaresan | bits and pieces\n * incremental vs virtual dom. will incremental dom replace virtual | by chameera dulanga | bits and pieces\n\n\n# vdom \n\nvdom   vdom  vdom \n\n * vdom  diff vdom vnode diff vnode  dom  mutation \n * vdom   vdom  vdom  \n\nvdom  tradeoff vdom  vdom  dom vdom \n\n \n\n\n# solidjs \n\nsolidjs  vdom  dom  dom  vdom  overhead \n\n vdom \n\n *  vdom  diff \n *  reactsolidjs  vdom dom  dom \n *  \n\n solidjs   \n\n      solidjs jsx  vdom  solidjs  dom \n\n dom  solidjs  dom \n\n\n# \n\n\n\n * sawtaytoes/reactjs-solidjs-bridge: render solid.js components in react.js and visa versa.\n * solid.js feels like what i always wanted react to be | typeofnan\n * solidjs: reactivity to rendering - javascript indepth',charsets:{cjk:!0},lastUpdated:"2022/09/14, 18:44:08",lastUpdatedTimestamp:1663152248e3},{title:"",frontmatter:{title:"",date:"2022-04-14T23:36:48.000Z",permalink:"/node/index/",categories:null,tags:[null]},regularPath:"/40.node/0.index.html",relativePath:"40.node/0.index.md",key:"v-82075c46",path:"/node/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"Plan ",frontmatter:{title:"Plan ",date:"2022-04-16T13:46:07.000Z",permalink:"/node/plan/",categories:["node"],tags:[null]},regularPath:"/40.node/1.plan.html",relativePath:"40.node/1.plan.md",key:"v-cf050632",path:"/node/plan/",headers:[{level:2,title:"Plan",slug:"plan",normalizedTitle:"plan",charIndex:2}],readingTime:{text:"1 min read",minutes:.01,time:600,words:2},headersStr:"Plan",content:"# Plan",normalizedContent:"# plan",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"roadmap",frontmatter:{title:"roadmap",date:"2022-04-29T00:00:20.000Z",permalink:"/node/roadmap/",categories:["node"],tags:[null]},regularPath:"/40.node/2.roadmap.html",relativePath:"40.node/2.roadmap.md",key:"v-bebe86c6",path:"/node/roadmap/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2}],readingTime:{text:"1 min read",minutes:.045,time:2699.9999999999995,words:9},headersStr:"",content:"# \n\n * sindresorhus/awesome-nodejs: Delightful Node.js packages and resources",normalizedContent:"# \n\n * sindresorhus/awesome-nodejs: delightful node.js packages and resources",charsets:{cjk:!0},lastUpdated:"2022/04/29, 00:44:35",lastUpdatedTimestamp:1651164275e3},{title:"",frontmatter:{title:"",date:"2022-06-24T10:53:28.000Z",permalink:"/topic/index/",categories:["topic"],tags:[null]},regularPath:"/50.topic/0.index.html",relativePath:"50.topic/0.index.md",key:"v-4fe65767",path:"/topic/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/25, 18:09:57",lastUpdatedTimestamp:1656151797e3},{title:"",frontmatter:{title:"",date:"2022-06-24T11:22:51.000Z",permalink:"/topic/js2ts/index/",categories:["topic","ts2js"],tags:[null]},regularPath:"/50.topic/10.fromTs2Js/0.index.html",relativePath:"50.topic/10.fromTs2Js/0.index.md",key:"v-6fba7546",path:"/topic/js2ts/index/",readingTime:{text:"0 min read",minutes:0,time:0,words:0},headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/25, 18:09:57",lastUpdatedTimestamp:1656151797e3},{title:"Awesome NodeJS",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"40.node",imgUrl:"/assets/img/node.png",description:" NodeJS ......"}},title:"Awesome NodeJS",date:"2020-03-11T21:50:53.000Z",permalink:"/node/",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/999.%E7%9B%AE%E5%BD%95/20.node.html",relativePath:"999./20.node.md",key:"v-0790c155",path:"/node/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/29, 00:44:35",lastUpdatedTimestamp:1651164275e3},{title:"Awesome Web",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"30.web",imgUrl:"/assets/img/tech.png",description:" Web ......"}},title:"Awesome Web",date:"2020-03-11T21:50:53.000Z",permalink:"/web/",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/999.%E7%9B%AE%E5%BD%95/10.web.html",relativePath:"999./10.web.md",key:"v-97306cda",path:"/web/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"50.topic",imgUrl:"/assets/img/more.png",description:"......"}},title:"",date:"2020-03-11T21:50:53.000Z",permalink:"/topic/",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/999.%E7%9B%AE%E5%BD%95/30.topic.html",relativePath:"999./30.topic.md",key:"v-6cc4c933",path:"/topic/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/25, 18:09:57",lastUpdatedTimestamp:1656151797e3},{title:"",frontmatter:{archivesPage:!0,title:"",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-d744eac6",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"",frontmatter:{categoriesPage:!0,title:"",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-2bac39fd",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"",frontmatter:{tagsPage:!0,title:"",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-39df881d",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"Q&A",frontmatter:{title:"Q&A",date:"2022-01-11T14:03:46.000Z",permalink:"/qa/",categories:[null],tags:[null],sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/Q&A.html",relativePath:"Q&A.md",key:"v-75a63fbd",path:"/qa/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:21},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:38}],readingTime:{text:"1 min read",minutes:.03,time:1799.9999999999998,words:6},headersStr:"  ",content:"# \n\n\n# \n\n\n# ",normalizedContent:"# \n\n\n# \n\n\n# ",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"Home",frontmatter:{home:!0,heroText:"Fancy Front End",tagline:" ReactVue ",actionText:" ",actionLink:"/react/index/",bannerBg:"auto",features:[{title:"React",details:"hooks...",link:"/react/index",imgUrl:"/assets/img/react.svg"},{title:"Vue3",details:"runtime-coreruntime-domcompiler...",link:"/vue3/index",imgUrl:"/assets/img/vue.svg"},{title:"",details:"qiankunsingle-spavite...",link:"/web/index",imgUrl:"/assets/img/tech.png"}],postList:"detailed"},regularPath:"/",relativePath:"index.md",key:"v-2af0da94",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/01, 10:17:14",lastUpdatedTimestamp:1651371434e3},{title:"",frontmatter:{title:"",date:"2022-01-11T14:03:46.000Z",permalink:"/nav/",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/%E5%AF%BC%E8%88%AA%E7%AB%99.html",relativePath:".md",key:"v-7d3a31b9",path:"/nav/",headers:[{level:2,title:"Fancy ",slug:"fancy-",normalizedTitle:"fancy ",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:15}],readingTime:{text:"1 min read",minutes:.635,time:38100,words:127},headersStr:"Fancy  ",content:"# Fancy \n\n\n# ",normalizedContent:"# fancy \n\n\n# ",charsets:{cjk:!0},lastUpdated:"2022/08/01, 20:37:47",lastUpdatedTimestamp:1659357467e3},{title:"",frontmatter:{title:"",date:"2022-01-11T14:03:46.000Z",permalink:"/about/",categories:[null],tags:[null],sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/%E5%85%B3%E4%BA%8E.html",relativePath:".md",key:"v-d2407716",path:"/about/",headers:[{level:2,title:"",slug:"",normalizedTitle:"",charIndex:2},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:11},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:23},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:270},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:279},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:288},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:296},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:304},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:313}],readingTime:{text:"1 min read",minutes:.11,time:6600,words:22},headersStr:"        ",content:"# \n\n\n# \n\n\n# \n\n\n\n> \n\n ?   \n\n\n# \n\n\n# \n\n\n# \n\n\n# \n\n\n# \n\n\n# ",normalizedContent:"# \n\n\n# \n\n\n# \n\n\n\n> \n\n ?   \n\n\n# \n\n\n# \n\n\n# \n\n\n# \n\n\n# \n\n\n# ",charsets:{cjk:!0},lastUpdated:"2022/04/18, 20:57:27",lastUpdatedTimestamp:1650286647e3},{title:"prefetch",frontmatter:{title:"prefetch",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/core/prefetch/",categories:["qiankun","core"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/10.core/40.prefetch.html",relativePath:"30.web/6.qiankun/10.core/40.prefetch.md",key:"v-6196523d",path:"/qiankun/core/prefetch/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"Effects",frontmatter:{title:"Effects",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/core/effects/",categories:["qiankun","core"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/10.core/30.effects.html",relativePath:"30.web/6.qiankun/10.core/30.effects.md",key:"v-5d5e22bf",path:"/qiankun/core/effects/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3}],themeConfig:{nav:[{text:"React",link:"/react/index/",items:[{text:"",link:"/react/index/"},{text:"",link:"/react/basic/index/"},{text:"Scheduler",link:"/react/scheduler/index/"},{text:"Updater",link:"/react/updater/index/"},{text:"Render",link:"/react/render/index/"},{text:"",link:"/react/update/index/"},{text:"hooks ",link:"/react/hooks/index/"},{text:"",link:"/react/summary/index/"},{text:" React",link:"/react/tour/index/"}]},{text:"Vue3",link:"/vue3/index/",items:[{text:"",link:"/vue3/index/"},{text:"",link:"/vue3/basic/index/"},{text:"reactivity",link:"/vue3/reactivity/index/"},{text:"runtime-core",link:"/vue3/runtime-core/index/"},{text:"runtime-dom",link:"/vue3/runtime-dom/index/"}]},{text:"",link:"/web/",items:[{text:"Awesome Web",link:"/web/"},{text:"Awesome NodeJS",link:"/node/"}]},{text:"",link:"/topic/"},{text:"",link:"/nav/",items:[{text:"",link:"/nav/"},{text:"Q&A",link:"/qa/"},{text:"",link:"/slides/#/1"},{text:"",link:"/about/"}]},{text:"",link:"/archives/",items:[{text:"",link:"/categories/"},{text:"",link:"/tags/"},{text:"",link:"/archives/"}]},{text:"",link:"https://www.jonsam.site"}],sidebarDepth:1,logo:"/assets/img/logo.png",repo:"jonsam-ng/fancy-front-end",searchMaxSuggestions:10,lastUpdated:"",docsDir:"docs",editLinks:!0,editLinkText:"",category:!0,tag:!0,archive:!0,categoryText:"",titleBadge:!0,contentBgStyle:6,updateBar:{showToArticle:!0,moreArticle:"/archives"},rightMenuBar:!0,sidebarOpen:!0,pageButton:!0,sidebar:{"/10.react/":[["0.index.md","","/react/index/"],["1.plan.md","plan ","/react/plan/"],{title:"",collapsable:!0,children:[["10./0.index.md","","/react/basic/"],["10./10.chapter.md","","/react/basic/chapter/"],["10./20.faq.md","F&Q","/react/basic/faq/"],["10./30.ReactChildren.md","ReactChildren","/react/basic/children/"],["10./40.ReactElement.md","ReactElement","/react/basic/element/"]]},{title:"Reconciliation",collapsable:!0,children:[["20.Reconciliation/0.index.md","","/react/reconciliation/index/"],["20.Reconciliation/10.fiber.md","Fiber  Reconciliation","/react/reconciliation/fiber/"],["20.Reconciliation/20.reactChildFiber.md","ReactChildFiber ","/react/reconciliation/reactChildFiber/"],["20.Reconciliation/30.expirationTime.md","expirationTime","/react/reconciliation/expirationTime/"],["20.Reconciliation/40.scheduleWork.md","scheduleWork","/react/reconciliation/scheduleWork/"],["20.Reconciliation/50.lane.md","Lane ","/react/reconciliation/lane/"]]},{title:"Scheduler",collapsable:!0,children:[["30.Scheduler/0.index.md","","/react/scheduler/index/"],["30.Scheduler/10.scheduleCallback.md","scheduleCallback","/react/scheduler/scheduleCallback/"],["30.Scheduler/20.schedulerHostConfig.md","schedulerHostConfig","/react/scheduler/schedulerHostConfig/"],["30.Scheduler/30.scheduler.md","scheduler  API","/react/scheduler/scheduler/"]]},{title:"Updater",collapsable:!0,children:[["40.Updater/0.index.md","","/react/updater/index/"],["40.Updater/10.workloop.md","workLoop  performUnitOfWork","/react/updater/workloop/"]]},{title:"Render",collapsable:!0,children:[["50.Render/0.index.md","","/react/render/index/"],["50.Render/10.ReactDOM.md","ReactDOM.render ","/react/render/render/"]]},{title:"hooks",collapsable:!0,children:[["70.hooks/0.index.md","","/react/hooks/index/"],["70.hooks/10.useState.md","useState  useReducer","/react/hooks/useState/"],["70.hooks/20.useEffect.md","useEffect","/react/hooks/useEffect/"],["70.hooks/30.useRef.md","useRef ","/react/hooks/useRef/"]]},{title:"",collapsable:!0,children:[["80./0.index.md","","/react/summary/index/"],["80./10.bitOperation.md","","/react/summary/bitOperation/"],["80./20.first-render.md","React ","/react/summary/first-render/"],["80./30.event-listener.md","React ","/react/summary/event-listener/"],["80./40.10-min-react.md","30  React ","/react/summary/10-min-react/"]]},{title:"React",collapsable:!0,children:[["90.React/0.index.md","","/react/tour/index/"],["90.React/1.Plan.md","Plan ","/react/tour/plan/"],["90.React/2.talk.md","","/react/tour/talk/"],["90.React/10.react-basic-element.md","React ReactElement ","/react/tour/react-basic-element/"],["90.React/20.react-basic-children.md","React ReactChildren ","/react/tour/react-basic-children/"],["90.React/30.react-basic-view.md","React React ","/react/tour/react-basic-glimpse/"],["90.React/90.react-reconciliation-1.md","React React ","/react/tour/react-reconciliation-1/"],["90.React/100.react-reconciliation-2.md","React React ","/react/tour/react-reconciliation-2/"],["90.React/110.react-reconciliation-3.md","React React ","/react/tour/react-reconciliation-3/"],["90.React/120.react-reconciliation-4.md","React React ","/react/tour/react-reconciliation-4/"],["90.React/130.react-reconciliation-5.md","React React ","/react/tour/react-reconciliation-5/"],["90.React/140.react-reconciliation-6.md","React React ","/react/tour/react-reconciliation-6/"],["90.React/150.react-reconciliation-7.md","React React ","/react/tour/react-reconciliation-7/"],["90.React/160.react-reconciliation-8.md","React React ","/react/tour/react-reconciliation-8/"],["90.React/170.react-reconciliation-9.md","React React ","/react/tour/react-reconciliation-9/"],["90.React/180.react-reconciliation-10.md","React React ","/react/tour/react-reconciliation-10/"],["90.React/300.react-scheduler-1.md","React React ","/react/tour/react-scheduler-1/"],["90.React/900.react-docs-reading-1.md"," React ","/react/tour/dr-1/"],["90.React/910.react-docs-reading-2.md"," React ","/react/tour/dr-2/"]]}],catalogue:{web:"/web/",node:"/node/",topic:"/topic/"},"/20.vue3/":[["0.index.md","","/vue3/index/"],["1.plan.md","plan ","/vue3/plan/"],{title:"",collapsable:!0,children:[["10./0.index.md","","/vue3/basic/index/"]]},{title:"reactivity",collapsable:!0,children:[["20.reactivity/0.index.md","","/vue3/reactivity/index/"],["20.reactivity/10.ref.md","Ref","/vue3/reactivity/ref/"],["20.reactivity/20.reactive.md","Reactive","/vue3/basic/reactive/"],["20.reactivity/30.handler.md","Handler","/vue3/basic/handler/"],["20.reactivity/40.effect.md","Effect","/vue3/basic/effect/"],["20.reactivity/50.computed.md","Computed","/vue3/basic/computed/"]]},{title:"runtime-core",collapsable:!0,children:[["30.runtime-core/0.index.md","","/vue3/runtime-core/index/"]]},{title:"runtime-dom",collapsable:!0,children:[["40.runtime-dom/0.index.md","","/vue3/runtime-dom/index/"],["40.runtime-dom/10.apiCreateApp.md","apiCreateApp","/vue3/runtime-dom/apiCreateApp/"],["40.runtime-dom/20.apiDefineComponent.md","apiDefineComponent","/vue3/runtime-dom/apiDefineComponent/"],["40.runtime-dom/90.scheduler.md","scheduler","/pages/286896/"]]}],"/30.web/":[["0.index.md","","/web/index/"],["1.plan.md","Plan ","/web/plan/"],{title:"typescript-utility",collapsable:!0,children:[["4.typescript-utility/0.index.md","","/ts/index/"],{title:"",collapsable:!0,children:[["4.typescript-utility/10./0.index.md","","/ts/basic/index/"],["4.typescript-utility/10./10.basic-types.md","basic-types ","/ts/basic/basic-types/"],["4.typescript-utility/10./20.type-manipulation.md","type-manipulation ","/ts/basic/type-manipulation/"],["4.typescript-utility/10./30.classes.md","classes ","/ts/basic/classes/"],["4.typescript-utility/10./40.reference.md","reference ","/ts/basic/reference/"],["4.typescript-utility/10./50.type-zoo.md","type-zoo","/ts/basic/type-zoo/"]]},{title:"",collapsable:!0,children:[["4.typescript-utility/20./0.index.md","","/ts/utility/index/"],["4.typescript-utility/20./10.basic.md","Basic Utility Types","/ts/utility/basic/"],["4.typescript-utility/20./20.mapped-types.md","Mapped Types","/ts/utility/mapped/"]]}]},{title:"single-spa",collapsable:!0,children:[["5.single-spa/0.index.md","","/single-spa/index/"],{title:"app",collapsable:!0,children:[["5.single-spa/10.app/0.index.md","","/single-spa/app/index/"],["5.single-spa/10.app/10.apps.md","Apps","/single-spa/app/apps/"]]},{title:"lifecycles",collapsable:!0,children:[["5.single-spa/20.lifecycles/0.index.md","","/single-spa/lifecycle/index/"],["5.single-spa/20.lifecycles/10.load.md","load  unload","/single-spa/lifecycle/load/"],["5.single-spa/20.lifecycles/20.bootstrap.md","bootstrap","/single-spa/lifecycle/bootstrap/"],["5.single-spa/20.lifecycles/30.mount.md","mount  unmount","/single-spa/lifecycle/mount/"],["5.single-spa/20.lifecycles/40.update.md","update","/single-spa/lifecycle/update/"]]},{title:"navigation",collapsable:!0,children:[["5.single-spa/30.navigation/0.index.md","","/single-spa/nav/index/"],["5.single-spa/30.navigation/10.navigation-events.md","navigation-events ","/single-spa/nav/events/"],["5.single-spa/30.navigation/20.reroute.md","reroute ","/single-spa/nav/reroute/"]]},{title:"parcel",collapsable:!0,children:[["5.single-spa/40.parcel/0.index.md","","/single-spa/nav/parcel/"]]},{title:"",collapsable:!0,children:[["5.single-spa/50./0.index.md","","/single-spa/other/index/"],["5.single-spa/50./10.customEvent.md","customEvent","/single-spa/other/customEvent/"],["5.single-spa/50./20.error.md","","/single-spa/other/error/"]]},{title:"single-spa-react",collapsable:!0,children:[["5.single-spa/60.single-spa-react/0.index.md","","/single-spa/spa-react/index/"]]}]},{title:"qiankun",collapsable:!0,children:[["6.qiankun/0.index.md","","/qiankun/index/"],{title:"core",collapsable:!0,children:[["6.qiankun/10.core/0.index.md","","/qiankun/core/index/"],["6.qiankun/10.core/10.apis.md"," API","/qiankun/core/apis/"],["6.qiankun/10.core/20.loader.md","loadApp ","/qiankun/core/loader/"],["6.qiankun/10.core/30.effects.md","Effects","/qiankun/core/effects/"],["6.qiankun/10.core/40.prefetch.md","prefetch","/qiankun/core/prefetch/"],["6.qiankun/10.core/50.globalState.md","globalState","/qiankun/core/globalState/"],["6.qiankun/10.core/60.addon.md","addon","/qiankun/core/addon/"]]},{title:"sandbox",collapsable:!0,children:[["6.qiankun/20.sandbox/0.index.md","","/qiankun/sandbox/index/"],["6.qiankun/20.sandbox/10.sandbox.md","createSandboxContainer ","/qiankun/sandbox/sandbox/"],["6.qiankun/20.sandbox/20.proxySandbox.md","proxySandbox","/qiankun/sandbox/proxySandbox/"],["6.qiankun/20.sandbox/30.snapshotSandbox.md","snapshotSandbox","/qiankun/sandbox/snapshotSandbox/"]]},["6.qiankun/999.import-html-entry.md","import-html-entry ","/qiankun/import-html-entry/"]]},{title:"webpack",collapsable:!0,children:[["7.webpack/0.index.md","","/webpack/init/"],{title:"tapable",collapsable:!0,children:[["7.webpack/10.tapable/0.index.md","","/webpack/tapable/index"],["7.webpack/10.tapable/10.api.md","Api","/webpack/tapable/api/"],["7.webpack/10.tapable/20.Hook.md","Hook","/webpack/tapable/hook/"],["7.webpack/10.tapable/30.HookCodeFactory.md","HookCodeFactory","/webpack/tapable/factory/"]]},{title:"init",collapsable:!0,children:[["7.webpack/20.init/0.index.md","","/webpack/init/index/"],["7.webpack/20.init/10.compiler.md","init compiler","/webpack/init/compiler/"],["7.webpack/20.init/20.options.md","init options","/webpack/init/options/"]]},{title:"make",collapsable:!0,children:[["7.webpack/30.make/0.index.md","","/webpack/make/index/"],["7.webpack/30.make/10.compilation.md","make compilation","/webpack/make/compilation/"],["7.webpack/30.make/20.module.md","make module","/webpack/make/module/"],["7.webpack/30.make/30.walk.md","make walk","/webpack/make/walk/"]]},{title:"",collapsable:!0,children:[["7.webpack/100./10.dp.md","Webpack","/webpack/summary/dp/"],["7.webpack/100./20.ds.md","Webpack ","/webpack/summary/ds/"]]}]},{title:"axios",collapsable:!0,children:[["8.axios/0.index.md","","/axios/index/"],{title:"core",collapsable:!0,children:[["8.axios/10.core/0.index.md","","/axios/core/index/"],["8.axios/10.core/10.axios.md","axios ","/axios/core/instance/"],["8.axios/10.core/20.adapter.md","adapter ","/axios/core/adapter/"],["8.axios/10.core/30.interceptor.md","interceptor ","/axios/core/interceptor/"],["8.axios/10.core/40.cancel.md","cancel ","/axios/core/cancel/"]]}]},{title:"solid",collapsable:!0,children:[["9.solid/0.index.md","","/solid/index/"],["9.solid/1.plan.md","","/solid/plan/"],{title:"",collapsable:!0,children:[["9.solid/10./10.render-jsx.md"," JSX ","/solid/render/render-by-jsx"]]}]},{title:"vite",collapsable:!0,children:[["10.vite/0.index.md","","/vite/index/"],{title:"",collapsable:!0,children:[["10.vite/10./0.index.md","","/vite/basic/index/"]]},{title:"vite",collapsable:!0,children:[["10.vite/20.vite/0.index.md","","/vite/core/index/"],["10.vite/20.vite/10.cli.md","clivite ","/vite/core/cli/"],["10.vite/20.vite/20.server.md","server dev server ","/vite/core/server/"]]}]},{title:"jquery",collapsable:!0,children:[["50.jquery/0.index.md","","/jquery/index/"],["50.jquery/10.jq-book.md","JQuery ","/jquery/jq-book/"],["50.jquery/20.jq-source.md","JQuery ","/jquery/jq-source/"],["50.jquery/30.extend.md","jQuery ","/jquery/extend/"]]},{title:"snabbdom",collapsable:!0,children:[["60.snabbdom/0.index.md","","/pages/ba82e2/"],{title:"core",collapsable:!0,children:[["60.snabbdom/10.core/10.init.md","init","/pages/cf8075/"],["60.snabbdom/10.core/20.h.md","h","/pages/69bbdd/"],["60.snabbdom/10.core/30.jsx.md","jsx","/pages/fa7d5d/"],["60.snabbdom/10.core/40.vnode.md","vnode","/pages/3f1101/"],["60.snabbdom/10.core/50.thunk.md","thunk","/pages/d02874/"]]},{title:"helper",collapsable:!0,children:[["60.snabbdom/30.helper/10.attachto.md","attachto","/pages/903ddd/"]]}]},{title:"am-editor",collapsable:!0,children:[["70.am-editor/0.index.md","","/pages/08c8a2/"],{title:"engine",collapsable:!0,children:[["70.am-editor/10.engine/0.index.md","index","/pages/da29c0/"],["70.am-editor/10.engine/10.engine-basic.md","engine-basic","/pages/33f539/"],["70.am-editor/10.engine/20.engine.md","engine","/pages/518dfe/"],["70.am-editor/10.engine/30.container.md","container","/pages/a35554/"],["70.am-editor/10.engine/40.change.md","change","/pages/53c865/"],["70.am-editor/10.engine/50.range.md","range","/pages/7f2a93/"]]}]},{title:"html2canvas",collapsable:!0,children:[["80.html2canvas/0.index.md","","/pages/b58110/"]]},{title:"express",collapsable:!0,children:[["160.express/0.index.md","","/express/index/"]]},{title:"acorn",collapsable:!0,children:[["170.acorn/0.index.md","","/acorn/index/"]]},{title:"immutable.js",collapsable:!0,children:[["180.immutable.js/0.index.md","","/immutable/index/"]]}],"/40.node/":[["0.index.md","","/node/index/"],["1.plan.md","Plan ","/node/plan/"],["2.roadmap.md","roadmap","/node/roadmap/"]],"/50.topic/":[["0.index.md","","/topic/index/"],{title:"fromTs2Js",collapsable:!0,children:[["10.fromTs2Js/0.index.md","","/topic/js2ts/index/"]]}],"/999./":[["10.web.md","Awesome Web","/web/"],["20.node.md","Awesome NodeJS","/node/"],["30.topic.md","","/topic/"]]},author:{name:"jonsam",link:"https://github.com/jonsam-ng"},blogger:{avatar:"https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/oxygen-space/image.5a0lthv367k0.png",name:"Jonsam NG",slogan:""},social:{icons:[{iconClass:"icon-youjian",title:"",link:"mailto:jonsam.ng@foxmail.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/jonsam-ng"},{iconClass:"icon-mao",title:"",link:"https://www.jonsam.site"},{iconClass:"icon-shuben",title:"",link:"https://docs.jonsam.site"},{iconClass:"icon-code",title:"",link:"https://ml.jonsam.site"}]},footer:{createYear:2022,copyrightInfo:'Fancy Front End | Made by <a href="https://www.jonsam.site" target="_blank">Jonsam</a> by '},htmlModules:{}},locales:{"/":{lang:"zh-CN",title:"Fancy Front End",description:" ReactVue3 ",path:"/"}}};var at=t(52),it=t(51),st=t(106);let lt=!1;var ct={data:()=>({qr:null}),updated(){if(!lt||!this.qr)return;const n=document.querySelector(".nav-links"),e=document.querySelector(".qrcodeBtn");null!=n&&null==e&&this.$nextTick(()=>{const e=document.createElement("DIV");e.className+="nav-item",e.appendChild(this.qr.$el),n.appendChild(e)})},mounted(){if(this.qr||lt)return;lt=!0;const n=new(r.default.extend(st.default));n.$mount(),this.qr=n}};let pt=!1;var dt={mounted(){pt||(window.addEventListener("unload",this.saveLastReading),pt=!0)},methods:{saveLastReading(){localStorage.setItem("lastReading",JSON.stringify({path:this.$route.path,scrollTop:document.documentElement.scrollTop,timestamp:(new Date).getTime()}))}}};let ut=!1;var mt={mounted(){ut||(t.e(189).then(t.t.bind(null,370,7)).then((function(n){r.default.use(n.default,{lang:"zh-CN"})})),ut=!0)}},ht=t(107),ft=t(108),gt=(t(20),t(13));var yt={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:r}}=n;return!(e||!1===t||!0===r)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(gt.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(gt.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(gt.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let r=0,o=n.length;r<o;r++){const{frontmatter:{categories:o,tags:a}}=n[r];"array"===Object(gt.n)(o)&&o.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}),"array"===Object(gt.n)(a)&&a.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};r.default.component(ht.default),r.default.component(ft.default);function bt(n){return n.toString().padStart(2,"0")}t(258);r.default.component("Badges",()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,379))),r.default.component("Bilibili",()=>Promise.resolve().then(t.bind(null,51))),r.default.component("BlockToggle",()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,380))),r.default.component("Card",()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,381))),r.default.component("ClipboardComponent",()=>t.e(14).then(t.bind(null,382))),r.default.component("FontResizer",()=>Promise.all([t.e(0),t.e(7)]).then(t.bind(null,383))),r.default.component("GlobalTip",()=>Promise.all([t.e(0),t.e(8)]).then(t.bind(null,384))),r.default.component("LastReadingPopup",()=>Promise.resolve().then(t.bind(null,52))),r.default.component("Pdf",()=>Promise.all([t.e(0),t.e(3),t.e(9)]).then(t.bind(null,385))),r.default.component("QrCode",()=>Promise.resolve().then(t.bind(null,106))),r.default.component("TimeToRead",()=>Promise.all([t.e(0),t.e(10)]).then(t.bind(null,386))),r.default.component("VideoPlayer",()=>t.e(15).then(t.bind(null,387))),r.default.component("Badge",()=>Promise.all([t.e(0),t.e(12)]).then(t.bind(null,556))),r.default.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,107))),r.default.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,108)));t(259);class vt{constructor(n){Object.defineProperty(this,"registration",{value:n,configurable:!0,writable:!0})}update(){return this.registration.update()}skipWaiting(){const n=this.registration.waiting;return n?(console.log("[vuepress:sw] Doing worker.skipWaiting()."),new Promise((e,t)=>{const r=new MessageChannel;r.port1.onmessage=n=>{console.log("[vuepress:sw] Done worker.skipWaiting()."),n.data.error?t(n.data.error):e(n.data)},n.postMessage({type:"skip-waiting"},[r.port2])})):Promise.resolve()}}var kt=t(15);r.default.component("SWUpdatePopup",()=>Promise.all([t.e(0),t.e(11)]).then(t.bind(null,376)));t(260);var wt=t(105),xt=t.n(wt),Tt=t(32);let Ct,Rt;var Et;"valine"===(Et="gitalk")?t.e(188).then(t.t.bind(null,372,7)).then(n=>Rt=n.default):"gitalk"===Et&&Promise.all([t.e(0),t.e(186)]).then(t.t.bind(null,373,7)).then(()=>t.e(185).then(t.t.bind(null,374,7))).then(n=>Ct=n.default);function St(n,e){const t={};return Reflect.ownKeys(n).forEach(r=>{if("string"==typeof n[r])try{t[r]=xt.a.render(n[r],e)}catch(e){console.warn(`Comment config option error at key named "${r}"`),console.warn("More info: "+e.message),t[r]=n[r]}else t[r]=n[r]}),t}console.log(`How to use "gitalk" in ${Tt.name}@v${Tt.version}:`,Tt.homepage);const Pt={gitalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t);new Ct(St({clientID:"d3180fd85e7addd9c036",clientSecret:"933c6df009c1d8264e247ce9c1a68687dff0b5f6",repo:"fancy-front-end",owner:"jonsam-ng",admin:["jonsam-ng"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},valine:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new Rt({...St({clientID:"d3180fd85e7addd9c036",clientSecret:"933c6df009c1d8264e247ce9c1a68687dff0b5f6",repo:"fancy-front-end",owner:"jonsam-ng",admin:["jonsam-ng"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}}},_t="vuepress-plugin-comment";let It=null;function jt(n){return Pt.gitalk.clear(_t)}function Ot(n){return!1!==n.comment&&!1!==n.comments}function Ft(n){clearTimeout(It);if(document.querySelector("main.page"))return Pt.gitalk.render(n,_t);It=setTimeout(()=>Ft(n),200)}var At={mounted(){It=setTimeout(()=>{const n={to:{},from:{},...this.$frontmatter};jt()&&Ot(n)&&Ft(n)},1e3),this.$router.afterEach((n,e)=>{if(n&&e&&n.path===e.path)return;const t={to:n,from:e,...this.$frontmatter};jt()&&Ot(t)&&Ft(t)})}},Mt=Object(et.a)(At,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,Dt=(t(266),t(267),!0),zt="lazy",qt="200px",Lt=[({Vue:n,options:e,router:t,siteData:r,isServer:o})=>{const{options:a}=t;n.component(at.default.name,at.default),n.component(it.default.name,it.default),n.mixin(dt),n.mixin(ct),n.mixin(mt)},({Vue:n,options:e,router:t,siteData:r})=>{r.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${bt(n.getUTCMonth()+1)}-${bt(n.getUTCDate())} ${bt(n.getUTCHours())}:${bt(n.getUTCMinutes())}:${bt(n.getUTCSeconds())}`}(e)),t?n.author=t:r.themeConfig.author&&(n.author=r.themeConfig.author)}),n.mixin(yt)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},async({router:n,isServer:e})=>{if(!e){const{register:e}=await t.e(187).then(t.bind(null,371));n.onReady(()=>{e("/service-worker.js",{registrationOptions:{},ready(){console.log("[vuepress:sw] Service worker is active."),kt.a.$emit("sw-ready")},cached(n){console.log("[vuepress:sw] Content has been cached for offline use."),kt.a.$emit("sw-cached",new vt(n))},updated(n){console.log("[vuepress:sw] Content updated."),kt.a.$emit("sw-updated",new vt(n))},offline(){console.log("[vuepress:sw] No internet connection found. App is running in offline mode."),kt.a.$emit("sw-offline")},error(n){console.error("[vuepress:sw] Error during service worker registration:",n),kt.a.$emit("sw-error",n),GA_ID&&ga("send","exception",{exDescription:n.message,exFatal:!1})}})})}},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?634139bf8239f41da83be0a03473f9ff";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},({Vue:n})=>{n.component("Comment",Mt)},{},({Vue:n})=>{n.mixin({data:()=>({$io:void 0}),mounted(){const n=document.querySelectorAll("img."+zt);Dt&&"loading"in HTMLImageElement.prototype?n.forEach(n=>{!n.getAttribute("src")&&n.setAttribute("src",n.getAttribute("data-src"))}):(this.setObserver(),n.forEach(n=>{this.$io.observe(n)}))},methods:{setObserver(){this.$io=new IntersectionObserver(n=>{n.forEach(n=>{if(n.isIntersecting){const e=this.getSrc(n.target);e&&(n.target.src=e),this.$io.unobserve(n.target)}})},{rootMargin:qt})},getSrc(n){if(n.dataset)return n.dataset.src;{const e=n.attributes.find(n=>"data-src"===n.nodeName);return e&&e.nodeValue}}}})}],Ut=["SWUpdatePopup","Comment","LastReadingPopup","GlobalTip","BlockToggle"];class Nt extends class{constructor(){this.store=new r.default({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){r.default.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Nt.prototype,{getPageAsyncComponent:Gn.d,getLayoutAsyncComponent:Gn.c,getAsyncComponent:Gn.b,getVueComponent:Gn.e});var Ht={install(n){const e=new Nt;n.$vuepress=e,n.prototype.$vuepress=e}};function Wt(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Bt={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return Object(Gn.h)("pageKey",e),r.default.component(e)||r.default.component(e,Object(Gn.d)(e)),r.default.component(e)?n(e):n("")}},$t={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Vt={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Kt=(t(268),t(269),Object(et.a)(Vt,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Jt={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};r.default.config.productionTip=!1,r.default.use(Kn),r.default.use(Ht),r.default.mixin(function(n,e,t=r.default){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const o=new(n(t.$vuepress.$get("siteData"))),a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(o)),i={};return Object.keys(a).reduce((n,e)=>(e.startsWith("$")&&(n[e]=a[e].get),n),i),{computed:i}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},ot)),r.default.component("Content",Bt),r.default.component("ContentSlotsDistributor",$t),r.default.component("OutboundLink",Kt),r.default.component("ClientOnly",Jt),r.default.component("Layout",Object(Gn.c)("Layout")),r.default.component("NotFound",Object(Gn.c)("NotFound")),r.default.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.7",hash:"bafe71e"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:ot.routerBase||ot.base,t=new Kn({base:e,mode:"history",fallback:!1,routes:rt,scrollBehavior:(n,e,t)=>t||(n.hash?!r.default.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(Wt(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Wt(n,t)?r(t):r()}else r();else{const t=e.path+"/",o=e.path+".html";Wt(n,o)?r(o):Wt(n,t)?r(t):r()}})}(t);const o={};try{await Promise.all(Lt.filter(n=>"function"==typeof n).map(e=>e({Vue:r.default,options:o,router:t,siteData:ot,isServer:n})))}catch(n){console.error(n)}return{app:new r.default(Object.assign(o,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Ut.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);