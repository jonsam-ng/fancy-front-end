(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,i,s=e[0],l=e[1],c=e[2],d=0,u=[];d<s.length;d++)i=s[d],Object.prototype.hasOwnProperty.call(o,i)&&o[i]&&u.push(o[i][0]),o[i]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(p&&p(e);u.length;)u.shift()();return a.push.apply(a,c||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==o[l]&&(r=!1)}r&&(a.splice(e--,1),n=i(i.s=t[0]))}return n}var r={},o={1:0},a=[];function i(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=o[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=o[n]=[e,r]}));e.push(t[2]=r);var a,s=document.createElement("script");s.charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.src=function(n){return i.p+"assets/js/"+({}[n]||n)+"."+{2:"01e091c2",3:"50570587",4:"54e60667",5:"f620477b",6:"8880bb8c",7:"0c293177",8:"7cbef5ec",9:"2a7e5bdc",10:"ac472f43",11:"c50183f9",12:"71337abb",13:"292db5f6",14:"54d2636a",15:"81d908ff",16:"68d8e787",17:"895175dc",18:"736b781d",19:"504bd141",20:"e526fb51",21:"8375d39e",22:"0e15b626",23:"83bcc15c",24:"3df554ce",25:"6c56da2b",26:"76154857",27:"155dbcb4",28:"7178e96c",29:"f7337396",30:"191545d3",31:"b6a0fe90",32:"18cebeab",33:"146782c3",34:"c08af9cb",35:"ea730de0",36:"11aba0b0",37:"0fd8e20a",38:"2cde6902",39:"07c230cc",40:"e4fcccd0",41:"5f96c201",42:"e5023440",43:"2cfdc8d9",44:"37f32c52",45:"3973ea4b",46:"87541312",47:"04f0011f",48:"1151f311",49:"6830fb0c",50:"84b34574",51:"840f38c4",52:"3dbda6e7",53:"7f0a8896",54:"5d7f6427",55:"86c7b544",56:"49a27b9a",57:"287f9e58",58:"40a49fdb",59:"91487422",60:"8dfd58ee",61:"7b4874b9",62:"d83f3691",63:"1237a900",64:"1f096a25",65:"809d988d",66:"43c1e5f9",67:"24ab137d",68:"7b0346b5",69:"2008c989",70:"e8cf3232",71:"d661943d",72:"e67a47a3",73:"87f1db52",74:"ac67cd0d",75:"e25ebf69",76:"a7222468",77:"ffb71305",78:"72c00bee",79:"66ec368e",80:"8792d3d7",81:"49d3731a",82:"fbe09e61",83:"220a02bb",84:"4b722410",85:"f83d2db9",86:"17b19d53",87:"37568307",88:"d7cc6612",89:"ffb378d0",90:"02c91127",91:"c22d9224",92:"c79d457a",93:"33a03732",94:"c73ddbbc",95:"a5151497",96:"b8f204d2",97:"d7ddaa6f",98:"49dbda5e",99:"d14f43ad",100:"8081075e",101:"943ea683",102:"11c8554c",103:"c2780521",104:"81994794",105:"f987244b",106:"235a578e",107:"94cdbb18",108:"3a80cb29",109:"8884be03",110:"89ab5eb2",111:"355b1782",112:"34671c87",113:"0cca0902",114:"01616168",115:"4915c0b5",116:"ef93855a",117:"e3526ed0",118:"7d52a4ea",119:"a4bb17bb",120:"135aa6ea",121:"86c35c15",122:"1452986d",123:"0181b553",124:"edc508f8",125:"46d932c1",126:"17e05a12",127:"98159dfe",128:"9aaa5bc6",129:"26bed928",130:"9f74c846",131:"d6ef0885",132:"1d9ee075",133:"2b23ed7b",134:"c47e8a23",135:"2aeb3426",136:"0169c47b",137:"70cdfc24",138:"e54160ee",139:"9a6d1932",140:"ddabaeca",141:"35844ecc",142:"4ccdb5e4",143:"37a7f36e",144:"95ff6a63",145:"9899e545",146:"6865658b",147:"2a55d18a",148:"f3aab640",149:"57b565a0",150:"3f7143ae",151:"5981cf9e",152:"a3428a7b",153:"0f0b339d",154:"39f3b522",155:"13c8170a",156:"ccb66614",157:"4b8bce50",158:"6476dd1c",159:"b261a009",160:"e501007d",161:"d3f56d3d",162:"f8590797",163:"91fe4509",164:"6e92f3f4",165:"56868a39",166:"83812a3b",167:"4b528df4",168:"f2b151fb",169:"cb2ee128",170:"63b574e9",171:"ad38a311",172:"b592b97e",173:"302ef08b",174:"d71ad1a3",175:"2617c860",176:"19a67035",177:"75aab37d",178:"b2773712",179:"6a34b45f",180:"d447fc48",181:"d6b96886",182:"42c2bcd5",183:"a6256a82",184:"8a036f5a",185:"811d5831",186:"6436a583",187:"4bcf94a3",188:"33f39bd6",189:"c1b90840"}[n]+".js"}(n);var l=new Error;a=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=o[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+a+")",l.name="ChunkLoadError",l.type=r,l.request=a,t[1](l)}o[n]=void 0}};var c=setTimeout((function(){a({type:"timeout",target:s})}),12e4);s.onerror=s.onload=a,document.head.appendChild(s)}return Promise.all(e)},i.m=n,i.c=r,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)i.d(t,r,function(e){return n[e]}.bind(null,r));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/",i.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var p=l;a.push([116,0]),t()}([function(n,e,t){"use strict";t.d(e,"d",(function(){return b})),t.d(e,"c",(function(){return v})),t.d(e,"b",(function(){return k})),t.d(e,"e",(function(){return w})),t.d(e,"a",(function(){return x})),t.d(e,"f",(function(){return T})),t.d(e,"g",(function(){return C})),t.d(e,"h",(function(){return R}));t(20),t(144);var r=t(1),o={NotFound:()=>Promise.all([t.e(0),t.e(13)]).then(t.bind(null,377)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,375))},a={"v-376508bf":()=>t.e(16).then(t.bind(null,388)),"v-3611955d":()=>t.e(17).then(t.bind(null,389)),"v-0d7bb8be":()=>t.e(18).then(t.bind(null,390)),"v-359e682f":()=>t.e(19).then(t.bind(null,391)),"v-a1dbc2a2":()=>t.e(20).then(t.bind(null,392)),"v-406c3962":()=>t.e(21).then(t.bind(null,393)),"v-4b4b48ab":()=>t.e(22).then(t.bind(null,394)),"v-4d309ab6":()=>t.e(23).then(t.bind(null,395)),"v-1a05c896":()=>t.e(24).then(t.bind(null,396)),"v-27daf196":()=>t.e(25).then(t.bind(null,397)),"v-e4ff14f8":()=>t.e(26).then(t.bind(null,398)),"v-1daf77ea":()=>t.e(27).then(t.bind(null,399)),"v-7050b2a0":()=>t.e(28).then(t.bind(null,400)),"v-41adcea0":()=>t.e(29).then(t.bind(null,401)),"v-a7e4381c":()=>t.e(30).then(t.bind(null,402)),"v-fefa4114":()=>t.e(31).then(t.bind(null,403)),"v-21473796":()=>t.e(32).then(t.bind(null,404)),"v-492f4a82":()=>t.e(33).then(t.bind(null,405)),"v-1d8100c2":()=>t.e(34).then(t.bind(null,406)),"v-fcc2e96a":()=>t.e(35).then(t.bind(null,407)),"v-36e6278b":()=>t.e(36).then(t.bind(null,408)),"v-0fd7e2db":()=>t.e(37).then(t.bind(null,409)),"v-fda4440a":()=>t.e(38).then(t.bind(null,410)),"v-228419df":()=>t.e(39).then(t.bind(null,411)),"v-2778a33b":()=>t.e(40).then(t.bind(null,412)),"v-230de106":()=>t.e(41).then(t.bind(null,413)),"v-1154a3c8":()=>t.e(42).then(t.bind(null,414)),"v-35203ba8":()=>t.e(43).then(t.bind(null,415)),"v-59f008fe":()=>t.e(44).then(t.bind(null,416)),"v-5de90ac4":()=>t.e(45).then(t.bind(null,417)),"v-071d800b":()=>t.e(46).then(t.bind(null,418)),"v-7532101f":()=>t.e(47).then(t.bind(null,419)),"v-05b01242":()=>t.e(48).then(t.bind(null,420)),"v-1e97eeff":()=>t.e(49).then(t.bind(null,421)),"v-5962efbf":()=>t.e(50).then(t.bind(null,422)),"v-d7a41f02":()=>t.e(51).then(t.bind(null,423)),"v-620e1d82":()=>t.e(52).then(t.bind(null,424)),"v-09c3f1ff":()=>t.e(53).then(t.bind(null,425)),"v-448ef2bf":()=>t.e(54).then(t.bind(null,426)),"v-7f59f37f":()=>t.e(55).then(t.bind(null,427)),"v-8bb61782":()=>t.e(56).then(t.bind(null,428)),"v-4079c547":()=>t.e(57).then(t.bind(null,429)),"v-5585c5df":()=>t.e(58).then(t.bind(null,430)),"v-50140a3b":()=>t.e(59).then(t.bind(null,431)),"v-ec07c126":()=>t.e(60).then(t.bind(null,432)),"v-2d7c6c07":()=>t.e(61).then(t.bind(null,433)),"v-49f7f4ca":()=>t.e(62).then(t.bind(null,434)),"v-321a8dff":()=>t.e(63).then(t.bind(null,435)),"v-2e216f3f":()=>t.e(64).then(t.bind(null,436)),"v-1d06307d":()=>t.e(65).then(t.bind(null,437)),"v-cecea10e":()=>t.e(66).then(t.bind(null,438)),"v-620539aa":()=>t.e(67).then(t.bind(null,439)),"v-5d322c1d":()=>t.e(68).then(t.bind(null,440)),"v-dcaaef7a":()=>t.e(69).then(t.bind(null,441)),"v-4d69bd7d":()=>t.e(70).then(t.bind(null,442)),"v-eea5a8ce":()=>t.e(71).then(t.bind(null,443)),"v-7c3809bd":()=>t.e(72).then(t.bind(null,444)),"v-47f301c6":()=>t.e(73).then(t.bind(null,445)),"v-7844a83d":()=>t.e(74).then(t.bind(null,446)),"v-847c1376":()=>t.e(75).then(t.bind(null,447)),"v-36768879":()=>t.e(76).then(t.bind(null,448)),"v-af98cc06":()=>t.e(77).then(t.bind(null,449)),"v-7b4d74fd":()=>t.e(78).then(t.bind(null,450)),"v-50e647d9":()=>t.e(79).then(t.bind(null,451)),"v-26e7ba7d":()=>t.e(80).then(t.bind(null,452)),"v-566737cd":()=>t.e(81).then(t.bind(null,453)),"v-6e8687a2":()=>t.e(82).then(t.bind(null,454)),"v-7373c0fa":()=>t.e(83).then(t.bind(null,455)),"v-55a8d0bf":()=>t.e(84).then(t.bind(null,456)),"v-18766245":()=>t.e(85).then(t.bind(null,457)),"v-53f20ec6":()=>t.e(86).then(t.bind(null,458)),"v-4bc33869":()=>t.e(87).then(t.bind(null,459)),"v-687541db":()=>t.e(88).then(t.bind(null,460)),"v-6414adc6":()=>t.e(89).then(t.bind(null,461)),"v-2985970b":()=>t.e(90).then(t.bind(null,462)),"v-aef55d32":()=>t.e(91).then(t.bind(null,463)),"v-25439586":()=>t.e(92).then(t.bind(null,464)),"v-27eebe53":()=>t.e(93).then(t.bind(null,465)),"v-2080504b":()=>t.e(94).then(t.bind(null,466)),"v-057781cb":()=>t.e(95).then(t.bind(null,467)),"v-2af34dca":()=>t.e(96).then(t.bind(null,468)),"v-f790ca6e":()=>t.e(97).then(t.bind(null,469)),"v-1061317b":()=>t.e(98).then(t.bind(null,470)),"v-1ba4b31b":()=>t.e(99).then(t.bind(null,471)),"v-6b7f390c":()=>t.e(100).then(t.bind(null,472)),"v-3bded94c":()=>t.e(101).then(t.bind(null,473)),"v-0b29f556":()=>t.e(102).then(t.bind(null,474)),"v-70bd8ed4":()=>t.e(103).then(t.bind(null,475)),"v-5cc090d4":()=>t.e(104).then(t.bind(null,476)),"v-4dfd12d8":()=>t.e(105).then(t.bind(null,477)),"v-3336f808":()=>t.e(106).then(t.bind(null,478)),"v-3bd3e459":()=>t.e(107).then(t.bind(null,479)),"v-3bb59422":()=>t.e(108).then(t.bind(null,480)),"v-44bace4f":()=>t.e(109).then(t.bind(null,481)),"v-73517018":()=>t.e(110).then(t.bind(null,482)),"v-db70af54":()=>t.e(111).then(t.bind(null,483)),"v-e148fee0":()=>t.e(112).then(t.bind(null,484)),"v-6644dbd4":()=>t.e(113).then(t.bind(null,485)),"v-1bd41a5b":()=>t.e(114).then(t.bind(null,486)),"v-82122182":()=>t.e(116).then(t.bind(null,487)),"v-1401de91":()=>t.e(115).then(t.bind(null,488)),"v-1ff4e09f":()=>t.e(117).then(t.bind(null,489)),"v-f54ae5ba":()=>t.e(118).then(t.bind(null,490)),"v-52bd35e5":()=>t.e(119).then(t.bind(null,491)),"v-7c668ae7":()=>t.e(120).then(t.bind(null,492)),"v-6e596402":()=>t.e(121).then(t.bind(null,493)),"v-263cdfff":()=>t.e(125).then(t.bind(null,494)),"v-6646936e":()=>t.e(122).then(t.bind(null,495)),"v-4956ba5f":()=>t.e(126).then(t.bind(null,496)),"v-a0fcd902":()=>t.e(127).then(t.bind(null,497)),"v-b7416126":()=>t.e(128).then(t.bind(null,498)),"v-353fcddf":()=>t.e(129).then(t.bind(null,499)),"v-33490a39":()=>t.e(130).then(t.bind(null,500)),"v-51af4a72":()=>t.e(131).then(t.bind(null,501)),"v-07fff7d7":()=>t.e(132).then(t.bind(null,502)),"v-725a2703":()=>t.e(133).then(t.bind(null,503)),"v-ca971886":()=>t.e(134).then(t.bind(null,504)),"v-6892877d":()=>t.e(135).then(t.bind(null,505)),"v-d23fd306":()=>t.e(136).then(t.bind(null,506)),"v-210aaa1d":()=>t.e(137).then(t.bind(null,507)),"v-377700fe":()=>t.e(138).then(t.bind(null,508)),"v-405fbd6a":()=>t.e(139).then(t.bind(null,509)),"v-761f238a":()=>t.e(140).then(t.bind(null,510)),"v-c3847a42":()=>t.e(141).then(t.bind(null,511)),"v-87d0754a":()=>t.e(142).then(t.bind(null,512)),"v-2da3183a":()=>t.e(143).then(t.bind(null,513)),"v-53a11582":()=>t.e(144).then(t.bind(null,514)),"v-4c8845fc":()=>t.e(145).then(t.bind(null,515)),"v-df747cda":()=>t.e(146).then(t.bind(null,516)),"v-c36c87c2":()=>t.e(147).then(t.bind(null,517)),"v-397f75f5":()=>t.e(148).then(t.bind(null,518)),"v-b6310e56":()=>t.e(149).then(t.bind(null,519)),"v-0d9c3a15":()=>t.e(150).then(t.bind(null,520)),"v-8da47476":()=>t.e(151).then(t.bind(null,521)),"v-4bc1c689":()=>t.e(152).then(t.bind(null,522)),"v-7b75117d":()=>t.e(153).then(t.bind(null,523)),"v-10d9c13d":()=>t.e(154).then(t.bind(null,524)),"v-778f237d":()=>t.e(155).then(t.bind(null,525)),"v-5b6dcd7d":()=>t.e(156).then(t.bind(null,526)),"v-42d8aff9":()=>t.e(157).then(t.bind(null,527)),"v-7c8f5906":()=>t.e(158).then(t.bind(null,528)),"v-55778605":()=>t.e(159).then(t.bind(null,529)),"v-51bac5f7":()=>t.e(160).then(t.bind(null,530)),"v-f55aa90e":()=>t.e(161).then(t.bind(null,531)),"v-ea939fc6":()=>t.e(162).then(t.bind(null,532)),"v-498b6e86":()=>t.e(164).then(t.bind(null,533)),"v-c9eede46":()=>t.e(163).then(t.bind(null,534)),"v-3fcd21c9":()=>t.e(165).then(t.bind(null,535)),"v-3552c17d":()=>t.e(166).then(t.bind(null,536)),"v-dca0dbea":()=>t.e(167).then(t.bind(null,537)),"v-73c1945d":()=>t.e(168).then(t.bind(null,538)),"v-074761b1":()=>t.e(169).then(t.bind(null,539)),"v-82075c46":()=>t.e(170).then(t.bind(null,540)),"v-cf050632":()=>t.e(171).then(t.bind(null,541)),"v-bebe86c6":()=>t.e(172).then(t.bind(null,542)),"v-4fe65767":()=>t.e(173).then(t.bind(null,543)),"v-6fba7546":()=>t.e(174).then(t.bind(null,544)),"v-0790c155":()=>t.e(176).then(t.bind(null,545)),"v-97306cda":()=>t.e(175).then(t.bind(null,546)),"v-6cc4c933":()=>t.e(177).then(t.bind(null,547)),"v-d744eac6":()=>t.e(178).then(t.bind(null,548)),"v-2bac39fd":()=>t.e(179).then(t.bind(null,549)),"v-39df881d":()=>t.e(180).then(t.bind(null,550)),"v-75a63fbd":()=>t.e(181).then(t.bind(null,551)),"v-2af0da94":()=>t.e(182).then(t.bind(null,552)),"v-7d3a31b9":()=>t.e(184).then(t.bind(null,378)),"v-d2407716":()=>t.e(183).then(t.bind(null,553)),"v-6196523d":()=>t.e(124).then(t.bind(null,554)),"v-5d5e22bf":()=>t.e(123).then(t.bind(null,555))};function i(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const s=/-(\w)/g,l=i(n=>n.replace(s,(n,e)=>e?e.toUpperCase():"")),c=/\B([A-Z])/g,p=i(n=>n.replace(c,"-$1").toLowerCase()),d=i(n=>n.charAt(0).toUpperCase()+n.slice(1));function u(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(d(l(e))):n(d(e))||n(p(e))}const m=Object.assign({},o,a),h=n=>m[n],f=n=>a[n],g=n=>o[n],y=n=>r.default.component(n);function b(n){return u(f,n)}function v(n){return u(g,n)}function k(n){return u(h,n)}function w(n){return u(y,n)}function x(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!w(n)&&k(n)){const e=await k(n)();r.default.component(n,e.default)}}))}function T(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}function C(n,e){const{$localePath:t}=n;return"object"==typeof e&&e[t]?e[t]:e}function R(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}},function(n,e,t){"use strict";t.r(e),function(n){t.d(e,"EffectScope",(function(){return we})),t.d(e,"computed",(function(){return pe})),t.d(e,"customRef",(function(){return ee})),t.d(e,"default",(function(){return no})),t.d(e,"defineAsyncComponent",(function(){return Ot})),t.d(e,"defineComponent",(function(){return Jt})),t.d(e,"del",(function(){return $n})),t.d(e,"effectScope",(function(){return xe})),t.d(e,"getCurrentInstance",(function(){return un})),t.d(e,"getCurrentScope",(function(){return Te})),t.d(e,"h",(function(){return ft})),t.d(e,"inject",(function(){return Se})),t.d(e,"isProxy",(function(){return Fn})),t.d(e,"isReactive",(function(){return In})),t.d(e,"isReadonly",(function(){return On})),t.d(e,"isRef",(function(){return Kn})),t.d(e,"isShallow",(function(){return jn})),t.d(e,"markRaw",(function(){return Mn})),t.d(e,"mergeDefaults",(function(){return pt})),t.d(e,"nextTick",(function(){return _t})),t.d(e,"onActivated",(function(){return Ut})),t.d(e,"onBeforeMount",(function(){return At})),t.d(e,"onBeforeUnmount",(function(){return qt})),t.d(e,"onBeforeUpdate",(function(){return Dt})),t.d(e,"onDeactivated",(function(){return Nt})),t.d(e,"onErrorCaptured",(function(){return Vt})),t.d(e,"onMounted",(function(){return Mt})),t.d(e,"onRenderTracked",(function(){return Wt})),t.d(e,"onRenderTriggered",(function(){return Bt})),t.d(e,"onScopeDispose",(function(){return Ce})),t.d(e,"onServerPrefetch",(function(){return Ht})),t.d(e,"onUnmounted",(function(){return Lt})),t.d(e,"onUpdated",(function(){return zt})),t.d(e,"provide",(function(){return Re})),t.d(e,"proxyRefs",(function(){return Yn})),t.d(e,"reactive",(function(){return Sn})),t.d(e,"readonly",(function(){return ie})),t.d(e,"ref",(function(){return Jn})),t.d(e,"set",(function(){return Bn})),t.d(e,"shallowReactive",(function(){return Pn})),t.d(e,"shallowReadonly",(function(){return ce})),t.d(e,"shallowRef",(function(){return Gn})),t.d(e,"toRaw",(function(){return An})),t.d(e,"toRef",(function(){return re})),t.d(e,"toRefs",(function(){return te})),t.d(e,"triggerRef",(function(){return Xn})),t.d(e,"unref",(function(){return Zn})),t.d(e,"useAttrs",(function(){return st})),t.d(e,"useCssModule",(function(){return It})),t.d(e,"useCssVars",(function(){return jt})),t.d(e,"useListeners",(function(){return lt})),t.d(e,"useSlots",(function(){return it})),t.d(e,"version",(function(){return Kt})),t.d(e,"watch",(function(){return ve})),t.d(e,"watchEffect",(function(){return he})),t.d(e,"watchPostEffect",(function(){return fe})),t.d(e,"watchSyncEffect",(function(){return ge}));
/*!
 * Vue.js v2.7.13
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),o=Array.isArray;function a(n){return null==n}function i(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function p(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function u(n){return"[object Object]"===d.call(n)}function m(n){return"[object RegExp]"===d.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return i(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||u(n)&&n.toString===d?JSON.stringify(n,null,2):String(n)}function y(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),r=n.split(","),o=0;o<r.length;o++)t[r[o]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var v=b("key,ref,slot,slot-scope,is");function k(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var r=n.indexOf(e);if(r>-1)return n.splice(r,1)}}var w=Object.prototype.hasOwnProperty;function x(n,e){return w.call(n,e)}function T(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var C=/-(\w)/g,R=T((function(n){return n.replace(C,(function(n,e){return e?e.toUpperCase():""}))})),E=T((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),S=/\B([A-Z])/g,P=T((function(n){return n.replace(S,"-$1").toLowerCase()}));var _=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function I(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function j(n,e){for(var t in e)n[t]=e[t];return n}function O(n){for(var e={},t=0;t<n.length;t++)n[t]&&j(e,n[t]);return e}function F(n,e,t){}var A=function(n,e,t){return!1},M=function(n){return n};function D(n,e){if(n===e)return!0;var t=p(n),r=p(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var o=Array.isArray(n),a=Array.isArray(e);if(o&&a)return n.length===e.length&&n.every((function(n,t){return D(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(o||a)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return D(n[t],e[t])}))}catch(n){return!1}}function z(n,e){for(var t=0;t<n.length;t++)if(D(n[t],e))return t;return-1}function q(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function L(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var U=["component","directive","filter"],N=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],H={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:A,isReservedAttr:A,isUnknownElement:A,getTagNamespace:F,parsePlatformTagName:M,mustUseProp:A,async:!0,_lifecycleHooks:N},W=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function B(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function $(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var V=new RegExp("[^".concat(W.source,".$_\\d]"));var K="__proto__"in{},J="undefined"!=typeof window,G=J&&window.navigator.userAgent.toLowerCase(),Q=G&&/msie|trident/.test(G),X=G&&G.indexOf("msie 9.0")>0,Z=G&&G.indexOf("edge/")>0;G&&G.indexOf("android");var Y=G&&/iphone|ipad|ipod|ios/.test(G);G&&/chrome\/\d+/.test(G),G&&/phantomjs/.test(G);var nn,en=G&&G.match(/firefox\/(\d+)/),tn={}.watch,rn=!1;if(J)try{var on={};Object.defineProperty(on,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,on)}catch(n){}var an=function(){return void 0===nn&&(nn=!J&&void 0!==n&&(n.process&&"server"===n.process.env.VUE_ENV)),nn},sn=J&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,pn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var dn=null;function un(){return dn&&{proxy:dn}}function mn(n){void 0===n&&(n=null),n||dn&&dn._scope.off(),dn=n,n&&n._scope.on()}var hn=function(){function n(n,e,t,r,o,a,i,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=o,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),fn=function(n){void 0===n&&(n="");var e=new hn;return e.text=n,e.isComment=!0,e};function gn(n){return new hn(void 0,void 0,void 0,String(n))}function yn(n){var e=new hn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var bn=0,vn=[],kn=function(){function n(){this._pending=!1,this.id=bn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,vn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,r=e.length;t<r;t++){0,e[t].update()}},n}();kn.target=null;var wn=[];function xn(n){wn.push(n),kn.target=n}function Tn(){wn.pop(),kn.target=wn[wn.length-1]}var Cn=Array.prototype,Rn=Object.create(Cn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=Cn[n];$(Rn,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var o,a=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":o=t;break;case"splice":o=t.slice(2)}return o&&i.observeArray(o),i.dep.notify(),a}))}));var En=new WeakMap;function Sn(n){return _n(n,!1),n}function Pn(n){return _n(n,!0),$(n,"__v_isShallow",!0),n}function _n(n,e){if(!On(n)){Hn(n,e,an());0}}function In(n){return On(n)?In(n.__v_raw):!(!n||!n.__ob__)}function jn(n){return!(!n||!n.__v_isShallow)}function On(n){return!(!n||!n.__v_isReadonly)}function Fn(n){return In(n)||On(n)}function An(n){var e=n&&n.__v_raw;return e?An(e):n}function Mn(n){return p(n)&&En.set(n,!0),n}var Dn=Object.getOwnPropertyNames(Rn),zn={},qn=!0;function Ln(n){qn=n}var Un={notify:F,depend:F,addSub:F,removeSub:F},Nn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?Un:new kn,this.vmCount=0,$(n,"__ob__",this),o(n)){if(!t)if(K)n.__proto__=Rn;else for(var r=0,a=Dn.length;r<a;r++){$(n,s=Dn[r],Rn[s])}e||this.observeArray(n)}else{var i=Object.keys(n);for(r=0;r<i.length;r++){var s;Wn(n,s=i[r],zn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Hn(n[e],!1,this.mock)},n}();function Hn(n,e,t){return n&&x(n,"__ob__")&&n.__ob__ instanceof Nn?n.__ob__:!qn||!t&&an()||!o(n)&&!u(n)||!Object.isExtensible(n)||n.__v_skip||En.has(n)||Kn(n)||n instanceof hn?void 0:new Nn(n,e,t)}function Wn(n,e,t,r,a,i){var s=new kn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,p=l&&l.set;c&&!p||t!==zn&&2!==arguments.length||(t=n[e]);var d=!a&&Hn(t,!1,i);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return kn.target&&(s.depend(),d&&(d.dep.depend(),o(e)&&Vn(e))),Kn(e)&&!a?e.value:e},set:function(e){var r=c?c.call(n):t;if(L(r,e)){if(p)p.call(n,e);else{if(c)return;if(!a&&Kn(r)&&!Kn(e))return void(r.value=e);t=e}d=!a&&Hn(e,!1,i),s.notify()}}}),s}}function Bn(n,e,t){if(!On(n)){var r=n.__ob__;return o(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&Hn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(Wn(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function $n(n,e){if(o(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||On(n)||x(n,e)&&(delete n[e],t&&t.dep.notify())}}function Vn(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),o(e)&&Vn(e)}function Kn(n){return!(!n||!0!==n.__v_isRef)}function Jn(n){return Qn(n,!1)}function Gn(n){return Qn(n,!0)}function Qn(n,e){if(Kn(n))return n;var t={};return $(t,"__v_isRef",!0),$(t,"__v_isShallow",e),$(t,"dep",Wn(t,"value",n,null,e,an())),t}function Xn(n){n.dep&&n.dep.notify()}function Zn(n){return Kn(n)?n.value:n}function Yn(n){if(In(n))return n;for(var e={},t=Object.keys(n),r=0;r<t.length;r++)ne(e,n,t[r]);return e}function ne(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Kn(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];Kn(r)&&!Kn(n)?r.value=n:e[t]=n}})}function ee(n){var e=new kn,t=n((function(){e.depend()}),(function(){e.notify()})),r=t.get,o=t.set,a={get value(){return r()},set value(n){o(n)}};return $(a,"__v_isRef",!0),a}function te(n){var e=o(n)?new Array(n.length):{};for(var t in n)e[t]=re(n,t);return e}function re(n,e,t){var r=n[e];if(Kn(r))return r;var o={get value(){var r=n[e];return void 0===r?t:r},set value(t){n[e]=t}};return $(o,"__v_isRef",!0),o}var oe=new WeakMap,ae=new WeakMap;function ie(n){return se(n,!1)}function se(n,e){if(!u(n))return n;if(On(n))return n;var t=e?ae:oe,r=t.get(n);if(r)return r;var o=Object.create(Object.getPrototypeOf(n));t.set(n,o),$(o,"__v_isReadonly",!0),$(o,"__v_raw",n),Kn(n)&&$(o,"__v_isRef",!0),(e||jn(n))&&$(o,"__v_isShallow",!0);for(var a=Object.keys(n),i=0;i<a.length;i++)le(o,n,a[i],e);return o}function le(n,e,t,r){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];return r||!u(n)?n:ie(n)},set:function(){}})}function ce(n){return se(n,!0)}function pe(n,e){var t,r,o=c(n);o?(t=n,r=F):(t=n.get,r=n.set);var a=an()?null:new Yt(dn,t,F,{lazy:!0});var i={effect:a,get value(){return a?(a.dirty&&a.evaluate(),kn.target&&a.depend(),a.value):t()},set value(n){r(n)}};return $(i,"__v_isRef",!0),$(i,"__v_isReadonly",o),i}var de="".concat("watcher"," callback"),ue="".concat("watcher"," getter"),me="".concat("watcher"," cleanup");function he(n,e){return ke(n,null,e)}function fe(n,e){return ke(n,null,{flush:"post"})}function ge(n,e){return ke(n,null,{flush:"sync"})}var ye,be={};function ve(n,e,t){return ke(n,e,t)}function ke(n,e,t){var a=void 0===t?r:t,i=a.immediate,s=a.deep,l=a.flush,p=void 0===l?"pre":l;a.onTrack,a.onTrigger;var d,u,m=dn,h=function(n,e,t){return void 0===t&&(t=null),yt(n,null,t,m,e)},f=!1,g=!1;if(Kn(n)?(d=function(){return n.value},f=jn(n)):In(n)?(d=function(){return n.__ob__.dep.depend(),n},s=!0):o(n)?(g=!0,f=n.some((function(n){return In(n)||jn(n)})),d=function(){return n.map((function(n){return Kn(n)?n.value:In(n)?Qt(n):c(n)?h(n,ue):void 0}))}):d=c(n)?e?function(){return h(n,ue)}:function(){if(!m||!m._isDestroyed)return u&&u(),h(n,"watcher",[b])}:F,e&&s){var y=d;d=function(){return Qt(y())}}var b=function(n){u=v.onStop=function(){h(n,me)}};if(an())return b=F,e?i&&h(e,de,[d(),g?[]:void 0,b]):d(),F;var v=new Yt(dn,d,F,{lazy:!0});v.noRecurse=!e;var k=g?[]:be;return v.run=function(){if(v.active)if(e){var n=v.get();(s||f||(g?n.some((function(n,e){return L(n,k[e])})):L(n,k)))&&(u&&u(),h(e,de,[n,k===be?void 0:k,b]),k=n)}else v.get()},"sync"===p?v.update=v.run:"post"===p?(v.post=!0,v.update=function(){return kr(v)}):v.update=function(){if(m&&m===dn&&!m._isMounted){var n=m._preWatchers||(m._preWatchers=[]);n.indexOf(v)<0&&n.push(v)}else kr(v)},e?i?v.run():k=v.get():"post"===p&&m?m.$once("hook:mounted",(function(){return v.get()})):v.get(),function(){v.teardown()}}var we=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=ye,!n&&ye&&(this.index=(ye.scopes||(ye.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=ye;try{return ye=this,n()}finally{ye=e}}else 0},n.prototype.on=function(){ye=this},n.prototype.off=function(){ye=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},n}();function xe(n){return new we(n)}function Te(){return ye}function Ce(n){ye&&ye.cleanups.push(n)}function Re(n,e){dn&&(Ee(dn)[n]=e)}function Ee(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}function Se(n,e,t){void 0===t&&(t=!1);var r=dn;if(r){var o=r.$parent&&r.$parent._provided;if(o&&n in o)return o[n];if(arguments.length>1)return t&&c(e)?e.call(r):e}else 0}var Pe=T((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function _e(n,e){function t(){var n=t.fns;if(!o(n))return yt(n,null,arguments,e,"v-on handler");for(var r=n.slice(),a=0;a<r.length;a++)yt(r[a],null,arguments,e,"v-on handler")}return t.fns=n,t}function Ie(n,e,t,r,o,i){var l,c,p,d;for(l in n)c=n[l],p=e[l],d=Pe(l),a(c)||(a(p)?(a(c.fns)&&(c=n[l]=_e(c,i)),s(d.once)&&(c=n[l]=o(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==p&&(p.fns=c,n[l]=p));for(l in e)a(n[l])&&r((d=Pe(l)).name,e[l],d.capture)}function je(n,e,t){var r;n instanceof hn&&(n=n.data.hook||(n.data.hook={}));var o=n[e];function l(){t.apply(this,arguments),k(r.fns,l)}a(o)?r=_e([l]):i(o.fns)&&s(o.merged)?(r=o).fns.push(l):r=_e([o,l]),r.merged=!0,n[e]=r}function Oe(n,e,t,r,o){if(i(e)){if(x(e,t))return n[t]=e[t],o||delete e[t],!0;if(x(e,r))return n[t]=e[r],o||delete e[r],!0}return!1}function Fe(n){return l(n)?[gn(n)]:o(n)?function n(e,t){var r,c,p,d,u=[];for(r=0;r<e.length;r++)a(c=e[r])||"boolean"==typeof c||(p=u.length-1,d=u[p],o(c)?c.length>0&&(Ae((c=n(c,"".concat(t||"","_").concat(r)))[0])&&Ae(d)&&(u[p]=gn(d.text+c[0].text),c.shift()),u.push.apply(u,c)):l(c)?Ae(d)?u[p]=gn(d.text+c):""!==c&&u.push(gn(c)):Ae(c)&&Ae(d)?u[p]=gn(d.text+c.text):(s(e._isVList)&&i(c.tag)&&a(c.key)&&i(t)&&(c.key="__vlist".concat(t,"_").concat(r,"__")),u.push(c)));return u}(n):void 0}function Ae(n){return i(n)&&i(n.text)&&!1===n.isComment}function Me(n,e){var t,r,a,s,l=null;if(o(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(p(n))if(pn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),d=c.next();!d.done;)l.push(e(d.value,l.length)),d=c.next()}else for(a=Object.keys(n),l=new Array(a.length),t=0,r=a.length;t<r;t++)s=a[t],l[t]=e(n[s],s,t);return i(l)||(l=[]),l._isVList=!0,l}function De(n,e,t,r){var o,a=this.$scopedSlots[n];a?(t=t||{},r&&(t=j(j({},r),t)),o=a(t)||(c(e)?e():e)):o=this.$slots[n]||(c(e)?e():e);var i=t&&t.slot;return i?this.$createElement("template",{slot:i},o):o}function ze(n){return qr(this.$options,"filters",n,!0)||M}function qe(n,e){return o(n)?-1===n.indexOf(e):n!==e}function Le(n,e,t,r,o){var a=H.keyCodes[e]||t;return o&&r&&!H.keyCodes[e]?qe(o,r):a?qe(a,n):r?P(r)!==e:void 0===n}function Ue(n,e,t,r,a){if(t)if(p(t)){o(t)&&(t=O(t));var i=void 0,s=function(o){if("class"===o||"style"===o||v(o))i=n;else{var s=n.attrs&&n.attrs.type;i=r||H.mustUseProp(e,s,o)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=R(o),c=P(o);l in i||c in i||(i[o]=t[o],a&&((n.on||(n.on={}))["update:".concat(o)]=function(n){t[o]=n}))};for(var l in t)s(l)}else;return n}function Ne(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||We(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function He(n,e,t){return We(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function We(n,e,t){if(o(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&Be(n[r],"".concat(e,"_").concat(r),t);else Be(n,e,t)}function Be(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function $e(n,e){if(e)if(u(e)){var t=n.on=n.on?j({},n.on):{};for(var r in e){var o=t[r],a=e[r];t[r]=o?[].concat(o,a):a}}else;return n}function Ve(n,e,t,r){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var i=n[a];o(i)?Ve(i,e,t):i&&(i.proxy&&(i.fn.proxy=!0),e[i.key]=i.fn)}return r&&(e.$key=r),e}function Ke(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function Je(n,e){return"string"==typeof n?e+n:n}function Ge(n){n._o=He,n._n=y,n._s=g,n._l=Me,n._t=De,n._q=D,n._i=z,n._m=Ne,n._f=ze,n._k=Le,n._b=Ue,n._v=gn,n._e=fn,n._u=Ve,n._g=$e,n._d=Ke,n._p=Je}function Qe(n,e){if(!n||!n.length)return{};for(var t={},r=0,o=n.length;r<o;r++){var a=n[r],i=a.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,a.context!==e&&a.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(a);else{var s=i.slot,l=t[s]||(t[s]=[]);"template"===a.tag?l.push.apply(l,a.children||[]):l.push(a)}}for(var c in t)t[c].every(Xe)&&delete t[c];return t}function Xe(n){return n.isComment&&!n.asyncFactory||" "===n.text}function Ze(n){return n.isComment&&n.asyncFactory}function Ye(n,e,t,o){var a,i=Object.keys(t).length>0,s=e?!!e.$stable:!i,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&o&&o!==r&&l===o.$key&&!i&&!o.$hasNormal)return o;for(var c in a={},e)e[c]&&"$"!==c[0]&&(a[c]=nt(n,t,c,e[c]))}else a={};for(var p in t)p in a||(a[p]=et(t,p));return e&&Object.isExtensible(e)&&(e._normalized=a),$(a,"$stable",s),$(a,"$key",l),$(a,"$hasNormal",i),a}function nt(n,e,t,r){var a=function(){var e=dn;mn(n);var t=arguments.length?r.apply(null,arguments):r({}),a=(t=t&&"object"==typeof t&&!o(t)?[t]:Fe(t))&&t[0];return mn(e),t&&(!a||1===t.length&&a.isComment&&!Ze(a))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:a,enumerable:!0,configurable:!0}),a}function et(n,e){return function(){return n[e]}}function tt(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};$(e,"_v_attr_proxy",!0),rt(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||rt(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||at(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:_(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return ne(n,e,t)}))}}}function rt(n,e,t,r,o){var a=!1;for(var i in e)i in n?e[i]!==t[i]&&(a=!0):(a=!0,ot(n,i,r,o));for(var i in n)i in e||(a=!0,delete n[i]);return a}function ot(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function at(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}function it(){return ct().slots}function st(){return ct().attrs}function lt(){return ct().listeners}function ct(){var n=dn;return n._setupContext||(n._setupContext=tt(n))}function pt(n,e){var t=o(n)?n.reduce((function(n,e){return n[e]={},n}),{}):n;for(var r in e){var a=t[r];a?o(a)||c(a)?t[r]={type:a,default:e[r]}:a.default=e[r]:null===a&&(t[r]={default:e[r]})}return t}var dt=null;function ut(n,e){return(n.__esModule||pn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),p(n)?e.extend(n):n}function mt(n){if(o(n))for(var e=0;e<n.length;e++){var t=n[e];if(i(t)&&(i(t.componentOptions)||Ze(t)))return t}}function ht(n,e,t,r,d,u){return(o(t)||l(t))&&(d=r,r=t,t=void 0),s(u)&&(d=2),function(n,e,t,r,l){if(i(t)&&i(t.__ob__))return fn();i(t)&&i(t.is)&&(e=t.is);if(!e)return fn();0;o(r)&&c(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=Fe(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(o(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var d,u;if("string"==typeof e){var m=void 0;u=n.$vnode&&n.$vnode.ns||H.getTagNamespace(e),d=H.isReservedTag(e)?new hn(H.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!i(m=qr(n.$options,"components",e))?new hn(e,t,r,void 0,void 0,n):Pr(m,t,n,r,e)}else d=Pr(e,t,n,r);return o(d)?d:i(d)?(i(u)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(i(e.children))for(var o=0,l=e.children.length;o<l;o++){var c=e.children[o];i(c.tag)&&(a(c.ns)||s(r)&&"svg"!==c.tag)&&n(c,t,r)}}(d,u),i(t)&&function(n){p(n.style)&&Qt(n.style);p(n.class)&&Qt(n.class)}(t),d):fn()}(n,e,t,r,d)}function ft(n,e,t){return ht(dn,n,e,t,2,!0)}function gt(n,e,t){xn();try{if(e)for(var r=e;r=r.$parent;){var o=r.$options.errorCaptured;if(o)for(var a=0;a<o.length;a++)try{if(!1===o[a].call(r,n,e,t))return}catch(n){bt(n,r,"errorCaptured hook")}}bt(n,e,t)}finally{Tn()}}function yt(n,e,t,r,o){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&f(a)&&!a._handled&&(a.catch((function(n){return gt(n,r,o+" (Promise/async)")})),a._handled=!0)}catch(n){gt(n,r,o)}return a}function bt(n,e,t){if(H.errorHandler)try{return H.errorHandler.call(null,n,e,t)}catch(e){e!==n&&vt(e,null,"config.errorHandler")}vt(n,e,t)}function vt(n,e,t){if(!J||"undefined"==typeof console)throw n;console.error(n)}var kt,wt=!1,xt=[],Tt=!1;function Ct(){Tt=!1;var n=xt.slice(0);xt.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var Rt=Promise.resolve();kt=function(){Rt.then(Ct),Y&&setTimeout(F)},wt=!0}else if(Q||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())kt="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Ct)}:function(){setTimeout(Ct,0)};else{var Et=1,St=new MutationObserver(Ct),Pt=document.createTextNode(String(Et));St.observe(Pt,{characterData:!0}),kt=function(){Et=(Et+1)%2,Pt.data=String(Et)},wt=!0}function _t(n,e){var t;if(xt.push((function(){if(n)try{n.call(e)}catch(n){gt(n,e,"nextTick")}else t&&t(e)})),Tt||(Tt=!0,kt()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function It(n){if(void 0===n&&(n="$style"),!dn)return r;var e=dn[n];return e||r}function jt(n){if(J){var e=dn;e&&fe((function(){var t=e.$el,r=n(e,e._setupProxy);if(t&&1===t.nodeType){var o=t.style;for(var a in r)o.setProperty("--".concat(a),r[a])}}))}}function Ot(n){c(n)&&(n={loader:n});var e=n.loader,t=n.loadingComponent,r=n.errorComponent,o=n.delay,a=void 0===o?200:o,i=n.timeout,s=(n.suspensible,n.onError);var l=null,p=0,d=function(){var n;return l||(n=l=e().catch((function(n){if(n=n instanceof Error?n:new Error(String(n)),s)return new Promise((function(e,t){s(n,(function(){return e((p++,l=null,d()))}),(function(){return t(n)}),p+1)}));throw n})).then((function(e){return n!==l&&l?l:(e&&(e.__esModule||"Module"===e[Symbol.toStringTag])&&(e=e.default),e)})))};return function(){return{component:d(),delay:a,timeout:i,error:r,loading:t}}}function Ft(n){return function(e,t){if(void 0===t&&(t=dn),t)return function(n,e,t){var r=n.$options;r[e]=Ar(r[e],t)}(t,n,e)}}var At=Ft("beforeMount"),Mt=Ft("mounted"),Dt=Ft("beforeUpdate"),zt=Ft("updated"),qt=Ft("beforeDestroy"),Lt=Ft("destroyed"),Ut=Ft("activated"),Nt=Ft("deactivated"),Ht=Ft("serverPrefetch"),Wt=Ft("renderTracked"),Bt=Ft("renderTriggered"),$t=Ft("errorCaptured");function Vt(n,e){void 0===e&&(e=dn),$t(n,e)}var Kt="2.7.13";function Jt(n){return n}var Gt=new cn;function Qt(n){return function n(e,t){var r,a,i=o(e);if(!i&&!p(e)||e.__v_skip||Object.isFrozen(e)||e instanceof hn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(i)for(r=e.length;r--;)n(e[r],t);else if(Kn(e))n(e.value,t);else for(a=Object.keys(e),r=a.length;r--;)n(e[a[r]],t)}(n,Gt),Gt.clear(),n}var Xt,Zt=0,Yt=function(){function n(n,e,t,r,o){var a,i;a=this,void 0===(i=ye&&!ye._vm?ye:n?n._scope:void 0)&&(i=ye),i&&i.active&&i.effects.push(a),(this.vm=n)&&o&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Zt,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!V.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=F)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;xn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;gt(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Qt(n),Tn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():kr(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||p(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');yt(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&k(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function nr(n,e){Xt.$on(n,e)}function er(n,e){Xt.$off(n,e)}function tr(n,e){var t=Xt;return function r(){var o=e.apply(null,arguments);null!==o&&t.$off(n,r)}}function rr(n,e,t){Xt=n,Ie(e,t||{},nr,er,tr,n),Xt=void 0}var or=null;function ar(n){var e=or;return or=n,function(){or=e}}function ir(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function sr(n,e){if(e){if(n._directInactive=!1,ir(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)sr(n.$children[t]);lr(n,"activated")}}function lr(n,e,t,r){void 0===r&&(r=!0),xn();var o=dn;r&&mn(n);var a=n.$options[e],i="".concat(e," hook");if(a)for(var s=0,l=a.length;s<l;s++)yt(a[s],n,t||null,n,i);n._hasHookEvent&&n.$emit("hook:"+e),r&&mn(o),Tn()}var cr=[],pr=[],dr={},ur=!1,mr=!1,hr=0;var fr=0,gr=Date.now;if(J&&!Q){var yr=window.performance;yr&&"function"==typeof yr.now&&gr()>document.createEvent("Event").timeStamp&&(gr=function(){return yr.now()})}var br=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function vr(){var n,e;for(fr=gr(),mr=!0,cr.sort(br),hr=0;hr<cr.length;hr++)(n=cr[hr]).before&&n.before(),e=n.id,dr[e]=null,n.run();var t=pr.slice(),r=cr.slice();hr=cr.length=pr.length=0,dr={},ur=mr=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,sr(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&lr(r,"updated")}}(r),function(){for(var n=0;n<vn.length;n++){var e=vn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}vn.length=0}(),sn&&H.devtools&&sn.emit("flush")}function kr(n){var e=n.id;if(null==dr[e]&&(n!==kn.target||!n.noRecurse)){if(dr[e]=!0,mr){for(var t=cr.length-1;t>hr&&cr[t].id>n.id;)t--;cr.splice(t+1,0,n)}else cr.push(n);ur||(ur=!0,_t(vr))}}function wr(n,e){if(n){for(var t=Object.create(null),r=pn?Reflect.ownKeys(n):Object.keys(n),o=0;o<r.length;o++){var a=r[o];if("__ob__"!==a){var i=n[a].from;if(i in e._provided)t[a]=e._provided[i];else if("default"in n[a]){var s=n[a].default;t[a]=c(s)?s.call(e):s}else 0}}return t}}function xr(n,e,t,a,i){var l,c=this,p=i.options;x(a,"_uid")?(l=Object.create(a))._original=a:(l=a,a=a._original);var d=s(p._compiled),u=!d;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||r,this.injections=wr(p.inject,a),this.slots=function(){return c.$slots||Ye(a,n.scopedSlots,c.$slots=Qe(t,a)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return Ye(a,n.scopedSlots,this.slots())}}),d&&(this.$options=p,this.$slots=this.slots(),this.$scopedSlots=Ye(a,n.scopedSlots,this.$slots)),p._scopeId?this._c=function(n,e,t,r){var i=ht(l,n,e,t,r,u);return i&&!o(i)&&(i.fnScopeId=p._scopeId,i.fnContext=a),i}:this._c=function(n,e,t,r){return ht(l,n,e,t,r,u)}}function Tr(n,e,t,r,o){var a=yn(n);return a.fnContext=t,a.fnOptions=r,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function Cr(n,e){for(var t in e)n[R(t)]=e[t]}function Rr(n){return n.name||n.__name||n._componentTag}Ge(xr.prototype);var Er={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Er.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;i(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,or)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,o,a){var i=o.data.scopedSlots,s=n.$scopedSlots,l=!!(i&&!i.$stable||s!==r&&!s.$stable||i&&n.$scopedSlots.$key!==i.$key||!i&&n.$scopedSlots.$key),c=!!(a||n.$options._renderChildren||l),p=n.$vnode;n.$options._parentVnode=o,n.$vnode=o,n._vnode&&(n._vnode.parent=o),n.$options._renderChildren=a;var d=o.data.attrs||r;n._attrsProxy&&rt(n._attrsProxy,d,p.data&&p.data.attrs||r,n,"$attrs")&&(c=!0),n.$attrs=d,t=t||r;var u=n.$options._parentListeners;if(n._listenersProxy&&rt(n._listenersProxy,t,u||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,rr(n,t,u),e&&n.$options.props){Ln(!1);for(var m=n._props,h=n.$options._propKeys||[],f=0;f<h.length;f++){var g=h[f],y=n.$options.props;m[g]=Lr(g,y,e,n)}Ln(!0),n.$options.propsData=e}c&&(n.$slots=Qe(a,o.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,lr(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,pr.push(e)):sr(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,ir(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);lr(e,"deactivated")}}(e,!0):e.$destroy())}},Sr=Object.keys(Er);function Pr(n,e,t,l,c){if(!a(n)){var d=t.$options._base;if(p(n)&&(n=d.extend(n)),"function"==typeof n){var u;if(a(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&i(n.errorComp))return n.errorComp;if(i(n.resolved))return n.resolved;var t=dt;if(t&&i(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&i(n.loadingComp))return n.loadingComp;if(t&&!i(n.owners)){var r=n.owners=[t],o=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return k(r,t)}));var d=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},u=q((function(t){n.resolved=ut(t,e),o?r.length=0:d(!0)})),m=q((function(e){i(n.errorComp)&&(n.error=!0,d(!0))})),h=n(u,m);return p(h)&&(f(h)?a(n.resolved)&&h.then(u,m):f(h.component)&&(h.component.then(u,m),i(h.error)&&(n.errorComp=ut(h.error,e)),i(h.loading)&&(n.loadingComp=ut(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,d(!1))}),h.delay||200)),i(h.timeout)&&(c=setTimeout((function(){c=null,a(n.resolved)&&m(null)}),h.timeout)))),o=!1,n.loading?n.loadingComp:n.resolved}}(u=n,d)))return function(n,e,t,r,o){var a=fn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:r,tag:o},a}(u,e,t,l,c);e=e||{},Yr(n),i(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),s=a[r],l=e.model.callback;i(s)?(o(s)?-1===s.indexOf(l):s!==l)&&(a[r]=[l].concat(s)):a[r]=l}(n.options,e);var m=function(n,e,t){var r=e.options.props;if(!a(r)){var o={},s=n.attrs,l=n.props;if(i(s)||i(l))for(var c in r){var p=P(c);Oe(o,l,c,p,!0)||Oe(o,s,c,p,!1)}return o}}(e,n);if(s(n.options.functional))return function(n,e,t,a,s){var l=n.options,c={},p=l.props;if(i(p))for(var d in p)c[d]=Lr(d,p,e||r);else i(t.attrs)&&Cr(c,t.attrs),i(t.props)&&Cr(c,t.props);var u=new xr(t,c,s,a,n),m=l.render.call(null,u._c,u);if(m instanceof hn)return Tr(m,t,u.parent,l,u);if(o(m)){for(var h=Fe(m)||[],f=new Array(h.length),g=0;g<h.length;g++)f[g]=Tr(h[g],t,u.parent,l,u);return f}}(n,m,e,t,l);var h=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Sr.length;t++){var r=Sr[t],o=e[r],a=Er[r];o===a||o&&o._merged||(e[r]=o?_r(a,o):a)}}(e);var y=Rr(n.options)||c;return new hn("vue-component-".concat(n.cid).concat(y?"-".concat(y):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:c,children:l},u)}}}function _r(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var Ir=F,jr=H.optionMergeStrategies;function Or(n,e){if(!e)return n;for(var t,r,o,a=pn?Reflect.ownKeys(e):Object.keys(e),i=0;i<a.length;i++)"__ob__"!==(t=a[i])&&(r=n[t],o=e[t],x(n,t)?r!==o&&u(r)&&u(o)&&Or(r,o):Bn(n,t,o));return n}function Fr(n,e,t){return t?function(){var r=c(e)?e.call(t,t):e,o=c(n)?n.call(t,t):n;return r?Or(r,o):o}:e?n?function(){return Or(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function Ar(n,e){var t=e?n?n.concat(e):o(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Mr(n,e,t,r){var o=Object.create(n||null);return e?j(o,e):o}jr.data=function(n,e,t){return t?Fr(n,e,t):e&&"function"!=typeof e?n:Fr(n,e)},N.forEach((function(n){jr[n]=Ar})),U.forEach((function(n){jr[n+"s"]=Mr})),jr.watch=function(n,e,t,r){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var i in j(a,n),e){var s=a[i],l=e[i];s&&!o(s)&&(s=[s]),a[i]=s?s.concat(l):o(l)?l:[l]}return a},jr.props=jr.methods=jr.inject=jr.computed=function(n,e,t,r){if(!n)return e;var o=Object.create(null);return j(o,n),e&&j(o,e),o},jr.provide=Fr;var Dr=function(n,e){return void 0===e?n:e};function zr(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,a,i={};if(o(t))for(r=t.length;r--;)"string"==typeof(a=t[r])&&(i[R(a)]={type:null});else if(u(t))for(var s in t)a=t[s],i[R(s)]=u(a)?a:{type:a};else 0;n.props=i}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(o(t))for(var a=0;a<t.length;a++)r[t[a]]={from:t[a]};else if(u(t))for(var i in t){var s=t[i];r[i]=u(s)?j({from:i},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];c(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=zr(n,e.extends,t)),e.mixins))for(var r=0,a=e.mixins.length;r<a;r++)n=zr(n,e.mixins[r],t);var i,s={};for(i in n)l(i);for(i in e)x(n,i)||l(i);function l(r){var o=jr[r]||Dr;s[r]=o(n[r],e[r],t,r)}return s}function qr(n,e,t,r){if("string"==typeof t){var o=n[e];if(x(o,t))return o[t];var a=R(t);if(x(o,a))return o[a];var i=E(a);return x(o,i)?o[i]:o[t]||o[a]||o[i]}}function Lr(n,e,t,r){var o=e[n],a=!x(t,n),i=t[n],s=Wr(Boolean,o.type);if(s>-1)if(a&&!x(o,"default"))i=!1;else if(""===i||i===P(n)){var l=Wr(String,o.type);(l<0||s<l)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!x(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(r)&&"Function"!==Nr(e.type)?r.call(n):r}(r,o,n);var p=qn;Ln(!0),Hn(i),Ln(p)}return i}var Ur=/^\s*function (\w+)/;function Nr(n){var e=n&&n.toString().match(Ur);return e?e[1]:""}function Hr(n,e){return Nr(n)===Nr(e)}function Wr(n,e){if(!o(e))return Hr(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Hr(e[t],n))return t;return-1}var Br={enumerable:!0,configurable:!0,get:F,set:F};function $r(n,e,t){Br.get=function(){return this[e][t]},Br.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Br)}function Vr(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=Pn({}),o=n.$options._propKeys=[];n.$parent&&Ln(!1);var a=function(a){o.push(a);var i=Lr(a,e,t,n);Wn(r,a,i),a in n||$r(n,"_props",a)};for(var i in e)a(i);Ln(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=tt(n);mn(n),xn();var o=yt(t,null,[n._props||Pn({}),r],n,"setup");if(Tn(),mn(),c(o))e.render=o;else if(p(o))if(n._setupState=o,o.__sfc){var a=n._setupProxy={};for(var i in o)"__sfc"!==i&&ne(a,o,i)}else for(var i in o)B(i)||ne(n,o,i);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?F:_(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;u(e=n._data=c(e)?function(n,e){xn();try{return n.call(e,e)}catch(n){return gt(n,e,"data()"),{}}finally{Tn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,o=(n.$options.methods,t.length);for(;o--;){var a=t[o];0,r&&x(r,a)||B(a)||$r(n,"_data",a)}var i=Hn(e);i&&i.vmCount++}(n);else{var t=Hn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=an();for(var o in e){var a=e[o],i=c(a)?a:a.get;0,r||(t[o]=new Yt(n,i||F,F,Kr)),o in n||Jr(n,o,a)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var r=e[t];if(o(r))for(var a=0;a<r.length;a++)Xr(n,t,r[a]);else Xr(n,t,r)}}(n,e.watch)}var Kr={lazy:!0};function Jr(n,e,t){var r=!an();c(t)?(Br.get=r?Gr(e):Qr(t),Br.set=F):(Br.get=t.get?r&&!1!==t.cache?Gr(e):Qr(t.get):F,Br.set=t.set||F),Object.defineProperty(n,e,Br)}function Gr(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),kn.target&&e.depend(),e.value}}function Qr(n){return function(){return n.call(this,this)}}function Xr(n,e,t,r){return u(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Zr=0;function Yr(n){var e=n.options;if(n.super){var t=Yr(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var o in t)t[o]!==r[o]&&(e||(e={}),e[o]=t[o]);return e}(n);r&&j(n.extendOptions,r),(e=n.options=zr(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function no(n){this._init(n)}function eo(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,o=n._Ctor||(n._Ctor={});if(o[r])return o[r];var a=Rr(n)||Rr(t.options);var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=zr(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)$r(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)Jr(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,U.forEach((function(n){i[n]=t[n]})),a&&(i.options.components[a]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=j({},i.options),o[r]=i,i}}function to(n){return n&&(Rr(n.Ctor.options)||n.tag)}function ro(n,e){return o(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function oo(n,e){var t=n.cache,r=n.keys,o=n._vnode;for(var a in t){var i=t[a];if(i){var s=i.name;s&&!e(s)&&ao(t,a,r,o)}}}function ao(n,e,t,r){var o=n[e];!o||r&&o.tag===r.tag||o.componentInstance.$destroy(),n[e]=null,k(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Zr++,e._isVue=!0,e.__v_skip=!0,e._scope=new we(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var o=r.componentOptions;t.propsData=o.propsData,t._parentListeners=o.listeners,t._renderChildren=o.children,t._componentTag=o.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=zr(Yr(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&rr(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,o=t&&t.context;n.$slots=Qe(e._renderChildren,o),n.$scopedSlots=t?Ye(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,o){return ht(n,e,t,r,o,!1)},n.$createElement=function(e,t,r,o){return ht(n,e,t,r,o,!0)};var a=t&&t.data;Wn(n,"$attrs",a&&a.attrs||r,null,!0),Wn(n,"$listeners",e._parentListeners||r,null,!0)}(e),lr(e,"beforeCreate",void 0,!1),function(n){var e=wr(n.$options.inject,n);e&&(Ln(!1),Object.keys(e).forEach((function(t){Wn(n,t,e[t])})),Ln(!0))}(e),Vr(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!p(t))return;for(var r=Ee(n),o=pn?Reflect.ownKeys(t):Object.keys(t),a=0;a<o.length;a++){var i=o[a];Object.defineProperty(r,i,Object.getOwnPropertyDescriptor(t,i))}}}(e),lr(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(no),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Bn,n.prototype.$delete=$n,n.prototype.$watch=function(n,e,t){if(u(e))return Xr(this,n,e,t);(t=t||{}).user=!0;var r=new Yt(this,n,e,t);if(t.immediate){var o='callback for immediate watcher "'.concat(r.expression,'"');xn(),yt(e,this,[r.value],this,o),Tn()}return function(){r.teardown()}}}(no),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(o(n))for(var a=0,i=n.length;a<i;a++)r.$on(n[a],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(o(n)){for(var r=0,a=n.length;r<a;r++)t.$off(n[r],e);return t}var i,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((i=s[l])===e||i.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?I(t):t;for(var r=I(arguments,1),o='event handler for "'.concat(n,'"'),a=0,i=t.length;a<i;a++)yt(t[a],e,r,e,o)}return e}}(no),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,o=t._vnode,a=ar(t);t._vnode=n,t.$el=o?t.__patch__(o,n):t.__patch__(t.$el,n,e,!1),a(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var i=t;i&&i.$vnode&&i.$parent&&i.$vnode===i.$parent._vnode;)i.$parent.$el=i.$el,i=i.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){lr(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||k(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),lr(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(no),function(n){Ge(n.prototype),n.prototype.$nextTick=function(n){return _t(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,a=t._parentVnode;a&&e._isMounted&&(e.$scopedSlots=Ye(e.$parent,a.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&at(e._slotsProxy,e.$scopedSlots)),e.$vnode=a;try{mn(e),dt=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){gt(t,e,"render"),n=e._vnode}finally{dt=null,mn()}return o(n)&&1===n.length&&(n=n[0]),n instanceof hn||(n=fn()),n.parent=a,n}}(no);var io=[String,RegExp,Array],so={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:io,exclude:io,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var o=t.tag,a=t.componentInstance,i=t.componentOptions;n[r]={name:to(i),tag:o,componentInstance:a},e.push(r),this.max&&e.length>parseInt(this.max)&&ao(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)ao(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){oo(n,(function(n){return ro(e,n)}))})),this.$watch("exclude",(function(e){oo(n,(function(n){return!ro(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=mt(n),t=e&&e.componentOptions;if(t){var r=to(t),o=this.include,a=this.exclude;if(o&&(!r||!ro(o,r))||a&&r&&ro(a,r))return e;var i=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;i[l]?(e.componentInstance=i[l].componentInstance,k(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return H}};Object.defineProperty(n,"config",e),n.util={warn:Ir,extend:j,mergeOptions:zr,defineReactive:Wn},n.set=Bn,n.delete=$n,n.nextTick=_t,n.observable=function(n){return Hn(n),n},n.options=Object.create(null),U.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,j(n.options.components,so),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=I(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=zr(this.options,n),this}}(n),eo(n),function(n){U.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&u(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(no),Object.defineProperty(no.prototype,"$isServer",{get:an}),Object.defineProperty(no.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(no,"FunctionalRenderContext",{value:xr}),no.version=Kt;var lo=b("style,class"),co=b("input,textarea,option,select,progress"),po=b("contenteditable,draggable,spellcheck"),uo=b("events,caret,typing,plaintext-only"),mo=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ho="http://www.w3.org/1999/xlink",fo=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},go=function(n){return fo(n)?n.slice(6,n.length):""},yo=function(n){return null==n||!1===n};function bo(n){for(var e=n.data,t=n,r=n;i(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=vo(r.data,e));for(;i(t=t.parent);)t&&t.data&&(e=vo(e,t.data));return function(n,e){if(i(n)||i(e))return ko(n,wo(e));return""}(e.staticClass,e.class)}function vo(n,e){return{staticClass:ko(n.staticClass,e.staticClass),class:i(n.class)?[n.class,e.class]:e.class}}function ko(n,e){return n?e?n+" "+e:n:e||""}function wo(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,o=n.length;r<o;r++)i(e=wo(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):p(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var xo={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},To=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Co=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Ro=function(n){return To(n)||Co(n)};var Eo=Object.create(null);var So=b("text,number,password,search,email,tel,url");var Po=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(xo[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),_o={create:function(n,e){Io(e)},update:function(n,e){n.data.ref!==e.data.ref&&(Io(n,!0),Io(e))},destroy:function(n){Io(n,!0)}};function Io(n,e){var t=n.data.ref;if(i(t)){var r=n.context,a=n.componentInstance||n.elm,s=e?null:a,l=e?void 0:a;if(c(t))yt(t,r,[s],r,"template ref function");else{var p=n.data.refInFor,d="string"==typeof t||"number"==typeof t,u=Kn(t),m=r.$refs;if(d||u)if(p){var h=d?m[t]:t.value;e?o(h)&&k(h,a):o(h)?h.includes(a)||h.push(a):d?(m[t]=[a],jo(r,t,m[t])):t.value=[a]}else if(d){if(e&&m[t]!==a)return;m[t]=l,jo(r,t,s)}else if(u){if(e&&t.value!==a)return;t.value=s}else 0}}}function jo(n,e,t){var r=n._setupState;r&&x(r,e)&&(Kn(r[e])?r[e].value=t:r[e]=t)}var Oo=new hn("",{},[]),Fo=["create","activate","update","remove","destroy"];function Ao(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&i(n.data)===i(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=i(t=n.data)&&i(t=t.attrs)&&t.type,o=i(t=e.data)&&i(t=t.attrs)&&t.type;return r===o||So(r)&&So(o)}(n,e)||s(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function Mo(n,e,t){var r,o,a={};for(r=e;r<=t;++r)i(o=n[r].key)&&(a[o]=r);return a}var Do={create:zo,update:zo,destroy:function(n){zo(n,Oo)}};function zo(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,o,a=n===Oo,i=e===Oo,s=Lo(n.data.directives,n.context),l=Lo(e.data.directives,e.context),c=[],p=[];for(t in l)r=s[t],o=l[t],r?(o.oldValue=r.value,o.oldArg=r.arg,No(o,"update",e,n),o.def&&o.def.componentUpdated&&p.push(o)):(No(o,"bind",e,n),o.def&&o.def.inserted&&c.push(o));if(c.length){var d=function(){for(var t=0;t<c.length;t++)No(c[t],"inserted",e,n)};a?je(e,"insert",d):d()}p.length&&je(e,"postpatch",(function(){for(var t=0;t<p.length;t++)No(p[t],"componentUpdated",e,n)}));if(!a)for(t in s)l[t]||No(s[t],"unbind",n,n,i)}(n,e)}var qo=Object.create(null);function Lo(n,e){var t,r,o=Object.create(null);if(!n)return o;for(t=0;t<n.length;t++){if((r=n[t]).modifiers||(r.modifiers=qo),o[Uo(r)]=r,e._setupState&&e._setupState.__sfc){var a=r.def||qr(e,"_setupState","v-"+r.name);r.def="function"==typeof a?{bind:a,update:a}:a}r.def=r.def||qr(e.$options,"directives",r.name)}return o}function Uo(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function No(n,e,t,r,o){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,r,o)}catch(r){gt(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Ho=[_o,Do];function Wo(n,e){var t=e.componentOptions;if(!(i(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var r,o,l=e.elm,c=n.data.attrs||{},p=e.data.attrs||{};for(r in(i(p.__ob__)||s(p._v_attr_proxy))&&(p=e.data.attrs=j({},p)),p)o=p[r],c[r]!==o&&Bo(l,r,o,e.data.pre);for(r in(Q||Z)&&p.value!==c.value&&Bo(l,"value",p.value),c)a(p[r])&&(fo(r)?l.removeAttributeNS(ho,go(r)):po(r)||l.removeAttribute(r))}}function Bo(n,e,t,r){r||n.tagName.indexOf("-")>-1?$o(n,e,t):mo(e)?yo(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):po(e)?n.setAttribute(e,function(n,e){return yo(e)||"false"===e?"false":"contenteditable"===n&&uo(e)?e:"true"}(e,t)):fo(e)?yo(t)?n.removeAttributeNS(ho,go(e)):n.setAttributeNS(ho,e,t):$o(n,e,t)}function $o(n,e,t){if(yo(t))n.removeAttribute(e);else{if(Q&&!X&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Vo={create:Wo,update:Wo};function Ko(n,e){var t=e.elm,r=e.data,o=n.data;if(!(a(r.staticClass)&&a(r.class)&&(a(o)||a(o.staticClass)&&a(o.class)))){var s=bo(e),l=t._transitionClasses;i(l)&&(s=ko(s,wo(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Jo,Go={create:Ko,update:Ko};function Qo(n,e,t){var r=Jo;return function o(){var a=e.apply(null,arguments);null!==a&&Yo(n,o,t,r)}}var Xo=wt&&!(en&&Number(en[1])<=53);function Zo(n,e,t,r){if(Xo){var o=fr,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=o||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}Jo.addEventListener(n,e,rn?{capture:t,passive:r}:t)}function Yo(n,e,t,r){(r||Jo).removeEventListener(n,e._wrapper||e,t)}function na(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Jo=e.elm||n.elm,function(n){if(i(n.__r)){var e=Q?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}i(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Ie(t,r,Zo,Yo,Qo,e.context),Jo=void 0}}var ea,ta={create:na,update:na,destroy:function(n){return na(n,Oo)}};function ra(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,r,o=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(i(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=j({},c)),l)t in c||(o[t]="");for(t in c){if(r=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===t&&"PROGRESS"!==o.tagName){o._value=r;var p=a(r)?"":String(r);oa(o,p)&&(o.value=p)}else if("innerHTML"===t&&Co(o.tagName)&&a(o.innerHTML)){(ea=ea||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var d=ea.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;d.firstChild;)o.appendChild(d.firstChild)}else if(r!==l[t])try{o[t]=r}catch(n){}}}}function oa(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(i(r)){if(r.number)return y(t)!==y(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var aa={create:ra,update:ra},ia=T((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function sa(n){var e=la(n.style);return n.staticStyle?j(n.staticStyle,e):e}function la(n){return Array.isArray(n)?O(n):"string"==typeof n?ia(n):n}var ca,pa=/^--/,da=/\s*!important$/,ua=function(n,e,t){if(pa.test(e))n.style.setProperty(e,t);else if(da.test(t))n.style.setProperty(P(e),t.replace(da,""),"important");else{var r=ha(e);if(Array.isArray(t))for(var o=0,a=t.length;o<a;o++)n.style[r]=t[o];else n.style[r]=t}},ma=["Webkit","Moz","ms"],ha=T((function(n){if(ca=ca||document.createElement("div").style,"filter"!==(n=R(n))&&n in ca)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ma.length;t++){var r=ma[t]+e;if(r in ca)return r}}));function fa(n,e){var t=e.data,r=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(r.staticStyle)&&a(r.style))){var o,s,l=e.elm,c=r.staticStyle,p=r.normalizedStyle||r.style||{},d=c||p,u=la(e.data.style)||{};e.data.normalizedStyle=i(u.__ob__)?j({},u):u;var m=function(n,e){var t,r={};if(e)for(var o=n;o.componentInstance;)(o=o.componentInstance._vnode)&&o.data&&(t=sa(o.data))&&j(r,t);(t=sa(n.data))&&j(r,t);for(var a=n;a=a.parent;)a.data&&(t=sa(a.data))&&j(r,t);return r}(e,!0);for(s in d)a(m[s])&&ua(l,s,"");for(s in m)(o=m[s])!==d[s]&&ua(l,s,null==o?"":o)}}var ga={create:fa,update:fa},ya=/\s+/;function ba(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ya).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function va(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ya).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ka(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&j(e,wa(n.name||"v")),j(e,n),e}return"string"==typeof n?wa(n):void 0}}var wa=T((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),xa=J&&!X,Ta="transition",Ca="transitionend",Ra="animation",Ea="animationend";xa&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Ta="WebkitTransition",Ca="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Ra="WebkitAnimation",Ea="webkitAnimationEnd"));var Sa=J?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Pa(n){Sa((function(){Sa(n)}))}function _a(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),ba(n,e))}function Ia(n,e){n._transitionClasses&&k(n._transitionClasses,e),va(n,e)}function ja(n,e,t){var r=Fa(n,e),o=r.type,a=r.timeout,i=r.propCount;if(!o)return t();var s="transition"===o?Ca:Ea,l=0,c=function(){n.removeEventListener(s,p),t()},p=function(e){e.target===n&&++l>=i&&c()};setTimeout((function(){l<i&&c()}),a+1),n.addEventListener(s,p)}var Oa=/\b(transform|all)(,|$)/;function Fa(n,e){var t,r=window.getComputedStyle(n),o=(r[Ta+"Delay"]||"").split(", "),a=(r[Ta+"Duration"]||"").split(", "),i=Aa(o,a),s=(r[Ra+"Delay"]||"").split(", "),l=(r[Ra+"Duration"]||"").split(", "),c=Aa(s,l),p=0,d=0;return"transition"===e?i>0&&(t="transition",p=i,d=a.length):"animation"===e?c>0&&(t="animation",p=c,d=l.length):d=(t=(p=Math.max(i,c))>0?i>c?"transition":"animation":null)?"transition"===t?a.length:l.length:0,{type:t,timeout:p,propCount:d,hasTransform:"transition"===t&&Oa.test(r[Ta+"Property"])}}function Aa(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Ma(e)+Ma(n[t])})))}function Ma(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Da(n,e){var t=n.elm;i(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=ka(n.data.transition);if(!a(r)&&!i(t._enterCb)&&1===t.nodeType){for(var o=r.css,s=r.type,l=r.enterClass,d=r.enterToClass,u=r.enterActiveClass,m=r.appearClass,h=r.appearToClass,f=r.appearActiveClass,g=r.beforeEnter,b=r.enter,v=r.afterEnter,k=r.enterCancelled,w=r.beforeAppear,x=r.appear,T=r.afterAppear,C=r.appearCancelled,R=r.duration,E=or,S=or.$vnode;S&&S.parent;)E=S.context,S=S.parent;var P=!E._isMounted||!n.isRootInsert;if(!P||x||""===x){var _=P&&m?m:l,I=P&&f?f:u,j=P&&h?h:d,O=P&&w||g,F=P&&c(x)?x:b,A=P&&T||v,M=P&&C||k,D=y(p(R)?R.enter:R);0;var z=!1!==o&&!X,L=La(F),U=t._enterCb=q((function(){z&&(Ia(t,j),Ia(t,I)),U.cancelled?(z&&Ia(t,_),M&&M(t)):A&&A(t),t._enterCb=null}));n.data.show||je(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),F&&F(t,U)})),O&&O(t),z&&(_a(t,_),_a(t,I),Pa((function(){Ia(t,_),U.cancelled||(_a(t,j),L||(qa(D)?setTimeout(U,D):ja(t,s,U)))}))),n.data.show&&(e&&e(),F&&F(t,U)),z||L||U()}}}function za(n,e){var t=n.elm;i(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=ka(n.data.transition);if(a(r)||1!==t.nodeType)return e();if(!i(t._leaveCb)){var o=r.css,s=r.type,l=r.leaveClass,c=r.leaveToClass,d=r.leaveActiveClass,u=r.beforeLeave,m=r.leave,h=r.afterLeave,f=r.leaveCancelled,g=r.delayLeave,b=r.duration,v=!1!==o&&!X,k=La(m),w=y(p(b)?b.leave:b);0;var x=t._leaveCb=q((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),v&&(Ia(t,c),Ia(t,d)),x.cancelled?(v&&Ia(t,l),f&&f(t)):(e(),h&&h(t)),t._leaveCb=null}));g?g(T):T()}function T(){x.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),u&&u(t),v&&(_a(t,l),_a(t,d),Pa((function(){Ia(t,l),x.cancelled||(_a(t,c),k||(qa(w)?setTimeout(x,w):ja(t,s,x)))}))),m&&m(t,x),v||k||x())}}function qa(n){return"number"==typeof n&&!isNaN(n)}function La(n){if(a(n))return!1;var e=n.fns;return i(e)?La(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Ua(n,e){!0!==e.data.show&&Da(e)}var Na=function(n){var e,t,r={},c=n.modules,p=n.nodeOps;for(e=0;e<Fo.length;++e)for(r[Fo[e]]=[],t=0;t<c.length;++t)i(c[t][Fo[e]])&&r[Fo[e]].push(c[t][Fo[e]]);function d(n){var e=p.parentNode(n);i(e)&&p.removeChild(e,n)}function u(n,e,t,o,a,l,c){if(i(n.elm)&&i(l)&&(n=l[c]=yn(n)),n.isRootInsert=!a,!function(n,e,t,o){var a=n.data;if(i(a)){var l=i(n.componentInstance)&&a.keepAlive;if(i(a=a.hook)&&i(a=a.init)&&a(n,!1),i(n.componentInstance))return m(n,e),h(t,n.elm,o),s(l)&&function(n,e,t,o){var a,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,i(a=s.data)&&i(a=a.transition)){for(a=0;a<r.activate.length;++a)r.activate[a](Oo,s);e.push(s);break}h(t,n.elm,o)}(n,e,t,o),!0}}(n,e,t,o)){var d=n.data,u=n.children,g=n.tag;i(g)?(n.elm=n.ns?p.createElementNS(n.ns,g):p.createElement(g,n),v(n),f(n,u,e),i(d)&&y(n,e),h(t,n.elm,o)):s(n.isComment)?(n.elm=p.createComment(n.text),h(t,n.elm,o)):(n.elm=p.createTextNode(n.text),h(t,n.elm,o))}}function m(n,e){i(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(y(n,e),v(n)):(Io(n),e.push(n))}function h(n,e,t){i(n)&&(i(t)?p.parentNode(t)===n&&p.insertBefore(n,e,t):p.appendChild(n,e))}function f(n,e,t){if(o(e)){0;for(var r=0;r<e.length;++r)u(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&p.appendChild(n.elm,p.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return i(n.tag)}function y(n,t){for(var o=0;o<r.create.length;++o)r.create[o](Oo,n);i(e=n.data.hook)&&(i(e.create)&&e.create(Oo,n),i(e.insert)&&t.push(n))}function v(n){var e;if(i(e=n.fnScopeId))p.setStyleScope(n.elm,e);else for(var t=n;t;)i(e=t.context)&&i(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e),t=t.parent;i(e=or)&&e!==n.context&&e!==n.fnContext&&i(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e)}function k(n,e,t,r,o,a){for(;r<=o;++r)u(t[r],a,n,e,!1,t,r)}function w(n){var e,t,o=n.data;if(i(o))for(i(e=o.hook)&&i(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(i(e=n.children))for(t=0;t<n.children.length;++t)w(n.children[t])}function x(n,e,t){for(;e<=t;++e){var r=n[e];i(r)&&(i(r.tag)?(T(r),w(r)):d(r.elm))}}function T(n,e){if(i(e)||i(n.data)){var t,o=r.remove.length+1;for(i(e)?e.listeners+=o:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,o),i(t=n.componentInstance)&&i(t=t._vnode)&&i(t.data)&&T(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);i(t=n.data.hook)&&i(t=t.remove)?t(n,e):e()}else d(n.elm)}function C(n,e,t,r){for(var o=t;o<r;o++){var a=e[o];if(i(a)&&Ao(n,a))return o}}function R(n,e,t,o,l,c){if(n!==e){i(e.elm)&&i(o)&&(e=o[l]=yn(e));var d=e.elm=n.elm;if(s(n.isAsyncPlaceholder))i(e.asyncFactory.resolved)?P(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;i(h)&&i(m=h.hook)&&i(m=m.prepatch)&&m(n,e);var f=n.children,y=e.children;if(i(h)&&g(e)){for(m=0;m<r.update.length;++m)r.update[m](n,e);i(m=h.hook)&&i(m=m.update)&&m(n,e)}a(e.text)?i(f)&&i(y)?f!==y&&function(n,e,t,r,o){var s,l,c,d=0,m=0,h=e.length-1,f=e[0],g=e[h],y=t.length-1,b=t[0],v=t[y],w=!o;for(0;d<=h&&m<=y;)a(f)?f=e[++d]:a(g)?g=e[--h]:Ao(f,b)?(R(f,b,r,t,m),f=e[++d],b=t[++m]):Ao(g,v)?(R(g,v,r,t,y),g=e[--h],v=t[--y]):Ao(f,v)?(R(f,v,r,t,y),w&&p.insertBefore(n,f.elm,p.nextSibling(g.elm)),f=e[++d],v=t[--y]):Ao(g,b)?(R(g,b,r,t,m),w&&p.insertBefore(n,g.elm,f.elm),g=e[--h],b=t[++m]):(a(s)&&(s=Mo(e,d,h)),a(l=i(b.key)?s[b.key]:C(b,e,d,h))?u(b,r,n,f.elm,!1,t,m):Ao(c=e[l],b)?(R(c,b,r,t,m),e[l]=void 0,w&&p.insertBefore(n,c.elm,f.elm)):u(b,r,n,f.elm,!1,t,m),b=t[++m]);d>h?k(n,a(t[y+1])?null:t[y+1].elm,t,m,y,r):m>y&&x(e,d,h)}(d,f,y,t,c):i(y)?(i(n.text)&&p.setTextContent(d,""),k(d,null,y,0,y.length-1,t)):i(f)?x(f,0,f.length-1):i(n.text)&&p.setTextContent(d,""):n.text!==e.text&&p.setTextContent(d,e.text),i(h)&&i(m=h.hook)&&i(m=m.postpatch)&&m(n,e)}}}function E(n,e,t){if(s(t)&&i(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var S=b("attrs,class,staticClass,staticStyle,key");function P(n,e,t,r){var o,a=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&i(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(i(l)&&(i(o=l.hook)&&i(o=o.init)&&o(e,!0),i(o=e.componentInstance)))return m(e,t),!0;if(i(a)){if(i(c))if(n.hasChildNodes())if(i(o=l)&&i(o=o.domProps)&&i(o=o.innerHTML)){if(o!==n.innerHTML)return!1}else{for(var p=!0,d=n.firstChild,u=0;u<c.length;u++){if(!d||!P(d,c[u],t,r)){p=!1;break}d=d.nextSibling}if(!p||d)return!1}else f(e,c,t);if(i(l)){var h=!1;for(var g in l)if(!S(g)){h=!0,y(e,t);break}!h&&l.class&&Qt(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,o){if(!a(e)){var l,c=!1,d=[];if(a(n))c=!0,u(e,d);else{var m=i(n.nodeType);if(!m&&Ao(n,e))R(n,e,d,null,null,o);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&P(n,e,d))return E(e,d,!0),n;l=n,n=new hn(p.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,f=p.parentNode(h);if(u(e,d,h._leaveCb?null:f,p.nextSibling(h)),i(e.parent))for(var y=e.parent,b=g(e);y;){for(var v=0;v<r.destroy.length;++v)r.destroy[v](y);if(y.elm=e.elm,b){for(var k=0;k<r.create.length;++k)r.create[k](Oo,y);var T=y.data.hook.insert;if(T.merged)for(var C=1;C<T.fns.length;C++)T.fns[C]()}else Io(y);y=y.parent}i(f)?x([n],0,0):i(n.tag)&&w(n)}}return E(e,d,c),e.elm}i(n)&&w(n)}}({nodeOps:Po,modules:[Vo,Go,ta,aa,ga,J?{create:Ua,activate:Ua,remove:function(n,e){!0!==n.data.show?za(n,e):e()}}:{}].concat(Ho)});X&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Ga(n,"input")}));var Ha={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?je(t,"postpatch",(function(){Ha.componentUpdated(n,e,t)})):Wa(n,e,t.context),n._vOptions=[].map.call(n.options,Va)):("textarea"===t.tag||So(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Ka),n.addEventListener("compositionend",Ja),n.addEventListener("change",Ja),X&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Wa(n,e,t.context);var r=n._vOptions,o=n._vOptions=[].map.call(n.options,Va);if(o.some((function(n,e){return!D(n,r[e])})))(n.multiple?e.value.some((function(n){return $a(n,o)})):e.value!==e.oldValue&&$a(e.value,o))&&Ga(n,"change")}}};function Wa(n,e,t){Ba(n,e,t),(Q||Z)&&setTimeout((function(){Ba(n,e,t)}),0)}function Ba(n,e,t){var r=e.value,o=n.multiple;if(!o||Array.isArray(r)){for(var a,i,s=0,l=n.options.length;s<l;s++)if(i=n.options[s],o)a=z(r,Va(i))>-1,i.selected!==a&&(i.selected=a);else if(D(Va(i),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));o||(n.selectedIndex=-1)}}function $a(n,e){return e.every((function(e){return!D(e,n)}))}function Va(n){return"_value"in n?n._value:n.value}function Ka(n){n.target.composing=!0}function Ja(n){n.target.composing&&(n.target.composing=!1,Ga(n.target,"input"))}function Ga(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Qa(n){return!n.componentInstance||n.data&&n.data.transition?n:Qa(n.componentInstance._vnode)}var Xa={model:Ha,show:{bind:function(n,e,t){var r=e.value,o=(t=Qa(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&o?(t.data.show=!0,Da(t,(function(){n.style.display=a}))):n.style.display=r?a:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=Qa(t)).data&&t.data.transition?(t.data.show=!0,r?Da(t,(function(){n.style.display=n.__vOriginalDisplay})):za(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,o){o||(n.style.display=n.__vOriginalDisplay)}}},Za={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ya(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Ya(mt(e.children)):n}function ni(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var o=t._parentListeners;for(var r in o)e[R(r)]=o[r];return e}function ei(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var ti=function(n){return n.tag||Ze(n)},ri=function(n){return"show"===n.name},oi={name:"transition",props:Za,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(ti)).length){0;var r=this.mode;0;var o=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return o;var a=Ya(o);if(!a)return o;if(this._leaving)return ei(n,o);var i="__transition-".concat(this._uid,"-");a.key=null==a.key?a.isComment?i+"comment":i+a.tag:l(a.key)?0===String(a.key).indexOf(i)?a.key:i+a.key:a.key;var s=(a.data||(a.data={})).transition=ni(this),c=this._vnode,p=Ya(c);if(a.data.directives&&a.data.directives.some(ri)&&(a.data.show=!0),p&&p.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,p)&&!Ze(p)&&(!p.componentInstance||!p.componentInstance._vnode.isComment)){var d=p.data.transition=j({},s);if("out-in"===r)return this._leaving=!0,je(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),ei(n,o);if("in-out"===r){if(Ze(a))return c;var u,m=function(){u()};je(s,"afterEnter",m),je(s,"enterCancelled",m),je(d,"delayLeave",(function(n){u=n}))}}return o}}},ai=j({tag:String,moveClass:String},Za);function ii(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function si(n){n.data.newPos=n.elm.getBoundingClientRect()}function li(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,o=e.top-t.top;if(r||o){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate(".concat(r,"px,").concat(o,"px)"),a.transitionDuration="0s"}}delete ai.mode;var ci={Transition:oi,TransitionGroup:{props:ai,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var o=ar(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,o(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,o=this.$slots.default||[],a=this.children=[],i=ni(this),s=0;s<o.length;s++){if((p=o[s]).tag)if(null!=p.key&&0!==String(p.key).indexOf("__vlist"))a.push(p),t[p.key]=p,(p.data||(p.data={})).transition=i;else;}if(r){var l=[],c=[];for(s=0;s<r.length;s++){var p;(p=r[s]).data.transition=i,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?l.push(p):c.push(p)}this.kept=n(e,null,l),this.removed=c}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(ii),n.forEach(si),n.forEach(li),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;_a(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(Ca,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(Ca,n),t._moveCb=null,Ia(t,e))})}})))},methods:{hasMove:function(n,e){if(!xa)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){va(t,n)})),ba(t,e),t.style.display="none",this.$el.appendChild(t);var r=Fa(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};no.config.mustUseProp=function(n,e,t){return"value"===t&&co(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},no.config.isReservedTag=Ro,no.config.isReservedAttr=lo,no.config.getTagNamespace=function(n){return Co(n)?"svg":"math"===n?"math":void 0},no.config.isUnknownElement=function(n){if(!J)return!0;if(Ro(n))return!1;if(n=n.toLowerCase(),null!=Eo[n])return Eo[n];var e=document.createElement(n);return n.indexOf("-")>-1?Eo[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Eo[n]=/HTMLUnknownElement/.test(e.toString())},j(no.options.directives,Xa),j(no.options.components,ci),no.prototype.__patch__=J?Na:F,no.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=fn),lr(n,"beforeMount"),r=function(){n._update(n._render(),t)},new Yt(n,r,F,{before:function(){n._isMounted&&!n._isDestroyed&&lr(n,"beforeUpdate")}},!0),t=!1;var o=n._preWatchers;if(o)for(var a=0;a<o.length;a++)o[a].run();return null==n.$vnode&&(n._isMounted=!0,lr(n,"mounted")),n}(this,n=n&&J?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},J&&setTimeout((function(){H.devtools&&sn&&sn.emit("init",no)}),0)}.call(this,t(21))},function(n,e,t){"use strict";function r(n,e,t,r,o,a,i,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),a&&(c._scopeId="data-v-"+a),i?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),o&&o.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},c._ssrRegister=l):o&&(l=s?function(){o.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:o),l)if(c.functional){c._injectStyles=l;var p=c.render;c.render=function(n,e){return l.call(e),p(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(63),o=r.all;n.exports=r.IS_HTMLDDA?function(n){return"function"==typeof n||n===o}:function(n){return"function"==typeof n}},function(n,e,t){(function(e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof e&&e)||function(){return this}()||Function("return this")()}).call(this,t(21))},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var r=t(5);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(18),o=t(59);n.exports=function(n){if("Function"===r(n))return o(n)}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(7),o=t(36),a=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(o(n),e)}},function(n,e,t){var r=t(77),o="object"==typeof self&&self&&self.Object===Object&&self,a=r||o||Function("return this")();n.exports=a},function(n,e,t){var r=t(3),o=t(63),a=o.all;n.exports=o.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:r(n)||n===a}:function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(175),o=t(178);n.exports=function(n,e){var t=o(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return a})),t.d(e,"j",(function(){return i})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return p})),t.d(e,"c",(function(){return d})),t.d(e,"f",(function(){return u})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return y})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return k}));t(20);const r=/#.*$/,o=/\.(md|html)$/,a=/\/$/,i=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(o,"")}function l(n){return i.test(n)}function c(n){return/^mailto:/.test(n)}function p(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;if(!n)return"404";const e=n.match(r),t=e?e[0]:"",o=s(n);return a.test(o)?n:o+".html"+t}function u(n,e){const t=n.hash,o=function(n){const e=n&&n.match(r);if(e)return e[0]}(e);if(o&&t!==o)return!1;return s(n.path)===s(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;const o=e.split("/");t&&o[o.length-1]||o.pop();const a=n.replace(/^\//,"").split("/");for(let n=0;n<a.length;n++){const e=a[n];".."===e?o.pop():"."!==e&&o.push(e)}""!==o[0]&&o.unshift("");return o.join("/")}(e,t));const r=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===r)return Object.assign({},n[e],{type:"page",path:d(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,r){const{pages:o,themeConfig:a}=t,i=r&&a.locales&&a.locales[r]||a;if("auto"===(n.frontmatter.sidebar||i.sidebar||a.sidebar))return f(n);const s=i.sidebar||a.sidebar;if(s){const{base:t,config:r}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const r in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:e[r]};var t;return{}}(e,s);return"auto"===r?f(n):r?r.map(n=>function n(e,t,r,o=1){if("string"==typeof e)return m(t,e,r);if(Array.isArray(e))return Object.assign(m(t,e[0],r),{title:e[1]});{o>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const a=e.children||[];return 0===a.length&&e.path?Object.assign(m(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:a.map(e=>n(e,t,r,o+1)),collapsable:!1!==e.collapsable}}}(n,o,t)):[]}return[]}function f(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function y(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function v(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function k(n,e){return v(e)-v(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";var r=t(1);e.a=new r.default},function(n,e,t){var r=t(6),o=t(72),a=t(111),i=t(33),s=t(62),l=TypeError,c=Object.defineProperty,p=Object.getOwnPropertyDescriptor;e.f=r?a?function(n,e,t){if(i(n),e=s(e),i(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=p(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(i(n),e=s(e),i(t),o)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(19),o=t(160),a=t(161),i=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?o(n):a(n)}},function(n,e,t){var r=t(59),o=r({}.toString),a=r("".slice);n.exports=function(n){return a(o(n),8,-1)}},function(n,e,t){var r=t(10).Symbol;n.exports=r},function(n,e,t){"use strict";var r=t(22),o=t(36),a=t(37),i=t(141),s=t(143),l=t(5)((function(){return 4294967297!==[].push.call({length:4294967296},1)})),c=!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}();r({target:"Array",proto:!0,arity:1,forced:l||c},{push:function(n){var e=o(this),t=a(e),r=arguments.length;s(t+r);for(var l=0;l<r;l++)e[t]=arguments[l],t++;return i(e,t),t}})},function(n,e){var t;t=function(){return this}();try{t=t||new Function("return this")()}catch(n){"object"==typeof window&&(t=window)}n.exports=t},function(n,e,t){var r=t(4),o=t(58).f,a=t(25),i=t(124),s=t(41),l=t(73),c=t(137);n.exports=function(n,e){var t,p,d,u,m,h=n.target,f=n.global,g=n.stat;if(t=f?r:g?r[h]||s(h,{}):(r[h]||{}).prototype)for(p in e){if(u=e[p],d=n.dontCallGetSet?(m=o(t,p))&&m.value:t[p],!c(f?p:h+(g?".":"#")+p,n.forced)&&void 0!==d){if(typeof u==typeof d)continue;l(u,d)}(n.sham||d&&d.sham)&&a(u,"sham",!0),i(t,p,u,n)}}},function(n,e,t){var r=t(4),o=t(3),a=function(n){return o(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(r[n]):r[n]&&r[n][e]}},function(n,e,t){var r=t(4),o=t(69),a=t(9),i=t(71),s=t(67),l=t(66),c=o("wks"),p=r.Symbol,d=p&&p.for,u=l?p:p&&p.withoutSetter||i;n.exports=function(n){if(!a(c,n)||!s&&"string"!=typeof c[n]){var e="Symbol."+n;s&&a(p,n)?c[n]=p[n]:c[n]=l&&d?d(e):u(e)}return c[n]}},function(n,e,t){var r=t(6),o=t(16),a=t(39);n.exports=r?function(n,e,t){return o.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(165),o=t(166),a=t(167),i=t(168),s=t(169);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(79);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(12)(Object,"create");n.exports=r},function(n,e,t){var r=t(187);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(49);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,o;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(o="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function o(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=o(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),p=r.speed,d=r.easing;return l.offsetWidth,i((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var o;return(o="translate3d"===r.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,o}(n,p,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+p+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),p)}),p)):setTimeout(e,p)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*o(Math.random()*e,.1,.95)),e=o(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var o,i=e.querySelector(r.barSelector),l=n?"-100":a(t.status||0),p=document.querySelector(r.parent);return s(i,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(o=e.querySelector(r.spinnerSelector))&&u(o),p!=document.body&&c(p,"nprogress-custom-parent"),p.appendChild(e),e},t.remove=function(){p(document.documentElement,"nprogress-busy"),p(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&u(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,o=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);o--;)if((r=n[o]+a)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,o,a=arguments;if(2==a.length)for(t in e)void 0!==(o=e[t])&&e.hasOwnProperty(t)&&r(n,t,o);else r(n,a[1],a[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function p(n,e){var t,r=d(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function u(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=o)},function(n){n.exports=JSON.parse('{"name":"vuepress-plugin-comment","version":"0.7.3","description":"Comment plugin in vuepress, such as Gitalk, Valine...","main":"index.js","scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"author":"dongyuanxin","license":"MIT","bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"}}')},function(n,e,t){var r=t(11),o=String,a=TypeError;n.exports=function(n){if(r(n))return n;throw a(o(n)+" is not an object")}},function(n,e,t){var r=t(5);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var r=t(53),o=t(60);n.exports=function(n){return r(o(n))}},function(n,e,t){var r=t(60),o=Object;n.exports=function(n){return o(r(n))}},function(n,e,t){var r=t(135);n.exports=function(n){return r(n.length)}},function(n,e,t){var r=t(34),o=Function.prototype.call;n.exports=r?o.bind(o):function(){return o.apply(o,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(4),o=t(41),a=r["__core-js_shared__"]||o("__core-js_shared__",{});n.exports=a},function(n,e,t){var r=t(4),o=Object.defineProperty;n.exports=function(n,e){try{o(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(159),o=t(14),a=Object.prototype,i=a.hasOwnProperty,s=a.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return o(n)&&i.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(12)(t(10),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(179),o=t(186),a=t(188),i=t(189),s=t(190);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(8),o=t(49),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!o(n))||(i.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(17),o=t(14);n.exports=function(n){return"symbol"==typeof n||o(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";t.r(e);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}class o{constructor(){r(this,"TABEL","fZodR9XQDSUm21yCkr6zBqiveYah8bt4xsWpHnJE7jL5VG3guMTKNPAwcF"),r(this,"TR",{}),r(this,"S",[11,10,3,8,4,6]),r(this,"XOR",177451812),r(this,"ADD",8728348608),this.init()}init(){const n=this.TABEL.length;for(let e=0;e<n;e++)this.TR[this.TABEL[e]]=e}av2bv(n){const e=(n^this.XOR)+this.ADD,t=["B","V","1",,,"4",,"1",,"7"];for(let n=0;n<6;n++)t[this.S[n]]=this.TABEL[Math.floor(e/58**n)%58];return t.join("")}bv2av(n){let e=0;for(let t=0;t<6;t++)e+=this.TR[n[this.S[t]]]*58**t;return"av"+String(e-this.ADD^this.XOR)}}var a={name:"Bilibili",data(){return{afs:!![!0,"true","allowfullscreen"].includes(this.allowfullscreen)}},props:{id:{type:String,required:!0},danmaku:{type:Boolean,default:!1,required:!1},page:{type:Number,default:1,required:!1},sandbox:{type:String,default:"allow-top-navigation allow-same-origin allow-forms allow-scripts allow-popups",required:!1},allowfullscreen:{type:[String,Boolean],required:!1,default:"allowfullscreen"},width:{type:String,required:!1,default:"100%"},height:{type:Array,required:!1,default:()=>[9/16,70]}},computed:{bvid(){if(!this.id||this.id.toLowerCase().startsWith("bv"))return this.id;const n=this.id.toLowerCase().startsWith("av")?this.id.slice(2):this.id;return o.av2bv(n)},avid(){return o.bv2av(this.bvid)},src(){return`//player.bilibili.com/player.html?bvid=${this.bvid}&page=${this.page}&danmaku=${this.danmaku}`}},mounted(){this.$nextTick(()=>{let n=this.$refs.sbplayer;n&&(n.style.height=n.scrollWidth*this.height[0]+this.height[1]+"px")})}},i=(t(254),t(2)),s=Object(i.a)(a,(function(){var n=this._self._c;return n("div",{staticClass:"biliPlayer"},[n("iframe",{ref:"sbplayer",staticClass:"player",style:{width:this.width},attrs:{src:this.src,allowfullscreen:this.afs,scrolling:"no",frameborder:"0",sandbox:this.sandbox}})])}),[],!1,null,"f246d424",null);e.default=s.exports},function(n,e,t){"use strict";t.r(e);var r={name:"LastReadingPopup",data:()=>({lastReading:null,show:!1}),computed:{popupConfig(){const n={"/":{message:"检测到您上一次阅读的位置，是否移至该位置？",sureButtonText:"确定",cancelButtonText:"取消"},"/zh/":{message:"检测到您上一次阅读的位置，是否移至该位置？",sureButtonText:"前往",cancelButtonText:"取消"}};return n[`/${this.$lang.split("-")[0]}/`]||n[this.$localePath]||n},message(){const n=this.popupConfig;return n&&n.message||n["/"].message},sureButtonText(){const n=this.popupConfig;return n&&n.sureButtonText||n["/"].sureButtonText},cancelButtonText(){const n=this.popupConfig;return n&&n.cancelButtonText||n["/"].cancelButtonText}},mounted(){window.ActiveXObject||"ActiveXObject"in window?setTimeout(()=>{window.addEventListener("load",this.init())},1e3):setTimeout(()=>{window.addEventListener("load",this.init)},1e3)},methods:{init(){this.lastReading=JSON.parse(localStorage.getItem("lastReading")),this.lastReading&&(this.$route.path===this.lastReading.path?this.goto():(this.show=!0,setTimeout(this.clean,1e4)))},goto(){this.$route.path!==this.lastReading.path?this.$router.replace(this.lastReading.path).then(()=>{document.documentElement.scrollTop=this.lastReading.scrollTop,this.clean()}):this.$nextTick(()=>{document.documentElement.scrollTop=this.lastReading.scrollTop})},dontgoto(){this.clean()},clean(){this.show=!1,localStorage.removeItem("lastReading")}}},o=(t(253),t(2)),a=Object(o.a)(r,(function(){var n=this,e=n._self._c;return e("transition",{attrs:{name:"sw-update-popup"}},[n.show?e("div",{staticClass:"sw-update-popup"},[n._v("\n    "+n._s(n.message)+"\n\n    "),e("br"),n._v(" "),e("button",{on:{click:n.goto}},[n._v("\n      "+n._s(n.sureButtonText)+"\n    ")]),n._v(" "),e("button",{on:{click:n.dontgoto}},[n._v("\n      "+n._s(n.cancelButtonText)+"\n    ")])]):n._e()])}),[],!1,null,"181714f2",null);e.default=a.exports},function(n,e,t){var r=t(7),o=t(5),a=t(18),i=Object,s=r("".split);n.exports=o((function(){return!i("z").propertyIsEnumerable(0)}))?function(n){return"String"==a(n)?s(n,""):i(n)}:i},function(n,e,t){var r=t(3),o=t(122),a=TypeError;n.exports=function(n){if(r(n))return n;throw a(o(n)+" is not a function")}},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){(function(e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,o=/^0b[01]+$/i,a=/^0o[0-7]+$/i,i=parseInt,s="object"==typeof e&&e&&e.Object===Object&&e,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),p=Object.prototype.toString,d=Math.max,u=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==p.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=o.test(n);return s||a.test(n)?i(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,o,a,i,s,l,c=0,p=!1,g=!1,y=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=r,a=o;return r=o=void 0,c=e,i=n.apply(a,t)}function v(n){return c=n,s=setTimeout(w,e),p?b(n):i}function k(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=a}function w(){var n=m();if(k(n))return x(n);s=setTimeout(w,function(n){var t=e-(n-l);return g?u(t,a-(n-c)):t}(n))}function x(n){return s=void 0,y&&r?b(n):(r=o=void 0,i)}function T(){var n=m(),t=k(n);if(r=arguments,o=this,l=n,t){if(void 0===s)return v(l);if(g)return s=setTimeout(w,e),b(l)}return void 0===s&&(s=setTimeout(w,e)),i}return e=f(e)||0,h(t)&&(p=!!t.leading,a=(g="maxWait"in t)?d(f(t.maxWait)||0,e):a,y="trailing"in t?!!t.trailing:y),T.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=o=s=void 0},T.flush=function(){return void 0===s?i:x(m())},T}}).call(this,t(21))},function(n,e,t){var r=t(6),o=t(38),a=t(118),i=t(39),s=t(35),l=t(62),c=t(9),p=t(72),d=Object.getOwnPropertyDescriptor;e.f=r?d:function(n,e){if(n=s(n),e=l(e),p)try{return d(n,e)}catch(n){}if(c(n,e))return i(!o(a.f,n,e),n[e])}},function(n,e,t){var r=t(34),o=Function.prototype,a=o.call,i=r&&o.bind.bind(a,a);n.exports=r?i:function(n){return function(){return a.apply(n,arguments)}}},function(n,e,t){var r=t(61),o=TypeError;n.exports=function(n){if(r(n))throw o("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var r=t(119),o=t(64);n.exports=function(n){var e=r(n,"string");return o(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,r=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:r}},function(n,e,t){var r=t(23),o=t(3),a=t(65),i=t(66),s=Object;n.exports=i?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return o(e)&&a(e.prototype,s(n))}},function(n,e,t){var r=t(7);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r=t(67);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(68),o=t(5);n.exports=!!Object.getOwnPropertySymbols&&!o((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,o,a=t(4),i=t(120),s=a.process,l=a.Deno,c=s&&s.versions||l&&l.version,p=c&&c.v8;p&&(o=(r=p.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!o&&i&&(!(r=i.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=i.match(/Chrome\/(\d+)/))&&(o=+r[1]),n.exports=o},function(n,e,t){var r=t(70),o=t(40);(n.exports=function(n,e){return o[n]||(o[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.26.0",mode:r?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.26.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var r=t(7),o=0,a=Math.random(),i=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+i(++o+a,36)}},function(n,e,t){var r=t(6),o=t(5),a=t(110);n.exports=!r&&!o((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(9),o=t(130),a=t(58),i=t(16);n.exports=function(n,e,t){for(var s=o(e),l=i.f,c=a.f,p=0;p<s.length;p++){var d=s[p];r(n,d)||t&&r(t,d)||l(n,d,c(e,d))}}},function(n,e,t){var r=t(134);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){var r=t(7),o=t(33),a=t(147);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return o(t),a(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,o=n.length;++t<r;)n[o+t]=e[t];return n}},function(n,e,t){(function(e){var t="object"==typeof e&&e&&e.Object===Object&&e;n.exports=t}).call(this,t(21))},function(n,e,t){var r=t(26),o=t(170),a=t(171),i=t(172),s=t(173),l=t(174);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=o,c.prototype.delete=a,c.prototype.get=i,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(17),o=t(44);n.exports=function(n){if(!o(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(191),o=t(14);n.exports=function n(e,t,a,i,s){return e===t||(null==e||null==t||!o(e)&&!o(t)?e!=e&&t!=t:r(e,t,a,i,n,s))}},function(n,e,t){var r=t(84),o=t(194),a=t(85);n.exports=function(n,e,t,i,s,l){var c=1&t,p=n.length,d=e.length;if(p!=d&&!(c&&d>p))return!1;var u=l.get(n),m=l.get(e);if(u&&m)return u==e&&m==n;var h=-1,f=!0,g=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++h<p;){var y=n[h],b=e[h];if(i)var v=c?i(b,y,h,e,n,l):i(y,b,h,n,e,l);if(void 0!==v){if(v)continue;f=!1;break}if(g){if(!o(e,(function(n,e){if(!a(g,e)&&(y===n||s(y,n,t,i,l)))return g.push(e)}))){f=!1;break}}else if(y!==b&&!s(y,b,t,i,l)){f=!1;break}}return l.delete(n),l.delete(e),f}},function(n,e,t){var r=t(45),o=t(192),a=t(193);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=o,i.prototype.has=a,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(204),o=t(210),a=t(90);n.exports=function(n){return a(n)?r(n):o(n)}},function(n,e,t){(function(n){var r=t(10),o=t(206),a=e&&!e.nodeType&&e,i=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=i&&i.exports===a?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||o;n.exports=l}).call(this,t(56)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(207),o=t(208),a=t(209),i=a&&a.isTypedArray,s=i?o(i):r;n.exports=s},function(n,e,t){var r=t(80),o=t(47);n.exports=function(n){return null!=n&&o(n.length)&&!r(n)}},function(n,e,t){var r=t(12)(t(10),"Set");n.exports=r},function(n,e,t){var r=t(44);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(95),o=t(30);n.exports=function(n,e){for(var t=0,a=(e=r(e,n)).length;null!=n&&t<a;)n=n[o(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var r=t(8),o=t(48),a=t(221),i=t(224);n.exports=function(n,e){return r(n)?n:o(n,e)?[n]:a(i(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(157),o=t(162),a=t(233),i=t(241),s=t(250),l=t(114),c=a((function(n){var e=l(n);return s(e)&&(e=void 0),i(r(n,1,s,!0),o(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,o=r.exec(t);if(!o)return t;var a="",i=0,s=0;for(i=o.index;i<t.length;i++){switch(t.charCodeAt(i)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==i&&(a+=t.substring(s,i)),s=i+1,a+=e}return s!==i?a+t.substring(s,i):a}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var r=t(262),o=t(263),a=t(264),i=!1,s=t(265).version,l=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=l.concat("cache"),p=/^\uFEFF/;function d(n,t){var o,a,i=t.views,s=/^[A-Za-z]+:\\|^\//.exec(n);if(s&&s.length)o=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(a=e.resolveInclude(n,t.filename),r.existsSync(a)&&(o=a)),o||Array.isArray(i)&&i.some((function(t){return a=e.resolveInclude(n,t,!0),r.existsSync(a)}))&&(o=a),!o)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return o}function u(n,t){var r,o=n.filename,a=arguments.length>1;if(n.cache){if(!o)throw new Error("cache option requires a filename");if(r=e.cache.get(o))return r;a||(t=h(o).toString().replace(p,""))}else if(!a){if(!o)throw new Error("Internal EJS error: no file name or template provided");t=h(o).toString().replace(p,"")}return r=e.compile(t,n),n.cache&&e.cache.set(o,r),r}function m(n,t,r){var o;if(!r){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,r){try{e(o=u(n)(t))}catch(n){r(n)}}));throw new Error("Please provide a callback function")}try{o=u(n)(t)}catch(n){return r(n)}r(null,o)}function h(n){return e.fileLoader(n)}function f(n,e,t,r,o){var a=e.split("\n"),i=Math.max(r-3,0),s=Math.min(a.length,r+3),l=o(t),c=a.slice(i,s).map((function(n,e){var t=e+i+1;return(t==r?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=l,n.message=(l||"ejs")+":"+r+"\n"+c+"\n\n"+n.message,n}function g(n){return n.replace(/;(\s*$)/,"$1")}function y(n,t){t=t||{};var r={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],r.client=t.client||!1,r.escapeFunction=t.escape||t.escapeFunction||a.escapeXML,r.compileDebug=!1!==t.compileDebug,r.debug=!!t.debug,r.filename=t.filename,r.openDelimiter=t.openDelimiter||e.openDelimiter||"<",r.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",r.delimiter=t.delimiter||e.delimiter||"%",r.strict=t.strict||!1,r.context=t.context,r.cache=t.cache||!1,r.rmWhitespace=t.rmWhitespace,r.root=t.root,r.outputFunctionName=t.outputFunctionName,r.localsName=t.localsName||e.localsName||"locals",r.views=t.views,r.async=t.async,r.destructuredLocals=t.destructuredLocals,r.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,r.strict?r._with=!1:r._with=void 0===t._with||t._with,this.opts=r,this.regex=this.createRegex()}e.cache=a.cache,e.fileLoader=r.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var r=o.dirname,a=o.extname,i=(0,o.resolve)(t?e:r(e),n);return a(n)||(i+=".ejs"),i},e.compile=function(n,e){return e&&e.scope&&(i||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),i=!0),e.context||(e.context=e.scope),delete e.scope),new y(n,e).compile()},e.render=function(n,e,t){var r=e||{},o=t||{};return 2==arguments.length&&a.shallowCopyFromList(o,r,l),u(o,n)(r)},e.renderFile=function(){var n,e,t,r=Array.prototype.slice.call(arguments),o=r.shift(),i={filename:o};return"function"==typeof arguments[arguments.length-1]&&(n=r.pop()),r.length?(e=r.shift(),r.length?a.shallowCopy(i,r.pop()):(e.settings&&(e.settings.views&&(i.views=e.settings.views),e.settings["view cache"]&&(i.cache=!0),(t=e.settings["view options"])&&a.shallowCopy(i,t)),a.shallowCopyFromList(i,e,c)),i.filename=o):e={},m(i,e,n)},e.Template=y,e.clearCache=function(){e.cache.reset()},y.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},y.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=a.escapeRegExpChars(this.opts.delimiter),t=a.escapeRegExpChars(this.opts.openDelimiter),r=a.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,r),new RegExp(n)},compile:function(){var n,e,t,r=this.opts,i="",s="",l=r.escapeFunction;if(!this.source){if(this.generateSource(),i+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',r.outputFunctionName&&(i+="  var "+r.outputFunctionName+" = __append;\n"),r.destructuredLocals&&r.destructuredLocals.length){for(var c="  var __locals = ("+r.localsName+" || {}),\n",p=0;p<r.destructuredLocals.length;p++){var m=r.destructuredLocals[p];p>0&&(c+=",\n  "),c+=m+" = __locals."+m}i+=c+";\n"}!1!==r._with&&(i+="  with ("+r.localsName+" || {}) {\n",s+="  }\n"),s+="  return __output;\n",this.source=i+this.source+s}n=r.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(r.filename?JSON.stringify(r.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,r.client&&(n="escapeFn = escapeFn || "+l.toString()+";\n"+n,r.compileDebug&&(n="rethrow = rethrow || "+f.toString()+";\n"+n)),r.strict&&(n='"use strict";\n'+n),r.debug&&console.log(n),r.compileDebug&&r.filename&&(n=n+"\n//# sourceURL="+r.filename+"\n");try{if(r.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(r.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(r.filename&&(n.message+=" in "+r.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",r.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var h=r.client?e:function(n){return e.apply(r.context,[n||{},l,function(e,t){var o=a.shallowCopy({},n);return t&&(o=a.shallowCopy(o,t)),function(n,e){var t=a.shallowCopy({},e);return t.filename=d(n,t),u(t)}(e,r)(o)},f])};if(h.dependencies=this.dependencies,r.filename&&"function"==typeof Object.defineProperty){var g=r.filename,y=o.basename(g,o.extname(g));try{Object.defineProperty(h,"name",{value:y,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return h},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,r=this.parseTemplateText(),o=this.opts.delimiter,i=this.opts.openDelimiter,s=this.opts.closeDelimiter;r&&r.length&&r.forEach((function(l,c){var u,m,f,g,b,v;if(0===l.indexOf(i+o)&&0!==l.indexOf(i+o+o)&&(m=r[c+2])!=o+s&&m!="-"+o+s&&m!="_"+o+s)throw new Error('Could not find matching close tag for "'+l+'".');if(n.legacyInclude&&(f=l.match(/^\s*include\s+(\S+)/))&&(u=r[c-1])&&(u==i+o||u==i+o+"-"||u==i+o+"_"))return g=a.shallowCopy({},t.opts),b=function(n,e){var t,r,o=a.shallowCopy({},e);r=h(t=d(n,o)).toString().replace(p,""),o.filename=t;var i=new y(r,o);return i.generateSource(),{source:i.source,filename:t,template:r}}(f[1],g),v=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(b.template)+"\n      , __filename = "+JSON.stringify(b.filename)+";\n      try {\n"+b.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+b.source+"    ; }).call(this)\n",t.source+=v,void t.dependencies.push(e.resolveInclude(f[1],g.filename));t.scanLine(l)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,r=t.exec(e),o=[];r;)0!==(n=r.index)&&(o.push(e.substring(0,n)),e=e.slice(n)),o.push(r[0]),e=e.slice(r[0].length),r=t.exec(e);return e&&o.push(e),o},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,r=this.opts.openDelimiter,o=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case r+t:case r+t+"_":this.mode=y.modes.EVAL;break;case r+t+"=":this.mode=y.modes.ESCAPED;break;case r+t+"-":this.mode=y.modes.RAW;break;case r+t+"#":this.mode=y.modes.COMMENT;break;case r+t+t:this.mode=y.modes.LITERAL,this.source+='    ; __append("'+n.replace(r+t+t,r+t)+'")\n';break;case t+t+o:this.mode=y.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+o,t+o)+'")\n';break;case t+o:case"-"+t+o:case"_"+t+o:this.mode==y.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case y.modes.EVAL:case y.modes.ESCAPED:case y.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case y.modes.EVAL:this.source+="    ; "+n+"\n";break;case y.modes.ESCAPED:this.source+="    ; __append(escapeFn("+g(n)+"))\n";break;case y.modes.RAW:this.source+="    ; __append("+g(n)+")\n";break;case y.modes.COMMENT:break;case y.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=a.escapeXML,e.__express=e.renderFile,e.VERSION=s,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var r=1,o=2,a=4,i=8;function s(n){this.mode=a,this.data=n}s.prototype={getLength:function(n){return this.data.length},write:function(n){for(var e=0;e<this.data.length;e++)n.put(this.data.charCodeAt(e),8)}};var l=s,c={L:1,M:0,Q:3,H:2};function p(n,e){this.totalCount=n,this.dataCount=e}p.RS_BLOCK_TABLE=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]],p.getRSBlocks=function(n,e){var t=p.getRsBlockTable(n,e);if(null==t)throw new Error("bad rs block @ typeNumber:"+n+"/errorCorrectLevel:"+e);for(var r=t.length/3,o=new Array,a=0;a<r;a++)for(var i=t[3*a+0],s=t[3*a+1],l=t[3*a+2],c=0;c<i;c++)o.push(new p(s,l));return o},p.getRsBlockTable=function(n,e){switch(e){case c.L:return p.RS_BLOCK_TABLE[4*(n-1)+0];case c.M:return p.RS_BLOCK_TABLE[4*(n-1)+1];case c.Q:return p.RS_BLOCK_TABLE[4*(n-1)+2];case c.H:return p.RS_BLOCK_TABLE[4*(n-1)+3];default:return}};var d=p;function u(){this.buffer=new Array,this.length=0}u.prototype={get:function(n){var e=Math.floor(n/8);return 1==(this.buffer[e]>>>7-n%8&1)},put:function(n,e){for(var t=0;t<e;t++)this.putBit(1==(n>>>e-t-1&1))},getLengthInBits:function(){return this.length},putBit:function(n){var e=Math.floor(this.length/8);this.buffer.length<=e&&this.buffer.push(0),n&&(this.buffer[e]|=128>>>this.length%8),this.length++}};for(var m=u,h={glog:function(n){if(n<1)throw new Error("glog("+n+")");return h.LOG_TABLE[n]},gexp:function(n){for(;n<0;)n+=255;for(;n>=256;)n-=255;return h.EXP_TABLE[n]},EXP_TABLE:new Array(256),LOG_TABLE:new Array(256)},f=0;f<8;f++)h.EXP_TABLE[f]=1<<f;for(f=8;f<256;f++)h.EXP_TABLE[f]=h.EXP_TABLE[f-4]^h.EXP_TABLE[f-5]^h.EXP_TABLE[f-6]^h.EXP_TABLE[f-8];for(f=0;f<255;f++)h.LOG_TABLE[h.EXP_TABLE[f]]=f;var g=h;function y(n,e){if(null==n.length)throw new Error(n.length+"/"+e);for(var t=0;t<n.length&&0==n[t];)t++;this.num=new Array(n.length-t+e);for(var r=0;r<n.length-t;r++)this.num[r]=n[r+t]}y.prototype={get:function(n){return this.num[n]},getLength:function(){return this.num.length},multiply:function(n){for(var e=new Array(this.getLength()+n.getLength()-1),t=0;t<this.getLength();t++)for(var r=0;r<n.getLength();r++)e[t+r]^=g.gexp(g.glog(this.get(t))+g.glog(n.get(r)));return new y(e,0)},mod:function(n){if(this.getLength()-n.getLength()<0)return this;for(var e=g.glog(this.get(0))-g.glog(n.get(0)),t=new Array(this.getLength()),r=0;r<this.getLength();r++)t[r]=this.get(r);for(r=0;r<n.getLength();r++)t[r]^=g.gexp(g.glog(n.get(r))+e);return new y(t,0).mod(n)}};var b=y,v=0,k=1,w=2,x=3,T=4,C=5,R=6,E=7,S={PATTERN_POSITION_TABLE:[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],G15:1335,G18:7973,G15_MASK:21522,getBCHTypeInfo:function(n){for(var e=n<<10;S.getBCHDigit(e)-S.getBCHDigit(S.G15)>=0;)e^=S.G15<<S.getBCHDigit(e)-S.getBCHDigit(S.G15);return(n<<10|e)^S.G15_MASK},getBCHTypeNumber:function(n){for(var e=n<<12;S.getBCHDigit(e)-S.getBCHDigit(S.G18)>=0;)e^=S.G18<<S.getBCHDigit(e)-S.getBCHDigit(S.G18);return n<<12|e},getBCHDigit:function(n){for(var e=0;0!=n;)e++,n>>>=1;return e},getPatternPosition:function(n){return S.PATTERN_POSITION_TABLE[n-1]},getMask:function(n,e,t){switch(n){case v:return(e+t)%2==0;case k:return e%2==0;case w:return t%3==0;case x:return(e+t)%3==0;case T:return(Math.floor(e/2)+Math.floor(t/3))%2==0;case C:return e*t%2+e*t%3==0;case R:return(e*t%2+e*t%3)%2==0;case E:return(e*t%3+(e+t)%2)%2==0;default:throw new Error("bad maskPattern:"+n)}},getErrorCorrectPolynomial:function(n){for(var e=new b([1],0),t=0;t<n;t++)e=e.multiply(new b([1,g.gexp(t)],0));return e},getLengthInBits:function(n,e){if(1<=e&&e<10)switch(n){case r:return 10;case o:return 9;case a:case i:return 8;default:throw new Error("mode:"+n)}else if(e<27)switch(n){case r:return 12;case o:return 11;case a:return 16;case i:return 10;default:throw new Error("mode:"+n)}else{if(!(e<41))throw new Error("type:"+e);switch(n){case r:return 14;case o:return 13;case a:return 16;case i:return 12;default:throw new Error("mode:"+n)}}},getLostPoint:function(n){for(var e=n.getModuleCount(),t=0,r=0;r<e;r++)for(var o=0;o<e;o++){for(var a=0,i=n.isDark(r,o),s=-1;s<=1;s++)if(!(r+s<0||e<=r+s))for(var l=-1;l<=1;l++)o+l<0||e<=o+l||0==s&&0==l||i==n.isDark(r+s,o+l)&&a++;a>5&&(t+=3+a-5)}for(r=0;r<e-1;r++)for(o=0;o<e-1;o++){var c=0;n.isDark(r,o)&&c++,n.isDark(r+1,o)&&c++,n.isDark(r,o+1)&&c++,n.isDark(r+1,o+1)&&c++,0!=c&&4!=c||(t+=3)}for(r=0;r<e;r++)for(o=0;o<e-6;o++)n.isDark(r,o)&&!n.isDark(r,o+1)&&n.isDark(r,o+2)&&n.isDark(r,o+3)&&n.isDark(r,o+4)&&!n.isDark(r,o+5)&&n.isDark(r,o+6)&&(t+=40);for(o=0;o<e;o++)for(r=0;r<e-6;r++)n.isDark(r,o)&&!n.isDark(r+1,o)&&n.isDark(r+2,o)&&n.isDark(r+3,o)&&n.isDark(r+4,o)&&!n.isDark(r+5,o)&&n.isDark(r+6,o)&&(t+=40);var p=0;for(o=0;o<e;o++)for(r=0;r<e;r++)n.isDark(r,o)&&p++;return t+=10*(Math.abs(100*p/e/e-50)/5)}},P=S;function _(n,e){this.typeNumber=n,this.errorCorrectLevel=e,this.modules=null,this.moduleCount=0,this.dataCache=null,this.dataList=[]}var I=_.prototype;I.addData=function(n){var e=new l(n);this.dataList.push(e),this.dataCache=null},I.isDark=function(n,e){if(n<0||this.moduleCount<=n||e<0||this.moduleCount<=e)throw new Error(n+","+e);return this.modules[n][e]},I.getModuleCount=function(){return this.moduleCount},I.make=function(){if(this.typeNumber<1){var n=1;for(n=1;n<40;n++){for(var e=d.getRSBlocks(n,this.errorCorrectLevel),t=new m,r=0,o=0;o<e.length;o++)r+=e[o].dataCount;for(o=0;o<this.dataList.length;o++){var a=this.dataList[o];t.put(a.mode,4),t.put(a.getLength(),P.getLengthInBits(a.mode,n)),a.write(t)}if(t.getLengthInBits()<=8*r)break}this.typeNumber=n}this.makeImpl(!1,this.getBestMaskPattern())},I.makeImpl=function(n,e){this.moduleCount=4*this.typeNumber+17,this.modules=new Array(this.moduleCount);for(var t=0;t<this.moduleCount;t++){this.modules[t]=new Array(this.moduleCount);for(var r=0;r<this.moduleCount;r++)this.modules[t][r]=null}this.setupPositionProbePattern(0,0),this.setupPositionProbePattern(this.moduleCount-7,0),this.setupPositionProbePattern(0,this.moduleCount-7),this.setupPositionAdjustPattern(),this.setupTimingPattern(),this.setupTypeInfo(n,e),this.typeNumber>=7&&this.setupTypeNumber(n),null==this.dataCache&&(this.dataCache=_.createData(this.typeNumber,this.errorCorrectLevel,this.dataList)),this.mapData(this.dataCache,e)},I.setupPositionProbePattern=function(n,e){for(var t=-1;t<=7;t++)if(!(n+t<=-1||this.moduleCount<=n+t))for(var r=-1;r<=7;r++)e+r<=-1||this.moduleCount<=e+r||(this.modules[n+t][e+r]=0<=t&&t<=6&&(0==r||6==r)||0<=r&&r<=6&&(0==t||6==t)||2<=t&&t<=4&&2<=r&&r<=4)},I.getBestMaskPattern=function(){for(var n=0,e=0,t=0;t<8;t++){this.makeImpl(!0,t);var r=P.getLostPoint(this);(0==t||n>r)&&(n=r,e=t)}return e},I.createMovieClip=function(n,e,t){var r=n.createEmptyMovieClip(e,t);this.make();for(var o=0;o<this.modules.length;o++)for(var a=1*o,i=0;i<this.modules[o].length;i++){var s=1*i;this.modules[o][i]&&(r.beginFill(0,100),r.moveTo(s,a),r.lineTo(s+1,a),r.lineTo(s+1,a+1),r.lineTo(s,a+1),r.endFill())}return r},I.setupTimingPattern=function(){for(var n=8;n<this.moduleCount-8;n++)null==this.modules[n][6]&&(this.modules[n][6]=n%2==0);for(var e=8;e<this.moduleCount-8;e++)null==this.modules[6][e]&&(this.modules[6][e]=e%2==0)},I.setupPositionAdjustPattern=function(){for(var n=P.getPatternPosition(this.typeNumber),e=0;e<n.length;e++)for(var t=0;t<n.length;t++){var r=n[e],o=n[t];if(null==this.modules[r][o])for(var a=-2;a<=2;a++)for(var i=-2;i<=2;i++)this.modules[r+a][o+i]=-2==a||2==a||-2==i||2==i||0==a&&0==i}},I.setupTypeNumber=function(n){for(var e=P.getBCHTypeNumber(this.typeNumber),t=0;t<18;t++){var r=!n&&1==(e>>t&1);this.modules[Math.floor(t/3)][t%3+this.moduleCount-8-3]=r}for(t=0;t<18;t++){r=!n&&1==(e>>t&1);this.modules[t%3+this.moduleCount-8-3][Math.floor(t/3)]=r}},I.setupTypeInfo=function(n,e){for(var t=this.errorCorrectLevel<<3|e,r=P.getBCHTypeInfo(t),o=0;o<15;o++){var a=!n&&1==(r>>o&1);o<6?this.modules[o][8]=a:o<8?this.modules[o+1][8]=a:this.modules[this.moduleCount-15+o][8]=a}for(o=0;o<15;o++){a=!n&&1==(r>>o&1);o<8?this.modules[8][this.moduleCount-o-1]=a:o<9?this.modules[8][15-o-1+1]=a:this.modules[8][15-o-1]=a}this.modules[this.moduleCount-8][8]=!n},I.mapData=function(n,e){for(var t=-1,r=this.moduleCount-1,o=7,a=0,i=this.moduleCount-1;i>0;i-=2)for(6==i&&i--;;){for(var s=0;s<2;s++)if(null==this.modules[r][i-s]){var l=!1;a<n.length&&(l=1==(n[a]>>>o&1)),P.getMask(e,r,i-s)&&(l=!l),this.modules[r][i-s]=l,-1==--o&&(a++,o=7)}if((r+=t)<0||this.moduleCount<=r){r-=t,t=-t;break}}},_.PAD0=236,_.PAD1=17,_.createData=function(n,e,t){for(var r=d.getRSBlocks(n,e),o=new m,a=0;a<t.length;a++){var i=t[a];o.put(i.mode,4),o.put(i.getLength(),P.getLengthInBits(i.mode,n)),i.write(o)}var s=0;for(a=0;a<r.length;a++)s+=r[a].dataCount;if(o.getLengthInBits()>8*s)throw new Error("code length overflow. ("+o.getLengthInBits()+">"+8*s+")");for(o.getLengthInBits()+4<=8*s&&o.put(0,4);o.getLengthInBits()%8!=0;)o.putBit(!1);for(;!(o.getLengthInBits()>=8*s||(o.put(_.PAD0,8),o.getLengthInBits()>=8*s));)o.put(_.PAD1,8);return _.createBytes(o,r)},_.createBytes=function(n,e){for(var t=0,r=0,o=0,a=new Array(e.length),i=new Array(e.length),s=0;s<e.length;s++){var l=e[s].dataCount,c=e[s].totalCount-l;r=Math.max(r,l),o=Math.max(o,c),a[s]=new Array(l);for(var p=0;p<a[s].length;p++)a[s][p]=255&n.buffer[p+t];t+=l;var d=P.getErrorCorrectPolynomial(c),u=new b(a[s],d.getLength()-1).mod(d);i[s]=new Array(d.getLength()-1);for(p=0;p<i[s].length;p++){var m=p+u.getLength()-i[s].length;i[s][p]=m>=0?u.get(m):0}}var h=0;for(p=0;p<e.length;p++)h+=e[p].totalCount;var f=new Array(h),g=0;for(p=0;p<r;p++)for(s=0;s<e.length;s++)p<a[s].length&&(f[g++]=a[s][p]);for(p=0;p<o;p++)for(s=0;s<e.length;s++)p<i[s].length&&(f[g++]=i[s][p]);return f};var j=_;var O={components:{QrcodeVue:{props:{value:{type:String,required:!0,default:""},className:{type:String,default:""},size:{type:[Number,String],default:100,validator:function(n){return!0!==isNaN(Number(n))}},level:{type:String,default:"L",validator:function(n){return["L","Q","M","H"].indexOf(n)>-1}},background:{type:String,default:"#fff"},foreground:{type:String,default:"#000"},renderAs:{type:String,required:!1,default:"canvas",validator:function(n){return["canvas","svg"].indexOf(n)>-1}}},data:function(){return{numCells:0,fgPath:""}},updated:function(){this.render()},mounted:function(){this.render()},methods:{render:function(){var n=this.value,e=this.size,t=this.level,r=this.background,o=this.foreground,a=this.renderAs,i=e>>>0,s=new j(-1,c[t]);s.addData(function(n){for(var e="",t=0;t<n.length;t++){var r=n.charCodeAt(t);r<128?e+=String.fromCharCode(r):r<2048?(e+=String.fromCharCode(192|r>>6),e+=String.fromCharCode(128|63&r)):r<55296||r>=57344?(e+=String.fromCharCode(224|r>>12),e+=String.fromCharCode(128|r>>6&63),e+=String.fromCharCode(128|63&r)):(t++,r=65536+((1023&r)<<10|1023&n.charCodeAt(t)),e+=String.fromCharCode(240|r>>18),e+=String.fromCharCode(128|r>>12&63),e+=String.fromCharCode(128|r>>6&63),e+=String.fromCharCode(128|63&r))}return e}(n)),s.make();var l=s.modules,p=i/l.length,d=i/l.length,u=window.devicePixelRatio||1;if("svg"===a)this.numCells=l.length,this.fgPath=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=[];return n.forEach((function(n,r){var o=null;n.forEach((function(a,i){if(!a&&null!==o)return t.push("M".concat(o+e," ").concat(r+e,"h").concat(i-o,"v1H").concat(o+e,"z")),void(o=null);if(i!==n.length-1)a&&null===o&&(o=i);else{if(!a)return;null===o?t.push("M".concat(i+e,",").concat(r+e," h1v1H").concat(i+e,"z")):t.push("M".concat(o+e,",").concat(r+e," h").concat(i+1-o,"v1H").concat(o+e,"z"))}}))})),t.join("")}(l);else{var m=this.$refs["qrcode-vue"],h=m.getContext("2d");m.height=m.width=i*u,h.scale(u,u),l.forEach((function(n,e){n.forEach((function(n,t){h.fillStyle=n?o:r;var a=Math.ceil((t+1)*p)-Math.floor(t*p),i=Math.ceil((e+1)*d)-Math.floor(e*d);h.fillRect(Math.round(t*p),Math.round(e*d),a,i)}))}))}}},render:function(n){var e=this.className,t=this.value,r=this.level,o=this.background,a=this.foreground,i=this.size,s=this.renderAs,l=this.numCells,c=this.fgPath;return n("div",{class:this.class||e,attrs:{value:t,level:r,background:o,foreground:a}},["svg"===s?n("svg",{attrs:{height:i,width:i,shapeRendering:"crispEdges",viewBox:"0 0 ".concat(l," ").concat(l)},style:{width:i+"px",height:i+"px"}},[n("path",{attrs:{fill:o,d:"M0,0 h".concat(l,"v").concat(l,"H0z")}}),n("path",{attrs:{fill:a,d:c}})]):n("canvas",{attrs:{height:i,width:i},style:{width:i+"px",height:i+"px"},ref:"qrcode-vue"},[])])}}},data:()=>({show:!1,qrcodeText:"",qrSize:100,channelQR:""}),props:{size:{type:[String,Number],default:"small"},channel:{type:Boolean,default:!1}},mounted(){let n=this.size,e="";switch(n){case"small":e=100;break;case"medium":e=150;break;case"big":e=200;break;default:if(null==(t=n)||""===t.toString().replace(/\s/g,"")||""==typeof t||isNaN(t))e=100;else{const t=Math.min(window.innerHeight,window.innerWidth);n=~~n,e=n<10?10:n>t?t:n}}var t;this.qrSize=e,this.channel&&(this.channelQR=location.href.indexOf("?")>-1?"&channel=qrcode":"?channel=qrcode"),document.documentElement.addEventListener("mousedown",()=>{this.show=!1})},methods:{showQrCode(){this.show=!this.show,this.show&&this.$nextTick(()=>{this.qrcodeText=location.href+this.channelQR})}}},F=(t(255),t(2)),A=Object(F.a)(O,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"qrcodeBtn",attrs:{title:"手机查看"},on:{mousedown:function(e){return e.stopPropagation(),n.showQrCode.apply(null,arguments)}}},[e("svg",{attrs:{t:"1652063987836",viewBox:"0 0 1024 1024",xmlns:"http://www.w3.org/2000/svg","p-id":"2096",width:"16",height:"16"}},[e("path",{attrs:{d:"M891.01653333 648.53333333V530.0224h-180.224v60.07466667h120.14933334V648.53333333z m-59.52853333 59.52853334v-58.9824h-60.6208v60.07466666h60.07466667v120.69546667h-57.89013334V771.41333333h-62.2592V649.6256h-60.07466666v60.07466667H591.18933333v-59.52853334h-60.6208v60.07466667h60.07466667v59.52853333h-60.07466667v120.14933334h60.07466667v-120.14933334h60.07466667v119.6032h60.07466666V831.488h61.71306667v58.43626667h118.51093333V708.06186667z m-180.77013333-58.9824V530.56853333l-120.14933334-0.54613333v60.07466667h60.07466667v58.9824zM132.98346667 133.5296v361.54026667h360.448V133.5296h-360.448z m226.64533333 226.64533333h-92.84266667v-92.84266666h92.84266667v92.84266666z m-226.64533333 169.84746667v359.90186667h360.448V530.0224h-360.448z m226.64533333 226.0992h-92.84266667v-92.84266667h92.84266667v92.84266667z m170.93973333-622.592v360.448h360.448v-360.448h-360.448z m229.92213334 226.64533333h-92.84266667v-92.84266666h92.84266667v92.84266666z",fill:"#2C2C2C","p-id":"2097"}})]),n._v(" "),n.show?e("qrcode-vue",{ref:"qrcodeContainer",attrs:{id:"qrcodeContainer",value:n.qrcodeText,size:n.qrSize,level:"H"}}):n._e()],1)}),[],!1,null,null,null);e.default=A.exports},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},o=(t(256),t(2)),a=Object(o.a)(r,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"1e7dd946",null);e.default=a.exports},function(n,e,t){"use strict";t.r(e);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},o=(t(257),t(2)),a=Object(o.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"9a3094b0",null);e.default=a.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(4),o=t(11),a=r.document,i=o(a)&&o(a.createElement);n.exports=function(n){return i?a.createElement(n):{}}},function(n,e,t){var r=t(6),o=t(5);n.exports=r&&o((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(69),o=t(71),a=r("keys");n.exports=function(n){return a[n]||(a[n]=o(n))}},function(n,e,t){var r=t(7),o=t(9),a=t(35),i=t(132).indexOf,s=t(55),l=r([].push);n.exports=function(n,e){var t,r=a(n),c=0,p=[];for(t in r)!o(s,t)&&o(r,t)&&l(p,t);for(;e.length>c;)o(r,t=e[c++])&&(~i(p,t)||l(p,t));return p}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e){var t,r,o=n.exports={};function a(){throw new Error("setTimeout has not been defined")}function i(){throw new Error("clearTimeout has not been defined")}function s(n){if(t===setTimeout)return setTimeout(n,0);if((t===a||!t)&&setTimeout)return t=setTimeout,setTimeout(n,0);try{return t(n,0)}catch(e){try{return t.call(null,n,0)}catch(e){return t.call(this,n,0)}}}!function(){try{t="function"==typeof setTimeout?setTimeout:a}catch(n){t=a}try{r="function"==typeof clearTimeout?clearTimeout:i}catch(n){r=i}}();var l,c=[],p=!1,d=-1;function u(){p&&l&&(p=!1,l.length?c=l.concat(c):d=-1,c.length&&m())}function m(){if(!p){var n=s(u);p=!0;for(var e=c.length;e;){for(l=c,c=[];++d<e;)l&&l[d].run();d=-1,e=c.length}l=null,p=!1,function(n){if(r===clearTimeout)return clearTimeout(n);if((r===i||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(n);try{r(n)}catch(e){try{return r.call(null,n)}catch(e){return r.call(this,n)}}}(n)}}function h(n,e){this.fun=n,this.array=e}function f(){}o.nextTick=function(n){var e=new Array(arguments.length-1);if(arguments.length>1)for(var t=1;t<arguments.length;t++)e[t-1]=arguments[t];c.push(new h(n,e)),1!==c.length||p||s(m)},h.prototype.run=function(){this.fun.apply(null,this.array)},o.title="browser",o.browser=!0,o.env={},o.argv=[],o.version="",o.versions={},o.on=f,o.addListener=f,o.once=f,o.off=f,o.removeListener=f,o.removeAllListeners=f,o.emit=f,o.prependListener=f,o.prependOnceListener=f,o.listeners=function(n){return[]},o.binding=function(n){throw new Error("process.binding is not supported")},o.cwd=function(){return"/"},o.chdir=function(n){throw new Error("process.chdir is not supported")},o.umask=function(){return 0}},function(n,e,t){n.exports=t(270)},function(n,e,t){"use strict";var r=t(22),o=t(138).left,a=t(139),i=t(68),s=t(140);r({target:"Array",proto:!0,forced:!a("reduce")||!s&&i>79&&i<83},{reduce:function(n){var e=arguments.length;return o(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,o=Object.getOwnPropertyDescriptor,a=o&&!r.call({1:2},1);e.f=a?function(n){var e=o(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(38),o=t(11),a=t(64),i=t(121),s=t(123),l=t(24),c=TypeError,p=l("toPrimitive");n.exports=function(n,e){if(!o(n)||a(n))return n;var t,l=i(n,p);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!o(t)||a(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){var r=t(23);n.exports=r("navigator","userAgent")||""},function(n,e,t){var r=t(54),o=t(61);n.exports=function(n,e){var t=n[e];return o(t)?void 0:r(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var r=t(38),o=t(3),a=t(11),i=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&o(t=n.toString)&&!a(s=r(t,n)))return s;if(o(t=n.valueOf)&&!a(s=r(t,n)))return s;if("string"!==e&&o(t=n.toString)&&!a(s=r(t,n)))return s;throw i("Can't convert object to primitive value")}},function(n,e,t){var r=t(3),o=t(16),a=t(125),i=t(41);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(r(t)&&a(t,c,s),s.global)l?n[e]=t:i(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:o.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var r=t(5),o=t(3),a=t(9),i=t(6),s=t(126).CONFIGURABLE,l=t(127),c=t(128),p=c.enforce,d=c.get,u=Object.defineProperty,m=i&&!r((function(){return 8!==u((function(){}),"length",{value:8}).length})),h=String(String).split("String"),f=n.exports=function(n,e,t){"Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!a(n,"name")||s&&n.name!==e)&&(i?u(n,"name",{value:e,configurable:!0}):n.name=e),m&&t&&a(t,"arity")&&n.length!==t.arity&&u(n,"length",{value:t.arity});try{t&&a(t,"constructor")&&t.constructor?i&&u(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=p(n);return a(r,"source")||(r.source=h.join("string"==typeof e?e:"")),n};Function.prototype.toString=f((function(){return o(this)&&d(this).source||l(this)}),"toString")},function(n,e,t){var r=t(6),o=t(9),a=Function.prototype,i=r&&Object.getOwnPropertyDescriptor,s=o(a,"name"),l=s&&"something"===function(){}.name,c=s&&(!r||r&&i(a,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var r=t(7),o=t(3),a=t(40),i=r(Function.toString);o(a.inspectSource)||(a.inspectSource=function(n){return i(n)}),n.exports=a.inspectSource},function(n,e,t){var r,o,a,i=t(129),s=t(4),l=t(11),c=t(25),p=t(9),d=t(40),u=t(112),m=t(55),h=s.TypeError,f=s.WeakMap;if(i||d.state){var g=d.state||(d.state=new f);g.get=g.get,g.has=g.has,g.set=g.set,r=function(n,e){if(g.has(n))throw h("Object already initialized");return e.facade=n,g.set(n,e),e},o=function(n){return g.get(n)||{}},a=function(n){return g.has(n)}}else{var y=u("state");m[y]=!0,r=function(n,e){if(p(n,y))throw h("Object already initialized");return e.facade=n,c(n,y,e),e},o=function(n){return p(n,y)?n[y]:{}},a=function(n){return p(n,y)}}n.exports={set:r,get:o,has:a,enforce:function(n){return a(n)?o(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=o(e)).type!==n)throw h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(4),o=t(3),a=r.WeakMap;n.exports=o(a)&&/native code/.test(String(a))},function(n,e,t){var r=t(23),o=t(7),a=t(131),i=t(136),s=t(33),l=o([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=a.f(s(n)),t=i.f;return t?l(e,t(n)):e}},function(n,e,t){var r=t(113),o=t(109).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,o)}},function(n,e,t){var r=t(35),o=t(133),a=t(37),i=function(n){return function(e,t,i){var s,l=r(e),c=a(l),p=o(i,c);if(n&&t!=t){for(;c>p;)if((s=l[p++])!=s)return!0}else for(;c>p;p++)if((n||p in l)&&l[p]===t)return n||p||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e,t){var r=t(74),o=Math.max,a=Math.min;n.exports=function(n,e){var t=r(n);return t<0?o(t+e,0):a(t,e)}},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:t)(e)}},function(n,e,t){var r=t(74),o=Math.min;n.exports=function(n){return n>0?o(r(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(5),o=t(3),a=/#|\.prototype\./,i=function(n,e){var t=l[s(n)];return t==p||t!=c&&(o(e)?r(e):!!e)},s=i.normalize=function(n){return String(n).replace(a,".").toLowerCase()},l=i.data={},c=i.NATIVE="N",p=i.POLYFILL="P";n.exports=i},function(n,e,t){var r=t(54),o=t(36),a=t(53),i=t(37),s=TypeError,l=function(n){return function(e,t,l,c){r(t);var p=o(e),d=a(p),u=i(p),m=n?u-1:0,h=n?-1:1;if(l<2)for(;;){if(m in d){c=d[m],m+=h;break}if(m+=h,n?m<0:u<=m)throw s("Reduce of empty array with no initial value")}for(;n?m>=0:u>m;m+=h)m in d&&(c=t(c,d[m],m,p));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var r=t(5);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(18),o=t(4);n.exports="process"==r(o.process)},function(n,e,t){"use strict";var r=t(6),o=t(142),a=TypeError,i=Object.getOwnPropertyDescriptor,s=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(o(n)&&!i(n,"length").writable)throw a("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var r=t(18);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var r=t(22),o=t(4),a=t(145),i=t(146),s=o.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=i(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},p=function(n,e){if(s&&s[n]){var t={};t[n]=i("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return a(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),c("URIError",(function(n){return function(e){return a(n,this,arguments)}})),p("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),p("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),p("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){var r=t(34),o=Function.prototype,a=o.apply,i=o.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?i.bind(a):function(){return i.apply(a,arguments)})},function(n,e,t){"use strict";var r=t(23),o=t(9),a=t(25),i=t(65),s=t(75),l=t(73),c=t(148),p=t(149),d=t(150),u=t(154),m=t(155),h=t(156),f=t(6),g=t(70);n.exports=function(n,e,t,y){var b=y?2:1,v=n.split("."),k=v[v.length-1],w=r.apply(null,v);if(w){var x=w.prototype;if(!g&&o(x,"cause")&&delete x.cause,!t)return w;var T=r("Error"),C=e((function(n,e){var t=d(y?e:n,void 0),r=y?new w(n):new w;return void 0!==t&&a(r,"message",t),h&&a(r,"stack",m(r.stack,2)),this&&i(x,this)&&p(r,this,C),arguments.length>b&&u(r,arguments[b]),r}));if(C.prototype=x,"Error"!==k?s?s(C,T):l(C,T,{name:!0}):f&&"stackTraceLimit"in w&&(c(C,w,"stackTraceLimit"),c(C,w,"prepareStackTrace")),l(C,w),!g)try{x.name!==k&&a(x,"name",k),x.constructor=C}catch(n){}return C}}},function(n,e,t){var r=t(3),o=String,a=TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw a("Can't set "+o(n)+" as a prototype")}},function(n,e,t){var r=t(16).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var r=t(3),o=t(11),a=t(75);n.exports=function(n,e,t){var i,s;return a&&r(i=e.constructor)&&i!==t&&o(s=i.prototype)&&s!==t.prototype&&a(n,s),n}},function(n,e,t){var r=t(151);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){var r=t(152),o=String;n.exports=function(n){if("Symbol"===r(n))throw TypeError("Cannot convert a Symbol value to a string");return o(n)}},function(n,e,t){var r=t(153),o=t(3),a=t(18),i=t(24)("toStringTag"),s=Object,l="Arguments"==a(function(){return arguments}());n.exports=r?a:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),i))?t:l?a(e):"Object"==(r=a(e))&&o(e.callee)?"Arguments":r}},function(n,e,t){var r={};r[t(24)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(11),o=t(25);n.exports=function(n,e){r(e)&&"cause"in e&&o(n,"cause",e.cause)}},function(n,e,t){var r=t(7),o=Error,a=r("".replace),i=String(o("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(i);n.exports=function(n,e){if(l&&"string"==typeof n&&!o.prepareStackTrace)for(;e--;)n=a(n,s,"");return n}},function(n,e,t){var r=t(5),o=t(39);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",o(1,7)),7!==n.stack)}))},function(n,e,t){var r=t(76),o=t(158);n.exports=function n(e,t,a,i,s){var l=-1,c=e.length;for(a||(a=o),s||(s=[]);++l<c;){var p=e[l];t>0&&a(p)?t>1?n(p,t-1,a,i,s):r(s,p):i||(s[s.length]=p)}return s}},function(n,e,t){var r=t(19),o=t(42),a=t(8),i=r?r.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||o(n)||!!(i&&n&&n[i])}},function(n,e,t){var r=t(17),o=t(14);n.exports=function(n){return o(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(19),o=Object.prototype,a=o.hasOwnProperty,i=o.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=a.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var o=i.call(n);return r&&(e?n[s]=t:delete n[s]),o}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(163),o=t(219),a=t(50),i=t(8),s=t(230);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?i(n)?o(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(164),o=t(218),a=t(93);n.exports=function(n){var e=o(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(78),o=t(82);n.exports=function(n,e,t,a){var i=t.length,s=i,l=!a;if(null==n)return!s;for(n=Object(n);i--;){var c=t[i];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++i<s;){var p=(c=t[i])[0],d=n[p],u=c[1];if(l&&c[2]){if(void 0===d&&!(p in n))return!1}else{var m=new r;if(a)var h=a(d,u,p,n,e,m);if(!(void 0===h?o(u,d,3,a,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(27),o=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():o.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(27);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(27);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(27);n.exports=function(n,e){var t=this.__data__,o=r(t,n);return o<0?(++this.size,t.push([n,e])):t[o][1]=e,this}},function(n,e,t){var r=t(26);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(26),o=t(43),a=t(45);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var i=t.__data__;if(!o||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(80),o=t(176),a=t(44),i=t(81),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,p=l.toString,d=c.hasOwnProperty,u=RegExp("^"+p.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||o(n))&&(r(n)?u:s).test(i(n))}},function(n,e,t){var r,o=t(177),a=(r=/[^.]+$/.exec(o&&o.keys&&o.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var r=t(10)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(180),o=t(26),a=t(43);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(a||o),string:new r}}},function(n,e,t){var r=t(181),o=t(182),a=t(183),i=t(184),s=t(185);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(28);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(28),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return o.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(28),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:o.call(e,n)}},function(n,e,t){var r=t(28);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(29);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(29);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(29);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(29);n.exports=function(n,e){var t=r(this,n),o=t.size;return t.set(n,e),this.size+=t.size==o?0:1,this}},function(n,e,t){var r=t(78),o=t(83),a=t(195),i=t(198),s=t(214),l=t(8),c=t(87),p=t(89),d="[object Object]",u=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,f){var g=l(n),y=l(e),b=g?"[object Array]":s(n),v=y?"[object Array]":s(e),k=(b="[object Arguments]"==b?d:b)==d,w=(v="[object Arguments]"==v?d:v)==d,x=b==v;if(x&&c(n)){if(!c(e))return!1;g=!0,k=!1}if(x&&!k)return f||(f=new r),g||p(n)?o(n,e,t,m,h,f):a(n,e,b,t,m,h,f);if(!(1&t)){var T=k&&u.call(n,"__wrapped__"),C=w&&u.call(e,"__wrapped__");if(T||C){var R=T?n.value():n,E=C?e.value():e;return f||(f=new r),h(R,E,t,m,f)}}return!!x&&(f||(f=new r),i(n,e,t,m,h,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(19),o=t(196),a=t(79),i=t(83),s=t(197),l=t(46),c=r?r.prototype:void 0,p=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,d,u){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new o(n),new o(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var h=1&r;if(m||(m=l),n.size!=e.size&&!h)return!1;var f=u.get(n);if(f)return f==e;r|=2,u.set(n,e);var g=i(m(n),m(e),r,c,d,u);return u.delete(n),g;case"[object Symbol]":if(p)return p.call(n)==p.call(e)}return!1}},function(n,e,t){var r=t(10).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(199),o=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,i,s){var l=1&t,c=r(n),p=c.length;if(p!=r(e).length&&!l)return!1;for(var d=p;d--;){var u=c[d];if(!(l?u in e:o.call(e,u)))return!1}var m=s.get(n),h=s.get(e);if(m&&h)return m==e&&h==n;var f=!0;s.set(n,e),s.set(e,n);for(var g=l;++d<p;){var y=n[u=c[d]],b=e[u];if(a)var v=l?a(b,y,u,e,n,s):a(y,b,u,n,e,s);if(!(void 0===v?y===b||i(y,b,t,a,s):v)){f=!1;break}g||(g="constructor"==u)}if(f&&!g){var k=n.constructor,w=e.constructor;k==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof k&&k instanceof k&&"function"==typeof w&&w instanceof w||(f=!1)}return s.delete(n),s.delete(e),f}},function(n,e,t){var r=t(200),o=t(201),a=t(86);n.exports=function(n){return r(n,a,o)}},function(n,e,t){var r=t(76),o=t(8);n.exports=function(n,e,t){var a=e(n);return o(n)?a:r(a,t(n))}},function(n,e,t){var r=t(202),o=t(203),a=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,s=i?function(n){return null==n?[]:(n=Object(n),r(i(n),(function(e){return a.call(n,e)})))}:o;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,o=0,a=[];++t<r;){var i=n[t];e(i,t,n)&&(a[o++]=i)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(205),o=t(42),a=t(8),i=t(87),s=t(88),l=t(89),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),p=!t&&o(n),d=!t&&!p&&i(n),u=!t&&!p&&!d&&l(n),m=t||p||d||u,h=m?r(n.length,String):[],f=h.length;for(var g in n)!e&&!c.call(n,g)||m&&("length"==g||d&&("offset"==g||"parent"==g)||u&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||s(g,f))||h.push(g);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(17),o=t(47),a=t(14),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&o(n.length)&&!!i[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(77),o=e&&!e.nodeType&&e,a=o&&"object"==typeof n&&n&&!n.nodeType&&n,i=a&&a.exports===o&&r.process,s=function(){try{var n=a&&a.require&&a.require("util").types;return n||i&&i.binding&&i.binding("util")}catch(n){}}();n.exports=s}).call(this,t(56)(n))},function(n,e,t){var r=t(211),o=t(212),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return o(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(213)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(215),o=t(43),a=t(216),i=t(91),s=t(217),l=t(17),c=t(81),p=c(r),d=c(o),u=c(a),m=c(i),h=c(s),f=l;(r&&"[object DataView]"!=f(new r(new ArrayBuffer(1)))||o&&"[object Map]"!=f(new o)||a&&"[object Promise]"!=f(a.resolve())||i&&"[object Set]"!=f(new i)||s&&"[object WeakMap]"!=f(new s))&&(f=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case p:return"[object DataView]";case d:return"[object Map]";case u:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=f},function(n,e,t){var r=t(12)(t(10),"DataView");n.exports=r},function(n,e,t){var r=t(12)(t(10),"Promise");n.exports=r},function(n,e,t){var r=t(12)(t(10),"WeakMap");n.exports=r},function(n,e,t){var r=t(92),o=t(86);n.exports=function(n){for(var e=o(n),t=e.length;t--;){var a=e[t],i=n[a];e[t]=[a,i,r(i)]}return e}},function(n,e,t){var r=t(82),o=t(220),a=t(227),i=t(48),s=t(92),l=t(93),c=t(30);n.exports=function(n,e){return i(n)&&s(e)?l(c(n),e):function(t){var i=o(t,n);return void 0===i&&i===e?a(t,n):r(e,i,3)}}},function(n,e,t){var r=t(94);n.exports=function(n,e,t){var o=null==n?void 0:r(n,e);return void 0===o?t:o}},function(n,e,t){var r=t(222),o=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,i=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(o,(function(n,t,r,o){e.push(r?o.replace(a,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var r=t(223);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(45);function o(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,o=e?e.apply(this,r):r[0],a=t.cache;if(a.has(o))return a.get(o);var i=n.apply(this,r);return t.cache=a.set(o,i)||a,i};return t.cache=new(o.Cache||r),t}o.Cache=r,n.exports=o},function(n,e,t){var r=t(225);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(19),o=t(226),a=t(8),i=t(49),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return o(e,n)+"";if(i(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,o=Array(r);++t<r;)o[t]=e(n[t],t,n);return o}},function(n,e,t){var r=t(228),o=t(229);n.exports=function(n,e){return null!=n&&o(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(95),o=t(42),a=t(8),i=t(88),s=t(47),l=t(30);n.exports=function(n,e,t){for(var c=-1,p=(e=r(e,n)).length,d=!1;++c<p;){var u=l(e[c]);if(!(d=null!=n&&t(n,u)))break;n=n[u]}return d||++c!=p?d:!!(p=null==n?0:n.length)&&s(p)&&i(u,p)&&(a(n)||o(n))}},function(n,e,t){var r=t(231),o=t(232),a=t(48),i=t(30);n.exports=function(n){return a(n)?r(i(n)):o(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(94);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(50),o=t(234),a=t(236);n.exports=function(n,e){return a(o(n,e,r),n+"")}},function(n,e,t){var r=t(235),o=Math.max;n.exports=function(n,e,t){return e=o(void 0===e?n.length-1:e,0),function(){for(var a=arguments,i=-1,s=o(a.length-e,0),l=Array(s);++i<s;)l[i]=a[e+i];i=-1;for(var c=Array(e+1);++i<e;)c[i]=a[i];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(237),o=t(240)(r);n.exports=o},function(n,e,t){var r=t(238),o=t(239),a=t(50),i=o?function(n,e){return o(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:a;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(12),o=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=o},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var o=t(),a=16-(o-r);if(r=o,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(84),o=t(242),a=t(247),i=t(85),s=t(248),l=t(46);n.exports=function(n,e,t){var c=-1,p=o,d=n.length,u=!0,m=[],h=m;if(t)u=!1,p=a;else if(d>=200){var f=e?null:s(n);if(f)return l(f);u=!1,p=i,h=new r}else h=e?[]:m;n:for(;++c<d;){var g=n[c],y=e?e(g):g;if(g=t||0!==g?g:0,u&&y==y){for(var b=h.length;b--;)if(h[b]===y)continue n;e&&h.push(y),m.push(g)}else p(h,y,t)||(h!==m&&h.push(y),m.push(g))}return m}},function(n,e,t){var r=t(243);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(244),o=t(245),a=t(246);n.exports=function(n,e,t){return e==e?a(n,e,t):r(n,o,t)}},function(n,e){n.exports=function(n,e,t,r){for(var o=n.length,a=t+(r?1:-1);r?a--:++a<o;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,o=n.length;++r<o;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,o=null==n?0:n.length;++r<o;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(91),o=t(249),a=t(46),i=r&&1/a(new r([,-0]))[1]==1/0?function(n){return new r(n)}:o;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(90),o=t(14);n.exports=function(n){return o(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(96)},function(n,e,t){"use strict";t(97)},function(n,e,t){"use strict";t(98)},function(n,e,t){"use strict";t(99)},function(n,e,t){"use strict";t(100)},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(22),o=t(4),a=t(261);r({global:!0},{Reflect:{}}),a(o.Reflect,"Reflect",!0)},function(n,e,t){var r=t(16).f,o=t(9),a=t(24)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!o(n,a)&&r(n,a,{configurable:!0,value:e})}},function(n,e){},function(n,e,t){(function(n){function t(n,e){for(var t=0,r=n.length-1;r>=0;r--){var o=n[r];"."===o?n.splice(r,1):".."===o?(n.splice(r,1),t++):t&&(n.splice(r,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function r(n,e){if(n.filter)return n.filter(e);for(var t=[],r=0;r<n.length;r++)e(n[r],r,n)&&t.push(n[r]);return t}e.resolve=function(){for(var e="",o=!1,a=arguments.length-1;a>=-1&&!o;a--){var i=a>=0?arguments[a]:n.cwd();if("string"!=typeof i)throw new TypeError("Arguments to path.resolve must be strings");i&&(e=i+"/"+e,o="/"===i.charAt(0))}return(o?"/":"")+(e=t(r(e.split("/"),(function(n){return!!n})),!o).join("/"))||"."},e.normalize=function(n){var a=e.isAbsolute(n),i="/"===o(n,-1);return(n=t(r(n.split("/"),(function(n){return!!n})),!a).join("/"))||a||(n="."),n&&i&&(n+="/"),(a?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(r(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function r(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var o=r(n.split("/")),a=r(t.split("/")),i=Math.min(o.length,a.length),s=i,l=0;l<i;l++)if(o[l]!==a[l]){s=l;break}var c=[];for(l=s;l<o.length;l++)c.push("..");return(c=c.concat(a.slice(s))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,r=-1,o=!0,a=n.length-1;a>=1;--a)if(47===(e=n.charCodeAt(a))){if(!o){r=a;break}}else o=!1;return-1===r?t?"/":".":t&&1===r?"/":n.slice(0,r)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,r=-1,o=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!o){t=e+1;break}}else-1===r&&(o=!1,r=e+1);return-1===r?"":n.slice(t,r)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,r=-1,o=!0,a=0,i=n.length-1;i>=0;--i){var s=n.charCodeAt(i);if(47!==s)-1===r&&(o=!1,r=i+1),46===s?-1===e?e=i:1!==a&&(a=1):-1!==e&&(a=-1);else if(!o){t=i+1;break}}return-1===e||-1===r||0===a||1===a&&e===r-1&&e===t+1?"":n.slice(e,r)};var o="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}}).call(this,t(115))},function(n,e,t){"use strict";var r=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(r,"\\$&"):""};var o={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},a=/[&<>'"]/g;function i(n){return o[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(a,i)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var r=0;r<t.length;r++){var o=t[r];void 0!==e[o]&&(n[o]=e[o])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"name":"ejs","description":"Embedded JavaScript templates","keywords":["template","engine","ejs"],"version":"2.7.4","author":"Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)","license":"Apache-2.0","main":"./lib/ejs.js","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"bugs":"https://github.com/mde/ejs/issues","homepage":"https://github.com/mde/ejs","dependencies":{},"devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"scripts":{"test":"mocha","postinstall":"node ./postinstall.js"}}')},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(101)},function(n,e,t){"use strict";t(102)},function(n,e,t){"use strict";t.r(e);var r=t(1);
/*!
  * vue-router v3.6.5
  * (c) 2022 Evan You
  * @license MIT
  */function o(n,e){for(var t in e)n[t]=e[t];return n}var a=/[!'()*]/g,i=function(n){return"%"+n.charCodeAt(0).toString(16)},s=/%2C/g,l=function(n){return encodeURIComponent(n).replace(a,i).replace(s,",")};function c(n){try{return decodeURIComponent(n)}catch(n){0}return n}var p=function(n){return null==n||"object"==typeof n?n:String(n)};function d(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=c(t.shift()),o=t.length>0?c(t.join("=")):null;void 0===e[r]?e[r]=o:Array.isArray(e[r])?e[r].push(o):e[r]=[e[r],o]})),e):e}function u(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return l(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(l(e)):r.push(l(e)+"="+l(n)))})),r.join("&")}return l(e)+"="+l(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var m=/\/?$/;function h(n,e,t,r){var o=r&&r.options.stringifyQuery,a=e.query||{};try{a=f(a)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:b(e,o),matched:n?y(n):[]};return t&&(i.redirectedFrom=b(t,o)),Object.freeze(i)}function f(n){if(Array.isArray(n))return n.map(f);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=f(n[t]);return e}return n}var g=h(null,{path:"/"});function y(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function b(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var o=n.hash;return void 0===o&&(o=""),(t||"/")+(e||u)(r)+o}function v(n,e,t){return e===g?n===e:!!e&&(n.path&&e.path?n.path.replace(m,"")===e.path.replace(m,"")&&(t||n.hash===e.hash&&k(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&k(n.query,e.query)&&k(n.params,e.params))))}function k(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,o){var a=n[t];if(r[o]!==t)return!1;var i=e[t];return null==a||null==i?a===i:"object"==typeof a&&"object"==typeof i?k(a,i):String(a)===String(i)}))}function w(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var o=t.instances[r],a=t.enteredCbs[r];if(o&&a){delete t.enteredCbs[r];for(var i=0;i<a.length;i++)o._isBeingDestroyed||a[i](o)}}}}var x={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,a=e.parent,i=e.data;i.routerView=!0;for(var s=a.$createElement,l=t.name,c=a.$route,p=a._routerViewCache||(a._routerViewCache={}),d=0,u=!1;a&&a._routerRoot!==a;){var m=a.$vnode?a.$vnode.data:{};m.routerView&&d++,m.keepAlive&&a._directInactive&&a._inactive&&(u=!0),a=a.$parent}if(i.routerViewDepth=d,u){var h=p[l],f=h&&h.component;return f?(h.configProps&&T(f,i,h.route,h.configProps),s(f,i,r)):s()}var g=c.matched[d],y=g&&g.components[l];if(!g||!y)return p[l]=null,s();p[l]={component:y},i.registerRouteInstance=function(n,e){var t=g.instances[l];(e&&t!==n||!e&&t===n)&&(g.instances[l]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){g.instances[l]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==g.instances[l]&&(g.instances[l]=n.componentInstance),w(c)};var b=g.props&&g.props[l];return b&&(o(p[l],{route:c,configProps:b}),T(y,i,c,b)),s(y,i,r)}};function T(n,e,t,r){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(a){a=e.props=o({},a);var i=e.attrs=e.attrs||{};for(var s in a)n.props&&s in n.props||(i[s]=a[s],delete a[s])}}function C(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var o=e.split("/");t&&o[o.length-1]||o.pop();for(var a=n.replace(/^\//,"").split("/"),i=0;i<a.length;i++){var s=a[i];".."===s?o.pop():"."!==s&&o.push(s)}return""!==o[0]&&o.unshift(""),o.join("/")}function R(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var E=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},S=N,P=F,_=function(n,e){return M(F(n,e),e)},I=M,j=U,O=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function F(n,e){for(var t,r=[],o=0,a=0,i="",s=e&&e.delimiter||"/";null!=(t=O.exec(n));){var l=t[0],c=t[1],p=t.index;if(i+=n.slice(a,p),a=p+l.length,c)i+=c[1];else{var d=n[a],u=t[2],m=t[3],h=t[4],f=t[5],g=t[6],y=t[7];i&&(r.push(i),i="");var b=null!=u&&null!=d&&d!==u,v="+"===g||"*"===g,k="?"===g||"*"===g,w=t[2]||s,x=h||f;r.push({name:m||o++,prefix:u||"",delimiter:w,optional:k,repeat:v,partial:b,asterisk:!!y,pattern:x?z(x):y?".*":"[^"+D(w)+"]+?"})}}return a<n.length&&(i+=n.substr(a)),i&&r.push(i),r}function A(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function M(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",L(e)));return function(e,r){for(var o="",a=e||{},i=(r||{}).pretty?A:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,p=a[l.name];if(null==p){if(l.optional){l.partial&&(o+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(E(p)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(p)+"`");if(0===p.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<p.length;d++){if(c=i(p[d]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");o+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(p).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(p),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');o+=l.prefix+c}}else o+=l}return o}}function D(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function z(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function q(n,e){return n.keys=e,n}function L(n){return n&&n.sensitive?"":"i"}function U(n,e,t){E(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,o=!1!==t.end,a="",i=0;i<n.length;i++){var s=n[i];if("string"==typeof s)a+=D(s);else{var l=D(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),a+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var p=D(t.delimiter||"/"),d=a.slice(-p.length)===p;return r||(a=(d?a.slice(0,-p.length):a)+"(?:"+p+"(?=$))?"),a+=o?"$":r&&d?"":"(?="+p+"|$)",q(new RegExp("^"+a,L(t)),e)}function N(n,e,t){return E(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return q(n,e)}(n,e):E(n)?function(n,e,t){for(var r=[],o=0;o<n.length;o++)r.push(N(n[o],e,t).source);return q(new RegExp("(?:"+r.join("|")+")",L(t)),e)}(n,e,t):function(n,e,t){return U(F(n,t),e,t)}(n,e,t)}S.parse=P,S.compile=_,S.tokensToFunction=I,S.tokensToRegExp=j;var H=Object.create(null);function W(n,e,t){e=e||{};try{var r=H[n]||(H[n]=S.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function B(n,e,t,r){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var i=(a=o({},n)).params;return i&&"object"==typeof i&&(a.params=o({},i)),a}if(!a.path&&a.params&&e){(a=o({},a))._normalized=!0;var s=o(o({},e.params),a.params);if(e.name)a.name=e.name,a.params=s;else if(e.matched.length){var l=e.matched[e.matched.length-1].path;a.path=W(l,s,e.path)}else 0;return a}var c=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var o=n.indexOf("?");return o>=0&&(t=n.slice(o+1),n=n.slice(0,o)),{path:n,query:t,hash:e}}(a.path||""),u=e&&e.path||"/",m=c.path?C(c.path,u,t||a.append):u,h=function(n,e,t){void 0===e&&(e={});var r,o=t||d;try{r=o(n||"")}catch(n){r={}}for(var a in e){var i=e[a];r[a]=Array.isArray(i)?i.map(p):p(i)}return r}(c.query,a.query,r&&r.options.parseQuery),f=a.hash||c.hash;return f&&"#"!==f.charAt(0)&&(f="#"+f),{_normalized:!0,path:m,query:h,hash:f}}var $,V=function(){},K={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,a=t.resolve(this.to,r,this.append),i=a.location,s=a.route,l=a.href,c={},p=t.options.linkActiveClass,d=t.options.linkExactActiveClass,u=null==p?"router-link-active":p,f=null==d?"router-link-exact-active":d,g=null==this.activeClass?u:this.activeClass,y=null==this.exactActiveClass?f:this.exactActiveClass,b=s.redirectedFrom?h(null,B(s.redirectedFrom),null,t):s;c[y]=v(r,b,this.exactPath),c[g]=this.exact||this.exactPath?c[y]:function(n,e){return 0===n.path.replace(m,"/").indexOf(e.path.replace(m,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,b);var k=c[y]?this.ariaCurrentValue:null,w=function(n){J(n)&&(e.replace?t.replace(i,V):t.push(i,V))},x={click:J};Array.isArray(this.event)?this.event.forEach((function(n){x[n]=w})):x[this.event]=w;var T={class:c},C=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:l,route:s,navigate:w,isActive:c[g],isExactActive:c[y]});if(C){if(1===C.length)return C[0];if(C.length>1||!C.length)return 0===C.length?n():n("span",{},C)}if("a"===this.tag)T.on=x,T.attrs={href:l,"aria-current":k};else{var R=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(R){R.isStatic=!1;var E=R.data=o({},R.data);for(var S in E.on=E.on||{},E.on){var P=E.on[S];S in x&&(E.on[S]=Array.isArray(P)?P:[P])}for(var _ in x)_ in E.on?E.on[_].push(x[_]):E.on[_]=w;var I=R.data.attrs=o({},R.data.attrs);I.href=l,I["aria-current"]=k}else T.on=x}return n(this.tag,T,this.$slots.default)}};function J(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var G="undefined"!=typeof window;function Q(n,e,t,r,o){var a=e||[],i=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,o,a,i){var s=o.path,l=o.name;0;var c=o.pathToRegexpOptions||{},p=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return R(e.path+"/"+n)}(s,a,c.strict);"boolean"==typeof o.caseSensitive&&(c.sensitive=o.caseSensitive);var d={path:p,regex:X(p,c),components:o.components||{default:o.component},alias:o.alias?"string"==typeof o.alias?[o.alias]:o.alias:[],instances:{},enteredCbs:{},name:l,parent:a,matchAs:i,redirect:o.redirect,beforeEnter:o.beforeEnter,meta:o.meta||{},props:null==o.props?{}:o.components?o.props:{default:o.props}};o.children&&o.children.forEach((function(o){var a=i?R(i+"/"+o.path):void 0;n(e,t,r,o,d,a)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==o.alias)for(var u=Array.isArray(o.alias)?o.alias:[o.alias],m=0;m<u.length;++m){0;var h={path:u[m],children:o.children};n(e,t,r,h,a,d.path||"/")}l&&(r[l]||(r[l]=d))}(a,i,s,n,o)}));for(var l=0,c=a.length;l<c;l++)"*"===a[l]&&(a.push(a.splice(l,1)[0]),c--,l--);return{pathList:a,pathMap:i,nameMap:s}}function X(n,e){return S(n,[],e)}function Z(n,e){var t=Q(n),r=t.pathList,o=t.pathMap,a=t.nameMap;function i(n,t,i){var s=B(n,t,!1,e),c=s.name;if(c){var p=a[c];if(!p)return l(null,s);var d=p.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var u in t.params)!(u in s.params)&&d.indexOf(u)>-1&&(s.params[u]=t.params[u]);return s.path=W(p.path,s.params),l(p,s,i)}if(s.path){s.params={};for(var m=0;m<r.length;m++){var h=r[m],f=o[h];if(Y(f.regex,s.path,s.params))return l(f,s,i)}}return l(null,s)}function s(n,t){var r=n.redirect,o="function"==typeof r?r(h(n,t,null,e)):r;if("string"==typeof o&&(o={path:o}),!o||"object"!=typeof o)return l(null,t);var s=o,c=s.name,p=s.path,d=t.query,u=t.hash,m=t.params;if(d=s.hasOwnProperty("query")?s.query:d,u=s.hasOwnProperty("hash")?s.hash:u,m=s.hasOwnProperty("params")?s.params:m,c){a[c];return i({_normalized:!0,name:c,query:d,hash:u,params:m},void 0,t)}if(p){var f=function(n,e){return C(n,e.parent?e.parent.path:"/",!0)}(p,n);return i({_normalized:!0,path:W(f,m),query:d,hash:u},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=i({_normalized:!0,path:W(t,e.params)});if(r){var o=r.matched,a=o[o.length-1];return e.params=r.params,l(a,e)}return l(null,e)}(0,t,n.matchAs):h(n,t,r,e)}return{match:i,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;Q([e||n],r,o,a,t),t&&t.alias.length&&Q(t.alias.map((function(n){return{path:n,children:[e]}})),r,o,a,t)},getRoutes:function(){return r.map((function(n){return o[n]}))},addRoutes:function(n){Q(n,r,o,a)}}}function Y(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var o=1,a=r.length;o<a;++o){var i=n.keys[o-1];i&&(t[i.name||"pathMatch"]="string"==typeof r[o]?c(r[o]):r[o])}return!0}var nn=G&&window.performance&&window.performance.now?window.performance:Date;function en(){return nn.now().toFixed(3)}var tn=en();function rn(){return tn}function on(n){return tn=n}var an=Object.create(null);function sn(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=o({},window.history.state);return t.key=rn(),window.history.replaceState(t,"",e),window.addEventListener("popstate",pn),function(){window.removeEventListener("popstate",pn)}}function ln(n,e,t,r){if(n.app){var o=n.options.scrollBehavior;o&&n.app.$nextTick((function(){var a=function(){var n=rn();if(n)return an[n]}(),i=o.call(n,e,t,r?a:null);i&&("function"==typeof i.then?i.then((function(n){fn(n,a)})).catch((function(n){0})):fn(i,a))}))}}function cn(){var n=rn();n&&(an[n]={x:window.pageXOffset,y:window.pageYOffset})}function pn(n){cn(),n.state&&n.state.key&&on(n.state.key)}function dn(n){return mn(n.x)||mn(n.y)}function un(n){return{x:mn(n.x)?n.x:window.pageXOffset,y:mn(n.y)?n.y:window.pageYOffset}}function mn(n){return"number"==typeof n}var hn=/^#\d/;function fn(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var o=hn.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(o){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(o,a={x:mn((t=a).x)?t.x:0,y:mn(t.y)?t.y:0})}else dn(n)&&(e=un(n))}else r&&dn(n)&&(e=un(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var gn,yn=G&&((-1===(gn=window.navigator.userAgent).indexOf("Android 2.")&&-1===gn.indexOf("Android 4.0")||-1===gn.indexOf("Mobile Safari")||-1!==gn.indexOf("Chrome")||-1!==gn.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function bn(n,e){cn();var t=window.history;try{if(e){var r=o({},t.state);r.key=rn(),t.replaceState(r,"",n)}else t.pushState({key:on(en())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function vn(n){bn(n,!0)}var kn={redirected:2,aborted:4,cancelled:8,duplicated:16};function wn(n,e){return Tn(n,e,kn.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return Cn.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function xn(n,e){return Tn(n,e,kn.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Tn(n,e,t,r){var o=new Error(r);return o._isRouter=!0,o.from=n,o.to=e,o.type=t,o}var Cn=["params","query","hash"];function Rn(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function En(n,e){return Rn(n)&&n._isRouter&&(null==e||n.type===e)}function Sn(n,e,t){var r=function(o){o>=n.length?t():n[o]?e(n[o],(function(){r(o+1)})):r(o+1)};r(0)}function Pn(n){return function(e,t,r){var o=!1,a=0,i=null;_n(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){o=!0,a++;var l,c=On((function(e){var o;((o=e).__esModule||jn&&"Module"===o[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:$.extend(e),t.components[s]=e,--a<=0&&r()})),p=On((function(n){var e="Failed to resolve async component "+s+": "+n;i||(i=Rn(n)?n:new Error(e),r(i))}));try{l=n(c,p)}catch(n){p(n)}if(l)if("function"==typeof l.then)l.then(c,p);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,p)}}})),o||r()}}function _n(n,e){return In(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function In(n){return Array.prototype.concat.apply([],n)}var jn="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function On(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var Fn=function(n,e){this.router=n,this.base=function(n){if(!n)if(G){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=g,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function An(n,e,t,r){var o=_n(n,(function(n,r,o,a){var i=function(n,e){"function"!=typeof n&&(n=$.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,r,o,a)})):t(i,r,o,a)}));return In(r?o.reverse():o)}function Mn(n,e){if(e)return function(){return n.apply(e,arguments)}}Fn.prototype.listen=function(n){this.cb=n},Fn.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Fn.prototype.onError=function(n){this.errorCbs.push(n)},Fn.prototype.transitionTo=function(n,e,t){var r,o=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(r,(function(){o.updateRoute(r),e&&e(r),o.ensureURL(),o.router.afterHooks.forEach((function(n){n&&n(r,a)})),o.ready||(o.ready=!0,o.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!o.ready&&(En(n,kn.redirected)&&a===g||(o.ready=!0,o.readyErrorCbs.forEach((function(e){e(n)}))))}))},Fn.prototype.confirmTransition=function(n,e,t){var r=this,o=this.current;this.pending=n;var a,i,s=function(n){!En(n)&&Rn(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=o.matched.length-1;if(v(n,o)&&l===c&&n.matched[l]===o.matched[c])return this.ensureURL(),n.hash&&ln(this.router,o,n,!1),s(((i=Tn(a=o,n,kn.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",i));var p=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=p.updated,u=p.deactivated,m=p.activated,h=[].concat(function(n){return An(n,"beforeRouteLeave",Mn,!0)}(u),this.router.beforeHooks,function(n){return An(n,"beforeRouteUpdate",Mn)}(d),m.map((function(n){return n.beforeEnter})),Pn(m)),f=function(e,t){if(r.pending!==n)return s(xn(o,n));try{e(n,o,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return Tn(n,e,kn.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(o,n))):Rn(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(wn(o,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};Sn(h,f,(function(){Sn(function(n){return An(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,o,a){return n(r,o,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,r)}))}(m).concat(r.router.resolveHooks),f,(function(){if(r.pending!==n)return s(xn(o,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){w(n)}))}))}))},Fn.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Fn.prototype.setupListeners=function(){},Fn.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=g,this.pending=null};var Dn=function(n){function e(e,t){n.call(this,e,t),this._startLocation=zn(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=yn&&t;r&&this.listeners.push(sn());var o=function(){var t=n.current,o=zn(n.base);n.current===g&&o===n._startLocation||n.transitionTo(o,(function(n){r&&ln(e,n,t,!0)}))};window.addEventListener("popstate",o),this.listeners.push((function(){window.removeEventListener("popstate",o)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){bn(R(r.base+n.fullPath)),ln(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){vn(R(r.base+n.fullPath)),ln(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(zn(this.base)!==this.current.fullPath){var e=R(this.base+this.current.fullPath);n?bn(e):vn(e)}},e.prototype.getCurrentLocation=function(){return zn(this.base)},e}(Fn);function zn(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(R(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var qn=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=zn(n);if(!/^\/#/.test(e))return window.location.replace(R(n+"/#"+e)),!0}(this.base)||Ln()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=yn&&e;t&&this.listeners.push(sn());var r=function(){var e=n.current;Ln()&&n.transitionTo(Un(),(function(r){t&&ln(n.router,r,e,!0),yn||Wn(r.fullPath)}))},o=yn?"popstate":"hashchange";window.addEventListener(o,r),this.listeners.push((function(){window.removeEventListener(o,r)}))}},e.prototype.push=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){Hn(n.fullPath),ln(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){Wn(n.fullPath),ln(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Un()!==e&&(n?Hn(e):Wn(e))},e.prototype.getCurrentLocation=function(){return Un()},e}(Fn);function Ln(){var n=Un();return"/"===n.charAt(0)||(Wn("/"+n),!1)}function Un(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Nn(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Hn(n){yn?bn(Nn(n)):window.location.hash=n}function Wn(n){yn?vn(Nn(n)):window.location.replace(Nn(n))}var Bn=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){En(n,kn.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Fn),$n=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Z(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!yn&&!1!==n.fallback,this.fallback&&(e="hash"),G||(e="abstract"),this.mode=e,e){case"history":this.history=new Dn(this,n.base);break;case"hash":this.history=new qn(this,n.base,this.fallback);break;case"abstract":this.history=new Bn(this,n.base);break;default:0}},Vn={currentRoute:{configurable:!0}};$n.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Vn.currentRoute.get=function(){return this.history&&this.history.current},$n.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Dn||t instanceof qn){var r=function(n){t.setupListeners(),function(n){var r=t.current,o=e.options.scrollBehavior;yn&&o&&"fullPath"in n&&ln(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},$n.prototype.beforeEach=function(n){return Jn(this.beforeHooks,n)},$n.prototype.beforeResolve=function(n){return Jn(this.resolveHooks,n)},$n.prototype.afterEach=function(n){return Jn(this.afterHooks,n)},$n.prototype.onReady=function(n,e){this.history.onReady(n,e)},$n.prototype.onError=function(n){this.history.onError(n)},$n.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},$n.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},$n.prototype.go=function(n){this.history.go(n)},$n.prototype.back=function(){this.go(-1)},$n.prototype.forward=function(){this.go(1)},$n.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},$n.prototype.resolve=function(n,e,t){var r=B(n,e=e||this.history.current,t,this),o=this.match(r,e),a=o.redirectedFrom||o.fullPath;return{location:r,route:o,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?R(n+"/"+r):r}(this.history.base,a,this.mode),normalizedTo:r,resolved:o}},$n.prototype.getRoutes=function(){return this.matcher.getRoutes()},$n.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==g&&this.history.transitionTo(this.history.getCurrentLocation())},$n.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==g&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties($n.prototype,Vn);var Kn=$n;function Jn(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}$n.install=function n(e){if(!n.installed||$!==e){n.installed=!0,$=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",x),e.component("RouterLink",K);var o=e.config.optionMergeStrategies;o.beforeRouteEnter=o.beforeRouteLeave=o.beforeRouteUpdate=o.created}},$n.version="3.6.5",$n.isNavigationFailure=En,$n.NavigationFailureType=kn,$n.START_LOCATION=g,G&&window.Vue&&window.Vue.use($n);t(117);var Gn=t(0),Qn=t(103),Xn=t.n(Qn),Zn=t(104),Yn=t.n(Zn),ne={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${Yn()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=te(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=re(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return Xn()([{name:"description",content:this.$description}],n,this.siteMeta,oe)},updateCanonicalLink(){ee(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",te(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){re(null,this.currentMetaTags),ee()}};function ee(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function te(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function re(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function oe(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var ae=t(57),ie={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ae)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),o=window.innerHeight+t;for(let n=0;n<e.length;n++){const a=e[n],i=e[n+1],s=0===n&&0===t||t>=a.parentElement.offsetTop+10&&(!i||t<i.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(a.hash)){const t=a;if(o===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},se=t(31),le=t.n(se),ce={mounted(){le.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||r.default.component(n.name)||le.a.start(),t()}),this.$router.afterEach(()=>{le.a.done(),this.isSidebarOpen=!1})}};t(251),t(252);class pe{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var de={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new pe).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],o=document.createElement("style");o.type="text/css","top"===t&&r.firstChild?r.insertBefore(o,r.firstChild):r.appendChild(o),o.styleSheet?o.styleSheet.cssText=n:o.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var ue={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},me={},he=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},fe=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:ue[n]},ge=function n(e,t,r){var o=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))o[n]=t[n];else{var e=n.replace("data","");o.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,a=e.children;o.appendChild(n(t,r,a))})),o},ye=function(n,e,t){var r,o=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==o.length||t?o:o[0]},be=function(n,e){var t,r,o=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<template>([\s\S]+)<\/template>/),i=n.match(/<script>([\s\S]+)<\/script>/),s={css:o&&o[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=he(s.html),s.jsTpl=(t=s.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),o=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,a=[eval][0](o);return a.template=e,a}(s.js,s.html);var l=fe("vue");return s.jsLib.unshift(l),s},ve=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),o=n.match(/<html>([\s\S]+)<\/html>/),a=n.match(/<script>([\s\S]+)<\/script>/),i={css:r&&r[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return i.htmlTpl=i.html,i.jsTpl=i.js,i.script=(t=i.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),i},ke=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function we(){var n=ye(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=ye(n,"vuepress-plugin-demo-block__code"),t=ye(n,"vuepress-plugin-demo-block__display"),r=ye(n,"vuepress-plugin-demo-block__footer"),o=ye(t,"vuepress-plugin-demo-block__app"),a=decodeURIComponent(n.dataset.code),i=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);i=i?JSON.parse(i):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),o=new Function("return ".concat(r))(),a={js:o,css:o.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:ke(n),htmlTpl:he("")},i=fe("react"),s=fe("reactDOM");return a.jsLib.unshift(i,s),a}(a,i):"vanilla"===s?ve(a,i):be(a,i),p=ge("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(p),p.addEventListener("click",xe.bind(null,p,l,e,r)),fe("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,o=n.jsLib,a=n.cssLib,i=o.concat(a).concat(fe("cssLib")).concat(fe("jsLib")).join(",");return ge("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:i}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),fe("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,o=n.jsLib,a=n.cssLib,i=JSON.stringify({css:e,html:t,js:r,js_external:o.concat(fe("jsLib")).join(";"),css_external:a.concat(fe("cssLib")).join(";"),layout:fe("codepenLayout"),js_pre_processor:fe("codepenJsProcessor"),editors:fe("codepenEditors")});return ge("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:i}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==i.horizontal?i.horizontal:fe("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var d=e.firstChild.cloneNode(!0);d.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(d)}if(c.css&&function(n){if(!me[n]){var e=ge("style",{innerHTML:n});document.body.appendChild(e),me[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),o);else if("vue"===s){var u=(new(Vue.extend(c.script))).$mount();o.appendChild(u.$el)}else"vanilla"===s&&(o.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){we()}),300)}function xe(n,e,t,r){var o="1"!==n.dataset.isExpand;t.style.height=o?"".concat(e,"px"):0,o?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=o?"1":"0"}var Te={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},we()},updated:function(){we()}},Ce="auto",Re="zoom-in",Ee="zoom-out",Se="grab",Pe="move";function _e(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o={passive:!1};r?n.addEventListener(e,t,o):n.removeEventListener(e,t,o)}function Ie(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function je(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Oe(n,e,t){!function(n){var e=Fe,t=Ae;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var o=n.transform;delete n.transform,n[t]=o}}(e);var r=n.style,o={};for(var a in e)t&&(o[a]=r[a]||""),r[a]=e[a];return o}var Fe="transition",Ae="transform",Me="transform",De="transitionend";var ze=function(){},qe={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:ze,onClose:ze,onGrab:ze,onMove:ze,onRelease:ze,onBeforeOpen:ze,onBeforeClose:ze,onBeforeGrab:ze,onBeforeRelease:ze,onImageLoading:ze,onImageLoaded:ze},Le={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),Ne(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,o=this.lastScrollPosition.y-t,a=this.options.scrollThreshold;(Math.abs(o)>=a||Math.abs(r)>=a)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(Ue(n)&&!Ne(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){Ue(n)&&!Ne(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function Ue(n){return 0===n.button}function Ne(n){return n.metaKey||n.ctrlKey}var He={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Oe(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),_e(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Oe(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},We="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Be=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),$e=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},Ve={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=je(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,o=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Se:Ee,transition:Me+"\n        "+r+"s\n        "+o,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Oe(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Oe(this.el,{transform:"none"})},grab:function(n,e,t){var r=Ke(),o=r.x-n,a=r.y-e;Oe(this.el,{cursor:Pe,transform:"translate3d(\n        "+(this.translate.x+o)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=Ke(),o=r.x-n,a=r.y-e;Oe(this.el,{transition:Me,transform:"translate3d(\n        "+(this.translate.x+o)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Oe(this.el,this.styleClose)},restoreOpenStyle:function(){Oe(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Ke(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,o=r.customSize,a=r.scaleBase;if(!o&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(o&&"object"===(void 0===o?"undefined":We(o)))return{x:o.width/this.rect.width,y:o.height/this.rect.height};var i=this.rect.width/2,s=this.rect.height/2,l=Ke(),c={x:l.x-i,y:l.y-s},p=c.x/i,d=c.y/s,u=a+Math.min(p,d);if(o&&"string"==typeof o){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,f=parseFloat(o)*m/(100*this.rect.width),g=parseFloat(o)*h/(100*this.rect.height);if(u>f||u>g)return{x:f,y:g}}return{x:u,y:u}}};function Ke(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Je(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){_e(n,r,e[r],t)}))}var Ge=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Ve),this.overlay=Object.create(He),this.handler=Object.create(Le),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=$e({},qe,e),this.overlay.init(this),this.handler.init(this)}return Be(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Re,_e(n,"click",this.handler.click),this.options.preloadImage&&Ie(je(n)));return this}},{key:"config",value:function(n){return n?($e(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var o=this.target.srcOriginal;null!=o&&(this.options.onImageLoading(r),Ie(o,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),_e(document,"scroll",this.handler.scroll),_e(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&_e(window,"resize",this.handler.resizeWindow);var a=function n(){_e(r,De,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Je(document,e.handler,!0),t(r)};return _e(r,De,a),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Ce,this.overlay.fadeOut(),this.target.zoomOut(),_e(document,"scroll",this.handler.scroll,!1),_e(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&_e(window,"resize",this.handler.resizeWindow,!1);var r=function r(){_e(t,De,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Je(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return _e(t,De,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var o=this.target.el;this.options.onBeforeGrab(o),this.released=!1,this.target.grab(n,e,t);var a=function n(){_e(o,De,n,!1),r(o)};return _e(o,De,a),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Pe,this.target.move(n,e,t);var o=this.target.el,a=function n(){_e(o,De,n,!1),r(o)};return _e(o,De,a),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Ce,this.target.restoreOpenStyle();var r=function r(){_e(t,De,r,!1),n.lock=!1,n.released=!0,e(t)};return _e(t,De,r),this}}}]),n}();const Qe=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),Xe=Number("500");class Ze{constructor(){this.instance=new Ge(Qe)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=Xe){setTimeout(()=>this.update(n),e)}}var Ye=[ne,ie,ce,de,Te,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new Ze,this.$vuepress.zooming.updateDelay()}}],nt={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return Object(Gn.h)("layout",n),r.default.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},et=t(2),tt=Object(et.a)(nt,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;Object(Gn.f)(tt,"mixins",Ye);const rt=[{name:"v-376508bf",path:"/react/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-376508bf").then(t)}},{path:"/react/index/index.html",redirect:"/react/index/"},{path:"/10.react/0.index.html",redirect:"/react/index/"},{name:"v-3611955d",path:"/react/plan/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3611955d").then(t)}},{path:"/react/plan/index.html",redirect:"/react/plan/"},{path:"/10.react/1.plan.html",redirect:"/react/plan/"},{name:"v-0d7bb8be",path:"/react/basic/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0d7bb8be").then(t)}},{path:"/react/basic/index.html",redirect:"/react/basic/"},{path:"/10.react/10.基础/0.index.html",redirect:"/react/basic/"},{name:"v-359e682f",path:"/react/basic/chapter/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-359e682f").then(t)}},{path:"/react/basic/chapter/index.html",redirect:"/react/basic/chapter/"},{path:"/10.react/10.基础/10.chapter.html",redirect:"/react/basic/chapter/"},{name:"v-a1dbc2a2",path:"/react/basic/faq/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-a1dbc2a2").then(t)}},{path:"/react/basic/faq/index.html",redirect:"/react/basic/faq/"},{path:"/10.react/10.基础/20.faq.html",redirect:"/react/basic/faq/"},{name:"v-406c3962",path:"/react/basic/children/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-406c3962").then(t)}},{path:"/react/basic/children/index.html",redirect:"/react/basic/children/"},{path:"/10.react/10.基础/30.ReactChildren.html",redirect:"/react/basic/children/"},{name:"v-4b4b48ab",path:"/react/basic/element/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4b4b48ab").then(t)}},{path:"/react/basic/element/index.html",redirect:"/react/basic/element/"},{path:"/10.react/10.基础/40.ReactElement.html",redirect:"/react/basic/element/"},{name:"v-4d309ab6",path:"/react/reconciliation/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4d309ab6").then(t)}},{path:"/react/reconciliation/index/index.html",redirect:"/react/reconciliation/index/"},{path:"/10.react/20.调和（Reconciliation）/0.index.html",redirect:"/react/reconciliation/index/"},{name:"v-1a05c896",path:"/react/reconciliation/fiber/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1a05c896").then(t)}},{path:"/react/reconciliation/fiber/index.html",redirect:"/react/reconciliation/fiber/"},{path:"/10.react/20.调和（Reconciliation）/10.fiber.html",redirect:"/react/reconciliation/fiber/"},{name:"v-27daf196",path:"/react/reconciliation/reactChildFiber/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-27daf196").then(t)}},{path:"/react/reconciliation/reactChildFiber/index.html",redirect:"/react/reconciliation/reactChildFiber/"},{path:"/10.react/20.调和（Reconciliation）/20.reactChildFiber.html",redirect:"/react/reconciliation/reactChildFiber/"},{name:"v-e4ff14f8",path:"/react/reconciliation/expirationTime/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-e4ff14f8").then(t)}},{path:"/react/reconciliation/expirationTime/index.html",redirect:"/react/reconciliation/expirationTime/"},{path:"/10.react/20.调和（Reconciliation）/30.expirationTime.html",redirect:"/react/reconciliation/expirationTime/"},{name:"v-1daf77ea",path:"/react/reconciliation/scheduleWork/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1daf77ea").then(t)}},{path:"/react/reconciliation/scheduleWork/index.html",redirect:"/react/reconciliation/scheduleWork/"},{path:"/10.react/20.调和（Reconciliation）/40.scheduleWork.html",redirect:"/react/reconciliation/scheduleWork/"},{name:"v-7050b2a0",path:"/react/reconciliation/lane/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7050b2a0").then(t)}},{path:"/react/reconciliation/lane/index.html",redirect:"/react/reconciliation/lane/"},{path:"/10.react/20.调和（Reconciliation）/50.lane.html",redirect:"/react/reconciliation/lane/"},{name:"v-41adcea0",path:"/react/scheduler/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-41adcea0").then(t)}},{path:"/react/scheduler/index/index.html",redirect:"/react/scheduler/index/"},{path:"/10.react/30.调度器（Scheduler）/0.index.html",redirect:"/react/scheduler/index/"},{name:"v-a7e4381c",path:"/react/scheduler/scheduleCallback/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-a7e4381c").then(t)}},{path:"/react/scheduler/scheduleCallback/index.html",redirect:"/react/scheduler/scheduleCallback/"},{path:"/10.react/30.调度器（Scheduler）/10.scheduleCallback.html",redirect:"/react/scheduler/scheduleCallback/"},{name:"v-fefa4114",path:"/react/scheduler/schedulerHostConfig/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-fefa4114").then(t)}},{path:"/react/scheduler/schedulerHostConfig/index.html",redirect:"/react/scheduler/schedulerHostConfig/"},{path:"/10.react/30.调度器（Scheduler）/20.schedulerHostConfig.html",redirect:"/react/scheduler/schedulerHostConfig/"},{name:"v-21473796",path:"/react/scheduler/scheduler/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-21473796").then(t)}},{path:"/react/scheduler/scheduler/index.html",redirect:"/react/scheduler/scheduler/"},{path:"/10.react/30.调度器（Scheduler）/30.scheduler.html",redirect:"/react/scheduler/scheduler/"},{name:"v-492f4a82",path:"/react/updater/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-492f4a82").then(t)}},{path:"/react/updater/index/index.html",redirect:"/react/updater/index/"},{path:"/10.react/40.更新器（Updater）/0.index.html",redirect:"/react/updater/index/"},{name:"v-1d8100c2",path:"/react/updater/workloop/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1d8100c2").then(t)}},{path:"/react/updater/workloop/index.html",redirect:"/react/updater/workloop/"},{path:"/10.react/40.更新器（Updater）/10.workloop.html",redirect:"/react/updater/workloop/"},{name:"v-fcc2e96a",path:"/react/render/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-fcc2e96a").then(t)}},{path:"/react/render/index/index.html",redirect:"/react/render/index/"},{path:"/10.react/50.渲染器（Render）/0.index.html",redirect:"/react/render/index/"},{name:"v-36e6278b",path:"/react/render/render/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-36e6278b").then(t)}},{path:"/react/render/render/index.html",redirect:"/react/render/render/"},{path:"/10.react/50.渲染器（Render）/10.ReactDOM.html",redirect:"/react/render/render/"},{name:"v-0fd7e2db",path:"/react/hooks/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0fd7e2db").then(t)}},{path:"/react/hooks/index/index.html",redirect:"/react/hooks/index/"},{path:"/10.react/70.hooks原理/0.index.html",redirect:"/react/hooks/index/"},{name:"v-fda4440a",path:"/react/hooks/useState/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-fda4440a").then(t)}},{path:"/react/hooks/useState/index.html",redirect:"/react/hooks/useState/"},{path:"/10.react/70.hooks原理/10.useState.html",redirect:"/react/hooks/useState/"},{name:"v-228419df",path:"/react/hooks/useEffect/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-228419df").then(t)}},{path:"/react/hooks/useEffect/index.html",redirect:"/react/hooks/useEffect/"},{path:"/10.react/70.hooks原理/20.useEffect.html",redirect:"/react/hooks/useEffect/"},{name:"v-2778a33b",path:"/react/hooks/useRef/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2778a33b").then(t)}},{path:"/react/hooks/useRef/index.html",redirect:"/react/hooks/useRef/"},{path:"/10.react/70.hooks原理/30.useRef.html",redirect:"/react/hooks/useRef/"},{name:"v-230de106",path:"/react/summary/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-230de106").then(t)}},{path:"/react/summary/index/index.html",redirect:"/react/summary/index/"},{path:"/10.react/80.总结/0.index.html",redirect:"/react/summary/index/"},{name:"v-1154a3c8",path:"/react/summary/bitOperation/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1154a3c8").then(t)}},{path:"/react/summary/bitOperation/index.html",redirect:"/react/summary/bitOperation/"},{path:"/10.react/80.总结/10.bitOperation.html",redirect:"/react/summary/bitOperation/"},{name:"v-35203ba8",path:"/react/summary/first-render/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-35203ba8").then(t)}},{path:"/react/summary/first-render/index.html",redirect:"/react/summary/first-render/"},{path:"/10.react/80.总结/20.first-render.html",redirect:"/react/summary/first-render/"},{name:"v-59f008fe",path:"/react/summary/event-listener/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-59f008fe").then(t)}},{path:"/react/summary/event-listener/index.html",redirect:"/react/summary/event-listener/"},{path:"/10.react/80.总结/30.event-listener.html",redirect:"/react/summary/event-listener/"},{name:"v-5de90ac4",path:"/react/summary/10-min-react/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5de90ac4").then(t)}},{path:"/react/summary/10-min-react/index.html",redirect:"/react/summary/10-min-react/"},{path:"/10.react/80.总结/40.10-min-react.html",redirect:"/react/summary/10-min-react/"},{name:"v-071d800b",path:"/react/tour/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-071d800b").then(t)}},{path:"/react/tour/index/index.html",redirect:"/react/tour/index/"},{path:"/10.react/90.React源码漂流记/0.index.html",redirect:"/react/tour/index/"},{name:"v-7532101f",path:"/react/tour/plan/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7532101f").then(t)}},{path:"/react/tour/plan/index.html",redirect:"/react/tour/plan/"},{path:"/10.react/90.React源码漂流记/1.Plan.html",redirect:"/react/tour/plan/"},{name:"v-05b01242",path:"/react/tour/react-basic-element/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-05b01242").then(t)}},{path:"/react/tour/react-basic-element/index.html",redirect:"/react/tour/react-basic-element/"},{path:"/10.react/90.React源码漂流记/10.react-basic-element.html",redirect:"/react/tour/react-basic-element/"},{name:"v-1e97eeff",path:"/react/tour/react-reconciliation-2/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1e97eeff").then(t)}},{path:"/react/tour/react-reconciliation-2/index.html",redirect:"/react/tour/react-reconciliation-2/"},{path:"/10.react/90.React源码漂流记/100.react-reconciliation-2.html",redirect:"/react/tour/react-reconciliation-2/"},{name:"v-5962efbf",path:"/react/tour/react-reconciliation-3/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5962efbf").then(t)}},{path:"/react/tour/react-reconciliation-3/index.html",redirect:"/react/tour/react-reconciliation-3/"},{path:"/10.react/90.React源码漂流记/110.react-reconciliation-3.html",redirect:"/react/tour/react-reconciliation-3/"},{name:"v-d7a41f02",path:"/react/tour/react-reconciliation-4/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-d7a41f02").then(t)}},{path:"/react/tour/react-reconciliation-4/index.html",redirect:"/react/tour/react-reconciliation-4/"},{path:"/10.react/90.React源码漂流记/120.react-reconciliation-4.html",redirect:"/react/tour/react-reconciliation-4/"},{name:"v-620e1d82",path:"/react/tour/react-reconciliation-5/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-620e1d82").then(t)}},{path:"/react/tour/react-reconciliation-5/index.html",redirect:"/react/tour/react-reconciliation-5/"},{path:"/10.react/90.React源码漂流记/130.react-reconciliation-5.html",redirect:"/react/tour/react-reconciliation-5/"},{name:"v-09c3f1ff",path:"/react/tour/react-reconciliation-6/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-09c3f1ff").then(t)}},{path:"/react/tour/react-reconciliation-6/index.html",redirect:"/react/tour/react-reconciliation-6/"},{path:"/10.react/90.React源码漂流记/140.react-reconciliation-6.html",redirect:"/react/tour/react-reconciliation-6/"},{name:"v-448ef2bf",path:"/react/tour/react-reconciliation-7/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-448ef2bf").then(t)}},{path:"/react/tour/react-reconciliation-7/index.html",redirect:"/react/tour/react-reconciliation-7/"},{path:"/10.react/90.React源码漂流记/150.react-reconciliation-7.html",redirect:"/react/tour/react-reconciliation-7/"},{name:"v-7f59f37f",path:"/react/tour/react-reconciliation-8/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7f59f37f").then(t)}},{path:"/react/tour/react-reconciliation-8/index.html",redirect:"/react/tour/react-reconciliation-8/"},{path:"/10.react/90.React源码漂流记/160.react-reconciliation-8.html",redirect:"/react/tour/react-reconciliation-8/"},{name:"v-8bb61782",path:"/react/tour/react-reconciliation-9/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-8bb61782").then(t)}},{path:"/react/tour/react-reconciliation-9/index.html",redirect:"/react/tour/react-reconciliation-9/"},{path:"/10.react/90.React源码漂流记/170.react-reconciliation-9.html",redirect:"/react/tour/react-reconciliation-9/"},{name:"v-4079c547",path:"/react/tour/react-reconciliation-10/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4079c547").then(t)}},{path:"/react/tour/react-reconciliation-10/index.html",redirect:"/react/tour/react-reconciliation-10/"},{path:"/10.react/90.React源码漂流记/180.react-reconciliation-10.html",redirect:"/react/tour/react-reconciliation-10/"},{name:"v-5585c5df",path:"/react/tour/talk/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5585c5df").then(t)}},{path:"/react/tour/talk/index.html",redirect:"/react/tour/talk/"},{path:"/10.react/90.React源码漂流记/2.talk.html",redirect:"/react/tour/talk/"},{name:"v-50140a3b",path:"/react/tour/react-basic-children/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-50140a3b").then(t)}},{path:"/react/tour/react-basic-children/index.html",redirect:"/react/tour/react-basic-children/"},{path:"/10.react/90.React源码漂流记/20.react-basic-children.html",redirect:"/react/tour/react-basic-children/"},{name:"v-ec07c126",path:"/react/tour/react-basic-glimpse/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-ec07c126").then(t)}},{path:"/react/tour/react-basic-glimpse/index.html",redirect:"/react/tour/react-basic-glimpse/"},{path:"/10.react/90.React源码漂流记/30.react-basic-view.html",redirect:"/react/tour/react-basic-glimpse/"},{name:"v-2d7c6c07",path:"/react/tour/react-scheduler-1/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2d7c6c07").then(t)}},{path:"/react/tour/react-scheduler-1/index.html",redirect:"/react/tour/react-scheduler-1/"},{path:"/10.react/90.React源码漂流记/300.react-scheduler-1.html",redirect:"/react/tour/react-scheduler-1/"},{name:"v-49f7f4ca",path:"/react/tour/react-reconciliation-1/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-49f7f4ca").then(t)}},{path:"/react/tour/react-reconciliation-1/index.html",redirect:"/react/tour/react-reconciliation-1/"},{path:"/10.react/90.React源码漂流记/90.react-reconciliation-1.html",redirect:"/react/tour/react-reconciliation-1/"},{name:"v-321a8dff",path:"/react/tour/dr-1/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-321a8dff").then(t)}},{path:"/react/tour/dr-1/index.html",redirect:"/react/tour/dr-1/"},{path:"/10.react/90.React源码漂流记/900.react-docs-reading-1.html",redirect:"/react/tour/dr-1/"},{name:"v-2e216f3f",path:"/react/tour/dr-2/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2e216f3f").then(t)}},{path:"/react/tour/dr-2/index.html",redirect:"/react/tour/dr-2/"},{path:"/10.react/90.React源码漂流记/910.react-docs-reading-2.html",redirect:"/react/tour/dr-2/"},{name:"v-1d06307d",path:"/vue3/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1d06307d").then(t)}},{path:"/vue3/index/index.html",redirect:"/vue3/index/"},{path:"/20.vue3/0.index.html",redirect:"/vue3/index/"},{name:"v-cecea10e",path:"/vue3/plan/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-cecea10e").then(t)}},{path:"/vue3/plan/index.html",redirect:"/vue3/plan/"},{path:"/20.vue3/1.plan.html",redirect:"/vue3/plan/"},{name:"v-620539aa",path:"/vue3/basic/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-620539aa").then(t)}},{path:"/vue3/basic/index/index.html",redirect:"/vue3/basic/index/"},{path:"/20.vue3/10.基础/0.index.html",redirect:"/vue3/basic/index/"},{name:"v-5d322c1d",path:"/vue3/reactivity/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5d322c1d").then(t)}},{path:"/vue3/reactivity/index/index.html",redirect:"/vue3/reactivity/index/"},{path:"/20.vue3/20.reactivity/0.index.html",redirect:"/vue3/reactivity/index/"},{name:"v-dcaaef7a",path:"/vue3/reactivity/ref/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-dcaaef7a").then(t)}},{path:"/vue3/reactivity/ref/index.html",redirect:"/vue3/reactivity/ref/"},{path:"/20.vue3/20.reactivity/10.ref.html",redirect:"/vue3/reactivity/ref/"},{name:"v-4d69bd7d",path:"/vue3/basic/reactive/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4d69bd7d").then(t)}},{path:"/vue3/basic/reactive/index.html",redirect:"/vue3/basic/reactive/"},{path:"/20.vue3/20.reactivity/20.reactive.html",redirect:"/vue3/basic/reactive/"},{name:"v-eea5a8ce",path:"/vue3/basic/handler/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-eea5a8ce").then(t)}},{path:"/vue3/basic/handler/index.html",redirect:"/vue3/basic/handler/"},{path:"/20.vue3/20.reactivity/30.handler.html",redirect:"/vue3/basic/handler/"},{name:"v-7c3809bd",path:"/vue3/basic/effect/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7c3809bd").then(t)}},{path:"/vue3/basic/effect/index.html",redirect:"/vue3/basic/effect/"},{path:"/20.vue3/20.reactivity/40.effect.html",redirect:"/vue3/basic/effect/"},{name:"v-47f301c6",path:"/vue3/basic/computed/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-47f301c6").then(t)}},{path:"/vue3/basic/computed/index.html",redirect:"/vue3/basic/computed/"},{path:"/20.vue3/20.reactivity/50.computed.html",redirect:"/vue3/basic/computed/"},{name:"v-7844a83d",path:"/vue3/runtime-core/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7844a83d").then(t)}},{path:"/vue3/runtime-core/index/index.html",redirect:"/vue3/runtime-core/index/"},{path:"/20.vue3/30.runtime-core/0.index.html",redirect:"/vue3/runtime-core/index/"},{name:"v-847c1376",path:"/vue3/runtime-dom/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-847c1376").then(t)}},{path:"/vue3/runtime-dom/index/index.html",redirect:"/vue3/runtime-dom/index/"},{path:"/20.vue3/40.runtime-dom/0.index.html",redirect:"/vue3/runtime-dom/index/"},{name:"v-36768879",path:"/vue3/runtime-dom/apiCreateApp/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-36768879").then(t)}},{path:"/vue3/runtime-dom/apiCreateApp/index.html",redirect:"/vue3/runtime-dom/apiCreateApp/"},{path:"/20.vue3/40.runtime-dom/10.apiCreateApp.html",redirect:"/vue3/runtime-dom/apiCreateApp/"},{name:"v-af98cc06",path:"/vue3/runtime-dom/apiDefineComponent/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-af98cc06").then(t)}},{path:"/vue3/runtime-dom/apiDefineComponent/index.html",redirect:"/vue3/runtime-dom/apiDefineComponent/"},{path:"/20.vue3/40.runtime-dom/20.apiDefineComponent.html",redirect:"/vue3/runtime-dom/apiDefineComponent/"},{name:"v-7b4d74fd",path:"/pages/286896/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7b4d74fd").then(t)}},{path:"/pages/286896/index.html",redirect:"/pages/286896/"},{path:"/20.vue3/40.runtime-dom/90.scheduler.html",redirect:"/pages/286896/"},{name:"v-50e647d9",path:"/web/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-50e647d9").then(t)}},{path:"/web/index/index.html",redirect:"/web/index/"},{path:"/30.web/0.index.html",redirect:"/web/index/"},{name:"v-26e7ba7d",path:"/web/plan/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-26e7ba7d").then(t)}},{path:"/web/plan/index.html",redirect:"/web/plan/"},{path:"/30.web/1.plan.html",redirect:"/web/plan/"},{name:"v-566737cd",path:"/vite/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-566737cd").then(t)}},{path:"/vite/index/index.html",redirect:"/vite/index/"},{path:"/30.web/10.vite源码/0.index.html",redirect:"/vite/index/"},{name:"v-6e8687a2",path:"/vite/basic/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6e8687a2").then(t)}},{path:"/vite/basic/index/index.html",redirect:"/vite/basic/index/"},{path:"/30.web/10.vite源码/10.基础/0.index.html",redirect:"/vite/basic/index/"},{name:"v-7373c0fa",path:"/vite/core/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7373c0fa").then(t)}},{path:"/vite/core/index/index.html",redirect:"/vite/core/index/"},{path:"/30.web/10.vite源码/20.vite/0.index.html",redirect:"/vite/core/index/"},{name:"v-55a8d0bf",path:"/vite/core/cli/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-55a8d0bf").then(t)}},{path:"/vite/core/cli/index.html",redirect:"/vite/core/cli/"},{path:"/30.web/10.vite源码/20.vite/10.cli.html",redirect:"/vite/core/cli/"},{name:"v-18766245",path:"/vite/core/server/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-18766245").then(t)}},{path:"/vite/core/server/index.html",redirect:"/vite/core/server/"},{path:"/30.web/10.vite源码/20.vite/20.server.html",redirect:"/vite/core/server/"},{name:"v-53f20ec6",path:"/express/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-53f20ec6").then(t)}},{path:"/express/index/index.html",redirect:"/express/index/"},{path:"/30.web/160.express/0.index.html",redirect:"/express/index/"},{name:"v-4bc33869",path:"/acorn/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4bc33869").then(t)}},{path:"/acorn/index/index.html",redirect:"/acorn/index/"},{path:"/30.web/170.acorn源码/0.index.html",redirect:"/acorn/index/"},{name:"v-687541db",path:"/immutable/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-687541db").then(t)}},{path:"/immutable/index/index.html",redirect:"/immutable/index/"},{path:"/30.web/180.immutable.js源码/0.index.html",redirect:"/immutable/index/"},{name:"v-6414adc6",path:"/ts/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6414adc6").then(t)}},{path:"/ts/index/index.html",redirect:"/ts/index/"},{path:"/30.web/4.typescript-utility/0.index.html",redirect:"/ts/index/"},{name:"v-2985970b",path:"/ts/basic/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2985970b").then(t)}},{path:"/ts/basic/index/index.html",redirect:"/ts/basic/index/"},{path:"/30.web/4.typescript-utility/10.基础/0.index.html",redirect:"/ts/basic/index/"},{name:"v-aef55d32",path:"/ts/basic/basic-types/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-aef55d32").then(t)}},{path:"/ts/basic/basic-types/index.html",redirect:"/ts/basic/basic-types/"},{path:"/30.web/4.typescript-utility/10.基础/10.basic-types.html",redirect:"/ts/basic/basic-types/"},{name:"v-25439586",path:"/ts/basic/type-manipulation/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-25439586").then(t)}},{path:"/ts/basic/type-manipulation/index.html",redirect:"/ts/basic/type-manipulation/"},{path:"/30.web/4.typescript-utility/10.基础/20.type-manipulation.html",redirect:"/ts/basic/type-manipulation/"},{name:"v-27eebe53",path:"/ts/basic/classes/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-27eebe53").then(t)}},{path:"/ts/basic/classes/index.html",redirect:"/ts/basic/classes/"},{path:"/30.web/4.typescript-utility/10.基础/30.classes.html",redirect:"/ts/basic/classes/"},{name:"v-2080504b",path:"/ts/basic/reference/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2080504b").then(t)}},{path:"/ts/basic/reference/index.html",redirect:"/ts/basic/reference/"},{path:"/30.web/4.typescript-utility/10.基础/40.reference.html",redirect:"/ts/basic/reference/"},{name:"v-057781cb",path:"/ts/basic/type-zoo/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-057781cb").then(t)}},{path:"/ts/basic/type-zoo/index.html",redirect:"/ts/basic/type-zoo/"},{path:"/30.web/4.typescript-utility/10.基础/50.type-zoo.html",redirect:"/ts/basic/type-zoo/"},{name:"v-2af34dca",path:"/ts/utility/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2af34dca").then(t)}},{path:"/ts/utility/index/index.html",redirect:"/ts/utility/index/"},{path:"/30.web/4.typescript-utility/20.类型工具/0.index.html",redirect:"/ts/utility/index/"},{name:"v-f790ca6e",path:"/ts/utility/basic/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-f790ca6e").then(t)}},{path:"/ts/utility/basic/index.html",redirect:"/ts/utility/basic/"},{path:"/30.web/4.typescript-utility/20.类型工具/10.basic.html",redirect:"/ts/utility/basic/"},{name:"v-1061317b",path:"/ts/utility/mapped/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1061317b").then(t)}},{path:"/ts/utility/mapped/index.html",redirect:"/ts/utility/mapped/"},{path:"/30.web/4.typescript-utility/20.类型工具/20.mapped-types.html",redirect:"/ts/utility/mapped/"},{name:"v-1ba4b31b",path:"/single-spa/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1ba4b31b").then(t)}},{path:"/single-spa/index/index.html",redirect:"/single-spa/index/"},{path:"/30.web/5.single-spa源码/0.index.html",redirect:"/single-spa/index/"},{name:"v-6b7f390c",path:"/single-spa/app/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6b7f390c").then(t)}},{path:"/single-spa/app/index/index.html",redirect:"/single-spa/app/index/"},{path:"/30.web/5.single-spa源码/10.app与应用管理/0.index.html",redirect:"/single-spa/app/index/"},{name:"v-3bded94c",path:"/single-spa/app/apps/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3bded94c").then(t)}},{path:"/single-spa/app/apps/index.html",redirect:"/single-spa/app/apps/"},{path:"/30.web/5.single-spa源码/10.app与应用管理/10.apps.html",redirect:"/single-spa/app/apps/"},{name:"v-0b29f556",path:"/single-spa/lifecycle/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0b29f556").then(t)}},{path:"/single-spa/lifecycle/index/index.html",redirect:"/single-spa/lifecycle/index/"},{path:"/30.web/5.single-spa源码/20.lifecycles与生命周期管理/0.index.html",redirect:"/single-spa/lifecycle/index/"},{name:"v-70bd8ed4",path:"/single-spa/lifecycle/load/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-70bd8ed4").then(t)}},{path:"/single-spa/lifecycle/load/index.html",redirect:"/single-spa/lifecycle/load/"},{path:"/30.web/5.single-spa源码/20.lifecycles与生命周期管理/10.load.html",redirect:"/single-spa/lifecycle/load/"},{name:"v-5cc090d4",path:"/single-spa/lifecycle/bootstrap/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5cc090d4").then(t)}},{path:"/single-spa/lifecycle/bootstrap/index.html",redirect:"/single-spa/lifecycle/bootstrap/"},{path:"/30.web/5.single-spa源码/20.lifecycles与生命周期管理/20.bootstrap.html",redirect:"/single-spa/lifecycle/bootstrap/"},{name:"v-4dfd12d8",path:"/single-spa/lifecycle/mount/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4dfd12d8").then(t)}},{path:"/single-spa/lifecycle/mount/index.html",redirect:"/single-spa/lifecycle/mount/"},{path:"/30.web/5.single-spa源码/20.lifecycles与生命周期管理/30.mount.html",redirect:"/single-spa/lifecycle/mount/"},{name:"v-3336f808",path:"/single-spa/lifecycle/update/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3336f808").then(t)}},{path:"/single-spa/lifecycle/update/index.html",redirect:"/single-spa/lifecycle/update/"},{path:"/30.web/5.single-spa源码/20.lifecycles与生命周期管理/40.update.html",redirect:"/single-spa/lifecycle/update/"},{name:"v-3bd3e459",path:"/single-spa/nav/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3bd3e459").then(t)}},{path:"/single-spa/nav/index/index.html",redirect:"/single-spa/nav/index/"},{path:"/30.web/5.single-spa源码/30.navigation与路由管理/0.index.html",redirect:"/single-spa/nav/index/"},{name:"v-3bb59422",path:"/single-spa/nav/events/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3bb59422").then(t)}},{path:"/single-spa/nav/events/index.html",redirect:"/single-spa/nav/events/"},{path:"/30.web/5.single-spa源码/30.navigation与路由管理/10.navigation-events.html",redirect:"/single-spa/nav/events/"},{name:"v-44bace4f",path:"/single-spa/nav/reroute/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-44bace4f").then(t)}},{path:"/single-spa/nav/reroute/index.html",redirect:"/single-spa/nav/reroute/"},{path:"/30.web/5.single-spa源码/30.navigation与路由管理/20.reroute.html",redirect:"/single-spa/nav/reroute/"},{name:"v-73517018",path:"/single-spa/nav/parcel/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-73517018").then(t)}},{path:"/single-spa/nav/parcel/index.html",redirect:"/single-spa/nav/parcel/"},{path:"/30.web/5.single-spa源码/40.parcel组件/0.index.html",redirect:"/single-spa/nav/parcel/"},{name:"v-db70af54",path:"/single-spa/other/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-db70af54").then(t)}},{path:"/single-spa/other/index/index.html",redirect:"/single-spa/other/index/"},{path:"/30.web/5.single-spa源码/50.其他/0.index.html",redirect:"/single-spa/other/index/"},{name:"v-e148fee0",path:"/single-spa/other/customEvent/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-e148fee0").then(t)}},{path:"/single-spa/other/customEvent/index.html",redirect:"/single-spa/other/customEvent/"},{path:"/30.web/5.single-spa源码/50.其他/10.customEvent.html",redirect:"/single-spa/other/customEvent/"},{name:"v-6644dbd4",path:"/single-spa/other/error/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6644dbd4").then(t)}},{path:"/single-spa/other/error/index.html",redirect:"/single-spa/other/error/"},{path:"/30.web/5.single-spa源码/50.其他/20.error.html",redirect:"/single-spa/other/error/"},{name:"v-1bd41a5b",path:"/single-spa/spa-react/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1bd41a5b").then(t)}},{path:"/single-spa/spa-react/index/index.html",redirect:"/single-spa/spa-react/index/"},{path:"/30.web/5.single-spa源码/60.single-spa-react/0.index.html",redirect:"/single-spa/spa-react/index/"},{name:"v-82122182",path:"/jquery/jq-book/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-82122182").then(t)}},{path:"/jquery/jq-book/index.html",redirect:"/jquery/jq-book/"},{path:"/30.web/50.jquery源码/10.jq-book.html",redirect:"/jquery/jq-book/"},{name:"v-1401de91",path:"/jquery/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1401de91").then(t)}},{path:"/jquery/index/index.html",redirect:"/jquery/index/"},{path:"/30.web/50.jquery源码/0.index.html",redirect:"/jquery/index/"},{name:"v-1ff4e09f",path:"/jquery/jq-source/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-1ff4e09f").then(t)}},{path:"/jquery/jq-source/index.html",redirect:"/jquery/jq-source/"},{path:"/30.web/50.jquery源码/20.jq-source.html",redirect:"/jquery/jq-source/"},{name:"v-f54ae5ba",path:"/jquery/extend/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-f54ae5ba").then(t)}},{path:"/jquery/extend/index.html",redirect:"/jquery/extend/"},{path:"/30.web/50.jquery源码/30.extend.html",redirect:"/jquery/extend/"},{name:"v-52bd35e5",path:"/qiankun/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-52bd35e5").then(t)}},{path:"/qiankun/index/index.html",redirect:"/qiankun/index/"},{path:"/30.web/6.qiankun源码/0.index.html",redirect:"/qiankun/index/"},{name:"v-7c668ae7",path:"/qiankun/core/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7c668ae7").then(t)}},{path:"/qiankun/core/index/index.html",redirect:"/qiankun/core/index/"},{path:"/30.web/6.qiankun源码/10.core/0.index.html",redirect:"/qiankun/core/index/"},{name:"v-6e596402",path:"/qiankun/core/apis/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6e596402").then(t)}},{path:"/qiankun/core/apis/index.html",redirect:"/qiankun/core/apis/"},{path:"/30.web/6.qiankun源码/10.core/10.apis.html",redirect:"/qiankun/core/apis/"},{name:"v-263cdfff",path:"/qiankun/core/globalState/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-263cdfff").then(t)}},{path:"/qiankun/core/globalState/index.html",redirect:"/qiankun/core/globalState/"},{path:"/30.web/6.qiankun源码/10.core/50.globalState.html",redirect:"/qiankun/core/globalState/"},{name:"v-6646936e",path:"/qiankun/core/loader/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6646936e").then(t)}},{path:"/qiankun/core/loader/index.html",redirect:"/qiankun/core/loader/"},{path:"/30.web/6.qiankun源码/10.core/20.loader.html",redirect:"/qiankun/core/loader/"},{name:"v-4956ba5f",path:"/qiankun/core/addon/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4956ba5f").then(t)}},{path:"/qiankun/core/addon/index.html",redirect:"/qiankun/core/addon/"},{path:"/30.web/6.qiankun源码/10.core/60.addon.html",redirect:"/qiankun/core/addon/"},{name:"v-a0fcd902",path:"/qiankun/sandbox/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-a0fcd902").then(t)}},{path:"/qiankun/sandbox/index/index.html",redirect:"/qiankun/sandbox/index/"},{path:"/30.web/6.qiankun源码/20.sandbox/0.index.html",redirect:"/qiankun/sandbox/index/"},{name:"v-b7416126",path:"/qiankun/sandbox/sandbox/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-b7416126").then(t)}},{path:"/qiankun/sandbox/sandbox/index.html",redirect:"/qiankun/sandbox/sandbox/"},{path:"/30.web/6.qiankun源码/20.sandbox/10.sandbox.html",redirect:"/qiankun/sandbox/sandbox/"},{name:"v-353fcddf",path:"/qiankun/sandbox/proxySandbox/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-353fcddf").then(t)}},{path:"/qiankun/sandbox/proxySandbox/index.html",redirect:"/qiankun/sandbox/proxySandbox/"},{path:"/30.web/6.qiankun源码/20.sandbox/20.proxySandbox.html",redirect:"/qiankun/sandbox/proxySandbox/"},{name:"v-33490a39",path:"/qiankun/sandbox/snapshotSandbox/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-33490a39").then(t)}},{path:"/qiankun/sandbox/snapshotSandbox/index.html",redirect:"/qiankun/sandbox/snapshotSandbox/"},{path:"/30.web/6.qiankun源码/20.sandbox/30.snapshotSandbox.html",redirect:"/qiankun/sandbox/snapshotSandbox/"},{name:"v-51af4a72",path:"/qiankun/import-html-entry/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-51af4a72").then(t)}},{path:"/qiankun/import-html-entry/index.html",redirect:"/qiankun/import-html-entry/"},{path:"/30.web/6.qiankun源码/999.import-html-entry.html",redirect:"/qiankun/import-html-entry/"},{name:"v-07fff7d7",path:"/pages/ba82e2/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-07fff7d7").then(t)}},{path:"/pages/ba82e2/index.html",redirect:"/pages/ba82e2/"},{path:"/30.web/60.snabbdom/0.index.html",redirect:"/pages/ba82e2/"},{name:"v-725a2703",path:"/pages/cf8075/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-725a2703").then(t)}},{path:"/pages/cf8075/index.html",redirect:"/pages/cf8075/"},{path:"/30.web/60.snabbdom/10.core/10.init.html",redirect:"/pages/cf8075/"},{name:"v-ca971886",path:"/pages/69bbdd/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-ca971886").then(t)}},{path:"/pages/69bbdd/index.html",redirect:"/pages/69bbdd/"},{path:"/30.web/60.snabbdom/10.core/20.h.html",redirect:"/pages/69bbdd/"},{name:"v-6892877d",path:"/pages/fa7d5d/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6892877d").then(t)}},{path:"/pages/fa7d5d/index.html",redirect:"/pages/fa7d5d/"},{path:"/30.web/60.snabbdom/10.core/30.jsx.html",redirect:"/pages/fa7d5d/"},{name:"v-d23fd306",path:"/pages/3f1101/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-d23fd306").then(t)}},{path:"/pages/3f1101/index.html",redirect:"/pages/3f1101/"},{path:"/30.web/60.snabbdom/10.core/40.vnode.html",redirect:"/pages/3f1101/"},{name:"v-210aaa1d",path:"/pages/d02874/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-210aaa1d").then(t)}},{path:"/pages/d02874/index.html",redirect:"/pages/d02874/"},{path:"/30.web/60.snabbdom/10.core/50.thunk.html",redirect:"/pages/d02874/"},{name:"v-377700fe",path:"/pages/903ddd/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-377700fe").then(t)}},{path:"/pages/903ddd/index.html",redirect:"/pages/903ddd/"},{path:"/30.web/60.snabbdom/30.helper/10.attachto.html",redirect:"/pages/903ddd/"},{name:"v-405fbd6a",path:"/webpack/init/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-405fbd6a").then(t)}},{path:"/webpack/init/index.html",redirect:"/webpack/init/"},{path:"/30.web/7.webpack/0.index.html",redirect:"/webpack/init/"},{name:"v-761f238a",path:"/webpack/tapable/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-761f238a").then(t)}},{path:"/webpack/tapable/index/index.html",redirect:"/webpack/tapable/index/"},{path:"/30.web/7.webpack/10.tapable源码/0.index.html",redirect:"/webpack/tapable/index/"},{name:"v-c3847a42",path:"/webpack/tapable/api/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-c3847a42").then(t)}},{path:"/webpack/tapable/api/index.html",redirect:"/webpack/tapable/api/"},{path:"/30.web/7.webpack/10.tapable源码/10.api.html",redirect:"/webpack/tapable/api/"},{name:"v-87d0754a",path:"/webpack/tapable/hook/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-87d0754a").then(t)}},{path:"/webpack/tapable/hook/index.html",redirect:"/webpack/tapable/hook/"},{path:"/30.web/7.webpack/10.tapable源码/20.Hook.html",redirect:"/webpack/tapable/hook/"},{name:"v-2da3183a",path:"/webpack/tapable/factory/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2da3183a").then(t)}},{path:"/webpack/tapable/factory/index.html",redirect:"/webpack/tapable/factory/"},{path:"/30.web/7.webpack/10.tapable源码/30.HookCodeFactory.html",redirect:"/webpack/tapable/factory/"},{name:"v-53a11582",path:"/webpack/summary/dp/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-53a11582").then(t)}},{path:"/webpack/summary/dp/index.html",redirect:"/webpack/summary/dp/"},{path:"/30.web/7.webpack/100.总结/10.dp.html",redirect:"/webpack/summary/dp/"},{name:"v-4c8845fc",path:"/webpack/summary/ds/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4c8845fc").then(t)}},{path:"/webpack/summary/ds/index.html",redirect:"/webpack/summary/ds/"},{path:"/30.web/7.webpack/100.总结/20.ds.html",redirect:"/webpack/summary/ds/"},{name:"v-df747cda",path:"/webpack/init/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-df747cda").then(t)}},{path:"/webpack/init/index/index.html",redirect:"/webpack/init/index/"},{path:"/30.web/7.webpack/20.init阶段/0.index.html",redirect:"/webpack/init/index/"},{name:"v-c36c87c2",path:"/webpack/init/compiler/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-c36c87c2").then(t)}},{path:"/webpack/init/compiler/index.html",redirect:"/webpack/init/compiler/"},{path:"/30.web/7.webpack/20.init阶段/10.compiler.html",redirect:"/webpack/init/compiler/"},{name:"v-397f75f5",path:"/webpack/init/options/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-397f75f5").then(t)}},{path:"/webpack/init/options/index.html",redirect:"/webpack/init/options/"},{path:"/30.web/7.webpack/20.init阶段/20.options.html",redirect:"/webpack/init/options/"},{name:"v-b6310e56",path:"/webpack/make/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-b6310e56").then(t)}},{path:"/webpack/make/index/index.html",redirect:"/webpack/make/index/"},{path:"/30.web/7.webpack/30.make阶段/0.index.html",redirect:"/webpack/make/index/"},{name:"v-0d9c3a15",path:"/webpack/make/compilation/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0d9c3a15").then(t)}},{path:"/webpack/make/compilation/index.html",redirect:"/webpack/make/compilation/"},{path:"/30.web/7.webpack/30.make阶段/10.compilation.html",redirect:"/webpack/make/compilation/"},{name:"v-8da47476",path:"/webpack/make/module/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-8da47476").then(t)}},{path:"/webpack/make/module/index.html",redirect:"/webpack/make/module/"},{path:"/30.web/7.webpack/30.make阶段/20.module.html",redirect:"/webpack/make/module/"},{name:"v-4bc1c689",path:"/webpack/make/walk/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4bc1c689").then(t)}},{path:"/webpack/make/walk/index.html",redirect:"/webpack/make/walk/"},{path:"/30.web/7.webpack/30.make阶段/30.walk.html",redirect:"/webpack/make/walk/"},{name:"v-7b75117d",path:"/pages/08c8a2/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7b75117d").then(t)}},{path:"/pages/08c8a2/index.html",redirect:"/pages/08c8a2/"},{path:"/30.web/70.am-editor/0.index.html",redirect:"/pages/08c8a2/"},{name:"v-10d9c13d",path:"/pages/da29c0/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-10d9c13d").then(t)}},{path:"/pages/da29c0/index.html",redirect:"/pages/da29c0/"},{path:"/30.web/70.am-editor/10.engine/0.index.html",redirect:"/pages/da29c0/"},{name:"v-778f237d",path:"/pages/33f539/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-778f237d").then(t)}},{path:"/pages/33f539/index.html",redirect:"/pages/33f539/"},{path:"/30.web/70.am-editor/10.engine/10.engine-basic.html",redirect:"/pages/33f539/"},{name:"v-5b6dcd7d",path:"/pages/518dfe/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5b6dcd7d").then(t)}},{path:"/pages/518dfe/index.html",redirect:"/pages/518dfe/"},{path:"/30.web/70.am-editor/10.engine/20.engine.html",redirect:"/pages/518dfe/"},{name:"v-42d8aff9",path:"/pages/a35554/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-42d8aff9").then(t)}},{path:"/pages/a35554/index.html",redirect:"/pages/a35554/"},{path:"/30.web/70.am-editor/10.engine/30.container.html",redirect:"/pages/a35554/"},{name:"v-7c8f5906",path:"/pages/53c865/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7c8f5906").then(t)}},{path:"/pages/53c865/index.html",redirect:"/pages/53c865/"},{path:"/30.web/70.am-editor/10.engine/40.change.html",redirect:"/pages/53c865/"},{name:"v-55778605",path:"/pages/7f2a93/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-55778605").then(t)}},{path:"/pages/7f2a93/index.html",redirect:"/pages/7f2a93/"},{path:"/30.web/70.am-editor/10.engine/50.range.html",redirect:"/pages/7f2a93/"},{name:"v-51bac5f7",path:"/axios/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-51bac5f7").then(t)}},{path:"/axios/index/index.html",redirect:"/axios/index/"},{path:"/30.web/8.axios/0.index.html",redirect:"/axios/index/"},{name:"v-f55aa90e",path:"/axios/core/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-f55aa90e").then(t)}},{path:"/axios/core/index/index.html",redirect:"/axios/core/index/"},{path:"/30.web/8.axios/10.core/0.index.html",redirect:"/axios/core/index/"},{name:"v-ea939fc6",path:"/axios/core/instance/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-ea939fc6").then(t)}},{path:"/axios/core/instance/index.html",redirect:"/axios/core/instance/"},{path:"/30.web/8.axios/10.core/10.axios.html",redirect:"/axios/core/instance/"},{name:"v-498b6e86",path:"/axios/core/interceptor/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-498b6e86").then(t)}},{path:"/axios/core/interceptor/index.html",redirect:"/axios/core/interceptor/"},{path:"/30.web/8.axios/10.core/30.interceptor.html",redirect:"/axios/core/interceptor/"},{name:"v-c9eede46",path:"/axios/core/adapter/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-c9eede46").then(t)}},{path:"/axios/core/adapter/index.html",redirect:"/axios/core/adapter/"},{path:"/30.web/8.axios/10.core/20.adapter.html",redirect:"/axios/core/adapter/"},{name:"v-3fcd21c9",path:"/axios/core/cancel/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3fcd21c9").then(t)}},{path:"/axios/core/cancel/index.html",redirect:"/axios/core/cancel/"},{path:"/30.web/8.axios/10.core/40.cancel.html",redirect:"/axios/core/cancel/"},{name:"v-3552c17d",path:"/pages/b58110/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-3552c17d").then(t)}},{path:"/pages/b58110/index.html",redirect:"/pages/b58110/"},{path:"/30.web/80.html2canvas/0.index.html",redirect:"/pages/b58110/"},{name:"v-dca0dbea",path:"/solid/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-dca0dbea").then(t)}},{path:"/solid/index/index.html",redirect:"/solid/index/"},{path:"/30.web/9.solid/0.index.html",redirect:"/solid/index/"},{name:"v-73c1945d",path:"/solid/plan/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-73c1945d").then(t)}},{path:"/solid/plan/index.html",redirect:"/solid/plan/"},{path:"/30.web/9.solid/1.plan.html",redirect:"/solid/plan/"},{name:"v-074761b1",path:"/solid/render/render-by-jsx/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-074761b1").then(t)}},{path:"/solid/render/render-by-jsx/index.html",redirect:"/solid/render/render-by-jsx/"},{path:"/30.web/9.solid/10.渲染/10.render-jsx.html",redirect:"/solid/render/render-by-jsx/"},{name:"v-82075c46",path:"/node/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-82075c46").then(t)}},{path:"/node/index/index.html",redirect:"/node/index/"},{path:"/40.node/0.index.html",redirect:"/node/index/"},{name:"v-cf050632",path:"/node/plan/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-cf050632").then(t)}},{path:"/node/plan/index.html",redirect:"/node/plan/"},{path:"/40.node/1.plan.html",redirect:"/node/plan/"},{name:"v-bebe86c6",path:"/node/roadmap/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-bebe86c6").then(t)}},{path:"/node/roadmap/index.html",redirect:"/node/roadmap/"},{path:"/40.node/2.roadmap.html",redirect:"/node/roadmap/"},{name:"v-4fe65767",path:"/topic/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-4fe65767").then(t)}},{path:"/topic/index/index.html",redirect:"/topic/index/"},{path:"/50.topic/0.index.html",redirect:"/topic/index/"},{name:"v-6fba7546",path:"/topic/js2ts/index/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6fba7546").then(t)}},{path:"/topic/js2ts/index/index.html",redirect:"/topic/js2ts/index/"},{path:"/50.topic/10.fromTs2Js/0.index.html",redirect:"/topic/js2ts/index/"},{name:"v-0790c155",path:"/node/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-0790c155").then(t)}},{path:"/node/index.html",redirect:"/node/"},{path:"/999.目录/20.node.html",redirect:"/node/"},{name:"v-97306cda",path:"/web/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-97306cda").then(t)}},{path:"/web/index.html",redirect:"/web/"},{path:"/999.目录/10.web.html",redirect:"/web/"},{name:"v-6cc4c933",path:"/topic/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6cc4c933").then(t)}},{path:"/topic/index.html",redirect:"/topic/"},{path:"/999.目录/30.topic.html",redirect:"/topic/"},{name:"v-d744eac6",path:"/archives/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-d744eac6").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-2bac39fd",path:"/categories/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2bac39fd").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-39df881d",path:"/tags/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-39df881d").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-75a63fbd",path:"/qa/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-75a63fbd").then(t)}},{path:"/qa/index.html",redirect:"/qa/"},{path:"/Q&A.html",redirect:"/qa/"},{name:"v-2af0da94",path:"/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-2af0da94").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-7d3a31b9",path:"/nav/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-7d3a31b9").then(t)}},{path:"/nav/index.html",redirect:"/nav/"},{path:"/导航站.html",redirect:"/nav/"},{name:"v-d2407716",path:"/about/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-d2407716").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/关于.html",redirect:"/about/"},{name:"v-6196523d",path:"/qiankun/core/prefetch/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-6196523d").then(t)}},{path:"/qiankun/core/prefetch/index.html",redirect:"/qiankun/core/prefetch/"},{path:"/30.web/6.qiankun源码/10.core/40.prefetch.html",redirect:"/qiankun/core/prefetch/"},{name:"v-5d5e22bf",path:"/qiankun/core/effects/",component:tt,beforeEnter:(n,e,t)=>{Object(Gn.a)("Layout","v-5d5e22bf").then(t)}},{path:"/qiankun/core/effects/index.html",redirect:"/qiankun/core/effects/"},{path:"/30.web/6.qiankun源码/10.core/30.effects.html",redirect:"/qiankun/core/effects/"},{path:"*",component:tt}],ot={title:"",description:"",base:"/",headTags:[["link",{rel:"icon",href:"/assets/img/favicon.ico"}],["meta",{name:"referrer",content:"no-referrer-when-downgrade"}],["meta",{name:"apple-mobile-web-app-capable",content:"yes"}],["meta",{name:"apple-mobile-web-app-status-bar-style",content:"black"}],["meta",{name:"keywords",content:"前端源码,React源码,Vue源码,Vu3源码,Webpack源码"}],["meta",{name:"theme-color",content:"#3CB982"}],["link",{rel:"stylesheet",href:"//at.alicdn.com/t/font_3314748_9xij1pv3h4i.css"}]],pages:[{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-14T22:02:21.000Z",permalink:"/react/index/",categories:["react"],tags:[null]},regularPath:"/10.react/0.index.html",relativePath:"10.react/0.index.md",key:"v-376508bf",path:"/react/index/",headers:[{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:154},{level:2,title:"阅读方法",slug:"阅读方法",normalizedTitle:"阅读方法",charIndex:524},{level:2,title:"参考链接",slug:"参考链接",normalizedTitle:"参考链接",charIndex:698}],readingTime:{text:"1 min read",minutes:.495,time:29700,words:99},headersStr:"说明 阅读方法 参考链接",content:"react 源码的阅读是很久之前的一项计划，读这个源码需要花费大量的时间，我主要是在闲暇时间里去完成的。一边阅读，一边做笔记，然后将笔记整理成文档，看到自己能够有一些内容产出，心里还是蛮高兴的。这份笔记的时间跨度很大，而且笔记也在不断的充实和积累。作为一种学习和积淀的过程，对自己来说也是收益颇丰。\n\n\n# 说明\n\n在这里我先要说明一些事项，以作为阅读之前的提醒。\n\n事项          描述\nReact 版本    旧版：v16.8.6，新版：17.0.3\nIDE         VScode\n静态生成器       VuePress\n源码 Repo     https://github.com/jonsam-ng/ReactSourceCodeAnalyze.git\n笔记源码 Repo   https://github.com/jonsam-ng/fe-source-reading\n笔记地址        https://source.jonsam.site\n阅读重点        React 调度、更新的过程，diff 原理，重要的数据结构、hooks 原理等\n阅读方式        运行源码、源码标注、笔记分析总结\n\n\n# 阅读方法\n\n 1. 运行和调试 React 源码。\n\ngit clone https://github.com/jonsam-ng/ReactSourceCodeAnalyze.git \ncd source-code-demo\nyarn \nyarn start\n\n\n1\n2\n3\n4\n\n 2. 按照一定的阅读顺序阅读源码，请先阅读基础部分。\n\n\n# 参考链接\n\n * React 官网\n * React Fiber 初探 -- 熊建刚\n * 7kms/react-illustration-series\n * React 源码阅读系列文章\n * React 源码解析\n * React 技术揭秘",normalizedContent:"react 源码的阅读是很久之前的一项计划，读这个源码需要花费大量的时间，我主要是在闲暇时间里去完成的。一边阅读，一边做笔记，然后将笔记整理成文档，看到自己能够有一些内容产出，心里还是蛮高兴的。这份笔记的时间跨度很大，而且笔记也在不断的充实和积累。作为一种学习和积淀的过程，对自己来说也是收益颇丰。\n\n\n# 说明\n\n在这里我先要说明一些事项，以作为阅读之前的提醒。\n\n事项          描述\nreact 版本    旧版：v16.8.6，新版：17.0.3\nide         vscode\n静态生成器       vuepress\n源码 repo     https://github.com/jonsam-ng/reactsourcecodeanalyze.git\n笔记源码 repo   https://github.com/jonsam-ng/fe-source-reading\n笔记地址        https://source.jonsam.site\n阅读重点        react 调度、更新的过程，diff 原理，重要的数据结构、hooks 原理等\n阅读方式        运行源码、源码标注、笔记分析总结\n\n\n# 阅读方法\n\n 1. 运行和调试 react 源码。\n\ngit clone https://github.com/jonsam-ng/reactsourcecodeanalyze.git \ncd source-code-demo\nyarn \nyarn start\n\n\n1\n2\n3\n4\n\n 2. 按照一定的阅读顺序阅读源码，请先阅读基础部分。\n\n\n# 参考链接\n\n * react 官网\n * react fiber 初探 -- 熊建刚\n * 7kms/react-illustration-series\n * react 源码阅读系列文章\n * react 源码解析\n * react 技术揭秘",charsets:{cjk:!0},lastUpdated:"2022/04/16, 15:48:02",lastUpdatedTimestamp:1650095282e3},{title:"plan 计划",frontmatter:{title:"plan 计划",date:"2022-04-16T15:39:58.000Z",permalink:"/react/plan/",categories:["react"],tags:[null]},regularPath:"/10.react/1.plan.html",relativePath:"10.react/1.plan.md",key:"v-3611955d",path:"/react/plan/",headers:[{level:2,title:"Plan 计划",slug:"plan-计划",normalizedTitle:"plan 计划",charIndex:2},{level:3,title:"Basic",slug:"basic",normalizedTitle:"basic",charIndex:14},{level:3,title:"Reconciliation",slug:"reconciliation",normalizedTitle:"reconciliation",charIndex:66},{level:3,title:"Scheduler",slug:"scheduler",normalizedTitle:"scheduler",charIndex:183},{level:3,title:"Updater",slug:"updater",normalizedTitle:"updater",charIndex:263},{level:3,title:"Render",slug:"render",normalizedTitle:"render",charIndex:275},{level:3,title:"Hooks",slug:"hooks",normalizedTitle:"hooks",charIndex:331},{level:3,title:"Summary",slug:"summary",normalizedTitle:"summary",charIndex:435}],readingTime:{text:"1 min read",minutes:.405,time:24300,words:81},headersStr:"Plan 计划 Basic Reconciliation Scheduler Updater Render Hooks Summary",content:"# Plan 计划\n\n\n# Basic\n\n * [X]React Element\n * [X]React Children\n\n\n# Reconciliation\n\n * [x] fiber 与 reconciliation\n * [x] ReactChildFiber 的创建\n * [x] expirationTime 与优先级\n * [] 调和章节总结\n\n\n# Scheduler\n\n * [] 调度优先级的计算\n * [x] scheduleWork 与任务调度\n * [] 更新队列（UpdateQueue）\n\n\n# Updater\n\n\n# Render\n\n * [] 创建更新\n * [] 调度更新\n * [] 执行更新\n * [] 提交更新\n\n\n# Hooks\n\n * [x]useState\n * [x]useEffect\n * [x]useReducer\n * [x]useRef\n * []useContext\n * FC 与 hook 机制\n\n\n# Summary\n\n * [x] React 总体流程分析\n * [] React 中的数据结构总结\n * [] 新版本中 lanes 在优先级上所做的更改\n * [] 事件优先级\n * [x] 位运算补课\n * [] 带着原理重读 React 官方文档",normalizedContent:"# plan 计划\n\n\n# basic\n\n * [x]react element\n * [x]react children\n\n\n# reconciliation\n\n * [x] fiber 与 reconciliation\n * [x] reactchildfiber 的创建\n * [x] expirationtime 与优先级\n * [] 调和章节总结\n\n\n# scheduler\n\n * [] 调度优先级的计算\n * [x] schedulework 与任务调度\n * [] 更新队列（updatequeue）\n\n\n# updater\n\n\n# render\n\n * [] 创建更新\n * [] 调度更新\n * [] 执行更新\n * [] 提交更新\n\n\n# hooks\n\n * [x]usestate\n * [x]useeffect\n * [x]usereducer\n * [x]useref\n * []usecontext\n * fc 与 hook 机制\n\n\n# summary\n\n * [x] react 总体流程分析\n * [] react 中的数据结构总结\n * [] 新版本中 lanes 在优先级上所做的更改\n * [] 事件优先级\n * [x] 位运算补课\n * [] 带着原理重读 react 官方文档",charsets:{cjk:!0},lastUpdated:"2022/04/16, 15:48:02",lastUpdatedTimestamp:1650095282e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-14T22:02:21.000Z",permalink:"/react/basic/",categories:["react","basic"],tags:[null]},regularPath:"/10.react/10.%E5%9F%BA%E7%A1%80/0.index.html",relativePath:"10.react/10.基础/0.index.md",key:"v-0d7bb8be",path:"/react/basic/",readingTime:{text:"1 min read",minutes:.76,time:45600,words:152},headersStr:null,content:"在 react 包中 React.js 文件中对 React 有如下定义，通过这个定义，我们可以对 React 的核心 API 初步认识。\n\nconst React = {\n  // ReactChildren提供了处理 this.props.children 的工具集，跟旧版本的一样\n  Children: { // 操作ReactChildren的方法。ReactChildren不是数组。模拟数组的一些方法。\n    map,\n    forEach,\n    count,\n    toArray,\n    only,\n  },\n  // 旧版本只有ReactComponent一种\n  // 新版本定义了三种不同类型的组件基类Component，PureComponent ，unstable_AsyncComponent （16.2.0）\n  createRef, // 创建ref用于类组件。\n  Component, // 组件\n  // The difference between them is that React.Component doesn’t implement shouldComponentUpdate(), but React.PureComponent implements it with a shallow prop and state comparison.\n  PureComponent, \n\n  createContext, // 创建 context 用于状态共享和传递，与 useContext 一起使用\n  forwardRef, // ref转发\n  lazy, // 懒导入\n  memo, // 缓存优化\n\n  // Hook API\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useDebugValue,\n  useLayoutEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n\n  Fragment: REACT_FRAGMENT_TYPE,\n  Profiler: REACT_PROFILER_TYPE,\n  StrictMode: REACT_STRICT_MODE_TYPE, // 严格模式\n  Suspense: REACT_SUSPENSE_TYPE, // 与lazy结合使用，指定一个feedback。\n  unstable_SuspenseList: REACT_SUSPENSE_LIST_TYPE,\n  // 生成组件\n  // ! createElement/cloneElement开发环境与产品环境不一样。\n  createElement: __DEV__ ? createElementWithValidation : createElement,\n  cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement,\n  createFactory: __DEV__ ? createFactoryWithValidation : createFactory,\n  isValidElement: isValidElement,\n\n  version: ReactVersion,\n\n  unstable_withSuspenseConfig: withSuspenseConfig,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n其中比较重要的大致为：\n\n * 元素相关：Children、createElement、cloneElement。\n * 组件相关：Component、PureComponent、createRef、Fragment、forwardRef\n * hooks api: useCallback,useContext,useEffect,useImperativeHandle,useDebugValue,useLayoutEffect,useMemo,useReducer,useRef,useState。\n * 优化相关：lazy、memo、Suspense。\n * 其他：createContext。",normalizedContent:"在 react 包中 react.js 文件中对 react 有如下定义，通过这个定义，我们可以对 react 的核心 api 初步认识。\n\nconst react = {\n  // reactchildren提供了处理 this.props.children 的工具集，跟旧版本的一样\n  children: { // 操作reactchildren的方法。reactchildren不是数组。模拟数组的一些方法。\n    map,\n    foreach,\n    count,\n    toarray,\n    only,\n  },\n  // 旧版本只有reactcomponent一种\n  // 新版本定义了三种不同类型的组件基类component，purecomponent ，unstable_asynccomponent （16.2.0）\n  createref, // 创建ref用于类组件。\n  component, // 组件\n  // the difference between them is that react.component doesn’t implement shouldcomponentupdate(), but react.purecomponent implements it with a shallow prop and state comparison.\n  purecomponent, \n\n  createcontext, // 创建 context 用于状态共享和传递，与 usecontext 一起使用\n  forwardref, // ref转发\n  lazy, // 懒导入\n  memo, // 缓存优化\n\n  // hook api\n  usecallback,\n  usecontext,\n  useeffect,\n  useimperativehandle,\n  usedebugvalue,\n  uselayouteffect,\n  usememo,\n  usereducer,\n  useref,\n  usestate,\n\n  fragment: react_fragment_type,\n  profiler: react_profiler_type,\n  strictmode: react_strict_mode_type, // 严格模式\n  suspense: react_suspense_type, // 与lazy结合使用，指定一个feedback。\n  unstable_suspenselist: react_suspense_list_type,\n  // 生成组件\n  // ! createelement/cloneelement开发环境与产品环境不一样。\n  createelement: __dev__ ? createelementwithvalidation : createelement,\n  cloneelement: __dev__ ? cloneelementwithvalidation : cloneelement,\n  createfactory: __dev__ ? createfactorywithvalidation : createfactory,\n  isvalidelement: isvalidelement,\n\n  version: reactversion,\n\n  unstable_withsuspenseconfig: withsuspenseconfig,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n其中比较重要的大致为：\n\n * 元素相关：children、createelement、cloneelement。\n * 组件相关：component、purecomponent、createref、fragment、forwardref\n * hooks api: usecallback,usecontext,useeffect,useimperativehandle,usedebugvalue,uselayouteffect,usememo,usereducer,useref,usestate。\n * 优化相关：lazy、memo、suspense。\n * 其他：createcontext。",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"章节说明",frontmatter:{title:"章节说明",date:"2022-04-14T22:02:21.000Z",permalink:"/react/basic/chapter/",categories:["react","basic"],tags:[null]},regularPath:"/10.react/10.%E5%9F%BA%E7%A1%80/10.chapter.html",relativePath:"10.react/10.基础/10.chapter.md",key:"v-359e682f",path:"/react/basic/chapter/",headers:[{level:2,title:"React 宏观架构图",slug:"react-宏观架构图",normalizedTitle:"react 宏观架构图",charIndex:2},{level:2,title:"开始上手",slug:"开始上手",normalizedTitle:"开始上手",charIndex:114},{level:2,title:"基础",slug:"基础",normalizedTitle:"基础",charIndex:154},{level:3,title:"目标",slug:"目标",normalizedTitle:"目标",charIndex:161},{level:3,title:"文章梗概",slug:"文章梗概",normalizedTitle:"文章梗概",charIndex:274},{level:2,title:"调和（Reconciliation）",slug:"调和-reconciliation",normalizedTitle:"调和（reconciliation）",charIndex:429},{level:3,title:"目标",slug:"目标-2",normalizedTitle:"目标",charIndex:161},{level:3,title:"文章梗概",slug:"文章梗概-2",normalizedTitle:"文章梗概",charIndex:274},{level:3,title:"宏观掌控",slug:"宏观掌控",normalizedTitle:"宏观掌控",charIndex:41},{level:2,title:"调度器（Scheduler）",slug:"调度器-scheduler",normalizedTitle:"调度器（scheduler）",charIndex:645},{level:3,title:"目标",slug:"目标-3",normalizedTitle:"目标",charIndex:161},{level:3,title:"文章梗概",slug:"文章梗概-3",normalizedTitle:"文章梗概",charIndex:274},{level:3,title:"宏观掌控",slug:"宏观掌控-2",normalizedTitle:"宏观掌控",charIndex:41},{level:2,title:"更新器（Updater）",slug:"更新器-updater",normalizedTitle:"更新器（updater）",charIndex:838},{level:3,title:"目标",slug:"目标-4",normalizedTitle:"目标",charIndex:161},{level:3,title:"文章梗概",slug:"文章梗概-4",normalizedTitle:"文章梗概",charIndex:274},{level:3,title:"宏观掌控",slug:"宏观掌控-3",normalizedTitle:"宏观掌控",charIndex:41},{level:2,title:"渲染器（Render）",slug:"渲染器-render",normalizedTitle:"渲染器（render）",charIndex:955},{level:3,title:"目标",slug:"目标-5",normalizedTitle:"目标",charIndex:161},{level:3,title:"文章梗概",slug:"文章梗概-5",normalizedTitle:"文章梗概",charIndex:274},{level:3,title:"宏观掌控",slug:"宏观掌控-4",normalizedTitle:"宏观掌控",charIndex:41},{level:2,title:"更新过程",slug:"更新过程",normalizedTitle:"更新过程",charIndex:1147},{level:3,title:"目标",slug:"目标-6",normalizedTitle:"目标",charIndex:161},{level:3,title:"文章梗概",slug:"文章梗概-6",normalizedTitle:"文章梗概",charIndex:274},{level:3,title:"宏观掌控",slug:"宏观掌控-5",normalizedTitle:"宏观掌控",charIndex:41},{level:2,title:"hooks 原理",slug:"hooks-原理",normalizedTitle:"hooks 原理",charIndex:1301},{level:3,title:"目标",slug:"目标-7",normalizedTitle:"目标",charIndex:161},{level:3,title:"文章梗概",slug:"文章梗概-7",normalizedTitle:"文章梗概",charIndex:274},{level:3,title:"宏观掌控",slug:"宏观掌控-6",normalizedTitle:"宏观掌控",charIndex:41},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1458}],readingTime:{text:"1 min read",minutes:.95,time:57e3,words:190},headersStr:"React 宏观架构图 开始上手 基础 目标 文章梗概 调和（Reconciliation） 目标 文章梗概 宏观掌控 调度器（Scheduler） 目标 文章梗概 宏观掌控 更新器（Updater） 目标 文章梗概 宏观掌控 渲染器（Render） 目标 文章梗概 宏观掌控 更新过程 目标 文章梗概 宏观掌控 hooks 原理 目标 文章梗概 宏观掌控 总结",content:"# React 宏观架构图\n\n现附上 react 各模块之间的架构图，下文中各章节宏观掌控部分将会详细说明当前章节在此图中的位置，方便我们总体把握源码阅读的脉络。\n\n详细宏观架构上的解读请参考：React 核心包结构；\n\n\n# 开始上手\n\n阅读前需要知晓的阅读说明、阅读方法、更新计划和参考文档等。\n\n\n# 基础\n\n\n# 目标\n\n * 了解每个章节目录的主要内容，以及该内容在整个 react 宏观层面中所处的位置。\n * 学习 react 中的基础内容和基础概念，大部分处于应用层的分析。\n * 这部分源码主要集中在 react 包中。\n\n\n# 文章梗概\n\n * ReactElement：react 中 jsx 语法的解析以及 react 元素的构建和常用 ReactElement 相关的 API。\n * ReactChildren：属于 ReactElement 的扩展，讲解 ReactChildren 的常用 API 的源码和实现原理。\n\n\n# 调和（Reconciliation）\n\n\n# 目标\n\n * 学习调和器在协同调度器、更新器、渲染器工作的作用和原理。\n * 学习 Fiber 在调和器中发挥的重要作用。\n\n\n# 文章梗概\n\n * fiber 与 Reconciliation：Fiber 的理解和 Fiber 在调和器中发挥的作用。\n\n\n# 宏观掌控\n\n * 对应上图中黄色区域的内容。\n * 这一章节的源码主要在 react-reconciler 包中。\n\n\n# 调度器（Scheduler）\n\n\n# 目标\n\n * 学习调度器创建、调度任务和执行回调的原理。\n\n\n# 文章梗概\n\n * scheduleWork 与任务调度：学习调和器和调度器协同工作实现渲染任务调度的原理。\n\n\n# 宏观掌控\n\n * 对应上图中黄色区域的下半部分和蓝色区域。\n * 这部分的代码主要集中在 react-reconciler 包和 scheduler 包中。\n\n\n# 更新器（Updater）\n\n\n# 目标\n\n * 学习组件层面的更新和渲染时如何实现的。\n\n\n# 文章梗概\n\n\n# 宏观掌控\n\n * 对应上图中深黄色区域。\n * 这部分源码主要集中在 react-reconciler 包中。\n\n\n# 渲染器（Render）\n\n\n# 目标\n\n * 学习 FiberTree 转换到 DomTree 的过程原理。\n * 学习 react 渲染的 diff 原理以及其他优化相关。\n\n\n# 文章梗概\n\n * ReactDOM.render 方法：render 方法是如何创建更新的。\n\n\n# 宏观掌控\n\n * 对应上图中灰色区域。\n * 这部分的代码在 react-dom 包中。\n\n\n# 更新过程\n\n\n# 目标\n\n * 学习从输入到输出的 react 更新过程。\n\n\n# 文章梗概\n\n\n# 宏观掌控\n\n * 黄色区域中从信息输入端到信息输出端的更新流程，包括创建更新、执行更新、提交更新几个部分。\n * 这部分源码主要集中在 react-reconciler、react-dom 包中。\n\n\n# hooks 原理\n\n\n# 目标\n\n * 学习 hooks Api 的使用原理。\n\n\n# 文章梗概\n\n * useState：useState 创建更新的原理。\n * useEffect：useEffect 的原理解析。\n\n\n# 宏观掌控\n\n * 这部分属于应用层，这部分源码主要集中在 react 包中。\n\n\n# 总结\n\n * 对前文的学习过程进行总结和归纳。",normalizedContent:"# react 宏观架构图\n\n现附上 react 各模块之间的架构图，下文中各章节宏观掌控部分将会详细说明当前章节在此图中的位置，方便我们总体把握源码阅读的脉络。\n\n详细宏观架构上的解读请参考：react 核心包结构；\n\n\n# 开始上手\n\n阅读前需要知晓的阅读说明、阅读方法、更新计划和参考文档等。\n\n\n# 基础\n\n\n# 目标\n\n * 了解每个章节目录的主要内容，以及该内容在整个 react 宏观层面中所处的位置。\n * 学习 react 中的基础内容和基础概念，大部分处于应用层的分析。\n * 这部分源码主要集中在 react 包中。\n\n\n# 文章梗概\n\n * reactelement：react 中 jsx 语法的解析以及 react 元素的构建和常用 reactelement 相关的 api。\n * reactchildren：属于 reactelement 的扩展，讲解 reactchildren 的常用 api 的源码和实现原理。\n\n\n# 调和（reconciliation）\n\n\n# 目标\n\n * 学习调和器在协同调度器、更新器、渲染器工作的作用和原理。\n * 学习 fiber 在调和器中发挥的重要作用。\n\n\n# 文章梗概\n\n * fiber 与 reconciliation：fiber 的理解和 fiber 在调和器中发挥的作用。\n\n\n# 宏观掌控\n\n * 对应上图中黄色区域的内容。\n * 这一章节的源码主要在 react-reconciler 包中。\n\n\n# 调度器（scheduler）\n\n\n# 目标\n\n * 学习调度器创建、调度任务和执行回调的原理。\n\n\n# 文章梗概\n\n * schedulework 与任务调度：学习调和器和调度器协同工作实现渲染任务调度的原理。\n\n\n# 宏观掌控\n\n * 对应上图中黄色区域的下半部分和蓝色区域。\n * 这部分的代码主要集中在 react-reconciler 包和 scheduler 包中。\n\n\n# 更新器（updater）\n\n\n# 目标\n\n * 学习组件层面的更新和渲染时如何实现的。\n\n\n# 文章梗概\n\n\n# 宏观掌控\n\n * 对应上图中深黄色区域。\n * 这部分源码主要集中在 react-reconciler 包中。\n\n\n# 渲染器（render）\n\n\n# 目标\n\n * 学习 fibertree 转换到 domtree 的过程原理。\n * 学习 react 渲染的 diff 原理以及其他优化相关。\n\n\n# 文章梗概\n\n * reactdom.render 方法：render 方法是如何创建更新的。\n\n\n# 宏观掌控\n\n * 对应上图中灰色区域。\n * 这部分的代码在 react-dom 包中。\n\n\n# 更新过程\n\n\n# 目标\n\n * 学习从输入到输出的 react 更新过程。\n\n\n# 文章梗概\n\n\n# 宏观掌控\n\n * 黄色区域中从信息输入端到信息输出端的更新流程，包括创建更新、执行更新、提交更新几个部分。\n * 这部分源码主要集中在 react-reconciler、react-dom 包中。\n\n\n# hooks 原理\n\n\n# 目标\n\n * 学习 hooks api 的使用原理。\n\n\n# 文章梗概\n\n * usestate：usestate 创建更新的原理。\n * useeffect：useeffect 的原理解析。\n\n\n# 宏观掌控\n\n * 这部分属于应用层，这部分源码主要集中在 react 包中。\n\n\n# 总结\n\n * 对前文的学习过程进行总结和归纳。",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"F&Q",frontmatter:{title:"F&Q",date:"2022-04-14T22:02:21.000Z",permalink:"/react/basic/faq/",categories:["react","basic"],tags:[null]},regularPath:"/10.react/10.%E5%9F%BA%E7%A1%80/20.faq.html",relativePath:"10.react/10.基础/20.faq.md",key:"v-a1dbc2a2",path:"/react/basic/faq/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"如何更高效的搜索 React 源码仓库？",slug:"如何更高效的搜索-react-源码仓库",normalizedTitle:"如何更高效的搜索 react 源码仓库？",charIndex:17}],readingTime:{text:"1 min read",minutes:.14,time:8400,words:28},headersStr:"目录 如何更高效的搜索 React 源码仓库？",content:"# 目录\n\n\n\n * 目录\n * 如何更高效的搜索 React 源码仓库？\n\n\n\n\n# 如何更高效的搜索 React 源码仓库？\n\n在 vscode 搜索栏添加如下选项：\n\nfiles to include: src/react/packages/\nfiles to exclude: *test*.js,*.coffee,*test.ts,*.d.ts,*.md,*.snap,*.old.js,*.min.js,*.umd.js,*.development.js,__tests__\n\n\n1\n2\n\n\n如图：",normalizedContent:"# 目录\n\n\n\n * 目录\n * 如何更高效的搜索 react 源码仓库？\n\n\n\n\n# 如何更高效的搜索 react 源码仓库？\n\n在 vscode 搜索栏添加如下选项：\n\nfiles to include: src/react/packages/\nfiles to exclude: *test*.js,*.coffee,*test.ts,*.d.ts,*.md,*.snap,*.old.js,*.min.js,*.umd.js,*.development.js,__tests__\n\n\n1\n2\n\n\n如图：",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"ReactChildren",frontmatter:{title:"ReactChildren",date:"2022-04-14T22:02:21.000Z",permalink:"/react/basic/children/",categories:["react","basic"],tags:[null]},regularPath:"/10.react/10.%E5%9F%BA%E7%A1%80/30.ReactChildren.html",relativePath:"10.react/10.基础/30.ReactChildren.md",key:"v-406c3962",path:"/react/basic/children/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"map",slug:"map",normalizedTitle:"map",charIndex:17},{level:3,title:"traverseContext",slug:"traversecontext",normalizedTitle:"traversecontext",charIndex:26},{level:3,title:"traverseAllChildren",slug:"traverseallchildren",normalizedTitle:"traverseallchildren",charIndex:47},{level:4,title:"mapSingleChildIntoContext",slug:"mapsinglechildintocontext",normalizedTitle:"mapsinglechildintocontext",charIndex:1018},{level:3,title:"ChildrenKey 的维护",slug:"childrenkey-的维护",normalizedTitle:"childrenkey 的维护",charIndex:72},{level:2,title:"forEach",slug:"foreach",normalizedTitle:"foreach",charIndex:91},{level:2,title:"count",slug:"count",normalizedTitle:"count",charIndex:102},{level:2,title:"toArray",slug:"toarray",normalizedTitle:"toarray",charIndex:111},{level:2,title:"only",slug:"only",normalizedTitle:"only",charIndex:122}],readingTime:{text:"6 min read",minutes:5.075,time:304500,words:1015},headersStr:"目录 map traverseContext traverseAllChildren mapSingleChildIntoContext ChildrenKey 的维护 forEach count toArray only",content:"# 目录\n\n\n\n * 目录\n * map\n   * traverseContext\n   * traverseAllChildren\n   * ChildrenKey 的维护\n * forEach\n * count\n * toArray\n * only\n\n\n\nReact Children 有如下四个方法：\n\n// 操作ReactChildren的方法。ReactChildren不是数组。模拟数组的一些方法。\n{ \n  map,\n  forEach,\n  count,\n  toArray,\n  only,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# map\n\nmap 内部调用 mapChildren 方法。\n\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n  const result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这个 mapIntoWithKeyPrefixInternal 很有意思，我们来看看。\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  let escapedPrefix = '';\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n  // 从缓存池中获取 traverseContext，此时并没有加入 traverseContextPool\n  const traverseContext = getPooledTraverseContext(\n    array,\n    escapedPrefix,\n    func,\n    context,\n  );\n  // 遍历 children 执行回调，并且将结果加入到 mapResult。\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  // 释放当前遍历的traverseContext。\n  releaseTraverseContext(traverseContext);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 这里使用了 traverseContext 的缓存池，目的是避免大量的创建对象耗费内存。\n * traverseAllChildren 这里将 mapSingleChildIntoContext 抽离出来，便于复用。\n * traverseContextPool 里只存未使用的空的 traverseContext，在 releaseTraverseContext 中加入缓存池。\n\n\n# traverseContext\n\n从缓存池中获取 context：\n\n// 遍历环境缓存池\nconst POOL_SIZE = 10;\nconst traverseContextPool = [];\nfunction getPooledTraverseContext(\n  mapResult, // 遍历结果数组\n  keyPrefix, // traverseContext 的 key\n  mapFunction, // 遍历回调函数\n  mapContext, // 遍历的 context\n) {\n  // 如果当前缓存池非空\n  if (traverseContextPool.length) {\n    // 取出队尾的traverseContext\n    const traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    // 返回修改后的 traverseContext\n    return traverseContext;\n  } else {\n    // 缓存池为空则新建一个 traverseContext，最多 10 个\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0,\n    };\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n释放 context 到缓存池：\n\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 这种写法在需要频繁创建对象的场景中可以参考。缓存池大小 POOL_SIZE 需要权衡考虑效率和内存问题。如果 POOL_SIZE 太小，就不能很好的起到缓存的效果，如果太大缓存池本身就需要占用太多内存，而且用不完的 context 对象也容易造成浪费和低效。\n\n\n# traverseAllChildren\n\ntraverseAllChildren 内部由 traverseAllChildrenImpl 实现，主要作用是遍历目标 children，调用 callback，维护 children 的 key 值。\n\n// 返回子代数量\nfunction traverseAllChildrenImpl(\n  children, // 遍历目标\n  nameSoFar,\n  callback, // mapSingleChildIntoContext 内部的遍历回调器\n  traverseContext,\n) {\n  const type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  // 为 true 表示不需要进一步处理，可以直接 callback。(null,string,number,Element,Portal)。\n  // 因为只有一个元素，只 callback 一次。\n  let invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n    }\n  }\n\n  if (invokeCallback) {\n    callback(\n      traverseContext,\n      children,\n      // If it's the only child, treat the name as if it was wrapped in an array\n      // so that it's consistent if the number of children grows.\n      // nameSoFar 初始化，children 不是数组，获取 key 值\n      nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar,\n    );\n    return 1;\n  }\n\n  let child;\n  let nextName;\n  let subtreeCount = 0; // Count of children found in the current subtree.\n  // 如：.j:\n  const nextNamePrefix =\n    nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(\n        child,\n        nextName,\n        callback,\n        traverseContext,\n      );\n    }\n  } else {\n    // 针对不是数组但内部实现了迭代器的 children。\n    const iteratorFn = getIteratorFn(children);\n    if (typeof iteratorFn === 'function') {\n      const iterator = iteratorFn.call(children);\n      let step;\n      let ii = 0;\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getComponentKey(child, ii++);\n        subtreeCount += traverseAllChildrenImpl(\n          child,\n          nextName,\n          callback,\n          traverseContext,\n        );\n      }\n    } else if (type === 'object') {\n      // 如果传入 children 是对象，则报错。\n      let addendum = '';\n      if (__DEV__) {\n        addendum =\n          ' If you meant to render a collection of children, use an array ' +\n          'instead.' +\n          ReactDebugCurrentFrame.getStackAddendum();\n      }\n      const childrenString = '' + children;\n      invariant(\n        false,\n        'Objects are not valid as a React child (found: %s).%s',\n        childrenString === '[object Object]'\n          ? 'object with keys {' + Object.keys(children).join(', ') + '}'\n          : childrenString,\n        addendum,\n      );\n    }\n  }\n\n  return subtreeCount;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n\n * traverseAllChildrenImpl 如果发现 children 是数组则会递归遍历，最终将 children 展平（包括多为数组），执行 callback。 traverseAllChildrenImpl 只回调 children 的叶子节点。\n\n# mapSingleChildIntoContext\n\nmap 所使用的 contextMap 是 mapSingleChildIntoContext，这里才真正调用用户传入的回调，并且返回处理后的节点。\n\nfunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\n  const {result, keyPrefix, func, context} = bookKeeping;\n\n  // 调用用户的回调函数\n  let mappedChild = func.call(context, child, bookKeeping.count++);\n  if (Array.isArray(mappedChild)) {\n    // 如果返回了数组，继续进行 map\n    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c => c);\n  } else if (mappedChild != null) {\n    // 是否是 ReactElement\n    if (isValidElement(mappedChild)) {\n      // 处理mappedChild的 key 值\n      mappedChild = cloneAndReplaceKey(\n        mappedChild,\n        // Keep both the (mapped) and old keys if they differ, just as\n        // traverseAllChildren used to do for objects as children\n        keyPrefix +\n          (mappedChild.key && (!child || child.key !== mappedChild.key)\n            ? escapeUserProvidedKey(mappedChild.key) + '/'\n            : '') +\n          childKey,\n      );\n    }\n    // 加入result数组\n    result.push(mappedChild);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * 这里在回调时，如果用户传回来的还是数组，就继续 map ，只有 用户回调的不是数组且为合法的 ReactElement 时，才会被放入 result 中。result 是 map 的返回值。\n\n\n# ChildrenKey 的维护\n\nkey 所使用的分隔符：\n\nconst SEPARATOR = '.';\nconst SUBSEPARATOR = ':';\n\n\n1\n2\n\n\n生成 key 值的算法：\n\nfunction getComponentKey(component, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  // 如果组件有 key 值则使用\n  if (\n    typeof component === 'object' &&\n    component !== null &&\n    component.key != null\n  ) {\n    // Explicit key\n    return escape(component.key);\n  }\n  // Implicit key determined by the index in the set\n  // 使用 36 进制，即 0-9-a-z。(35).toString(36) === 'z'。\n  return index.toString(36);\n}\n\nfunction escape(key) {\n  const escapeRegex = /[=:]/g;\n  const escaperLookup = {\n    '=': '=0',\n    ':': '=2',\n  };\n  const escapedString = ('' + key).replace(escapeRegex, function(match) {\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n * 因为 key 中使用了固定的分隔符，所以用户传递的 key 需要 escape 做等意替换，并且添加前缀 $ 。\n\nkey 值的命名方法：\n\n.key => .key:key1 => .key:key1:key2 ...\n\n\n1\n\n\n\n# forEach\n\nforEach 内部由 forEachChildren 实现。代码如下：\n\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  if (children == null) {\n    return children;\n  }\n  const traverseContext = getPooledTraverseContext(\n    null,\n    null,\n    forEachFunc,\n    forEachContext,\n  );\n  traverseAllChildren(children, forEachSingleChild, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n由此可见：\n\n * forEach 相比于 mapIntoWithKeyPrefixInternal，只是 contextMap 修改成了 forEachSingleChild ，其他代码并未变化。\n * forEach 和 map 的区别是：forEach 没有返回值；不接受用户回调的结果。\n\nforEachSingleChild 的处理也很简单，只是调用了回调：\n\nfunction forEachSingleChild(bookKeeping, child, name) {\n  const {func, context} = bookKeeping;\n  func.call(context, child, bookKeeping.count++);\n}\n\n\n1\n2\n3\n4\n\n\n\n# count\n\ncount 内部由 countChildren 实现，主要作用是返回拉平后的 children 的叶子节点的数量。\n\nfunction countChildren(children) {\n  return traverseAllChildren(children, () => null, null);\n}\n\n\n1\n2\n3\n\n\n\n# toArray\n\ntoArray 将 children 以数组形式返回。这里内部不需要执行回调，因此 contextMap 为 null，\n\nfunction toArray(children) {\n  const result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, child => child);\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# only\n\nonly 内部由 onlyChild 实现。only 验证 children 是否是单节点，并将之返回。代码如下：\n\nfunction onlyChild(children) {\n  invariant(\n    isValidElement(children),\n    'React.Children.only expected to receive a single React element child.',\n  );\n  return children;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n",normalizedContent:"# 目录\n\n\n\n * 目录\n * map\n   * traversecontext\n   * traverseallchildren\n   * childrenkey 的维护\n * foreach\n * count\n * toarray\n * only\n\n\n\nreact children 有如下四个方法：\n\n// 操作reactchildren的方法。reactchildren不是数组。模拟数组的一些方法。\n{ \n  map,\n  foreach,\n  count,\n  toarray,\n  only,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# map\n\nmap 内部调用 mapchildren 方法。\n\nfunction mapchildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n  const result = [];\n  mapintowithkeyprefixinternal(children, result, null, func, context);\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这个 mapintowithkeyprefixinternal 很有意思，我们来看看。\n\nfunction mapintowithkeyprefixinternal(children, array, prefix, func, context) {\n  let escapedprefix = '';\n  if (prefix != null) {\n    escapedprefix = escapeuserprovidedkey(prefix) + '/';\n  }\n  // 从缓存池中获取 traversecontext，此时并没有加入 traversecontextpool\n  const traversecontext = getpooledtraversecontext(\n    array,\n    escapedprefix,\n    func,\n    context,\n  );\n  // 遍历 children 执行回调，并且将结果加入到 mapresult。\n  traverseallchildren(children, mapsinglechildintocontext, traversecontext);\n  // 释放当前遍历的traversecontext。\n  releasetraversecontext(traversecontext);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 这里使用了 traversecontext 的缓存池，目的是避免大量的创建对象耗费内存。\n * traverseallchildren 这里将 mapsinglechildintocontext 抽离出来，便于复用。\n * traversecontextpool 里只存未使用的空的 traversecontext，在 releasetraversecontext 中加入缓存池。\n\n\n# traversecontext\n\n从缓存池中获取 context：\n\n// 遍历环境缓存池\nconst pool_size = 10;\nconst traversecontextpool = [];\nfunction getpooledtraversecontext(\n  mapresult, // 遍历结果数组\n  keyprefix, // traversecontext 的 key\n  mapfunction, // 遍历回调函数\n  mapcontext, // 遍历的 context\n) {\n  // 如果当前缓存池非空\n  if (traversecontextpool.length) {\n    // 取出队尾的traversecontext\n    const traversecontext = traversecontextpool.pop();\n    traversecontext.result = mapresult;\n    traversecontext.keyprefix = keyprefix;\n    traversecontext.func = mapfunction;\n    traversecontext.context = mapcontext;\n    traversecontext.count = 0;\n    // 返回修改后的 traversecontext\n    return traversecontext;\n  } else {\n    // 缓存池为空则新建一个 traversecontext，最多 10 个\n    return {\n      result: mapresult,\n      keyprefix: keyprefix,\n      func: mapfunction,\n      context: mapcontext,\n      count: 0,\n    };\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n释放 context 到缓存池：\n\nfunction releasetraversecontext(traversecontext) {\n  traversecontext.result = null;\n  traversecontext.keyprefix = null;\n  traversecontext.func = null;\n  traversecontext.context = null;\n  traversecontext.count = 0;\n  if (traversecontextpool.length < pool_size) {\n    traversecontextpool.push(traversecontext);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 这种写法在需要频繁创建对象的场景中可以参考。缓存池大小 pool_size 需要权衡考虑效率和内存问题。如果 pool_size 太小，就不能很好的起到缓存的效果，如果太大缓存池本身就需要占用太多内存，而且用不完的 context 对象也容易造成浪费和低效。\n\n\n# traverseallchildren\n\ntraverseallchildren 内部由 traverseallchildrenimpl 实现，主要作用是遍历目标 children，调用 callback，维护 children 的 key 值。\n\n// 返回子代数量\nfunction traverseallchildrenimpl(\n  children, // 遍历目标\n  namesofar,\n  callback, // mapsinglechildintocontext 内部的遍历回调器\n  traversecontext,\n) {\n  const type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // all of the above are perceived as null.\n    children = null;\n  }\n\n  // 为 true 表示不需要进一步处理，可以直接 callback。(null,string,number,element,portal)。\n  // 因为只有一个元素，只 callback 一次。\n  let invokecallback = false;\n\n  if (children === null) {\n    invokecallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokecallback = true;\n        break;\n      case 'object':\n        switch (children.$$typeof) {\n          case react_element_type:\n          case react_portal_type:\n            invokecallback = true;\n        }\n    }\n  }\n\n  if (invokecallback) {\n    callback(\n      traversecontext,\n      children,\n      // if it's the only child, treat the name as if it was wrapped in an array\n      // so that it's consistent if the number of children grows.\n      // namesofar 初始化，children 不是数组，获取 key 值\n      namesofar === '' ? separator + getcomponentkey(children, 0) : namesofar,\n    );\n    return 1;\n  }\n\n  let child;\n  let nextname;\n  let subtreecount = 0; // count of children found in the current subtree.\n  // 如：.j:\n  const nextnameprefix =\n    namesofar === '' ? separator : namesofar + subseparator;\n\n  if (array.isarray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      child = children[i];\n      nextname = nextnameprefix + getcomponentkey(child, i);\n      subtreecount += traverseallchildrenimpl(\n        child,\n        nextname,\n        callback,\n        traversecontext,\n      );\n    }\n  } else {\n    // 针对不是数组但内部实现了迭代器的 children。\n    const iteratorfn = getiteratorfn(children);\n    if (typeof iteratorfn === 'function') {\n      const iterator = iteratorfn.call(children);\n      let step;\n      let ii = 0;\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextname = nextnameprefix + getcomponentkey(child, ii++);\n        subtreecount += traverseallchildrenimpl(\n          child,\n          nextname,\n          callback,\n          traversecontext,\n        );\n      }\n    } else if (type === 'object') {\n      // 如果传入 children 是对象，则报错。\n      let addendum = '';\n      if (__dev__) {\n        addendum =\n          ' if you meant to render a collection of children, use an array ' +\n          'instead.' +\n          reactdebugcurrentframe.getstackaddendum();\n      }\n      const childrenstring = '' + children;\n      invariant(\n        false,\n        'objects are not valid as a react child (found: %s).%s',\n        childrenstring === '[object object]'\n          ? 'object with keys {' + object.keys(children).join(', ') + '}'\n          : childrenstring,\n        addendum,\n      );\n    }\n  }\n\n  return subtreecount;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n\n * traverseallchildrenimpl 如果发现 children 是数组则会递归遍历，最终将 children 展平（包括多为数组），执行 callback。 traverseallchildrenimpl 只回调 children 的叶子节点。\n\n# mapsinglechildintocontext\n\nmap 所使用的 contextmap 是 mapsinglechildintocontext，这里才真正调用用户传入的回调，并且返回处理后的节点。\n\nfunction mapsinglechildintocontext(bookkeeping, child, childkey) {\n  const {result, keyprefix, func, context} = bookkeeping;\n\n  // 调用用户的回调函数\n  let mappedchild = func.call(context, child, bookkeeping.count++);\n  if (array.isarray(mappedchild)) {\n    // 如果返回了数组，继续进行 map\n    mapintowithkeyprefixinternal(mappedchild, result, childkey, c => c);\n  } else if (mappedchild != null) {\n    // 是否是 reactelement\n    if (isvalidelement(mappedchild)) {\n      // 处理mappedchild的 key 值\n      mappedchild = cloneandreplacekey(\n        mappedchild,\n        // keep both the (mapped) and old keys if they differ, just as\n        // traverseallchildren used to do for objects as children\n        keyprefix +\n          (mappedchild.key && (!child || child.key !== mappedchild.key)\n            ? escapeuserprovidedkey(mappedchild.key) + '/'\n            : '') +\n          childkey,\n      );\n    }\n    // 加入result数组\n    result.push(mappedchild);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * 这里在回调时，如果用户传回来的还是数组，就继续 map ，只有 用户回调的不是数组且为合法的 reactelement 时，才会被放入 result 中。result 是 map 的返回值。\n\n\n# childrenkey 的维护\n\nkey 所使用的分隔符：\n\nconst separator = '.';\nconst subseparator = ':';\n\n\n1\n2\n\n\n生成 key 值的算法：\n\nfunction getcomponentkey(component, index) {\n  // do some typechecking here since we call this blindly. we want to ensure\n  // that we don't block potential future es apis.\n  // 如果组件有 key 值则使用\n  if (\n    typeof component === 'object' &&\n    component !== null &&\n    component.key != null\n  ) {\n    // explicit key\n    return escape(component.key);\n  }\n  // implicit key determined by the index in the set\n  // 使用 36 进制，即 0-9-a-z。(35).tostring(36) === 'z'。\n  return index.tostring(36);\n}\n\nfunction escape(key) {\n  const escaperegex = /[=:]/g;\n  const escaperlookup = {\n    '=': '=0',\n    ':': '=2',\n  };\n  const escapedstring = ('' + key).replace(escaperegex, function(match) {\n    return escaperlookup[match];\n  });\n\n  return '$' + escapedstring;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n * 因为 key 中使用了固定的分隔符，所以用户传递的 key 需要 escape 做等意替换，并且添加前缀 $ 。\n\nkey 值的命名方法：\n\n.key => .key:key1 => .key:key1:key2 ...\n\n\n1\n\n\n\n# foreach\n\nforeach 内部由 foreachchildren 实现。代码如下：\n\nfunction foreachchildren(children, foreachfunc, foreachcontext) {\n  if (children == null) {\n    return children;\n  }\n  const traversecontext = getpooledtraversecontext(\n    null,\n    null,\n    foreachfunc,\n    foreachcontext,\n  );\n  traverseallchildren(children, foreachsinglechild, traversecontext);\n  releasetraversecontext(traversecontext);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n由此可见：\n\n * foreach 相比于 mapintowithkeyprefixinternal，只是 contextmap 修改成了 foreachsinglechild ，其他代码并未变化。\n * foreach 和 map 的区别是：foreach 没有返回值；不接受用户回调的结果。\n\nforeachsinglechild 的处理也很简单，只是调用了回调：\n\nfunction foreachsinglechild(bookkeeping, child, name) {\n  const {func, context} = bookkeeping;\n  func.call(context, child, bookkeeping.count++);\n}\n\n\n1\n2\n3\n4\n\n\n\n# count\n\ncount 内部由 countchildren 实现，主要作用是返回拉平后的 children 的叶子节点的数量。\n\nfunction countchildren(children) {\n  return traverseallchildren(children, () => null, null);\n}\n\n\n1\n2\n3\n\n\n\n# toarray\n\ntoarray 将 children 以数组形式返回。这里内部不需要执行回调，因此 contextmap 为 null，\n\nfunction toarray(children) {\n  const result = [];\n  mapintowithkeyprefixinternal(children, result, null, child => child);\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# only\n\nonly 内部由 onlychild 实现。only 验证 children 是否是单节点，并将之返回。代码如下：\n\nfunction onlychild(children) {\n  invariant(\n    isvalidelement(children),\n    'react.children.only expected to receive a single react element child.',\n  );\n  return children;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"ReactElement",frontmatter:{title:"ReactElement",date:"2022-04-14T22:02:21.000Z",permalink:"/react/basic/element/",categories:["react","basic"],tags:[null]},regularPath:"/10.react/10.%E5%9F%BA%E7%A1%80/40.ReactElement.html",relativePath:"10.react/10.基础/40.ReactElement.md",key:"v-4b4b48ab",path:"/react/basic/element/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"JSX",slug:"jsx",normalizedTitle:"jsx",charIndex:17},{level:2,title:"ReactElement",slug:"reactelement",normalizedTitle:"reactelement",charIndex:24},{level:3,title:"createElement",slug:"createelement",normalizedTitle:"createelement",charIndex:42},{level:3,title:"isValidElement",slug:"isvalidelement",normalizedTitle:"isvalidelement",charIndex:61},{level:3,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:81}],readingTime:{text:"3 min read",minutes:2.995,time:179700.00000000003,words:599},headersStr:"目录 JSX ReactElement createElement isValidElement 小结",content:'# 目录\n\n\n\n * 目录\n * JSX\n * ReactElement\n   * createElement\n   * isValidElement\n   * 小结\n\n\n\n\n# JSX\n\n * JSX 是一种将 JS 和 HTML 混合写的语法糖，需要通过 babel 解析之后浏览器才能识别。\n * JSX 语法可以通过 @babel/plugin-transform-react-jsx-source 插件进行解析。\n\n例如如下代码：\n\nconst Con = () => {\n\treturn (\n    <div style={{color: \'#ffffff\'}}>\n      <p class="title">react</p>\n      <span class="detail">reading</span>\n    </div>\n    )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n将会被解析为：\n\nconst Con = () => {\n  return /*#__PURE__*/React.createElement("div", {\n    style: {\n      color: \'#ffffff\'\n    }\n  }, /*#__PURE__*/React.createElement("p", {\n    class: "title"\n  }, "react"), /*#__PURE__*/React.createElement("span", {\n    class: "detail"\n  }, "reading"));\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如上可知：\n\n * babel 插件在解析 jsx 代码时，js 部分是不需要解析的，html 部分会被解析为 React.createElement 语法。\n * 静态的部分会被加上 /*#__PURE__*/ 的静态内容标记。\n * 多个子节点并不是通过数组传入而是以多个参数的形式传入的，这个可以通过 rest 运算符处理。\n\n\n# ReactElement\n\n在 react 包中 ReactElement 文件中 导出了 createElement、cloneElement、createFactory、isValidElement 几个关于 ELement 的 API。\n\n\n# createElement\n\n先来看一个例子，假如一个呗 babel 解析过的 jsx 代码如下：\n\nReact.createElement("div", {\n    class: "class_name",\n    id: "id_name",\n    key: "key_name",\n    ref: "ref_name"\n}, React.createElement("span", null, "Tom"), React.createElement("span", null, "Jerry"));\n\n\n1\n2\n3\n4\n5\n6\n\n\n传入 createElement 函数返回：\n\n{\n    $$typeof: REACT_ELEMENT_TYPE,\n    type：\'div\'，\n    key: \'key_name\',\n    ref: "ref_name",\n    props: {\n        class: "class_name",\n        id: "id_name",\n        children: [\n            React.createElement("span", null, "Tom"),\n            React.createElement("span", null, "Jerry")\n        ]\n    }\n     _owner: ReactCurrentOwner.current,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n_owner 就是 react 中所谓的 fiber（纤维）。线面我们来看下 createElement 的代码实现：\n\n// 根据元素类型 type，元素属性 config 和元素子节点（数组） children 创建 react 元素\nexport function createElement(type, config, children) {\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n\n  if (config != null) {\n    // 检查是否添加了 ref 属性\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    // 检查是否添加了 key 属性\n    if (hasValidKey(config)) {\n      key = \'\' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    // 添加至属性对象\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    // 单一子节点直接赋值\n    // children 是放到 props 上的，因此可以通过 props 的 children 获得组件内部内容\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  // 元素默认的属性\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  return ReactElement(\n    // 元素类型\n    type,\n    // 内部属性\n    key,\n    ref,\n    self,\n    source,\n    ReactCurrentOwner.current,\n    // 元素属性\n    props,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n以及 ReactElement 工厂函数：\n\nconst ReactElement = function (type, key, ref, self, source, owner, props) {\n  // 新建一个ReactElement对象\n  const element = {\n    // This tag allows us to uniquely identify this as a React Element\n    // ReactElement 的标志\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // 所属的组件\n    // Record the component responsible for creating this element.\n    _owner: owner,\n  };\n\n  return element;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * $$typeof : 这是一个常量，是 react 元素的标志，react 的元素都会带有这个属性。普通的 react 元素 $$typeof 的值一般都是 REACT_ELEMENT_TYPE ，但是也有特殊，比如 通过 ReactDOM.createPortals(child, container) 创建的 portal 元素的值为 ReactDOM.createPortals(child, container) 。\n * type：DOM 元素的类型，如 \'div\'。\n * key：列表元素的唯一标志。\n * ref：组件引用变量。\n * props：元素属性，包括默认属性、用户定义属性和子元素 children。\n * _owner：即 fiber。表示钙元素所从属的 fiber 实例。\n\n\n# isValidElement\n\n// 校验是否是合法元素，只需要校验类型，重点是判断.$$typeof属性\nexport function isValidElement(object) {\n  return (\n    typeof object === \'object\' &&\n    object !== null &&\n    // $$typeof是组件的属性，本质是Symbol,ReactElement类型是Symbol，是独有的。\n    // REACT_ELEMENT_TYPE指的就是Symbol(react.element)\n    object.$$typeof === REACT_ELEMENT_TYPE // $$typeof: Symbol(react.element)\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n是合法的 ReactElement 元素的两个必要条件：\n\n * 类型是 \'object\'，且不是 null;\n * $$typeof 属性必须是 REACT_ELEMENT_TYPE 。\n\n\n# 小结\n\n * createElement 方法将组件转化成 ReactElement 元素，具有 $$typeof 、type、key、ref、props、_owner 等属性，其中 $$typeof 用于对 ReactElement 的类型做判断，type 和 props (包括 children) 用于将 VNode 转化为真实的 DOM，key 和 ref 是组件树中必要元素，而_owner 则记录了当前所属的组件 fiber 实例，用于调和组件的渲染和卸载。\n * cloneElement 通过一个给定的 ReactElement 克隆一个 ReactElement。\n * isValidElement 判断对象是否是合法的 ReactElement。',normalizedContent:'# 目录\n\n\n\n * 目录\n * jsx\n * reactelement\n   * createelement\n   * isvalidelement\n   * 小结\n\n\n\n\n# jsx\n\n * jsx 是一种将 js 和 html 混合写的语法糖，需要通过 babel 解析之后浏览器才能识别。\n * jsx 语法可以通过 @babel/plugin-transform-react-jsx-source 插件进行解析。\n\n例如如下代码：\n\nconst con = () => {\n\treturn (\n    <div style={{color: \'#ffffff\'}}>\n      <p class="title">react</p>\n      <span class="detail">reading</span>\n    </div>\n    )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n将会被解析为：\n\nconst con = () => {\n  return /*#__pure__*/react.createelement("div", {\n    style: {\n      color: \'#ffffff\'\n    }\n  }, /*#__pure__*/react.createelement("p", {\n    class: "title"\n  }, "react"), /*#__pure__*/react.createelement("span", {\n    class: "detail"\n  }, "reading"));\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如上可知：\n\n * babel 插件在解析 jsx 代码时，js 部分是不需要解析的，html 部分会被解析为 react.createelement 语法。\n * 静态的部分会被加上 /*#__pure__*/ 的静态内容标记。\n * 多个子节点并不是通过数组传入而是以多个参数的形式传入的，这个可以通过 rest 运算符处理。\n\n\n# reactelement\n\n在 react 包中 reactelement 文件中 导出了 createelement、cloneelement、createfactory、isvalidelement 几个关于 element 的 api。\n\n\n# createelement\n\n先来看一个例子，假如一个呗 babel 解析过的 jsx 代码如下：\n\nreact.createelement("div", {\n    class: "class_name",\n    id: "id_name",\n    key: "key_name",\n    ref: "ref_name"\n}, react.createelement("span", null, "tom"), react.createelement("span", null, "jerry"));\n\n\n1\n2\n3\n4\n5\n6\n\n\n传入 createelement 函数返回：\n\n{\n    $$typeof: react_element_type,\n    type：\'div\'，\n    key: \'key_name\',\n    ref: "ref_name",\n    props: {\n        class: "class_name",\n        id: "id_name",\n        children: [\n            react.createelement("span", null, "tom"),\n            react.createelement("span", null, "jerry")\n        ]\n    }\n     _owner: reactcurrentowner.current,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n_owner 就是 react 中所谓的 fiber（纤维）。线面我们来看下 createelement 的代码实现：\n\n// 根据元素类型 type，元素属性 config 和元素子节点（数组） children 创建 react 元素\nexport function createelement(type, config, children) {\n  let propname;\n\n  // reserved names are extracted\n  const props = {};\n\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n\n  if (config != null) {\n    // 检查是否添加了 ref 属性\n    if (hasvalidref(config)) {\n      ref = config.ref;\n    }\n    // 检查是否添加了 key 属性\n    if (hasvalidkey(config)) {\n      key = \'\' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // remaining properties are added to a new props object\n    // 添加至属性对象\n    for (propname in config) {\n      if (\n        hasownproperty.call(config, propname) &&\n        !reserved_props.hasownproperty(propname)\n      ) {\n        props[propname] = config[propname];\n      }\n    }\n  }\n\n  // children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenlength = arguments.length - 2;\n  if (childrenlength === 1) {\n    // 单一子节点直接赋值\n    // children 是放到 props 上的，因此可以通过 props 的 children 获得组件内部内容\n    props.children = children;\n  } else if (childrenlength > 1) {\n    const childarray = array(childrenlength);\n    for (let i = 0; i < childrenlength; i++) {\n      childarray[i] = arguments[i + 2];\n    }\n    props.children = childarray;\n  }\n\n  // resolve default props\n  // 元素默认的属性\n  if (type && type.defaultprops) {\n    const defaultprops = type.defaultprops;\n    for (propname in defaultprops) {\n      if (props[propname] === undefined) {\n        props[propname] = defaultprops[propname];\n      }\n    }\n  }\n  return reactelement(\n    // 元素类型\n    type,\n    // 内部属性\n    key,\n    ref,\n    self,\n    source,\n    reactcurrentowner.current,\n    // 元素属性\n    props,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n以及 reactelement 工厂函数：\n\nconst reactelement = function (type, key, ref, self, source, owner, props) {\n  // 新建一个reactelement对象\n  const element = {\n    // this tag allows us to uniquely identify this as a react element\n    // reactelement 的标志\n    $$typeof: react_element_type,\n\n    // built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // 所属的组件\n    // record the component responsible for creating this element.\n    _owner: owner,\n  };\n\n  return element;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * $$typeof : 这是一个常量，是 react 元素的标志，react 的元素都会带有这个属性。普通的 react 元素 $$typeof 的值一般都是 react_element_type ，但是也有特殊，比如 通过 reactdom.createportals(child, container) 创建的 portal 元素的值为 reactdom.createportals(child, container) 。\n * type：dom 元素的类型，如 \'div\'。\n * key：列表元素的唯一标志。\n * ref：组件引用变量。\n * props：元素属性，包括默认属性、用户定义属性和子元素 children。\n * _owner：即 fiber。表示钙元素所从属的 fiber 实例。\n\n\n# isvalidelement\n\n// 校验是否是合法元素，只需要校验类型，重点是判断.$$typeof属性\nexport function isvalidelement(object) {\n  return (\n    typeof object === \'object\' &&\n    object !== null &&\n    // $$typeof是组件的属性，本质是symbol,reactelement类型是symbol，是独有的。\n    // react_element_type指的就是symbol(react.element)\n    object.$$typeof === react_element_type // $$typeof: symbol(react.element)\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n是合法的 reactelement 元素的两个必要条件：\n\n * 类型是 \'object\'，且不是 null;\n * $$typeof 属性必须是 react_element_type 。\n\n\n# 小结\n\n * createelement 方法将组件转化成 reactelement 元素，具有 $$typeof 、type、key、ref、props、_owner 等属性，其中 $$typeof 用于对 reactelement 的类型做判断，type 和 props (包括 children) 用于将 vnode 转化为真实的 dom，key 和 ref 是组件树中必要元素，而_owner 则记录了当前所属的组件 fiber 实例，用于调和组件的渲染和卸载。\n * cloneelement 通过一个给定的 reactelement 克隆一个 reactelement。\n * isvalidelement 判断对象是否是合法的 reactelement。',charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-14T22:02:21.000Z",permalink:"/react/reconciliation/index/",categories:["react","reconciliation"],tags:[null]},regularPath:"/10.react/20.%E8%B0%83%E5%92%8C%EF%BC%88Reconciliation%EF%BC%89/0.index.html",relativePath:"10.react/20.调和（Reconciliation）/0.index.md",key:"v-4d309ab6",path:"/react/reconciliation/index/",headers:[{level:2,title:"reconciler 运作流程的 4 个阶段",slug:"reconciler-运作流程的-4-个阶段",normalizedTitle:"reconciler 运作流程的 4 个阶段",charIndex:2}],readingTime:{text:"1 min read",minutes:.115,time:6900,words:23},headersStr:"reconciler 运作流程的 4 个阶段",content:"# reconciler 运作流程的 4 个阶段\n\nreconciler 在运作过程中，可分为如下四个阶段：\n\n 1. 输入阶段：\n 2. 任务的注册与调度阶段\n 3. 任务回调与 FiberTree 的构建阶段\n 4. 输出阶段",normalizedContent:"# reconciler 运作流程的 4 个阶段\n\nreconciler 在运作过程中，可分为如下四个阶段：\n\n 1. 输入阶段：\n 2. 任务的注册与调度阶段\n 3. 任务回调与 fibertree 的构建阶段\n 4. 输出阶段",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"Fiber 与 Reconciliation",frontmatter:{title:"Fiber 与 Reconciliation",date:"2022-04-14T22:02:21.000Z",permalink:"/react/reconciliation/fiber/",categories:["react","reconciliation"],tags:[null]},regularPath:"/10.react/20.%E8%B0%83%E5%92%8C%EF%BC%88Reconciliation%EF%BC%89/10.fiber.html",relativePath:"10.react/20.调和（Reconciliation）/10.fiber.md",key:"v-1a05c896",path:"/react/reconciliation/fiber/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"Fiber Reconciliation",slug:"fiber-reconciliation",normalizedTitle:"fiber reconciliation",charIndex:17},{level:3,title:"调和（Reconciliation）的概念",slug:"调和-reconciliation-的概念",normalizedTitle:"调和（reconciliation）的概念",charIndex:43},{level:3,title:"fiber 的功能",slug:"fiber-的功能",normalizedTitle:"fiber 的功能",charIndex:70},{level:3,title:"浏览器对优先级控制的支持",slug:"浏览器对优先级控制的支持",normalizedTitle:"浏览器对优先级控制的支持",charIndex:85},{level:3,title:"fiber、Fiber 与组件的关系",slug:"fiber、fiber-与组件的关系",normalizedTitle:"fiber、fiber 与组件的关系",charIndex:103},{level:2,title:"Fiber 详解",slug:"fiber-详解",normalizedTitle:"fiber 详解",charIndex:125},{level:3,title:"Fiber 的定义",slug:"fiber-的定义",normalizedTitle:"fiber 的定义",charIndex:139},{level:3,title:"fiber 的类型",slug:"fiber-的类型",normalizedTitle:"fiber 的类型",charIndex:154},{level:3,title:"fiber 的创建",slug:"fiber-的创建",normalizedTitle:"fiber 的创建",charIndex:169},{level:2,title:"FiberRoot",slug:"fiberroot",normalizedTitle:"fiberroot",charIndex:182},{level:3,title:"FiberRoot 的定义",slug:"fiberroot-的定义",normalizedTitle:"fiberroot 的定义",charIndex:197},{level:3,title:"创建 FiberRoot",slug:"创建-fiberroot",normalizedTitle:"创建 fiberroot",charIndex:216},{level:2,title:"HostFiberRoot",slug:"hostfiberroot",normalizedTitle:"hostfiberroot",charIndex:232},{level:2,title:"ReactChildFiber",slug:"reactchildfiber",normalizedTitle:"reactchildfiber",charIndex:249}],readingTime:{text:"12 min read",minutes:11.015,time:660900.0000000001,words:2203},headersStr:"目录 Fiber Reconciliation 调和（Reconciliation）的概念 fiber 的功能 浏览器对优先级控制的支持 fiber、Fiber 与组件的关系 Fiber 详解 Fiber 的定义 fiber 的类型 fiber 的创建 FiberRoot FiberRoot 的定义 创建 FiberRoot HostFiberRoot ReactChildFiber",content:"# 目录\n\n\n\n * 目录\n * Fiber Reconciliation\n   * 调和（Reconciliation）的概念\n   * fiber 的功能\n   * 浏览器对优先级控制的支持\n   * fiber、Fiber 与组件的关系\n * Fiber 详解\n   * Fiber 的定义\n   * fiber 的类型\n   * fiber 的创建\n * FiberRoot\n   * FiberRoot 的定义\n   * 创建 FiberRoot\n * HostFiberRoot\n * ReactChildFiber\n\n\n\n调和的代码主要在 react-reconciler 包中。\n\n\n# Fiber Reconciliation\n\n\n# 调和（Reconciliation）的概念\n\n对于 Reconciliation 可以从宏观和微观两个层面进行理解，宏观来看，调和就是在应用挂载、更新、卸载的生命周期中，维护调度器、渲染器、更新器各个部分的协调工作，维护应用渲染的更新循环；从微观来看，就是在渲染过程中，调和维护调用组件树中的组件的 render 方法渲染组件、组件的更新和卸载的生命周期。\n\nReact 15.X 中 Stack Reconciler 缺乏对渲染任务优先级的管理，渲染任务可能会阻塞线程，导致其他高优先级的任务无法执行，造成页面卡顿。\n\nFiber Reconciliation 是在 React16 提出的，使渲染任务分段执行，不阻塞主线程，当进程中有更高优先级的任务时就阻塞渲染任务去执行更高优先级的任务。\n\n\n# fiber 的功能\n\nfiber 实例与组件实例意义对应（但并非是一对一的关系，而是多对一的关系），负责组件实例的渲染更新。fiber 实例之间通过指针组成一棵 Fiber Tree，可以实现更细粒度的渲染控制。\n\nfiber 提供的功能有：\n\n * 可切分，可中断任务；\n * 可重用各分阶段任务，且可以设置优先级；\n * 可以在父子组件任务间前进后退切换任务；\n * render 方法可以返回多元素（即可以返回数组）；\n * 支持异常边界处理异常；\n\n\n# 浏览器对优先级控制的支持\n\n这种优先级的控制在浏览器中依赖于这两个 Api：\n\nrequestIdleCallback: 在线程空闲时期调度执行低优先级函数；\nrequestAnimationFrame: 在下一个动画帧调度执行高优先级函数；\n\n\n1\n2\n\n * requestIdleCallback 执行低优先级的任务，如数据获取。可分为多个 idle callback 将任务细分，具有 deadline，防止执行时间过程阻塞 UI 渲染。\n * requestAnimationFrame 执行高优先级的任务，如交互动画。\n\n不支持这种 Api 的浏览器可以用 js 来模拟。\n\n\n# fiber、Fiber 与组件的关系\n\n * fiber 实例与组件实例相对应，Fiber Tree 对应组件树，Fiber Root 对应组件树根节点。\n * Fiber 只应用的调和算法，fiber 负责组件实例的渲染。\n\n\n# Fiber 详解\n\n\n# Fiber 的定义\n\n在 react-reconciler 包中 对 Fiber 由如下的定义（dev 环境下的值已去除）：\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\n// Fiber 作用于需要渲染或者已经渲染的组件。一个组件可能有不止一个 Fiber。\nexport type Fiber = {|\n  // These first fields are conceptually members of an Instance. This used to\n  // be split into a separate type and intersected with the other Fiber fields,\n  // but until Flow fixes its intersection bugs, we've merged them into a\n  // single type.\n\n  // An Instance is shared between all versions of a component. We can easily\n  // break this out into a separate object to avoid copying so much to the\n  // alternate versions of the tree. We put this on a single object for now to\n  // minimize the number of objects created during the initial render.\n  // 一个 Fiber 实例有组件的各个历史版本所共享。创建一个完整的对象以减少初次渲染时创建对象的数目。\n\n  // Tag identifying the type of fiber.\n  // 区分 Fiber 的类型:0-21\n  tag: WorkTag,\n\n  // Unique identifier of this child.\n  // fiber 实例的 key 值。\n  key: null | string,\n\n  // The value of element.type which is used to preserve the identity during\n  // reconciliation of this child.\n  // 元素类型 element.type\n  elementType: any,\n\n  // The resolved function/class/ associated with this fiber.\n  // fiber对应的function/class/module类型组件名.\n  type: any,\n\n  // The local state associated with this fiber.\n  // fiber所在组件树的根组件FiberRoot对象\n  stateNode: any,\n\n  // Conceptual aliases\n  // parent : Instance -> return The parent happens to be the same as the\n  // return fiber since we've merged the fiber and instance.\n\n  // Remaining fields belong to Fiber\n\n  // The Fiber to return to after finishing processing this one.\n  // This is effectively the parent, but there can be multiple parents (two)\n  // so this is only the parent of the thing we're currently processing.\n  // It is conceptually the same as the return address of a stack frame.\n  // 处理完当前 fiber 之后返回的 fiber，即父级 fiber。\n  return: Fiber | null,\n\n  // Singly Linked List Tree Structure.\n  // 子 fiber 和父级 fiber。数据结构：单链表树。\n  child: Fiber | null,\n  sibling: Fiber | null,\n  index: number,\n\n  // The ref last used to attach this node.\n  // I'll avoid adding an owner field for prod and model that as functions.\n  ref: null | (((handle: mixed) => void) & {_stringRef: ?string}) | RefObject,\n\n  // Input is the data coming into process this fiber. Arguments. Props.\n  // 当前 work-i-progress 的组件 props。\n  pendingProps: any, // This type will be more specific once we overload the tag.\n  // 缓存之前的组件的 props。\n  memoizedProps: any, // The props used to create the output.\n\n  // A queue of state updates and callbacks.\n  // 状态更新和回调的队列，用于对组件做更新。\n  updateQueue: UpdateQueue<any> | null,\n\n  // The state used to create the output\n  memoizedState: any,\n\n  // Dependencies (contexts, events) for this fiber, if it has any\n  // fiber 依赖\n  dependencies: Dependencies | null,\n\n  // Bitfield that describes properties about the fiber and its subtree. E.g.\n  // the ConcurrentMode flag indicates whether the subtree should be async-by-\n  // default. When a fiber is created, it inherits the mode of its\n  // parent. Additional flags can be set at creation time, but after that the\n  // value should remain unchanged throughout the fiber's lifetime, particularly\n  // before its child fibers are created.\n  // 用于描述 fiber 和 fiber tree 的属性的二进制常量。如 NoMode、StrictMode\n  mode: TypeOfMode,\n\n  // Effect\n  // effect 的状态\n  effectTag: SideEffectTag,\n\n  // Singly linked list fast path to the next fiber with side-effects.\n  // 以单链表的结构指向下一个 effect\n  nextEffect: Fiber | null,\n\n  // The first and last fiber with side-effect within this subtree. This allows\n  // us to reuse a slice of the linked list when we reuse the work done within\n  // this fiber.\n  // 当前的 pending effect 和 上一个 effect.\n  firstEffect: Fiber | null,\n  lastEffect: Fiber | null,\n\n  // Represents a time in the future by which this work should be completed.\n  // Does not include work found in its subtree.\n  // expirationTime 表示未来这个任务会被完成的时刻。也就是距离任务执行的时间间隔。到期时间。\n  expirationTime: ExpirationTime,\n\n  // This is used to quickly determine if a subtree has no pending changes.\n  // 子节点的 expirationTime，取 子树到期时间的最小值。用于判断是否子树还有渲染变化。\n  childExpirationTime: ExpirationTime,\n\n  // This is a pooled version of a Fiber. Every fiber that gets updated will\n  // eventually have a pair. There are cases when we can clean up pairs to save\n  // memory if we need to.\n  // 这个Fiber 的版本池，每个更新的 fiber 都会有一个相对的 alternate fiber。\n  alternate: Fiber | null,\n\n  // Time spent rendering this Fiber and its descendants for the current update.\n  // This tells us how well the tree makes use of sCU for memoization.\n  // It is reset to 0 each time we render and only updated when we don't bailout.\n  // This field is only set when the enableProfilerTimer flag is enabled.\n  actualDuration?: number,\n\n  // If the Fiber is currently active in the \"render\" phase,\n  // This marks the time at which the work began.\n  // This field is only set when the enableProfilerTimer flag is enabled.\n  actualStartTime?: number,\n\n  // Duration of the most recent render time for this Fiber.\n  // This value is not updated when we bailout for memoization purposes.\n  // This field is only set when the enableProfilerTimer flag is enabled.\n  selfBaseDuration?: number,\n\n  // Sum of base times for all descendants of this Fiber.\n  // This value bubbles up during the \"complete\" phase.\n  // This field is only set when the enableProfilerTimer flag is enabled.\n  treeBaseDuration?: number,\n|};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n\n\n需要注意一下几点：\n\n * stateNode 记录了 fiberRoot 对象。\n * return 记录了 parent fiber。\n * updateQueue 记录当前节点的更新队列，将会在 schedule 中涉及，fiber 负责在 reconciliation 时组件的渲染工作，在后续的 schedule 中会被此处的更新列表进行 update。\n * expirationTime 这个尤为重要，他表示渲染任务执行的到时时间，这个值越小，表示距离任务执行的时间间隔越短。fiber 对于渲染任务优先级的管理依赖于此，相对于 stack reconciliation 中对优先级做几种定量的分类相比，这种计算方法更加细粒度、灵活和精确。\n * alternate 是 fiber 的版本记录，表示上一次的 fiber。当需要回退时，可以很快的恢复之前的 fiber 状态。\n\n\n# fiber 的类型\n\nfiber 被定义为 21 种类型。\n\nexport const FunctionComponent = 0; // 函数组件\nexport const ClassComponent = 1; // 类组件\nexport const IndeterminateComponent = 2; // Before we know whether it is function or class\nexport const HostRoot = 3; // Root of a host tree. Could be nested inside another node.\nexport const HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\nexport const HostComponent = 5;\nexport const HostText = 6;\nexport const Fragment = 7;\nexport const Mode = 8;\nexport const ContextConsumer = 9;\nexport const ContextProvider = 10;\nexport const ForwardRef = 11;\nexport const Profiler = 12;\nexport const SuspenseComponent = 13;\nexport const MemoComponent = 14;\nexport const SimpleMemoComponent = 15;\nexport const LazyComponent = 16;\nexport const IncompleteClassComponent = 17;\nexport const DehydratedFragment = 18;\nexport const SuspenseListComponent = 19;\nexport const FundamentalComponent = 20;\nexport const ScopeComponent = 21;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# fiber 的创建\n\nfiber 由工厂函数 createFiber 创建。\n\nconst createFiber = function(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n): Fiber {\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\nfunction FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n) {\n  // Instance：fiber 实例相关\n  this.tag = tag;\n  this.key = key;\n  this.elementType = null;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber：fiber 架构相关\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n\n  this.mode = mode;\n\n  // Effects：effect 相关\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n  this.childExpirationTime = NoWork;\n\n  this.alternate = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n创建 alternate fiber:\n\nfunction createWorkInProgress(\n  current: Fiber, // 当前的 fiber\n  pendingProps: any, // 当前组件的 props\n  expirationTime: ExpirationTime, // 到期时间\n): Fiber {\n  let workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    // 如果当前的 alternate fiber 不存在，就创建一个新的 fiber,并处理为  alternate fiber。\n    workInProgress = createFiber(\n      current.tag,\n      pendingProps,\n      current.key,\n      current.mode,\n    );\n    workInProgress.elementType = current.elementType;\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    // double buffering pooling technique： 互相交替模拟版本池。\n    workInProgress.alternate = current;\n    // 将workInProgress挂载到current.alternate很好理解。\n    current.alternate = workInProgress;\n  } else {\n    // 如果  alternate fiber 以存在，将他修改为新的  alternate fiber。\n    // 减少重复创建对象带来的资源开销。\n    workInProgress.pendingProps = pendingProps;\n\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n  }\n\n  workInProgress.childExpirationTime = current.childExpirationTime;\n  workInProgress.expirationTime = current.expirationTime;\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n\n  // Clone the dependencies object. This is mutated during the render phase, so\n  // it cannot be shared with the current fiber.\n  const currentDependencies = current.dependencies;\n  workInProgress.dependencies =\n    currentDependencies === null\n      ? null\n      : {\n          expirationTime: currentDependencies.expirationTime,\n          firstContext: currentDependencies.firstContext,\n          responders: currentDependencies.responders,\n        };\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  return workInProgress;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n * 这里如果 fiber 上已经有 alternate 就直接修改 alternate，不必创新创建 alternate fiber，可以大量减少创建对象带来的内存开销。\n * workInProgress 和 current 双向 alternate 记录是为了模拟 fiber 版本池的效果，这里就不需要复杂的数据结构来实现了。alternate 给了 fiber 更新更多的机动性。\n * workInProgress 代表了当前 fiber 的稳定版本，可以理解为 stable version，current 代表了 fiber 的更新版本，可以理解为 beta version。运行在页面上的永远是 workInProgress，而只有经过了 schedule 和 render，current 才会成为下一个 workInProgress。\n\n下面来看一下 fiber 中的特例 ———— FiberRoot。\n\n\n# FiberRoot\n\n\n# FiberRoot 的定义\n\n在 react-reconciler 包中 ReactFiberRoot.js 文件中可以看到 FiberRoot 有如下定义：\n\nexport type FiberRoot = {\n  ...BaseFiberRootProperties,\n  ...ProfilingOnlyFiberRootProperties,\n  ...SuspenseCallbackOnlyFiberRootProperties,\n};\n\n\n1\n2\n3\n4\n5\n\n\n我们主要来看下 BaseFiberRootProperties。\n\ntype BaseFiberRootProperties = {|\n  // The type of root (legacy, batched, concurrent, etc.)\n  // fiberRoot 的类型\n  // export type RootTag = 0 | 1 | 2;\n  // export const LegacyRoot = 0;\n  // export const BatchedRoot = 1;\n  // export const ConcurrentRoot = 2;\n  tag: RootTag,\n\n  // Any additional information from the host associated with this root.\n  // 与根节点相关的容器信息\n  containerInfo: any,\n  // Used only by persistent updates.\n  pendingChildren: any,\n  // The currently active root fiber. This is the mutable root of the tree.\n  // 当前容器中激活的 Fiber 对象\n  current: Fiber,\n\n  pingCache:\n    | WeakMap<Thenable, Set<ExpirationTime>>\n    | Map<Thenable, Set<ExpirationTime>>\n    | null,\n  // 将被 commit 的 fiber 的到期时间\n  finishedExpirationTime: ExpirationTime,\n  // A finished work-in-progress HostRoot that's ready to be committed.\n  // 将被 commit 的 Fiber（HostRoot）\n  finishedWork: Fiber | null,\n  // Timeout handle returned by setTimeout. Used to cancel a pending timeout, if\n  // it's superseded by a new one.\n  timeoutHandle: TimeoutHandle | NoTimeout,\n  // Top context object, used by renderSubtreeIntoContainer\n  // 顶级的 context 对象\n  context: Object | null,\n  pendingContext: Object | null,\n  // Determines if we should attempt to hydrate on the initial mount\n  // 是否需要在初次渲染时进行hydrate\n  +hydrate: boolean,\n  // List of top-level batches. This list indicates whether a commit should be\n  // deferred. Also contains completion callbacks.\n  // TODO: Lift this into the renderer\n  firstBatch: Batch | null,\n  // Node returned by Scheduler.scheduleCallback\n  callbackNode: *,\n  // Expiration of the callback associated with this root\n  // callback 的超时时间\n  callbackExpirationTime: ExpirationTime,\n  // Priority of the callback associated with this root\n  callbackPriority: ReactPriorityLevel,\n  // The earliest pending expiration time that exists in the tree\n  firstPendingTime: ExpirationTime,\n  // The earliest suspended expiration time that exists in the tree\n  firstSuspendedTime: ExpirationTime,\n  // The latest suspended expiration time that exists in the tree\n  lastSuspendedTime: ExpirationTime,\n  // The next known expiration time after the suspended range\n  nextKnownPendingLevel: ExpirationTime,\n  // The latest time at which a suspended component pinged the root to\n  // render again\n  lastPingedTime: ExpirationTime,\n  lastExpiredTime: ExpirationTime,\n|};\n\n// FiberRootNode 工厂函数\nfunction FiberRootNode(containerInfo, tag, hydrate) {\n  this.tag = tag;\n  this.current = null;\n  this.containerInfo = containerInfo;\n  this.pendingChildren = null;\n  this.pingCache = null;\n  this.finishedExpirationTime = NoWork;\n  this.finishedWork = null;\n  this.timeoutHandle = noTimeout;\n  this.context = null;\n  this.pendingContext = null;\n  this.hydrate = hydrate;\n  this.firstBatch = null;\n  this.callbackNode = null;\n  this.callbackPriority = NoPriority;\n  this.firstPendingTime = NoWork;\n  this.firstSuspendedTime = NoWork;\n  this.lastSuspendedTime = NoWork;\n  this.nextKnownPendingLevel = NoWork;\n  this.lastPingedTime = NoWork;\n  this.lastExpiredTime = NoWork;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n\n# 创建 FiberRoot\n\nFiberRoot 由函数 createFiberRoot 创建。\n\nfunction createFiberRoot(\n  // 容器信息\n  containerInfo: any,\n  // FiberRoot 的类型\n  tag: RootTag,\n  hydrate: boolean,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n): FiberRoot {\n  const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any);\n  // 创建 HostFiberRoot，可见 HostFiberRoot 是 挂载到 FiberRoot.current 上面的\n  const uninitializedFiber = createHostRootFiber(tag);\n  root.current = uninitializedFiber;\n  // 将 FiberRoot 挂载到 HostFiberRoot.stateNode 上。\n  uninitializedFiber.stateNode = root;\n\n  return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n由此可见：\n\n * double buffering pooling technique：这里运用了双缓冲技术，从 FiberRoot 可以获取到 HostFiberRoot 的 Fiber 信息，同时从 HostFiberRoot 也可以获取到 FiberRoot 的容器信息。这样当 HostFiberRoot 需要回退时，可以及时的从 FiberRoot 恢复信息。\n * FiberRoot 可以看做是真个 FiberTree 的一个容器，记载着一些容器信息和即将被 Commit 的 HostFiberRoot 的信息；HostFiberRoot 才是真正的 FiberTree 的根节点。\n\n\n# HostFiberRoot\n\nHostFiberRoot 本质上是 Fiber，是 FiberTree 的根节点。\n\n创建 HostFiberRoot 代码如下：\n\nfunction createHostRootFiber(tag: RootTag): Fiber {\n  let mode;\n  if (tag === ConcurrentRoot) {\n    mode = ConcurrentMode | BatchedMode | StrictMode;\n  } else if (tag === BatchedRoot) {\n    mode = BatchedMode | StrictMode;\n  } else {\n    mode = NoMode;\n  }\n\n  return createFiber(HostRoot, null, null, mode);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 调用 createFiber 创建 HostFiberRoot，说明 HostFiberRoot 本质上还是 Fiber，只是 Fiber 被标记为了 HostRoot。\n\n\n# ReactChildFiber\n\n在生成 FiberRoot 和 HostFiberRoot 之后，还需要为子组件生成各自的子 fiber。这部分在 react-reconciler 包中 ReactChildFiber.js 文件中实现。这个过程大致分为两步：\n\n// 调和 ReactChildFiber\nexport const reconcileChildFibers = ChildReconciler(true);\n// 挂载 ReactChildFiber\nexport const mountChildFibers = ChildReconciler(false);\n\n\n1\n2\n3\n4\n\n\n这部分较为复杂，之后详解。在更新器章节，还会用到这里的内容。",normalizedContent:"# 目录\n\n\n\n * 目录\n * fiber reconciliation\n   * 调和（reconciliation）的概念\n   * fiber 的功能\n   * 浏览器对优先级控制的支持\n   * fiber、fiber 与组件的关系\n * fiber 详解\n   * fiber 的定义\n   * fiber 的类型\n   * fiber 的创建\n * fiberroot\n   * fiberroot 的定义\n   * 创建 fiberroot\n * hostfiberroot\n * reactchildfiber\n\n\n\n调和的代码主要在 react-reconciler 包中。\n\n\n# fiber reconciliation\n\n\n# 调和（reconciliation）的概念\n\n对于 reconciliation 可以从宏观和微观两个层面进行理解，宏观来看，调和就是在应用挂载、更新、卸载的生命周期中，维护调度器、渲染器、更新器各个部分的协调工作，维护应用渲染的更新循环；从微观来看，就是在渲染过程中，调和维护调用组件树中的组件的 render 方法渲染组件、组件的更新和卸载的生命周期。\n\nreact 15.x 中 stack reconciler 缺乏对渲染任务优先级的管理，渲染任务可能会阻塞线程，导致其他高优先级的任务无法执行，造成页面卡顿。\n\nfiber reconciliation 是在 react16 提出的，使渲染任务分段执行，不阻塞主线程，当进程中有更高优先级的任务时就阻塞渲染任务去执行更高优先级的任务。\n\n\n# fiber 的功能\n\nfiber 实例与组件实例意义对应（但并非是一对一的关系，而是多对一的关系），负责组件实例的渲染更新。fiber 实例之间通过指针组成一棵 fiber tree，可以实现更细粒度的渲染控制。\n\nfiber 提供的功能有：\n\n * 可切分，可中断任务；\n * 可重用各分阶段任务，且可以设置优先级；\n * 可以在父子组件任务间前进后退切换任务；\n * render 方法可以返回多元素（即可以返回数组）；\n * 支持异常边界处理异常；\n\n\n# 浏览器对优先级控制的支持\n\n这种优先级的控制在浏览器中依赖于这两个 api：\n\nrequestidlecallback: 在线程空闲时期调度执行低优先级函数；\nrequestanimationframe: 在下一个动画帧调度执行高优先级函数；\n\n\n1\n2\n\n * requestidlecallback 执行低优先级的任务，如数据获取。可分为多个 idle callback 将任务细分，具有 deadline，防止执行时间过程阻塞 ui 渲染。\n * requestanimationframe 执行高优先级的任务，如交互动画。\n\n不支持这种 api 的浏览器可以用 js 来模拟。\n\n\n# fiber、fiber 与组件的关系\n\n * fiber 实例与组件实例相对应，fiber tree 对应组件树，fiber root 对应组件树根节点。\n * fiber 只应用的调和算法，fiber 负责组件实例的渲染。\n\n\n# fiber 详解\n\n\n# fiber 的定义\n\n在 react-reconciler 包中 对 fiber 由如下的定义（dev 环境下的值已去除）：\n\n// a fiber is work on a component that needs to be done or was done. there can\n// be more than one per component.\n// fiber 作用于需要渲染或者已经渲染的组件。一个组件可能有不止一个 fiber。\nexport type fiber = {|\n  // these first fields are conceptually members of an instance. this used to\n  // be split into a separate type and intersected with the other fiber fields,\n  // but until flow fixes its intersection bugs, we've merged them into a\n  // single type.\n\n  // an instance is shared between all versions of a component. we can easily\n  // break this out into a separate object to avoid copying so much to the\n  // alternate versions of the tree. we put this on a single object for now to\n  // minimize the number of objects created during the initial render.\n  // 一个 fiber 实例有组件的各个历史版本所共享。创建一个完整的对象以减少初次渲染时创建对象的数目。\n\n  // tag identifying the type of fiber.\n  // 区分 fiber 的类型:0-21\n  tag: worktag,\n\n  // unique identifier of this child.\n  // fiber 实例的 key 值。\n  key: null | string,\n\n  // the value of element.type which is used to preserve the identity during\n  // reconciliation of this child.\n  // 元素类型 element.type\n  elementtype: any,\n\n  // the resolved function/class/ associated with this fiber.\n  // fiber对应的function/class/module类型组件名.\n  type: any,\n\n  // the local state associated with this fiber.\n  // fiber所在组件树的根组件fiberroot对象\n  statenode: any,\n\n  // conceptual aliases\n  // parent : instance -> return the parent happens to be the same as the\n  // return fiber since we've merged the fiber and instance.\n\n  // remaining fields belong to fiber\n\n  // the fiber to return to after finishing processing this one.\n  // this is effectively the parent, but there can be multiple parents (two)\n  // so this is only the parent of the thing we're currently processing.\n  // it is conceptually the same as the return address of a stack frame.\n  // 处理完当前 fiber 之后返回的 fiber，即父级 fiber。\n  return: fiber | null,\n\n  // singly linked list tree structure.\n  // 子 fiber 和父级 fiber。数据结构：单链表树。\n  child: fiber | null,\n  sibling: fiber | null,\n  index: number,\n\n  // the ref last used to attach this node.\n  // i'll avoid adding an owner field for prod and model that as functions.\n  ref: null | (((handle: mixed) => void) & {_stringref: ?string}) | refobject,\n\n  // input is the data coming into process this fiber. arguments. props.\n  // 当前 work-i-progress 的组件 props。\n  pendingprops: any, // this type will be more specific once we overload the tag.\n  // 缓存之前的组件的 props。\n  memoizedprops: any, // the props used to create the output.\n\n  // a queue of state updates and callbacks.\n  // 状态更新和回调的队列，用于对组件做更新。\n  updatequeue: updatequeue<any> | null,\n\n  // the state used to create the output\n  memoizedstate: any,\n\n  // dependencies (contexts, events) for this fiber, if it has any\n  // fiber 依赖\n  dependencies: dependencies | null,\n\n  // bitfield that describes properties about the fiber and its subtree. e.g.\n  // the concurrentmode flag indicates whether the subtree should be async-by-\n  // default. when a fiber is created, it inherits the mode of its\n  // parent. additional flags can be set at creation time, but after that the\n  // value should remain unchanged throughout the fiber's lifetime, particularly\n  // before its child fibers are created.\n  // 用于描述 fiber 和 fiber tree 的属性的二进制常量。如 nomode、strictmode\n  mode: typeofmode,\n\n  // effect\n  // effect 的状态\n  effecttag: sideeffecttag,\n\n  // singly linked list fast path to the next fiber with side-effects.\n  // 以单链表的结构指向下一个 effect\n  nexteffect: fiber | null,\n\n  // the first and last fiber with side-effect within this subtree. this allows\n  // us to reuse a slice of the linked list when we reuse the work done within\n  // this fiber.\n  // 当前的 pending effect 和 上一个 effect.\n  firsteffect: fiber | null,\n  lasteffect: fiber | null,\n\n  // represents a time in the future by which this work should be completed.\n  // does not include work found in its subtree.\n  // expirationtime 表示未来这个任务会被完成的时刻。也就是距离任务执行的时间间隔。到期时间。\n  expirationtime: expirationtime,\n\n  // this is used to quickly determine if a subtree has no pending changes.\n  // 子节点的 expirationtime，取 子树到期时间的最小值。用于判断是否子树还有渲染变化。\n  childexpirationtime: expirationtime,\n\n  // this is a pooled version of a fiber. every fiber that gets updated will\n  // eventually have a pair. there are cases when we can clean up pairs to save\n  // memory if we need to.\n  // 这个fiber 的版本池，每个更新的 fiber 都会有一个相对的 alternate fiber。\n  alternate: fiber | null,\n\n  // time spent rendering this fiber and its descendants for the current update.\n  // this tells us how well the tree makes use of scu for memoization.\n  // it is reset to 0 each time we render and only updated when we don't bailout.\n  // this field is only set when the enableprofilertimer flag is enabled.\n  actualduration?: number,\n\n  // if the fiber is currently active in the \"render\" phase,\n  // this marks the time at which the work began.\n  // this field is only set when the enableprofilertimer flag is enabled.\n  actualstarttime?: number,\n\n  // duration of the most recent render time for this fiber.\n  // this value is not updated when we bailout for memoization purposes.\n  // this field is only set when the enableprofilertimer flag is enabled.\n  selfbaseduration?: number,\n\n  // sum of base times for all descendants of this fiber.\n  // this value bubbles up during the \"complete\" phase.\n  // this field is only set when the enableprofilertimer flag is enabled.\n  treebaseduration?: number,\n|};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n\n\n需要注意一下几点：\n\n * statenode 记录了 fiberroot 对象。\n * return 记录了 parent fiber。\n * updatequeue 记录当前节点的更新队列，将会在 schedule 中涉及，fiber 负责在 reconciliation 时组件的渲染工作，在后续的 schedule 中会被此处的更新列表进行 update。\n * expirationtime 这个尤为重要，他表示渲染任务执行的到时时间，这个值越小，表示距离任务执行的时间间隔越短。fiber 对于渲染任务优先级的管理依赖于此，相对于 stack reconciliation 中对优先级做几种定量的分类相比，这种计算方法更加细粒度、灵活和精确。\n * alternate 是 fiber 的版本记录，表示上一次的 fiber。当需要回退时，可以很快的恢复之前的 fiber 状态。\n\n\n# fiber 的类型\n\nfiber 被定义为 21 种类型。\n\nexport const functioncomponent = 0; // 函数组件\nexport const classcomponent = 1; // 类组件\nexport const indeterminatecomponent = 2; // before we know whether it is function or class\nexport const hostroot = 3; // root of a host tree. could be nested inside another node.\nexport const hostportal = 4; // a subtree. could be an entry point to a different renderer.\nexport const hostcomponent = 5;\nexport const hosttext = 6;\nexport const fragment = 7;\nexport const mode = 8;\nexport const contextconsumer = 9;\nexport const contextprovider = 10;\nexport const forwardref = 11;\nexport const profiler = 12;\nexport const suspensecomponent = 13;\nexport const memocomponent = 14;\nexport const simplememocomponent = 15;\nexport const lazycomponent = 16;\nexport const incompleteclasscomponent = 17;\nexport const dehydratedfragment = 18;\nexport const suspenselistcomponent = 19;\nexport const fundamentalcomponent = 20;\nexport const scopecomponent = 21;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# fiber 的创建\n\nfiber 由工厂函数 createfiber 创建。\n\nconst createfiber = function(\n  tag: worktag,\n  pendingprops: mixed,\n  key: null | string,\n  mode: typeofmode,\n): fiber {\n  return new fibernode(tag, pendingprops, key, mode);\n};\n\nfunction fibernode(\n  tag: worktag,\n  pendingprops: mixed,\n  key: null | string,\n  mode: typeofmode,\n) {\n  // instance：fiber 实例相关\n  this.tag = tag;\n  this.key = key;\n  this.elementtype = null;\n  this.type = null;\n  this.statenode = null;\n\n  // fiber：fiber 架构相关\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingprops = pendingprops;\n  this.memoizedprops = null;\n  this.updatequeue = null;\n  this.memoizedstate = null;\n  this.dependencies = null;\n\n  this.mode = mode;\n\n  // effects：effect 相关\n  this.effecttag = noeffect;\n  this.nexteffect = null;\n\n  this.firsteffect = null;\n  this.lasteffect = null;\n\n  this.expirationtime = nowork;\n  this.childexpirationtime = nowork;\n\n  this.alternate = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n创建 alternate fiber:\n\nfunction createworkinprogress(\n  current: fiber, // 当前的 fiber\n  pendingprops: any, // 当前组件的 props\n  expirationtime: expirationtime, // 到期时间\n): fiber {\n  let workinprogress = current.alternate;\n  if (workinprogress === null) {\n    // we use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. we pool the \"other\" unused\n    // node that we're free to reuse. this is lazily created to avoid allocating\n    // extra objects for things that are never updated. it also allow us to\n    // reclaim the extra memory if needed.\n    // 如果当前的 alternate fiber 不存在，就创建一个新的 fiber,并处理为  alternate fiber。\n    workinprogress = createfiber(\n      current.tag,\n      pendingprops,\n      current.key,\n      current.mode,\n    );\n    workinprogress.elementtype = current.elementtype;\n    workinprogress.type = current.type;\n    workinprogress.statenode = current.statenode;\n\n    // double buffering pooling technique： 互相交替模拟版本池。\n    workinprogress.alternate = current;\n    // 将workinprogress挂载到current.alternate很好理解。\n    current.alternate = workinprogress;\n  } else {\n    // 如果  alternate fiber 以存在，将他修改为新的  alternate fiber。\n    // 减少重复创建对象带来的资源开销。\n    workinprogress.pendingprops = pendingprops;\n\n    // we already have an alternate.\n    // reset the effect tag.\n    workinprogress.effecttag = noeffect;\n\n    // the effect list is no longer valid.\n    workinprogress.nexteffect = null;\n    workinprogress.firsteffect = null;\n    workinprogress.lasteffect = null;\n  }\n\n  workinprogress.childexpirationtime = current.childexpirationtime;\n  workinprogress.expirationtime = current.expirationtime;\n\n  workinprogress.child = current.child;\n  workinprogress.memoizedprops = current.memoizedprops;\n  workinprogress.memoizedstate = current.memoizedstate;\n  workinprogress.updatequeue = current.updatequeue;\n\n  // clone the dependencies object. this is mutated during the render phase, so\n  // it cannot be shared with the current fiber.\n  const currentdependencies = current.dependencies;\n  workinprogress.dependencies =\n    currentdependencies === null\n      ? null\n      : {\n          expirationtime: currentdependencies.expirationtime,\n          firstcontext: currentdependencies.firstcontext,\n          responders: currentdependencies.responders,\n        };\n\n  // these will be overridden during the parent's reconciliation\n  workinprogress.sibling = current.sibling;\n  workinprogress.index = current.index;\n  workinprogress.ref = current.ref;\n\n  return workinprogress;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n * 这里如果 fiber 上已经有 alternate 就直接修改 alternate，不必创新创建 alternate fiber，可以大量减少创建对象带来的内存开销。\n * workinprogress 和 current 双向 alternate 记录是为了模拟 fiber 版本池的效果，这里就不需要复杂的数据结构来实现了。alternate 给了 fiber 更新更多的机动性。\n * workinprogress 代表了当前 fiber 的稳定版本，可以理解为 stable version，current 代表了 fiber 的更新版本，可以理解为 beta version。运行在页面上的永远是 workinprogress，而只有经过了 schedule 和 render，current 才会成为下一个 workinprogress。\n\n下面来看一下 fiber 中的特例 ———— fiberroot。\n\n\n# fiberroot\n\n\n# fiberroot 的定义\n\n在 react-reconciler 包中 reactfiberroot.js 文件中可以看到 fiberroot 有如下定义：\n\nexport type fiberroot = {\n  ...basefiberrootproperties,\n  ...profilingonlyfiberrootproperties,\n  ...suspensecallbackonlyfiberrootproperties,\n};\n\n\n1\n2\n3\n4\n5\n\n\n我们主要来看下 basefiberrootproperties。\n\ntype basefiberrootproperties = {|\n  // the type of root (legacy, batched, concurrent, etc.)\n  // fiberroot 的类型\n  // export type roottag = 0 | 1 | 2;\n  // export const legacyroot = 0;\n  // export const batchedroot = 1;\n  // export const concurrentroot = 2;\n  tag: roottag,\n\n  // any additional information from the host associated with this root.\n  // 与根节点相关的容器信息\n  containerinfo: any,\n  // used only by persistent updates.\n  pendingchildren: any,\n  // the currently active root fiber. this is the mutable root of the tree.\n  // 当前容器中激活的 fiber 对象\n  current: fiber,\n\n  pingcache:\n    | weakmap<thenable, set<expirationtime>>\n    | map<thenable, set<expirationtime>>\n    | null,\n  // 将被 commit 的 fiber 的到期时间\n  finishedexpirationtime: expirationtime,\n  // a finished work-in-progress hostroot that's ready to be committed.\n  // 将被 commit 的 fiber（hostroot）\n  finishedwork: fiber | null,\n  // timeout handle returned by settimeout. used to cancel a pending timeout, if\n  // it's superseded by a new one.\n  timeouthandle: timeouthandle | notimeout,\n  // top context object, used by rendersubtreeintocontainer\n  // 顶级的 context 对象\n  context: object | null,\n  pendingcontext: object | null,\n  // determines if we should attempt to hydrate on the initial mount\n  // 是否需要在初次渲染时进行hydrate\n  +hydrate: boolean,\n  // list of top-level batches. this list indicates whether a commit should be\n  // deferred. also contains completion callbacks.\n  // todo: lift this into the renderer\n  firstbatch: batch | null,\n  // node returned by scheduler.schedulecallback\n  callbacknode: *,\n  // expiration of the callback associated with this root\n  // callback 的超时时间\n  callbackexpirationtime: expirationtime,\n  // priority of the callback associated with this root\n  callbackpriority: reactprioritylevel,\n  // the earliest pending expiration time that exists in the tree\n  firstpendingtime: expirationtime,\n  // the earliest suspended expiration time that exists in the tree\n  firstsuspendedtime: expirationtime,\n  // the latest suspended expiration time that exists in the tree\n  lastsuspendedtime: expirationtime,\n  // the next known expiration time after the suspended range\n  nextknownpendinglevel: expirationtime,\n  // the latest time at which a suspended component pinged the root to\n  // render again\n  lastpingedtime: expirationtime,\n  lastexpiredtime: expirationtime,\n|};\n\n// fiberrootnode 工厂函数\nfunction fiberrootnode(containerinfo, tag, hydrate) {\n  this.tag = tag;\n  this.current = null;\n  this.containerinfo = containerinfo;\n  this.pendingchildren = null;\n  this.pingcache = null;\n  this.finishedexpirationtime = nowork;\n  this.finishedwork = null;\n  this.timeouthandle = notimeout;\n  this.context = null;\n  this.pendingcontext = null;\n  this.hydrate = hydrate;\n  this.firstbatch = null;\n  this.callbacknode = null;\n  this.callbackpriority = nopriority;\n  this.firstpendingtime = nowork;\n  this.firstsuspendedtime = nowork;\n  this.lastsuspendedtime = nowork;\n  this.nextknownpendinglevel = nowork;\n  this.lastpingedtime = nowork;\n  this.lastexpiredtime = nowork;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n\n# 创建 fiberroot\n\nfiberroot 由函数 createfiberroot 创建。\n\nfunction createfiberroot(\n  // 容器信息\n  containerinfo: any,\n  // fiberroot 的类型\n  tag: roottag,\n  hydrate: boolean,\n  hydrationcallbacks: null | suspensehydrationcallbacks,\n): fiberroot {\n  const root: fiberroot = (new fiberrootnode(containerinfo, tag, hydrate): any);\n  // 创建 hostfiberroot，可见 hostfiberroot 是 挂载到 fiberroot.current 上面的\n  const uninitializedfiber = createhostrootfiber(tag);\n  root.current = uninitializedfiber;\n  // 将 fiberroot 挂载到 hostfiberroot.statenode 上。\n  uninitializedfiber.statenode = root;\n\n  return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n由此可见：\n\n * double buffering pooling technique：这里运用了双缓冲技术，从 fiberroot 可以获取到 hostfiberroot 的 fiber 信息，同时从 hostfiberroot 也可以获取到 fiberroot 的容器信息。这样当 hostfiberroot 需要回退时，可以及时的从 fiberroot 恢复信息。\n * fiberroot 可以看做是真个 fibertree 的一个容器，记载着一些容器信息和即将被 commit 的 hostfiberroot 的信息；hostfiberroot 才是真正的 fibertree 的根节点。\n\n\n# hostfiberroot\n\nhostfiberroot 本质上是 fiber，是 fibertree 的根节点。\n\n创建 hostfiberroot 代码如下：\n\nfunction createhostrootfiber(tag: roottag): fiber {\n  let mode;\n  if (tag === concurrentroot) {\n    mode = concurrentmode | batchedmode | strictmode;\n  } else if (tag === batchedroot) {\n    mode = batchedmode | strictmode;\n  } else {\n    mode = nomode;\n  }\n\n  return createfiber(hostroot, null, null, mode);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 调用 createfiber 创建 hostfiberroot，说明 hostfiberroot 本质上还是 fiber，只是 fiber 被标记为了 hostroot。\n\n\n# reactchildfiber\n\n在生成 fiberroot 和 hostfiberroot 之后，还需要为子组件生成各自的子 fiber。这部分在 react-reconciler 包中 reactchildfiber.js 文件中实现。这个过程大致分为两步：\n\n// 调和 reactchildfiber\nexport const reconcilechildfibers = childreconciler(true);\n// 挂载 reactchildfiber\nexport const mountchildfibers = childreconciler(false);\n\n\n1\n2\n3\n4\n\n\n这部分较为复杂，之后详解。在更新器章节，还会用到这里的内容。",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"ReactChildFiber 的创建",frontmatter:{title:"ReactChildFiber 的创建",date:"2022-04-14T22:02:21.000Z",permalink:"/react/reconciliation/reactChildFiber/",categories:["react","reconciliation"],tags:[null]},regularPath:"/10.react/20.%E8%B0%83%E5%92%8C%EF%BC%88Reconciliation%EF%BC%89/20.reactChildFiber.html",relativePath:"10.react/20.调和（Reconciliation）/20.reactChildFiber.md",key:"v-27daf196",path:"/react/reconciliation/reactChildFiber/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"reconcileChildFibers",slug:"reconcilechildfibers",normalizedTitle:"reconcilechildfibers",charIndex:17},{level:2,title:"reconcileSingleElement",slug:"reconcilesingleelement",normalizedTitle:"reconcilesingleelement",charIndex:41},{level:2,title:"reconcileSinglePortal",slug:"reconcilesingleportal",normalizedTitle:"reconcilesingleportal",charIndex:67},{level:2,title:"reconcileSingleTextNode",slug:"reconcilesingletextnode",normalizedTitle:"reconcilesingletextnode",charIndex:92},{level:2,title:"reconcileChildrenArray",slug:"reconcilechildrenarray",normalizedTitle:"reconcilechildrenarray",charIndex:119},{level:3,title:"updateSlot",slug:"updateslot",normalizedTitle:"updateslot",charIndex:147},{level:3,title:"placeChild",slug:"placechild",normalizedTitle:"placechild",charIndex:163},{level:3,title:"updateFromMap",slug:"updatefrommap",normalizedTitle:"updatefrommap",charIndex:179},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:196}],readingTime:{text:"13 min read",minutes:12.85,time:771e3,words:2570},headersStr:"目录 reconcileChildFibers reconcileSingleElement reconcileSinglePortal reconcileSingleTextNode reconcileChildrenArray updateSlot placeChild updateFromMap 小结",content:"# 目录\n\n\n\n * 目录\n * reconcileChildFibers\n * reconcileSingleElement\n * reconcileSinglePortal\n * reconcileSingleTextNode\n * reconcileChildrenArray\n   * updateSlot\n   * placeChild\n   * updateFromMap\n * 小结\n\n\n\nReactChildFiber 的创建过程分为调和和挂载两种过程。这两个过程都调用了 ChildReconciler 这个函数。这个函数比较复杂，我们分解来看。\n\nexport const reconcileChildFibers = ChildReconciler(true);\nexport const mountChildFibers = ChildReconciler(false);\n\n\n1\n2\n\n\n\n# reconcileChildFibers\n\nChildReconciler(shouldTrackSideEffects)。\n\nChildReconciler 返回函数 reconcileChildFibers，根据传入参数 shouldTrackSideEffects 的值不同，分别起到了调和和挂载的功能。执行 reconcileChildFibers 将返回创建或者更新的 fiber。\n\n * mount 阶段：shouldTrackSideEffects 为 false，不需要追踪副作用，因为所有的副作用都执行一遍。\n * render 阶段：shouldTrackSideEffects 为 true，需要追踪副作用并在适当的时机执行。\n * 根据 shouldTrackSideEffects 这个值我们就可以判断当前的代码是运行在 mount 阶段还是 render 阶段。\n\n先来看看 reconcileChildFibers 这个函数：\n\nfunction reconcileChildFibers(\n  returnFiber: Fiber, // 父级 fiber\n  currentFirstChild: Fiber | null, // 当前的 child\n  newChild: any, // 新传来的 Child\n  expirationTime: ExpirationTime,\n): Fiber | null {\n  // This function is not recursive.\n  // If the top level item is an array, we treat it as a set of children,\n  // not as a fragment. Nested arrays on the other hand will be treated as\n  // fragment nodes. Recursion happens at the normal flow.\n\n  // Handle top level unkeyed fragments as if they were arrays.\n  // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n  // We treat the ambiguous cases above the same.\n  const isUnkeyedTopLevelFragment =\n    typeof newChild === 'object' &&\n    newChild !== null &&\n    newChild.type === REACT_FRAGMENT_TYPE &&\n    newChild.key === null;\n  // 如果是没有 key 值的 fragment 元素，则取他的 children，这个 Children 可能是数组。\n  // 这里是我们使用 <></> 语法糖的原理\n  if (isUnkeyedTopLevelFragment) {\n    newChild = newChild.props.children;\n  }\n\n  // Handle object types\n  const isObject = typeof newChild === 'object' && newChild !== null;\n  // newChild 是单独的 ReactElement。\n  if (isObject) {\n    switch (newChild.$$typeof) {\n      // 普通的 ReactElement（包括 fragment）\n      case REACT_ELEMENT_TYPE:\n        return placeSingleChild(\n          reconcileSingleElement(\n            returnFiber,\n            currentFirstChild,\n            newChild,\n            expirationTime,\n          ),\n        );\n      // Portal ReactElement\n      case REACT_PORTAL_TYPE:\n        return placeSingleChild(\n          reconcileSinglePortal(\n            returnFiber,\n            currentFirstChild,\n            newChild,\n            expirationTime,\n          ),\n        );\n    }\n  }\n  // newChild 字符或者数字\n  if (typeof newChild === 'string' || typeof newChild === 'number') {\n    return placeSingleChild(\n      reconcileSingleTextNode(\n        returnFiber,\n        currentFirstChild,\n        '' + newChild,\n        expirationTime,\n      ),\n    );\n  }\n\n  // children 数组\n  if (isArray(newChild)) {\n    return reconcileChildrenArray(\n      returnFiber,\n      currentFirstChild,\n      newChild,\n      expirationTime,\n    );\n  }\n\n  // newChild 是具有迭代器的对象\n  if (getIteratorFn(newChild)) {\n    return reconcileChildrenIterator(\n      returnFiber,\n      currentFirstChild,\n      newChild,\n      expirationTime,\n    );\n  }\n\n  if (isObject) {\n    throwOnInvalidObjectType(returnFiber, newChild);\n  }\n\n  if (__DEV__) {\n    if (typeof newChild === 'function') {\n      warnOnFunctionType();\n    }\n  }\n  // newChild 是 undefined 或者是具有 key 值的顶层的 fragment 元素\n  if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {\n    // If the new child is undefined, and the return fiber is a composite\n    // component, throw an error. If Fiber return types are disabled,\n    // we already threw above.\n    switch (returnFiber.tag) {\n      // 如果父级是类组件\n      case ClassComponent: {\n        if (__DEV__) {\n          const instance = returnFiber.stateNode;\n          if (instance.render._isMockFunction) {\n            // We allow auto-mocks to proceed as if they're returning null.\n            break;\n          }\n        }\n      }\n      // Intentionally fall through to the next case, which handles both\n      // functions and classes\n      // eslint-disable-next-lined no-fallthrough\n      // 如果父级是函数式组件\n      case FunctionComponent: {\n        const Component = returnFiber.type;\n        invariant(\n          false,\n          '%s(...): Nothing was returned from render. This usually means a ' +\n            'return statement is missing. Or, to render nothing, ' +\n            'return null.',\n          Component.displayName || Component.name || 'Component',\n        );\n      }\n    }\n  }\n  // 其余的情况视为空，直接将 currentFirstChild 删除并返回 null。\n  // Remaining cases are all treated as empty.\n  return deleteRemainingChildren(returnFiber, currentFirstChild);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n\n\n这个函数的主要作用就是根据父级 fiber（returnFiber）、当前的 fiber（currentFirstChild）和新传来的 ReactElement (newChild)，创建或者更新子级 fiber。\n\n分析一下主要的过程：\n\n * isUnkeyedTopLevelFragment 判断 NewChild 是否是 FRAGMENT，如果是 就取 newChild.props.children 。 这里是我们使用 <></> 语法糖的原理。\n * 判断 newChild 如果是普通的 ReactElement，分为 SingleElement 类型和 SinglePortal 类型，分别调用 reconcileSingleElement 和 reconcileSinglePortal 进行调和。\n * 判断 newChild 如果是 string 或者 number 类型，调用 reconcileSingleTextNode 进行调和。\n * 判断 newChild 如果是数组，调用 reconcileChildrenArray 进行调和。\n * 判断 newChild 如果是具有迭代器的对象，调用 reconcileChildrenIterator 进行调和。\n * 其他情况则根据是类组件还是函数组件进行报错处理。\n * placeSingleChild 为返回的 newFiber 在 shouldTrackSideEffects 为 true 时添加 \"Placement\" 的 effectTag 标记。\n\n\n# reconcileSingleElement\n\n这个函数对单一元素进行调和处理。\n\nfunction reconcileSingleElement(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  element: ReactElement,\n  expirationTime: ExpirationTime,\n): Fiber {\n  const key = element.key;\n  let child = currentFirstChild;\n  while (child !== null) {\n    // TODO: If key === null and child.key === null, then this only applies to\n    // the first item in the list.\n    if (child.key === key) {\n      // 找到element的 key 的 fiber\n      if (\n        child.tag === Fragment\n          ? element.type === REACT_FRAGMENT_TYPE\n          : child.elementType === element.type ||\n            // Keep this check inline so it only runs on the false path:\n            (__DEV__\n              ? isCompatibleFamilyForHotReloading(child, element)\n              : false)\n      ) {\n        // 如果是同种元素类型\n        // 删除其他兄弟节点\n        deleteRemainingChildren(returnFiber, child.sibling);\n        // merge props\n        const existing = useFiber(\n          child,\n          element.type === REACT_FRAGMENT_TYPE\n            ? element.props.children\n            : element.props,\n          expirationTime,\n        );\n        existing.ref = coerceRef(returnFiber, child, element);\n        existing.return = returnFiber;\n        if (__DEV__) {\n          existing._debugSource = element._source;\n          existing._debugOwner = element._owner;\n        }\n        // 只在 相同 key 相同元素类型时提前 return\n        return existing;\n      } else {\n        // 不是同种类型\n        deleteRemainingChildren(returnFiber, child);\n        break;\n      }\n    } else {\n      // 不等于 element 的 key 的 fiber\n      deleteChild(returnFiber, child);\n    }\n    child = child.sibling;\n  }\n // child 为 null，没有找到同 key 同类型的元素\n // 不能通过 merge props 的方法改造已有的 fiber,只能创建新的 fiber。\n  if (element.type === REACT_FRAGMENT_TYPE) {\n    // 从 fragment 元素创建 fiber\n    const created = createFiberFromFragment(\n      element.props.children,\n      returnFiber.mode,\n      expirationTime,\n      element.key,\n    );\n    created.return = returnFiber;\n    return created;\n  } else {\n    const created = createFiberFromElement(\n      element,\n      returnFiber.mode,\n      expirationTime,\n    );\n    created.ref = coerceRef(returnFiber, currentFirstChild, element);\n    created.return = returnFiber;\n    return created;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n * 在 while 循环里试图从 child 及其兄弟节点中找到与 newChild 的 key 值相同的 fiber，如果没找到 child 及其兄弟节点全部会被删除，如果找到了而且刚好是同种类型的元素（包括 fragment），这时就将剩余的兄弟节点全部删除，将找到的 fiber 改造为新的 fiber。如果 key 相同但是元素不相同，同样删除所有的节点，走后面新建 fiber 的流程。\n * 在原有的 fiber 上改造成新的 fiber 是函数 useFiber 实现的。 createWorkInProgress 会从 fiber 中去除 workInProgress 的 fiber 并对 pendingProps 进行融合。\n\nfunction useFiber(\n  fiber: Fiber,\n  pendingProps: mixed,\n  expirationTime: ExpirationTime,\n): Fiber {\n  // merge fiber props 并 返回新的 fiber\n  // We currently set sibling to null and index to 0 here because it is easy\n  // to forget to do before returning it. E.g. for the single child case.\n  // 创建 work-in-progress 的 fiber，注入 element 的 props\n  const clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n  clone.index = 0;\n  clone.sibling = null;\n  return clone;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# reconcileSinglePortal\n\n这个函数是对单一 portal 元素进行调和。原理与 reconcileSingleElement 相似，不再赘述。\n\n\n# reconcileSingleTextNode\n\n这个函数对文本节点进行调和。与普通节点不同的是，文本节点不用通过比较 key 值来减少 fiber 创建的损耗，只需要将原来的内容清除，创建或者更新为新的文本节点即可。\n\nfunction reconcileSingleTextNode(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  textContent: string,\n  expirationTime: ExpirationTime,\n): Fiber {\n  // There's no need to check for keys on text nodes since we don't have a\n  // way to define them.\n  // 字符节点不用比较 key，只要原来 child 有值且为 HostText，就可以复用次 fiber\n  // 文本节点不用遍历兄弟节点\n  if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n    // We already have an existing node so let's just update it and delete\n    // the rest.\n    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n    const existing = useFiber(currentFirstChild, textContent, expirationTime);\n    existing.return = returnFiber;\n    return existing;\n  }\n  // The existing first child is not a text node so we need to create one\n  // and delete the existing ones.\n  // 否则直接本剧 text 创建一个新的 fiber\n  deleteRemainingChildren(returnFiber, currentFirstChild);\n  const created = createFiberFromText(\n    textContent,\n    returnFiber.mode,\n    expirationTime,\n  );\n  created.return = returnFiber;\n  return created;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n可以看到，这里采用的思路是：\n\n * 如果原来就是文本节点，也就是 currentFirstChild.tag === HostText 时，直接删除其余的兄弟节点，并且将当前的 fiber 改造成新的文本节点，即调用 useFiber 函数。\n * 否则直接删除包括当前节点在内的所有节点，并且调用 createFiberFromText 创建新的文本节点。\n\n\n# reconcileChildrenArray\n\n上面讨论的都是对单一的节点进行调和，包括普通的 ReactElement 元素、string、Number、textNode 等，这里这个函数就是对上述单一元素所组成的数组进行调和。\n\n在分析函数 reconcileChildrenArray 之前，我们先理清楚两个概念：oldFiber 和 newChildren。oldFiber 是当前的稳定的 fiber 链表，oldFiber.sibling 指向下一个 fiber 节点，其本质上是 fiber 链表。newChildren 指的是从渲染器中更新回调中新的正在更新的 ReactElement 数组，其本质上是 ReactElement 数组。在这里我们可以把两者都看作是数组进行理解。\n\n下面的 oldFiber 我将理解为 old children，其每一项是 old child；newChildren 我将理解为 old children，每一项为 new child。\n\n下面我们来来重点看下 reconcileChildrenArray 这个函数：\n\n function reconcileChildrenArray(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  newChildren: Array<*>, // newChildren 是 ReactElement 数组\n  expirationTime: ExpirationTime,\n): Fiber | null {\n\n  if (__DEV__) {\n    // First, validate keys.\n    // dev 环境下会对 key 值不合法的元素进行警告\n    let knownKeys = null;\n    for (let i = 0; i < newChildren.length; i++) {\n      const child = newChildren[i];\n      knownKeys = warnOnInvalidKey(child, knownKeys);\n    }\n  }\n\n  let resultingFirstChild: Fiber | null = null;\n  let previousNewFiber: Fiber | null = null;\n\n  let oldFiber = currentFirstChild;\n  let lastPlacedIndex = 0;\n  let newIdx = 0;\n  let nextOldFiber = null;\n  // 循环 new children 数组\n  for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n    // 如果 old child 的下标大于与之对等的 new child 的下标，延迟推移一次\n    if (oldFiber.index > newIdx) {\n      nextOldFiber = oldFiber;\n      // 这里将 oldFiber 置null，下面的 updateSlot 就会直接覆盖此节点位置。\n      // 但是 oldFiber 的节点内容没有丢，后面还会继续用它进行比较并复用\n      oldFiber = null;\n    } else {\n      // 循环的过程中 old children也在后移，这里是在逐位比较\n      // 到这里说明 oldFiber.index <= newIdx，由于newIdx 初始未 0，所以初始时 oldFiber.index <=0\n      // 所以 oldFiber.index === 0，此后依次推移，index 就是相对应的\n      nextOldFiber = oldFiber.sibling;\n    }\n    // 如果 key 值匹配则返回 fiber ，否则返回 null。\n    const newFiber = updateSlot(\n      returnFiber,\n      oldFiber,\n      newChildren[newIdx],\n      expirationTime,\n    );\n    // 这种情况表示遇到 key 值不匹配的问题了，表明当前的情况是更改\n    if (newFiber === null) {\n      // TODO: This breaks on empty slots like null children. That's\n      // unfortunate because it triggers the slow path all the time. We need\n      // a better way to communicate whether this was a miss or null,\n      // boolean, undefined, etc.\n      if (oldFiber === null) {\n        oldFiber = nextOldFiber;\n      }\n      // 提前跳出循环，处理更改的逻辑\n      break;\n    }\n    // 如果在更新阶段，old child 将会被移除，因为此节点不会被重用\n    // 因为 old child 已经被记载在 nextOldFiber 中，这里删除是为了防止再次被循环到\n    if (shouldTrackSideEffects) {\n      if (oldFiber && newFiber.alternate === null) {\n        // We matched the slot, but we didn't reuse the existing fiber, so we\n        // need to delete the existing child.\n        deleteChild(returnFiber, oldFiber);\n      }\n    }\n    // 放置节点\n    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n    // resultingFirstChild 将以链表的方式记录 new children 的数组\n    if (previousNewFiber === null) {\n      // TODO: Move out of the loop. This only happens for the first run.\n      resultingFirstChild = newFiber;\n    } else {\n      // TODO: Defer siblings if we're not at the right index for this slot.\n      // I.e. if we had null values before, then we want to defer this\n      // for each null value. However, we also don't want to call updateSlot\n      // with the previous one.\n      previousNewFiber.sibling = newFiber;\n    }\n    previousNewFiber = newFiber;\n    // 移动到下一个 old child\n    oldFiber = nextOldFiber;\n  }\n  // 当上面循环完毕，说明 new children 或者 old children 已经执行完了，由2种情况：old children 有剩余、new children 有剩余\n  // 分别对应的情景为：删除，增加\n  // 如果 new children 循环完了，说明 old children 有剩余，剩余的可以直接删除\n  if (newIdx === newChildren.length) {\n    // We've reached the end of the new children. We can delete the rest.\n    deleteRemainingChildren(returnFiber, oldFiber);\n    return resultingFirstChild;\n  }\n  // 如果 old children 循环完了，剩余的 new children 就可以直接照搬过来\n  if (oldFiber === null) {\n    // If we don't have any more existing children we can choose a fast path\n    // since the rest will all be insertions.\n    // 循环剩余的new children\n    for (; newIdx < newChildren.length; newIdx++) {\n      // 创建 fiber \n      const newFiber = createChild(\n        returnFiber,\n        newChildren[newIdx],\n        expirationTime,\n      );\n      // 跳过非法的元素\n      if (newFiber === null) {\n        continue;\n      }\n      // 放置节点\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      // 挂载到 resultingFirstChild 链表上\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n    }\n    // 这里将处理完毕的 new children 返回\n    return resultingFirstChild;\n  }\n  // 上面两种情况都 return ，这里属于第 3 中情况：更改\n  // 更改是提前跳出的，可见更改的优先级要大于删除和增加\n  // 根据 old children 的 key 值建立一个 key 和 fiber 的映射\n  // Add all children to a key map for quick lookups.\n  const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n  // Keep scanning and use the map to restore deleted items as moves.\n  // 循环后面 key 值不匹配的 ne children\n  for (; newIdx < newChildren.length; newIdx++) {\n    // 试图从 map 中查找 key 值相同的 old child 以复用、\n    // updateFromMap 中会根据是否可复用选择复用或者新建 Fiber\n    const newFiber = updateFromMap(\n      existingChildren,\n      returnFiber,\n      newIdx,\n      newChildren[newIdx],\n      expirationTime,\n    );\n    // 如果找到则放入resultingFirstChild 中\n    if (newFiber !== null) {\n      if (shouldTrackSideEffects) {\n        if (newFiber.alternate !== null) {\n          // The new fiber is a work in progress, but if there exists a\n          // current, that means that we reused the fiber. We need to delete\n          // it from the child list so that we don't add it to the deletion\n          // list.\n          // 从 map 中已找到的值删除\n          existingChildren.delete(\n            newFiber.key === null ? newIdx : newFiber.key,\n          );\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        resultingFirstChild = newFiber;\n      } else {\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n    }\n  }\n\n  if (shouldTrackSideEffects) {\n    // Any existing children that weren't consumed above were deleted. We need\n    // to add them to the deletion list.\n    // 其余不能复用的 old children 全部删除\n    existingChildren.forEach(child => deleteChild(returnFiber, child));\n  }\n\n  return resultingFirstChild;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n\n\n总体来看，react 对 childFiberArray 的调和方法大概是这样：\n\n * 分为改动、增加和删除三个场景，其中改动的优先级要大于删除和增加。\n * 先将 old children 和 new children 按照 index 逐个对比，只要遇到有 key 值不匹配的（updateSlot 函数），就进入改动场景，前面匹配的直接复用。\n * 改动场景中会将剩余的 old children 组成 Map<key, fiber> ，循环剩余的 new children，如果能在 map 中找到匹配 key 值的节点就复用，否则就创建（updateFromMap 函数）。\n * 如果没有进入改动场景，那就根据 old children 和 new children 谁有剩余进入删除或者增加的场景。\n * 如果 old children 有剩余，则进入删除场景，将剩余的 old children 全部删除。\n * 如果 new children 有剩余，则进入增加场景，剩余的 new children 全部新建并插入。\n * 最终返回挂载了处理过的 new fibers 链表（resultingFirstChild）。\n\n这里的改动、增加和删除三个场景和列表中的改动、增加和删除三个操作是不一样的，可以看到我们针对列表所做的大部分改动、增加和删除操作都是由 reconcileChildrenArray 的改动场景来完成的，只有在列表的末尾的增加和删除操作才会由 reconcileChildrenArray 的增加和删除场景去完成。这也说明可了 key 值对列表的重要性，在渲染阶段，利用 key 值来复用节点极大的降低了节点的创建成本、提高了页面的更新效率。\n\n> 现在我们知道了 key 值对于 fiber 的重要的优化意义。那么除了我们在列表中手动给节点添加的 key 值，其余的 key 值又是如何维护的呢？\n\n在前文 createFiber 中，我们知道 key 值是通过传入来创建 fiber 的。通过搜索得知，在各种形式的 fiber 创建方式中 key 都是传入的参数。我们在 createFiber 中打印出相应的 key 值，然后添加下面的测试代码：\n\nconst List = () => {\n  const arr = new Array(20).fill(0);\n  return arr.map(a => <p key={Math.random()}>{a}</p>)\n}\n\n\n1\n2\n3\n4\n\n\n打印效果如下：\n\n这说明 key 值的重要的优化作用主要发生在增删改操作频繁的列表的渲染中，在其他的地方作用并不明显，因为并没有可复用节点的需求。\n\n----------------------------------------\n\n下面我们来单独看看几个小函数：\n\n\n# updateSlot\n\n这个函数逐个比较 old children 和 new children 的 key 值是否相等，相等则复用，不等则返回 null，创建跳出循环的条件。\n\nfunction updateSlot(\n  returnFiber: Fiber,\n  oldFiber: Fiber | null,\n  newChild: any,\n  expirationTime: ExpirationTime,\n): Fiber | null {\n  // Update the fiber if the keys match, otherwise return null.\n\n  const key = oldFiber !== null ? oldFiber.key : null;\n\n  if (typeof newChild === 'string' || typeof newChild === 'number') {\n    // Text nodes don't have keys. If the previous node is implicitly keyed\n    // we can continue to replace it without aborting even if it is not a text\n    // node.\n    if (key !== null) {\n      return null;\n    }\n    return updateTextNode(\n      returnFiber,\n      oldFiber,\n      '' + newChild,\n      expirationTime,\n    );\n  }\n\n  if (typeof newChild === 'object' && newChild !== null) {\n    switch (newChild.$$typeof) {\n      case REACT_ELEMENT_TYPE: {\n        if (newChild.key === key) {\n          if (newChild.type === REACT_FRAGMENT_TYPE) {\n            return updateFragment(\n              returnFiber,\n              oldFiber,\n              newChild.props.children,\n              expirationTime,\n              key,\n            );\n          }\n          return updateElement(\n            returnFiber,\n            oldFiber,\n            newChild,\n            expirationTime,\n          );\n        } else {\n          return null;\n        }\n      }\n      case REACT_PORTAL_TYPE: {\n        if (newChild.key === key) {\n          return updatePortal(\n            returnFiber,\n            oldFiber,\n            newChild,\n            expirationTime,\n          );\n        } else {\n          return null;\n        }\n      }\n    }\n\n    if (isArray(newChild) || getIteratorFn(newChild)) {\n      if (key !== null) {\n        return null;\n      }\n\n      return updateFragment(\n        returnFiber,\n        oldFiber,\n        newChild,\n        expirationTime,\n        null,\n      );\n    }\n\n    throwOnInvalidObjectType(returnFiber, newChild);\n  }\n\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n注意，在 updateXXX 的函数中的逻辑都是对先判断 fiber 是否可更新，否则再去创建 fiber。 这里参照上文中对文本、普通 ReactElement、PortalElement 等单一节点的调和方法。\n\n\n# placeChild\n\n这个函数为 fiber 添加 'Placement' 标签，也就是放置节点。节点放置分为 move 和 insertion 两种操作。\n\nfunction placeChild(\n  newFiber: Fiber,\n  lastPlacedIndex: number,\n  newIndex: number,\n): number {\n  newFiber.index = newIndex;\n  if (!shouldTrackSideEffects) {\n    // Noop.\n    return lastPlacedIndex;\n  }\n  const current = newFiber.alternate;\n  if (current !== null) {\n    const oldIndex = current.index;\n    // 愿挨的 index 与 新的 index 不一致，移动节点\n    if (oldIndex < lastPlacedIndex) {\n      // This is a move.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    } else {\n      // index 一致，不必移动，保持原位\n      // This item can stay in place.\n      return oldIndex;\n    }\n  } else {\n    // 原来没有的直接插入到指定的 index 位置。\n    // This is an insertion.\n    newFiber.effectTag = Placement;\n    return lastPlacedIndex;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n从之前的分析中可以看出：\n\n * 对于 new children 中的每一个节点，都需要调用一下 placeChild 进行 “放置”。事实上对于，无论是 'move' 还是 'insertion' 都是加入了 'Placement' 标签。这是因为为 neFibers 转化为 DomTree 时，只要是标记了 'Placement' 标签的节点，都会被按照新的 fiber.index 来调整位置。这时我们再来看 Fiber 定义中的 index，概念就更加清晰了。\n\n\n# updateFromMap\n\n这个函数从 old children 中复用 fiber，如果没有找到则创建新的 fiber。\n\n function updateFromMap(\n  existingChildren: Map<string | number, Fiber>,\n  returnFiber: Fiber,\n  newIdx: number,\n  newChild: any,\n  expirationTime: ExpirationTime,\n): Fiber | null {\n  if (typeof newChild === 'string' || typeof newChild === 'number') {\n    // Text nodes don't have keys, so we neither have to check the old nor\n    // new node for the key. If both are text nodes, they match.\n    const matchedFiber = existingChildren.get(newIdx) || null;\n    return updateTextNode(\n      returnFiber,\n      matchedFiber,\n      '' + newChild,\n      expirationTime,\n    );\n  }\n\n  if (typeof newChild === 'object' && newChild !== null) {\n    switch (newChild.$$typeof) {\n      case REACT_ELEMENT_TYPE: {\n        const matchedFiber =\n          existingChildren.get(\n            newChild.key === null ? newIdx : newChild.key,\n          ) || null;\n        if (newChild.type === REACT_FRAGMENT_TYPE) {\n          return updateFragment(\n            returnFiber,\n            matchedFiber,\n            newChild.props.children,\n            expirationTime,\n            newChild.key,\n          );\n        }\n        return updateElement(\n          returnFiber,\n          matchedFiber,\n          newChild,\n          expirationTime,\n        );\n      }\n      case REACT_PORTAL_TYPE: {\n        const matchedFiber =\n          existingChildren.get(\n            newChild.key === null ? newIdx : newChild.key,\n          ) || null;\n        return updatePortal(\n          returnFiber,\n          matchedFiber,\n          newChild,\n          expirationTime,\n        );\n      }\n    }\n\n    if (isArray(newChild) || getIteratorFn(newChild)) {\n      const matchedFiber = existingChildren.get(newIdx) || null;\n      return updateFragment(\n        returnFiber,\n        matchedFiber,\n        newChild,\n        expirationTime,\n        null,\n      );\n    }\n\n    throwOnInvalidObjectType(returnFiber, newChild);\n  }\n\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n * 从 existingChildren 中取出 matchedFiber 进行复用。\n * 根据不同的类型进行更新或者创建 fiber。\n\n上面我们理清楚了 reconcileChildFibers 的过程，具体在 mount 阶段和 render 阶段会有一些不同。\n\n * mount 阶段主要注重于创建 fiber。\n * render 阶段在创建 fiber 之前要考虑是否可以复用，减少创建成本。\n\n\n# 小结\n\n这篇文章详述了 ReactChildFiber 的创建过程，包括 SingleChild 和 ChildArray 的创建过程，理解 ReactElement 的输入是如何更新和转换为 Fiber 的，而整个 VNode Tree 转化为 FiberTree 正在这一过程的递归。",normalizedContent:"# 目录\n\n\n\n * 目录\n * reconcilechildfibers\n * reconcilesingleelement\n * reconcilesingleportal\n * reconcilesingletextnode\n * reconcilechildrenarray\n   * updateslot\n   * placechild\n   * updatefrommap\n * 小结\n\n\n\nreactchildfiber 的创建过程分为调和和挂载两种过程。这两个过程都调用了 childreconciler 这个函数。这个函数比较复杂，我们分解来看。\n\nexport const reconcilechildfibers = childreconciler(true);\nexport const mountchildfibers = childreconciler(false);\n\n\n1\n2\n\n\n\n# reconcilechildfibers\n\nchildreconciler(shouldtracksideeffects)。\n\nchildreconciler 返回函数 reconcilechildfibers，根据传入参数 shouldtracksideeffects 的值不同，分别起到了调和和挂载的功能。执行 reconcilechildfibers 将返回创建或者更新的 fiber。\n\n * mount 阶段：shouldtracksideeffects 为 false，不需要追踪副作用，因为所有的副作用都执行一遍。\n * render 阶段：shouldtracksideeffects 为 true，需要追踪副作用并在适当的时机执行。\n * 根据 shouldtracksideeffects 这个值我们就可以判断当前的代码是运行在 mount 阶段还是 render 阶段。\n\n先来看看 reconcilechildfibers 这个函数：\n\nfunction reconcilechildfibers(\n  returnfiber: fiber, // 父级 fiber\n  currentfirstchild: fiber | null, // 当前的 child\n  newchild: any, // 新传来的 child\n  expirationtime: expirationtime,\n): fiber | null {\n  // this function is not recursive.\n  // if the top level item is an array, we treat it as a set of children,\n  // not as a fragment. nested arrays on the other hand will be treated as\n  // fragment nodes. recursion happens at the normal flow.\n\n  // handle top level unkeyed fragments as if they were arrays.\n  // this leads to an ambiguity between <>{[...]}</> and <>...</>.\n  // we treat the ambiguous cases above the same.\n  const isunkeyedtoplevelfragment =\n    typeof newchild === 'object' &&\n    newchild !== null &&\n    newchild.type === react_fragment_type &&\n    newchild.key === null;\n  // 如果是没有 key 值的 fragment 元素，则取他的 children，这个 children 可能是数组。\n  // 这里是我们使用 <></> 语法糖的原理\n  if (isunkeyedtoplevelfragment) {\n    newchild = newchild.props.children;\n  }\n\n  // handle object types\n  const isobject = typeof newchild === 'object' && newchild !== null;\n  // newchild 是单独的 reactelement。\n  if (isobject) {\n    switch (newchild.$$typeof) {\n      // 普通的 reactelement（包括 fragment）\n      case react_element_type:\n        return placesinglechild(\n          reconcilesingleelement(\n            returnfiber,\n            currentfirstchild,\n            newchild,\n            expirationtime,\n          ),\n        );\n      // portal reactelement\n      case react_portal_type:\n        return placesinglechild(\n          reconcilesingleportal(\n            returnfiber,\n            currentfirstchild,\n            newchild,\n            expirationtime,\n          ),\n        );\n    }\n  }\n  // newchild 字符或者数字\n  if (typeof newchild === 'string' || typeof newchild === 'number') {\n    return placesinglechild(\n      reconcilesingletextnode(\n        returnfiber,\n        currentfirstchild,\n        '' + newchild,\n        expirationtime,\n      ),\n    );\n  }\n\n  // children 数组\n  if (isarray(newchild)) {\n    return reconcilechildrenarray(\n      returnfiber,\n      currentfirstchild,\n      newchild,\n      expirationtime,\n    );\n  }\n\n  // newchild 是具有迭代器的对象\n  if (getiteratorfn(newchild)) {\n    return reconcilechildreniterator(\n      returnfiber,\n      currentfirstchild,\n      newchild,\n      expirationtime,\n    );\n  }\n\n  if (isobject) {\n    throwoninvalidobjecttype(returnfiber, newchild);\n  }\n\n  if (__dev__) {\n    if (typeof newchild === 'function') {\n      warnonfunctiontype();\n    }\n  }\n  // newchild 是 undefined 或者是具有 key 值的顶层的 fragment 元素\n  if (typeof newchild === 'undefined' && !isunkeyedtoplevelfragment) {\n    // if the new child is undefined, and the return fiber is a composite\n    // component, throw an error. if fiber return types are disabled,\n    // we already threw above.\n    switch (returnfiber.tag) {\n      // 如果父级是类组件\n      case classcomponent: {\n        if (__dev__) {\n          const instance = returnfiber.statenode;\n          if (instance.render._ismockfunction) {\n            // we allow auto-mocks to proceed as if they're returning null.\n            break;\n          }\n        }\n      }\n      // intentionally fall through to the next case, which handles both\n      // functions and classes\n      // eslint-disable-next-lined no-fallthrough\n      // 如果父级是函数式组件\n      case functioncomponent: {\n        const component = returnfiber.type;\n        invariant(\n          false,\n          '%s(...): nothing was returned from render. this usually means a ' +\n            'return statement is missing. or, to render nothing, ' +\n            'return null.',\n          component.displayname || component.name || 'component',\n        );\n      }\n    }\n  }\n  // 其余的情况视为空，直接将 currentfirstchild 删除并返回 null。\n  // remaining cases are all treated as empty.\n  return deleteremainingchildren(returnfiber, currentfirstchild);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n\n\n这个函数的主要作用就是根据父级 fiber（returnfiber）、当前的 fiber（currentfirstchild）和新传来的 reactelement (newchild)，创建或者更新子级 fiber。\n\n分析一下主要的过程：\n\n * isunkeyedtoplevelfragment 判断 newchild 是否是 fragment，如果是 就取 newchild.props.children 。 这里是我们使用 <></> 语法糖的原理。\n * 判断 newchild 如果是普通的 reactelement，分为 singleelement 类型和 singleportal 类型，分别调用 reconcilesingleelement 和 reconcilesingleportal 进行调和。\n * 判断 newchild 如果是 string 或者 number 类型，调用 reconcilesingletextnode 进行调和。\n * 判断 newchild 如果是数组，调用 reconcilechildrenarray 进行调和。\n * 判断 newchild 如果是具有迭代器的对象，调用 reconcilechildreniterator 进行调和。\n * 其他情况则根据是类组件还是函数组件进行报错处理。\n * placesinglechild 为返回的 newfiber 在 shouldtracksideeffects 为 true 时添加 \"placement\" 的 effecttag 标记。\n\n\n# reconcilesingleelement\n\n这个函数对单一元素进行调和处理。\n\nfunction reconcilesingleelement(\n  returnfiber: fiber,\n  currentfirstchild: fiber | null,\n  element: reactelement,\n  expirationtime: expirationtime,\n): fiber {\n  const key = element.key;\n  let child = currentfirstchild;\n  while (child !== null) {\n    // todo: if key === null and child.key === null, then this only applies to\n    // the first item in the list.\n    if (child.key === key) {\n      // 找到element的 key 的 fiber\n      if (\n        child.tag === fragment\n          ? element.type === react_fragment_type\n          : child.elementtype === element.type ||\n            // keep this check inline so it only runs on the false path:\n            (__dev__\n              ? iscompatiblefamilyforhotreloading(child, element)\n              : false)\n      ) {\n        // 如果是同种元素类型\n        // 删除其他兄弟节点\n        deleteremainingchildren(returnfiber, child.sibling);\n        // merge props\n        const existing = usefiber(\n          child,\n          element.type === react_fragment_type\n            ? element.props.children\n            : element.props,\n          expirationtime,\n        );\n        existing.ref = coerceref(returnfiber, child, element);\n        existing.return = returnfiber;\n        if (__dev__) {\n          existing._debugsource = element._source;\n          existing._debugowner = element._owner;\n        }\n        // 只在 相同 key 相同元素类型时提前 return\n        return existing;\n      } else {\n        // 不是同种类型\n        deleteremainingchildren(returnfiber, child);\n        break;\n      }\n    } else {\n      // 不等于 element 的 key 的 fiber\n      deletechild(returnfiber, child);\n    }\n    child = child.sibling;\n  }\n // child 为 null，没有找到同 key 同类型的元素\n // 不能通过 merge props 的方法改造已有的 fiber,只能创建新的 fiber。\n  if (element.type === react_fragment_type) {\n    // 从 fragment 元素创建 fiber\n    const created = createfiberfromfragment(\n      element.props.children,\n      returnfiber.mode,\n      expirationtime,\n      element.key,\n    );\n    created.return = returnfiber;\n    return created;\n  } else {\n    const created = createfiberfromelement(\n      element,\n      returnfiber.mode,\n      expirationtime,\n    );\n    created.ref = coerceref(returnfiber, currentfirstchild, element);\n    created.return = returnfiber;\n    return created;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n * 在 while 循环里试图从 child 及其兄弟节点中找到与 newchild 的 key 值相同的 fiber，如果没找到 child 及其兄弟节点全部会被删除，如果找到了而且刚好是同种类型的元素（包括 fragment），这时就将剩余的兄弟节点全部删除，将找到的 fiber 改造为新的 fiber。如果 key 相同但是元素不相同，同样删除所有的节点，走后面新建 fiber 的流程。\n * 在原有的 fiber 上改造成新的 fiber 是函数 usefiber 实现的。 createworkinprogress 会从 fiber 中去除 workinprogress 的 fiber 并对 pendingprops 进行融合。\n\nfunction usefiber(\n  fiber: fiber,\n  pendingprops: mixed,\n  expirationtime: expirationtime,\n): fiber {\n  // merge fiber props 并 返回新的 fiber\n  // we currently set sibling to null and index to 0 here because it is easy\n  // to forget to do before returning it. e.g. for the single child case.\n  // 创建 work-in-progress 的 fiber，注入 element 的 props\n  const clone = createworkinprogress(fiber, pendingprops, expirationtime);\n  clone.index = 0;\n  clone.sibling = null;\n  return clone;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# reconcilesingleportal\n\n这个函数是对单一 portal 元素进行调和。原理与 reconcilesingleelement 相似，不再赘述。\n\n\n# reconcilesingletextnode\n\n这个函数对文本节点进行调和。与普通节点不同的是，文本节点不用通过比较 key 值来减少 fiber 创建的损耗，只需要将原来的内容清除，创建或者更新为新的文本节点即可。\n\nfunction reconcilesingletextnode(\n  returnfiber: fiber,\n  currentfirstchild: fiber | null,\n  textcontent: string,\n  expirationtime: expirationtime,\n): fiber {\n  // there's no need to check for keys on text nodes since we don't have a\n  // way to define them.\n  // 字符节点不用比较 key，只要原来 child 有值且为 hosttext，就可以复用次 fiber\n  // 文本节点不用遍历兄弟节点\n  if (currentfirstchild !== null && currentfirstchild.tag === hosttext) {\n    // we already have an existing node so let's just update it and delete\n    // the rest.\n    deleteremainingchildren(returnfiber, currentfirstchild.sibling);\n    const existing = usefiber(currentfirstchild, textcontent, expirationtime);\n    existing.return = returnfiber;\n    return existing;\n  }\n  // the existing first child is not a text node so we need to create one\n  // and delete the existing ones.\n  // 否则直接本剧 text 创建一个新的 fiber\n  deleteremainingchildren(returnfiber, currentfirstchild);\n  const created = createfiberfromtext(\n    textcontent,\n    returnfiber.mode,\n    expirationtime,\n  );\n  created.return = returnfiber;\n  return created;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n可以看到，这里采用的思路是：\n\n * 如果原来就是文本节点，也就是 currentfirstchild.tag === hosttext 时，直接删除其余的兄弟节点，并且将当前的 fiber 改造成新的文本节点，即调用 usefiber 函数。\n * 否则直接删除包括当前节点在内的所有节点，并且调用 createfiberfromtext 创建新的文本节点。\n\n\n# reconcilechildrenarray\n\n上面讨论的都是对单一的节点进行调和，包括普通的 reactelement 元素、string、number、textnode 等，这里这个函数就是对上述单一元素所组成的数组进行调和。\n\n在分析函数 reconcilechildrenarray 之前，我们先理清楚两个概念：oldfiber 和 newchildren。oldfiber 是当前的稳定的 fiber 链表，oldfiber.sibling 指向下一个 fiber 节点，其本质上是 fiber 链表。newchildren 指的是从渲染器中更新回调中新的正在更新的 reactelement 数组，其本质上是 reactelement 数组。在这里我们可以把两者都看作是数组进行理解。\n\n下面的 oldfiber 我将理解为 old children，其每一项是 old child；newchildren 我将理解为 old children，每一项为 new child。\n\n下面我们来来重点看下 reconcilechildrenarray 这个函数：\n\n function reconcilechildrenarray(\n  returnfiber: fiber,\n  currentfirstchild: fiber | null,\n  newchildren: array<*>, // newchildren 是 reactelement 数组\n  expirationtime: expirationtime,\n): fiber | null {\n\n  if (__dev__) {\n    // first, validate keys.\n    // dev 环境下会对 key 值不合法的元素进行警告\n    let knownkeys = null;\n    for (let i = 0; i < newchildren.length; i++) {\n      const child = newchildren[i];\n      knownkeys = warnoninvalidkey(child, knownkeys);\n    }\n  }\n\n  let resultingfirstchild: fiber | null = null;\n  let previousnewfiber: fiber | null = null;\n\n  let oldfiber = currentfirstchild;\n  let lastplacedindex = 0;\n  let newidx = 0;\n  let nextoldfiber = null;\n  // 循环 new children 数组\n  for (; oldfiber !== null && newidx < newchildren.length; newidx++) {\n    // 如果 old child 的下标大于与之对等的 new child 的下标，延迟推移一次\n    if (oldfiber.index > newidx) {\n      nextoldfiber = oldfiber;\n      // 这里将 oldfiber 置null，下面的 updateslot 就会直接覆盖此节点位置。\n      // 但是 oldfiber 的节点内容没有丢，后面还会继续用它进行比较并复用\n      oldfiber = null;\n    } else {\n      // 循环的过程中 old children也在后移，这里是在逐位比较\n      // 到这里说明 oldfiber.index <= newidx，由于newidx 初始未 0，所以初始时 oldfiber.index <=0\n      // 所以 oldfiber.index === 0，此后依次推移，index 就是相对应的\n      nextoldfiber = oldfiber.sibling;\n    }\n    // 如果 key 值匹配则返回 fiber ，否则返回 null。\n    const newfiber = updateslot(\n      returnfiber,\n      oldfiber,\n      newchildren[newidx],\n      expirationtime,\n    );\n    // 这种情况表示遇到 key 值不匹配的问题了，表明当前的情况是更改\n    if (newfiber === null) {\n      // todo: this breaks on empty slots like null children. that's\n      // unfortunate because it triggers the slow path all the time. we need\n      // a better way to communicate whether this was a miss or null,\n      // boolean, undefined, etc.\n      if (oldfiber === null) {\n        oldfiber = nextoldfiber;\n      }\n      // 提前跳出循环，处理更改的逻辑\n      break;\n    }\n    // 如果在更新阶段，old child 将会被移除，因为此节点不会被重用\n    // 因为 old child 已经被记载在 nextoldfiber 中，这里删除是为了防止再次被循环到\n    if (shouldtracksideeffects) {\n      if (oldfiber && newfiber.alternate === null) {\n        // we matched the slot, but we didn't reuse the existing fiber, so we\n        // need to delete the existing child.\n        deletechild(returnfiber, oldfiber);\n      }\n    }\n    // 放置节点\n    lastplacedindex = placechild(newfiber, lastplacedindex, newidx);\n    // resultingfirstchild 将以链表的方式记录 new children 的数组\n    if (previousnewfiber === null) {\n      // todo: move out of the loop. this only happens for the first run.\n      resultingfirstchild = newfiber;\n    } else {\n      // todo: defer siblings if we're not at the right index for this slot.\n      // i.e. if we had null values before, then we want to defer this\n      // for each null value. however, we also don't want to call updateslot\n      // with the previous one.\n      previousnewfiber.sibling = newfiber;\n    }\n    previousnewfiber = newfiber;\n    // 移动到下一个 old child\n    oldfiber = nextoldfiber;\n  }\n  // 当上面循环完毕，说明 new children 或者 old children 已经执行完了，由2种情况：old children 有剩余、new children 有剩余\n  // 分别对应的情景为：删除，增加\n  // 如果 new children 循环完了，说明 old children 有剩余，剩余的可以直接删除\n  if (newidx === newchildren.length) {\n    // we've reached the end of the new children. we can delete the rest.\n    deleteremainingchildren(returnfiber, oldfiber);\n    return resultingfirstchild;\n  }\n  // 如果 old children 循环完了，剩余的 new children 就可以直接照搬过来\n  if (oldfiber === null) {\n    // if we don't have any more existing children we can choose a fast path\n    // since the rest will all be insertions.\n    // 循环剩余的new children\n    for (; newidx < newchildren.length; newidx++) {\n      // 创建 fiber \n      const newfiber = createchild(\n        returnfiber,\n        newchildren[newidx],\n        expirationtime,\n      );\n      // 跳过非法的元素\n      if (newfiber === null) {\n        continue;\n      }\n      // 放置节点\n      lastplacedindex = placechild(newfiber, lastplacedindex, newidx);\n      // 挂载到 resultingfirstchild 链表上\n      if (previousnewfiber === null) {\n        // todo: move out of the loop. this only happens for the first run.\n        resultingfirstchild = newfiber;\n      } else {\n        previousnewfiber.sibling = newfiber;\n      }\n      previousnewfiber = newfiber;\n    }\n    // 这里将处理完毕的 new children 返回\n    return resultingfirstchild;\n  }\n  // 上面两种情况都 return ，这里属于第 3 中情况：更改\n  // 更改是提前跳出的，可见更改的优先级要大于删除和增加\n  // 根据 old children 的 key 值建立一个 key 和 fiber 的映射\n  // add all children to a key map for quick lookups.\n  const existingchildren = mapremainingchildren(returnfiber, oldfiber);\n\n  // keep scanning and use the map to restore deleted items as moves.\n  // 循环后面 key 值不匹配的 ne children\n  for (; newidx < newchildren.length; newidx++) {\n    // 试图从 map 中查找 key 值相同的 old child 以复用、\n    // updatefrommap 中会根据是否可复用选择复用或者新建 fiber\n    const newfiber = updatefrommap(\n      existingchildren,\n      returnfiber,\n      newidx,\n      newchildren[newidx],\n      expirationtime,\n    );\n    // 如果找到则放入resultingfirstchild 中\n    if (newfiber !== null) {\n      if (shouldtracksideeffects) {\n        if (newfiber.alternate !== null) {\n          // the new fiber is a work in progress, but if there exists a\n          // current, that means that we reused the fiber. we need to delete\n          // it from the child list so that we don't add it to the deletion\n          // list.\n          // 从 map 中已找到的值删除\n          existingchildren.delete(\n            newfiber.key === null ? newidx : newfiber.key,\n          );\n        }\n      }\n      lastplacedindex = placechild(newfiber, lastplacedindex, newidx);\n      if (previousnewfiber === null) {\n        resultingfirstchild = newfiber;\n      } else {\n        previousnewfiber.sibling = newfiber;\n      }\n      previousnewfiber = newfiber;\n    }\n  }\n\n  if (shouldtracksideeffects) {\n    // any existing children that weren't consumed above were deleted. we need\n    // to add them to the deletion list.\n    // 其余不能复用的 old children 全部删除\n    existingchildren.foreach(child => deletechild(returnfiber, child));\n  }\n\n  return resultingfirstchild;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n\n\n总体来看，react 对 childfiberarray 的调和方法大概是这样：\n\n * 分为改动、增加和删除三个场景，其中改动的优先级要大于删除和增加。\n * 先将 old children 和 new children 按照 index 逐个对比，只要遇到有 key 值不匹配的（updateslot 函数），就进入改动场景，前面匹配的直接复用。\n * 改动场景中会将剩余的 old children 组成 map<key, fiber> ，循环剩余的 new children，如果能在 map 中找到匹配 key 值的节点就复用，否则就创建（updatefrommap 函数）。\n * 如果没有进入改动场景，那就根据 old children 和 new children 谁有剩余进入删除或者增加的场景。\n * 如果 old children 有剩余，则进入删除场景，将剩余的 old children 全部删除。\n * 如果 new children 有剩余，则进入增加场景，剩余的 new children 全部新建并插入。\n * 最终返回挂载了处理过的 new fibers 链表（resultingfirstchild）。\n\n这里的改动、增加和删除三个场景和列表中的改动、增加和删除三个操作是不一样的，可以看到我们针对列表所做的大部分改动、增加和删除操作都是由 reconcilechildrenarray 的改动场景来完成的，只有在列表的末尾的增加和删除操作才会由 reconcilechildrenarray 的增加和删除场景去完成。这也说明可了 key 值对列表的重要性，在渲染阶段，利用 key 值来复用节点极大的降低了节点的创建成本、提高了页面的更新效率。\n\n> 现在我们知道了 key 值对于 fiber 的重要的优化意义。那么除了我们在列表中手动给节点添加的 key 值，其余的 key 值又是如何维护的呢？\n\n在前文 createfiber 中，我们知道 key 值是通过传入来创建 fiber 的。通过搜索得知，在各种形式的 fiber 创建方式中 key 都是传入的参数。我们在 createfiber 中打印出相应的 key 值，然后添加下面的测试代码：\n\nconst list = () => {\n  const arr = new array(20).fill(0);\n  return arr.map(a => <p key={math.random()}>{a}</p>)\n}\n\n\n1\n2\n3\n4\n\n\n打印效果如下：\n\n这说明 key 值的重要的优化作用主要发生在增删改操作频繁的列表的渲染中，在其他的地方作用并不明显，因为并没有可复用节点的需求。\n\n----------------------------------------\n\n下面我们来单独看看几个小函数：\n\n\n# updateslot\n\n这个函数逐个比较 old children 和 new children 的 key 值是否相等，相等则复用，不等则返回 null，创建跳出循环的条件。\n\nfunction updateslot(\n  returnfiber: fiber,\n  oldfiber: fiber | null,\n  newchild: any,\n  expirationtime: expirationtime,\n): fiber | null {\n  // update the fiber if the keys match, otherwise return null.\n\n  const key = oldfiber !== null ? oldfiber.key : null;\n\n  if (typeof newchild === 'string' || typeof newchild === 'number') {\n    // text nodes don't have keys. if the previous node is implicitly keyed\n    // we can continue to replace it without aborting even if it is not a text\n    // node.\n    if (key !== null) {\n      return null;\n    }\n    return updatetextnode(\n      returnfiber,\n      oldfiber,\n      '' + newchild,\n      expirationtime,\n    );\n  }\n\n  if (typeof newchild === 'object' && newchild !== null) {\n    switch (newchild.$$typeof) {\n      case react_element_type: {\n        if (newchild.key === key) {\n          if (newchild.type === react_fragment_type) {\n            return updatefragment(\n              returnfiber,\n              oldfiber,\n              newchild.props.children,\n              expirationtime,\n              key,\n            );\n          }\n          return updateelement(\n            returnfiber,\n            oldfiber,\n            newchild,\n            expirationtime,\n          );\n        } else {\n          return null;\n        }\n      }\n      case react_portal_type: {\n        if (newchild.key === key) {\n          return updateportal(\n            returnfiber,\n            oldfiber,\n            newchild,\n            expirationtime,\n          );\n        } else {\n          return null;\n        }\n      }\n    }\n\n    if (isarray(newchild) || getiteratorfn(newchild)) {\n      if (key !== null) {\n        return null;\n      }\n\n      return updatefragment(\n        returnfiber,\n        oldfiber,\n        newchild,\n        expirationtime,\n        null,\n      );\n    }\n\n    throwoninvalidobjecttype(returnfiber, newchild);\n  }\n\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n注意，在 updatexxx 的函数中的逻辑都是对先判断 fiber 是否可更新，否则再去创建 fiber。 这里参照上文中对文本、普通 reactelement、portalelement 等单一节点的调和方法。\n\n\n# placechild\n\n这个函数为 fiber 添加 'placement' 标签，也就是放置节点。节点放置分为 move 和 insertion 两种操作。\n\nfunction placechild(\n  newfiber: fiber,\n  lastplacedindex: number,\n  newindex: number,\n): number {\n  newfiber.index = newindex;\n  if (!shouldtracksideeffects) {\n    // noop.\n    return lastplacedindex;\n  }\n  const current = newfiber.alternate;\n  if (current !== null) {\n    const oldindex = current.index;\n    // 愿挨的 index 与 新的 index 不一致，移动节点\n    if (oldindex < lastplacedindex) {\n      // this is a move.\n      newfiber.effecttag = placement;\n      return lastplacedindex;\n    } else {\n      // index 一致，不必移动，保持原位\n      // this item can stay in place.\n      return oldindex;\n    }\n  } else {\n    // 原来没有的直接插入到指定的 index 位置。\n    // this is an insertion.\n    newfiber.effecttag = placement;\n    return lastplacedindex;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n从之前的分析中可以看出：\n\n * 对于 new children 中的每一个节点，都需要调用一下 placechild 进行 “放置”。事实上对于，无论是 'move' 还是 'insertion' 都是加入了 'placement' 标签。这是因为为 nefibers 转化为 domtree 时，只要是标记了 'placement' 标签的节点，都会被按照新的 fiber.index 来调整位置。这时我们再来看 fiber 定义中的 index，概念就更加清晰了。\n\n\n# updatefrommap\n\n这个函数从 old children 中复用 fiber，如果没有找到则创建新的 fiber。\n\n function updatefrommap(\n  existingchildren: map<string | number, fiber>,\n  returnfiber: fiber,\n  newidx: number,\n  newchild: any,\n  expirationtime: expirationtime,\n): fiber | null {\n  if (typeof newchild === 'string' || typeof newchild === 'number') {\n    // text nodes don't have keys, so we neither have to check the old nor\n    // new node for the key. if both are text nodes, they match.\n    const matchedfiber = existingchildren.get(newidx) || null;\n    return updatetextnode(\n      returnfiber,\n      matchedfiber,\n      '' + newchild,\n      expirationtime,\n    );\n  }\n\n  if (typeof newchild === 'object' && newchild !== null) {\n    switch (newchild.$$typeof) {\n      case react_element_type: {\n        const matchedfiber =\n          existingchildren.get(\n            newchild.key === null ? newidx : newchild.key,\n          ) || null;\n        if (newchild.type === react_fragment_type) {\n          return updatefragment(\n            returnfiber,\n            matchedfiber,\n            newchild.props.children,\n            expirationtime,\n            newchild.key,\n          );\n        }\n        return updateelement(\n          returnfiber,\n          matchedfiber,\n          newchild,\n          expirationtime,\n        );\n      }\n      case react_portal_type: {\n        const matchedfiber =\n          existingchildren.get(\n            newchild.key === null ? newidx : newchild.key,\n          ) || null;\n        return updateportal(\n          returnfiber,\n          matchedfiber,\n          newchild,\n          expirationtime,\n        );\n      }\n    }\n\n    if (isarray(newchild) || getiteratorfn(newchild)) {\n      const matchedfiber = existingchildren.get(newidx) || null;\n      return updatefragment(\n        returnfiber,\n        matchedfiber,\n        newchild,\n        expirationtime,\n        null,\n      );\n    }\n\n    throwoninvalidobjecttype(returnfiber, newchild);\n  }\n\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n * 从 existingchildren 中取出 matchedfiber 进行复用。\n * 根据不同的类型进行更新或者创建 fiber。\n\n上面我们理清楚了 reconcilechildfibers 的过程，具体在 mount 阶段和 render 阶段会有一些不同。\n\n * mount 阶段主要注重于创建 fiber。\n * render 阶段在创建 fiber 之前要考虑是否可以复用，减少创建成本。\n\n\n# 小结\n\n这篇文章详述了 reactchildfiber 的创建过程，包括 singlechild 和 childarray 的创建过程，理解 reactelement 的输入是如何更新和转换为 fiber 的，而整个 vnode tree 转化为 fibertree 正在这一过程的递归。",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"expirationTime与优先级",frontmatter:{title:"expirationTime与优先级",date:"2022-04-14T22:02:21.000Z",permalink:"/react/reconciliation/expirationTime/",categories:["react","reconciliation"],tags:[null]},regularPath:"/10.react/20.%E8%B0%83%E5%92%8C%EF%BC%88Reconciliation%EF%BC%89/30.expirationTime.html",relativePath:"10.react/20.调和（Reconciliation）/30.expirationTime.md",key:"v-e4ff14f8",path:"/react/reconciliation/expirationTime/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"调度优先级",slug:"调度优先级",normalizedTitle:"调度优先级",charIndex:17},{level:2,title:"priorityLevel",slug:"prioritylevel",normalizedTitle:"prioritylevel",charIndex:26},{level:2,title:"expirationTime",slug:"expirationtime",normalizedTitle:"expirationtime",charIndex:43},{level:3,title:"computeExpirationForFiber",slug:"computeexpirationforfiber",normalizedTitle:"computeexpirationforfiber",charIndex:63},{level:3,title:"computeExpirationBucket",slug:"computeexpirationbucket",normalizedTitle:"computeexpirationbucket",charIndex:94},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:121}],readingTime:{text:"5 min read",minutes:4.885,time:293099.99999999994,words:977},headersStr:"目录 调度优先级 priorityLevel expirationTime computeExpirationForFiber computeExpirationBucket 小结",content:"# 目录\n\n\n\n * 目录\n * 调度优先级\n * priorityLevel\n * expirationTime\n   * computeExpirationForFiber\n   * computeExpirationBucket\n * 小结\n\n\n\n\n# 调度优先级\n\nreact 中优先级分为四种:\n\n事件优先级：按照用户事件的交互紧急程度，划分的优先级\n更新优先级：事件导致React产生的更新对象（update）的优先级（update.lane）\n任务优先级：产生更新对象之后，React去执行一个更新任务，这个任务所持有的优先级\n调度优先级：Scheduler依据React更新任务生成一个调度任务，这个调度任务所持有的优先级\n\n\n1\n2\n3\n4\n\n\n参考：React 中的优先级\n\n这里我们探讨的是调度优先级。在上文中我们已经知道虽然 js 是单线程执行的，但是现代的浏览器可以通过 requestIdleCallback 和 requestAnimationFrame 来执行不同优先级的任务。通过这种优先级的管理，可以让页面的渲染更加流畅，而不至于让低优先级的任务阻塞了高优先级的任务的执行。\n\nreact 中配合浏览器来实现优先级管理的正是前文所述的 fiber 系统，只是前文我们主要在研究 fiber 在渲染中的创建和更新流程，现在我们就来着重分析 fiber 系统对于优先级管理所发挥的重要角色。这里我们只分析优先级的管理，至于不同优先级的任务是如何具体执行的，我们将在渲染器中具体分析。\n\n\n# priorityLevel\n\n在使用 expirationTime 之前 react 内部对优先级进行了划分，针对不同的优先级来进行调度。\n\n// 优先级的分类，依次变高\nexport const NoWork = 0;\n// TODO: Think of a better name for Never. The key difference with Idle is that\n// Never work can be committed in an inconsistent state without tearing the UI.\nexport const Never = 1;\n// Idle is slightly higher priority than Never. It must completely finish in order to be consistent.\nexport const Idle = 2;\nexport const Batched = Sync - 1;\nexport const Sync = MAX_SIGNED_31_BIT_INT; // Max int32: Math.pow(2, 31) - 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * NoWork: 最低优先级，没有需要处理的任务\n * Never：优先级低于 Idle，不阻塞 UI 渲染\n * Idle：异步执行，不阻塞 UI 渲染\n * Sync：最高优先级，立即执行（同步执行）\n\n不同优先级的任务对应的执行时机不同，请看 inferPriorityFromExpirationTime 函数：\n\nexport const HIGH_PRIORITY_EXPIRATION = 150;\nexport const HIGH_PRIORITY_BATCH_SIZE = 100;\nexport function inferPriorityFromExpirationTime(\n  currentTime: ExpirationTime,\n  expirationTime: ExpirationTime,\n): ReactPriorityLevel {\n  if (expirationTime === Sync) {\n    return ImmediatePriority;\n  }\n  if (expirationTime === Never || expirationTime === Idle) {\n    return IdlePriority;\n  }\n  const msUntil =\n    expirationTimeToMs(expirationTime) - expirationTimeToMs(currentTime);\n  if (msUntil <= 0) {\n    return ImmediatePriority;\n  }\n  if (msUntil <= HIGH_PRIORITY_EXPIRATION + HIGH_PRIORITY_BATCH_SIZE) {\n    return UserBlockingPriority;\n  }\n  if (msUntil <= LOW_PRIORITY_EXPIRATION + LOW_PRIORITY_BATCH_SIZE) {\n    return NormalPriority;\n  }\n\n  // TODO: Handle LowPriority\n\n  // Assume anything lower has idle priority\n  return IdlePriority;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n可以看到这里的真正的任务优先级包括：\n\nImmediatePriority, // 同步立即执行\nUserBlockingPriority, // 高优先级任务，阻塞 UI 任务\nNormalPriority, // 普通优先级任务\nIdlePriority, // 异步延期执行\n\n\n1\n2\n3\n4\n\n\n这里仅仅是从 priorityLevel 机制到 expirationTime 机制的过度。在新版本中对此作了调整，仅做理解即可。\n\n\n# expirationTime\n\nreact 中的调度优先级是通过 expirationTime 来实现的（暂不考虑新版本中的 lanes）。 expirationTime 字面意思是 “到期时间” 或者 “过期时间”，指的是距离任务被执行还需要等待的时间，到期时间越短，说明优先级越高。具体来理解，当调度任务由调度器接手时会根据优先级给这个任务分配一个到期时间，当到期时间达到时，当前任务就会被回调，进入调和器去调度执行。\n\n先来看下 expirationTime 的定义，在 react-reconciler 包中 ReactFiberExpirationTime.js 文件：\n\nexport type ExpirationTime = number;\n\n\n1\n\n\nexpirationTime 是 number 类型，通过比较 expirationTime 和 currentTime 可以将计算出 expirationTime 的值。\n\n我们先来看看 expirationTime 和时间单位（ms）是怎么换算的？\n\nexport const Sync = MAX_SIGNED_31_BIT_INT;\nexport const Batched = Sync - 1;\nconst UNIT_SIZE = 10;\nconst MAGIC_NUMBER_OFFSET = Batched - 1;\n\nexport function msToExpirationTime(ms: number): ExpirationTime {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  // 这里使用 MAGIC_NUMBER_OFFSET 是为了避免让这个值等于 noWork。\n  return MAGIC_NUMBER_OFFSET - ((ms / UNIT_SIZE) | 0);\n}\n\nexport function expirationTimeToMs(expirationTime: ExpirationTime): number {\n  return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这里是 expirationTime 和毫秒的换算公式：\n\n * |0 是取整的操作。比如： 2.3|0=2 ， '333.4'|0=333 ， 'e333'|0=0 。\n * 这里我们把常量带进去整理下：\n   * msToExpirationTime：1073741821-((ms/10)|0)。可以考到这是一个减函数，当 ms 很小时，expirationTime 将会很大。\n   * msUntil：((currentTime/10)|0)-((expirationTime/10)|0)。可以看到 msUntil 的值如果是负值，则应该立即执行，msUntil 值越小优先级越高。\n   * expirationTimeToMs：(1073741821-expirationTime)*10。\n\n下面我们来看下 fiber 机制中 expirationTime 是如何计算的：\n\n\n# computeExpirationForFiber\n\n这个函数会为 fiber 计算 expirationTime，根据调度器给出的优先级，计算 expirationTime。\n\nfunction computeExpirationForFiber(\n  currentTime: ExpirationTime,\n  fiber: Fiber,\n  suspenseConfig: null | SuspenseConfig,\n): ExpirationTime {\n  const mode = fiber.mode;\n  if ((mode & BatchedMode) === NoMode) {\n    // 当 mode 不是 BatchedMode 时，同步渲染\n    return Sync; // 1073741823 MAX_SIGNED_31_BIT_INT\n  }\n  // 从调度器获得优先级\n  const priorityLevel = getCurrentPriorityLevel();\n  if ((mode & ConcurrentMode) === NoMode) {\n    // 不是 ConcurrentMode \n    return priorityLevel === ImmediatePriority ? Sync : Batched;\n  }\n\n  if ((executionContext & RenderContext) !== NoContext) {\n    // executionContext 为 RenderContext\n    // Use whatever time we're already rendering\n    // TODO: Should there be a way to opt out, like with `runWithPriority`?\n    return renderExpirationTime; // NoWork 0\n  }\n\n  let expirationTime;\n  if (suspenseConfig !== null) {\n    // Compute an expiration time based on the Suspense timeout.\n    expirationTime = computeSuspenseExpiration(\n      currentTime,\n      suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION,\n    );\n  } else {\n    // Compute an expiration time based on the Scheduler priority.\n    switch (priorityLevel) {\n      case ImmediatePriority:\n        expirationTime = Sync;\n        break;\n      case UserBlockingPriority:\n        // TODO: Rename this to computeUserBlockingExpiration\n        expirationTime = computeInteractiveExpiration(currentTime);\n        break;\n      case NormalPriority:\n      case LowPriority: // TODO: Handle LowPriority\n        // TODO: Rename this to... something better.\n        expirationTime = computeAsyncExpiration(currentTime);\n        break;\n      case IdlePriority:\n        expirationTime = Idle;\n        break;\n      default:\n        invariant(false, 'Expected a valid priority level');\n    }\n  }\n\n  // If we're in the middle of rendering a tree, do not update at the same\n  // expiration time that is already rendering.\n  // TODO: We shouldn't have to do this if the update is on a different root.\n  // Refactor computeExpirationForFiber + scheduleUpdate so we have access to\n  // the root when we check for this condition.\n  // 如果 FiberTree 已经在渲染了，不用重复更新超时时间，减 1 是为了区别当前的 batch\n  if (workInProgressRoot !== null && expirationTime === renderExpirationTime) {\n    // This is a trick to move this update into a separate batch\n    expirationTime -= 1;\n  }\n\n  return expirationTime;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n 1. UserBlockingPriority、NormalPriority 和 LowPriority 这三种优先级应为异步执行，分别由 computeInteractiveExpiration 和 computeAsyncExpiration 两个函数来计算 expirationTime。\n 2. computeInteractiveExpiration 的优先级比 computeAsyncExpiration 要高。\n 3. react fiber 中的 mode:\n\nexport const NoMode = 0b0000; // 0\nexport const StrictMode = 0b0001; // 1\nexport const BatchedMode = 0b0010; // 2\nexport const ConcurrentMode = 0b0100; // 4\nexport const ProfileMode = 0b1000; // 8\n\n\n1\n2\n3\n4\n5\n\n * StrictMode 严格模式：检测废弃 API，React16-17 开发环境使用。\n * BatchedMode 普通模式：同步渲染，React15-16 的生产环境用。\n * ConcurrentMode 并发模式：异步渲染，React17 的生产环境用。\n * ProfileMode 性能测试模式：检测性能问题，React16-17 开发环境使用。\n\n 4. fiber mode 中的位运算技巧。\n\n在 2 的 n 次方序列中（不包括 0），任何数与自己相与值仍然是自己，与其他数相与值为 0。即 (x&x)===x，(x&y)===0。 因此我们现在需要将事物进行分类，如流程、种类等，可以用到这个技巧。\n\n\n# computeExpirationBucket\n\nexport const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;\nexport const HIGH_PRIORITY_BATCH_SIZE = 100;\nfunction computeInteractiveExpiration(currentTime: ExpirationTime) {\n  return computeExpirationBucket(\n    currentTime,\n    HIGH_PRIORITY_EXPIRATION,\n    HIGH_PRIORITY_BATCH_SIZE,\n  );\n}\n\nexport const LOW_PRIORITY_EXPIRATION = 5000;\nexport const LOW_PRIORITY_BATCH_SIZE = 250;\nexport function computeAsyncExpiration(\n  currentTime: ExpirationTime,\n): ExpirationTime {\n  return computeExpirationBucket(\n    currentTime,\n    LOW_PRIORITY_EXPIRATION,\n    LOW_PRIORITY_BATCH_SIZE,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这两个函数内部都是调用 computeExpirationBucket 来计算超时时间的。现在我们着重来看看 computeExpirationBucket 这个函数：\n\nconst UNIT_SIZE = 10;\nconst MAGIC_NUMBER_OFFSET = 2;\n\nfunction ceiling(num: number, precision: number): number {\n  return (((num / precision) | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(\n  currentTime,\n  expirationInMs,\n  bucketSizeMs,\n): ExpirationTime {\n  return (\n    MAGIC_NUMBER_OFFSET +\n    ceiling(\n      currentTime - MAGIC_NUMBER_OFFSET + expirationInMs / UNIT_SIZE,\n      bucketSizeMs / UNIT_SIZE,\n    )\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n将常量带入，可以得到：((((currentTime - 2 + 5000 / 10) / 25) | 0) + 1) * 25\n\n((((26 - 2 + 5000 / 10) / 25) | 0) + 1) * 25   525\n((((27 - 2 + 5000 / 10) / 25) | 0) + 1) * 25   550\n((((51 - 2 + 5000 / 10) / 25) | 0) + 1) * 25   550\n((((52 - 2 + 5000 / 10) / 25) | 0) + 1) * 25   575\n\n\n1\n2\n3\n4\n\n\n可以看到：在 27-51 这段的 currentTime 里，对应的 expirationTime 都是 550。同样的 expirationTime 也就意味着这些任务将会在同一时间被调度器执行回调，也就是说这些任务会同时去做更新，这就是 react 中的批量更新。\n\n低优先的过期时间间隔是 25ms（UserBlockingPriority），高优先级的过期时间间隔是 10ms（NormalPriority、LowPriority）。\n\n批量更新允许 react 将优先级差不多的一批更新批量的一起更新，这样就可以避免频繁的状态变化曹成频繁更新，导致一些没有意义的中间状态也被执行更新的问题。这样的更新机制极大地提高了 react 的更新效率。\n\n\n# 小结\n\n我编文章讲到 fiber expiration 优先级机制，以及在异步更新的 fiber 中 expiration 的计算方法批量更新特性。",normalizedContent:"# 目录\n\n\n\n * 目录\n * 调度优先级\n * prioritylevel\n * expirationtime\n   * computeexpirationforfiber\n   * computeexpirationbucket\n * 小结\n\n\n\n\n# 调度优先级\n\nreact 中优先级分为四种:\n\n事件优先级：按照用户事件的交互紧急程度，划分的优先级\n更新优先级：事件导致react产生的更新对象（update）的优先级（update.lane）\n任务优先级：产生更新对象之后，react去执行一个更新任务，这个任务所持有的优先级\n调度优先级：scheduler依据react更新任务生成一个调度任务，这个调度任务所持有的优先级\n\n\n1\n2\n3\n4\n\n\n参考：react 中的优先级\n\n这里我们探讨的是调度优先级。在上文中我们已经知道虽然 js 是单线程执行的，但是现代的浏览器可以通过 requestidlecallback 和 requestanimationframe 来执行不同优先级的任务。通过这种优先级的管理，可以让页面的渲染更加流畅，而不至于让低优先级的任务阻塞了高优先级的任务的执行。\n\nreact 中配合浏览器来实现优先级管理的正是前文所述的 fiber 系统，只是前文我们主要在研究 fiber 在渲染中的创建和更新流程，现在我们就来着重分析 fiber 系统对于优先级管理所发挥的重要角色。这里我们只分析优先级的管理，至于不同优先级的任务是如何具体执行的，我们将在渲染器中具体分析。\n\n\n# prioritylevel\n\n在使用 expirationtime 之前 react 内部对优先级进行了划分，针对不同的优先级来进行调度。\n\n// 优先级的分类，依次变高\nexport const nowork = 0;\n// todo: think of a better name for never. the key difference with idle is that\n// never work can be committed in an inconsistent state without tearing the ui.\nexport const never = 1;\n// idle is slightly higher priority than never. it must completely finish in order to be consistent.\nexport const idle = 2;\nexport const batched = sync - 1;\nexport const sync = max_signed_31_bit_int; // max int32: math.pow(2, 31) - 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * nowork: 最低优先级，没有需要处理的任务\n * never：优先级低于 idle，不阻塞 ui 渲染\n * idle：异步执行，不阻塞 ui 渲染\n * sync：最高优先级，立即执行（同步执行）\n\n不同优先级的任务对应的执行时机不同，请看 inferpriorityfromexpirationtime 函数：\n\nexport const high_priority_expiration = 150;\nexport const high_priority_batch_size = 100;\nexport function inferpriorityfromexpirationtime(\n  currenttime: expirationtime,\n  expirationtime: expirationtime,\n): reactprioritylevel {\n  if (expirationtime === sync) {\n    return immediatepriority;\n  }\n  if (expirationtime === never || expirationtime === idle) {\n    return idlepriority;\n  }\n  const msuntil =\n    expirationtimetoms(expirationtime) - expirationtimetoms(currenttime);\n  if (msuntil <= 0) {\n    return immediatepriority;\n  }\n  if (msuntil <= high_priority_expiration + high_priority_batch_size) {\n    return userblockingpriority;\n  }\n  if (msuntil <= low_priority_expiration + low_priority_batch_size) {\n    return normalpriority;\n  }\n\n  // todo: handle lowpriority\n\n  // assume anything lower has idle priority\n  return idlepriority;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n可以看到这里的真正的任务优先级包括：\n\nimmediatepriority, // 同步立即执行\nuserblockingpriority, // 高优先级任务，阻塞 ui 任务\nnormalpriority, // 普通优先级任务\nidlepriority, // 异步延期执行\n\n\n1\n2\n3\n4\n\n\n这里仅仅是从 prioritylevel 机制到 expirationtime 机制的过度。在新版本中对此作了调整，仅做理解即可。\n\n\n# expirationtime\n\nreact 中的调度优先级是通过 expirationtime 来实现的（暂不考虑新版本中的 lanes）。 expirationtime 字面意思是 “到期时间” 或者 “过期时间”，指的是距离任务被执行还需要等待的时间，到期时间越短，说明优先级越高。具体来理解，当调度任务由调度器接手时会根据优先级给这个任务分配一个到期时间，当到期时间达到时，当前任务就会被回调，进入调和器去调度执行。\n\n先来看下 expirationtime 的定义，在 react-reconciler 包中 reactfiberexpirationtime.js 文件：\n\nexport type expirationtime = number;\n\n\n1\n\n\nexpirationtime 是 number 类型，通过比较 expirationtime 和 currenttime 可以将计算出 expirationtime 的值。\n\n我们先来看看 expirationtime 和时间单位（ms）是怎么换算的？\n\nexport const sync = max_signed_31_bit_int;\nexport const batched = sync - 1;\nconst unit_size = 10;\nconst magic_number_offset = batched - 1;\n\nexport function mstoexpirationtime(ms: number): expirationtime {\n  // always add an offset so that we don't clash with the magic number for nowork.\n  // 这里使用 magic_number_offset 是为了避免让这个值等于 nowork。\n  return magic_number_offset - ((ms / unit_size) | 0);\n}\n\nexport function expirationtimetoms(expirationtime: expirationtime): number {\n  return (magic_number_offset - expirationtime) * unit_size;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这里是 expirationtime 和毫秒的换算公式：\n\n * |0 是取整的操作。比如： 2.3|0=2 ， '333.4'|0=333 ， 'e333'|0=0 。\n * 这里我们把常量带进去整理下：\n   * mstoexpirationtime：1073741821-((ms/10)|0)。可以考到这是一个减函数，当 ms 很小时，expirationtime 将会很大。\n   * msuntil：((currenttime/10)|0)-((expirationtime/10)|0)。可以看到 msuntil 的值如果是负值，则应该立即执行，msuntil 值越小优先级越高。\n   * expirationtimetoms：(1073741821-expirationtime)*10。\n\n下面我们来看下 fiber 机制中 expirationtime 是如何计算的：\n\n\n# computeexpirationforfiber\n\n这个函数会为 fiber 计算 expirationtime，根据调度器给出的优先级，计算 expirationtime。\n\nfunction computeexpirationforfiber(\n  currenttime: expirationtime,\n  fiber: fiber,\n  suspenseconfig: null | suspenseconfig,\n): expirationtime {\n  const mode = fiber.mode;\n  if ((mode & batchedmode) === nomode) {\n    // 当 mode 不是 batchedmode 时，同步渲染\n    return sync; // 1073741823 max_signed_31_bit_int\n  }\n  // 从调度器获得优先级\n  const prioritylevel = getcurrentprioritylevel();\n  if ((mode & concurrentmode) === nomode) {\n    // 不是 concurrentmode \n    return prioritylevel === immediatepriority ? sync : batched;\n  }\n\n  if ((executioncontext & rendercontext) !== nocontext) {\n    // executioncontext 为 rendercontext\n    // use whatever time we're already rendering\n    // todo: should there be a way to opt out, like with `runwithpriority`?\n    return renderexpirationtime; // nowork 0\n  }\n\n  let expirationtime;\n  if (suspenseconfig !== null) {\n    // compute an expiration time based on the suspense timeout.\n    expirationtime = computesuspenseexpiration(\n      currenttime,\n      suspenseconfig.timeoutms | 0 || low_priority_expiration,\n    );\n  } else {\n    // compute an expiration time based on the scheduler priority.\n    switch (prioritylevel) {\n      case immediatepriority:\n        expirationtime = sync;\n        break;\n      case userblockingpriority:\n        // todo: rename this to computeuserblockingexpiration\n        expirationtime = computeinteractiveexpiration(currenttime);\n        break;\n      case normalpriority:\n      case lowpriority: // todo: handle lowpriority\n        // todo: rename this to... something better.\n        expirationtime = computeasyncexpiration(currenttime);\n        break;\n      case idlepriority:\n        expirationtime = idle;\n        break;\n      default:\n        invariant(false, 'expected a valid priority level');\n    }\n  }\n\n  // if we're in the middle of rendering a tree, do not update at the same\n  // expiration time that is already rendering.\n  // todo: we shouldn't have to do this if the update is on a different root.\n  // refactor computeexpirationforfiber + scheduleupdate so we have access to\n  // the root when we check for this condition.\n  // 如果 fibertree 已经在渲染了，不用重复更新超时时间，减 1 是为了区别当前的 batch\n  if (workinprogressroot !== null && expirationtime === renderexpirationtime) {\n    // this is a trick to move this update into a separate batch\n    expirationtime -= 1;\n  }\n\n  return expirationtime;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n 1. userblockingpriority、normalpriority 和 lowpriority 这三种优先级应为异步执行，分别由 computeinteractiveexpiration 和 computeasyncexpiration 两个函数来计算 expirationtime。\n 2. computeinteractiveexpiration 的优先级比 computeasyncexpiration 要高。\n 3. react fiber 中的 mode:\n\nexport const nomode = 0b0000; // 0\nexport const strictmode = 0b0001; // 1\nexport const batchedmode = 0b0010; // 2\nexport const concurrentmode = 0b0100; // 4\nexport const profilemode = 0b1000; // 8\n\n\n1\n2\n3\n4\n5\n\n * strictmode 严格模式：检测废弃 api，react16-17 开发环境使用。\n * batchedmode 普通模式：同步渲染，react15-16 的生产环境用。\n * concurrentmode 并发模式：异步渲染，react17 的生产环境用。\n * profilemode 性能测试模式：检测性能问题，react16-17 开发环境使用。\n\n 4. fiber mode 中的位运算技巧。\n\n在 2 的 n 次方序列中（不包括 0），任何数与自己相与值仍然是自己，与其他数相与值为 0。即 (x&x)===x，(x&y)===0。 因此我们现在需要将事物进行分类，如流程、种类等，可以用到这个技巧。\n\n\n# computeexpirationbucket\n\nexport const high_priority_expiration = __dev__ ? 500 : 150;\nexport const high_priority_batch_size = 100;\nfunction computeinteractiveexpiration(currenttime: expirationtime) {\n  return computeexpirationbucket(\n    currenttime,\n    high_priority_expiration,\n    high_priority_batch_size,\n  );\n}\n\nexport const low_priority_expiration = 5000;\nexport const low_priority_batch_size = 250;\nexport function computeasyncexpiration(\n  currenttime: expirationtime,\n): expirationtime {\n  return computeexpirationbucket(\n    currenttime,\n    low_priority_expiration,\n    low_priority_batch_size,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这两个函数内部都是调用 computeexpirationbucket 来计算超时时间的。现在我们着重来看看 computeexpirationbucket 这个函数：\n\nconst unit_size = 10;\nconst magic_number_offset = 2;\n\nfunction ceiling(num: number, precision: number): number {\n  return (((num / precision) | 0) + 1) * precision;\n}\n\nfunction computeexpirationbucket(\n  currenttime,\n  expirationinms,\n  bucketsizems,\n): expirationtime {\n  return (\n    magic_number_offset +\n    ceiling(\n      currenttime - magic_number_offset + expirationinms / unit_size,\n      bucketsizems / unit_size,\n    )\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n将常量带入，可以得到：((((currenttime - 2 + 5000 / 10) / 25) | 0) + 1) * 25\n\n((((26 - 2 + 5000 / 10) / 25) | 0) + 1) * 25   525\n((((27 - 2 + 5000 / 10) / 25) | 0) + 1) * 25   550\n((((51 - 2 + 5000 / 10) / 25) | 0) + 1) * 25   550\n((((52 - 2 + 5000 / 10) / 25) | 0) + 1) * 25   575\n\n\n1\n2\n3\n4\n\n\n可以看到：在 27-51 这段的 currenttime 里，对应的 expirationtime 都是 550。同样的 expirationtime 也就意味着这些任务将会在同一时间被调度器执行回调，也就是说这些任务会同时去做更新，这就是 react 中的批量更新。\n\n低优先的过期时间间隔是 25ms（userblockingpriority），高优先级的过期时间间隔是 10ms（normalpriority、lowpriority）。\n\n批量更新允许 react 将优先级差不多的一批更新批量的一起更新，这样就可以避免频繁的状态变化曹成频繁更新，导致一些没有意义的中间状态也被执行更新的问题。这样的更新机制极大地提高了 react 的更新效率。\n\n\n# 小结\n\n我编文章讲到 fiber expiration 优先级机制，以及在异步更新的 fiber 中 expiration 的计算方法批量更新特性。",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"scheduleWork与调度过程",frontmatter:{title:"scheduleWork与调度过程",date:"2022-04-14T22:02:21.000Z",permalink:"/react/reconciliation/scheduleWork/",categories:["react","reconciliation"],tags:[null]},regularPath:"/10.react/20.%E8%B0%83%E5%92%8C%EF%BC%88Reconciliation%EF%BC%89/40.scheduleWork.html",relativePath:"10.react/20.调和（Reconciliation）/40.scheduleWork.md",key:"v-1daf77ea",path:"/react/reconciliation/scheduleWork/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"scheduleWork：为 Fiber 调度更新",slug:"schedulework-为-fiber-调度更新",normalizedTitle:"schedulework：为 fiber 调度更新",charIndex:17},{level:3,title:"markUpdateTimeFromFiberToRoot：更新 Fiber Tree 的 expirationTime",slug:"markupdatetimefromfibertoroot-更新-fiber-tree-的-expirationtime",normalizedTitle:"markupdatetimefromfibertoroot：更新 fiber tree 的 expirationtime",charIndex:48},{level:3,title:"checkForNestedUpdates: 检查嵌套更新",slug:"checkfornestedupdates-检查嵌套更新",normalizedTitle:"checkfornestedupdates: 检查嵌套更新",charIndex:114},{level:3,title:"嵌套更新的层级数是如何计算的？",slug:"嵌套更新的层级数是如何计算的",normalizedTitle:"嵌套更新的层级数是如何计算的？",charIndex:149},{level:3,title:"checkForInterruption",slug:"checkforinterruption",normalizedTitle:"checkforinterruption",charIndex:170},{level:3,title:"recordScheduleUpdate：记录调度更新的阶段",slug:"recordscheduleupdate-记录调度更新的阶段",normalizedTitle:"recordscheduleupdate：记录调度更新的阶段",charIndex:196},{level:2,title:"ensureRootIsScheduled：确保 Root 被调度",slug:"ensurerootisscheduled-确保-root-被调度",normalizedTitle:"ensurerootisscheduled：确保 root 被调度",charIndex:230},{level:2,title:"scheduleSyncCallback：同步渲染的调度",slug:"schedulesynccallback-同步渲染的调度",normalizedTitle:"schedulesynccallback：同步渲染的调度",charIndex:267},{level:2,title:"scheduleCallback：异步渲染的调度",slug:"schedulecallback-异步渲染的调度",normalizedTitle:"schedulecallback：异步渲染的调度",charIndex:299},{level:2,title:"schedulePendingInteractions 方法：追踪调度过程",slug:"schedulependinginteractions-方法-追踪调度过程",normalizedTitle:"schedulependinginteractions 方法：追踪调度过程",charIndex:327},{level:2,title:"performSyncWorkOnRoot：同步任务调度更新",slug:"performsyncworkonroot-同步任务调度更新",normalizedTitle:"performsyncworkonroot：同步任务调度更新",charIndex:368},{level:2,title:"performConcurrentWorkOnRoot：异步任务调度更新",slug:"performconcurrentworkonroot-异步任务调度更新",normalizedTitle:"performconcurrentworkonroot：异步任务调度更新",charIndex:402},{level:2,title:"flushSyncCallbackQueue",slug:"flushsynccallbackqueue",normalizedTitle:"flushsynccallbackqueue",charIndex:442},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:468}],readingTime:{text:"11 min read",minutes:10.31,time:618600,words:2062},headersStr:"目录 scheduleWork：为 Fiber 调度更新 markUpdateTimeFromFiberToRoot：更新 Fiber Tree 的 expirationTime checkForNestedUpdates: 检查嵌套更新 嵌套更新的层级数是如何计算的？ checkForInterruption recordScheduleUpdate：记录调度更新的阶段 ensureRootIsScheduled：确保 Root 被调度 scheduleSyncCallback：同步渲染的调度 scheduleCallback：异步渲染的调度 schedulePendingInteractions 方法：追踪调度过程 performSyncWorkOnRoot：同步任务调度更新 performConcurrentWorkOnRoot：异步任务调度更新 flushSyncCallbackQueue 小结",content:"# 目录\n\n\n\n * 目录\n * scheduleWork：为 Fiber 调度更新\n   * markUpdateTimeFromFiberToRoot：更新 Fiber Tree 的 expirationTime\n   * checkForNestedUpdates: 检查嵌套更新\n   * 嵌套更新的层级数是如何计算的？\n   * checkForInterruption\n   * recordScheduleUpdate：记录调度更新的阶段\n * ensureRootIsScheduled：确保 Root 被调度\n * scheduleSyncCallback：同步渲染的调度\n * scheduleCallback：异步渲染的调度\n * schedulePendingInteractions 方法：追踪调度过程\n * performSyncWorkOnRoot：同步任务调度更新\n * performConcurrentWorkOnRoot：异步任务调度更新\n * flushSyncCallbackQueue\n * 小结\n\n\n\nscheduleWork 是 react 调度的起点。 scheduleWork(fiber, expirationTime) 传入 fiber 和 expirationTime，可见 fiber 更新的调度是根据 expirationTime 来处理的。\n\n在 react-reconciler/src/ReactFiberWorkLoop.js 中函数 scheduleUpdateOnFiber 实际上就是 scheduleWork。\n\n可以看到现在的 ReactFiberWorkLoop 还在 react-reconciler 包中，其实这里是调度的入口，是调和器与调度器交互的入口。在这里调和器将对 fiber 上的调度追溯到 HostFiberRoot（Fiber 的根节点），在 HostFiberRoot 根据 expirationTime 优先级层级区分为同步调度和异步调度，如果是同步调度（比如 FirstRender 阶段），将跳过调度器直接执行后续的更新流程，只有异步调度或者说当前已经处于 commit 或者 render 状态的同步调度才会交给调度器去调度和回调。\n\n下面我们就来看下调和器是如何做好与调度器的交接工作的。\n\n\n# scheduleWork：为 Fiber 调度更新\n\nscheduleUpdateOnFiber 代码如下：\n\n/**\n * scheduleWork的别名，创建调度任务执行更新\n * @param {*} fiber \n * @param {*} expirationTime \n */\nexport function scheduleUpdateOnFiber(\n    fiber: Fiber,\n    expirationTime: ExpirationTime,\n) {\n    // 检查嵌套更新  \n    checkForNestedUpdates();\n    warnAboutInvalidUpdatesOnClassComponentsInDEV(fiber);\n    // 从 fiber 到 root 标记 expirationTime，找到 root \n    const root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);\n    console.log(\"调度任务中root是：\", root);\n    // 关灯的打印情况：\n    // 调度任务中root： FiberRootNode {tag: 0, current: FiberNode, containerInfo: div#root, pendingChildren: null, pingCache: null, …}\n    // 如果 root 不存在直接退出调度\n    if (root === null) {\n        warnAboutUpdateOnUnmountedFiberInDEV(fiber);\n        return;\n    }\n    // 检查中断\n    checkForInterruption(fiber, expirationTime);\n    // 记录调度更新\n    recordScheduleUpdate();\n\n    // TODO: computeExpirationForFiber also reads the priority. Pass the\n    // priority as an argument to that function and this one.\n    // 获得调度器当前回调的优先级\n    const priorityLevel = getCurrentPriorityLevel();\n\n    // 同步调度，跳过优先级调度直接执行\n    if (expirationTime === Sync) {\n        if (\n            // 如果是 unbatchedUpdates 且不在 rendering 和 commit 状态\n            // Check if we're inside unbatchedUpdates\n            // 第一个条件是 executionContext 的值为 LegacyUnbatchedContext，第二个条件是， executionContext 不能处在 RenderContext 或者是 CommitContext 的阶段。\n            (executionContext & LegacyUnbatchedContext) !== NoContext &&\n            // Check if we're not already rendering\n            // 这里表示不是处于 RenderContext 和 CommitContext，因为如果已经在 render 或者 commit 阶段，需要等待下一次\n            // 不在 render 阶段或 commit 阶段则直接执行更新\n            (executionContext & (RenderContext | CommitContext)) === NoContext\n        ) {\n            // Register pending interactions on the root to avoid losing traced interaction data.\n            // 追踪调度过程，包括计数、错误检测\n            schedulePendingInteractions(root, expirationTime);\n\n            // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\n            // root inside of batchedUpdates should be synchronous, but layout updates\n            // should be deferred until the end of the batch.\n            // 同步方式渲染 root，在 ReactDOM 中 FiberTree 的初始化会走到这里\n            performSyncWorkOnRoot(root);\n        } else {\n\t\t\t      // 首次渲染，同步更新，确保root节点被调度\n            ensureRootIsScheduled(root);\n            // 调度追踪\n            schedulePendingInteractions(root, expirationTime);\n            // 当前处于空闲状态，可以加工同步回调队列\n            if (executionContext === NoContext) {\n                // Flush the synchronous work now, unless we're already working or inside\n                // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n                // scheduleCallbackForFiber to preserve the ability to schedule a callback\n                // without immediately flushing it. We only do this for user-initiated\n                // updates, to preserve historical behavior of sync mode.\n                // 刷新同步任务队列\n                flushSyncCallbackQueue();\n            }\n        }\n    } else {\n        // 异步调度\n        ensureRootIsScheduled(root);\n        schedulePendingInteractions(root, expirationTime);\n    }\n\n   // 这里是对离散事件的管理，由映射表 rootsWithPendingDiscreteUpdates 管理\n    if (\n    (executionContext & DiscreteEventContext) !== NoContext &&\n    // Only updates at user-blocking priority or greater are considered\n    // discrete, even inside a discrete event.\n    (priorityLevel === UserBlockingPriority ||\n      priorityLevel === ImmediatePriority)\n      // 当前如果处于DiscreteEventContext，且调度器当前的回调优先级为 UserBlockingPriority 或者 ImmediatePriority\n      // 离散事件优先级（比如 click）较低\n  ) {\n    // This is the result of a discrete event. Track the lowest priority\n    // discrete update per root so we can flush them early, if needed.\n    if (rootsWithPendingDiscreteUpdates === null) {\n      // 如果离散表不存在就创建离散更新的映射表\n      rootsWithPendingDiscreteUpdates = new Map([[root, expirationTime]]);\n    } else {\n      // 当前 HostFiberRoot 上的离散更新\n      const lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);\n      // 如果当前 HostFiberRoot 上还没有离散更新，或者这里的离散更新优先级更高，就将之覆盖掉离散表上当前 HostFiberRoot 上的更新。这里不会\n      if (lastDiscreteTime === undefined || lastDiscreteTime > expirationTime) {\n        rootsWithPendingDiscreteUpdates.set(root, expirationTime);\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n\n\n\n# markUpdateTimeFromFiberToRoot：更新 Fiber Tree 的 expirationTime\n\n该函数用于获得 FiberRoot 对象，算出的本次更新的 expirationTime，更新 Fiber tree 上的 expirationTime。React 的每次更新其实是从整个 Fiber 树的根节点开始调度的。\n\n// 获取root节点，并且给root节点添加标记。\nfunction markUpdateTimeFromFiberToRoot(fiber, expirationTime) {\n  // Update the source fiber's expiration time\n  // 同步 fiber 和 fiber.alternate 的 expirationTime\n  // 如果 fiber 的 expirationTime 比 expirationTime 低，则说明 fiber 的优先级较低，则把 fiber 的优先级\n  // 提高到当前优先级\n  if (fiber.expirationTime < expirationTime) {\n    fiber.expirationTime = expirationTime;\n  }\n  let alternate = fiber.alternate;\n  if (alternate !== null && alternate.expirationTime < expirationTime) {\n    alternate.expirationTime = expirationTime;\n  }\n  // Walk the parent path to the root and update the child expiration time.\n  // 向上追溯到 root 节点并且更新子节点的超时时间，获取 fiber 的父节点\n  let node = fiber.return;\n  let root = null;\n  // 如果 fiber 没有父节点且具有 HostRoot 的标记则次 fiber 就是 FiberRoot。\n  if (node === null && fiber.tag === HostRoot) {\n    // fiber.return 为空则没有父节点，这里直接找到 root 节点\n    root = fiber.stateNode;\n  } else {\n    // 没有直接获取到 FiberRoot，则向上追溯\n    while (node !== null) {\n      // 更新 node 和 alternate 的超时时间\n      alternate = node.alternate;\n      if (node.childExpirationTime < expirationTime) {\n        // 更新父节点的childExpirationTime，代表子节点的超时时间\n        node.childExpirationTime = expirationTime;\n        if (\n          alternate !== null &&\n          alternate.childExpirationTime < expirationTime\n        ) {\n          alternate.childExpirationTime = expirationTime;\n        }\n      } else if (\n        alternate !== null &&\n        alternate.childExpirationTime < expirationTime\n      ) {\n        alternate.childExpirationTime = expirationTime;\n      }\n      // 追溯到 root 节点\n      if (node.return === null && node.tag === HostRoot) {\n        root = node.stateNode;\n        break;\n      }\n      node = node.return;\n    }\n  }\n\n  if (root !== null) {\n    // root 正是调度更新节点树的根节点\n    if (workInProgressRoot === root) {\n      // Received an update to a tree that's in the middle of rendering. Mark\n      // that's unprocessed work on this root.\n      // 标记更新节点树下一次更新时间，workInProgressRootNextUnprocessedUpdateTime 取较大值\n      markUnprocessedUpdateTime(expirationTime);\n\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // 根已经延迟暂停，这意味着这个渲染\n        // 肯定不会完成。由于我们有新的更新，让我们将其标记为\n        // 现在暂停，就在标记传入更新之前。这有\n        // 中断当前渲染并切换到更新的效果。\n        // TODO: This happens to work when receiving an update during the render\n        // phase, because of the trick inside computeExpirationForFiber to\n        // subtract 1 from `renderExpirationTime` to move it into a\n        // separate bucket. But we should probably model it with an exception,\n        // using the same mechanism we use to force hydration of a subtree.\n        // TODO: This does not account for low pri updates that were already\n        // scheduled before the root started rendering. Need to track the next\n        // pending expiration time (perhaps by backtracking the return path) and\n        // then trigger a restart in the `renderDidSuspendDelayIfPossible` path.\n        markRootSuspendedAtTime(root, renderExpirationTime);\n      }\n    }\n    // Mark that the root has a pending update.\n    // 为 root 节点调度执行更新。\n    markRootUpdatedAtTime(root, expirationTime);\n  }\n\n  return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n * 这个方法的主要作用是：更新渲染树的 expirationTime，同时找到 root 节点。\n * node.return === null && node.tag === HostRoot 是 root 节点的特征。\n\n\n# checkForNestedUpdates: 检查嵌套更新\n\n如果 nestedUpdateCount > NESTED_UPDATE_LIMIT 会被判定为嵌套更新然后报 Maximum update depth exceeded 的错误。其中 NESTED_UPDATE_LIMIT 为 50，这是为了防止嵌套更新的死循环。比如在 render 中调用 setState 的情况。\n\n\n# 嵌套更新的层级数是如何计算的？\n\nlet nestedUpdateCount: number = 0;\nlet rootWithNestedUpdates: FiberRoot | null = null;\n\n\n1\n2\n\n\n在函数 commitRootImpl() 中有如下代码来更新 nestedUpdateCount ：\n\nif (remainingExpirationTime === Sync) {\n  // Count the number of times the root synchronously re-renders without\n  // finishing. If there are too many, it indicates an infinite update loop.\n  if (root === rootWithNestedUpdates) {\n\t  nestedUpdateCount++;\n  } else {\n\t  nestedUpdateCount = 0;\n\t  rootWithNestedUpdates = root;\n  }\n} else {\n  nestedUpdateCount = 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# checkForInterruption\n\ncheckForInterruption 方法会标记中断的 fiber，中断的 fiber 标记到 interruptedBy 上。\n\nfunction checkForInterruption(\n    fiberThatReceivedUpdate: Fiber,\n    updateExpirationTime: ExpirationTime,\n) {\n    if (\n        enableUserTimingAPI &&\n        workInProgressRoot !== null &&\n        updateExpirationTime > renderExpirationTime\n        // 如果非首次渲染，且更新超时时间超过渲染超时时间则被标记为中断 fiber\n    ) {\n        interruptedBy = fiberThatReceivedUpdate;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果 fiber 的优先级比当前执行的渲染任务的优先级更高，则需要将正在执行的渲染任务终端，转而去执行当前 fiber 的渲染更新任务。\n\n\n# recordScheduleUpdate：记录调度更新的阶段\n\nrecordScheduleUpdate 方法记录调度更新，标记当前调度是处于 commit 阶段还是处于 render 阶段，分别记录在标记 hasScheduledUpdateInCurrentCommit 和 hasScheduledUpdateInCurrentPhase 。\n\nexport function recordScheduleUpdate(): void {\n    if (enableUserTimingAPI) {\n        // isCommitting 标记当前是否处于 commit 阶段\n        if (isCommitting) {\n            // 标记在当前 commit 有调度更新\n            hasScheduledUpdateInCurrentCommit = true;\n        }\n        if (\n            // currentPhase 记录当前的生命周期阶段 \n            currentPhase !== null &&\n            currentPhase !== 'componentWillMount' &&\n            currentPhase !== 'componentWillReceiveProps'\n        ) {\n            // 标记在当前阶段有调度更新\n            hasScheduledUpdateInCurrentPhase = true;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n由代码可以看到，无论是首次渲染还是非首次渲染都会调用 ensureRootIsScheduled 和 schedulePendingInteractions 这两个方法。可见这是两个核心方法。\n\n现在重点看 ensureRootIsScheduled 和 schedulePendingInteractions 方法。\n\n\n# ensureRootIsScheduled：确保 Root 被调度\n\n// Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the\n// expiration time of the existing task is the same as the expiration time of\n// the next level that the root has work on. This function is called on every\n// update, and right before exiting a task.\n// 这个函数在 root 上调度任务，每个 root 节点只能有一个任务。如果某个 root 已经被调度了任务，则更新该任务的超时时间。\n// 这个函数再每次更新和执行任务之前都被调用。\nfunction ensureRootIsScheduled(root: FiberRoot) {\n  //lastExpiredTime 初始值为 noWork，只有当任务过期时，会被更改为过期时间（markRootExpiredAtTime方法）\n  const lastExpiredTime = root.lastExpiredTime;\n  // 正常在拉起调度之前 lastExpiredTime 应该在 noWork，否则就说明应当先把 root 上遗留的更新任务给回调完，这时直接采用了同步的回调。\n  if (lastExpiredTime !== NoWork) {\n    // 特殊情况：过期的工作应该同步刷新。\n    // 同步更新，过期的root立即更新\n    root.callbackExpirationTime = Sync;\n    root.callbackPriority = ImmediatePriority;\n    root.callbackNode = scheduleSyncCallback(\n      performSyncWorkOnRoot.bind(null, root),\n    );\n    return;\n  }\n\n  const expirationTime = getNextRootExpirationTimeToWorkOn(root);\n  const existingCallbackNode = root.callbackNode;\n  // 没有调度任务，做一些重置的工作\n  if (expirationTime === NoWork) {\n    // There's nothing to work on.\n    if (existingCallbackNode !== null) {\n      root.callbackNode = null;\n      root.callbackExpirationTime = NoWork;\n      root.callbackPriority = NoPriority;\n    }\n    return;\n  }\n\n  // TODO: If this is an update, we already read the current time. Pass the\n  // time as an argument.\n  // 获取当前时间与任务的优先级\n  const currentTime = requestCurrentTime();\n  const priorityLevel = inferPriorityFromExpirationTime(\n    currentTime,\n    expirationTime,\n  );\n\n  // If there's an existing render task, confirm it has the correct priority and\n  // expiration time. Otherwise, we'll cancel it and schedule a new one.\n  // 如果存在一个渲染任务，确认它具有正确的优先级和过期时间。 否则，我们将取消它并安排一个新的。\n  // 当前的 ROOT 上已经被调度过，这时只需将它更新\n  if (existingCallbackNode !== null) {\n    const existingCallbackPriority = root.callbackPriority;\n    const existingCallbackExpirationTime = root.callbackExpirationTime;\n    if ( // 检查是否是合法的渲染任务\n      // Callback must have the exact same expiration time.\n      existingCallbackExpirationTime === expirationTime &&\n      // Callback must have greater or equal priority.\n      existingCallbackPriority >= priorityLevel\n      // 如果已有的调度优先级更高，这时原来的优先级并不会延迟当前任务的执行，因此可以沿用这个调度，不必将它取消\n    ) {\n      // Existing callback is sufficient.\n      return;\n    }\n    // Need to schedule a new task.\n    // TODO: Instead of scheduling a new task, we should be able to change the\n    // priority of the existing one.\n    // 否则就取消原来的调度任务\n    cancelCallback(existingCallbackNode);\n  }\n\n  root.callbackExpirationTime = expirationTime;\n  root.callbackPriority = priorityLevel;\n\n  let callbackNode;\n  // 同步的渲染任务\n  if (expirationTime === Sync) {\n    // Sync React callbacks are scheduled on a special internal queue\n    // 同步调度由单独的调度队列调度，注意这里并不是 FirstRender\n    callbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n  } else if (disableSchedulerTimeoutBasedOnReactExpirationTime) {\n    callbackNode = scheduleCallback(\n      priorityLevel,\n      performConcurrentWorkOnRoot.bind(null, root),\n    );\n  } else {\n    // 异步的渲染任务调度\n    callbackNode = scheduleCallback(\n      priorityLevel,\n      performConcurrentWorkOnRoot.bind(null, root),\n      // Compute a task timeout based on the expiration time. This also affects\n      // ordering because tasks are processed in timeout order.\n      {timeout: expirationTimeToMs(expirationTime) - now()},\n    );\n  }\n\n  root.callbackNode = callbackNode;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n\n * 同步的调度调用了 scheduleSyncCallback 方法，异步的调度调用了 scheduleCallback 方法。\n\n\n# scheduleSyncCallback：同步渲染的调度\n\nfunction scheduleSyncCallback(callback: SchedulerCallback) {\n    // Push this callback into an internal queue. We'll flush these either in\n    // the next tick, or earlier if something calls `flushSyncCallbackQueue`.\n    if (syncQueue === null) {\n        // 调度队列为空，新建调度队列，并且此任务将会被调度\n        syncQueue = [callback];\n        // Flush the queue in the next tick, at the earliest.\n        // 标记当前正在被同步调度的节点，初始化调度\n        immediateQueueCallbackNode = Scheduler_scheduleCallback(\n            Scheduler_ImmediatePriority,\n            flushSyncCallbackQueueImpl,\n        );\n    } else {\n        // Push onto existing queue. Don't need to schedule a callback because\n        // we already scheduled one when we created the queue.\n        // 加入调度队列，暂时不被调度，因为在创建syncQueue时就已经初始化过了。\n        syncQueue.push(callback);\n    }\n    return fakeCallbackNode;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 同步任务由特殊的队列 syncQueue 调度，进入队列的首个任务将会初始化调度流程，其他任务只加入队列。\n * 同步任务调度由 Scheduler_scheduleCallback 初始化调度，调度将会在下一个 tick 执行，或者在 flushSyncCallbackQueue 被调用时提前执行。此处正式进入调度器中。\n * fakeCallbackNode 返回一个虚假的 callback 节点，事实上是 {}。\n\n\n# scheduleCallback：异步渲染的调度\n\nscheduleCallback 内部是调用 Scheduler_scheduleCallback 方法实现的，这个方法接收调度的优先级和 callback，返回一个新的调度任务。\n\nexport function scheduleCallback(\n  reactPriorityLevel: ReactPriorityLevel,\n  callback: SchedulerCallback,\n  options: SchedulerCallbackOptions | void | null,\n) {\n  const priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);\n  return Scheduler_scheduleCallback(priorityLevel, callback, options);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * Scheduler_scheduleCallback：生成调度任务，设置回调。这里就进入到调度器中了，我们将在调度器中详解。到这里异步调度就移交给调度器了。\n\n\n# schedulePendingInteractions 方法：追踪调度过程\n\n此方法内部调用 scheduleInteractions 方法。这个函数的主要作用是管理和更新 pendingInteractionMap 数据结构，其结构 Map(<expirationTime>, <Interactions Set>) ，interactions 是在任务调度的过程中创建的。下面来看看代码：\n\nfunction scheduleInteractions(root, expirationTime, interactions) {\n  // 这个功能由enableSchedulerTracing标志控制，\n  if (!enableSchedulerTracing) {\n    return;\n  }\n  // interactions 是挂载在 __interactionsRef.current 上的值。\n  // pushInteractions 和 popInteractions 操作 interactions 的值\n  if (interactions.size > 0) {\n    const pendingInteractionMap = root.pendingInteractionMap;\n    const pendingInteractions = pendingInteractionMap.get(expirationTime);\n    // 还有 pending 的任务\n    if (pendingInteractions != null) {\n      interactions.forEach(interaction => {\n        if (!pendingInteractions.has(interaction)) {\n          // Update the pending async work count for previously unscheduled interaction.\n          // 记录 pending 的同步任务的数量\n          interaction.__count++;\n        }\n        // 将 interaction 加入到 pendingInteractions\n        pendingInteractions.add(interaction);\n      });\n    } else {\n      // 没有 pending 的任务，则新建一个interactions的集合加入到pendingInteractionMap。\n      // pendingInteractionMap 的结构为 Map(<expirationTime>, <Interactions Set>)\n      pendingInteractionMap.set(expirationTime, new Set(interactions));\n\n      // Update the pending async work count for the current interactions.\n      // 记录当前 pending 的任务数量\n      interactions.forEach(interaction => {\n        interaction.__count++;\n      });\n    }\n    // 获得订阅者\n    const subscriber = __subscriberRef.current;\n    if (subscriber !== null) {\n      // 获取当前调度的线程 id\n      const threadID = computeThreadID(root, expirationTime);\n      // 向订阅者发出 onWorkScheduled 的通知\n      subscriber.onWorkScheduled(interactions, threadID);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n下面是 pushInteractions 的代码：\n\nfunction pushInteractions(root) {\n  if (enableSchedulerTracing) {\n    const prevInteractions: Set<Interaction> | null = __interactionsRef.current;\n    __interactionsRef.current = root.memoizedInteractions;\n    return prevInteractions;\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n可见 interactions 是从 root.memoizedInteractions 获取的，pushInteractions 返回上一次的 interactions。\n\n上面经过我们的分析，无论是异步回调还是非 FirstRender 的同步回调，都由调度器交接了后续的工作，还剩余一种情况那就 FirstRender 我们还没有分析。我们已经知道 FirstRender 是不会交给调度器去调度的，而是直接由调和器执行了后续的更新回调。在这里我们就来看一下 FirstRender 是怎么处理的，当前我们不会分析的太具体，因为在后续的 更新周期 章节中将会对更新最详细的分析。\n\n\n# performSyncWorkOnRoot：同步任务调度更新\n\n\n# performConcurrentWorkOnRoot：异步任务调度更新\n\n\n# flushSyncCallbackQueue\n\n\n# 小结\n\n 1. scheduleUpdateOnFiber 的执行原理\n\nscheduleUpdateOnFiber 和 ensureRootIsScheduled 这两个函数结合在一起，大致可以看出 react 调度任务的脉络。在进行进人调度时，会根据当前是同步模式还是异步模式，以及是否是初次渲染采用不同的调度方法，总结如下。\n\n同步 / 异步模式   初次渲染    操作\n同步          初次渲染    直接调用 performSyncWorkOnRoot 渲染更新\n同步          非初次渲染   调用 scheduleSyncCallback 进行 callback 调度\n异步          -       调用 scheduleCallback 进行 callback 调度\n\n由此，我们可以看出：\n\n * 除了同步渲染且为初次渲染的情况下，才会跳过调度过程，直接进行渲染。否则，都会进行 callback 的调度渲染，调度渲染不会立即执行，而是交给调度器完后后续的回调过程。\n * 同步渲染由 scheduleSyncCallback 调度，异步渲染由 scheduleCallback 调度，最终都是由 unstable_scheduleCallback 来管理调度任务， unstable_scheduleCallback 的功能是创建任务、将任务分为延时任务和即时任务和调度任务的执行。\n\n 2. react 任务调度都做了些什么？\n\n * react 调度是从 FiberRoot 开始的，FiberRoot 就是没有父节点且标记为 HostRoot 的 Fiber 根节点。\n * 调度开始，需要执行一些检查嵌套更新、检查中断更新、记录调度更新的操作，之后就会根据 expirationTime 来判断当前是什么更新模式，走上面的调度更新流程。\n * 调度更新不仅会影响 Fiber 节点自身，还会可能会影响到 Fiber 的父节点，因为 markUpdateTimeFromFiberToRoot 会更新 fiber 的 expirationTime ，如果 fiber 不是 fiberRoot，还会更新其父节点的 childExpirationTime 。\n * 在调度之后， schedulePendingInteractions 会对调度过程做一些统计、记录工作。\n\n 3. 调和器和调度器的上层接口\n\n在 react-reconciler 包中，文件 SchedulerWithReactIntegration.js 充当了调和器和调度器的桥梁作用，在这个文件中引入了调度器的一些接口并基于调和器进行了封装。从文件名字我们就能看出这一点。\n\n可以看到这些方法实际上是来自于调度器。\n\nconst {\n  unstable_runWithPriority: Scheduler_runWithPriority,\n  unstable_scheduleCallback: Scheduler_scheduleCallback,\n  unstable_cancelCallback: Scheduler_cancelCallback,\n  unstable_shouldYield: Scheduler_shouldYield,\n  unstable_requestPaint: Scheduler_requestPaint,\n  unstable_now: Scheduler_now,\n  unstable_getCurrentPriorityLevel: Scheduler_getCurrentPriorityLevel,\n  unstable_ImmediatePriority: Scheduler_ImmediatePriority,\n  unstable_UserBlockingPriority: Scheduler_UserBlockingPriority,\n  unstable_NormalPriority: Scheduler_NormalPriority,\n  unstable_LowPriority: Scheduler_LowPriority,\n  unstable_IdlePriority: Scheduler_IdlePriority,\n} = Scheduler;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这些方法是 SchedulerWithReactIntegration 基于调度器的封装。\n\n * getCurrentPriorityLevel : 从调度器获取当前调度的优先级。\n * scheduleSyncCallback : 通过调度器调度同步任务并维护同步更新列表 syncQueue。\n * cancelCallback : 从调度器中取消当前的回调。\n * flushSyncCallbackQueue : 批量执行 syncQueue 中的同步更新。",normalizedContent:"# 目录\n\n\n\n * 目录\n * schedulework：为 fiber 调度更新\n   * markupdatetimefromfibertoroot：更新 fiber tree 的 expirationtime\n   * checkfornestedupdates: 检查嵌套更新\n   * 嵌套更新的层级数是如何计算的？\n   * checkforinterruption\n   * recordscheduleupdate：记录调度更新的阶段\n * ensurerootisscheduled：确保 root 被调度\n * schedulesynccallback：同步渲染的调度\n * schedulecallback：异步渲染的调度\n * schedulependinginteractions 方法：追踪调度过程\n * performsyncworkonroot：同步任务调度更新\n * performconcurrentworkonroot：异步任务调度更新\n * flushsynccallbackqueue\n * 小结\n\n\n\nschedulework 是 react 调度的起点。 schedulework(fiber, expirationtime) 传入 fiber 和 expirationtime，可见 fiber 更新的调度是根据 expirationtime 来处理的。\n\n在 react-reconciler/src/reactfiberworkloop.js 中函数 scheduleupdateonfiber 实际上就是 schedulework。\n\n可以看到现在的 reactfiberworkloop 还在 react-reconciler 包中，其实这里是调度的入口，是调和器与调度器交互的入口。在这里调和器将对 fiber 上的调度追溯到 hostfiberroot（fiber 的根节点），在 hostfiberroot 根据 expirationtime 优先级层级区分为同步调度和异步调度，如果是同步调度（比如 firstrender 阶段），将跳过调度器直接执行后续的更新流程，只有异步调度或者说当前已经处于 commit 或者 render 状态的同步调度才会交给调度器去调度和回调。\n\n下面我们就来看下调和器是如何做好与调度器的交接工作的。\n\n\n# schedulework：为 fiber 调度更新\n\nscheduleupdateonfiber 代码如下：\n\n/**\n * schedulework的别名，创建调度任务执行更新\n * @param {*} fiber \n * @param {*} expirationtime \n */\nexport function scheduleupdateonfiber(\n    fiber: fiber,\n    expirationtime: expirationtime,\n) {\n    // 检查嵌套更新  \n    checkfornestedupdates();\n    warnaboutinvalidupdatesonclasscomponentsindev(fiber);\n    // 从 fiber 到 root 标记 expirationtime，找到 root \n    const root = markupdatetimefromfibertoroot(fiber, expirationtime);\n    console.log(\"调度任务中root是：\", root);\n    // 关灯的打印情况：\n    // 调度任务中root： fiberrootnode {tag: 0, current: fibernode, containerinfo: div#root, pendingchildren: null, pingcache: null, …}\n    // 如果 root 不存在直接退出调度\n    if (root === null) {\n        warnaboutupdateonunmountedfiberindev(fiber);\n        return;\n    }\n    // 检查中断\n    checkforinterruption(fiber, expirationtime);\n    // 记录调度更新\n    recordscheduleupdate();\n\n    // todo: computeexpirationforfiber also reads the priority. pass the\n    // priority as an argument to that function and this one.\n    // 获得调度器当前回调的优先级\n    const prioritylevel = getcurrentprioritylevel();\n\n    // 同步调度，跳过优先级调度直接执行\n    if (expirationtime === sync) {\n        if (\n            // 如果是 unbatchedupdates 且不在 rendering 和 commit 状态\n            // check if we're inside unbatchedupdates\n            // 第一个条件是 executioncontext 的值为 legacyunbatchedcontext，第二个条件是， executioncontext 不能处在 rendercontext 或者是 commitcontext 的阶段。\n            (executioncontext & legacyunbatchedcontext) !== nocontext &&\n            // check if we're not already rendering\n            // 这里表示不是处于 rendercontext 和 commitcontext，因为如果已经在 render 或者 commit 阶段，需要等待下一次\n            // 不在 render 阶段或 commit 阶段则直接执行更新\n            (executioncontext & (rendercontext | commitcontext)) === nocontext\n        ) {\n            // register pending interactions on the root to avoid losing traced interaction data.\n            // 追踪调度过程，包括计数、错误检测\n            schedulependinginteractions(root, expirationtime);\n\n            // this is a legacy edge case. the initial mount of a reactdom.render-ed\n            // root inside of batchedupdates should be synchronous, but layout updates\n            // should be deferred until the end of the batch.\n            // 同步方式渲染 root，在 reactdom 中 fibertree 的初始化会走到这里\n            performsyncworkonroot(root);\n        } else {\n\t\t\t      // 首次渲染，同步更新，确保root节点被调度\n            ensurerootisscheduled(root);\n            // 调度追踪\n            schedulependinginteractions(root, expirationtime);\n            // 当前处于空闲状态，可以加工同步回调队列\n            if (executioncontext === nocontext) {\n                // flush the synchronous work now, unless we're already working or inside\n                // a batch. this is intentionally inside scheduleupdateonfiber instead of\n                // schedulecallbackforfiber to preserve the ability to schedule a callback\n                // without immediately flushing it. we only do this for user-initiated\n                // updates, to preserve historical behavior of sync mode.\n                // 刷新同步任务队列\n                flushsynccallbackqueue();\n            }\n        }\n    } else {\n        // 异步调度\n        ensurerootisscheduled(root);\n        schedulependinginteractions(root, expirationtime);\n    }\n\n   // 这里是对离散事件的管理，由映射表 rootswithpendingdiscreteupdates 管理\n    if (\n    (executioncontext & discreteeventcontext) !== nocontext &&\n    // only updates at user-blocking priority or greater are considered\n    // discrete, even inside a discrete event.\n    (prioritylevel === userblockingpriority ||\n      prioritylevel === immediatepriority)\n      // 当前如果处于discreteeventcontext，且调度器当前的回调优先级为 userblockingpriority 或者 immediatepriority\n      // 离散事件优先级（比如 click）较低\n  ) {\n    // this is the result of a discrete event. track the lowest priority\n    // discrete update per root so we can flush them early, if needed.\n    if (rootswithpendingdiscreteupdates === null) {\n      // 如果离散表不存在就创建离散更新的映射表\n      rootswithpendingdiscreteupdates = new map([[root, expirationtime]]);\n    } else {\n      // 当前 hostfiberroot 上的离散更新\n      const lastdiscretetime = rootswithpendingdiscreteupdates.get(root);\n      // 如果当前 hostfiberroot 上还没有离散更新，或者这里的离散更新优先级更高，就将之覆盖掉离散表上当前 hostfiberroot 上的更新。这里不会\n      if (lastdiscretetime === undefined || lastdiscretetime > expirationtime) {\n        rootswithpendingdiscreteupdates.set(root, expirationtime);\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n\n\n\n# markupdatetimefromfibertoroot：更新 fiber tree 的 expirationtime\n\n该函数用于获得 fiberroot 对象，算出的本次更新的 expirationtime，更新 fiber tree 上的 expirationtime。react 的每次更新其实是从整个 fiber 树的根节点开始调度的。\n\n// 获取root节点，并且给root节点添加标记。\nfunction markupdatetimefromfibertoroot(fiber, expirationtime) {\n  // update the source fiber's expiration time\n  // 同步 fiber 和 fiber.alternate 的 expirationtime\n  // 如果 fiber 的 expirationtime 比 expirationtime 低，则说明 fiber 的优先级较低，则把 fiber 的优先级\n  // 提高到当前优先级\n  if (fiber.expirationtime < expirationtime) {\n    fiber.expirationtime = expirationtime;\n  }\n  let alternate = fiber.alternate;\n  if (alternate !== null && alternate.expirationtime < expirationtime) {\n    alternate.expirationtime = expirationtime;\n  }\n  // walk the parent path to the root and update the child expiration time.\n  // 向上追溯到 root 节点并且更新子节点的超时时间，获取 fiber 的父节点\n  let node = fiber.return;\n  let root = null;\n  // 如果 fiber 没有父节点且具有 hostroot 的标记则次 fiber 就是 fiberroot。\n  if (node === null && fiber.tag === hostroot) {\n    // fiber.return 为空则没有父节点，这里直接找到 root 节点\n    root = fiber.statenode;\n  } else {\n    // 没有直接获取到 fiberroot，则向上追溯\n    while (node !== null) {\n      // 更新 node 和 alternate 的超时时间\n      alternate = node.alternate;\n      if (node.childexpirationtime < expirationtime) {\n        // 更新父节点的childexpirationtime，代表子节点的超时时间\n        node.childexpirationtime = expirationtime;\n        if (\n          alternate !== null &&\n          alternate.childexpirationtime < expirationtime\n        ) {\n          alternate.childexpirationtime = expirationtime;\n        }\n      } else if (\n        alternate !== null &&\n        alternate.childexpirationtime < expirationtime\n      ) {\n        alternate.childexpirationtime = expirationtime;\n      }\n      // 追溯到 root 节点\n      if (node.return === null && node.tag === hostroot) {\n        root = node.statenode;\n        break;\n      }\n      node = node.return;\n    }\n  }\n\n  if (root !== null) {\n    // root 正是调度更新节点树的根节点\n    if (workinprogressroot === root) {\n      // received an update to a tree that's in the middle of rendering. mark\n      // that's unprocessed work on this root.\n      // 标记更新节点树下一次更新时间，workinprogressrootnextunprocessedupdatetime 取较大值\n      markunprocessedupdatetime(expirationtime);\n\n      if (workinprogressrootexitstatus === rootsuspendedwithdelay) {\n        // the root already suspended with a delay, which means this render\n        // definitely won't finish. since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. this has the\n        // effect of interrupting the current render and switching to the update.\n        // 根已经延迟暂停，这意味着这个渲染\n        // 肯定不会完成。由于我们有新的更新，让我们将其标记为\n        // 现在暂停，就在标记传入更新之前。这有\n        // 中断当前渲染并切换到更新的效果。\n        // todo: this happens to work when receiving an update during the render\n        // phase, because of the trick inside computeexpirationforfiber to\n        // subtract 1 from `renderexpirationtime` to move it into a\n        // separate bucket. but we should probably model it with an exception,\n        // using the same mechanism we use to force hydration of a subtree.\n        // todo: this does not account for low pri updates that were already\n        // scheduled before the root started rendering. need to track the next\n        // pending expiration time (perhaps by backtracking the return path) and\n        // then trigger a restart in the `renderdidsuspenddelayifpossible` path.\n        markrootsuspendedattime(root, renderexpirationtime);\n      }\n    }\n    // mark that the root has a pending update.\n    // 为 root 节点调度执行更新。\n    markrootupdatedattime(root, expirationtime);\n  }\n\n  return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n\n * 这个方法的主要作用是：更新渲染树的 expirationtime，同时找到 root 节点。\n * node.return === null && node.tag === hostroot 是 root 节点的特征。\n\n\n# checkfornestedupdates: 检查嵌套更新\n\n如果 nestedupdatecount > nested_update_limit 会被判定为嵌套更新然后报 maximum update depth exceeded 的错误。其中 nested_update_limit 为 50，这是为了防止嵌套更新的死循环。比如在 render 中调用 setstate 的情况。\n\n\n# 嵌套更新的层级数是如何计算的？\n\nlet nestedupdatecount: number = 0;\nlet rootwithnestedupdates: fiberroot | null = null;\n\n\n1\n2\n\n\n在函数 commitrootimpl() 中有如下代码来更新 nestedupdatecount ：\n\nif (remainingexpirationtime === sync) {\n  // count the number of times the root synchronously re-renders without\n  // finishing. if there are too many, it indicates an infinite update loop.\n  if (root === rootwithnestedupdates) {\n\t  nestedupdatecount++;\n  } else {\n\t  nestedupdatecount = 0;\n\t  rootwithnestedupdates = root;\n  }\n} else {\n  nestedupdatecount = 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# checkforinterruption\n\ncheckforinterruption 方法会标记中断的 fiber，中断的 fiber 标记到 interruptedby 上。\n\nfunction checkforinterruption(\n    fiberthatreceivedupdate: fiber,\n    updateexpirationtime: expirationtime,\n) {\n    if (\n        enableusertimingapi &&\n        workinprogressroot !== null &&\n        updateexpirationtime > renderexpirationtime\n        // 如果非首次渲染，且更新超时时间超过渲染超时时间则被标记为中断 fiber\n    ) {\n        interruptedby = fiberthatreceivedupdate;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果 fiber 的优先级比当前执行的渲染任务的优先级更高，则需要将正在执行的渲染任务终端，转而去执行当前 fiber 的渲染更新任务。\n\n\n# recordscheduleupdate：记录调度更新的阶段\n\nrecordscheduleupdate 方法记录调度更新，标记当前调度是处于 commit 阶段还是处于 render 阶段，分别记录在标记 hasscheduledupdateincurrentcommit 和 hasscheduledupdateincurrentphase 。\n\nexport function recordscheduleupdate(): void {\n    if (enableusertimingapi) {\n        // iscommitting 标记当前是否处于 commit 阶段\n        if (iscommitting) {\n            // 标记在当前 commit 有调度更新\n            hasscheduledupdateincurrentcommit = true;\n        }\n        if (\n            // currentphase 记录当前的生命周期阶段 \n            currentphase !== null &&\n            currentphase !== 'componentwillmount' &&\n            currentphase !== 'componentwillreceiveprops'\n        ) {\n            // 标记在当前阶段有调度更新\n            hasscheduledupdateincurrentphase = true;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n由代码可以看到，无论是首次渲染还是非首次渲染都会调用 ensurerootisscheduled 和 schedulependinginteractions 这两个方法。可见这是两个核心方法。\n\n现在重点看 ensurerootisscheduled 和 schedulependinginteractions 方法。\n\n\n# ensurerootisscheduled：确保 root 被调度\n\n// use this function to schedule a task for a root. there's only one task per\n// root; if a task was already scheduled, we'll check to make sure the\n// expiration time of the existing task is the same as the expiration time of\n// the next level that the root has work on. this function is called on every\n// update, and right before exiting a task.\n// 这个函数在 root 上调度任务，每个 root 节点只能有一个任务。如果某个 root 已经被调度了任务，则更新该任务的超时时间。\n// 这个函数再每次更新和执行任务之前都被调用。\nfunction ensurerootisscheduled(root: fiberroot) {\n  //lastexpiredtime 初始值为 nowork，只有当任务过期时，会被更改为过期时间（markrootexpiredattime方法）\n  const lastexpiredtime = root.lastexpiredtime;\n  // 正常在拉起调度之前 lastexpiredtime 应该在 nowork，否则就说明应当先把 root 上遗留的更新任务给回调完，这时直接采用了同步的回调。\n  if (lastexpiredtime !== nowork) {\n    // 特殊情况：过期的工作应该同步刷新。\n    // 同步更新，过期的root立即更新\n    root.callbackexpirationtime = sync;\n    root.callbackpriority = immediatepriority;\n    root.callbacknode = schedulesynccallback(\n      performsyncworkonroot.bind(null, root),\n    );\n    return;\n  }\n\n  const expirationtime = getnextrootexpirationtimetoworkon(root);\n  const existingcallbacknode = root.callbacknode;\n  // 没有调度任务，做一些重置的工作\n  if (expirationtime === nowork) {\n    // there's nothing to work on.\n    if (existingcallbacknode !== null) {\n      root.callbacknode = null;\n      root.callbackexpirationtime = nowork;\n      root.callbackpriority = nopriority;\n    }\n    return;\n  }\n\n  // todo: if this is an update, we already read the current time. pass the\n  // time as an argument.\n  // 获取当前时间与任务的优先级\n  const currenttime = requestcurrenttime();\n  const prioritylevel = inferpriorityfromexpirationtime(\n    currenttime,\n    expirationtime,\n  );\n\n  // if there's an existing render task, confirm it has the correct priority and\n  // expiration time. otherwise, we'll cancel it and schedule a new one.\n  // 如果存在一个渲染任务，确认它具有正确的优先级和过期时间。 否则，我们将取消它并安排一个新的。\n  // 当前的 root 上已经被调度过，这时只需将它更新\n  if (existingcallbacknode !== null) {\n    const existingcallbackpriority = root.callbackpriority;\n    const existingcallbackexpirationtime = root.callbackexpirationtime;\n    if ( // 检查是否是合法的渲染任务\n      // callback must have the exact same expiration time.\n      existingcallbackexpirationtime === expirationtime &&\n      // callback must have greater or equal priority.\n      existingcallbackpriority >= prioritylevel\n      // 如果已有的调度优先级更高，这时原来的优先级并不会延迟当前任务的执行，因此可以沿用这个调度，不必将它取消\n    ) {\n      // existing callback is sufficient.\n      return;\n    }\n    // need to schedule a new task.\n    // todo: instead of scheduling a new task, we should be able to change the\n    // priority of the existing one.\n    // 否则就取消原来的调度任务\n    cancelcallback(existingcallbacknode);\n  }\n\n  root.callbackexpirationtime = expirationtime;\n  root.callbackpriority = prioritylevel;\n\n  let callbacknode;\n  // 同步的渲染任务\n  if (expirationtime === sync) {\n    // sync react callbacks are scheduled on a special internal queue\n    // 同步调度由单独的调度队列调度，注意这里并不是 firstrender\n    callbacknode = schedulesynccallback(performsyncworkonroot.bind(null, root));\n  } else if (disableschedulertimeoutbasedonreactexpirationtime) {\n    callbacknode = schedulecallback(\n      prioritylevel,\n      performconcurrentworkonroot.bind(null, root),\n    );\n  } else {\n    // 异步的渲染任务调度\n    callbacknode = schedulecallback(\n      prioritylevel,\n      performconcurrentworkonroot.bind(null, root),\n      // compute a task timeout based on the expiration time. this also affects\n      // ordering because tasks are processed in timeout order.\n      {timeout: expirationtimetoms(expirationtime) - now()},\n    );\n  }\n\n  root.callbacknode = callbacknode;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n\n * 同步的调度调用了 schedulesynccallback 方法，异步的调度调用了 schedulecallback 方法。\n\n\n# schedulesynccallback：同步渲染的调度\n\nfunction schedulesynccallback(callback: schedulercallback) {\n    // push this callback into an internal queue. we'll flush these either in\n    // the next tick, or earlier if something calls `flushsynccallbackqueue`.\n    if (syncqueue === null) {\n        // 调度队列为空，新建调度队列，并且此任务将会被调度\n        syncqueue = [callback];\n        // flush the queue in the next tick, at the earliest.\n        // 标记当前正在被同步调度的节点，初始化调度\n        immediatequeuecallbacknode = scheduler_schedulecallback(\n            scheduler_immediatepriority,\n            flushsynccallbackqueueimpl,\n        );\n    } else {\n        // push onto existing queue. don't need to schedule a callback because\n        // we already scheduled one when we created the queue.\n        // 加入调度队列，暂时不被调度，因为在创建syncqueue时就已经初始化过了。\n        syncqueue.push(callback);\n    }\n    return fakecallbacknode;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 同步任务由特殊的队列 syncqueue 调度，进入队列的首个任务将会初始化调度流程，其他任务只加入队列。\n * 同步任务调度由 scheduler_schedulecallback 初始化调度，调度将会在下一个 tick 执行，或者在 flushsynccallbackqueue 被调用时提前执行。此处正式进入调度器中。\n * fakecallbacknode 返回一个虚假的 callback 节点，事实上是 {}。\n\n\n# schedulecallback：异步渲染的调度\n\nschedulecallback 内部是调用 scheduler_schedulecallback 方法实现的，这个方法接收调度的优先级和 callback，返回一个新的调度任务。\n\nexport function schedulecallback(\n  reactprioritylevel: reactprioritylevel,\n  callback: schedulercallback,\n  options: schedulercallbackoptions | void | null,\n) {\n  const prioritylevel = reactprioritytoschedulerpriority(reactprioritylevel);\n  return scheduler_schedulecallback(prioritylevel, callback, options);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * scheduler_schedulecallback：生成调度任务，设置回调。这里就进入到调度器中了，我们将在调度器中详解。到这里异步调度就移交给调度器了。\n\n\n# schedulependinginteractions 方法：追踪调度过程\n\n此方法内部调用 scheduleinteractions 方法。这个函数的主要作用是管理和更新 pendinginteractionmap 数据结构，其结构 map(<expirationtime>, <interactions set>) ，interactions 是在任务调度的过程中创建的。下面来看看代码：\n\nfunction scheduleinteractions(root, expirationtime, interactions) {\n  // 这个功能由enableschedulertracing标志控制，\n  if (!enableschedulertracing) {\n    return;\n  }\n  // interactions 是挂载在 __interactionsref.current 上的值。\n  // pushinteractions 和 popinteractions 操作 interactions 的值\n  if (interactions.size > 0) {\n    const pendinginteractionmap = root.pendinginteractionmap;\n    const pendinginteractions = pendinginteractionmap.get(expirationtime);\n    // 还有 pending 的任务\n    if (pendinginteractions != null) {\n      interactions.foreach(interaction => {\n        if (!pendinginteractions.has(interaction)) {\n          // update the pending async work count for previously unscheduled interaction.\n          // 记录 pending 的同步任务的数量\n          interaction.__count++;\n        }\n        // 将 interaction 加入到 pendinginteractions\n        pendinginteractions.add(interaction);\n      });\n    } else {\n      // 没有 pending 的任务，则新建一个interactions的集合加入到pendinginteractionmap。\n      // pendinginteractionmap 的结构为 map(<expirationtime>, <interactions set>)\n      pendinginteractionmap.set(expirationtime, new set(interactions));\n\n      // update the pending async work count for the current interactions.\n      // 记录当前 pending 的任务数量\n      interactions.foreach(interaction => {\n        interaction.__count++;\n      });\n    }\n    // 获得订阅者\n    const subscriber = __subscriberref.current;\n    if (subscriber !== null) {\n      // 获取当前调度的线程 id\n      const threadid = computethreadid(root, expirationtime);\n      // 向订阅者发出 onworkscheduled 的通知\n      subscriber.onworkscheduled(interactions, threadid);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n下面是 pushinteractions 的代码：\n\nfunction pushinteractions(root) {\n  if (enableschedulertracing) {\n    const previnteractions: set<interaction> | null = __interactionsref.current;\n    __interactionsref.current = root.memoizedinteractions;\n    return previnteractions;\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n可见 interactions 是从 root.memoizedinteractions 获取的，pushinteractions 返回上一次的 interactions。\n\n上面经过我们的分析，无论是异步回调还是非 firstrender 的同步回调，都由调度器交接了后续的工作，还剩余一种情况那就 firstrender 我们还没有分析。我们已经知道 firstrender 是不会交给调度器去调度的，而是直接由调和器执行了后续的更新回调。在这里我们就来看一下 firstrender 是怎么处理的，当前我们不会分析的太具体，因为在后续的 更新周期 章节中将会对更新最详细的分析。\n\n\n# performsyncworkonroot：同步任务调度更新\n\n\n# performconcurrentworkonroot：异步任务调度更新\n\n\n# flushsynccallbackqueue\n\n\n# 小结\n\n 1. scheduleupdateonfiber 的执行原理\n\nscheduleupdateonfiber 和 ensurerootisscheduled 这两个函数结合在一起，大致可以看出 react 调度任务的脉络。在进行进人调度时，会根据当前是同步模式还是异步模式，以及是否是初次渲染采用不同的调度方法，总结如下。\n\n同步 / 异步模式   初次渲染    操作\n同步          初次渲染    直接调用 performsyncworkonroot 渲染更新\n同步          非初次渲染   调用 schedulesynccallback 进行 callback 调度\n异步          -       调用 schedulecallback 进行 callback 调度\n\n由此，我们可以看出：\n\n * 除了同步渲染且为初次渲染的情况下，才会跳过调度过程，直接进行渲染。否则，都会进行 callback 的调度渲染，调度渲染不会立即执行，而是交给调度器完后后续的回调过程。\n * 同步渲染由 schedulesynccallback 调度，异步渲染由 schedulecallback 调度，最终都是由 unstable_schedulecallback 来管理调度任务， unstable_schedulecallback 的功能是创建任务、将任务分为延时任务和即时任务和调度任务的执行。\n\n 2. react 任务调度都做了些什么？\n\n * react 调度是从 fiberroot 开始的，fiberroot 就是没有父节点且标记为 hostroot 的 fiber 根节点。\n * 调度开始，需要执行一些检查嵌套更新、检查中断更新、记录调度更新的操作，之后就会根据 expirationtime 来判断当前是什么更新模式，走上面的调度更新流程。\n * 调度更新不仅会影响 fiber 节点自身，还会可能会影响到 fiber 的父节点，因为 markupdatetimefromfibertoroot 会更新 fiber 的 expirationtime ，如果 fiber 不是 fiberroot，还会更新其父节点的 childexpirationtime 。\n * 在调度之后， schedulependinginteractions 会对调度过程做一些统计、记录工作。\n\n 3. 调和器和调度器的上层接口\n\n在 react-reconciler 包中，文件 schedulerwithreactintegration.js 充当了调和器和调度器的桥梁作用，在这个文件中引入了调度器的一些接口并基于调和器进行了封装。从文件名字我们就能看出这一点。\n\n可以看到这些方法实际上是来自于调度器。\n\nconst {\n  unstable_runwithpriority: scheduler_runwithpriority,\n  unstable_schedulecallback: scheduler_schedulecallback,\n  unstable_cancelcallback: scheduler_cancelcallback,\n  unstable_shouldyield: scheduler_shouldyield,\n  unstable_requestpaint: scheduler_requestpaint,\n  unstable_now: scheduler_now,\n  unstable_getcurrentprioritylevel: scheduler_getcurrentprioritylevel,\n  unstable_immediatepriority: scheduler_immediatepriority,\n  unstable_userblockingpriority: scheduler_userblockingpriority,\n  unstable_normalpriority: scheduler_normalpriority,\n  unstable_lowpriority: scheduler_lowpriority,\n  unstable_idlepriority: scheduler_idlepriority,\n} = scheduler;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这些方法是 schedulerwithreactintegration 基于调度器的封装。\n\n * getcurrentprioritylevel : 从调度器获取当前调度的优先级。\n * schedulesynccallback : 通过调度器调度同步任务并维护同步更新列表 syncqueue。\n * cancelcallback : 从调度器中取消当前的回调。\n * flushsynccallbackqueue : 批量执行 syncqueue 中的同步更新。",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"Lane 与优先级",frontmatter:{title:"Lane 与优先级",date:"2022-04-14T22:02:21.000Z",permalink:"/react/reconciliation/lane/",categories:["react","reconciliation"],tags:[null]},regularPath:"/10.react/20.%E8%B0%83%E5%92%8C%EF%BC%88Reconciliation%EF%BC%89/50.lane.html",relativePath:"10.react/20.调和（Reconciliation）/50.lane.md",key:"v-7050b2a0",path:"/react/reconciliation/lane/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-14T22:02:21.000Z",permalink:"/react/scheduler/index/",categories:["react","scheduler"],tags:[null]},regularPath:"/10.react/30.%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%88Scheduler%EF%BC%89/0.index.html",relativePath:"10.react/30.调度器（Scheduler）/0.index.md",key:"v-41adcea0",path:"/react/scheduler/index/",headers:[{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1409}],readingTime:{text:"1 min read",minutes:.41,time:24599.999999999996,words:82},headersStr:"参考资料",content:"上一章节我们主要讲到调和器的作用和原理，详解分析了 fiber 的创建和更新过程、expirationTime 优先级机制等，所谓调和器，就是在 react 的更新渲染的生命周期中国起到了调和的作用，它不仅是整个 react 内核协同工作的管理者，也是 react 整个更新周期的基础。在调和器的调和作用下，维护者 react 整体的更新周期，同时促进更新器在组件维度上去完成组件创建、更新、渲染和卸载的任务。\n\n那么为什么需要调度器呢？我们知道，调和器虽然在宏观上掌控着更新的创建和回调，但是如何去调度这个更新任务的执行还是得靠调度器的工作。因此，可以说调度器的作用就是帮助调和器和包装和管理更新，在调度器里，我们称之为任务，调度器维护者基于优先级机制的更新任务列表，并且按照一定的顺序交给调和器去执行，这些被调度器回调的更新被调和器进一步执行并提交，最终完成 FiberTree 的创建交给渲染器去渲染。\n\n从一方面看，调度器完成者任务调度的工作，从另一方面看，任务的调度本质上也是对资源的调度。如果缺少有效的资源调度，就无法把本身有效的资源充分的发挥其作用来高效的完成页面的渲染和更新任务。从本质上来看，页面的渲染就是一个事件循环，各种轻重缓急的事件任务都需要耗费资源去完成，这样看看，调度器对于提升资源的利用效率就显得至关重要了。\n\n调度器部分的源码在 scheduler 包中 Scheduler.js 文件中，我们先来看看 scheduler 中会有哪些内容：\n\nexport {\n  // 调度优先级\n  ImmediatePriority as unstable_ImmediatePriority,\n  UserBlockingPriority as unstable_UserBlockingPriority,\n  NormalPriority as unstable_NormalPriority,\n  IdlePriority as unstable_IdlePriority,\n  LowPriority as unstable_LowPriority,\n  // 以某种优先级执行回调\n  unstable_runWithPriority,\n  unstable_next,\n  // 调度一个回调\n  unstable_scheduleCallback,\n  // 取消一个回调\n  unstable_cancelCallback,\n  unstable_wrapCallback,\n  // 获得当前正在被调度的回调的优先级\n  unstable_getCurrentPriorityLevel,\n  unstable_shouldYield,\n  unstable_requestPaint,\n  unstable_continueExecution,\n  unstable_pauseExecution,\n  unstable_getFirstCallbackNode,\n  getCurrentTime as unstable_now,\n  forceFrameRate as unstable_forceFrameRate,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 参考资料\n\n * 一篇长文帮你彻底搞懂 React 的调度机制原理\n * 浏览器的 16ms 渲染帧",normalizedContent:"上一章节我们主要讲到调和器的作用和原理，详解分析了 fiber 的创建和更新过程、expirationtime 优先级机制等，所谓调和器，就是在 react 的更新渲染的生命周期中国起到了调和的作用，它不仅是整个 react 内核协同工作的管理者，也是 react 整个更新周期的基础。在调和器的调和作用下，维护者 react 整体的更新周期，同时促进更新器在组件维度上去完成组件创建、更新、渲染和卸载的任务。\n\n那么为什么需要调度器呢？我们知道，调和器虽然在宏观上掌控着更新的创建和回调，但是如何去调度这个更新任务的执行还是得靠调度器的工作。因此，可以说调度器的作用就是帮助调和器和包装和管理更新，在调度器里，我们称之为任务，调度器维护者基于优先级机制的更新任务列表，并且按照一定的顺序交给调和器去执行，这些被调度器回调的更新被调和器进一步执行并提交，最终完成 fibertree 的创建交给渲染器去渲染。\n\n从一方面看，调度器完成者任务调度的工作，从另一方面看，任务的调度本质上也是对资源的调度。如果缺少有效的资源调度，就无法把本身有效的资源充分的发挥其作用来高效的完成页面的渲染和更新任务。从本质上来看，页面的渲染就是一个事件循环，各种轻重缓急的事件任务都需要耗费资源去完成，这样看看，调度器对于提升资源的利用效率就显得至关重要了。\n\n调度器部分的源码在 scheduler 包中 scheduler.js 文件中，我们先来看看 scheduler 中会有哪些内容：\n\nexport {\n  // 调度优先级\n  immediatepriority as unstable_immediatepriority,\n  userblockingpriority as unstable_userblockingpriority,\n  normalpriority as unstable_normalpriority,\n  idlepriority as unstable_idlepriority,\n  lowpriority as unstable_lowpriority,\n  // 以某种优先级执行回调\n  unstable_runwithpriority,\n  unstable_next,\n  // 调度一个回调\n  unstable_schedulecallback,\n  // 取消一个回调\n  unstable_cancelcallback,\n  unstable_wrapcallback,\n  // 获得当前正在被调度的回调的优先级\n  unstable_getcurrentprioritylevel,\n  unstable_shouldyield,\n  unstable_requestpaint,\n  unstable_continueexecution,\n  unstable_pauseexecution,\n  unstable_getfirstcallbacknode,\n  getcurrenttime as unstable_now,\n  forceframerate as unstable_forceframerate,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 参考资料\n\n * 一篇长文帮你彻底搞懂 react 的调度机制原理\n * 浏览器的 16ms 渲染帧",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"scheduleCallback与调度任务",frontmatter:{title:"scheduleCallback与调度任务",date:"2022-04-14T22:02:21.000Z",permalink:"/react/scheduler/scheduleCallback/",categories:["react","scheduler"],tags:[null]},regularPath:"/10.react/30.%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%88Scheduler%EF%BC%89/10.scheduleCallback.html",relativePath:"10.react/30.调度器（Scheduler）/10.scheduleCallback.md",key:"v-a7e4381c",path:"/react/scheduler/scheduleCallback/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"unstable_scheduleCallback",slug:"unstable-schedulecallback",normalizedTitle:"unstable_schedulecallback",charIndex:17},{level:2,title:"flushWork 和 workLoop",slug:"flushwork-和-workloop",normalizedTitle:"flushwork 和 workloop",charIndex:46},{level:3,title:"在一个任务被加入到同步队列时发生了什么？",slug:"在一个任务被加入到同步队列时发生了什么",normalizedTitle:"在一个任务被加入到同步队列时发生了什么？",charIndex:72},{level:3,title:"flushWork",slug:"flushwork",normalizedTitle:"flushwork",charIndex:46},{level:3,title:"advanceTimers",slug:"advancetimers",normalizedTitle:"advancetimers",charIndex:113},{level:3,title:"workLoop",slug:"workloop",normalizedTitle:"workloop",charIndex:58},{level:2,title:"handleTimeout",slug:"handletimeout",normalizedTitle:"handletimeout",charIndex:144},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:161}],readingTime:{text:"6 min read",minutes:5.855,time:351300,words:1171},headersStr:"目录 unstable_scheduleCallback flushWork 和 workLoop 在一个任务被加入到同步队列时发生了什么？ flushWork advanceTimers workLoop handleTimeout 小结",content:"# 目录\n\n\n\n * 目录\n * unstable_scheduleCallback\n * flushWork 和 workLoop\n   * 在一个任务被加入到同步队列时发生了什么？\n   * flushWork\n   * advanceTimers\n   * workLoop\n * handleTimeout\n * 小结\n\n\n\n\n# unstable_scheduleCallback\n\n在调和器的章节中我们知道了同步渲染由 scheduleSyncCallback 调度，异步渲染由 scheduleCallback 调度，最终都是由 unstable_scheduleCllback 来管理调度任务。unstable_scheduleCallback 是调度器中暴露出来的，在独立的 scheduler/Scheduler.js 文件中。\n\nunstable_scheduleCallback 方法代码如下：\n\nfunction unstable_scheduleCallback(priorityLevel, callback, options) {\n    // 获取当前时间\n    var currentTime = getCurrentTime();\n\n    // 计算startTime 和 timeout\n    var startTime;\n    var timeout;\n    if (typeof options === 'object' && options !== null) {\n        var delay = options.delay;\n        if (typeof delay === 'number' && delay > 0) {\n            startTime = currentTime + delay;\n        } else {\n            startTime = currentTime;\n        }\n        timeout =\n            typeof options.timeout === 'number' ?\n            options.timeout :\n            timeoutForPriorityLevel(priorityLevel);\n    } else {\n        timeout = timeoutForPriorityLevel(priorityLevel);\n        startTime = currentTime;\n    }\n    // 计算 expirationTime\n    var expirationTime = startTime + timeout;\n    // 创建新的 task\n    var newTask = {\n        // 任务 id \n        id: taskIdCounter++,\n        // 任务执行完之后的回调\n        callback,\n        // 任务的优先级\n        priorityLevel,\n        // 开始时间\n        startTime,\n        // 到期时间：经过多长时间没执行的话必须执行\n        expirationTime,\n        // 任务排序的索引\n        sortIndex: -1,\n    };\n    if (enableProfiling) {\n        newTask.isQueued = false;\n    }\n\n    if (startTime > currentTime) {\n        // This is a delayed task.\n        // startTime 大于 currentTime 则 task 被 delay\n        // 延迟任务\n        // 延迟的任务队列将以 startTime 进行排序\n        newTask.sortIndex = startTime;\n        // 将新建的 task 添加至队列，延时任务加入到 \n        // 延迟任务由队列 timerQueue 维护\n        push(timerQueue, newTask);\n        // 如果当前没有即时任务，且 newTask 为最早的延时任务\n        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n            // All tasks are delayed, and this is the task with the earliest delay.\n            if (isHostTimeoutScheduled) {\n                // Cancel an existing timeout.\n                // 如果现在有延迟任务预约，就将这个延迟任务的预约取消，因为现在有优先级更高的了\n                cancelHostTimeout();\n            } else {\n              // 如果没有延迟任务的预约，就预约任务的回调\n                isHostTimeoutScheduled = true;\n            }\n            // Schedule a timeout.\n            // 设置延时， 主线程延时回调，传入延迟时长和回调函数\n            requestHostTimeout(handleTimeout, startTime - currentTime);\n        }\n    } else {\n        // 即时任务，将以 expirationTime 进行排序\n        newTask.sortIndex = expirationTime;\n        // 即时任务加入到 taskQueue\n        // 即时任务由队列 taskQueue 维护\n        push(taskQueue, newTask);\n        if (enableProfiling) {\n            markTaskStart(newTask, currentTime);\n            newTask.isQueued = true;\n        }\n        // Schedule a host callback, if needed. If we're already performing work,\n        // wait until the next time we yield.\n        //如果当前并没被其他即时任务预约，也没有正在回调某个任务\n        if (!isHostCallbackScheduled && !isPerformingWork) {\n            // 预约当前任务\n            isHostCallbackScheduled = true;\n            // 请求主线程回调\n            requestHostCallback(flushWork);\n        }\n    }\n\n    return newTask;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n\n\n这个函数的作用是：创建调度任务请求主线程回调。具体来看：\n\n * 将回调包装成任务，并且由相对的任务队列来管理。\n * 区分即时任务和延时任务，即时任务由 taskQueue 管理，延时任务由 timerQueue 管理。\n * 如果是即时任务，则请求主线程回调，如果是延时任务，则请求主线程延时回调。\n\n 1. 如何计算 startTime 和 expirationTime？\n\n * 如果 options 中传了 delay，则 startTime = currentTime + delay ，否则 startTime = currentTime 。\n * 如果 options 中传了 timeout，则 timeout 为 options.timeout ， 否则会跟根据优先级计算 timeout，即 timeout = timeoutForPriorityLevel(priorityLevel) 。\n * expirationTime = startTime + timeout 即超时时间为 currentTime + delay + timeout 。\n\n 2. 如何判断是即时任务还是延时任务？\n\n将 startTime 和 currentTime 进行比较，如果 startTime > currentTime ，则认为是延时任务，否则就认为是即时任务。\n\n结合 currentTime 的计算方法可知，只有 options 中 delay 存在且大于 0 时，才会被认为是延时任务。\n\n 3. callback 是如何处理的？\n\ncallback 被挂载到到 newTask 上，newTask 最终由 unstable_scheduleCallback 返回。\n\n 4. 即时任务和延时任务分别是如何处理的？\n\n * 即时任务\n\n即时任务会被加入到 taskQueue 队列中，由 requestHostCallback 调度，直接请求主线程回调。\n\n * 延时任务\n\n延时任务会被加入到 timerQueue 队列中，由 requestHostTimeout 调度，请求主线程延时回调。\n\n 5. taskQueue 和 timerQueue 的区别？\n\n// Tasks are stored on a min heap\nvar taskQueue = [];\nvar timerQueue = [];\n\n\n1\n2\n3\n\n * 这两个队列都是小顶堆，初始化为 [] 。\n * taskQueue 队列管理即时任务， timerQueue 队列管理延时任务，只有 taskQueue 中的任务才会被主线程立即回调。\n\n 6. 任务的排序：\n\n * 即时任务：以 expirationTime 排序，expirationTime 越小优先级越高。\n * 延时任务：以 startTime 排序，startTime 越小优先级越高，startTime = currentTime + delay。\n\n 7. 关于小顶堆\n\n参考：\n\n * # JS 数据结构与算法之《堆》\n * # 前端进阶算法 9：看完这篇，再也不怕堆排序、Top K、中位数问题面试了\n\n 8. 下面这三个函数由 SchedulerHostConfig 实现，前面我们已经知道 requestAnimationFrame 和 requestIdleCallback 这两个函数可以实现浏览器中任务执行的优先级，但是由于 API 兼容性（requestIdleCallback）的问题，react 内部进行了实现，用 requestAnimationFrame 和 setTimeout 模拟实现 requestIdleCallback。这部分我们将在 SchedulerHostConfig 中分析。\n\n * requestHostTimeout：请求主线程延时回调\n * cancelHostTimeout：取消主线程延迟回调\n * requestHostCallback：请求主线程回调\n\n\n# flushWork 和 workLoop\n\n这里我们知道 unstable_scheduleCallback 实际上就是调度器的入口，针对外部传入的 callback，调度器将之包装成即时任务和延时任务，按照 delay 区分不同的优先级执行回调。requestHostTimeout 和 requestHostCallback 分别回使传入的任务延时执行和立即执行。调度器最重要的功能就是任务队列的管理、任务执行和任务的中断与恢复。我们先来看下同步任务列表时如何处理的。具体内部是如何即时执行和延时执行的，后文详述。\n\n\n# 在一个任务被加入到同步队列时发生了什么？\n\npush(taskQueue, newTask);\nif (!isHostCallbackScheduled && !isPerformingWork) {\n  isHostCallbackScheduled = true;\n  //  请求主线程回调\n  requestHostCallback(flushWork);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 unstable_scheduleCallback 这段代码中可以看出，如果在加入这个任务到同步队列时，如果当前主线程并没有请求即时回调也没有执行同步任务队列，这是就主动请求一次主线程即时回调。\n\n\n# flushWork\n\n// performWorkUntilDeadline 回调次函数时hasTimeRemaining=true，initialTime=currentTime\nfunction flushWork(hasTimeRemaining, initialTime) {\n  if (enableProfiling) {\n    markSchedulerUnsuspended(initialTime);\n  }\n\n  // We'll need a host callback the next time work is scheduled.\n  // 当前属于 isPerformingWork 阶段（回调执行阶段），这是允许其他的任务继续请求主线程回调\n  isHostCallbackScheduled = false;\n  if (isHostTimeoutScheduled) {\n    // We scheduled a timeout but it's no longer needed. Cancel it.\n    // 如果同步任务队列已经被回调执行了，那么延迟任务队列的延时回调就不需要了\n    // 为什么不需要了？因为延时回调 handleTimeout 的功能在 workLoop 中已经被包含了\n    // 将延时任务队列中到期的任务放入即时任务队列，视情况请求延时回调或者即时回调，后文详述\n    isHostTimeoutScheduled = false;\n    cancelHostTimeout();\n  }\n\n  // isPerformingWork 表示当前处于同步任务回调执行阶段\n  isPerformingWork = true;\n  const previousPriorityLevel = currentPriorityLevel;\n  try {\n    if (enableProfiling) {\n      try {\n        // 继续调用 workLoop\n        return workLoop(hasTimeRemaining, initialTime);\n      } catch (error) {\n        if (currentTask !== null) {\n          const currentTime = getCurrentTime();\n          markTaskErrored(currentTask, currentTime);\n          currentTask.isQueued = false;\n        }\n        throw error;\n      }\n    } else {\n      // No catch in prod codepath.\n      return workLoop(hasTimeRemaining, initialTime);\n    }\n  } finally {\n    // 执行回调阶段后的清理工作\n    currentTask = null;\n    currentPriorityLevel = previousPriorityLevel;\n    isPerformingWork = false;\n    if (enableProfiling) {\n      const currentTime = getCurrentTime();\n      markSchedulerSuspended(currentTime);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n这个函数的实际上是将 workLoop 函数包装了一层，做了一些优化、清理等工作，主要的逻辑还在 workLoop 中。\n\n\n# advanceTimers\n\n在进入 workLoop 函数的分析之前，先来看下 advanceTimers 这个函数。我们已经知道所有的任务已经被分成即时任务（同步任务）和延时任务来管理。其实在执行同步任务队列之前，我们需要对同步任务队列做更新，因为程序执行到这里可能会有延时任务已经到期了，这时这个已经到期的延时任务需要转移到同步任务队列之中，而这份工作正在 advanceTimers 函数实现的。\n\nadvanceTimers 源码如下：\n\nfunction advanceTimers(currentTime) {\n  // Check for tasks that are no longer delayed and add them to the queue.\n  // 从延时任务中取出最早的任务\n  let timer = peek(timerQueue);\n  while (timer !== null) {\n    // callback 为 null，表示该任务已经被取消了，所以删除之。\n    if (timer.callback === null) {\n      // Timer was cancelled.\n      pop(timerQueue);\n    } else if (timer.startTime <= currentTime) {\n      // Timer fired. Transfer to the task queue.\n      // startTime 已经过了时间了，这说明这个任务已经成为了到期的任务\n      // 将之从延时任务队列中取出转移到即时任务队列，并改变其排序的索引\n      pop(timerQueue);\n      timer.sortIndex = timer.expirationTime;\n      push(taskQueue, timer);\n      if (enableProfiling) {\n        markTaskStart(timer, currentTime);\n        timer.isQueued = true;\n      }\n    } else {\n      // Remaining timers are pending.\n      // 未到期则直接结束循环，因为整个队列是有序的，后面的一定未到期，不必再判断了\n      return;\n    }\n    // 指针移动到下一个任务\n    timer = peek(timerQueue);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n可以看到，advanceTimers 的主要作用是：更新即时任务队列。\n\n\n# workLoop\n\n这个函数包含了即时任务队列在回调中处理的核心逻辑。\n\nfunction workLoop(hasTimeRemaining, initialTime) {\n  let currentTime = initialTime;\n  // 更新同步任务队列\n  advanceTimers(currentTime);\n  // 去除最早的即时任务\n  currentTask = peek(taskQueue);\n  while (\n    currentTask !== null &&\n    // isSchedulerPaused 表示调度器被中断\n    !(enableSchedulerDebugging && isSchedulerPaused)\n  ) {\n    if (\n      currentTask.expirationTime > currentTime &&\n      (!hasTimeRemaining || shouldYieldToHost())\n    ) {\n      // 如果任务并没有过期，或者没有剩余的时间直接终止执行\n      // 一般来说这里并不会发生\n      // This currentTask hasn't expired, and we've reached the deadline.\n      break;\n    }\n    // 取出当前任务的原始的回调函数\n    const callback = currentTask.callback;\n    // 这个任务是新任务或者是没有执行完的任务，需要继续执行。\n    if (callback !== null) {\n      // 将 callback 置空是因为我们现在已经要执行他了\n      currentTask.callback = null;\n      currentPriorityLevel = currentTask.priorityLevel;\n      // didUserCallbackTimeout 恒为 true\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      markTaskRun(currentTask, currentTime);\n      // 执行回调函数，并且获得了回调函数的返回值。\n      // 为什么要有返回值？我们要通过这个返回值来判断这个任务到底有没有执行完\n      const continuationCallback = callback(didUserCallbackTimeout);\n      currentTime = getCurrentTime();\n      // 如果回调函数是一个函数，一般会返回回调函数本身，说明任务并没有执行完。只是执行了部分，可能是被中断了。\n      if (typeof continuationCallback === 'function') {\n        // 把这个回调结果放在callback上。这时任务并没有从队列中移除，只是 callback 改变了。任务的优先级不变。\n        currentTask.callback = continuationCallback;\n        markTaskYield(currentTask, currentTime);\n      } else {\n        if (enableProfiling) {\n          markTaskCompleted(currentTask, currentTime);\n          currentTask.isQueued = false;\n        }\n        // 回调函数如果不是返回函数说明任务已经执行完了，可以将任务从队列中移除了\n        if (currentTask === peek(taskQueue)) {\n          pop(taskQueue);\n        }\n      }\n      // 在继续循环之前先更新下即时任务队列。\n      advanceTimers(currentTime);\n    } else {\n      // 已经取消的任务删之。\n      pop(taskQueue);\n    }\n    // 指针移动到队列中的首个任务继续执行。\n    currentTask = peek(taskQueue);\n  }\n  // Return whether there's additional work\n  if (currentTask !== null) {\n    // 队列的任务并没有执行完，返回 true。\n    // 这里会告知任务的执行者，采取措施。\n    // 实际上 performWorkUntilDeadline 会通过 port.postMessage 再发出一个消息 \n    return true;\n  } else {\n    // 如果延时任务队列还有任务，通过最早的任务在请求一次延时回调。\n    let firstTimer = peek(timerQueue);\n    if (firstTimer !== null) {\n      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n    }\n    // 任务队列已经执行完，返回 false 表示可以结束本次调度。\n    return false;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n * 看这里跳出循环的条件可能有些疑问，为什么同步任务队列里要判断任务没有过期？同步任务队列里的任务并不一定都是过期的，也有些是没有过期的，从前文中计算任务的 expiration = start + time 可知，这里的 timeout 会影响 expiration，表示这个任务最多可以推迟的时间，已经过期的任务必须立即执行掉，但是未过期的任务可以有一定的推迟，但是这个推迟的条件比较苛刻，可以看到在！hasTimeRemaining 即没有剩余执行时间时，或者 shouldYieldToHost () 即需要向主线程让渡执行权的时候（后文详述），才可以推迟。\n\n核心理解\n\n 1. 任务队列的中断和恢复机制\n\n为什么要中断任务队列？\n\n从上面的代码中，我们已经知道了在剩余执行时间不够时或者有更高优先级的任务需要让渡执行权给主线程时，需要中断任务队列。综合来看中断任务队列是因为：\n\n * 防止任务队列过大造成主线程阻塞、用户交互迟缓、页面阻塞（相对于其他任务，用户交互任务一般都是优先级比较高的任务）；\n * 并非所有的即时任务都需要立即执行的，在一定情况下是可以有一定的延迟度的，只是相对于延时任务而言的 “立即执行”。\n\n怎么中断任务队列？怎么恢复？\n\n跳出任务队列执行的循环，并且在 workLoop 函数中返回 true。告知执行者，本次调度是被中断的，执行者会在发出一次消息回调一次。回调时任务列表会在执行一次。\n\n 2. 任务的中断和恢复机制\n\n为什么要中断任务？\n\n * 防止过大的任务阻塞主线程。\n * 根据时间片将任务进行切分，提高任务执行效率。\n\n任务的中断和恢复？\n\nworkLoop 是根据 callback 的返回值来判断是否需要中断的。在 callback 返回 'function' 类型的值时即表示请求中断，这时 workLoop 就会保存现场，不删除此任务，先执行下一个任务，下次执行任务队列时对于中断的任务可以恢复现场，直到 callback 返回了 null，表示任务执行完毕，此时 workLoop 将删除此任务，继续执行下一个任务。\n\n 1. 为什么要有中断？\n\n中断很重要，中断可以把代码分到不同的帧去执行，我们知道调度器的在回调时正是考虑到帧的问题，防止在同一帧做过多的事情，造成页面掉帧，这点将在后文详述。\n\n 4. 执行者是如何感知任务队列的终端状态？\n\n这里所说的执行者是指 performWorkUntilDeadline 函数，执行者是通过此函数返回值来判断终端的具体状态的，函数返回 true 表示存在任务队列执行过程中有中断，需要再派一个执行者继续处理，返回 false 表示任务队列执行完毕，此次回调到此结束。\n\n任务中断与恢复示意图:\n\n\n# handleTimeout\n\n在上文中，我们讲述了同步任务队列是如何执行的，以及任务中断和恢复问题，下面我们再来看一下延时任务是如何调度执行的。需要说明的是，上文我们解释了 advanceTimers 函数的作用，他可以更新同步任务队列，经过思考我们可能已经意思到了，延时任务是通过跳跃到同步任务队列来执行的。没错，我们将在下面详细说明这一点：\n\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = false;\n  // 更新同步任务队列，此时延时任务队列中的任务应该都没有过期。\n  advanceTimers(currentTime);\n  // 如果已经请求了主线程回调就没有必要再请求回调了\n  if (!isHostCallbackScheduled) {\n    // 如果即时任务队列里有任务可以消费了但是没有请求回调，就主动请求一个主线程回调\n    if (peek(taskQueue) !== null) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    } else {\n      // 如果没有即时任务需要去回调执行，就以延时任务队列中最小的 timeout 继续请求延时回调。\n      const firstTimer = peek(timerQueue);\n      if (firstTimer !== null) {\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n从这里我们可以看出：\n\n * handleTimeout 只会在没有请求主线程回调时继续请求主线程即时回调或者主线程延时回调，这取决于更新之后的即时任务队列到底还有没有值可以被消费。\n * 因为即时任务需要被立即执行的，所以这个优先去请求主线程即时回调了，其实在 workLoop 的最后也会检查还有没有延时任务来请求主线程延时回调。\n * 因为延迟任务随时都有可能过期成为即时任务，所以需要执行者不断检查，不管是主线程延时回调还是即时回调都会在请求一次延时回调。\n\n\n# 小结\n\n这篇文章介绍了任务队列的维护、执行、中断与恢复，以及任务的执行、中断与恢复，下片文章将具体介绍调度器是如何即时回调和延时回调的。",normalizedContent:"# 目录\n\n\n\n * 目录\n * unstable_schedulecallback\n * flushwork 和 workloop\n   * 在一个任务被加入到同步队列时发生了什么？\n   * flushwork\n   * advancetimers\n   * workloop\n * handletimeout\n * 小结\n\n\n\n\n# unstable_schedulecallback\n\n在调和器的章节中我们知道了同步渲染由 schedulesynccallback 调度，异步渲染由 schedulecallback 调度，最终都是由 unstable_schedulecllback 来管理调度任务。unstable_schedulecallback 是调度器中暴露出来的，在独立的 scheduler/scheduler.js 文件中。\n\nunstable_schedulecallback 方法代码如下：\n\nfunction unstable_schedulecallback(prioritylevel, callback, options) {\n    // 获取当前时间\n    var currenttime = getcurrenttime();\n\n    // 计算starttime 和 timeout\n    var starttime;\n    var timeout;\n    if (typeof options === 'object' && options !== null) {\n        var delay = options.delay;\n        if (typeof delay === 'number' && delay > 0) {\n            starttime = currenttime + delay;\n        } else {\n            starttime = currenttime;\n        }\n        timeout =\n            typeof options.timeout === 'number' ?\n            options.timeout :\n            timeoutforprioritylevel(prioritylevel);\n    } else {\n        timeout = timeoutforprioritylevel(prioritylevel);\n        starttime = currenttime;\n    }\n    // 计算 expirationtime\n    var expirationtime = starttime + timeout;\n    // 创建新的 task\n    var newtask = {\n        // 任务 id \n        id: taskidcounter++,\n        // 任务执行完之后的回调\n        callback,\n        // 任务的优先级\n        prioritylevel,\n        // 开始时间\n        starttime,\n        // 到期时间：经过多长时间没执行的话必须执行\n        expirationtime,\n        // 任务排序的索引\n        sortindex: -1,\n    };\n    if (enableprofiling) {\n        newtask.isqueued = false;\n    }\n\n    if (starttime > currenttime) {\n        // this is a delayed task.\n        // starttime 大于 currenttime 则 task 被 delay\n        // 延迟任务\n        // 延迟的任务队列将以 starttime 进行排序\n        newtask.sortindex = starttime;\n        // 将新建的 task 添加至队列，延时任务加入到 \n        // 延迟任务由队列 timerqueue 维护\n        push(timerqueue, newtask);\n        // 如果当前没有即时任务，且 newtask 为最早的延时任务\n        if (peek(taskqueue) === null && newtask === peek(timerqueue)) {\n            // all tasks are delayed, and this is the task with the earliest delay.\n            if (ishosttimeoutscheduled) {\n                // cancel an existing timeout.\n                // 如果现在有延迟任务预约，就将这个延迟任务的预约取消，因为现在有优先级更高的了\n                cancelhosttimeout();\n            } else {\n              // 如果没有延迟任务的预约，就预约任务的回调\n                ishosttimeoutscheduled = true;\n            }\n            // schedule a timeout.\n            // 设置延时， 主线程延时回调，传入延迟时长和回调函数\n            requesthosttimeout(handletimeout, starttime - currenttime);\n        }\n    } else {\n        // 即时任务，将以 expirationtime 进行排序\n        newtask.sortindex = expirationtime;\n        // 即时任务加入到 taskqueue\n        // 即时任务由队列 taskqueue 维护\n        push(taskqueue, newtask);\n        if (enableprofiling) {\n            marktaskstart(newtask, currenttime);\n            newtask.isqueued = true;\n        }\n        // schedule a host callback, if needed. if we're already performing work,\n        // wait until the next time we yield.\n        //如果当前并没被其他即时任务预约，也没有正在回调某个任务\n        if (!ishostcallbackscheduled && !isperformingwork) {\n            // 预约当前任务\n            ishostcallbackscheduled = true;\n            // 请求主线程回调\n            requesthostcallback(flushwork);\n        }\n    }\n\n    return newtask;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n\n\n这个函数的作用是：创建调度任务请求主线程回调。具体来看：\n\n * 将回调包装成任务，并且由相对的任务队列来管理。\n * 区分即时任务和延时任务，即时任务由 taskqueue 管理，延时任务由 timerqueue 管理。\n * 如果是即时任务，则请求主线程回调，如果是延时任务，则请求主线程延时回调。\n\n 1. 如何计算 starttime 和 expirationtime？\n\n * 如果 options 中传了 delay，则 starttime = currenttime + delay ，否则 starttime = currenttime 。\n * 如果 options 中传了 timeout，则 timeout 为 options.timeout ， 否则会跟根据优先级计算 timeout，即 timeout = timeoutforprioritylevel(prioritylevel) 。\n * expirationtime = starttime + timeout 即超时时间为 currenttime + delay + timeout 。\n\n 2. 如何判断是即时任务还是延时任务？\n\n将 starttime 和 currenttime 进行比较，如果 starttime > currenttime ，则认为是延时任务，否则就认为是即时任务。\n\n结合 currenttime 的计算方法可知，只有 options 中 delay 存在且大于 0 时，才会被认为是延时任务。\n\n 3. callback 是如何处理的？\n\ncallback 被挂载到到 newtask 上，newtask 最终由 unstable_schedulecallback 返回。\n\n 4. 即时任务和延时任务分别是如何处理的？\n\n * 即时任务\n\n即时任务会被加入到 taskqueue 队列中，由 requesthostcallback 调度，直接请求主线程回调。\n\n * 延时任务\n\n延时任务会被加入到 timerqueue 队列中，由 requesthosttimeout 调度，请求主线程延时回调。\n\n 5. taskqueue 和 timerqueue 的区别？\n\n// tasks are stored on a min heap\nvar taskqueue = [];\nvar timerqueue = [];\n\n\n1\n2\n3\n\n * 这两个队列都是小顶堆，初始化为 [] 。\n * taskqueue 队列管理即时任务， timerqueue 队列管理延时任务，只有 taskqueue 中的任务才会被主线程立即回调。\n\n 6. 任务的排序：\n\n * 即时任务：以 expirationtime 排序，expirationtime 越小优先级越高。\n * 延时任务：以 starttime 排序，starttime 越小优先级越高，starttime = currenttime + delay。\n\n 7. 关于小顶堆\n\n参考：\n\n * # js 数据结构与算法之《堆》\n * # 前端进阶算法 9：看完这篇，再也不怕堆排序、top k、中位数问题面试了\n\n 8. 下面这三个函数由 schedulerhostconfig 实现，前面我们已经知道 requestanimationframe 和 requestidlecallback 这两个函数可以实现浏览器中任务执行的优先级，但是由于 api 兼容性（requestidlecallback）的问题，react 内部进行了实现，用 requestanimationframe 和 settimeout 模拟实现 requestidlecallback。这部分我们将在 schedulerhostconfig 中分析。\n\n * requesthosttimeout：请求主线程延时回调\n * cancelhosttimeout：取消主线程延迟回调\n * requesthostcallback：请求主线程回调\n\n\n# flushwork 和 workloop\n\n这里我们知道 unstable_schedulecallback 实际上就是调度器的入口，针对外部传入的 callback，调度器将之包装成即时任务和延时任务，按照 delay 区分不同的优先级执行回调。requesthosttimeout 和 requesthostcallback 分别回使传入的任务延时执行和立即执行。调度器最重要的功能就是任务队列的管理、任务执行和任务的中断与恢复。我们先来看下同步任务列表时如何处理的。具体内部是如何即时执行和延时执行的，后文详述。\n\n\n# 在一个任务被加入到同步队列时发生了什么？\n\npush(taskqueue, newtask);\nif (!ishostcallbackscheduled && !isperformingwork) {\n  ishostcallbackscheduled = true;\n  //  请求主线程回调\n  requesthostcallback(flushwork);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 unstable_schedulecallback 这段代码中可以看出，如果在加入这个任务到同步队列时，如果当前主线程并没有请求即时回调也没有执行同步任务队列，这是就主动请求一次主线程即时回调。\n\n\n# flushwork\n\n// performworkuntildeadline 回调次函数时hastimeremaining=true，initialtime=currenttime\nfunction flushwork(hastimeremaining, initialtime) {\n  if (enableprofiling) {\n    markschedulerunsuspended(initialtime);\n  }\n\n  // we'll need a host callback the next time work is scheduled.\n  // 当前属于 isperformingwork 阶段（回调执行阶段），这是允许其他的任务继续请求主线程回调\n  ishostcallbackscheduled = false;\n  if (ishosttimeoutscheduled) {\n    // we scheduled a timeout but it's no longer needed. cancel it.\n    // 如果同步任务队列已经被回调执行了，那么延迟任务队列的延时回调就不需要了\n    // 为什么不需要了？因为延时回调 handletimeout 的功能在 workloop 中已经被包含了\n    // 将延时任务队列中到期的任务放入即时任务队列，视情况请求延时回调或者即时回调，后文详述\n    ishosttimeoutscheduled = false;\n    cancelhosttimeout();\n  }\n\n  // isperformingwork 表示当前处于同步任务回调执行阶段\n  isperformingwork = true;\n  const previousprioritylevel = currentprioritylevel;\n  try {\n    if (enableprofiling) {\n      try {\n        // 继续调用 workloop\n        return workloop(hastimeremaining, initialtime);\n      } catch (error) {\n        if (currenttask !== null) {\n          const currenttime = getcurrenttime();\n          marktaskerrored(currenttask, currenttime);\n          currenttask.isqueued = false;\n        }\n        throw error;\n      }\n    } else {\n      // no catch in prod codepath.\n      return workloop(hastimeremaining, initialtime);\n    }\n  } finally {\n    // 执行回调阶段后的清理工作\n    currenttask = null;\n    currentprioritylevel = previousprioritylevel;\n    isperformingwork = false;\n    if (enableprofiling) {\n      const currenttime = getcurrenttime();\n      markschedulersuspended(currenttime);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n这个函数的实际上是将 workloop 函数包装了一层，做了一些优化、清理等工作，主要的逻辑还在 workloop 中。\n\n\n# advancetimers\n\n在进入 workloop 函数的分析之前，先来看下 advancetimers 这个函数。我们已经知道所有的任务已经被分成即时任务（同步任务）和延时任务来管理。其实在执行同步任务队列之前，我们需要对同步任务队列做更新，因为程序执行到这里可能会有延时任务已经到期了，这时这个已经到期的延时任务需要转移到同步任务队列之中，而这份工作正在 advancetimers 函数实现的。\n\nadvancetimers 源码如下：\n\nfunction advancetimers(currenttime) {\n  // check for tasks that are no longer delayed and add them to the queue.\n  // 从延时任务中取出最早的任务\n  let timer = peek(timerqueue);\n  while (timer !== null) {\n    // callback 为 null，表示该任务已经被取消了，所以删除之。\n    if (timer.callback === null) {\n      // timer was cancelled.\n      pop(timerqueue);\n    } else if (timer.starttime <= currenttime) {\n      // timer fired. transfer to the task queue.\n      // starttime 已经过了时间了，这说明这个任务已经成为了到期的任务\n      // 将之从延时任务队列中取出转移到即时任务队列，并改变其排序的索引\n      pop(timerqueue);\n      timer.sortindex = timer.expirationtime;\n      push(taskqueue, timer);\n      if (enableprofiling) {\n        marktaskstart(timer, currenttime);\n        timer.isqueued = true;\n      }\n    } else {\n      // remaining timers are pending.\n      // 未到期则直接结束循环，因为整个队列是有序的，后面的一定未到期，不必再判断了\n      return;\n    }\n    // 指针移动到下一个任务\n    timer = peek(timerqueue);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n可以看到，advancetimers 的主要作用是：更新即时任务队列。\n\n\n# workloop\n\n这个函数包含了即时任务队列在回调中处理的核心逻辑。\n\nfunction workloop(hastimeremaining, initialtime) {\n  let currenttime = initialtime;\n  // 更新同步任务队列\n  advancetimers(currenttime);\n  // 去除最早的即时任务\n  currenttask = peek(taskqueue);\n  while (\n    currenttask !== null &&\n    // isschedulerpaused 表示调度器被中断\n    !(enableschedulerdebugging && isschedulerpaused)\n  ) {\n    if (\n      currenttask.expirationtime > currenttime &&\n      (!hastimeremaining || shouldyieldtohost())\n    ) {\n      // 如果任务并没有过期，或者没有剩余的时间直接终止执行\n      // 一般来说这里并不会发生\n      // this currenttask hasn't expired, and we've reached the deadline.\n      break;\n    }\n    // 取出当前任务的原始的回调函数\n    const callback = currenttask.callback;\n    // 这个任务是新任务或者是没有执行完的任务，需要继续执行。\n    if (callback !== null) {\n      // 将 callback 置空是因为我们现在已经要执行他了\n      currenttask.callback = null;\n      currentprioritylevel = currenttask.prioritylevel;\n      // didusercallbacktimeout 恒为 true\n      const didusercallbacktimeout = currenttask.expirationtime <= currenttime;\n      marktaskrun(currenttask, currenttime);\n      // 执行回调函数，并且获得了回调函数的返回值。\n      // 为什么要有返回值？我们要通过这个返回值来判断这个任务到底有没有执行完\n      const continuationcallback = callback(didusercallbacktimeout);\n      currenttime = getcurrenttime();\n      // 如果回调函数是一个函数，一般会返回回调函数本身，说明任务并没有执行完。只是执行了部分，可能是被中断了。\n      if (typeof continuationcallback === 'function') {\n        // 把这个回调结果放在callback上。这时任务并没有从队列中移除，只是 callback 改变了。任务的优先级不变。\n        currenttask.callback = continuationcallback;\n        marktaskyield(currenttask, currenttime);\n      } else {\n        if (enableprofiling) {\n          marktaskcompleted(currenttask, currenttime);\n          currenttask.isqueued = false;\n        }\n        // 回调函数如果不是返回函数说明任务已经执行完了，可以将任务从队列中移除了\n        if (currenttask === peek(taskqueue)) {\n          pop(taskqueue);\n        }\n      }\n      // 在继续循环之前先更新下即时任务队列。\n      advancetimers(currenttime);\n    } else {\n      // 已经取消的任务删之。\n      pop(taskqueue);\n    }\n    // 指针移动到队列中的首个任务继续执行。\n    currenttask = peek(taskqueue);\n  }\n  // return whether there's additional work\n  if (currenttask !== null) {\n    // 队列的任务并没有执行完，返回 true。\n    // 这里会告知任务的执行者，采取措施。\n    // 实际上 performworkuntildeadline 会通过 port.postmessage 再发出一个消息 \n    return true;\n  } else {\n    // 如果延时任务队列还有任务，通过最早的任务在请求一次延时回调。\n    let firsttimer = peek(timerqueue);\n    if (firsttimer !== null) {\n      requesthosttimeout(handletimeout, firsttimer.starttime - currenttime);\n    }\n    // 任务队列已经执行完，返回 false 表示可以结束本次调度。\n    return false;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n * 看这里跳出循环的条件可能有些疑问，为什么同步任务队列里要判断任务没有过期？同步任务队列里的任务并不一定都是过期的，也有些是没有过期的，从前文中计算任务的 expiration = start + time 可知，这里的 timeout 会影响 expiration，表示这个任务最多可以推迟的时间，已经过期的任务必须立即执行掉，但是未过期的任务可以有一定的推迟，但是这个推迟的条件比较苛刻，可以看到在！hastimeremaining 即没有剩余执行时间时，或者 shouldyieldtohost () 即需要向主线程让渡执行权的时候（后文详述），才可以推迟。\n\n核心理解\n\n 1. 任务队列的中断和恢复机制\n\n为什么要中断任务队列？\n\n从上面的代码中，我们已经知道了在剩余执行时间不够时或者有更高优先级的任务需要让渡执行权给主线程时，需要中断任务队列。综合来看中断任务队列是因为：\n\n * 防止任务队列过大造成主线程阻塞、用户交互迟缓、页面阻塞（相对于其他任务，用户交互任务一般都是优先级比较高的任务）；\n * 并非所有的即时任务都需要立即执行的，在一定情况下是可以有一定的延迟度的，只是相对于延时任务而言的 “立即执行”。\n\n怎么中断任务队列？怎么恢复？\n\n跳出任务队列执行的循环，并且在 workloop 函数中返回 true。告知执行者，本次调度是被中断的，执行者会在发出一次消息回调一次。回调时任务列表会在执行一次。\n\n 2. 任务的中断和恢复机制\n\n为什么要中断任务？\n\n * 防止过大的任务阻塞主线程。\n * 根据时间片将任务进行切分，提高任务执行效率。\n\n任务的中断和恢复？\n\nworkloop 是根据 callback 的返回值来判断是否需要中断的。在 callback 返回 'function' 类型的值时即表示请求中断，这时 workloop 就会保存现场，不删除此任务，先执行下一个任务，下次执行任务队列时对于中断的任务可以恢复现场，直到 callback 返回了 null，表示任务执行完毕，此时 workloop 将删除此任务，继续执行下一个任务。\n\n 1. 为什么要有中断？\n\n中断很重要，中断可以把代码分到不同的帧去执行，我们知道调度器的在回调时正是考虑到帧的问题，防止在同一帧做过多的事情，造成页面掉帧，这点将在后文详述。\n\n 4. 执行者是如何感知任务队列的终端状态？\n\n这里所说的执行者是指 performworkuntildeadline 函数，执行者是通过此函数返回值来判断终端的具体状态的，函数返回 true 表示存在任务队列执行过程中有中断，需要再派一个执行者继续处理，返回 false 表示任务队列执行完毕，此次回调到此结束。\n\n任务中断与恢复示意图:\n\n\n# handletimeout\n\n在上文中，我们讲述了同步任务队列是如何执行的，以及任务中断和恢复问题，下面我们再来看一下延时任务是如何调度执行的。需要说明的是，上文我们解释了 advancetimers 函数的作用，他可以更新同步任务队列，经过思考我们可能已经意思到了，延时任务是通过跳跃到同步任务队列来执行的。没错，我们将在下面详细说明这一点：\n\nfunction handletimeout(currenttime) {\n  ishosttimeoutscheduled = false;\n  // 更新同步任务队列，此时延时任务队列中的任务应该都没有过期。\n  advancetimers(currenttime);\n  // 如果已经请求了主线程回调就没有必要再请求回调了\n  if (!ishostcallbackscheduled) {\n    // 如果即时任务队列里有任务可以消费了但是没有请求回调，就主动请求一个主线程回调\n    if (peek(taskqueue) !== null) {\n      ishostcallbackscheduled = true;\n      requesthostcallback(flushwork);\n    } else {\n      // 如果没有即时任务需要去回调执行，就以延时任务队列中最小的 timeout 继续请求延时回调。\n      const firsttimer = peek(timerqueue);\n      if (firsttimer !== null) {\n        requesthosttimeout(handletimeout, firsttimer.starttime - currenttime);\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n从这里我们可以看出：\n\n * handletimeout 只会在没有请求主线程回调时继续请求主线程即时回调或者主线程延时回调，这取决于更新之后的即时任务队列到底还有没有值可以被消费。\n * 因为即时任务需要被立即执行的，所以这个优先去请求主线程即时回调了，其实在 workloop 的最后也会检查还有没有延时任务来请求主线程延时回调。\n * 因为延迟任务随时都有可能过期成为即时任务，所以需要执行者不断检查，不管是主线程延时回调还是即时回调都会在请求一次延时回调。\n\n\n# 小结\n\n这篇文章介绍了任务队列的维护、执行、中断与恢复，以及任务的执行、中断与恢复，下片文章将具体介绍调度器是如何即时回调和延时回调的。",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"schedulerHostConfig",frontmatter:{title:"schedulerHostConfig",date:"2022-04-14T22:02:21.000Z",permalink:"/react/scheduler/schedulerHostConfig/",categories:["react","scheduler"],tags:[null]},regularPath:"/10.react/30.%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%88Scheduler%EF%BC%89/20.schedulerHostConfig.html",relativePath:"10.react/30.调度器（Scheduler）/20.schedulerHostConfig.md",key:"v-fefa4114",path:"/react/scheduler/schedulerHostConfig/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"非 DOM 环境",slug:"非-dom-环境",normalizedTitle:"非 dom 环境",charIndex:17},{level:2,title:"requestHostCallback：请求主线程回调",slug:"requesthostcallback-请求主线程回调",normalizedTitle:"requesthostcallback：请求主线程回调",charIndex:29},{level:3,title:"postMessage：发送执行消息",slug:"postmessage-发送执行消息",normalizedTitle:"postmessage：发送执行消息",charIndex:62},{level:3,title:"performWorkUntilDeadline: 执行回调函数",slug:"performworkuntildeadline-执行回调函数",normalizedTitle:"performworkuntildeadline: 执行回调函数",charIndex:86},{level:3,title:"onAnimationFrame",slug:"onanimationframe",normalizedTitle:"onanimationframe",charIndex:124},{level:2,title:"cancelHostCallback",slug:"cancelhostcallback",normalizedTitle:"cancelhostcallback",charIndex:144},{level:2,title:"requestHostTimeout：请求主线程延时回调",slug:"requesthosttimeout-请求主线程延时回调",normalizedTitle:"requesthosttimeout：请求主线程延时回调",charIndex:166},{level:2,title:"cancelHostTimeout：取消主线程延迟回调",slug:"cancelhosttimeout-取消主线程延迟回调",normalizedTitle:"cancelhosttimeout：取消主线程延迟回调",charIndex:198}],readingTime:{text:"7 min read",minutes:6.025,time:361500,words:1205},headersStr:"目录 非 DOM 环境 requestHostCallback：请求主线程回调 postMessage：发送执行消息 performWorkUntilDeadline: 执行回调函数 onAnimationFrame cancelHostCallback requestHostTimeout：请求主线程延时回调 cancelHostTimeout：取消主线程延迟回调",content:"# 目录\n\n\n\n * 目录\n * 非 DOM 环境\n * requestHostCallback：请求主线程回调\n   * postMessage：发送执行消息\n   * performWorkUntilDeadline: 执行回调函数\n   * onAnimationFrame\n * cancelHostCallback\n * requestHostTimeout：请求主线程延时回调\n * cancelHostTimeout：取消主线程延迟回调\n\n\n\n\n# 非 DOM 环境\n\n在非 DOM 环境中，不存在 rAF Api，因此采用了原生的 setTimeout 来模拟。这里主要用于 node 环境。\n\nif (\n  // If Scheduler runs in a non-DOM environment, it falls back to a naive\n  // implementation using setTimeout.\n  // 在非 DOM 环境中，回退到 setTimeout 的原生实现，因为 非 DOM 环境没有 rAF Api。\n  typeof window === 'undefined' ||\n  // Check if MessageChannel is supported, too.\n  // DOM 环境要用到 MessageChannel API\n  // 如果 window 和MessageChannel 都不存在，就是用原生 setTimeout 模拟\n  typeof MessageChannel !== 'function'\n) {\n  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\n  // fallback to a naive implementation.\n  let _callback = null;\n  let _timeoutID = null;\n  // 如果有 callback 就执行，执行失败就尝试空闲时段重新执行\n  const _flushCallback = function() {\n    if (_callback !== null) {\n      try {\n        const currentTime = getCurrentTime();\n        const hasRemainingTime = true;\n        _callback(hasRemainingTime, currentTime);\n        _callback = null;\n      } catch (e) {\n        setTimeout(_flushCallback, 0);\n        throw e;\n      }\n    }\n  };\n  // Scheduler 初始化的时间\n  const initialTime = Date.now();\n  // 距离初始化的时间差\n  getCurrentTime = function() {\n    return Date.now() - initialTime;\n  };\n  // 请求主线程回调\n  requestHostCallback = function(cb) {\n    if (_callback !== null) {\n      // Protect against re-entrancy.\n      // 这里将 requestHostCallback 作为定时器的回调传入，延迟 0 毫秒表示回调将在空闲时间立即执行，\n      // 执行时将 cb 作为参数传入\n      // 如果 callback 还未 flush，就尝试在空闲时间重新请求回调（依次循环）\n      setTimeout(requestHostCallback, 0, cb);\n    } else {\n      // callback 为空时挂载 cb，并且在空闲时间执行 callback\n      _callback = cb;\n      setTimeout(_flushCallback, 0);\n    }\n  };\n  // 取消主线程当前的回调，当前即时回调 由 _callback 管理\n  cancelHostCallback = function() {\n    _callback = null;\n  };\n  // 请求主线程延时回调，直接调用 setTimeout\n  requestHostTimeout = function(cb, ms) {\n    _timeoutID = setTimeout(cb, ms);\n  };\n  // 取消主线程当前延时回调，当前延时回调由 _timeoutID 管理\n  cancelHostTimeout = function() {\n    clearTimeout(_timeoutID);\n  };\n  shouldYieldToHost = function() {\n    return false;\n  };\n  // 请求重绘\n  requestPaint = forceFrameRate = function() {};\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n在 DOM 环境中，将会以 rAF 和 setTimeout 模拟。\n\n\n# requestHostCallback：请求主线程回调\n\n// 请求主线程即时回调\nrequestHostCallback = function (callback) {\n  // 保存下当前的 callback\n  scheduledHostCallback = callback;\n  if (enableMessageLoopImplementation) {\n    // 如果当前还没有打开消息循环，说明没有其他消息回调在处理，可以打开消息循环（加锁），并发出消息\n    if (!isMessageLoopRunning) {\n      isMessageLoopRunning = true;\n      port.postMessage(null);\n    }\n  } else {\n    // 如果enableMessageLoopImplementation为 false，即没有打开消息循环的特性(不使用 messageChannel Api)，就直接用 RAF 循环实现\n    if (!isRAFLoopRunning) {\n      // Start a rAF loop.\n      isRAFLoopRunning = true;\n      // rAFTime 指的是 performance.now() 的时间\n      requestAnimationFrame(rAFTime => {\n        onAnimationFrame(rAFTime);\n      });\n    }\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n这个函数的作用是请求主线程即时回调。这里根据 enableMessageLoopImplementation 消息循环机制的实现是否开启分成了两种方式。我们主要来看消息循环实现的这种。\n\n\n# postMessage：发送执行消息\n\n// see: https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel\nconst channel = new MessageChannel();\nconst port = channel.port2;\n// 当 port 上发消息时，会执行 performWorkUntilDeadline\nchannel.port1.onmessage = performWorkUntilDeadline;\n\n\n1\n2\n3\n4\n5\n\n\n这里使用了 MessageChannel API，兼容性很好。能够在 port1 和 post2 之间发送和接受消息。这里 port1 监听到 port 发消息就会执行 performWorkUntilDeadline。\n\n\n# performWorkUntilDeadline: 执行回调函数\n\nperformWorkUntilDeadline 函数是调度任务的执行者，\n\n// 执行回调任务\nconst performWorkUntilDeadline = () => {\n  if (enableMessageLoopImplementation) {\n    if (scheduledHostCallback !== null) {\n      const currentTime = getCurrentTime();\n      // Yield after `frameLength` ms, regardless of where we are in the vsync\n      // cycle(硬件设备的频率). This means there's always time remaining at the beginning of\n      // the message event.\n      // 在 frameLength 之后 yield，因此在消息时间开始时有剩余的时间\n      frameDeadline = currentTime + frameLength;\n      const hasTimeRemaining = true;\n      // 调用回调函数，回调函数返回布尔值表示是否中断\n      try {\n        const hasMoreWork = scheduledHostCallback(\n          hasTimeRemaining,\n          currentTime,\n        );\n        // 没有更多任务，清空 scheduledHostCallback\n        // 结合到 react 逻辑，如果没有中断，本次回调结束\n        if (!hasMoreWork) {\n          isMessageLoopRunning = false;\n          scheduledHostCallback = null;\n        } else {\n          // If there's more work, schedule the next message event at the end\n          // of the preceding one.\n          // 如果有更多的任务，继续发起下一个事件回调\n          // 结合 react 逻辑，如果有中断，在发一次消息，排除一个执行者\n          port.postMessage(null);\n        }\n      } catch (error) {\n        // If a scheduler task throws, exit the current browser task so the\n        // error can be observed.\n        // 如果当前回调调用失败，继续发起下一个事件消息\n        port.postMessage(null);\n        throw error;\n      }\n    } else {\n      // 没有回调就把消息锁打开\n      isMessageLoopRunning = false;\n    }\n    // Yielding to the browser will give it a chance to paint, so we can\n    // reset this.\n    needsPaint = false;\n  } else {\n    // 如果没有打开 MessageLoop 特性，就 不会自动发起下一个事件回调，由上层函数每帧检查进行回调\n    if (scheduledHostCallback !== null) {\n      const currentTime = getCurrentTime();\n      const hasTimeRemaining = frameDeadline - currentTime > 0;\n      try {\n        const hasMoreWork = scheduledHostCallback(\n          hasTimeRemaining,\n          currentTime,\n        );\n        if (!hasMoreWork) {\n          scheduledHostCallback = null;\n        }\n      } catch (error) {\n        // If a scheduler task throws, exit the current browser task so the\n        // error can be observed, and post a new task as soon as possible\n        // so we can continue where we left off.\n        port.postMessage(null);\n        throw error;\n      }\n    }\n    // Yielding to the browser will give it a chance to paint, so we can\n    // reset this.\n    needsPaint = false;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# onAnimationFrame\n\nconst onAnimationFrame = rAFTime => {\n  // 没有回调任务\n  if (scheduledHostCallback === null) {\n    // No scheduled work. Exit.\n    prevRAFTime = -1;\n    prevRAFInterval = -1;\n    isRAFLoopRunning = false;\n    return;\n  }\n\n  // Eagerly schedule the next animation callback at the beginning of the\n  // frame. If the scheduler queue is not empty at the end of the frame, it\n  // will continue flushing inside that callback. If the queue *is* empty,\n  // then it will exit immediately. Posting the callback at the start of the\n  // frame ensures it's fired within the earliest possible frame. If we\n  // waited until the end of the frame to post the callback, we risk the\n  // browser skipping a frame and not firing the callback until the frame\n  // after that.\n  // 在帧首提前调度下一个动画回调。如果在帧尾调度队列非空，将会在此次回调时继续执行其他的回调。\n  // 如果调度队列为空，则立即退出。在帧首调节这个回调以保证他会在尽可能早的帧里被触发。\n  // 如果等到帧尾在提交回调，可能会导致浏览器有跳帧和没有在帧尾触发回调的风险。\n  isRAFLoopRunning = true;\n  requestAnimationFrame(nextRAFTime => {\\=\n    // 在下一帧中清除定时器并再次执行onAnimationFrame\n    clearTimeout(rAFTimeoutID);\n    onAnimationFrame(nextRAFTime);\n  });\n\n  // requestAnimationFrame is throttled when the tab is backgrounded. We\n  // don't want to stop working entirely. So we'll fallback to a timeout loop.\n  // TODO: Need a better heuristic for backgrounded work.\n  // 当 tab 页在后台时，rAF 将会被节流。我们并不想完全停止，所以这时回退到 setTimeout。\n  const onTimeout = () => {\n    frameDeadline = getCurrentTime() + frameLength / 2;\n    performWorkUntilDeadline();\n    rAFTimeoutID = setTimeout(onTimeout, frameLength * 3);\n  };\n  rAFTimeoutID = setTimeout(onTimeout, frameLength * 3);\n\n  if (\n    prevRAFTime !== -1 &&\n    // Make sure this rAF time is different from the previous one. This check\n    // could fail if two rAFs fire in the same frame.\n    // 保证新的 rAF 并非原来的 rAF。这里意思是 rAFTime 和 prevRAFTime 不在同一帧。\n    rAFTime - prevRAFTime > 0.1\n  ) {\n    const rAFInterval = rAFTime - prevRAFTime;\n    if (!fpsLocked && prevRAFInterval !== -1) {\n      // We've observed two consecutive frame intervals. We'll use this to\n      // dynamically adjust the frame rate.\n\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently\n      // optimizing. For example, if we're running on 120hz display or 90hz VR\n      // display. Take the max of the two in case one of them was an anomaly\n      // due to missed frame deadlines.\n      // 观察到两个连续的帧间隔，将以此动态调整帧率\n      // 如果两次的帧时间间隔都小于 frameLength，说明浏览器 CPU 资源富足(帧率较高)，将降低 yield 的间隔 frameLength。\n      // 根据连续两帧之间的间隔时间动态调整 frameLength\n      if (rAFInterval < frameLength && prevRAFInterval < frameLength) {\n        // 调整为两者中较大值\n        frameLength =\n          rAFInterval < prevRAFInterval ? prevRAFInterval : rAFInterval;\n        // 最小只能降低到 8.33\n        if (frameLength < 8.33) {\n          // Defensive coding. We don't support higher frame rates than 120hz.\n          // If the calculated frame length gets lower than 8, it is probably\n          // a bug.\n          // 最多只能支持 120 赫兹的帧率，\n          frameLength = 8.33;\n        }\n      }\n    }\n    prevRAFInterval = rAFInterval;\n  }\n  // 保存上一次的rAFTime并更新frameDeadline\n  prevRAFTime = rAFTime;\n  frameDeadline = rAFTime + frameLength;\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  // 发出回调消息\n  // 发消息只是检查有无回调任务，有则执行。\n  port.postMessage(null);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n\n# cancelHostCallback\n\ncancelHostCallback = function() {\n  scheduledHostCallback = null;\n};\n\n\n1\n2\n3\n\n\n\n# requestHostTimeout：请求主线程延时回调\n\n// 请求主线程延时回调。这里直接用了 setTimeout。\nrequestHostTimeout = function(callback, ms) {\n  taskTimeoutID = setTimeout(() => {\n    callback(getCurrentTime());\n  }, ms);\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# cancelHostTimeout：取消主线程延迟回调\n\ncancelHostTimeout = function() {\n  clearTimeout(taskTimeoutID);\n  taskTimeoutID = -1;\n};\n\n\n1\n2\n3\n4\n",normalizedContent:"# 目录\n\n\n\n * 目录\n * 非 dom 环境\n * requesthostcallback：请求主线程回调\n   * postmessage：发送执行消息\n   * performworkuntildeadline: 执行回调函数\n   * onanimationframe\n * cancelhostcallback\n * requesthosttimeout：请求主线程延时回调\n * cancelhosttimeout：取消主线程延迟回调\n\n\n\n\n# 非 dom 环境\n\n在非 dom 环境中，不存在 raf api，因此采用了原生的 settimeout 来模拟。这里主要用于 node 环境。\n\nif (\n  // if scheduler runs in a non-dom environment, it falls back to a naive\n  // implementation using settimeout.\n  // 在非 dom 环境中，回退到 settimeout 的原生实现，因为 非 dom 环境没有 raf api。\n  typeof window === 'undefined' ||\n  // check if messagechannel is supported, too.\n  // dom 环境要用到 messagechannel api\n  // 如果 window 和messagechannel 都不存在，就是用原生 settimeout 模拟\n  typeof messagechannel !== 'function'\n) {\n  // if this accidentally gets imported in a non-browser environment, e.g. javascriptcore,\n  // fallback to a naive implementation.\n  let _callback = null;\n  let _timeoutid = null;\n  // 如果有 callback 就执行，执行失败就尝试空闲时段重新执行\n  const _flushcallback = function() {\n    if (_callback !== null) {\n      try {\n        const currenttime = getcurrenttime();\n        const hasremainingtime = true;\n        _callback(hasremainingtime, currenttime);\n        _callback = null;\n      } catch (e) {\n        settimeout(_flushcallback, 0);\n        throw e;\n      }\n    }\n  };\n  // scheduler 初始化的时间\n  const initialtime = date.now();\n  // 距离初始化的时间差\n  getcurrenttime = function() {\n    return date.now() - initialtime;\n  };\n  // 请求主线程回调\n  requesthostcallback = function(cb) {\n    if (_callback !== null) {\n      // protect against re-entrancy.\n      // 这里将 requesthostcallback 作为定时器的回调传入，延迟 0 毫秒表示回调将在空闲时间立即执行，\n      // 执行时将 cb 作为参数传入\n      // 如果 callback 还未 flush，就尝试在空闲时间重新请求回调（依次循环）\n      settimeout(requesthostcallback, 0, cb);\n    } else {\n      // callback 为空时挂载 cb，并且在空闲时间执行 callback\n      _callback = cb;\n      settimeout(_flushcallback, 0);\n    }\n  };\n  // 取消主线程当前的回调，当前即时回调 由 _callback 管理\n  cancelhostcallback = function() {\n    _callback = null;\n  };\n  // 请求主线程延时回调，直接调用 settimeout\n  requesthosttimeout = function(cb, ms) {\n    _timeoutid = settimeout(cb, ms);\n  };\n  // 取消主线程当前延时回调，当前延时回调由 _timeoutid 管理\n  cancelhosttimeout = function() {\n    cleartimeout(_timeoutid);\n  };\n  shouldyieldtohost = function() {\n    return false;\n  };\n  // 请求重绘\n  requestpaint = forceframerate = function() {};\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n在 dom 环境中，将会以 raf 和 settimeout 模拟。\n\n\n# requesthostcallback：请求主线程回调\n\n// 请求主线程即时回调\nrequesthostcallback = function (callback) {\n  // 保存下当前的 callback\n  scheduledhostcallback = callback;\n  if (enablemessageloopimplementation) {\n    // 如果当前还没有打开消息循环，说明没有其他消息回调在处理，可以打开消息循环（加锁），并发出消息\n    if (!ismessagelooprunning) {\n      ismessagelooprunning = true;\n      port.postmessage(null);\n    }\n  } else {\n    // 如果enablemessageloopimplementation为 false，即没有打开消息循环的特性(不使用 messagechannel api)，就直接用 raf 循环实现\n    if (!israflooprunning) {\n      // start a raf loop.\n      israflooprunning = true;\n      // raftime 指的是 performance.now() 的时间\n      requestanimationframe(raftime => {\n        onanimationframe(raftime);\n      });\n    }\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n这个函数的作用是请求主线程即时回调。这里根据 enablemessageloopimplementation 消息循环机制的实现是否开启分成了两种方式。我们主要来看消息循环实现的这种。\n\n\n# postmessage：发送执行消息\n\n// see: https://developer.mozilla.org/en-us/docs/web/api/messagechannel\nconst channel = new messagechannel();\nconst port = channel.port2;\n// 当 port 上发消息时，会执行 performworkuntildeadline\nchannel.port1.onmessage = performworkuntildeadline;\n\n\n1\n2\n3\n4\n5\n\n\n这里使用了 messagechannel api，兼容性很好。能够在 port1 和 post2 之间发送和接受消息。这里 port1 监听到 port 发消息就会执行 performworkuntildeadline。\n\n\n# performworkuntildeadline: 执行回调函数\n\nperformworkuntildeadline 函数是调度任务的执行者，\n\n// 执行回调任务\nconst performworkuntildeadline = () => {\n  if (enablemessageloopimplementation) {\n    if (scheduledhostcallback !== null) {\n      const currenttime = getcurrenttime();\n      // yield after `framelength` ms, regardless of where we are in the vsync\n      // cycle(硬件设备的频率). this means there's always time remaining at the beginning of\n      // the message event.\n      // 在 framelength 之后 yield，因此在消息时间开始时有剩余的时间\n      framedeadline = currenttime + framelength;\n      const hastimeremaining = true;\n      // 调用回调函数，回调函数返回布尔值表示是否中断\n      try {\n        const hasmorework = scheduledhostcallback(\n          hastimeremaining,\n          currenttime,\n        );\n        // 没有更多任务，清空 scheduledhostcallback\n        // 结合到 react 逻辑，如果没有中断，本次回调结束\n        if (!hasmorework) {\n          ismessagelooprunning = false;\n          scheduledhostcallback = null;\n        } else {\n          // if there's more work, schedule the next message event at the end\n          // of the preceding one.\n          // 如果有更多的任务，继续发起下一个事件回调\n          // 结合 react 逻辑，如果有中断，在发一次消息，排除一个执行者\n          port.postmessage(null);\n        }\n      } catch (error) {\n        // if a scheduler task throws, exit the current browser task so the\n        // error can be observed.\n        // 如果当前回调调用失败，继续发起下一个事件消息\n        port.postmessage(null);\n        throw error;\n      }\n    } else {\n      // 没有回调就把消息锁打开\n      ismessagelooprunning = false;\n    }\n    // yielding to the browser will give it a chance to paint, so we can\n    // reset this.\n    needspaint = false;\n  } else {\n    // 如果没有打开 messageloop 特性，就 不会自动发起下一个事件回调，由上层函数每帧检查进行回调\n    if (scheduledhostcallback !== null) {\n      const currenttime = getcurrenttime();\n      const hastimeremaining = framedeadline - currenttime > 0;\n      try {\n        const hasmorework = scheduledhostcallback(\n          hastimeremaining,\n          currenttime,\n        );\n        if (!hasmorework) {\n          scheduledhostcallback = null;\n        }\n      } catch (error) {\n        // if a scheduler task throws, exit the current browser task so the\n        // error can be observed, and post a new task as soon as possible\n        // so we can continue where we left off.\n        port.postmessage(null);\n        throw error;\n      }\n    }\n    // yielding to the browser will give it a chance to paint, so we can\n    // reset this.\n    needspaint = false;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# onanimationframe\n\nconst onanimationframe = raftime => {\n  // 没有回调任务\n  if (scheduledhostcallback === null) {\n    // no scheduled work. exit.\n    prevraftime = -1;\n    prevrafinterval = -1;\n    israflooprunning = false;\n    return;\n  }\n\n  // eagerly schedule the next animation callback at the beginning of the\n  // frame. if the scheduler queue is not empty at the end of the frame, it\n  // will continue flushing inside that callback. if the queue *is* empty,\n  // then it will exit immediately. posting the callback at the start of the\n  // frame ensures it's fired within the earliest possible frame. if we\n  // waited until the end of the frame to post the callback, we risk the\n  // browser skipping a frame and not firing the callback until the frame\n  // after that.\n  // 在帧首提前调度下一个动画回调。如果在帧尾调度队列非空，将会在此次回调时继续执行其他的回调。\n  // 如果调度队列为空，则立即退出。在帧首调节这个回调以保证他会在尽可能早的帧里被触发。\n  // 如果等到帧尾在提交回调，可能会导致浏览器有跳帧和没有在帧尾触发回调的风险。\n  israflooprunning = true;\n  requestanimationframe(nextraftime => {\\=\n    // 在下一帧中清除定时器并再次执行onanimationframe\n    cleartimeout(raftimeoutid);\n    onanimationframe(nextraftime);\n  });\n\n  // requestanimationframe is throttled when the tab is backgrounded. we\n  // don't want to stop working entirely. so we'll fallback to a timeout loop.\n  // todo: need a better heuristic for backgrounded work.\n  // 当 tab 页在后台时，raf 将会被节流。我们并不想完全停止，所以这时回退到 settimeout。\n  const ontimeout = () => {\n    framedeadline = getcurrenttime() + framelength / 2;\n    performworkuntildeadline();\n    raftimeoutid = settimeout(ontimeout, framelength * 3);\n  };\n  raftimeoutid = settimeout(ontimeout, framelength * 3);\n\n  if (\n    prevraftime !== -1 &&\n    // make sure this raf time is different from the previous one. this check\n    // could fail if two rafs fire in the same frame.\n    // 保证新的 raf 并非原来的 raf。这里意思是 raftime 和 prevraftime 不在同一帧。\n    raftime - prevraftime > 0.1\n  ) {\n    const rafinterval = raftime - prevraftime;\n    if (!fpslocked && prevrafinterval !== -1) {\n      // we've observed two consecutive frame intervals. we'll use this to\n      // dynamically adjust the frame rate.\n\n      // if one frame goes long, then the next one can be short to catch up.\n      // if two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently\n      // optimizing. for example, if we're running on 120hz display or 90hz vr\n      // display. take the max of the two in case one of them was an anomaly\n      // due to missed frame deadlines.\n      // 观察到两个连续的帧间隔，将以此动态调整帧率\n      // 如果两次的帧时间间隔都小于 framelength，说明浏览器 cpu 资源富足(帧率较高)，将降低 yield 的间隔 framelength。\n      // 根据连续两帧之间的间隔时间动态调整 framelength\n      if (rafinterval < framelength && prevrafinterval < framelength) {\n        // 调整为两者中较大值\n        framelength =\n          rafinterval < prevrafinterval ? prevrafinterval : rafinterval;\n        // 最小只能降低到 8.33\n        if (framelength < 8.33) {\n          // defensive coding. we don't support higher frame rates than 120hz.\n          // if the calculated frame length gets lower than 8, it is probably\n          // a bug.\n          // 最多只能支持 120 赫兹的帧率，\n          framelength = 8.33;\n        }\n      }\n    }\n    prevrafinterval = rafinterval;\n  }\n  // 保存上一次的raftime并更新framedeadline\n  prevraftime = raftime;\n  framedeadline = raftime + framelength;\n\n  // we use the postmessage trick to defer idle work until after the repaint.\n  // 发出回调消息\n  // 发消息只是检查有无回调任务，有则执行。\n  port.postmessage(null);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n\n# cancelhostcallback\n\ncancelhostcallback = function() {\n  scheduledhostcallback = null;\n};\n\n\n1\n2\n3\n\n\n\n# requesthosttimeout：请求主线程延时回调\n\n// 请求主线程延时回调。这里直接用了 settimeout。\nrequesthosttimeout = function(callback, ms) {\n  tasktimeoutid = settimeout(() => {\n    callback(getcurrenttime());\n  }, ms);\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# cancelhosttimeout：取消主线程延迟回调\n\ncancelhosttimeout = function() {\n  cleartimeout(tasktimeoutid);\n  tasktimeoutid = -1;\n};\n\n\n1\n2\n3\n4\n",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"scheduler 顶层 API",frontmatter:{title:"scheduler 顶层 API",date:"2022-04-14T22:02:21.000Z",permalink:"/react/scheduler/scheduler/",categories:["react","scheduler"],tags:[null]},regularPath:"/10.react/30.%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%88Scheduler%EF%BC%89/30.scheduler.html",relativePath:"10.react/30.调度器（Scheduler）/30.scheduler.md",key:"v-21473796",path:"/react/scheduler/scheduler/",headers:[{level:2,title:"scheduler 中是如何定义优先级的？",slug:"scheduler-中是如何定义优先级的",normalizedTitle:"scheduler 中是如何定义优先级的？",charIndex:27}],readingTime:{text:"1 min read",minutes:.29,time:17400,words:58},headersStr:"scheduler 中是如何定义优先级的？",content:"在这篇文章里介绍一下调度器里其他的 Api。\n\n\n# scheduler 中是如何定义优先级的？\n\nscheduler 中将任务的优先级分成如下的几种：\n\nexport type PriorityLevel = 0 | 1 | 2 | 3 | 4 | 5;\n\nexport const NoPriority = 0; // 最低优先级\nexport const ImmediatePriority = 1; // zui\nexport const UserBlockingPriority = 2;\nexport const NormalPriority = 3;\nexport const LowPriority = 4;\nexport const IdlePriority = 5;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",normalizedContent:"在这篇文章里介绍一下调度器里其他的 api。\n\n\n# scheduler 中是如何定义优先级的？\n\nscheduler 中将任务的优先级分成如下的几种：\n\nexport type prioritylevel = 0 | 1 | 2 | 3 | 4 | 5;\n\nexport const nopriority = 0; // 最低优先级\nexport const immediatepriority = 1; // zui\nexport const userblockingpriority = 2;\nexport const normalpriority = 3;\nexport const lowpriority = 4;\nexport const idlepriority = 5;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-14T22:02:21.000Z",permalink:"/react/updater/index/",categories:["react","updater"],tags:[null]},regularPath:"/10.react/40.%E6%9B%B4%E6%96%B0%E5%99%A8%EF%BC%88Updater%EF%BC%89/0.index.html",relativePath:"10.react/40.更新器（Updater）/0.index.md",key:"v-492f4a82",path:"/react/updater/index/",readingTime:{text:"1 min read",minutes:.115,time:6900,words:23},headersStr:null,content:"在调和器章节，我们已经在 react-reconciliation 包中学习到了调和器中调和器的入口函数 scheduleUpdateOnFiber、ensureRootIsScheduled 确保 FiberRoot 被调度、同步渲染的调度的调度函数 scheduleSyncCallback、异步渲染的调度函数 scheduleCallback、追踪调度过程函数 schedulePendingInteractions、在 FiberRoot 上调度更新异步任务函数 performConcurrentWorkOnRoot、在 FiberRoot 上调度更新同步任务函数 performSyncWorkOnRoot 等重要函数。本章我们继续探索 React 调度更新的过程，着重学习调后后的任务是经过更新器的处理将 FiberTree 转化为 ReactElementTree 的。",normalizedContent:"在调和器章节，我们已经在 react-reconciliation 包中学习到了调和器中调和器的入口函数 scheduleupdateonfiber、ensurerootisscheduled 确保 fiberroot 被调度、同步渲染的调度的调度函数 schedulesynccallback、异步渲染的调度函数 schedulecallback、追踪调度过程函数 schedulependinginteractions、在 fiberroot 上调度更新异步任务函数 performconcurrentworkonroot、在 fiberroot 上调度更新同步任务函数 performsyncworkonroot 等重要函数。本章我们继续探索 react 调度更新的过程，着重学习调后后的任务是经过更新器的处理将 fibertree 转化为 reactelementtree 的。",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"workLoop 和 performUnitOfWork",frontmatter:{title:"workLoop 和 performUnitOfWork",date:"2022-04-14T22:02:21.000Z",permalink:"/react/updater/workloop/",categories:["react","updater"],tags:[null]},regularPath:"/10.react/40.%E6%9B%B4%E6%96%B0%E5%99%A8%EF%BC%88Updater%EF%BC%89/10.workloop.html",relativePath:"10.react/40.更新器（Updater）/10.workloop.md",key:"v-1d8100c2",path:"/react/updater/workloop/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"workLoopSync 和 workLoopConcurrent",slug:"workloopsync-和-workloopconcurrent",normalizedTitle:"workloopsync 和 workloopconcurrent",charIndex:17},{level:2,title:"performUnitOfWork",slug:"performunitofwork",normalizedTitle:"performunitofwork",charIndex:54},{level:2,title:"beginWork",slug:"beginwork",normalizedTitle:"beginwork",charIndex:75},{level:2,title:"mountIndeterminateComponent",slug:"mountindeterminatecomponent",normalizedTitle:"mountindeterminatecomponent",charIndex:88}],readingTime:{text:"10 min read",minutes:9.3,time:558e3,words:1860},headersStr:"目录 workLoopSync 和 workLoopConcurrent performUnitOfWork beginWork mountIndeterminateComponent",content:"# 目录\n\n\n\n * 目录\n * workLoopSync 和 workLoopConcurrent\n * performUnitOfWork\n * beginWork\n * mountIndeterminateComponent\n\n\n\n本节的代码主要在 react-reconciler 包中。\n\n\n# workLoopSync 和 workLoopConcurrent\n\n在调和器章节中，我们注意到 performConcurrentWorkOnRoot 函数调用了 workLoopConcurrent 方法。performSyncWorkOnRoot 中调用了 workLoopSync 方法。下面我们重点看下 workLoopConcurrent 和 workLoopSync 方法的原理。代码如下：\n\n// The fiber we're working on\nlet workInProgress: Fiber | null = null;\n\n// The work loop is an extremely hot path. Tell Closure not to inline it.\n/** @noinline */\nfunction workLoopSync() {\n  // Already timed out, so perform work without checking if we need to yield.\n  while (workInProgress !== null) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n\n/** @noinline */\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n分析如下：\n\n * 从代码总体上来看，不管是同步的调度还是异步的调度，到了 workLoop 这里，并不区分同步还是异步，都是调用 performUnitOfWork 方法处理。\n * workInProgress 表示当前正在处理的 Fiber，本质上 performUnitOfWork 是对 workInProgress Fiber 的更新。loop 的含义就在于，只要 workInProgress 不为空，就要一直调用 performUnitOfWork 处理当前的 Fiber。\n * 对于异步回调过来的任务，在 performUnitOfWork 处理每一个 Fiber 之前都要判断 shouldYield 的值是否是 false。shouldYield 是从调度器中发来的信息，表示当前是否有更高优先级的任务需要处理。对于同步任务则不需要判断，因为同步任务本身就是最高优先级的任务。如果调度器发出了新的回调，workLoopConcurrent 会被终止，新的回调 performConcurrentWorkOnRoot 中 prepareFreshStack 函数中更新 workInProgress，使 workInProgress 指向优先级更高的 FiberRoot，此后更高优先级的 workLoopConcurrent 就会触发。\n * @inline 是一个告诉编译器不要 inlining 函数的标记。由于 workLoopSync 是一个会被频繁调用的函数，加此标记其实在编译器调优。更详细请参考如下文档：To Inline or Not to Inline? Enhanced Inlining Decisions、An annotation to either prevent or force inlining of a function\n\n> Inlining heavy functions results in little performance improvement. First, very few runtime function calls are eliminated. Second, the path from the caller to a heavy function is not a hot path at all, and thus will not benefit from postinlining optimization. Third, inlining heavy functions might prevent frequent edges from being inlined if the code growth budget is spent.\n\n\n# performUnitOfWork\n\n首先我们来解释一下 unitOfWork 的含义，从上文我们已经了解到不管是同步任务还是异步任务都会发起一个 workLoop，在这个 workLoop 中不要不断的调用 performUnitOfWork 来处理当前 Fiber。unitOfWork 从字面含义上来看是任务单元的意思，因此可以 performUnitOfWork 看做是执行任务单元的活动。一个完整的 workLoop 正是通过这样的任务单元积累起来的。从整个调和器来看 performUnitOfWork 才是真正干苦力的工人。\n\nfunction performUnitOfWork(unitOfWork: Fiber): Fiber | null {\n  // The current, flushed, state of this fiber is the alternate. Ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  // 从 Fiber 版本池中获取 alternate Fiber，current 中包含 Fiber 的状态\n  // current 指的是已经渲染在页面上的 Fiber(current fiber)，unitOfWork 指的是即将被渲染的 Fiber（pending fiber）。\n  const current = unitOfWork.alternate;\n\n  // 开启活动计时，只在 enableUserTimingAPI 特性开启时\n  startWorkTimer(unitOfWork);\n  setCurrentDebugFiberInDEV(unitOfWork);\n\n  let next;\n  // 判断 unitOfWork.mode === ProfileMode，开启了enableProfilerTimer模式，如果此时是 ProfileMode\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\n    startProfilerTimer(unitOfWork);\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n    // 开始执行活动，并返回下一活动\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n  }\n\n  resetCurrentDebugFiberInDEV();\n  // \n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    // 如果没有更多活动，则完成 workLoop\n    next = completeUnitOfWork(unitOfWork);\n  }\n\n  // 标记当前 workInProgress 的 owner component 为 null\n  ReactCurrentOwner.current = null;\n  return next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n其中比较关键的是如下代码：\n\nnext = beginWork(current, unitOfWork, renderExpirationTime);\nunitOfWork.memoizedProps = unitOfWork.pendingProps;\nif (next === null) {\n  // If this doesn't spawn new work, complete the current work.\n  // 如果没有更多活动，则完成 workLoop\n  next = completeUnitOfWork(unitOfWork);\n}\n\n// 标记当前 workInProgress 的 owner component 为 null\nReactCurrentOwner.current = null;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n从整体上来看，performUnitOfWork 处理了如下的工作：\n\n 1. 调用 beginWork，将 Fiber 更新（或者创建）为 ReactElement 并返回下一个任务（child 或者是 null）。\n 2. 将 memoizedProps 更新为 pendingProps，便于下一次 beginWork 使用。\n 3. 如果 beginWork 之后没有任务了，则调用 completeUnitOfWork 做一些首位工作。\n 4. 清空 ReactCurrentOwner 标记。\n\n\n# beginWork\n\nbeginWork 函数比较复杂，他的大致思路如下：\n\nfunction () {\n  // update 阶段\n  if(isUpdate) {\n    // pending fiber 优先级小于渲染的优先级\n    if(updateExpirationTime < renderExpirationTime) {\n      // 不需要执行任务，根据 pending fiber 的类型将 fiber 入 context stack;\n      switch (workInProgress.tag) {\n        case SomeType: \n          pushContext(workInProgress);\n          // 一些其他的处理;\n          return null || child || child.sibling 等;\n      }\n    }\n  }\n\n  // 根据 pending fiber 的类型，创建或者更新，返回 ReactElement\n  switch (workInProgress.tag) {\n    case SomeType: \n      return mountOrUpdateComponent();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n下面我们展开来看：\n\nfunction beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n): Fiber | null {\n  // 获取 pending fiber 的过期时间\n  const updateExpirationTime = workInProgress.expirationTime;\n\n  // current 区分首次渲染，current !== null 表示 update 阶段\n  // 如果是 update 阶段可以复用 current，因此可以更新并提前返回，否则 mount 阶段就需要 mountXXXComponent\n  if (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n    // 判断 newFiber 和 oldFiber 中 props 是否变化\n    if (\n      oldProps !== newProps ||\n      hasLegacyContextChanged()\n    ) {\n      // If props or context changed, mark the fiber as having performed work.\n      // This may be unset if the props are determined to be equal later (memo).\n      didReceiveUpdate = true;\n    } else if (updateExpirationTime < renderExpirationTime) {\n      // pending fiber 的优先级小于 render 优先级，不需要执行任务\n      didReceiveUpdate = false;\n      // This fiber does not have any pending work. Bailout without entering\n      // the begin phase. There's still some bookkeeping we that needs to be done\n      // in this optimized path, mostly pushing stuff onto the stack.\n      // 根据 pending fiber 的类型推入 context stack\n      switch (workInProgress.tag) {\n        case HostRoot:\n          pushHostRootContext(workInProgress);\n          resetHydrationState();\n          break;\n        case HostComponent:\n          pushHostContext(workInProgress);\n          if (\n            workInProgress.mode & ConcurrentMode &&\n            renderExpirationTime !== Never &&\n            shouldDeprioritizeSubtree(workInProgress.type, newProps)\n          ) {\n            if (enableSchedulerTracing) {\n              markSpawnedWork(Never);\n            }\n            // Schedule this fiber to re-render at offscreen priority. Then bailout.\n            workInProgress.expirationTime = workInProgress.childExpirationTime = Never;\n            return null;\n          }\n          break;\n        case ClassComponent: {\n          const Component = workInProgress.type;\n          if (isLegacyContextProvider(Component)) {\n            pushLegacyContextProvider(workInProgress);\n          }\n          break;\n        }\n        case HostPortal:\n          pushHostContainer(\n            workInProgress,\n            workInProgress.stateNode.containerInfo,\n          );\n          break;\n        case ContextProvider: {\n          const newValue = workInProgress.memoizedProps.value;\n          pushProvider(workInProgress, newValue);\n          break;\n        }\n        case Profiler:\n          if (enableProfilerTimer) {\n            workInProgress.effectTag |= Update;\n          }\n          break;\n        case SuspenseComponent: {\n          const state: SuspenseState | null = workInProgress.memoizedState;\n          if (state !== null) {\n            if (enableSuspenseServerRenderer) {\n              if (state.dehydrated !== null) {\n                pushSuspenseContext(\n                  workInProgress,\n                  setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n                );\n                // We know that this component will suspend again because if it has\n                // been unsuspended it has committed as a resolved Suspense component.\n                // If it needs to be retried, it should have work scheduled on it.\n                workInProgress.effectTag |= DidCapture;\n                break;\n              }\n            }\n\n            // If this boundary is currently timed out, we need to decide\n            // whether to retry the primary children, or to skip over it and\n            // go straight to the fallback. Check the priority of the primary\n            // child fragment.\n            const primaryChildFragment: Fiber = (workInProgress.child: any);\n            const primaryChildExpirationTime =\n              primaryChildFragment.childExpirationTime;\n            if (\n              primaryChildExpirationTime !== NoWork &&\n              primaryChildExpirationTime >= renderExpirationTime\n            ) {\n              // The primary children have pending work. Use the normal path\n              // to attempt to render the primary children again.\n              return updateSuspenseComponent(\n                current,\n                workInProgress,\n                renderExpirationTime,\n              );\n            } else {\n              pushSuspenseContext(\n                workInProgress,\n                setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n              );\n              // The primary children do not have pending work with sufficient\n              // priority. Bailout.\n              const child = bailoutOnAlreadyFinishedWork(\n                current,\n                workInProgress,\n                renderExpirationTime,\n              );\n              if (child !== null) {\n                // The fallback children have pending work. Skip over the\n                // primary children and work on the fallback.\n                return child.sibling;\n              } else {\n                return null;\n              }\n            }\n          } else {\n            pushSuspenseContext(\n              workInProgress,\n              setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n            );\n          }\n          break;\n        }\n        case SuspenseListComponent: {\n          const didSuspendBefore =\n            (current.effectTag & DidCapture) !== NoEffect;\n\n          const hasChildWork =\n            workInProgress.childExpirationTime >= renderExpirationTime;\n\n          if (didSuspendBefore) {\n            if (hasChildWork) {\n              // If something was in fallback state last time, and we have all the\n              // same children then we're still in progressive loading state.\n              // Something might get unblocked by state updates or retries in the\n              // tree which will affect the tail. So we need to use the normal\n              // path to compute the correct tail.\n              return updateSuspenseListComponent(\n                current,\n                workInProgress,\n                renderExpirationTime,\n              );\n            }\n            // If none of the children had any work, that means that none of\n            // them got retried so they'll still be blocked in the same way\n            // as before. We can fast bail out.\n            workInProgress.effectTag |= DidCapture;\n          }\n\n          // If nothing suspended before and we're rendering the same children,\n          // then the tail doesn't matter. Anything new that suspends will work\n          // in the \"together\" mode, so we can continue from the state we had.\n          let renderState = workInProgress.memoizedState;\n          if (renderState !== null) {\n            // Reset to the \"together\" mode in case we've started a different\n            // update in the past but didn't complete it.\n            renderState.rendering = null;\n            renderState.tail = null;\n          }\n          pushSuspenseContext(workInProgress, suspenseStackCursor.current);\n\n          if (hasChildWork) {\n            break;\n          } else {\n            // If none of the children had any work, that means that none of\n            // them got retried so they'll still be blocked in the same way\n            // as before. We can fast bail out.\n            return null;\n          }\n        }\n      }\n      // 如果子树需要渲染，返回 child，否则返回 null。\n      return bailoutOnAlreadyFinishedWork(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    } else {\n      // An update was scheduled on this fiber, but there are no new props\n      // nor legacy context. Set this to false. If an update queue or context\n      // consumer produces a changed value, it will set this to true. Otherwise,\n      // the component will assume the children have not changed and bail out.\n      // \n      didReceiveUpdate = false;\n    }\n  } else {\n    didReceiveUpdate = false;\n  }\n  // mount 阶段或者少数更新情况会执行下面的内容，进入 begin 的阶段\n  // Before entering the begin phase, clear the expiration time.\n  workInProgress.expirationTime = NoWork;\n\n  // 根据 pending fiber 的类型，返回不同的 ReactElement\n  switch (workInProgress.tag) {\n    case IndeterminateComponent: {\n      return mountIndeterminateComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        renderExpirationTime,\n      );\n    }\n    case LazyComponent: {\n      const elementType = workInProgress.elementType;\n      return mountLazyComponent(\n        current,\n        workInProgress,\n        elementType,\n        updateExpirationTime,\n        renderExpirationTime,\n      );\n    }\n    case FunctionComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateFunctionComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderExpirationTime);\n    case HostComponent:\n      return updateHostComponent(current, workInProgress, renderExpirationTime);\n    case HostText:\n      return updateHostText(current, workInProgress);\n    case SuspenseComponent:\n      return updateSuspenseComponent(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    case HostPortal:\n      return updatePortalComponent(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    case ForwardRef: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === type\n          ? unresolvedProps\n          : resolveDefaultProps(type, unresolvedProps);\n      return updateForwardRef(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    case Fragment:\n      return updateFragment(current, workInProgress, renderExpirationTime);\n    case Mode:\n      return updateMode(current, workInProgress, renderExpirationTime);\n    case Profiler:\n      return updateProfiler(current, workInProgress, renderExpirationTime);\n    case ContextProvider:\n      return updateContextProvider(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    case ContextConsumer:\n      return updateContextConsumer(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    case MemoComponent: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      // Resolve outer props first, then resolve inner props.\n      let resolvedProps = resolveDefaultProps(type, unresolvedProps);\n      if (__DEV__) {\n        if (workInProgress.type !== workInProgress.elementType) {\n          const outerPropTypes = type.propTypes;\n          if (outerPropTypes) {\n            checkPropTypes(\n              outerPropTypes,\n              resolvedProps, // Resolved for outer only\n              'prop',\n              getComponentName(type),\n              getCurrentFiberStackInDev,\n            );\n          }\n        }\n      }\n      resolvedProps = resolveDefaultProps(type.type, resolvedProps);\n      return updateMemoComponent(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        updateExpirationTime,\n        renderExpirationTime,\n      );\n    }\n    case SimpleMemoComponent: {\n      return updateSimpleMemoComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        updateExpirationTime,\n        renderExpirationTime,\n      );\n    }\n    case IncompleteClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return mountIncompleteClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    case SuspenseListComponent: {\n      return updateSuspenseListComponent(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    }\n    case FundamentalComponent: {\n      if (enableFundamentalAPI) {\n        return updateFundamentalComponent(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      }\n      break;\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        return updateScopeComponent(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      }\n      break;\n    }\n  }\n  invariant(\n    false,\n    'Unknown unit of work tag (%s). This error is likely caused by a bug in ' +\n      'React. Please file an issue.',\n    workInProgress.tag,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n\n\n简要分析下这段代码：\n\n 1. beginWork 内部是区分 mount 阶段和 update 阶段来处理的，在 update 阶段只有 workInProgress 的优先级小于 render 优先级即 renderExpirationTime 时才会提前退出，返回 null 或者 child 或者其他特殊情况。这也就是说 下面的一系列的 mountComponent 或者 updateComponent 其实是在 mount 阶段和 update 阶段都会执行的。\n 2. 两段 switch case 的代码比较复杂，之后单独分析。大致上第一段 switch case 代码段执行了一系列入栈操作在 completeWork 函数中执行了一些列的出栈操作。具体作用后面具体剖析。第二段 switch case 代码比较重要，下面来先分析分析。\n\n\n# mountIndeterminateComponent\n\n我们先来弄清楚 IndeterminateComponent 是什么？\n\n在 shared/ReactWorkTags.js 文件中可以查到 IndeterminateComponent 的定义。从注释来看，IndeterminateComponent 应该是在未知是 FC (Function Component) 还是 CC (Class Function) 之前，为组件设定的临时类型。因此这种类型很有可能只在 mount 阶段出现，在 update 阶段会更新为 FunctionComponent 或者 ClassComponent。\n\n另外，从 mountLazyComponent 中调用 resolveLazyComponentTag 函数来看，如果 lazy component 不被识别为 ClassComponent、FunctionComponent、ForwardRef 或者 MemoComponent，就会被认为是 IndeterminateComponent 类型。\n\nexport const IndeterminateComponent = 2; // Before we know whether it is function or class\n\n\n1\n",normalizedContent:"# 目录\n\n\n\n * 目录\n * workloopsync 和 workloopconcurrent\n * performunitofwork\n * beginwork\n * mountindeterminatecomponent\n\n\n\n本节的代码主要在 react-reconciler 包中。\n\n\n# workloopsync 和 workloopconcurrent\n\n在调和器章节中，我们注意到 performconcurrentworkonroot 函数调用了 workloopconcurrent 方法。performsyncworkonroot 中调用了 workloopsync 方法。下面我们重点看下 workloopconcurrent 和 workloopsync 方法的原理。代码如下：\n\n// the fiber we're working on\nlet workinprogress: fiber | null = null;\n\n// the work loop is an extremely hot path. tell closure not to inline it.\n/** @noinline */\nfunction workloopsync() {\n  // already timed out, so perform work without checking if we need to yield.\n  while (workinprogress !== null) {\n    workinprogress = performunitofwork(workinprogress);\n  }\n}\n\n/** @noinline */\nfunction workloopconcurrent() {\n  // perform work until scheduler asks us to yield\n  while (workinprogress !== null && !shouldyield()) {\n    workinprogress = performunitofwork(workinprogress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n分析如下：\n\n * 从代码总体上来看，不管是同步的调度还是异步的调度，到了 workloop 这里，并不区分同步还是异步，都是调用 performunitofwork 方法处理。\n * workinprogress 表示当前正在处理的 fiber，本质上 performunitofwork 是对 workinprogress fiber 的更新。loop 的含义就在于，只要 workinprogress 不为空，就要一直调用 performunitofwork 处理当前的 fiber。\n * 对于异步回调过来的任务，在 performunitofwork 处理每一个 fiber 之前都要判断 shouldyield 的值是否是 false。shouldyield 是从调度器中发来的信息，表示当前是否有更高优先级的任务需要处理。对于同步任务则不需要判断，因为同步任务本身就是最高优先级的任务。如果调度器发出了新的回调，workloopconcurrent 会被终止，新的回调 performconcurrentworkonroot 中 preparefreshstack 函数中更新 workinprogress，使 workinprogress 指向优先级更高的 fiberroot，此后更高优先级的 workloopconcurrent 就会触发。\n * @inline 是一个告诉编译器不要 inlining 函数的标记。由于 workloopsync 是一个会被频繁调用的函数，加此标记其实在编译器调优。更详细请参考如下文档：to inline or not to inline? enhanced inlining decisions、an annotation to either prevent or force inlining of a function\n\n> inlining heavy functions results in little performance improvement. first, very few runtime function calls are eliminated. second, the path from the caller to a heavy function is not a hot path at all, and thus will not benefit from postinlining optimization. third, inlining heavy functions might prevent frequent edges from being inlined if the code growth budget is spent.\n\n\n# performunitofwork\n\n首先我们来解释一下 unitofwork 的含义，从上文我们已经了解到不管是同步任务还是异步任务都会发起一个 workloop，在这个 workloop 中不要不断的调用 performunitofwork 来处理当前 fiber。unitofwork 从字面含义上来看是任务单元的意思，因此可以 performunitofwork 看做是执行任务单元的活动。一个完整的 workloop 正是通过这样的任务单元积累起来的。从整个调和器来看 performunitofwork 才是真正干苦力的工人。\n\nfunction performunitofwork(unitofwork: fiber): fiber | null {\n  // the current, flushed, state of this fiber is the alternate. ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  // 从 fiber 版本池中获取 alternate fiber，current 中包含 fiber 的状态\n  // current 指的是已经渲染在页面上的 fiber(current fiber)，unitofwork 指的是即将被渲染的 fiber（pending fiber）。\n  const current = unitofwork.alternate;\n\n  // 开启活动计时，只在 enableusertimingapi 特性开启时\n  startworktimer(unitofwork);\n  setcurrentdebugfiberindev(unitofwork);\n\n  let next;\n  // 判断 unitofwork.mode === profilemode，开启了enableprofilertimer模式，如果此时是 profilemode\n  if (enableprofilertimer && (unitofwork.mode & profilemode) !== nomode) {\n    startprofilertimer(unitofwork);\n    next = beginwork(current, unitofwork, renderexpirationtime);\n    stopprofilertimerifrunningandrecorddelta(unitofwork, true);\n  } else {\n    // 开始执行活动，并返回下一活动\n    next = beginwork(current, unitofwork, renderexpirationtime);\n  }\n\n  resetcurrentdebugfiberindev();\n  // \n  unitofwork.memoizedprops = unitofwork.pendingprops;\n  if (next === null) {\n    // if this doesn't spawn new work, complete the current work.\n    // 如果没有更多活动，则完成 workloop\n    next = completeunitofwork(unitofwork);\n  }\n\n  // 标记当前 workinprogress 的 owner component 为 null\n  reactcurrentowner.current = null;\n  return next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n其中比较关键的是如下代码：\n\nnext = beginwork(current, unitofwork, renderexpirationtime);\nunitofwork.memoizedprops = unitofwork.pendingprops;\nif (next === null) {\n  // if this doesn't spawn new work, complete the current work.\n  // 如果没有更多活动，则完成 workloop\n  next = completeunitofwork(unitofwork);\n}\n\n// 标记当前 workinprogress 的 owner component 为 null\nreactcurrentowner.current = null;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n从整体上来看，performunitofwork 处理了如下的工作：\n\n 1. 调用 beginwork，将 fiber 更新（或者创建）为 reactelement 并返回下一个任务（child 或者是 null）。\n 2. 将 memoizedprops 更新为 pendingprops，便于下一次 beginwork 使用。\n 3. 如果 beginwork 之后没有任务了，则调用 completeunitofwork 做一些首位工作。\n 4. 清空 reactcurrentowner 标记。\n\n\n# beginwork\n\nbeginwork 函数比较复杂，他的大致思路如下：\n\nfunction () {\n  // update 阶段\n  if(isupdate) {\n    // pending fiber 优先级小于渲染的优先级\n    if(updateexpirationtime < renderexpirationtime) {\n      // 不需要执行任务，根据 pending fiber 的类型将 fiber 入 context stack;\n      switch (workinprogress.tag) {\n        case sometype: \n          pushcontext(workinprogress);\n          // 一些其他的处理;\n          return null || child || child.sibling 等;\n      }\n    }\n  }\n\n  // 根据 pending fiber 的类型，创建或者更新，返回 reactelement\n  switch (workinprogress.tag) {\n    case sometype: \n      return mountorupdatecomponent();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n下面我们展开来看：\n\nfunction beginwork(\n  current: fiber | null,\n  workinprogress: fiber,\n  renderexpirationtime: expirationtime,\n): fiber | null {\n  // 获取 pending fiber 的过期时间\n  const updateexpirationtime = workinprogress.expirationtime;\n\n  // current 区分首次渲染，current !== null 表示 update 阶段\n  // 如果是 update 阶段可以复用 current，因此可以更新并提前返回，否则 mount 阶段就需要 mountxxxcomponent\n  if (current !== null) {\n    const oldprops = current.memoizedprops;\n    const newprops = workinprogress.pendingprops;\n    // 判断 newfiber 和 oldfiber 中 props 是否变化\n    if (\n      oldprops !== newprops ||\n      haslegacycontextchanged()\n    ) {\n      // if props or context changed, mark the fiber as having performed work.\n      // this may be unset if the props are determined to be equal later (memo).\n      didreceiveupdate = true;\n    } else if (updateexpirationtime < renderexpirationtime) {\n      // pending fiber 的优先级小于 render 优先级，不需要执行任务\n      didreceiveupdate = false;\n      // this fiber does not have any pending work. bailout without entering\n      // the begin phase. there's still some bookkeeping we that needs to be done\n      // in this optimized path, mostly pushing stuff onto the stack.\n      // 根据 pending fiber 的类型推入 context stack\n      switch (workinprogress.tag) {\n        case hostroot:\n          pushhostrootcontext(workinprogress);\n          resethydrationstate();\n          break;\n        case hostcomponent:\n          pushhostcontext(workinprogress);\n          if (\n            workinprogress.mode & concurrentmode &&\n            renderexpirationtime !== never &&\n            shoulddeprioritizesubtree(workinprogress.type, newprops)\n          ) {\n            if (enableschedulertracing) {\n              markspawnedwork(never);\n            }\n            // schedule this fiber to re-render at offscreen priority. then bailout.\n            workinprogress.expirationtime = workinprogress.childexpirationtime = never;\n            return null;\n          }\n          break;\n        case classcomponent: {\n          const component = workinprogress.type;\n          if (islegacycontextprovider(component)) {\n            pushlegacycontextprovider(workinprogress);\n          }\n          break;\n        }\n        case hostportal:\n          pushhostcontainer(\n            workinprogress,\n            workinprogress.statenode.containerinfo,\n          );\n          break;\n        case contextprovider: {\n          const newvalue = workinprogress.memoizedprops.value;\n          pushprovider(workinprogress, newvalue);\n          break;\n        }\n        case profiler:\n          if (enableprofilertimer) {\n            workinprogress.effecttag |= update;\n          }\n          break;\n        case suspensecomponent: {\n          const state: suspensestate | null = workinprogress.memoizedstate;\n          if (state !== null) {\n            if (enablesuspenseserverrenderer) {\n              if (state.dehydrated !== null) {\n                pushsuspensecontext(\n                  workinprogress,\n                  setdefaultshallowsuspensecontext(suspensestackcursor.current),\n                );\n                // we know that this component will suspend again because if it has\n                // been unsuspended it has committed as a resolved suspense component.\n                // if it needs to be retried, it should have work scheduled on it.\n                workinprogress.effecttag |= didcapture;\n                break;\n              }\n            }\n\n            // if this boundary is currently timed out, we need to decide\n            // whether to retry the primary children, or to skip over it and\n            // go straight to the fallback. check the priority of the primary\n            // child fragment.\n            const primarychildfragment: fiber = (workinprogress.child: any);\n            const primarychildexpirationtime =\n              primarychildfragment.childexpirationtime;\n            if (\n              primarychildexpirationtime !== nowork &&\n              primarychildexpirationtime >= renderexpirationtime\n            ) {\n              // the primary children have pending work. use the normal path\n              // to attempt to render the primary children again.\n              return updatesuspensecomponent(\n                current,\n                workinprogress,\n                renderexpirationtime,\n              );\n            } else {\n              pushsuspensecontext(\n                workinprogress,\n                setdefaultshallowsuspensecontext(suspensestackcursor.current),\n              );\n              // the primary children do not have pending work with sufficient\n              // priority. bailout.\n              const child = bailoutonalreadyfinishedwork(\n                current,\n                workinprogress,\n                renderexpirationtime,\n              );\n              if (child !== null) {\n                // the fallback children have pending work. skip over the\n                // primary children and work on the fallback.\n                return child.sibling;\n              } else {\n                return null;\n              }\n            }\n          } else {\n            pushsuspensecontext(\n              workinprogress,\n              setdefaultshallowsuspensecontext(suspensestackcursor.current),\n            );\n          }\n          break;\n        }\n        case suspenselistcomponent: {\n          const didsuspendbefore =\n            (current.effecttag & didcapture) !== noeffect;\n\n          const haschildwork =\n            workinprogress.childexpirationtime >= renderexpirationtime;\n\n          if (didsuspendbefore) {\n            if (haschildwork) {\n              // if something was in fallback state last time, and we have all the\n              // same children then we're still in progressive loading state.\n              // something might get unblocked by state updates or retries in the\n              // tree which will affect the tail. so we need to use the normal\n              // path to compute the correct tail.\n              return updatesuspenselistcomponent(\n                current,\n                workinprogress,\n                renderexpirationtime,\n              );\n            }\n            // if none of the children had any work, that means that none of\n            // them got retried so they'll still be blocked in the same way\n            // as before. we can fast bail out.\n            workinprogress.effecttag |= didcapture;\n          }\n\n          // if nothing suspended before and we're rendering the same children,\n          // then the tail doesn't matter. anything new that suspends will work\n          // in the \"together\" mode, so we can continue from the state we had.\n          let renderstate = workinprogress.memoizedstate;\n          if (renderstate !== null) {\n            // reset to the \"together\" mode in case we've started a different\n            // update in the past but didn't complete it.\n            renderstate.rendering = null;\n            renderstate.tail = null;\n          }\n          pushsuspensecontext(workinprogress, suspensestackcursor.current);\n\n          if (haschildwork) {\n            break;\n          } else {\n            // if none of the children had any work, that means that none of\n            // them got retried so they'll still be blocked in the same way\n            // as before. we can fast bail out.\n            return null;\n          }\n        }\n      }\n      // 如果子树需要渲染，返回 child，否则返回 null。\n      return bailoutonalreadyfinishedwork(\n        current,\n        workinprogress,\n        renderexpirationtime,\n      );\n    } else {\n      // an update was scheduled on this fiber, but there are no new props\n      // nor legacy context. set this to false. if an update queue or context\n      // consumer produces a changed value, it will set this to true. otherwise,\n      // the component will assume the children have not changed and bail out.\n      // \n      didreceiveupdate = false;\n    }\n  } else {\n    didreceiveupdate = false;\n  }\n  // mount 阶段或者少数更新情况会执行下面的内容，进入 begin 的阶段\n  // before entering the begin phase, clear the expiration time.\n  workinprogress.expirationtime = nowork;\n\n  // 根据 pending fiber 的类型，返回不同的 reactelement\n  switch (workinprogress.tag) {\n    case indeterminatecomponent: {\n      return mountindeterminatecomponent(\n        current,\n        workinprogress,\n        workinprogress.type,\n        renderexpirationtime,\n      );\n    }\n    case lazycomponent: {\n      const elementtype = workinprogress.elementtype;\n      return mountlazycomponent(\n        current,\n        workinprogress,\n        elementtype,\n        updateexpirationtime,\n        renderexpirationtime,\n      );\n    }\n    case functioncomponent: {\n      const component = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      const resolvedprops =\n        workinprogress.elementtype === component\n          ? unresolvedprops\n          : resolvedefaultprops(component, unresolvedprops);\n      return updatefunctioncomponent(\n        current,\n        workinprogress,\n        component,\n        resolvedprops,\n        renderexpirationtime,\n      );\n    }\n    case classcomponent: {\n      const component = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      const resolvedprops =\n        workinprogress.elementtype === component\n          ? unresolvedprops\n          : resolvedefaultprops(component, unresolvedprops);\n      return updateclasscomponent(\n        current,\n        workinprogress,\n        component,\n        resolvedprops,\n        renderexpirationtime,\n      );\n    }\n    case hostroot:\n      return updatehostroot(current, workinprogress, renderexpirationtime);\n    case hostcomponent:\n      return updatehostcomponent(current, workinprogress, renderexpirationtime);\n    case hosttext:\n      return updatehosttext(current, workinprogress);\n    case suspensecomponent:\n      return updatesuspensecomponent(\n        current,\n        workinprogress,\n        renderexpirationtime,\n      );\n    case hostportal:\n      return updateportalcomponent(\n        current,\n        workinprogress,\n        renderexpirationtime,\n      );\n    case forwardref: {\n      const type = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      const resolvedprops =\n        workinprogress.elementtype === type\n          ? unresolvedprops\n          : resolvedefaultprops(type, unresolvedprops);\n      return updateforwardref(\n        current,\n        workinprogress,\n        type,\n        resolvedprops,\n        renderexpirationtime,\n      );\n    }\n    case fragment:\n      return updatefragment(current, workinprogress, renderexpirationtime);\n    case mode:\n      return updatemode(current, workinprogress, renderexpirationtime);\n    case profiler:\n      return updateprofiler(current, workinprogress, renderexpirationtime);\n    case contextprovider:\n      return updatecontextprovider(\n        current,\n        workinprogress,\n        renderexpirationtime,\n      );\n    case contextconsumer:\n      return updatecontextconsumer(\n        current,\n        workinprogress,\n        renderexpirationtime,\n      );\n    case memocomponent: {\n      const type = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      // resolve outer props first, then resolve inner props.\n      let resolvedprops = resolvedefaultprops(type, unresolvedprops);\n      if (__dev__) {\n        if (workinprogress.type !== workinprogress.elementtype) {\n          const outerproptypes = type.proptypes;\n          if (outerproptypes) {\n            checkproptypes(\n              outerproptypes,\n              resolvedprops, // resolved for outer only\n              'prop',\n              getcomponentname(type),\n              getcurrentfiberstackindev,\n            );\n          }\n        }\n      }\n      resolvedprops = resolvedefaultprops(type.type, resolvedprops);\n      return updatememocomponent(\n        current,\n        workinprogress,\n        type,\n        resolvedprops,\n        updateexpirationtime,\n        renderexpirationtime,\n      );\n    }\n    case simplememocomponent: {\n      return updatesimplememocomponent(\n        current,\n        workinprogress,\n        workinprogress.type,\n        workinprogress.pendingprops,\n        updateexpirationtime,\n        renderexpirationtime,\n      );\n    }\n    case incompleteclasscomponent: {\n      const component = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      const resolvedprops =\n        workinprogress.elementtype === component\n          ? unresolvedprops\n          : resolvedefaultprops(component, unresolvedprops);\n      return mountincompleteclasscomponent(\n        current,\n        workinprogress,\n        component,\n        resolvedprops,\n        renderexpirationtime,\n      );\n    }\n    case suspenselistcomponent: {\n      return updatesuspenselistcomponent(\n        current,\n        workinprogress,\n        renderexpirationtime,\n      );\n    }\n    case fundamentalcomponent: {\n      if (enablefundamentalapi) {\n        return updatefundamentalcomponent(\n          current,\n          workinprogress,\n          renderexpirationtime,\n        );\n      }\n      break;\n    }\n    case scopecomponent: {\n      if (enablescopeapi) {\n        return updatescopecomponent(\n          current,\n          workinprogress,\n          renderexpirationtime,\n        );\n      }\n      break;\n    }\n  }\n  invariant(\n    false,\n    'unknown unit of work tag (%s). this error is likely caused by a bug in ' +\n      'react. please file an issue.',\n    workinprogress.tag,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n\n\n简要分析下这段代码：\n\n 1. beginwork 内部是区分 mount 阶段和 update 阶段来处理的，在 update 阶段只有 workinprogress 的优先级小于 render 优先级即 renderexpirationtime 时才会提前退出，返回 null 或者 child 或者其他特殊情况。这也就是说 下面的一系列的 mountcomponent 或者 updatecomponent 其实是在 mount 阶段和 update 阶段都会执行的。\n 2. 两段 switch case 的代码比较复杂，之后单独分析。大致上第一段 switch case 代码段执行了一系列入栈操作在 completework 函数中执行了一些列的出栈操作。具体作用后面具体剖析。第二段 switch case 代码比较重要，下面来先分析分析。\n\n\n# mountindeterminatecomponent\n\n我们先来弄清楚 indeterminatecomponent 是什么？\n\n在 shared/reactworktags.js 文件中可以查到 indeterminatecomponent 的定义。从注释来看，indeterminatecomponent 应该是在未知是 fc (function component) 还是 cc (class function) 之前，为组件设定的临时类型。因此这种类型很有可能只在 mount 阶段出现，在 update 阶段会更新为 functioncomponent 或者 classcomponent。\n\n另外，从 mountlazycomponent 中调用 resolvelazycomponenttag 函数来看，如果 lazy component 不被识别为 classcomponent、functioncomponent、forwardref 或者 memocomponent，就会被认为是 indeterminatecomponent 类型。\n\nexport const indeterminatecomponent = 2; // before we know whether it is function or class\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-14T22:02:21.000Z",permalink:"/react/render/index/",categories:["react","render"],tags:[null]},regularPath:"/10.react/50.%E6%B8%B2%E6%9F%93%E5%99%A8%EF%BC%88Render%EF%BC%89/0.index.html",relativePath:"10.react/50.渲染器（Render）/0.index.md",key:"v-fcc2e96a",path:"/react/render/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"ReactDOM.render 方法",frontmatter:{title:"ReactDOM.render 方法",date:"2022-04-14T22:02:21.000Z",permalink:"/react/render/render/",categories:["react","render"],tags:[null]},regularPath:"/10.react/50.%E6%B8%B2%E6%9F%93%E5%99%A8%EF%BC%88Render%EF%BC%89/10.ReactDOM.html",relativePath:"10.react/50.渲染器（Render）/10.ReactDOM.md",key:"v-36e6278b",path:"/react/render/render/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"ReactDOM 是什么？",slug:"reactdom-是什么",normalizedTitle:"reactdom 是什么？",charIndex:17},{level:2,title:"render 方法",slug:"render-方法",normalizedTitle:"render 方法",charIndex:34},{level:3,title:"创建 ReactRoot",slug:"创建-reactroot",normalizedTitle:"创建 reactroot",charIndex:49},{level:3,title:"一些数据结构",slug:"一些数据结构",normalizedTitle:"一些数据结构",charIndex:67},{level:4,title:"FiberRoot",slug:"fiberroot",normalizedTitle:"fiberroot",charIndex:1695},{level:3,title:"updateContainer() 方法",slug:"updatecontainer-方法",normalizedTitle:"updatecontainer () 方法",charIndex:8771},{level:4,title:"createUpdate() 创建更新",slug:"createupdate-创建更新",normalizedTitle:"createupdate () 创建更新",charIndex:14084},{level:4,title:"enqueueUpdate() 更新入队",slug:"enqueueupdate-更新入队",normalizedTitle:"enqueueupdate () 更新入队",charIndex:15821}],readingTime:{text:"12 min read",minutes:11.985,time:719099.9999999999,words:2397},headersStr:"目录 ReactDOM 是什么？ render 方法 创建 ReactRoot 一些数据结构 FiberRoot updateContainer() 方法 createUpdate() 创建更新 enqueueUpdate() 更新入队",content:"# 目录\n\n\n\n * 目录\n * ReactDOM 是什么？\n * render 方法\n   * 创建 ReactRoot\n   * 一些数据结构\n   * updateContainer() 方法\n\n\n\n\n# ReactDOM 是什么？\n\n在 react-dom 包中 ReactDOM.js 里定义了 ReactDOM。大致如下：\n\nconst ReactDOM: Object = {\n\tcreatePortal, // 创建 portal\n\tfindDOMNode, // 获取 DOM\n\thydrate,\n\trender,\n\tunstable_renderSubtreeIntoContainer,\n\tunmountComponentAtNode,\n\tunstable_batchedUpdates,\n\tunstable_interactiveUpdates,\n\tunstable_discreteUpdates,\n\tunstable_flushDiscreteUpdates,\n\tflushSync,\n\tunstable_createRoot,\n\tunstable_createSyncRoot,\n\tunstable_flushControlled,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# render 方法\n\nrender 方法：\n\nrender(\n    element: React$Element < any >, // render 的元素\n    container: DOMContainer, // render 的容器\n    callback: ?Function, // callback\n) {\n    return legacyRenderSubtreeIntoContainer(\n        null,\n        element,\n        container,\n        false,\n        callback,\n    );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在 root 刚刚被创建时， parentComponent 一般都为 null； 内部调用 legacyRenderSubtreeIntoContainer 方法，代码如下：\n\nfunction legacyRenderSubtreeIntoContainer(\n    parentComponent: ? React$Component < any, any > ,\n    children : ReactNodeList, // 待渲染的元素\n    container: DOMContainer, // 渲染的目标容器\n    forceHydrate: boolean,\n    callback: ? Function,\n) {\n    let root: _ReactSyncRoot = (container._reactRootContainer: any);\n    let fiberRoot;\n    if (!root) {\n        // Initial mount\n        // 获取到 ReactSyncRoot 实例\n        root = container._reactRootContainer = legacyCreateRootFromDOMContainer(\n            container,\n            forceHydrate,\n        );\n        console.log('==>legacyRenderSubtreeIntoContainer_获取到 ReactSyncRoot 实例', {\n            root\n        });\n        // {\n        //   _internalRoot: FiberRootNode // 内部的 fiber 节点\n        //   callbackExpirationTime: 0\n        //   callbackNode: null\n        //   callbackPriority: 90\n        //   containerInfo: div#root // ROOT 的 DOM 节点\n        //   context: {}\n        //   current: FiberNode {tag: 3, key: null, elementType: null, type: null, stateNode: FiberRootNode, …}\n        //   finishedExpirationTime: 0\n        //   finishedWork: null\n        //   firstBatch: null\n        //   firstPendingTime: 0\n        //   firstSuspendedTime: 0\n        //   hydrate: false\n        //   interactionThreadID: 1\n        //   lastExpiredTime: 0\n        //   lastPingedTime: 0\n        //   lastSuspendedTime: 0\n        //   memoizedInteractions: Set(0) {}\n        //   nextKnownPendingLevel: 0\n        //   pendingChildren: null\n        //   pendingContext: null\n        //   pendingInteractionMap: Map(0) {}\n        //   pingCache: null\n        //   tag: 0\n        //   timeoutHandle: -1\n        // }\n        fiberRoot = root._internalRoot;\n        if (typeof callback === 'function') {\n            const originalCallback = callback;\n            callback = function () {\n                // 通过 public 的 root 实例去调用 callback\n                const instance = getPublicRootInstance(fiberRoot);\n                console.log('==>getPublicRootInstance_可被 callback 的 root 实例', {\n                    instance\n                });\n                // instance: null \n                originalCallback.call(instance);\n            };\n        }\n        // Initial mount should not be batched.\n        // render 为首次渲染，则不需要 batchedUpdates\n        unbatchedUpdates(() => {\n            // 响应更新\n            updateContainer(children, fiberRoot, parentComponent, callback);\n        });\n    } else {\n        // 如果 root 已经存在，则直接响应更新\n        fiberRoot = root._internalRoot;\n        if (typeof callback === 'function') {\n            const originalCallback = callback;\n            callback = function () {\n                const instance = getPublicRootInstance(fiberRoot);\n                originalCallback.call(instance);\n            };\n        }\n        // Update\n        updateContainer(children, fiberRoot, parentComponent, callback);\n    }\n    // 返回 public 的 root 实例\n    // render 函数是有返回值的，返回一个根节点的实例。\n    return getPublicRootInstance(fiberRoot);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n\n 1. 当 render () 被调用时， legacyRenderSubtreeIntoContainer 这个函数首先会去获取一个 _ReactSyncRoot 的实例，称之为 root，而真正需要更新使用的 fiberRoot = root._internalRoot 。\n 2. render () 函数中传入的 callback 函数会被包装， 通过 public 的 root 实例去调用 callback。\n 3. render 函数的更新是不需要 patch 的，因为它是根组件挂载时的首次更新，它会相应的调用 unbatchedUpdates() 来触发更新。\n 4. 无论是否需要 patch 的更新，都需要调用 updateContainer 进行更新操作。\n\n\n# 创建 ReactRoot\n\n root = container._reactRootContainer = legacyCreateRootFromDOMContainer(\n     container,\n     forceHydrate,\n );\n\n\n1\n2\n3\n4\n\n\n通过 legacyCreateRootFromDOMContainer 方法创建 ReactRoot ，ReatRoot 实际上是一个 ReactSyncRoot 的实例，这个实例被挂载到 container._reactRootContainer 上。\n\nlegacyCreateRootFromDOMContainer 方法如下：\n\nfunction legacyCreateRootFromDOMContainer(\n    container: DOMContainer,\n    forceHydrate: boolean,\n): _ReactSyncRoot {\n    // 是否应该 Hydrate\n    const shouldHydrate =\n        forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n    // First clear any existing content.\n    if (!shouldHydrate) {\n        let rootSibling;\n        // lastChild 属性返回被选节点的最后一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。\n\t\t// 循环删除尾结点，实际上是清空容器\n        while ((rootSibling = container.lastChild)) {\n            container.removeChild(rootSibling);\n        }\n    }\n\n    // Legacy roots are not batched.\n    return new ReactSyncRoot(\n        container,\n        LegacyRoot, // root 标记\n        shouldHydrate ?\n        {\n            hydrate: true,\n        } :\n        undefined,\n    );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n 1. 为什么要清空容器？在将根组件渲染到 root 容器之前，应该保证容器为空。\n 2. 什么是 hydrate？\n 3. LegacyRoot 是一个常量，代表的是传统的同步的渲染方式。\n\n\n# 一些数据结构\n\n# FiberRoot\n\nfiberRoot 的类型为 FiberRoot。fiberRoot 用于 react 的 updateContainer () 调用。\n\n在 react-reconciler/ReactFiberRoot.js 中定义如下：\n\nexport type FiberRoot = {\n    ...BaseFiberRootProperties,\n    ...ProfilingOnlyFiberRootProperties,\n    ...SuspenseCallbackOnlyFiberRootProperties,\n};\n\n\n1\n2\n3\n4\n5\n\n\n重点来看 BaseFiberRootProperties 的类型：\n\ntype BaseFiberRootProperties = {\n    |\n    // The type of root (legacy, batched, concurrent, etc.)\n    // tag 类型\n    // export type RootTag = 0 | 1 | 2;\n    // export const LegacyRoot = 0;\n    // export const BatchedRoot = 1;\n    // export const ConcurrentRoot = 2;\n    tag: RootTag,\n\n    // Any additional information from the host associated with this root.\n    // 容器信息\n    containerInfo: any,\n    // Used only by persistent updates.\n    pendingChildren: any,\n    // The currently active root fiber. This is the mutable root of the tree.\n    // 当前容器的 Fiber 对象\n    current: Fiber,\n\n    pingCache:\n        |\n        WeakMap < Thenable,\n    Set < ExpirationTime >>\n    |\n    Map < Thenable,\n    Set < ExpirationTime >>\n    |\n    null,\n\n    finishedExpirationTime: ExpirationTime,\n    // A finished work-in-progress HostRoot that's ready to be committed.\n    // 将被 commit 的 Fiber\n    finishedWork: Fiber | null,\n    // Timeout handle returned by setTimeout. Used to cancel a pending timeout, if\n    // it's superseded by a new one.\n    timeoutHandle: TimeoutHandle | NoTimeout,\n    // Top context object, used by renderSubtreeIntoContainer\n    context: Object | null,\n    pendingContext: Object | null,\n    // Determines if we should attempt to hydrate on the initial mount\n    // 是否需要在初次渲染时进行hydrate\n    +hydrate: boolean,\n    // List of top-level batches. This list indicates whether a commit should be\n    // deferred. Also contains completion callbacks.\n    // TODO: Lift this into the renderer\n    firstBatch: Batch | null,\n    // Node returned by Scheduler.scheduleCallback\n    callbackNode: * ,\n    // Expiration of the callback associated with this root\n    // callback 的超时时间\n    callbackExpirationTime: ExpirationTime,\n    // Priority of the callback associated with this root\n    callbackPriority: ReactPriorityLevel,\n    // The earliest pending expiration time that exists in the tree\n    firstPendingTime: ExpirationTime,\n    // The earliest suspended expiration time that exists in the tree\n    firstSuspendedTime: ExpirationTime,\n    // The latest suspended expiration time that exists in the tree\n    lastSuspendedTime: ExpirationTime,\n    // The next known expiration time after the suspended range\n    nextKnownPendingLevel: ExpirationTime,\n    // The latest time at which a suspended component pinged the root to\n    // render again\n    lastPingedTime: ExpirationTime,\n    lastExpiredTime: ExpirationTime,\n    |\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\nFiberRoot 数据结构归结如下：\n\n\n# updateContainer () 方法\n\n在 batchedUpdates() 和 unbatchedUpdates() 方法中会调用 updateContainer() 方法来更新视图。\n\nupdateContainer() 方法如下：\n\nfunction updateContainer(\n    element: ReactNodeList,\n    container: OpaqueRoot,\n    parentComponent: ? React$Component < any, any > ,\n    callback : ? Function,\n): ExpirationTime {\n    // 当前容器的 Fiber 对象\n    const current = container.current;\n    const currentTime = requestCurrentTime();\n    const suspenseConfig = requestCurrentSuspenseConfig();\n    const expirationTime = computeExpirationForFiber(\n        currentTime,\n        current,\n        suspenseConfig,\n    );\n    return updateContainerAtExpirationTime(\n        element,\n        container,\n        parentComponent,\n        expirationTime,\n        suspenseConfig,\n        callback,\n    );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n这个方法接受了 element、container、parentComponent 和 callback，返回一个 ExpirationTime 实例。它的只要作用是计算 expirationTime 和 suspenseConfig。\n\n * requestCurrentSuspenseConfig() 方法返回 ReactCurrentBatchConfig.suspense ，即是当前 batch 的配置信息。\n\n/**\n * Keeps track of the current batch's configuration such as how long an update\n * should suspend for if it needs to.\n */\n// 当前 batch 的配置\nconst ReactCurrentBatchConfig = {\n    suspense: (null: null | SuspenseConfig),\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * [[ExpirationTime,context 的计算方法]]\n\ncomputeExpirationForFiber(\n  currentTime: ExpirationTime,\n  fiber: Fiber,\n  suspenseConfig: null | SuspenseConfig,\n): ExpirationTime {\n  const mode = fiber.mode;\n  if ((mode & BatchedMode) === NoMode) {\n    console.log('==>', {mode, BatchedMode});\n    // {mode: 8, BatchedMode: 2}\n    // 8&2=0\n    return Sync; // 1073741823 MAX_SIGNED_31_BIT_INT\n  }\n\n  const priorityLevel = getCurrentPriorityLevel();\n  if ((mode & ConcurrentMode) === NoMode) {\n    console.log('==>', {mode, ConcurrentMode});\n    return priorityLevel === ImmediatePriority ? Sync : Batched;\n  }\n\n  if ((executionContext & RenderContext) !== NoContext) {\n    console.log('==>', {executionContext, RenderContext});\n    // Use whatever time we're already rendering\n    // TODO: Should there be a way to opt out, like with `runWithPriority`?\n    return renderExpirationTime; // NoWork 0\n  }\n\n  let expirationTime;\n  if (suspenseConfig !== null) {\n    // Compute an expiration time based on the Suspense timeout.\n    expirationTime = computeSuspenseExpiration(\n      currentTime,\n      suspenseConfig.timeoutMs | 0 || LOW_PRIORITY_EXPIRATION,\n    );\n  } else {\n    // Compute an expiration time based on the Scheduler priority.\n    switch (priorityLevel) {\n      case ImmediatePriority:\n        expirationTime = Sync;\n        break;\n      case UserBlockingPriority:\n        // TODO: Rename this to computeUserBlockingExpiration\n        expirationTime = computeInteractiveExpiration(currentTime);\n        break;\n      case NormalPriority:\n      case LowPriority: // TODO: Handle LowPriority\n        // TODO: Rename this to... something better.\n        expirationTime = computeAsyncExpiration(currentTime);\n        break;\n      case IdlePriority:\n        expirationTime = Idle;\n        break;\n      default:\n        invariant(false, 'Expected a valid priority level');\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n下面就是 updateContainerAtExpirationTime() 方法。这里的主要作用就是计算 context。\n\nfunction updateContainerAtExpirationTime(\n    element: ReactNodeList,\n    container: OpaqueRoot,\n    parentComponent: ? React$Component < any, any > ,\n    expirationTime : ExpirationTime,\n    suspenseConfig: null | SuspenseConfig,\n    callback: ? Function,\n) {\n    const current = container.current;\n  \t// 通过子树计算context，挂载到 container.context 或者 container.pendingContext\n    const context = getContextForSubtree(parentComponent);\n    if (container.context === null) {\n        container.context = context;\n    } else {\n        container.pendingContext = context;\n    }\n\n    return scheduleRootUpdate(\n        current,\n        element,\n        expirationTime,\n        suspenseConfig,\n        callback,\n    );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * [[ExpirationTime,context 的计算方法]]\n\n继续调用 scheduleRootUpdate() 方法。这里是 render 的核心方法之一，只要是起到调度根节点更新的作用。在此函数里将创建更新、更新入队、调度更新。\n\nfunction scheduleRootUpdate(\n    current: Fiber,\n    element: ReactNodeList,\n    expirationTime: ExpirationTime,\n    suspenseConfig: null | SuspenseConfig,\n    callback: ? Function,\n) {\n    // 根据当前render 的expirationTime和suspenseConfig 创建更新对象，称为一个 update。\n    const update = createUpdate(expirationTime, suspenseConfig);\n\n    callback = callback === undefined ? null : callback;\n    if (callback !== null) {\n        warningWithoutStack(\n            typeof callback === 'function',\n            'render(...): Expected the last optional `callback` argument to be a ' +\n            'function. Instead received: %s.',\n            callback,\n        );\n        // 将 callback 挂载到 update上\n        update.callback = callback;\n    }\n    // 更新入队列\n    enqueueUpdate(current, update);\n    // 在expirationTime时调度更新\n    scheduleWork(current, expirationTime);\n\n    return expirationTime;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n下面重点来追溯 createUpdate() 、 enqueueUpdate() 和 scheduleWork() 方法。\n\n# createUpdate () 创建更新\n\n创建一个 Update 对象。其中 tag 为 UpdateState 表示更新状态。\n\n// 函数createUpdate会创建一个update对象，用于存放更新的状态partialState、状态更新后的回调函数callback和渲染的过期时间expirationTime。\nfunction createUpdate(\n    expirationTime: ExpirationTime,\n    suspenseConfig: null | SuspenseConfig,\n): Update < * > {\n    let update: Update < * > = { // 初始化update对象的属性\n        expirationTime, // 过时时间\n        suspenseConfig, // 暂停配置\n\n        tag: UpdateState, // 常量标签，0，UpdateState表示这是一个更新状态的操作，值为0\n        payload: null, // 负载更新内容，比如`setState`接收的第一个参数\n        callback: null, // 回调函数\n\n        next: null, // 队列下一项更新的指针\n        nextEffect: null, // 指向下一项副作用更新的指针\n    };\n    if (__DEV__) {\n        update.priority = getCurrentPriorityLevel();\n    }\n    return update;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nUpdate 的类型如下：\n\ntype Update < State > = {\n    expirationTime: ExpirationTime,\n    suspenseConfig: null | SuspenseConfig,\n\n    tag: 0 | 1 | 2 | 3,\n    payload: any,\n    callback: (() => mixed) | null,\n\n    next: Update < State > | null,\n    nextEffect: Update < State > | null,\n\n    //DEV only\n    priority ? : ReactPriorityLevel,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * next 和 nextEffect 都是指向更新的指针。\n * Update 的 tag 类型如下：\n\nexport const UpdateState = 0;\nexport const ReplaceState = 1;\nexport const ForceUpdate = 2;\nexport const CaptureUpdate = 3;\n\n\n1\n2\n3\n4\n\n\nUpdate 的数据结构归结如下：\n\nKEY        TYPE              DESC\ntag        Number            当前有 0~3，分别是\n                             UpdateState、ReplaceState、ForceUpdate、CaptureUpdate\npayload    Function|Object   表示这个更新对应的数据内容\ncallback   Function          表示更新后的回调函数，如果这个回调有值，就会在 UpdateQueue 的副作用链表中挂载当前 Update 对象\nnext       Update            UpdateQueue 中的 Update 之间通过 next 来串联，表示下一个 Update 对象\n\n# enqueueUpdate () 更新入队\n\n创建 update 之后，需要将此 update 放入队列。 enqueueUpdate() 函数传入 fiber 和 update 两个参数。在看这里代码之前，先看看 fider 和 update 是什么样子的。\n\nfiber:\n\n{\n\tactualDuration: 0\n\tactualStartTime: -1\n\talternate: FiberNode { // alternate也是一个FiberNode\n\t\ttag: 3,\n\t\tkey: null,\n\t\telementType: null,\n\t\ttype: null,\n\t\tstateNode: FiberRootNode,\n\t\t…\n\t}\n\tchild: null\n\tchildExpirationTime: 0\n\tdependencies: null\n\teffectTag: 0\n\telementType: null\n\texpirationTime: 1073741823\n\tfirstEffect: null\n\tindex: 0\n\tkey: null\n\tlastEffect: null\n\tmemoizedProps: null\n\tmemoizedState: null\n\tmode: 8\n\tnextEffect: null\n\tpendingProps: null\n\tref: null\n\treturn :null\n\tselfBaseDuration: 0\n\tsibling: null\n\tstateNode: FiberRootNode {\n\t\ttag: 0,\n\t\tcurrent: FiberNode,\n\t\tcontainerInfo: div# root,\n\t\tpendingChildren: null,\n\t\tpingCache: null,\n\t\t…\n\t}\n\ttag: 3\n\ttreeBaseDuration: 0\n\ttype: null\n\tupdateQueue: {\n\t\tbaseState: null,\n\t\tfirstUpdate: {\n\t\t\t…},\n\t\tlastUpdate: {\n\t\t\t…},\n\t\tfirstCapturedUpdate: null,\n\t\tlastCapturedUpdate: null,\n\t\t…\n\t}\n\t_debugHookTypes: null\n\t_debugID: 1\n\t_debugIsCurrentlyTiming: false\n\t_debugNeedsRemount: false\n\t_debugOwner: null\n\t_debugSource: null\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\nupdate:\n\n{\n    callback: null\n    expirationTime: 1073741823\n    next: null\n    nextEffect: null\n    payload: {\n        element: {$$typeof: Symbol(react.element), key: null, ref: null, props: {…}, type: ƒ, …}\n    }\n    priority: 97\n    suspenseConfig: null\n    tag: 0\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n下面再来看看 enqueueUpdate() 方法：\n\n/**\n * @desc enqueueUpdate将update对象加入到队列，创建队列或者将更新加入队列尾部\n * @param 接受Fiber和update对象，Fiber本意为纤维\n * @returns\n */\nfunction enqueueUpdate < State > (fiber: Fiber, update: Update < State > ) {\n    // Update queues are created lazily.\n    const alternate = fiber.alternate; // workInProgress fiber\n\t// 两个队列分别为 current fiber 和 workInProgress fiber 的队列。\n    let queue1;\n    let queue2;\n    if (alternate === null) { // 首次渲染\n        // There's only one fiber.\n        queue1 = fiber.updateQueue;\n        queue2 = null;\n        if (queue1 === null) { // 当前没有队列\n\t\t\t// 创建更新队列， fiber.memoizedState是baseState\n            queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState); \n        }\n    } else {\n        // There are two owners.alternate不为null，workInProgress fiber 存在\n        queue1 = fiber.updateQueue;\n        queue2 = alternate.updateQueue;\n        if (queue1 === null) {\n            if (queue2 === null) {\n                // Neither fiber has an update queue. Create new ones.\n                queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n                queue2 = alternate.updateQueue = createUpdateQueue(\n                    alternate.memoizedState,\n                );\n            } else {\n                // Only one fiber has an update queue. Clone to create a new one.\n                queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);\n            }\n        } else {\n            if (queue2 === null) {\n                // Only one fiber has an update queue. Clone to create a new one.\n                queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);\n            } else {\n                // Both owners have an update queue.\n            }\n        }\n    }\n    if (queue2 === null || queue1 === queue2) { // 只有一个队列，将更新加入到队列\n        // There's only a single queue.\n        appendUpdateToQueue(queue1, update);\n    } else {\n        // There are two queues. We need to append the update to both queues,\n        // while accounting for the persistent structure of the list — we don't\n        // want the same update to be added multiple times.\n        if (queue1.lastUpdate === null || queue2.lastUpdate === null) { // 将更新加入到两个队列\n            // One of the queues is not empty. We must add the update to both queues.\n            appendUpdateToQueue(queue1, update);\n            appendUpdateToQueue(queue2, update);\n        } else {\n            // Both queues are non-empty. The last update is the same in both lists,\n            // because of structural sharing. So, only append to one of the lists.\n            appendUpdateToQueue(queue1, update);\n            // But we still need to update the `lastUpdate` pointer of queue2.\n            queue2.lastUpdate = update;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n * fiber.aternate 是什么？ 在任何时候，一个组件实例最多有两个与之对应的 Fiber 对象：当前即将渲染的（current fiber）和 workInProgress fiber，diff 产生出的变化会标记在 workInProgress fiber 上。current fiber 的 alternate 是 workInProgress fiber，workInProgress fiber 的 alternate 是 current fiber。workInProgress 构造完毕，得到了新的 fiber，然后把 current 指针指向 workInProgress，丢掉旧的 fiber。Fiber 的 alternate 是一个叫 cloneFiber 的函数惰性的创建的，与总是创建一个新对象不同，cloneFiber 将尝试重用 Fiber 的 alternate（如果存在的话），以实现最小化内存分配。\n\n参看：fiber.alternate\n\n下面的就是几个队列的操作，在此之前先来看看队列是什么样子的。\n\n{\n    queue1: {\n        baseState: null\n        firstCapturedEffect: null\n        firstCapturedUpdate: null\n        firstEffect: null\n        firstUpdate: {\n            expirationTime: 1073741823,\n            suspenseConfig: null,\n            tag: 0,\n            payload: {\n                …},\n            callback: null,\n            …\n        }\n        lastCapturedEffect: null\n        lastCapturedUpdate: null\n        lastEffect: null\n        lastUpdate: {\n            expirationTime: 1073741823,\n            suspenseConfig: null,\n            tag: 0,\n            payload: {\n                …},\n            callback: null,\n            …\n        }\n        __proto__: Object\n    },\n    queue2: null\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n * createUpdateQueue (fiber.memoizedState) 创建更新队列\n\nfiber.memoizedState 在创建更新队列时会作为 baseState 传入。baseState 表示更新前的基础状态。初次渲染时 memoizedState 一般为 null。\n\n/**\n * @desc 创建空的UpdateQueue对象\n * @param baseState: State\n * @returns UpdateQueue<State>\n */\nfunction createUpdateQueue < State > (baseState: State): UpdateQueue < State > {\n    const queue: UpdateQueue < State > = {\n        baseState,\n        firstUpdate: null, // 初次更新\n        lastUpdate: null, // 上次更新\n        firstCapturedUpdate: null, // 初次捕获更新\n        lastCapturedUpdate: null, // 最新捕获更新\n        firstEffect: null,\n        lastEffect: null,\n        firstCapturedEffect: null,\n        lastCapturedEffect: null,\n    };\n    return queue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nUpdateQueue 的结构总结如下： 在 FiberNode 节点中表示当前节点更新、更新的副作用（主要是 Callback）的集合，下面的结构省略了 CapturedUpdate 部分。\n\nKEY           TYPE     DESC\nbaseState     Object   表示更新前的基础状态\nfirstUpdate   Update   第一个 Update 对象引用，总体是一条单链表\nlastUpdate    Update   最后一个 Update 对象引用\nfirstEffect   Update   第一个包含副作用（Callback）的 Update 对象的引用\nlastEffect    Update   最后一个包含副作用（Callback）的 Update 对象的引用\n\n * cloneUpdateQueue (queue) 复制队列\n\ncloneUpdateQueue22 只会复制目标队列的 baseState、firstUpdate 和 lastUpdate 属性。\n\nfunction cloneUpdateQueue < State > (\n    currentQueue: UpdateQueue < State > ,\n): UpdateQueue < State > {\n    const queue: UpdateQueue < State > = {\n        baseState: currentQueue.baseState,\n        firstUpdate: currentQueue.firstUpdate,\n        lastUpdate: currentQueue.lastUpdate,\n\n        // TODO: With resuming, if we bail out and resuse the child tree, we should\n        // keep these effects.\n        firstCapturedUpdate: null,\n        lastCapturedUpdate: null,\n\n        firstEffect: null,\n        lastEffect: null,\n\n        firstCapturedEffect: null,\n        lastCapturedEffect: null,\n    };\n    return queue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * appendUpdateToQueue (queue, update) 添加更新到队列\n\nappendUpdateToQueue () 中 firstUpdate 的更新会先执行，lastUpdate 会指向下一个更新，如果尾指针 lastUpdate 为 null，就需要把头指针和尾指针都指向 update，否则就把尾指针和尾指针的 next 指向 update。\n\n/**\n * @description 将更新加入到队列（尾部）\n * @param {*} queue 队列\n * @param {*} update 更新\n */\nfunction appendUpdateToQueue < State > (\n    queue: UpdateQueue < State > ,\n    update: Update < State > ,\n) {\n    // Append the update to the end of the list.\n    if (queue.lastUpdate === null) {\n        // Queue is empty // 空队列\n        queue.firstUpdate = queue.lastUpdate = update; // 头指针和尾指针都指向了update\n    } else {\n        queue.lastUpdate.next = update; // 将update挂载到尾指针的 next\n        queue.lastUpdate = update; // 将尾指针移动到 update\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n 1. queue 是怎么使用的？\n\nqueue1 被挂载在 fiber.updateQueue 上，queue2 被挂载在 fiber.alternate.updateQueue 上。updateQueue 是在 fiber 系统的基础上进行管理的。\n\nqueue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\nqueue2 = alternate.updateQueue = createUpdateQueue(\n    alternate.memoizedState,\n);\n\n\n1\n2\n3\n4\n",normalizedContent:"# 目录\n\n\n\n * 目录\n * reactdom 是什么？\n * render 方法\n   * 创建 reactroot\n   * 一些数据结构\n   * updatecontainer() 方法\n\n\n\n\n# reactdom 是什么？\n\n在 react-dom 包中 reactdom.js 里定义了 reactdom。大致如下：\n\nconst reactdom: object = {\n\tcreateportal, // 创建 portal\n\tfinddomnode, // 获取 dom\n\thydrate,\n\trender,\n\tunstable_rendersubtreeintocontainer,\n\tunmountcomponentatnode,\n\tunstable_batchedupdates,\n\tunstable_interactiveupdates,\n\tunstable_discreteupdates,\n\tunstable_flushdiscreteupdates,\n\tflushsync,\n\tunstable_createroot,\n\tunstable_createsyncroot,\n\tunstable_flushcontrolled,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# render 方法\n\nrender 方法：\n\nrender(\n    element: react$element < any >, // render 的元素\n    container: domcontainer, // render 的容器\n    callback: ?function, // callback\n) {\n    return legacyrendersubtreeintocontainer(\n        null,\n        element,\n        container,\n        false,\n        callback,\n    );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在 root 刚刚被创建时， parentcomponent 一般都为 null； 内部调用 legacyrendersubtreeintocontainer 方法，代码如下：\n\nfunction legacyrendersubtreeintocontainer(\n    parentcomponent: ? react$component < any, any > ,\n    children : reactnodelist, // 待渲染的元素\n    container: domcontainer, // 渲染的目标容器\n    forcehydrate: boolean,\n    callback: ? function,\n) {\n    let root: _reactsyncroot = (container._reactrootcontainer: any);\n    let fiberroot;\n    if (!root) {\n        // initial mount\n        // 获取到 reactsyncroot 实例\n        root = container._reactrootcontainer = legacycreaterootfromdomcontainer(\n            container,\n            forcehydrate,\n        );\n        console.log('==>legacyrendersubtreeintocontainer_获取到 reactsyncroot 实例', {\n            root\n        });\n        // {\n        //   _internalroot: fiberrootnode // 内部的 fiber 节点\n        //   callbackexpirationtime: 0\n        //   callbacknode: null\n        //   callbackpriority: 90\n        //   containerinfo: div#root // root 的 dom 节点\n        //   context: {}\n        //   current: fibernode {tag: 3, key: null, elementtype: null, type: null, statenode: fiberrootnode, …}\n        //   finishedexpirationtime: 0\n        //   finishedwork: null\n        //   firstbatch: null\n        //   firstpendingtime: 0\n        //   firstsuspendedtime: 0\n        //   hydrate: false\n        //   interactionthreadid: 1\n        //   lastexpiredtime: 0\n        //   lastpingedtime: 0\n        //   lastsuspendedtime: 0\n        //   memoizedinteractions: set(0) {}\n        //   nextknownpendinglevel: 0\n        //   pendingchildren: null\n        //   pendingcontext: null\n        //   pendinginteractionmap: map(0) {}\n        //   pingcache: null\n        //   tag: 0\n        //   timeouthandle: -1\n        // }\n        fiberroot = root._internalroot;\n        if (typeof callback === 'function') {\n            const originalcallback = callback;\n            callback = function () {\n                // 通过 public 的 root 实例去调用 callback\n                const instance = getpublicrootinstance(fiberroot);\n                console.log('==>getpublicrootinstance_可被 callback 的 root 实例', {\n                    instance\n                });\n                // instance: null \n                originalcallback.call(instance);\n            };\n        }\n        // initial mount should not be batched.\n        // render 为首次渲染，则不需要 batchedupdates\n        unbatchedupdates(() => {\n            // 响应更新\n            updatecontainer(children, fiberroot, parentcomponent, callback);\n        });\n    } else {\n        // 如果 root 已经存在，则直接响应更新\n        fiberroot = root._internalroot;\n        if (typeof callback === 'function') {\n            const originalcallback = callback;\n            callback = function () {\n                const instance = getpublicrootinstance(fiberroot);\n                originalcallback.call(instance);\n            };\n        }\n        // update\n        updatecontainer(children, fiberroot, parentcomponent, callback);\n    }\n    // 返回 public 的 root 实例\n    // render 函数是有返回值的，返回一个根节点的实例。\n    return getpublicrootinstance(fiberroot);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n\n 1. 当 render () 被调用时， legacyrendersubtreeintocontainer 这个函数首先会去获取一个 _reactsyncroot 的实例，称之为 root，而真正需要更新使用的 fiberroot = root._internalroot 。\n 2. render () 函数中传入的 callback 函数会被包装， 通过 public 的 root 实例去调用 callback。\n 3. render 函数的更新是不需要 patch 的，因为它是根组件挂载时的首次更新，它会相应的调用 unbatchedupdates() 来触发更新。\n 4. 无论是否需要 patch 的更新，都需要调用 updatecontainer 进行更新操作。\n\n\n# 创建 reactroot\n\n root = container._reactrootcontainer = legacycreaterootfromdomcontainer(\n     container,\n     forcehydrate,\n );\n\n\n1\n2\n3\n4\n\n\n通过 legacycreaterootfromdomcontainer 方法创建 reactroot ，reatroot 实际上是一个 reactsyncroot 的实例，这个实例被挂载到 container._reactrootcontainer 上。\n\nlegacycreaterootfromdomcontainer 方法如下：\n\nfunction legacycreaterootfromdomcontainer(\n    container: domcontainer,\n    forcehydrate: boolean,\n): _reactsyncroot {\n    // 是否应该 hydrate\n    const shouldhydrate =\n        forcehydrate || shouldhydrateduetolegacyheuristic(container);\n    // first clear any existing content.\n    if (!shouldhydrate) {\n        let rootsibling;\n        // lastchild 属性返回被选节点的最后一个子节点。如果选定的节点没有子节点，则该属性返回 null。\n\t\t// 循环删除尾结点，实际上是清空容器\n        while ((rootsibling = container.lastchild)) {\n            container.removechild(rootsibling);\n        }\n    }\n\n    // legacy roots are not batched.\n    return new reactsyncroot(\n        container,\n        legacyroot, // root 标记\n        shouldhydrate ?\n        {\n            hydrate: true,\n        } :\n        undefined,\n    );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n 1. 为什么要清空容器？在将根组件渲染到 root 容器之前，应该保证容器为空。\n 2. 什么是 hydrate？\n 3. legacyroot 是一个常量，代表的是传统的同步的渲染方式。\n\n\n# 一些数据结构\n\n# fiberroot\n\nfiberroot 的类型为 fiberroot。fiberroot 用于 react 的 updatecontainer () 调用。\n\n在 react-reconciler/reactfiberroot.js 中定义如下：\n\nexport type fiberroot = {\n    ...basefiberrootproperties,\n    ...profilingonlyfiberrootproperties,\n    ...suspensecallbackonlyfiberrootproperties,\n};\n\n\n1\n2\n3\n4\n5\n\n\n重点来看 basefiberrootproperties 的类型：\n\ntype basefiberrootproperties = {\n    |\n    // the type of root (legacy, batched, concurrent, etc.)\n    // tag 类型\n    // export type roottag = 0 | 1 | 2;\n    // export const legacyroot = 0;\n    // export const batchedroot = 1;\n    // export const concurrentroot = 2;\n    tag: roottag,\n\n    // any additional information from the host associated with this root.\n    // 容器信息\n    containerinfo: any,\n    // used only by persistent updates.\n    pendingchildren: any,\n    // the currently active root fiber. this is the mutable root of the tree.\n    // 当前容器的 fiber 对象\n    current: fiber,\n\n    pingcache:\n        |\n        weakmap < thenable,\n    set < expirationtime >>\n    |\n    map < thenable,\n    set < expirationtime >>\n    |\n    null,\n\n    finishedexpirationtime: expirationtime,\n    // a finished work-in-progress hostroot that's ready to be committed.\n    // 将被 commit 的 fiber\n    finishedwork: fiber | null,\n    // timeout handle returned by settimeout. used to cancel a pending timeout, if\n    // it's superseded by a new one.\n    timeouthandle: timeouthandle | notimeout,\n    // top context object, used by rendersubtreeintocontainer\n    context: object | null,\n    pendingcontext: object | null,\n    // determines if we should attempt to hydrate on the initial mount\n    // 是否需要在初次渲染时进行hydrate\n    +hydrate: boolean,\n    // list of top-level batches. this list indicates whether a commit should be\n    // deferred. also contains completion callbacks.\n    // todo: lift this into the renderer\n    firstbatch: batch | null,\n    // node returned by scheduler.schedulecallback\n    callbacknode: * ,\n    // expiration of the callback associated with this root\n    // callback 的超时时间\n    callbackexpirationtime: expirationtime,\n    // priority of the callback associated with this root\n    callbackpriority: reactprioritylevel,\n    // the earliest pending expiration time that exists in the tree\n    firstpendingtime: expirationtime,\n    // the earliest suspended expiration time that exists in the tree\n    firstsuspendedtime: expirationtime,\n    // the latest suspended expiration time that exists in the tree\n    lastsuspendedtime: expirationtime,\n    // the next known expiration time after the suspended range\n    nextknownpendinglevel: expirationtime,\n    // the latest time at which a suspended component pinged the root to\n    // render again\n    lastpingedtime: expirationtime,\n    lastexpiredtime: expirationtime,\n    |\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\nfiberroot 数据结构归结如下：\n\n\n# updatecontainer () 方法\n\n在 batchedupdates() 和 unbatchedupdates() 方法中会调用 updatecontainer() 方法来更新视图。\n\nupdatecontainer() 方法如下：\n\nfunction updatecontainer(\n    element: reactnodelist,\n    container: opaqueroot,\n    parentcomponent: ? react$component < any, any > ,\n    callback : ? function,\n): expirationtime {\n    // 当前容器的 fiber 对象\n    const current = container.current;\n    const currenttime = requestcurrenttime();\n    const suspenseconfig = requestcurrentsuspenseconfig();\n    const expirationtime = computeexpirationforfiber(\n        currenttime,\n        current,\n        suspenseconfig,\n    );\n    return updatecontaineratexpirationtime(\n        element,\n        container,\n        parentcomponent,\n        expirationtime,\n        suspenseconfig,\n        callback,\n    );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n这个方法接受了 element、container、parentcomponent 和 callback，返回一个 expirationtime 实例。它的只要作用是计算 expirationtime 和 suspenseconfig。\n\n * requestcurrentsuspenseconfig() 方法返回 reactcurrentbatchconfig.suspense ，即是当前 batch 的配置信息。\n\n/**\n * keeps track of the current batch's configuration such as how long an update\n * should suspend for if it needs to.\n */\n// 当前 batch 的配置\nconst reactcurrentbatchconfig = {\n    suspense: (null: null | suspenseconfig),\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * [[expirationtime,context 的计算方法]]\n\ncomputeexpirationforfiber(\n  currenttime: expirationtime,\n  fiber: fiber,\n  suspenseconfig: null | suspenseconfig,\n): expirationtime {\n  const mode = fiber.mode;\n  if ((mode & batchedmode) === nomode) {\n    console.log('==>', {mode, batchedmode});\n    // {mode: 8, batchedmode: 2}\n    // 8&2=0\n    return sync; // 1073741823 max_signed_31_bit_int\n  }\n\n  const prioritylevel = getcurrentprioritylevel();\n  if ((mode & concurrentmode) === nomode) {\n    console.log('==>', {mode, concurrentmode});\n    return prioritylevel === immediatepriority ? sync : batched;\n  }\n\n  if ((executioncontext & rendercontext) !== nocontext) {\n    console.log('==>', {executioncontext, rendercontext});\n    // use whatever time we're already rendering\n    // todo: should there be a way to opt out, like with `runwithpriority`?\n    return renderexpirationtime; // nowork 0\n  }\n\n  let expirationtime;\n  if (suspenseconfig !== null) {\n    // compute an expiration time based on the suspense timeout.\n    expirationtime = computesuspenseexpiration(\n      currenttime,\n      suspenseconfig.timeoutms | 0 || low_priority_expiration,\n    );\n  } else {\n    // compute an expiration time based on the scheduler priority.\n    switch (prioritylevel) {\n      case immediatepriority:\n        expirationtime = sync;\n        break;\n      case userblockingpriority:\n        // todo: rename this to computeuserblockingexpiration\n        expirationtime = computeinteractiveexpiration(currenttime);\n        break;\n      case normalpriority:\n      case lowpriority: // todo: handle lowpriority\n        // todo: rename this to... something better.\n        expirationtime = computeasyncexpiration(currenttime);\n        break;\n      case idlepriority:\n        expirationtime = idle;\n        break;\n      default:\n        invariant(false, 'expected a valid priority level');\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n下面就是 updatecontaineratexpirationtime() 方法。这里的主要作用就是计算 context。\n\nfunction updatecontaineratexpirationtime(\n    element: reactnodelist,\n    container: opaqueroot,\n    parentcomponent: ? react$component < any, any > ,\n    expirationtime : expirationtime,\n    suspenseconfig: null | suspenseconfig,\n    callback: ? function,\n) {\n    const current = container.current;\n  \t// 通过子树计算context，挂载到 container.context 或者 container.pendingcontext\n    const context = getcontextforsubtree(parentcomponent);\n    if (container.context === null) {\n        container.context = context;\n    } else {\n        container.pendingcontext = context;\n    }\n\n    return schedulerootupdate(\n        current,\n        element,\n        expirationtime,\n        suspenseconfig,\n        callback,\n    );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * [[expirationtime,context 的计算方法]]\n\n继续调用 schedulerootupdate() 方法。这里是 render 的核心方法之一，只要是起到调度根节点更新的作用。在此函数里将创建更新、更新入队、调度更新。\n\nfunction schedulerootupdate(\n    current: fiber,\n    element: reactnodelist,\n    expirationtime: expirationtime,\n    suspenseconfig: null | suspenseconfig,\n    callback: ? function,\n) {\n    // 根据当前render 的expirationtime和suspenseconfig 创建更新对象，称为一个 update。\n    const update = createupdate(expirationtime, suspenseconfig);\n\n    callback = callback === undefined ? null : callback;\n    if (callback !== null) {\n        warningwithoutstack(\n            typeof callback === 'function',\n            'render(...): expected the last optional `callback` argument to be a ' +\n            'function. instead received: %s.',\n            callback,\n        );\n        // 将 callback 挂载到 update上\n        update.callback = callback;\n    }\n    // 更新入队列\n    enqueueupdate(current, update);\n    // 在expirationtime时调度更新\n    schedulework(current, expirationtime);\n\n    return expirationtime;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n下面重点来追溯 createupdate() 、 enqueueupdate() 和 schedulework() 方法。\n\n# createupdate () 创建更新\n\n创建一个 update 对象。其中 tag 为 updatestate 表示更新状态。\n\n// 函数createupdate会创建一个update对象，用于存放更新的状态partialstate、状态更新后的回调函数callback和渲染的过期时间expirationtime。\nfunction createupdate(\n    expirationtime: expirationtime,\n    suspenseconfig: null | suspenseconfig,\n): update < * > {\n    let update: update < * > = { // 初始化update对象的属性\n        expirationtime, // 过时时间\n        suspenseconfig, // 暂停配置\n\n        tag: updatestate, // 常量标签，0，updatestate表示这是一个更新状态的操作，值为0\n        payload: null, // 负载更新内容，比如`setstate`接收的第一个参数\n        callback: null, // 回调函数\n\n        next: null, // 队列下一项更新的指针\n        nexteffect: null, // 指向下一项副作用更新的指针\n    };\n    if (__dev__) {\n        update.priority = getcurrentprioritylevel();\n    }\n    return update;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nupdate 的类型如下：\n\ntype update < state > = {\n    expirationtime: expirationtime,\n    suspenseconfig: null | suspenseconfig,\n\n    tag: 0 | 1 | 2 | 3,\n    payload: any,\n    callback: (() => mixed) | null,\n\n    next: update < state > | null,\n    nexteffect: update < state > | null,\n\n    //dev only\n    priority ? : reactprioritylevel,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * next 和 nexteffect 都是指向更新的指针。\n * update 的 tag 类型如下：\n\nexport const updatestate = 0;\nexport const replacestate = 1;\nexport const forceupdate = 2;\nexport const captureupdate = 3;\n\n\n1\n2\n3\n4\n\n\nupdate 的数据结构归结如下：\n\nkey        type              desc\ntag        number            当前有 0~3，分别是\n                             updatestate、replacestate、forceupdate、captureupdate\npayload    function|object   表示这个更新对应的数据内容\ncallback   function          表示更新后的回调函数，如果这个回调有值，就会在 updatequeue 的副作用链表中挂载当前 update 对象\nnext       update            updatequeue 中的 update 之间通过 next 来串联，表示下一个 update 对象\n\n# enqueueupdate () 更新入队\n\n创建 update 之后，需要将此 update 放入队列。 enqueueupdate() 函数传入 fiber 和 update 两个参数。在看这里代码之前，先看看 fider 和 update 是什么样子的。\n\nfiber:\n\n{\n\tactualduration: 0\n\tactualstarttime: -1\n\talternate: fibernode { // alternate也是一个fibernode\n\t\ttag: 3,\n\t\tkey: null,\n\t\telementtype: null,\n\t\ttype: null,\n\t\tstatenode: fiberrootnode,\n\t\t…\n\t}\n\tchild: null\n\tchildexpirationtime: 0\n\tdependencies: null\n\teffecttag: 0\n\telementtype: null\n\texpirationtime: 1073741823\n\tfirsteffect: null\n\tindex: 0\n\tkey: null\n\tlasteffect: null\n\tmemoizedprops: null\n\tmemoizedstate: null\n\tmode: 8\n\tnexteffect: null\n\tpendingprops: null\n\tref: null\n\treturn :null\n\tselfbaseduration: 0\n\tsibling: null\n\tstatenode: fiberrootnode {\n\t\ttag: 0,\n\t\tcurrent: fibernode,\n\t\tcontainerinfo: div# root,\n\t\tpendingchildren: null,\n\t\tpingcache: null,\n\t\t…\n\t}\n\ttag: 3\n\ttreebaseduration: 0\n\ttype: null\n\tupdatequeue: {\n\t\tbasestate: null,\n\t\tfirstupdate: {\n\t\t\t…},\n\t\tlastupdate: {\n\t\t\t…},\n\t\tfirstcapturedupdate: null,\n\t\tlastcapturedupdate: null,\n\t\t…\n\t}\n\t_debughooktypes: null\n\t_debugid: 1\n\t_debugiscurrentlytiming: false\n\t_debugneedsremount: false\n\t_debugowner: null\n\t_debugsource: null\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\nupdate:\n\n{\n    callback: null\n    expirationtime: 1073741823\n    next: null\n    nexteffect: null\n    payload: {\n        element: {$$typeof: symbol(react.element), key: null, ref: null, props: {…}, type: ƒ, …}\n    }\n    priority: 97\n    suspenseconfig: null\n    tag: 0\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n下面再来看看 enqueueupdate() 方法：\n\n/**\n * @desc enqueueupdate将update对象加入到队列，创建队列或者将更新加入队列尾部\n * @param 接受fiber和update对象，fiber本意为纤维\n * @returns\n */\nfunction enqueueupdate < state > (fiber: fiber, update: update < state > ) {\n    // update queues are created lazily.\n    const alternate = fiber.alternate; // workinprogress fiber\n\t// 两个队列分别为 current fiber 和 workinprogress fiber 的队列。\n    let queue1;\n    let queue2;\n    if (alternate === null) { // 首次渲染\n        // there's only one fiber.\n        queue1 = fiber.updatequeue;\n        queue2 = null;\n        if (queue1 === null) { // 当前没有队列\n\t\t\t// 创建更新队列， fiber.memoizedstate是basestate\n            queue1 = fiber.updatequeue = createupdatequeue(fiber.memoizedstate); \n        }\n    } else {\n        // there are two owners.alternate不为null，workinprogress fiber 存在\n        queue1 = fiber.updatequeue;\n        queue2 = alternate.updatequeue;\n        if (queue1 === null) {\n            if (queue2 === null) {\n                // neither fiber has an update queue. create new ones.\n                queue1 = fiber.updatequeue = createupdatequeue(fiber.memoizedstate);\n                queue2 = alternate.updatequeue = createupdatequeue(\n                    alternate.memoizedstate,\n                );\n            } else {\n                // only one fiber has an update queue. clone to create a new one.\n                queue1 = fiber.updatequeue = cloneupdatequeue(queue2);\n            }\n        } else {\n            if (queue2 === null) {\n                // only one fiber has an update queue. clone to create a new one.\n                queue2 = alternate.updatequeue = cloneupdatequeue(queue1);\n            } else {\n                // both owners have an update queue.\n            }\n        }\n    }\n    if (queue2 === null || queue1 === queue2) { // 只有一个队列，将更新加入到队列\n        // there's only a single queue.\n        appendupdatetoqueue(queue1, update);\n    } else {\n        // there are two queues. we need to append the update to both queues,\n        // while accounting for the persistent structure of the list — we don't\n        // want the same update to be added multiple times.\n        if (queue1.lastupdate === null || queue2.lastupdate === null) { // 将更新加入到两个队列\n            // one of the queues is not empty. we must add the update to both queues.\n            appendupdatetoqueue(queue1, update);\n            appendupdatetoqueue(queue2, update);\n        } else {\n            // both queues are non-empty. the last update is the same in both lists,\n            // because of structural sharing. so, only append to one of the lists.\n            appendupdatetoqueue(queue1, update);\n            // but we still need to update the `lastupdate` pointer of queue2.\n            queue2.lastupdate = update;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n * fiber.aternate 是什么？ 在任何时候，一个组件实例最多有两个与之对应的 fiber 对象：当前即将渲染的（current fiber）和 workinprogress fiber，diff 产生出的变化会标记在 workinprogress fiber 上。current fiber 的 alternate 是 workinprogress fiber，workinprogress fiber 的 alternate 是 current fiber。workinprogress 构造完毕，得到了新的 fiber，然后把 current 指针指向 workinprogress，丢掉旧的 fiber。fiber 的 alternate 是一个叫 clonefiber 的函数惰性的创建的，与总是创建一个新对象不同，clonefiber 将尝试重用 fiber 的 alternate（如果存在的话），以实现最小化内存分配。\n\n参看：fiber.alternate\n\n下面的就是几个队列的操作，在此之前先来看看队列是什么样子的。\n\n{\n    queue1: {\n        basestate: null\n        firstcapturedeffect: null\n        firstcapturedupdate: null\n        firsteffect: null\n        firstupdate: {\n            expirationtime: 1073741823,\n            suspenseconfig: null,\n            tag: 0,\n            payload: {\n                …},\n            callback: null,\n            …\n        }\n        lastcapturedeffect: null\n        lastcapturedupdate: null\n        lasteffect: null\n        lastupdate: {\n            expirationtime: 1073741823,\n            suspenseconfig: null,\n            tag: 0,\n            payload: {\n                …},\n            callback: null,\n            …\n        }\n        __proto__: object\n    },\n    queue2: null\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n * createupdatequeue (fiber.memoizedstate) 创建更新队列\n\nfiber.memoizedstate 在创建更新队列时会作为 basestate 传入。basestate 表示更新前的基础状态。初次渲染时 memoizedstate 一般为 null。\n\n/**\n * @desc 创建空的updatequeue对象\n * @param basestate: state\n * @returns updatequeue<state>\n */\nfunction createupdatequeue < state > (basestate: state): updatequeue < state > {\n    const queue: updatequeue < state > = {\n        basestate,\n        firstupdate: null, // 初次更新\n        lastupdate: null, // 上次更新\n        firstcapturedupdate: null, // 初次捕获更新\n        lastcapturedupdate: null, // 最新捕获更新\n        firsteffect: null,\n        lasteffect: null,\n        firstcapturedeffect: null,\n        lastcapturedeffect: null,\n    };\n    return queue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nupdatequeue 的结构总结如下： 在 fibernode 节点中表示当前节点更新、更新的副作用（主要是 callback）的集合，下面的结构省略了 capturedupdate 部分。\n\nkey           type     desc\nbasestate     object   表示更新前的基础状态\nfirstupdate   update   第一个 update 对象引用，总体是一条单链表\nlastupdate    update   最后一个 update 对象引用\nfirsteffect   update   第一个包含副作用（callback）的 update 对象的引用\nlasteffect    update   最后一个包含副作用（callback）的 update 对象的引用\n\n * cloneupdatequeue (queue) 复制队列\n\ncloneupdatequeue22 只会复制目标队列的 basestate、firstupdate 和 lastupdate 属性。\n\nfunction cloneupdatequeue < state > (\n    currentqueue: updatequeue < state > ,\n): updatequeue < state > {\n    const queue: updatequeue < state > = {\n        basestate: currentqueue.basestate,\n        firstupdate: currentqueue.firstupdate,\n        lastupdate: currentqueue.lastupdate,\n\n        // todo: with resuming, if we bail out and resuse the child tree, we should\n        // keep these effects.\n        firstcapturedupdate: null,\n        lastcapturedupdate: null,\n\n        firsteffect: null,\n        lasteffect: null,\n\n        firstcapturedeffect: null,\n        lastcapturedeffect: null,\n    };\n    return queue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * appendupdatetoqueue (queue, update) 添加更新到队列\n\nappendupdatetoqueue () 中 firstupdate 的更新会先执行，lastupdate 会指向下一个更新，如果尾指针 lastupdate 为 null，就需要把头指针和尾指针都指向 update，否则就把尾指针和尾指针的 next 指向 update。\n\n/**\n * @description 将更新加入到队列（尾部）\n * @param {*} queue 队列\n * @param {*} update 更新\n */\nfunction appendupdatetoqueue < state > (\n    queue: updatequeue < state > ,\n    update: update < state > ,\n) {\n    // append the update to the end of the list.\n    if (queue.lastupdate === null) {\n        // queue is empty // 空队列\n        queue.firstupdate = queue.lastupdate = update; // 头指针和尾指针都指向了update\n    } else {\n        queue.lastupdate.next = update; // 将update挂载到尾指针的 next\n        queue.lastupdate = update; // 将尾指针移动到 update\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n 1. queue 是怎么使用的？\n\nqueue1 被挂载在 fiber.updatequeue 上，queue2 被挂载在 fiber.alternate.updatequeue 上。updatequeue 是在 fiber 系统的基础上进行管理的。\n\nqueue1 = fiber.updatequeue = createupdatequeue(fiber.memoizedstate);\nqueue2 = alternate.updatequeue = createupdatequeue(\n    alternate.memoizedstate,\n);\n\n\n1\n2\n3\n4\n",charsets:{cjk:!0},lastUpdated:"2022/04/18, 22:27:58",lastUpdatedTimestamp:1650292078e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-14T22:02:21.000Z",permalink:"/react/hooks/index/",categories:["react","hooks"],tags:[null]},regularPath:"/10.react/70.hooks%E5%8E%9F%E7%90%86/0.index.html",relativePath:"10.react/70.hooks原理/0.index.md",key:"v-0fd7e2db",path:"/react/hooks/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"useState 和 useReducer",frontmatter:{title:"useState 和 useReducer",date:"2022-04-14T22:02:21.000Z",permalink:"/react/hooks/useState/",categories:["react","hooks"],tags:[null]},regularPath:"/10.react/70.hooks%E5%8E%9F%E7%90%86/10.useState.html",relativePath:"10.react/70.hooks原理/10.useState.md",key:"v-fda4440a",path:"/react/hooks/useState/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"dispatcher 分发器",slug:"dispatcher-分发器",normalizedTitle:"dispatcher 分发器",charIndex:17},{level:3,title:"定义",slug:"定义",normalizedTitle:"定义",charIndex:37},{level:3,title:"dispatcher 是什么？如何生成的？",slug:"dispatcher-是什么-如何生成的",normalizedTitle:"dispatcher 是什么？如何生成的？",charIndex:45},{level:3,title:"dispatcher 是如何调度的？",slug:"dispatcher-是如何调度的",normalizedTitle:"dispatcher 是如何调度的？",charIndex:72},{level:2,title:"useState 的原理",slug:"usestate-的原理",normalizedTitle:"usestate 的原理",charIndex:94},{level:3,title:"mountState",slug:"mountstate",normalizedTitle:"mountstate",charIndex:112},{level:3,title:"dispatchAction",slug:"dispatchaction",normalizedTitle:"dispatchaction",charIndex:128},{level:3,title:"updateState",slug:"updatestate",normalizedTitle:"updatestate",charIndex:148},{level:4,title:"什么是 reducer 和 basicStateReducer？",slug:"什么是-reducer-和-basicstatereducer",normalizedTitle:"什么是 reducer 和 basicstatereducer？",charIndex:22853},{level:2,title:"updateReducer",slug:"updatereducer",normalizedTitle:"updatereducer",charIndex:163},{level:2,title:"一些问题",slug:"一些问题",normalizedTitle:"一些问题",charIndex:180},{level:3,title:"useState 是同步引起 UI 更新吗？",slug:"usestate-是同步引起-ui-更新吗",normalizedTitle:"usestate 是同步引起 ui 更新吗？",charIndex:190},{level:3,title:"renderPhaseUpdates 管理更新",slug:"renderphaseupdates-管理更新",normalizedTitle:"renderphaseupdates 管理更新",charIndex:218},{level:3,title:"为什么 setState 是状态的替换，而不是状态的补充？",slug:"为什么-setstate-是状态的替换-而不是状态的补充",normalizedTitle:"为什么 setstate 是状态的替换，而不是状态的补充？",charIndex:247},{level:3,title:"为什么 batch update 时，链表上会有多个 update?",slug:"为什么-batch-update-时-链表上会有多个-update",normalizedTitle:"为什么 batch update 时，链表上会有多个 update?",charIndex:282},{level:2,title:"本篇小结",slug:"本篇小结",normalizedTitle:"本篇小结",charIndex:320},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:328}],readingTime:{text:"20 min read",minutes:19.28,time:1156800.0000000002,words:3856},headersStr:"目录 dispatcher 分发器 定义 dispatcher 是什么？如何生成的？ dispatcher 是如何调度的？ useState 的原理 mountState dispatchAction updateState 什么是 reducer 和 basicStateReducer？ updateReducer 一些问题 useState 是同步引起 UI 更新吗？ renderPhaseUpdates 管理更新 为什么 setState 是状态的替换，而不是状态的补充？ 为什么 batch update 时，链表上会有多个 update? 本篇小结 参考资料",content:"# 目录\n\n\n\n * 目录\n * dispatcher 分发器\n   * 定义\n   * dispatcher 是什么？如何生成的？\n   * dispatcher 是如何调度的？\n * useState 的原理\n   * mountState\n   * dispatchAction\n   * updateState\n * updateReducer\n * 一些问题\n   * useState 是同步引起 UI 更新吗？\n   * renderPhaseUpdates 管理更新\n   * 为什么 setState 是状态的替换，而不是状态的补充？\n   * 为什么 batch update 时，链表上会有多个 update?\n * 本篇小结\n * 参考资料\n\n\n\n\n# dispatcher 分发器\n\n在 react 包中 react.js 文件导出了 hooks 相关的 API，包括：\n\nuseCallback, // 函数缓存\nuseContext, // 从 context 中获得 provider 传递的数据，经常和 createContext 和 context.Provider 一起使用。\nuseEffect, // 执行副作用，包括网络请求，数据交互，UI 更新等。\nuseImperativeHandle, // 将组件内部的变量或者方法暴露给外部，外部可使用 ref 进行调用。\nuseDebugValue, // debug 时的优化项\nuseLayoutEffect, // 在 DOM 更新之后浏览器执行绘制之前同步的执行副作用\nuseMemo, // 缓存变量\nuseReducer, // 用于状态管理（数据共享），可以调用 reducer，常与 useContext 一起使用\nuseRef, // 非响应式的数据暂存\nuseState, // 响应式的组件状态管理\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们先来看 useState 的原理。\n\n\n# 定义\n\n所有的 hooks 从 react 包中 ReactHooks.js 导出定义，useState 定义如下：\n\nfunction useState < S > (initialState: (() => S) | S) {\n    const dispatcher = resolveDispatcher();\n    return dispatcher.useState(initialState);\n}\n\n\n1\n2\n3\n4\n\n\n从这个定义里可以看出：\n\n 1. S 是 state 的泛型，useState 传入一个初始的状态 initialState ，初始状态可以直接传入，也可以函数式传入。当初始状态需要较多的计算量时，可以使用函数返回值的方式传入。\n 2. 所有的 hook 都需要经过 resolveDispatcher 返回的 dispatcher 来管理。\n\n\n# dispatcher 是什么？如何生成的？\n\n先来看 resolveDispatcher 这个函数，这个函数负责找到当前的分发器，ReactCurrentDispatcher 用来追踪当前的分发器：\n\nconst dispatcher = ReactCurrentDispatcher.current;\n\n\n1\n\n\n如果找不到分发器，就会报我们使用 hook 最常见的错误：\n\nInvalid hook call. Hooks can only be called inside of the body of a function component.\n\n\n1\n\n\nReactCurrentDispatcher 被放在了 ReactSharedInternals 中，从 react-reconciler 包中 ReactFiberHooks.js 中可以看到 Dispatcher 类型：\n\ntype Dispatcher = {\n    readContext < T > (\n        context: ReactContext < T > ,\n        observedBits: void | number | boolean,\n    ): T,\n    useState < S > (initialState: (() => S) | S): [S, Dispatch < BasicStateAction < S >> ],\n    useReducer < S,\n    I,\n    A > (\n        reducer: (S, A) => S,\n        initialArg: I,\n        init ? : (I) => S,\n    ): [S, Dispatch < A > ],\n    useContext < T > (\n        context: ReactContext < T > ,\n        observedBits: void | number | boolean,\n    ): T,\n    useRef < T > (initialValue: T): {\n        current: T\n    },\n    useEffect(\n        create: () => (() => void) | void,\n        deps: Array < mixed > | void | null,\n    ): void,\n    useLayoutEffect(\n        create: () => (() => void) | void,\n        deps: Array < mixed > | void | null,\n    ): void,\n    useCallback < T > (callback: T, deps: Array < mixed > | void | null): T,\n    useMemo < T > (nextCreate: () => T, deps: Array < mixed > | void | null): T,\n    useImperativeHandle < T > (\n        ref: {\n            current: T | null\n        } | ((inst: T | null) => mixed) | null | void,\n        create: () => T,\n        deps: Array < mixed > | void | null,\n    ): void,\n    useDebugValue < T > (value: T, formatterFn: ? (value: T) => mixed): void,\n    useResponder < E,\n    C > (\n        responder: ReactEventResponder < E, C > ,\n        props: Object,\n    ): ReactEventResponderListener < E,\n    C > ,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n可见所有的 hook 都是由 dispatcher 来调度执行的。那么 dispatcher 只有一种吗？dispatcher 不止以一种，包括 ContextOnlyDispatcher、HooksDispatcherOnMount、HooksDispatcherOnUpdate 三种，还有一些 dev 环境的 dispatcher。 可以把 dispatcher 看做是一个 hook 的分发器，在不同的渲染阶段由不同的分发器来进行调度。那么不同的分发器有什么区别呢？我们来看一下这三种分发器：\n\nexport const ContextOnlyDispatcher: Dispatcher = {\n    readContext,\n\n    useCallback: throwInvalidHookError,\n    useContext: throwInvalidHookError,\n    useEffect: throwInvalidHookError,\n    useImperativeHandle: throwInvalidHookError,\n    useLayoutEffect: throwInvalidHookError,\n    useMemo: throwInvalidHookError,\n    useReducer: throwInvalidHookError,\n    useRef: throwInvalidHookError,\n    useState: throwInvalidHookError,\n    useDebugValue: throwInvalidHookError,\n    useResponder: throwInvalidHookError,\n};\n\nconst HooksDispatcherOnMount: Dispatcher = {\n    readContext,\n\n    useCallback: mountCallback,\n    useContext: readContext,\n    useEffect: mountEffect,\n    useImperativeHandle: mountImperativeHandle,\n    useLayoutEffect: mountLayoutEffect,\n    useMemo: mountMemo,\n    useReducer: mountReducer,\n    useRef: mountRef,\n    useState: mountState,\n    useDebugValue: mountDebugValue,\n    useResponder: createResponderListener,\n};\n\nconst HooksDispatcherOnUpdate: Dispatcher = {\n    readContext,\n    useCallback: updateCallback,\n    useContext: readContext,\n    useEffect: updateEffect,\n    useImperativeHandle: updateImperativeHandle,\n    useLayoutEffect: updateLayoutEffect,\n    useMemo: updateMemo,\n    useReducer: updateReducer,\n    useRef: updateRef,\n    useState: updateState,\n    useDebugValue: updateDebugValue,\n    useResponder: createResponderListener,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n可见分发器的区别在于 hook 的实例是不同的，ContextOnlyDispatcher 中直接报 Invalid hook call 的错误， HooksDispatcherOnMount 中是 Mount 阶段的 hook，而HooksDispatcherOnUpdate 中是 update 阶段的 hook 。一个很明显的区别就是 HooksDispatcherOnMount 中的 hook 会做一些初始化、初始值的操作，而 HooksDispatcherOnUpdate 中的 hook 主要做一些更新的操作。\n\n\n# dispatcher 是如何调度的？\n\n上面已经说明了 dispatcher 是什么，现在探讨一下当前的 dispatcher 是怎么设置的。HooksDispatcherOnMount、HooksDispatcherOnUpdate 这两种 dispatcher，在 renderWithHooks 函数中设置。ContextOnlyDispatcher 还会在 resetHooks 函数中设置。\n\n这个函数将会在每次 hook 被调用时执行。\n\n先看一下 renderWithHooks 函数，去除 dev 代码：\n\nfunction renderWithHooks(\n    current: Fiber | null, // 已经被渲染的 fiber\n    workInProgress: Fiber, // 等待被渲染的 fiber\n    Component: any, // hook 所依赖的组件，由于 hook 只存在于函数式组件，这里就是 FC\n    props: any, // hook hook 所依赖的组件的属性\n    refOrContext: any,\n    nextRenderExpirationTime: ExpirationTime, // 下次渲染的到期时间\n): any {\n    renderExpirationTime = nextRenderExpirationTime;\n    // 这是当前正在渲染的 Fiber \n    currentlyRenderingFiber = workInProgress;\n    // 1. 更新 dispatcher\n    // 如果当前的 fiber 已经存在，说明是 update 阶段\n    nextCurrentHook = current !== null ? current.memoizedState : null;\n    \n    // current?.memoizedState 有值 ,则 dispatcher 为 HooksDispatcherOnUpdate，否则为 HooksDispatcherOnMount\n    ReactCurrentDispatcher.current =\n        nextCurrentHook === null ?\n        HooksDispatcherOnMount :\n        HooksDispatcherOnUpdate;\n    // 2. 执行 FC 获得节点\n    // 执行 Component() 函数即执行 FC，返回需要渲染的节点, 可见 FC 的参数为：props 和 refOrContext\n    let children = Component(props, refOrContext);\n\n\n    if (didScheduleRenderPhaseUpdate) {\n        do {\n            // 标志位置为了 false，则只会执行一次\n            didScheduleRenderPhaseUpdate = false;\n            // 记录渲染的次数，如果numberOfReRenders > RE_RENDER_LIMIT,就会报 Too many re-renders 的错误。防止进入渲染的死循环\n            numberOfReRenders += 1;\n            \n            // Start over from the beginning of the list\n            nextCurrentHook = current !== null ? current.memoizedState : null;\n            nextWorkInProgressHook = firstWorkInProgressHook;\n\n            currentHook = null;\n            workInProgressHook = null;\n            componentUpdateQueue = null;\n\n            // 这里是为了区分 dev 和 prd 环境中的 updateDispatcher\n            ReactCurrentDispatcher.current = __DEV__ ?\n                HooksDispatcherOnUpdateInDEV :\n                HooksDispatcherOnUpdate;\n            // re-render: 重新生成组件节点\n            children = Component(props, refOrContext);\n        } while (didScheduleRenderPhaseUpdate);\n\n        renderPhaseUpdates = null;\n        numberOfReRenders = 0;\n    }\n\n    // We can assume the previous dispatcher is always this one, since we set it\n    // at the beginning of the render phase and there's no re-entrancy.\n    // 渲染完毕后的 dispatcher 为 ContextOnlyDispatcher\n    // 只有在 renderWithHooks 内部，即是 hooks 在渲染时才会取 mountDispatcher 或者 updateDispatcher。\n    ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n    // 更新 renderedWork，renderedWork 记录上一次 hook 渲染的结果\n    const renderedWork: Fiber = (currentlyRenderingFiber: any);\n\n    renderedWork.memoizedState = firstWorkInProgressHook;\n    renderedWork.expirationTime = remainingExpirationTime;\n    renderedWork.updateQueue = (componentUpdateQueue: any);\n    renderedWork.effectTag |= sideEffectTag;\n\n    // This check uses currentHook so that it works the same in DEV and prod bundles.\n    // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n    const didRenderTooFewHooks =\n        currentHook !== null && currentHook.next !== null;\n\n    // 做清理工作，防止这些变量污染下次执行\n    renderExpirationTime = NoWork;\n    currentlyRenderingFiber = null;\n\n    currentHook = null;\n    nextCurrentHook = null;\n    firstWorkInProgressHook = null;\n    workInProgressHook = null;\n    nextWorkInProgressHook = null;\n\n    remainingExpirationTime = NoWork;\n    componentUpdateQueue = null;\n    sideEffectTag = 0;\n\n    invariant(\n        !didRenderTooFewHooks,\n        'Rendered fewer hooks than expected. This may be caused by an accidental ' +\n        'early return statement.',\n    );\n\n    // 返回更新后的组件\n    return children;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n\n核心理解\n\n * renderWithHooks 只会在 mount 阶段执行，每个 FC 组件会执行一次，类组件不执行。\n * renderWithHooks 生成的 children 是 ReactElement。\n\n由这个函数可以看出：\n\n 1. current 是当前已经渲染或的 Fiber，是现在的 Fiber， current.memoizedState 在类组件中保存的是上一次 Fiber 当前的状态，而在函数组件中无法通过 this 来引用 state，因此 current.memoizedState 中保存的是 hook。\n 2. 渲染 hook 时会根据 current.memoizedState 的值来判断是属于挂载阶段还是更新阶段，如果是挂载阶段，使用的 dispatcher 就是 HooksDispatcherOnMount ，如果是更新阶段，使用的 dispatcher 就是 HooksDispatcherOnUpdate 。\n 3. 在 dispatchAction 被调用时，才会更新状态重新渲染。\n 4. 渲染完毕后，dispatcher 就是 ContextOnlyDispatcher 。即 renderWithHooks 没有重新调用时，dispatcher 是不会生效的。\n 5. renderWithHooks 将执行函数式组件返回更新后的节点。\n 6. 有一段代码很奇怪：\n\nif (didScheduleRenderPhaseUpdate) {\n    do {\n        // 标志位置为了 false，则只会执行一次\n        didScheduleRenderPhaseUpdate = false;\n        // 记录渲染的次数，如果numberOfReRenders > RE_RENDER_LIMIT(25),就会报 Too many re-renders 的错误。防止进入渲染的死循环\n        numberOfReRenders += 1;\n\n        // 这里是为了区分 dev 和 prd 环境中的 updateDispatcher\n        ReactCurrentDispatcher.current = __DEV__ ?\n            HooksDispatcherOnUpdateInDEV :\n            HooksDispatcherOnUpdate;\n        // re-render: 重新生成组件节点\n        children = Component(props, refOrContext);\n    } while (didScheduleRenderPhaseUpdate);\n\n    renderPhaseUpdates = null;\n    numberOfReRenders = 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面不是讲了吗，renderWithHooks 只会在 mount 是调用啊，但是 didScheduleRenderPhaseUpdate 这个值是在 useReducer 中设置为 true 的啊，也就是说只有在 render 阶段才会进入这段代码，这不是矛盾吗？ 也许我们可以猜测，这段代码在 render 时也可能会运行，那既然这里有防止死循环的措施，那么我们就认为的创造一个死循环。我们在 FC 的顶层 setState 来人为造成死循环：\n\n现在我们知道了，这里就是在控制 render-in-render 的情况，一般这种情况并不会发生，如果发生了就会有 RE_RENDER_LIMIT 的限制，所以 didScheduleRenderPhaseUpdate 变量就是在描述是否是在 render 的过程中又发生了 render（之所以会这样，是因为 useReducer 正是在 render 时才被触发）。\n\n现在我们来分析下这个报错的过程，renderWithHooks 简写做 F：\n\nmount → 外层 FC 触发 F → log children → 进入内层包含死循环的 FC 触发 F → log children → 执行内层 FC → 执行到 toggleLight (引起死循环) → 触发 dispatchAction → didScheduleRenderPhaseUpdate 标记为 true → 执行完内层 FC 后，进入 render-in-render 代码段 → 代码段内部执行 FC → 执行到 toggleLight (引起死循环) → 触发 dispatchAction ... 进入 render-in-render 代码段 → 以此循环 24 次，分别打印 24 次 numberOfReRenders → (在 dev 环境下会 resetHooks 一次，将 didScheduleRenderPhaseUpdate 清零) → 上述内层组件过程在执行一次 → 这个内层组件渲染次数超过 RE_RENDER_LIMIT 限制，报错 → 打印其他 FC children。\n\n\n# useState 的原理\n\n经过上面的分析得知，在不同的生命周期使用的 dispatcher 是不同的，主要分为 mount、update 和 contextOnly 这三种。我们在调用相应的 hook 时，其实是由不同的 dispatcher 来接管的。\n\n下面我们来看下 useState 是如何更新状态的：\n\n\n# mountState\n\n在挂载阶段， HooksDispatcherOnMount 引用的是 mountState 。那就看看 mountState 函数：\n\nfunction mountState < S > (\n    initialState: (() => S) | S,\n): [S, Dispatch < BasicStateAction < S >> ] {\n    // hook 上记载了当前的 hook 的信息，当前要执行的 hook\n    const hook = mountWorkInProgressHook();\n    // 如果 initialState 是函数就执行他\n    if (typeof initialState === 'function') {\n        initialState = initialState();\n    }\n    // 初始状态被记载到memoizedState和baseState，其中 memoizedState 是上一次状态，baseState 是最初状态\n    hook.memoizedState = hook.baseState = initialState;\n    // 生成更新队列对象，挂载到 hook 上\n    // 作为 hook 更新链表的标识\n    const queue = (hook.queue = {\n        last: null,\n        dispatch: null,\n        lastRenderedReducer: basicStateReducer,\n        lastRenderedState: (initialState: any),\n    });\n    // 生成 setState 的回调方法，每个 setState 实质上是一个 dispatchAction\n    const dispatch: Dispatch <\n        BasicStateAction < S > , >\n        = (queue.dispatch = (dispatchAction.bind(\n            null,\n            // Flow doesn't know this is non-null, but we do.\n            ((currentlyRenderingFiber: any): Fiber),\n            queue,\n        ): any));\n    return [hook.memoizedState, dispatch];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n这里可以看出：\n\n 1. useState 在 Mount 阶段将初始状态记录在 hook.baseState 上，并且生成了一个状态更新的对象，这个更新对象上挂载了 dispatch：当前的 setState 方法、lastRenderedState：上次渲染的 State，lastRenderedReducer：上次 reduce 所使用的 reducer 。\n 2. 每个 setState 回调实质上就是一个 dispatchAction，这个 dispatchAction 依赖于 currentlyRenderingFiber：当前渲染的 Fiber、queue：状态更新对象。\n 3. queue 是隶属于 hook 的，是 hook 的一个属性，下文中 dispatchAction 的调用也是通过 Map (queue, LinkedList) 的结构来管理 hook 所产生的更新的。\n\n\n# dispatchAction\n\n如果这时我们调用了 setState 去更新状态，会发生什么呢？那我们就来看看 dispatchAction 这个函数：\n\nfunction dispatchAction < S, A > (\n        fiber: Fiber, // 当前渲染的 Fiber\n        queue: UpdateQueue < S, A > , // 状态更新对象\n        action: A,\n    ) {\n        // 避免渲染死循环，最多可连续渲染 25 次\n        invariant(\n            numberOfReRenders < RE_RENDER_LIMIT,\n            'Too many re-renders. React limits the number of renders to prevent ' +\n            'an infinite loop.',\n        );\n\n        const alternate = fiber.alternate;\n        if (\n            fiber === currentlyRenderingFiber ||\n            (alternate !== null && alternate === currentlyRenderingFiber)\n        ) { // 是否是当前需要渲染的 Fiber，进入渲染阶段， currentlyRenderingFiber 表示当前需要渲染的 fiber\n            // This is a render phase update. Stash it in a lazily-created map of\n            // queue -> linked list of updates. After this render pass, we'll restart\n            // and apply the stashed updates on top of the work-in-progress hook.\n            // 所有的 updates 会保存在一个 map 中，结构是： queue -> linked list\n            // 进入渲染状态的标志\n            didScheduleRenderPhaseUpdate = true;\n            // 创建一个更新句柄\n            const update: Update < S, A > = {\n                expirationTime: renderExpirationTime, // 更新的到期时间\n                suspenseConfig: null,\n                action, // dispatchAction 的传值，这是 updateState 消费更新的原材料\n                eagerReducer: null,\n                eagerState: null,\n                next: null,\n            };\n            if (__DEV__) {\n                // 从调度器获取当前更新的优先级\n                update.priority = getCurrentPriorityLevel();\n                // renderPhaseUpdates 是存放 update queue 的一个队列（Map），如果队列为空，则初始化队列\n                if (renderPhaseUpdates === null) {\n                    renderPhaseUpdates = new Map();\n                }\n                // 取出当前 hook 中的 update 队列的首项\n                const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n                // 如果当前不存在以 queue 对象为键的 update，则将创建的 update 放入队列\n                if (firstRenderPhaseUpdate === undefined) {\n                    renderPhaseUpdates.set(queue, update);\n                } else {\n                    // 如果当前 hook 已经有 update 了，将 update 移动到当前 LinkedLink 的尾部\n                    // Append the update to the end of the list.\n                    let lastRenderPhaseUpdate = firstRenderPhaseUpdate;\n                    while (lastRenderPhaseUpdate.next !== null) {\n                        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n                    }\n                    lastRenderPhaseUpdate.next = update;\n                }\n            } else {\n                // prod 环境 \n                const currentTime = requestCurrentTime();\n                const suspenseConfig = requestCurrentSuspenseConfig();\n                // 计算当前组件 fiber 的到期时间\n                const expirationTime = computeExpirationForFiber(\n                    currentTime,\n                    fiber,\n                    suspenseConfig,\n                );\n                // 创建 update 对象\n                const update: Update < S, A > = {\n                    expirationTime, //  fiber 的过期时间\n                    suspenseConfig, \n                    action, // dispatchAction 的传值\n                    eagerReducer: null, // 提前计算所使用的 reducer，即 queue.lastRenderedReducer\n                    eagerState: null, // 提前计算的 state 缓存\n                    next: null,\n                };\n\n                if (__DEV__) {\n                    update.priority = getCurrentPriorityLevel();\n                }\n                // update 的数据结构，环状单向链表\n                // Append the update to the end of the list.\n                // 将更新挂载到链表尾部\n                const last = queue.last;\n                if (last === null) {\n                    // 如果这是一个空队列，即 update 就是当前 hook 的首次更新，那就将 update 构成环形单向链表。\n                    // 这是因为我们判断这个链表是环形链表。\n                    // 注意：这里并不是说 mount 阶段，因为 mount 阶段只是初始化了 queue。\n                    // This is the first update. Create a circular list.\n                    update.next = update;\n                } else {\n                    // 非首次渲染\n                    // 如果队列非空，队尾的 next 即为 first\n                    const first = last.next;\n                    // 下面代码一般都会执行，因为已经初始化为环形链表了\n                    if (first !== null) {\n                        // 如果队尾是有指向的，也就是已经形成了环形单向链表，那就直接把 update 放到队尾。\n                        // 即 update 的 next 指向 first。\n                        // Still circular.\n                        update.next = first;\n                    }\n                    // 如果已经成环，就仍然是环形；如果没有成环，则 update 在队尾\n                    last.next = update;\n                }\n                // 更新队尾指针，队尾指针总是指向最新的 update\n                queue.last = update;\n                \n                // 一般来说，来到这里的 fiber 的 expirationTime 不会是即时的，如果出现了这种情况，比如即时任务，就可以提前计算新的 state。\n                // 可以看到，在下面的代码中如果 state 没变是直接 return 的，也就是跳过了调度器的 scheduleWork 的调度，减少了更新损耗。\n                // 如果新的 state 与 原来的 state 不等，则仍然需要调度器进行调度，但是计算的结果已经缓存在 update 中了。\n                // 这里的更新属于同步的更新，是通过 const eagerState = lastRenderedReducer(currentState, action) 来计算的。\n                if ( \n                    fiber.expirationTime === NoWork &&\n                    (alternate === null || alternate.expirationTime === NoWork)\n                ) {\n                    // The queue is currently empty, which means we can eagerly compute the\n                    // next state before entering the render phase. If the new state is the\n                    // same as the current state, we may be able to bail out entirely.\n                    const lastRenderedReducer = queue.lastRenderedReducer;\n                    if (lastRenderedReducer !== null) {\n                        let prevDispatcher;\n                        try {\n                            const currentState: S = (queue.lastRenderedState: any);\n                            const eagerState = lastRenderedReducer(currentState, action);\n                            // Stash the eagerly computed state, and the reducer used to compute\n                            // it, on the update object. If the reducer hasn't changed by the\n                            // time we enter the render phase, then the eager state can be used\n                            // without calling the reducer again.\n                            update.eagerReducer = lastRenderedReducer;\n                            update.eagerState = eagerState;\n                            if (is(eagerState, currentState)) {\n                                // Fast path. We can bail out without scheduling React to re-render.\n                                // It's still possible that we'll need to rebase this update later,\n                                // if the component re-renders for a different reason and by that\n                                // time the reducer has changed.\n                                return;\n                            }\n                        } catch (error) {\n                            // Suppress the error. It will throw again in the render phase.\n                        } finally {\n                            if (__DEV__) {\n                                ReactCurrentDispatcher.current = prevDispatcher;\n                            }\n                        }\n                    }\n                }\n\n                // 调度 fiber 上的更新\n                scheduleWork(fiber, expirationTime);\n            }\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n\n\n核心理解\n\n * hook 所产生的 update 是在 dispatchAction 中产生的， 也就是说整个函数一定运行在 render 阶段。\n * hook 上发生的更新在 dev 和 prod 不一样，在 dev 上是通过更新队列 renderPhaseUpdates Map (queue, 单向 linkedList) 来维护的，而在 prod 环境是通过 renderPhaseUpdates Map (queue, 环形 linkedList) 来维护的。\n * 每个 hook 维护了一个 queue 用来记录改 hook 所引发的更新。queue 的 last 指向最新的 update。queue 作为 renderPhaseUpdates 的键，挂在了 update 所组成的环形链表。\n * update 被初始化为环形链表，之后所产生的的 update 都被插入到环形链表的尾部。\n\n下面重点看一下 dispatchAction 中的数据结构。\n\n * dispatchAction 数据结构是 map<queue, linked list>，其中 update 构成单向环形链表。\n * scheduleWork (fiber, expirationTime) 会调度 fiber 的更新。\n * react update 数据结构图如下图。\n\n注意\n\n这张图以首次 update 和原来形成环状两个部分为主，原来没有形成环状基本不会出现。\n\nupdate 对象是如何处理的？\n\nupdate 对象是根据 queue.last 指针来确定的，也就是说可以通过 last 指针找到最新的 update 。那么 dispatchAction 这个函数的主要作用就是：\n\n * 将 hook 运行所产生的的 update 添加到链表中，便于 scheduleWork 以及之后的程序 (调度器) 去调度使用。\n * 同时对于挂载阶段的首次 update 也做了特殊的处理，在进入渲染之前如果是同步任务就提前计算下一个 state，即 eagerState。减少调度损耗。\n * scheduleWork 正是任务调度中的起始部分。\n\n下面来看几个问题？\n\n 1. 为什么使用单向环形链表和管理更新？\n\n * 单向环形链表相比于单向链表具有一个很大的优势就是可以从任意一个节点来遍历整个链表，对链表的头部和尾部没有那么重视。所有在单向环形链表中搜索的效率可以很大的提高。\n * react 的更新依赖于优先级，每一个 update 优先级不同，要保证高优先级的 update 优先执行，搜索效率尤为重要。\n * 环状链表可以方便定位到任何一次高优先级的更新位置去执行，而暂时摒弃低优先级的更新，提高更新的效率。\n\n参考文档：\n\n * 数据结构系列 - 2 - 循环链表\n\n\n# updateState\n\n在 render 阶段，HooksDispatcherOnUpdate 这个 dispatcher 所调用的是 updateState 这个函数。\n\n下面我们就来看看这个函数：\n\nfunction updateState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  return updateReducer(basicStateReducer, (initialState: any));\n}\n\n\n1\n2\n3\n4\n5\n\n\n这里可以看到：\n\n * updateState 是依赖于 updateReducer 来处理状态变化的，后面我们会看到 useReducer 在 update 阶段所使用的正是 updateReducer。\n * updateReducer 接受初始状态 reducer 和 initialState，返回一个 state 和一个 dispatch 函数，这符合我们对 useReducer 的认知。可见 useReducer 是 useState 状态管理的基础。\n * useState 使用的 reducer 是 basicStateReducer。\n\n# 什么是 reducer 和 basicStateReducer？\n\nfunction reducer(state, action): state {}\n\n\n1\n\n\nreducer 就是一个状态转换机，接受一个 state 和 用于转换 state 的 action，返回一个新的 state。\n\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  return typeof action === 'function' ? action(state) : action;\n}\n\n\n1\n2\n3\n\n\nbasicStateReducer 就是说：如果 action 是一个状态转换器（即是函数），就将原状态交由转换器进行转换，返回新的状态，否则就像 action 视为一个返回新状态。看到这里，和 useState 中 dispatch 的用法就契合上了，useState 使用了 basicStateReducer。\n\n下面来看一下 updateReducer 是如何处理的，解决了这个问题，我们可以同时弄清楚 useReducer 的原理了。\n\n\n# updateReducer\n\n请看 updateReducer 函数的源码：\n\nfunction updateReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  // 当前正在调度的 hook\n  const hook = updateWorkInProgressHook();\n  // queue 就是上文中分析的 hook 更新的数据结构，queue 非空，即 queue 中的 update 一定不会为空。\n  // 因为在useState mount 阶段会初始化一个 Update，并且 last 指针指向他。\n  const queue = hook.queue;\n  invariant(\n    queue !== null,\n    'Should have a queue. This is likely a bug in React. Please file an issue.',\n  );\n\n  // 最近用于渲染的 reducer 记录在 queue 上\n  queue.lastRenderedReducer = reducer;\n  // 如果 hook 已经 render 过\n  if (numberOfReRenders > 0) {\n    // This is a re-render. Apply the new render phase updates to the previous\n    // work-in-progress hook.\n    // 这里的 dispatch 是在上一次 setState 是挂载到 queue 上的，如果是 mount 阶段，\n    // 也会返回一个 dispatch，可参照 mount 阶段\n    const dispatch: Dispatch<A> = (queue.dispatch: any);\n    // renderPhaseUpdates 中记录了更新队列，结构是  Map<UpdateQueue,Update Linked List>\n    // 更新队列非空\n    if (renderPhaseUpdates !== null) {\n      // Render phase updates are stored in a map of queue -> linked list\n      // 获取当前 hook 的第一个更新\n      const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n      // 如果没有需要更新的，则不必走下面的 reduce 过程\n      // firstRenderPhaseUpdate 正在更新链表的头指针\n      if (firstRenderPhaseUpdate !== undefined) {\n        // 经过下面 reduce 的过程，当前 queue 下所有的更新应该都被处理，\n        // 所以这里可以提前将 queue 删掉，因为 queue 下面的 update 链表已经保存在 firstRenderPhaseUpdate指针\n        // 这里实际上是并没有断开 queue 和 firstRenderPhaseUpdate 的指向关系，只是在 firstRenderPhaseUpdate map 中将 queue 移除，\n        // 由于 queue 还有引用，不不会被垃圾回收。\n        renderPhaseUpdates.delete(queue);\n        // state reduce 过程以 memoizedState 为初始状态\n        let newState = hook.memoizedState;\n        let update = firstRenderPhaseUpdate;\n        // 这个循环说明在useState的状态更新过程中，会将 update 组成一个一个的 queue，每个 queue 中的\n        // 所有的 update 都是一起更新的（batch update），也就是一个更新链。这样可以避免产生过多的无意义的 re-render，\n        // 提高更新的效率。\n        // 这里链表的执行是从链尾到链首依次reduce的。\n        do {\n          // Process this render phase update. We don't have to check the\n          // priority because it will always be the same as the current\n          // render's.\n          // 这里不用关注优先级，因为这属于同一次渲染。\n          // 每个 update 上都有一个 action ,具体可见上文 update 的结构\n          // setState 的 action 是一个 BasicStateAction\n          const action = update.action;\n          // reducer 将当前状态转换为新状态\n          newState = reducer(newState, action);\n          // 指针移到下一个 update\n          update = update.next;\n        } while (update !== null);\n\n        // Mark that the fiber performed work, but only if the new state is\n        // different from the current state.\n        // 如果最新状态 newState 和原状态 memoizedState 不一致，则 didReceiveUpdate 为 true\n        // 表示在 fiber 应该执行更新\n        if (!is(newState, hook.memoizedState)) {\n          markWorkInProgressReceivedUpdate();\n        }\n        // 更新 memoizedState，方便下次 render\n        hook.memoizedState = newState;\n        // Don't persist the state accumulated from the render phase updates to\n        // the base state unless the queue is empty.\n        // TODO: Not sure if this is the desired semantics, but it's what we\n        // do for gDSFP. I can't remember why.\n        // 除非队列为空，否则不要将渲染阶段更新累积的状态持久化到基本状态。\n        if (hook.baseUpdate === queue.last) {\n          hook.baseState = newState;\n        }\n        // lastRenderedState 记录上一次的 state，此次 render 后，将上次渲染状态更新为 newState\n        queue.lastRenderedState = newState;\n        // 经过 render 之后返回新状态 newState 和 dispatch 函数。dispatch 实际上是从 queue 上取的，实际上是 dispatchAction 函数。\n        return [newState, dispatch];\n      }\n    }\n    // 没有经过 render，只需返回原状态 memoizedState。\n    return [hook.memoizedState, dispatch];\n  }\n  \n  // hook 首次 render,之所以要区分开，是因为首次 render 需要做一些初始化工作\n  // The last update in the entire queue\n  const last = queue.last;\n  // The last update that is part of the base state.\n  const baseUpdate = hook.baseUpdate;\n  const baseState = hook.baseState;\n\n  // Find the first unprocessed update.找到第一个未处理的更新\n  let first;\n  // baseUpdate 为上次的更新\n  if (baseUpdate !== null) {\n    if (last !== null) {\n      // For the first update, the queue is a circular linked list where\n      // `queue.last.next = queue.first`. Once the first update commits, and\n      // the `baseUpdate` is no longer empty, we can unravel the list.\n      // 这是首次 update，queue.last.next = queue.first, 如果是首次渲染，只有一个 update，如果这个 update 被 commit，\n      // 就可以将链表解开\n      last.next = null;\n    }\n    // 正常情况下直接取 baseUpdate.next\n    first = baseUpdate.next;\n  } else {\n    // 没有上次更新，取 last.next\n    first = last !== null ? last.next : null;\n  }\n  if (first !== null) {\n    // reduce 的初始状态\n    let newState = baseState;\n    let newBaseState = null;\n    let newBaseUpdate = null;\n    let prevUpdate = baseUpdate;\n    let update = first;\n    let didSkip = false;\n    // 循环 reduce 状态，获取最新状态\n    do {\n      const updateExpirationTime = update.expirationTime;\n      // 该 update 太新，未超过 renderExpirationTime，优先级较低, expirationTime 是负数\n      // renderExpirationTime = 0\n      if (updateExpirationTime < renderExpirationTime) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        // 对于优先级较低的 update,会先跳过。如果首次跳过，就应该对 newBaseUpdate、 newBaseState\n        // 赋原值，否则不改变值即可\n        if (!didSkip) {\n          didSkip = true;\n          newBaseUpdate = prevUpdate;\n          newBaseState = newState;\n        }\n        // remainingExpirationTime 表示当前队列中不用立即渲染的低优先级的 update 中距离 renderExpirationTime\n        // 最近的超时时间，这个时间越大，在下次渲染中该队列的优先级越大，每次终端都会更新这个值\n        // Update the remaining priority in the queue.\n        if (updateExpirationTime > remainingExpirationTime) {\n          remainingExpirationTime = updateExpirationTime;\n          markUnprocessedUpdateTime(remainingExpirationTime);\n        }\n      // 优先级达到标准的 update 会进行渲染\n      } else {\n        // This update does have sufficient priority.\n\n        // Mark the event time of this update as relevant to this render pass.\n        // TODO: This should ideally use the true event time of this update rather than\n        // its priority which is a derived and not reverseable value.\n        // TODO: We should skip this update if it was already committed but currently\n        // we have no way of detecting the difference between a committed and suspended\n        // update here.\n        markRenderEventTimeAndConfig(\n          updateExpirationTime,\n          update.suspenseConfig,\n        );\n\n        // Process this update.\n        // eagerReducer 和 当前的 reducer 表示进行了提前计算\n        if (update.eagerReducer === reducer) {\n          // If this update was processed eagerly, and its reducer matches the\n          // current reducer, we can use the eagerly computed state.\n          // 如果有提前计算的 reducer, 并且和当前的 reducer 一样，可以使用提前计算的结果\n          newState = ((update.eagerState: any): S);\n        } else {\n          // reduce 新的状态\n          const action = update.action;\n          newState = reducer(newState, action);\n        }\n      }\n      // 保存原来的状态\n      prevUpdate = update;\n      // 移向下一个 update\n      update = update.next;\n      // first 已经执行过，移动到链尾\n    } while (update !== null && update !== first);\n\n    // 如果有首次跳过中断的 update，newBaseUpdate 记录中断前的 update，否则记录最新的 update\n    if (!didSkip) {\n      newBaseUpdate = prevUpdate;\n      newBaseState = newState;\n    }\n\n    // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n    // 标记前后状态是否确实有更新，didReceiveUpdate 标记为 true 时，才会真正去更新 Fiber\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState;\n    hook.baseUpdate = newBaseUpdate;\n    hook.baseState = newBaseState;\n\n    queue.lastRenderedState = newState;\n  }\n\n  const dispatch: Dispatch<A> = (queue.dispatch: any);\n  return [hook.memoizedState, dispatch];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n\n\n上面这个函数的信息量很大，总结如下。\n\n * updateReducer 主要的作用就是：处理 updates 链表，更新 state 的状态。\n * queue 是 hook 上的管理更新的数据结构。queue 中包含了的数据如下。\n\n参数                    描述\nlastRenderedReducer   用于 reduce 状态的 reducer\ndispatch              暴露给用户的修改状态的 dispatchAction\nlast                  指向 update queue 中首个 update 的指针\nlastRenderedState     上一次渲染的状态\n\n * dispatch 和 reducer 的区别：\n\nfunction dispatch(state || () => state): void // 本质上就是一个 action\nfunction reducer(state, action): state // 本质上是一个状态转换器\n\n\n1\n2\n\n\n * numberOfReRenders 会随着 renderWithHooks 的调用增加，记录的是 renderWithHooks 的调用次数，也就是 re-render 的次数。renderWithHooks 主要在 react-reconciler 包中 ReactFiberBeginWork.js 中使用，这个函数是渲染 FC 组件的，返回组件的渲染节点。 numberOfReRenders 只有增加、重置两种操作。在 finishHooks 和 resetHooks 函数中会将 numberOfReRenders 重置为 0；这说明在 hook finish 之前，renderWithHooks 可能会调用多次。\n\n * renderExpirationTime 是一个常量 NoWork = 0 ，因此 updateExpirationTime 应该是负数，当这个到期时间达到 0 时，才具有渲染的与优先级，否则会被跳过，并更新 remainingExpirationTime（remainingExpirationTime 是逐渐变大的）。\n\n * updateReducer 结构图：\n\n核心理解\n\n * 在一个 hook 执行期间，首次更新渲染（不是 mount 时的渲染）和多次更新渲染所使用的 updateState 的逻辑是不一样的。首次更新渲染需要过滤掉优先级较低的 update ，多次更新渲染则直接对所有 update 进行 reduce（reduce 就是计算 newState 的过程）。\n * resetHooks 方法 会在 performSyncWorkOnRoot/performConcurrentWorkOnRoot → handleError 中调用。这说明在 react 执行期间，如果不出意外的话就一直属于 hook 运行的生命周期。\n * Batched Updates\n\n这里的核心逻辑就是对 hook 中的 queue 下的更新进行合并更新。合并更新是在一次发生的，也就是说 react 对用户的 dispatchAction 并非一次一次的更新，而是在 dispatchAction 和真正的 reduce updates 这中间做了一个合流，在 reduce update 之后产生新的状态到真正的渲染，也就是 renderWithHooks 这中间又间隔着调度器的调度，相当于又一次的合流。这样的两次合流，就是的从 dispatchAction 到 render 之间的损耗大大减小，渲染的效率有了很大的提高。就像千万溪流汇聚成大海，这样的渲染就节省了很多的中间状态的开支。\n\ndo {\n  newState = reducer(newState, action);\n  update = update.next;\n} while (update !== null);\n\n\n1\n2\n3\n4\n\n\n\n# 一些问题\n\n看到这里还有一些细节问题：\n\n\n# useState 是同步引起 UI 更新吗？\n\n在这个部分里，只是对 newState 做了计算，最终 newState 被挂载在了 hook.memoizedState 上（也就是说更新了 hook.memoizedState 的值），在需要 reRender 时将 didReceiveUpdate 标记为了 true。真正的 UI 的更新，还得跟 render 部分和调度器有关。didReceiveUpdate 主要在 react-reconciler 包中 ReactFiberBeginWork.js 中被使用。useState 只是对 didReceiveUpdate 做了标记，UI 更新会在 setState 之后 dispatchAction 中 scheduleWork 的调用后由调度器进行调度更新。\n\n\n# renderPhaseUpdates 管理更新\n\n下面仅展示 renderPhaseUpdates 相关的的内容。 renderPhaseUpdates 数据结构如下：\n\nlet renderPhaseUpdates: Map<\n  UpdateQueue<any, any>,\n  Update<any, any>,\n> | null = null;\n\n\n1\n2\n3\n4\n\n\ndispatchAction 中：\n\nif (renderPhaseUpdates === null) {\n  renderPhaseUpdates = new Map();\n}\nconst firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\nif (firstRenderPhaseUpdate === undefined) {\n  renderPhaseUpdates.set(queue, update);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nupdateReducer 中：\n\nif (renderPhaseUpdates !== null) {\n  const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n  if (firstRenderPhaseUpdate !== undefined) {\n    renderPhaseUpdates.delete(queue);\n    ...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * renderPhaseUpdates 本质是一个 Map，在 dispatchAction 中初始化，并且将 setState 所产生的更新装进 map，每个 useState 对应 map 中的一个 queue，queue 中是一个环状链表，last 指向首个 update。\n * 在 resetHooks 中被重置为 null，在 updateReducer 中 queue 被消费。\n\n\n# 为什么 setState 是状态的替换，而不是状态的补充？\n\n我们知道 setState 实质上创建 queue 上的更新并将 queue 上的 update 链表的结构更新了，并且通知了 scheduleWork 调度 fiber 上的更新。因此在更新中 updateReducer 生成了 newState，这里的 newState 作为新的页面状态重新渲染了页面。updateReducer 中更新 newState 靠的就是 reducer，在 useState 中使用的 reducer 就是 basicStateReducer 。basicStateReducer 是将 setState 中的状态直接替换了原来的状态。因此，setState 实际上是状态的替换。如果想要状态的补充，可以在 setState 中将原来的状态进行 merge 之后再替换，这不修改 setState 的本质特点，但是相比之下会更加灵活。\n\nbasicStateReducer：\n\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  return typeof action === 'function' ? action(state) : action;\n}\n\n\n1\n2\n3\n\n\nuseMergedState：\n\nexport function useMergedState<T>(initialState: T) {\n  const [state, setState] = useState<T>(initialState);\n  let mergeState: any = setState;\n  if (typeof state === 'object') {\n    mergeState = (value: T) => {\n      if (value && typeof value === 'object') {\n        setState({\n          ...state,\n          ...value,\n        });\n      } else {\n        setState(value);\n      }\n    };\n  }\n  return [state, setState, mergeState];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 为什么 batch update 时，链表上会有多个 update?\n\n * 链表上的 update 是由 dispatchAction 生成的，dispatchAction 生产 update 是同步执行的，也就是说，在很短的情况下 queue 上会几句大量的 update。\n * update 在被 dispatchAction 管理时并不会立即被 reduce，因为 update 依赖于调度器在 fiber 上进行优先级调度的，可以看做一个异步的过程。\n * 在某个 fiber 上所产生的任务被调度器释放触发更新循环时，可能在 queue 上已经积累了大量的 update 了。注意调度器的调度并不是以 update 为单位的，而是以 fiber 为单位的。这是因为 update 是在太多了，会引起调度的效率低下。\n\n\n# 本篇小结\n\n通过这边文章从 dispatcher 分发器、mountState、dispatchAction、updateState 等代码的分析，总结如下：\n\n 1. 重要函数的作用\n\n * dispatcher：管理当前环境下应该调用的 hook。\n * mountState：初始化 hook 和 queue。mount 阶段不生产和消费 update。\n * dispatchAction：生产 update；管理和维护 update，将 update 的调度移交给调度器。\n * updateState（updateReducer）：消费 update，更新 fiber 上的 state。\n\n 2. 原理梗概：\n\n * 各种 hook api 都是由 dispatcher 管理的，不同的渲染阶段会使用不同的 dispatcher，当然 dev 环境也会有 dev 环境的 dispatcher。\n * mount 阶段调用 mountState 初始化 state 并生成 queue， 在 dispatchAction 中加入 renderPhaseUpdates，并且直接由 dispatchAction 管理。\n * render 阶段调用 updateState 利用 reducer 更新 state 和 dispatch，这里并没有直接引起渲染。\n * 在 setState 被使用时就调用了 dispatchAction 调度渲染。dispatchAction 创建更新对象，更新 update 环形链表的结构，并且调用了 scheduleWork 去调度更新 Fiber。\n\n\n# 参考资料\n\n * 官方文档\n * React Hooks 核心实现",normalizedContent:"# 目录\n\n\n\n * 目录\n * dispatcher 分发器\n   * 定义\n   * dispatcher 是什么？如何生成的？\n   * dispatcher 是如何调度的？\n * usestate 的原理\n   * mountstate\n   * dispatchaction\n   * updatestate\n * updatereducer\n * 一些问题\n   * usestate 是同步引起 ui 更新吗？\n   * renderphaseupdates 管理更新\n   * 为什么 setstate 是状态的替换，而不是状态的补充？\n   * 为什么 batch update 时，链表上会有多个 update?\n * 本篇小结\n * 参考资料\n\n\n\n\n# dispatcher 分发器\n\n在 react 包中 react.js 文件导出了 hooks 相关的 api，包括：\n\nusecallback, // 函数缓存\nusecontext, // 从 context 中获得 provider 传递的数据，经常和 createcontext 和 context.provider 一起使用。\nuseeffect, // 执行副作用，包括网络请求，数据交互，ui 更新等。\nuseimperativehandle, // 将组件内部的变量或者方法暴露给外部，外部可使用 ref 进行调用。\nusedebugvalue, // debug 时的优化项\nuselayouteffect, // 在 dom 更新之后浏览器执行绘制之前同步的执行副作用\nusememo, // 缓存变量\nusereducer, // 用于状态管理（数据共享），可以调用 reducer，常与 usecontext 一起使用\nuseref, // 非响应式的数据暂存\nusestate, // 响应式的组件状态管理\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n我们先来看 usestate 的原理。\n\n\n# 定义\n\n所有的 hooks 从 react 包中 reacthooks.js 导出定义，usestate 定义如下：\n\nfunction usestate < s > (initialstate: (() => s) | s) {\n    const dispatcher = resolvedispatcher();\n    return dispatcher.usestate(initialstate);\n}\n\n\n1\n2\n3\n4\n\n\n从这个定义里可以看出：\n\n 1. s 是 state 的泛型，usestate 传入一个初始的状态 initialstate ，初始状态可以直接传入，也可以函数式传入。当初始状态需要较多的计算量时，可以使用函数返回值的方式传入。\n 2. 所有的 hook 都需要经过 resolvedispatcher 返回的 dispatcher 来管理。\n\n\n# dispatcher 是什么？如何生成的？\n\n先来看 resolvedispatcher 这个函数，这个函数负责找到当前的分发器，reactcurrentdispatcher 用来追踪当前的分发器：\n\nconst dispatcher = reactcurrentdispatcher.current;\n\n\n1\n\n\n如果找不到分发器，就会报我们使用 hook 最常见的错误：\n\ninvalid hook call. hooks can only be called inside of the body of a function component.\n\n\n1\n\n\nreactcurrentdispatcher 被放在了 reactsharedinternals 中，从 react-reconciler 包中 reactfiberhooks.js 中可以看到 dispatcher 类型：\n\ntype dispatcher = {\n    readcontext < t > (\n        context: reactcontext < t > ,\n        observedbits: void | number | boolean,\n    ): t,\n    usestate < s > (initialstate: (() => s) | s): [s, dispatch < basicstateaction < s >> ],\n    usereducer < s,\n    i,\n    a > (\n        reducer: (s, a) => s,\n        initialarg: i,\n        init ? : (i) => s,\n    ): [s, dispatch < a > ],\n    usecontext < t > (\n        context: reactcontext < t > ,\n        observedbits: void | number | boolean,\n    ): t,\n    useref < t > (initialvalue: t): {\n        current: t\n    },\n    useeffect(\n        create: () => (() => void) | void,\n        deps: array < mixed > | void | null,\n    ): void,\n    uselayouteffect(\n        create: () => (() => void) | void,\n        deps: array < mixed > | void | null,\n    ): void,\n    usecallback < t > (callback: t, deps: array < mixed > | void | null): t,\n    usememo < t > (nextcreate: () => t, deps: array < mixed > | void | null): t,\n    useimperativehandle < t > (\n        ref: {\n            current: t | null\n        } | ((inst: t | null) => mixed) | null | void,\n        create: () => t,\n        deps: array < mixed > | void | null,\n    ): void,\n    usedebugvalue < t > (value: t, formatterfn: ? (value: t) => mixed): void,\n    useresponder < e,\n    c > (\n        responder: reacteventresponder < e, c > ,\n        props: object,\n    ): reacteventresponderlistener < e,\n    c > ,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n可见所有的 hook 都是由 dispatcher 来调度执行的。那么 dispatcher 只有一种吗？dispatcher 不止以一种，包括 contextonlydispatcher、hooksdispatcheronmount、hooksdispatcheronupdate 三种，还有一些 dev 环境的 dispatcher。 可以把 dispatcher 看做是一个 hook 的分发器，在不同的渲染阶段由不同的分发器来进行调度。那么不同的分发器有什么区别呢？我们来看一下这三种分发器：\n\nexport const contextonlydispatcher: dispatcher = {\n    readcontext,\n\n    usecallback: throwinvalidhookerror,\n    usecontext: throwinvalidhookerror,\n    useeffect: throwinvalidhookerror,\n    useimperativehandle: throwinvalidhookerror,\n    uselayouteffect: throwinvalidhookerror,\n    usememo: throwinvalidhookerror,\n    usereducer: throwinvalidhookerror,\n    useref: throwinvalidhookerror,\n    usestate: throwinvalidhookerror,\n    usedebugvalue: throwinvalidhookerror,\n    useresponder: throwinvalidhookerror,\n};\n\nconst hooksdispatcheronmount: dispatcher = {\n    readcontext,\n\n    usecallback: mountcallback,\n    usecontext: readcontext,\n    useeffect: mounteffect,\n    useimperativehandle: mountimperativehandle,\n    uselayouteffect: mountlayouteffect,\n    usememo: mountmemo,\n    usereducer: mountreducer,\n    useref: mountref,\n    usestate: mountstate,\n    usedebugvalue: mountdebugvalue,\n    useresponder: createresponderlistener,\n};\n\nconst hooksdispatcheronupdate: dispatcher = {\n    readcontext,\n    usecallback: updatecallback,\n    usecontext: readcontext,\n    useeffect: updateeffect,\n    useimperativehandle: updateimperativehandle,\n    uselayouteffect: updatelayouteffect,\n    usememo: updatememo,\n    usereducer: updatereducer,\n    useref: updateref,\n    usestate: updatestate,\n    usedebugvalue: updatedebugvalue,\n    useresponder: createresponderlistener,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n可见分发器的区别在于 hook 的实例是不同的，contextonlydispatcher 中直接报 invalid hook call 的错误， hooksdispatcheronmount 中是 mount 阶段的 hook，而hooksdispatcheronupdate 中是 update 阶段的 hook 。一个很明显的区别就是 hooksdispatcheronmount 中的 hook 会做一些初始化、初始值的操作，而 hooksdispatcheronupdate 中的 hook 主要做一些更新的操作。\n\n\n# dispatcher 是如何调度的？\n\n上面已经说明了 dispatcher 是什么，现在探讨一下当前的 dispatcher 是怎么设置的。hooksdispatcheronmount、hooksdispatcheronupdate 这两种 dispatcher，在 renderwithhooks 函数中设置。contextonlydispatcher 还会在 resethooks 函数中设置。\n\n这个函数将会在每次 hook 被调用时执行。\n\n先看一下 renderwithhooks 函数，去除 dev 代码：\n\nfunction renderwithhooks(\n    current: fiber | null, // 已经被渲染的 fiber\n    workinprogress: fiber, // 等待被渲染的 fiber\n    component: any, // hook 所依赖的组件，由于 hook 只存在于函数式组件，这里就是 fc\n    props: any, // hook hook 所依赖的组件的属性\n    reforcontext: any,\n    nextrenderexpirationtime: expirationtime, // 下次渲染的到期时间\n): any {\n    renderexpirationtime = nextrenderexpirationtime;\n    // 这是当前正在渲染的 fiber \n    currentlyrenderingfiber = workinprogress;\n    // 1. 更新 dispatcher\n    // 如果当前的 fiber 已经存在，说明是 update 阶段\n    nextcurrenthook = current !== null ? current.memoizedstate : null;\n    \n    // current?.memoizedstate 有值 ,则 dispatcher 为 hooksdispatcheronupdate，否则为 hooksdispatcheronmount\n    reactcurrentdispatcher.current =\n        nextcurrenthook === null ?\n        hooksdispatcheronmount :\n        hooksdispatcheronupdate;\n    // 2. 执行 fc 获得节点\n    // 执行 component() 函数即执行 fc，返回需要渲染的节点, 可见 fc 的参数为：props 和 reforcontext\n    let children = component(props, reforcontext);\n\n\n    if (didschedulerenderphaseupdate) {\n        do {\n            // 标志位置为了 false，则只会执行一次\n            didschedulerenderphaseupdate = false;\n            // 记录渲染的次数，如果numberofrerenders > re_render_limit,就会报 too many re-renders 的错误。防止进入渲染的死循环\n            numberofrerenders += 1;\n            \n            // start over from the beginning of the list\n            nextcurrenthook = current !== null ? current.memoizedstate : null;\n            nextworkinprogresshook = firstworkinprogresshook;\n\n            currenthook = null;\n            workinprogresshook = null;\n            componentupdatequeue = null;\n\n            // 这里是为了区分 dev 和 prd 环境中的 updatedispatcher\n            reactcurrentdispatcher.current = __dev__ ?\n                hooksdispatcheronupdateindev :\n                hooksdispatcheronupdate;\n            // re-render: 重新生成组件节点\n            children = component(props, reforcontext);\n        } while (didschedulerenderphaseupdate);\n\n        renderphaseupdates = null;\n        numberofrerenders = 0;\n    }\n\n    // we can assume the previous dispatcher is always this one, since we set it\n    // at the beginning of the render phase and there's no re-entrancy.\n    // 渲染完毕后的 dispatcher 为 contextonlydispatcher\n    // 只有在 renderwithhooks 内部，即是 hooks 在渲染时才会取 mountdispatcher 或者 updatedispatcher。\n    reactcurrentdispatcher.current = contextonlydispatcher;\n\n    // 更新 renderedwork，renderedwork 记录上一次 hook 渲染的结果\n    const renderedwork: fiber = (currentlyrenderingfiber: any);\n\n    renderedwork.memoizedstate = firstworkinprogresshook;\n    renderedwork.expirationtime = remainingexpirationtime;\n    renderedwork.updatequeue = (componentupdatequeue: any);\n    renderedwork.effecttag |= sideeffecttag;\n\n    // this check uses currenthook so that it works the same in dev and prod bundles.\n    // hooktypesdev could catch more cases (e.g. context) but only in dev bundles.\n    const didrendertoofewhooks =\n        currenthook !== null && currenthook.next !== null;\n\n    // 做清理工作，防止这些变量污染下次执行\n    renderexpirationtime = nowork;\n    currentlyrenderingfiber = null;\n\n    currenthook = null;\n    nextcurrenthook = null;\n    firstworkinprogresshook = null;\n    workinprogresshook = null;\n    nextworkinprogresshook = null;\n\n    remainingexpirationtime = nowork;\n    componentupdatequeue = null;\n    sideeffecttag = 0;\n\n    invariant(\n        !didrendertoofewhooks,\n        'rendered fewer hooks than expected. this may be caused by an accidental ' +\n        'early return statement.',\n    );\n\n    // 返回更新后的组件\n    return children;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n\n核心理解\n\n * renderwithhooks 只会在 mount 阶段执行，每个 fc 组件会执行一次，类组件不执行。\n * renderwithhooks 生成的 children 是 reactelement。\n\n由这个函数可以看出：\n\n 1. current 是当前已经渲染或的 fiber，是现在的 fiber， current.memoizedstate 在类组件中保存的是上一次 fiber 当前的状态，而在函数组件中无法通过 this 来引用 state，因此 current.memoizedstate 中保存的是 hook。\n 2. 渲染 hook 时会根据 current.memoizedstate 的值来判断是属于挂载阶段还是更新阶段，如果是挂载阶段，使用的 dispatcher 就是 hooksdispatcheronmount ，如果是更新阶段，使用的 dispatcher 就是 hooksdispatcheronupdate 。\n 3. 在 dispatchaction 被调用时，才会更新状态重新渲染。\n 4. 渲染完毕后，dispatcher 就是 contextonlydispatcher 。即 renderwithhooks 没有重新调用时，dispatcher 是不会生效的。\n 5. renderwithhooks 将执行函数式组件返回更新后的节点。\n 6. 有一段代码很奇怪：\n\nif (didschedulerenderphaseupdate) {\n    do {\n        // 标志位置为了 false，则只会执行一次\n        didschedulerenderphaseupdate = false;\n        // 记录渲染的次数，如果numberofrerenders > re_render_limit(25),就会报 too many re-renders 的错误。防止进入渲染的死循环\n        numberofrerenders += 1;\n\n        // 这里是为了区分 dev 和 prd 环境中的 updatedispatcher\n        reactcurrentdispatcher.current = __dev__ ?\n            hooksdispatcheronupdateindev :\n            hooksdispatcheronupdate;\n        // re-render: 重新生成组件节点\n        children = component(props, reforcontext);\n    } while (didschedulerenderphaseupdate);\n\n    renderphaseupdates = null;\n    numberofrerenders = 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面不是讲了吗，renderwithhooks 只会在 mount 是调用啊，但是 didschedulerenderphaseupdate 这个值是在 usereducer 中设置为 true 的啊，也就是说只有在 render 阶段才会进入这段代码，这不是矛盾吗？ 也许我们可以猜测，这段代码在 render 时也可能会运行，那既然这里有防止死循环的措施，那么我们就认为的创造一个死循环。我们在 fc 的顶层 setstate 来人为造成死循环：\n\n现在我们知道了，这里就是在控制 render-in-render 的情况，一般这种情况并不会发生，如果发生了就会有 re_render_limit 的限制，所以 didschedulerenderphaseupdate 变量就是在描述是否是在 render 的过程中又发生了 render（之所以会这样，是因为 usereducer 正是在 render 时才被触发）。\n\n现在我们来分析下这个报错的过程，renderwithhooks 简写做 f：\n\nmount → 外层 fc 触发 f → log children → 进入内层包含死循环的 fc 触发 f → log children → 执行内层 fc → 执行到 togglelight (引起死循环) → 触发 dispatchaction → didschedulerenderphaseupdate 标记为 true → 执行完内层 fc 后，进入 render-in-render 代码段 → 代码段内部执行 fc → 执行到 togglelight (引起死循环) → 触发 dispatchaction ... 进入 render-in-render 代码段 → 以此循环 24 次，分别打印 24 次 numberofrerenders → (在 dev 环境下会 resethooks 一次，将 didschedulerenderphaseupdate 清零) → 上述内层组件过程在执行一次 → 这个内层组件渲染次数超过 re_render_limit 限制，报错 → 打印其他 fc children。\n\n\n# usestate 的原理\n\n经过上面的分析得知，在不同的生命周期使用的 dispatcher 是不同的，主要分为 mount、update 和 contextonly 这三种。我们在调用相应的 hook 时，其实是由不同的 dispatcher 来接管的。\n\n下面我们来看下 usestate 是如何更新状态的：\n\n\n# mountstate\n\n在挂载阶段， hooksdispatcheronmount 引用的是 mountstate 。那就看看 mountstate 函数：\n\nfunction mountstate < s > (\n    initialstate: (() => s) | s,\n): [s, dispatch < basicstateaction < s >> ] {\n    // hook 上记载了当前的 hook 的信息，当前要执行的 hook\n    const hook = mountworkinprogresshook();\n    // 如果 initialstate 是函数就执行他\n    if (typeof initialstate === 'function') {\n        initialstate = initialstate();\n    }\n    // 初始状态被记载到memoizedstate和basestate，其中 memoizedstate 是上一次状态，basestate 是最初状态\n    hook.memoizedstate = hook.basestate = initialstate;\n    // 生成更新队列对象，挂载到 hook 上\n    // 作为 hook 更新链表的标识\n    const queue = (hook.queue = {\n        last: null,\n        dispatch: null,\n        lastrenderedreducer: basicstatereducer,\n        lastrenderedstate: (initialstate: any),\n    });\n    // 生成 setstate 的回调方法，每个 setstate 实质上是一个 dispatchaction\n    const dispatch: dispatch <\n        basicstateaction < s > , >\n        = (queue.dispatch = (dispatchaction.bind(\n            null,\n            // flow doesn't know this is non-null, but we do.\n            ((currentlyrenderingfiber: any): fiber),\n            queue,\n        ): any));\n    return [hook.memoizedstate, dispatch];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n这里可以看出：\n\n 1. usestate 在 mount 阶段将初始状态记录在 hook.basestate 上，并且生成了一个状态更新的对象，这个更新对象上挂载了 dispatch：当前的 setstate 方法、lastrenderedstate：上次渲染的 state，lastrenderedreducer：上次 reduce 所使用的 reducer 。\n 2. 每个 setstate 回调实质上就是一个 dispatchaction，这个 dispatchaction 依赖于 currentlyrenderingfiber：当前渲染的 fiber、queue：状态更新对象。\n 3. queue 是隶属于 hook 的，是 hook 的一个属性，下文中 dispatchaction 的调用也是通过 map (queue, linkedlist) 的结构来管理 hook 所产生的更新的。\n\n\n# dispatchaction\n\n如果这时我们调用了 setstate 去更新状态，会发生什么呢？那我们就来看看 dispatchaction 这个函数：\n\nfunction dispatchaction < s, a > (\n        fiber: fiber, // 当前渲染的 fiber\n        queue: updatequeue < s, a > , // 状态更新对象\n        action: a,\n    ) {\n        // 避免渲染死循环，最多可连续渲染 25 次\n        invariant(\n            numberofrerenders < re_render_limit,\n            'too many re-renders. react limits the number of renders to prevent ' +\n            'an infinite loop.',\n        );\n\n        const alternate = fiber.alternate;\n        if (\n            fiber === currentlyrenderingfiber ||\n            (alternate !== null && alternate === currentlyrenderingfiber)\n        ) { // 是否是当前需要渲染的 fiber，进入渲染阶段， currentlyrenderingfiber 表示当前需要渲染的 fiber\n            // this is a render phase update. stash it in a lazily-created map of\n            // queue -> linked list of updates. after this render pass, we'll restart\n            // and apply the stashed updates on top of the work-in-progress hook.\n            // 所有的 updates 会保存在一个 map 中，结构是： queue -> linked list\n            // 进入渲染状态的标志\n            didschedulerenderphaseupdate = true;\n            // 创建一个更新句柄\n            const update: update < s, a > = {\n                expirationtime: renderexpirationtime, // 更新的到期时间\n                suspenseconfig: null,\n                action, // dispatchaction 的传值，这是 updatestate 消费更新的原材料\n                eagerreducer: null,\n                eagerstate: null,\n                next: null,\n            };\n            if (__dev__) {\n                // 从调度器获取当前更新的优先级\n                update.priority = getcurrentprioritylevel();\n                // renderphaseupdates 是存放 update queue 的一个队列（map），如果队列为空，则初始化队列\n                if (renderphaseupdates === null) {\n                    renderphaseupdates = new map();\n                }\n                // 取出当前 hook 中的 update 队列的首项\n                const firstrenderphaseupdate = renderphaseupdates.get(queue);\n                // 如果当前不存在以 queue 对象为键的 update，则将创建的 update 放入队列\n                if (firstrenderphaseupdate === undefined) {\n                    renderphaseupdates.set(queue, update);\n                } else {\n                    // 如果当前 hook 已经有 update 了，将 update 移动到当前 linkedlink 的尾部\n                    // append the update to the end of the list.\n                    let lastrenderphaseupdate = firstrenderphaseupdate;\n                    while (lastrenderphaseupdate.next !== null) {\n                        lastrenderphaseupdate = lastrenderphaseupdate.next;\n                    }\n                    lastrenderphaseupdate.next = update;\n                }\n            } else {\n                // prod 环境 \n                const currenttime = requestcurrenttime();\n                const suspenseconfig = requestcurrentsuspenseconfig();\n                // 计算当前组件 fiber 的到期时间\n                const expirationtime = computeexpirationforfiber(\n                    currenttime,\n                    fiber,\n                    suspenseconfig,\n                );\n                // 创建 update 对象\n                const update: update < s, a > = {\n                    expirationtime, //  fiber 的过期时间\n                    suspenseconfig, \n                    action, // dispatchaction 的传值\n                    eagerreducer: null, // 提前计算所使用的 reducer，即 queue.lastrenderedreducer\n                    eagerstate: null, // 提前计算的 state 缓存\n                    next: null,\n                };\n\n                if (__dev__) {\n                    update.priority = getcurrentprioritylevel();\n                }\n                // update 的数据结构，环状单向链表\n                // append the update to the end of the list.\n                // 将更新挂载到链表尾部\n                const last = queue.last;\n                if (last === null) {\n                    // 如果这是一个空队列，即 update 就是当前 hook 的首次更新，那就将 update 构成环形单向链表。\n                    // 这是因为我们判断这个链表是环形链表。\n                    // 注意：这里并不是说 mount 阶段，因为 mount 阶段只是初始化了 queue。\n                    // this is the first update. create a circular list.\n                    update.next = update;\n                } else {\n                    // 非首次渲染\n                    // 如果队列非空，队尾的 next 即为 first\n                    const first = last.next;\n                    // 下面代码一般都会执行，因为已经初始化为环形链表了\n                    if (first !== null) {\n                        // 如果队尾是有指向的，也就是已经形成了环形单向链表，那就直接把 update 放到队尾。\n                        // 即 update 的 next 指向 first。\n                        // still circular.\n                        update.next = first;\n                    }\n                    // 如果已经成环，就仍然是环形；如果没有成环，则 update 在队尾\n                    last.next = update;\n                }\n                // 更新队尾指针，队尾指针总是指向最新的 update\n                queue.last = update;\n                \n                // 一般来说，来到这里的 fiber 的 expirationtime 不会是即时的，如果出现了这种情况，比如即时任务，就可以提前计算新的 state。\n                // 可以看到，在下面的代码中如果 state 没变是直接 return 的，也就是跳过了调度器的 schedulework 的调度，减少了更新损耗。\n                // 如果新的 state 与 原来的 state 不等，则仍然需要调度器进行调度，但是计算的结果已经缓存在 update 中了。\n                // 这里的更新属于同步的更新，是通过 const eagerstate = lastrenderedreducer(currentstate, action) 来计算的。\n                if ( \n                    fiber.expirationtime === nowork &&\n                    (alternate === null || alternate.expirationtime === nowork)\n                ) {\n                    // the queue is currently empty, which means we can eagerly compute the\n                    // next state before entering the render phase. if the new state is the\n                    // same as the current state, we may be able to bail out entirely.\n                    const lastrenderedreducer = queue.lastrenderedreducer;\n                    if (lastrenderedreducer !== null) {\n                        let prevdispatcher;\n                        try {\n                            const currentstate: s = (queue.lastrenderedstate: any);\n                            const eagerstate = lastrenderedreducer(currentstate, action);\n                            // stash the eagerly computed state, and the reducer used to compute\n                            // it, on the update object. if the reducer hasn't changed by the\n                            // time we enter the render phase, then the eager state can be used\n                            // without calling the reducer again.\n                            update.eagerreducer = lastrenderedreducer;\n                            update.eagerstate = eagerstate;\n                            if (is(eagerstate, currentstate)) {\n                                // fast path. we can bail out without scheduling react to re-render.\n                                // it's still possible that we'll need to rebase this update later,\n                                // if the component re-renders for a different reason and by that\n                                // time the reducer has changed.\n                                return;\n                            }\n                        } catch (error) {\n                            // suppress the error. it will throw again in the render phase.\n                        } finally {\n                            if (__dev__) {\n                                reactcurrentdispatcher.current = prevdispatcher;\n                            }\n                        }\n                    }\n                }\n\n                // 调度 fiber 上的更新\n                schedulework(fiber, expirationtime);\n            }\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n\n\n核心理解\n\n * hook 所产生的 update 是在 dispatchaction 中产生的， 也就是说整个函数一定运行在 render 阶段。\n * hook 上发生的更新在 dev 和 prod 不一样，在 dev 上是通过更新队列 renderphaseupdates map (queue, 单向 linkedlist) 来维护的，而在 prod 环境是通过 renderphaseupdates map (queue, 环形 linkedlist) 来维护的。\n * 每个 hook 维护了一个 queue 用来记录改 hook 所引发的更新。queue 的 last 指向最新的 update。queue 作为 renderphaseupdates 的键，挂在了 update 所组成的环形链表。\n * update 被初始化为环形链表，之后所产生的的 update 都被插入到环形链表的尾部。\n\n下面重点看一下 dispatchaction 中的数据结构。\n\n * dispatchaction 数据结构是 map<queue, linked list>，其中 update 构成单向环形链表。\n * schedulework (fiber, expirationtime) 会调度 fiber 的更新。\n * react update 数据结构图如下图。\n\n注意\n\n这张图以首次 update 和原来形成环状两个部分为主，原来没有形成环状基本不会出现。\n\nupdate 对象是如何处理的？\n\nupdate 对象是根据 queue.last 指针来确定的，也就是说可以通过 last 指针找到最新的 update 。那么 dispatchaction 这个函数的主要作用就是：\n\n * 将 hook 运行所产生的的 update 添加到链表中，便于 schedulework 以及之后的程序 (调度器) 去调度使用。\n * 同时对于挂载阶段的首次 update 也做了特殊的处理，在进入渲染之前如果是同步任务就提前计算下一个 state，即 eagerstate。减少调度损耗。\n * schedulework 正是任务调度中的起始部分。\n\n下面来看几个问题？\n\n 1. 为什么使用单向环形链表和管理更新？\n\n * 单向环形链表相比于单向链表具有一个很大的优势就是可以从任意一个节点来遍历整个链表，对链表的头部和尾部没有那么重视。所有在单向环形链表中搜索的效率可以很大的提高。\n * react 的更新依赖于优先级，每一个 update 优先级不同，要保证高优先级的 update 优先执行，搜索效率尤为重要。\n * 环状链表可以方便定位到任何一次高优先级的更新位置去执行，而暂时摒弃低优先级的更新，提高更新的效率。\n\n参考文档：\n\n * 数据结构系列 - 2 - 循环链表\n\n\n# updatestate\n\n在 render 阶段，hooksdispatcheronupdate 这个 dispatcher 所调用的是 updatestate 这个函数。\n\n下面我们就来看看这个函数：\n\nfunction updatestate<s>(\n  initialstate: (() => s) | s,\n): [s, dispatch<basicstateaction<s>>] {\n  return updatereducer(basicstatereducer, (initialstate: any));\n}\n\n\n1\n2\n3\n4\n5\n\n\n这里可以看到：\n\n * updatestate 是依赖于 updatereducer 来处理状态变化的，后面我们会看到 usereducer 在 update 阶段所使用的正是 updatereducer。\n * updatereducer 接受初始状态 reducer 和 initialstate，返回一个 state 和一个 dispatch 函数，这符合我们对 usereducer 的认知。可见 usereducer 是 usestate 状态管理的基础。\n * usestate 使用的 reducer 是 basicstatereducer。\n\n# 什么是 reducer 和 basicstatereducer？\n\nfunction reducer(state, action): state {}\n\n\n1\n\n\nreducer 就是一个状态转换机，接受一个 state 和 用于转换 state 的 action，返回一个新的 state。\n\nfunction basicstatereducer<s>(state: s, action: basicstateaction<s>): s {\n  return typeof action === 'function' ? action(state) : action;\n}\n\n\n1\n2\n3\n\n\nbasicstatereducer 就是说：如果 action 是一个状态转换器（即是函数），就将原状态交由转换器进行转换，返回新的状态，否则就像 action 视为一个返回新状态。看到这里，和 usestate 中 dispatch 的用法就契合上了，usestate 使用了 basicstatereducer。\n\n下面来看一下 updatereducer 是如何处理的，解决了这个问题，我们可以同时弄清楚 usereducer 的原理了。\n\n\n# updatereducer\n\n请看 updatereducer 函数的源码：\n\nfunction updatereducer<s, i, a>(\n  reducer: (s, a) => s,\n  initialarg: i,\n  init?: i => s,\n): [s, dispatch<a>] {\n  // 当前正在调度的 hook\n  const hook = updateworkinprogresshook();\n  // queue 就是上文中分析的 hook 更新的数据结构，queue 非空，即 queue 中的 update 一定不会为空。\n  // 因为在usestate mount 阶段会初始化一个 update，并且 last 指针指向他。\n  const queue = hook.queue;\n  invariant(\n    queue !== null,\n    'should have a queue. this is likely a bug in react. please file an issue.',\n  );\n\n  // 最近用于渲染的 reducer 记录在 queue 上\n  queue.lastrenderedreducer = reducer;\n  // 如果 hook 已经 render 过\n  if (numberofrerenders > 0) {\n    // this is a re-render. apply the new render phase updates to the previous\n    // work-in-progress hook.\n    // 这里的 dispatch 是在上一次 setstate 是挂载到 queue 上的，如果是 mount 阶段，\n    // 也会返回一个 dispatch，可参照 mount 阶段\n    const dispatch: dispatch<a> = (queue.dispatch: any);\n    // renderphaseupdates 中记录了更新队列，结构是  map<updatequeue,update linked list>\n    // 更新队列非空\n    if (renderphaseupdates !== null) {\n      // render phase updates are stored in a map of queue -> linked list\n      // 获取当前 hook 的第一个更新\n      const firstrenderphaseupdate = renderphaseupdates.get(queue);\n      // 如果没有需要更新的，则不必走下面的 reduce 过程\n      // firstrenderphaseupdate 正在更新链表的头指针\n      if (firstrenderphaseupdate !== undefined) {\n        // 经过下面 reduce 的过程，当前 queue 下所有的更新应该都被处理，\n        // 所以这里可以提前将 queue 删掉，因为 queue 下面的 update 链表已经保存在 firstrenderphaseupdate指针\n        // 这里实际上是并没有断开 queue 和 firstrenderphaseupdate 的指向关系，只是在 firstrenderphaseupdate map 中将 queue 移除，\n        // 由于 queue 还有引用，不不会被垃圾回收。\n        renderphaseupdates.delete(queue);\n        // state reduce 过程以 memoizedstate 为初始状态\n        let newstate = hook.memoizedstate;\n        let update = firstrenderphaseupdate;\n        // 这个循环说明在usestate的状态更新过程中，会将 update 组成一个一个的 queue，每个 queue 中的\n        // 所有的 update 都是一起更新的（batch update），也就是一个更新链。这样可以避免产生过多的无意义的 re-render，\n        // 提高更新的效率。\n        // 这里链表的执行是从链尾到链首依次reduce的。\n        do {\n          // process this render phase update. we don't have to check the\n          // priority because it will always be the same as the current\n          // render's.\n          // 这里不用关注优先级，因为这属于同一次渲染。\n          // 每个 update 上都有一个 action ,具体可见上文 update 的结构\n          // setstate 的 action 是一个 basicstateaction\n          const action = update.action;\n          // reducer 将当前状态转换为新状态\n          newstate = reducer(newstate, action);\n          // 指针移到下一个 update\n          update = update.next;\n        } while (update !== null);\n\n        // mark that the fiber performed work, but only if the new state is\n        // different from the current state.\n        // 如果最新状态 newstate 和原状态 memoizedstate 不一致，则 didreceiveupdate 为 true\n        // 表示在 fiber 应该执行更新\n        if (!is(newstate, hook.memoizedstate)) {\n          markworkinprogressreceivedupdate();\n        }\n        // 更新 memoizedstate，方便下次 render\n        hook.memoizedstate = newstate;\n        // don't persist the state accumulated from the render phase updates to\n        // the base state unless the queue is empty.\n        // todo: not sure if this is the desired semantics, but it's what we\n        // do for gdsfp. i can't remember why.\n        // 除非队列为空，否则不要将渲染阶段更新累积的状态持久化到基本状态。\n        if (hook.baseupdate === queue.last) {\n          hook.basestate = newstate;\n        }\n        // lastrenderedstate 记录上一次的 state，此次 render 后，将上次渲染状态更新为 newstate\n        queue.lastrenderedstate = newstate;\n        // 经过 render 之后返回新状态 newstate 和 dispatch 函数。dispatch 实际上是从 queue 上取的，实际上是 dispatchaction 函数。\n        return [newstate, dispatch];\n      }\n    }\n    // 没有经过 render，只需返回原状态 memoizedstate。\n    return [hook.memoizedstate, dispatch];\n  }\n  \n  // hook 首次 render,之所以要区分开，是因为首次 render 需要做一些初始化工作\n  // the last update in the entire queue\n  const last = queue.last;\n  // the last update that is part of the base state.\n  const baseupdate = hook.baseupdate;\n  const basestate = hook.basestate;\n\n  // find the first unprocessed update.找到第一个未处理的更新\n  let first;\n  // baseupdate 为上次的更新\n  if (baseupdate !== null) {\n    if (last !== null) {\n      // for the first update, the queue is a circular linked list where\n      // `queue.last.next = queue.first`. once the first update commits, and\n      // the `baseupdate` is no longer empty, we can unravel the list.\n      // 这是首次 update，queue.last.next = queue.first, 如果是首次渲染，只有一个 update，如果这个 update 被 commit，\n      // 就可以将链表解开\n      last.next = null;\n    }\n    // 正常情况下直接取 baseupdate.next\n    first = baseupdate.next;\n  } else {\n    // 没有上次更新，取 last.next\n    first = last !== null ? last.next : null;\n  }\n  if (first !== null) {\n    // reduce 的初始状态\n    let newstate = basestate;\n    let newbasestate = null;\n    let newbaseupdate = null;\n    let prevupdate = baseupdate;\n    let update = first;\n    let didskip = false;\n    // 循环 reduce 状态，获取最新状态\n    do {\n      const updateexpirationtime = update.expirationtime;\n      // 该 update 太新，未超过 renderexpirationtime，优先级较低, expirationtime 是负数\n      // renderexpirationtime = 0\n      if (updateexpirationtime < renderexpirationtime) {\n        // priority is insufficient. skip this update. if this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        // 对于优先级较低的 update,会先跳过。如果首次跳过，就应该对 newbaseupdate、 newbasestate\n        // 赋原值，否则不改变值即可\n        if (!didskip) {\n          didskip = true;\n          newbaseupdate = prevupdate;\n          newbasestate = newstate;\n        }\n        // remainingexpirationtime 表示当前队列中不用立即渲染的低优先级的 update 中距离 renderexpirationtime\n        // 最近的超时时间，这个时间越大，在下次渲染中该队列的优先级越大，每次终端都会更新这个值\n        // update the remaining priority in the queue.\n        if (updateexpirationtime > remainingexpirationtime) {\n          remainingexpirationtime = updateexpirationtime;\n          markunprocessedupdatetime(remainingexpirationtime);\n        }\n      // 优先级达到标准的 update 会进行渲染\n      } else {\n        // this update does have sufficient priority.\n\n        // mark the event time of this update as relevant to this render pass.\n        // todo: this should ideally use the true event time of this update rather than\n        // its priority which is a derived and not reverseable value.\n        // todo: we should skip this update if it was already committed but currently\n        // we have no way of detecting the difference between a committed and suspended\n        // update here.\n        markrendereventtimeandconfig(\n          updateexpirationtime,\n          update.suspenseconfig,\n        );\n\n        // process this update.\n        // eagerreducer 和 当前的 reducer 表示进行了提前计算\n        if (update.eagerreducer === reducer) {\n          // if this update was processed eagerly, and its reducer matches the\n          // current reducer, we can use the eagerly computed state.\n          // 如果有提前计算的 reducer, 并且和当前的 reducer 一样，可以使用提前计算的结果\n          newstate = ((update.eagerstate: any): s);\n        } else {\n          // reduce 新的状态\n          const action = update.action;\n          newstate = reducer(newstate, action);\n        }\n      }\n      // 保存原来的状态\n      prevupdate = update;\n      // 移向下一个 update\n      update = update.next;\n      // first 已经执行过，移动到链尾\n    } while (update !== null && update !== first);\n\n    // 如果有首次跳过中断的 update，newbaseupdate 记录中断前的 update，否则记录最新的 update\n    if (!didskip) {\n      newbaseupdate = prevupdate;\n      newbasestate = newstate;\n    }\n\n    // mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n    // 标记前后状态是否确实有更新，didreceiveupdate 标记为 true 时，才会真正去更新 fiber\n    if (!is(newstate, hook.memoizedstate)) {\n      markworkinprogressreceivedupdate();\n    }\n\n    hook.memoizedstate = newstate;\n    hook.baseupdate = newbaseupdate;\n    hook.basestate = newbasestate;\n\n    queue.lastrenderedstate = newstate;\n  }\n\n  const dispatch: dispatch<a> = (queue.dispatch: any);\n  return [hook.memoizedstate, dispatch];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n\n\n上面这个函数的信息量很大，总结如下。\n\n * updatereducer 主要的作用就是：处理 updates 链表，更新 state 的状态。\n * queue 是 hook 上的管理更新的数据结构。queue 中包含了的数据如下。\n\n参数                    描述\nlastrenderedreducer   用于 reduce 状态的 reducer\ndispatch              暴露给用户的修改状态的 dispatchaction\nlast                  指向 update queue 中首个 update 的指针\nlastrenderedstate     上一次渲染的状态\n\n * dispatch 和 reducer 的区别：\n\nfunction dispatch(state || () => state): void // 本质上就是一个 action\nfunction reducer(state, action): state // 本质上是一个状态转换器\n\n\n1\n2\n\n\n * numberofrerenders 会随着 renderwithhooks 的调用增加，记录的是 renderwithhooks 的调用次数，也就是 re-render 的次数。renderwithhooks 主要在 react-reconciler 包中 reactfiberbeginwork.js 中使用，这个函数是渲染 fc 组件的，返回组件的渲染节点。 numberofrerenders 只有增加、重置两种操作。在 finishhooks 和 resethooks 函数中会将 numberofrerenders 重置为 0；这说明在 hook finish 之前，renderwithhooks 可能会调用多次。\n\n * renderexpirationtime 是一个常量 nowork = 0 ，因此 updateexpirationtime 应该是负数，当这个到期时间达到 0 时，才具有渲染的与优先级，否则会被跳过，并更新 remainingexpirationtime（remainingexpirationtime 是逐渐变大的）。\n\n * updatereducer 结构图：\n\n核心理解\n\n * 在一个 hook 执行期间，首次更新渲染（不是 mount 时的渲染）和多次更新渲染所使用的 updatestate 的逻辑是不一样的。首次更新渲染需要过滤掉优先级较低的 update ，多次更新渲染则直接对所有 update 进行 reduce（reduce 就是计算 newstate 的过程）。\n * resethooks 方法 会在 performsyncworkonroot/performconcurrentworkonroot → handleerror 中调用。这说明在 react 执行期间，如果不出意外的话就一直属于 hook 运行的生命周期。\n * batched updates\n\n这里的核心逻辑就是对 hook 中的 queue 下的更新进行合并更新。合并更新是在一次发生的，也就是说 react 对用户的 dispatchaction 并非一次一次的更新，而是在 dispatchaction 和真正的 reduce updates 这中间做了一个合流，在 reduce update 之后产生新的状态到真正的渲染，也就是 renderwithhooks 这中间又间隔着调度器的调度，相当于又一次的合流。这样的两次合流，就是的从 dispatchaction 到 render 之间的损耗大大减小，渲染的效率有了很大的提高。就像千万溪流汇聚成大海，这样的渲染就节省了很多的中间状态的开支。\n\ndo {\n  newstate = reducer(newstate, action);\n  update = update.next;\n} while (update !== null);\n\n\n1\n2\n3\n4\n\n\n\n# 一些问题\n\n看到这里还有一些细节问题：\n\n\n# usestate 是同步引起 ui 更新吗？\n\n在这个部分里，只是对 newstate 做了计算，最终 newstate 被挂载在了 hook.memoizedstate 上（也就是说更新了 hook.memoizedstate 的值），在需要 rerender 时将 didreceiveupdate 标记为了 true。真正的 ui 的更新，还得跟 render 部分和调度器有关。didreceiveupdate 主要在 react-reconciler 包中 reactfiberbeginwork.js 中被使用。usestate 只是对 didreceiveupdate 做了标记，ui 更新会在 setstate 之后 dispatchaction 中 schedulework 的调用后由调度器进行调度更新。\n\n\n# renderphaseupdates 管理更新\n\n下面仅展示 renderphaseupdates 相关的的内容。 renderphaseupdates 数据结构如下：\n\nlet renderphaseupdates: map<\n  updatequeue<any, any>,\n  update<any, any>,\n> | null = null;\n\n\n1\n2\n3\n4\n\n\ndispatchaction 中：\n\nif (renderphaseupdates === null) {\n  renderphaseupdates = new map();\n}\nconst firstrenderphaseupdate = renderphaseupdates.get(queue);\nif (firstrenderphaseupdate === undefined) {\n  renderphaseupdates.set(queue, update);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nupdatereducer 中：\n\nif (renderphaseupdates !== null) {\n  const firstrenderphaseupdate = renderphaseupdates.get(queue);\n  if (firstrenderphaseupdate !== undefined) {\n    renderphaseupdates.delete(queue);\n    ...\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * renderphaseupdates 本质是一个 map，在 dispatchaction 中初始化，并且将 setstate 所产生的更新装进 map，每个 usestate 对应 map 中的一个 queue，queue 中是一个环状链表，last 指向首个 update。\n * 在 resethooks 中被重置为 null，在 updatereducer 中 queue 被消费。\n\n\n# 为什么 setstate 是状态的替换，而不是状态的补充？\n\n我们知道 setstate 实质上创建 queue 上的更新并将 queue 上的 update 链表的结构更新了，并且通知了 schedulework 调度 fiber 上的更新。因此在更新中 updatereducer 生成了 newstate，这里的 newstate 作为新的页面状态重新渲染了页面。updatereducer 中更新 newstate 靠的就是 reducer，在 usestate 中使用的 reducer 就是 basicstatereducer 。basicstatereducer 是将 setstate 中的状态直接替换了原来的状态。因此，setstate 实际上是状态的替换。如果想要状态的补充，可以在 setstate 中将原来的状态进行 merge 之后再替换，这不修改 setstate 的本质特点，但是相比之下会更加灵活。\n\nbasicstatereducer：\n\nfunction basicstatereducer<s>(state: s, action: basicstateaction<s>): s {\n  return typeof action === 'function' ? action(state) : action;\n}\n\n\n1\n2\n3\n\n\nusemergedstate：\n\nexport function usemergedstate<t>(initialstate: t) {\n  const [state, setstate] = usestate<t>(initialstate);\n  let mergestate: any = setstate;\n  if (typeof state === 'object') {\n    mergestate = (value: t) => {\n      if (value && typeof value === 'object') {\n        setstate({\n          ...state,\n          ...value,\n        });\n      } else {\n        setstate(value);\n      }\n    };\n  }\n  return [state, setstate, mergestate];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 为什么 batch update 时，链表上会有多个 update?\n\n * 链表上的 update 是由 dispatchaction 生成的，dispatchaction 生产 update 是同步执行的，也就是说，在很短的情况下 queue 上会几句大量的 update。\n * update 在被 dispatchaction 管理时并不会立即被 reduce，因为 update 依赖于调度器在 fiber 上进行优先级调度的，可以看做一个异步的过程。\n * 在某个 fiber 上所产生的任务被调度器释放触发更新循环时，可能在 queue 上已经积累了大量的 update 了。注意调度器的调度并不是以 update 为单位的，而是以 fiber 为单位的。这是因为 update 是在太多了，会引起调度的效率低下。\n\n\n# 本篇小结\n\n通过这边文章从 dispatcher 分发器、mountstate、dispatchaction、updatestate 等代码的分析，总结如下：\n\n 1. 重要函数的作用\n\n * dispatcher：管理当前环境下应该调用的 hook。\n * mountstate：初始化 hook 和 queue。mount 阶段不生产和消费 update。\n * dispatchaction：生产 update；管理和维护 update，将 update 的调度移交给调度器。\n * updatestate（updatereducer）：消费 update，更新 fiber 上的 state。\n\n 2. 原理梗概：\n\n * 各种 hook api 都是由 dispatcher 管理的，不同的渲染阶段会使用不同的 dispatcher，当然 dev 环境也会有 dev 环境的 dispatcher。\n * mount 阶段调用 mountstate 初始化 state 并生成 queue， 在 dispatchaction 中加入 renderphaseupdates，并且直接由 dispatchaction 管理。\n * render 阶段调用 updatestate 利用 reducer 更新 state 和 dispatch，这里并没有直接引起渲染。\n * 在 setstate 被使用时就调用了 dispatchaction 调度渲染。dispatchaction 创建更新对象，更新 update 环形链表的结构，并且调用了 schedulework 去调度更新 fiber。\n\n\n# 参考资料\n\n * 官方文档\n * react hooks 核心实现",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"useEffect",frontmatter:{title:"useEffect",date:"2022-04-14T22:02:21.000Z",permalink:"/react/hooks/useEffect/",categories:["react","hooks"],tags:[null]},regularPath:"/10.react/70.hooks%E5%8E%9F%E7%90%86/20.useEffect.html",relativePath:"10.react/70.hooks原理/20.useEffect.md",key:"v-228419df",path:"/react/hooks/useEffect/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"定义",slug:"定义",normalizedTitle:"定义",charIndex:17},{level:2,title:"mount 阶段的 useEffect",slug:"mount-阶段的-useeffect",normalizedTitle:"mount 阶段的 useeffect",charIndex:23},{level:2,title:"update 阶段的 useEffect",slug:"update-阶段的-useeffect",normalizedTitle:"update 阶段的 useeffect",charIndex:46},{level:3,title:"effect deps 是如何比较的？",slug:"effect-deps-是如何比较的",normalizedTitle:"effect deps 是如何比较的？",charIndex:72},{level:2,title:"useEffect 如何避免在 mount 时执行？",slug:"useeffect-如何避免在-mount-时执行",normalizedTitle:"useeffect 如何避免在 mount 时执行？",charIndex:95},{level:2,title:"useEffect 调度执行",slug:"useeffect-调度执行",normalizedTitle:"useeffect 调度执行",charIndex:125},{level:2,title:"useEffect 怎么模拟类组件 lifecycle Api?",slug:"useeffect-怎么模拟类组件-lifecycle-api",normalizedTitle:"useeffect 怎么模拟类组件 lifecycle api?",charIndex:143},{level:2,title:"参看链接",slug:"参看链接",normalizedTitle:"参看链接",charIndex:179}],readingTime:{text:"3 min read",minutes:2.61,time:156600,words:522},headersStr:"目录 定义 mount 阶段的 useEffect update 阶段的 useEffect effect deps 是如何比较的？ useEffect 如何避免在 mount 时执行？ useEffect 调度执行 useEffect 怎么模拟类组件 lifecycle Api? 参看链接",content:"# 目录\n\n\n\n * 目录\n * 定义\n * mount 阶段的 useEffect\n * update 阶段的 useEffect\n   * effect deps 是如何比较的？\n * useEffect 如何避免在 mount 时执行？\n * useEffect 调度执行\n * useEffect 怎么模拟类组件 lifecycle Api?\n * 参看链接\n\n\n\n> useEffect 在 hooks 中通常被充当生命周期使用，相比于类组件的 lifecycle Api，useEffect 的使用更加简洁精巧。其主要作用是对响应式的依赖项产生副作用。 在 useEffect 中通常是执行副作用的操作，包括数据更新、网络请求、数据存储等操作。\n\n\n# 定义\n\n在 react 包 ReactHooks.js 文件中，有 useEffect 的定义。\n\nexport function useEffect(\n  create: () => (() => void) | void,\n  inputs: Array<mixed> | void | null,\n) {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, inputs);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由这个可知：\n\n * useEffect 同样是由 dispatcher 来管理的。\n * create 是一个函数，这个函数可以返回一个函数，返回的这个函数是一个 cleaner。\n * inputs 是依赖列表数组，依赖项必须是响应式的变量，如 props、state 或者依赖于二者的计算量。\n\n\n# mount 阶段的 useEffect\n\nuseEffect 在 HooksDispatcherOnMount 中引用的是 mountEffect 函数，内部调用 mountEffectImpl 函数。\n\nfunction mountEffectImpl(fiberEffectTag, hookEffectTag, create, deps): void {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  sideEffectTag |= fiberEffectTag;\n  // pushEffect 返回当前生成的 effect，这个 effect 被挂载到 hook.memoizedState 上。\n  hook.memoizedState = pushEffect(hookEffectTag, create, undefined, nextDeps);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\npushEffect 函数将更新 effect 队列，将新的 effect 加入到队首。\n\nfunction pushEffect(tag, create, destroy, deps) {\n  // 创建一个 effect 对象，由于是 mount 阶段 next为 null.\n  const effect: Effect = {\n    tag,\n    create,\n    destroy,\n    deps,\n    // Circular\n    next: (null: any),\n  };\n  if (componentUpdateQueue === null) {\n    // 如果更新队列为空，则创建更新队列，这个队列里只记载了 lastEffect。\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    // 记录当前的 effect\n    componentUpdateQueue.lastEffect = effect.next = effect;\n  } else {\n    const lastEffect = componentUpdateQueue.lastEffect;\n    if (lastEffect === null) {\n      componentUpdateQueue.lastEffect = effect.next = effect;\n    } else {\n      // 将 firstEffect 指向 effect，effect 指向 firstEffect。即时将 effect 放到更新队列的队首。\n      const firstEffect = lastEffect.next;\n      lastEffect.next = effect;\n      effect.next = firstEffect;\n      componentUpdateQueue.lastEffect = effect;\n    }\n  }\n  return effect;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n由这个函数可知：\n\n * effect 对象是由 componentUpdateQueue 来管理的，其内部是一个链表。lastEffect 指向链首，链首永远指向新加入的 effect。\n * Effect 的管理和调度执行是分离的，因为 effect 都需要在一定的渲染时机才能触发。\n * pushEffect 执行就会产生一个 effect，在 mount 阶段 pushEffect 必回执行一次，这说明 useEffect 在 mount 时一定会触发一次更新。\n\n\n# update 阶段的 useEffect\n\nupdate 阶段 useEffect 引用的是 updateEffect 函数，内部有 updateEffectImpl 实现。我们来看看这个函数：\n\nfunction updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps): void {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  let destroy = undefined;\n\n  if (currentHook !== null) {\n    // 取出上一次的 effect\n    const prevEffect = currentHook.memoizedState;\n    destroy = prevEffect.destroy;\n    // 这里如果 prevDeps 不为空，则 nextDeps 一定不为空，因此如果为空，就不用产生 Effect 了。\n    if (nextDeps !== null) {\n      const prevDeps = prevEffect.deps;\n      // 比较 effect 是否发生了变化，只有 effect 变化，才生成 Effect，否则 tag 为 NoHookEffect\n      //  tag 标记为 NoHookEffect 的 effect 不会被执行\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        pushEffect(NoHookEffect, create, destroy, nextDeps);\n        return;\n      }\n    }\n  }\n  // 依赖项发生了变化时，生成 effect\n  sideEffectTag |= fiberEffectTag;\n  hook.memoizedState = pushEffect(hookEffectTag, create, destroy, nextDeps);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# effect deps 是如何比较的？\n\nareHookInputsEqual 函数比较依赖项是否发生了改变，这里我们来看下他的实现：\n\nfunction areHookInputsEqual(\n  nextDeps: Array<mixed>,\n  prevDeps: Array<mixed> | null,\n) {\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (is(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\nfunction is(x: any, y: any) {\n  // 考虑两者都是 null 的情况\n  return (\n    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n可以看到：\n\n * areHookInputsEqual 比较依赖项只是浅比较，并没有做深比较。\n * 对于 Object 依赖而言，由于 useEffect 的依赖项通常是 state，而 useState 内部是替换旧状态的机制，这时也能够触发 effect。但是使用依赖项时要格外注意此类问题。\n\n\n# useEffect 如何避免在 mount 时执行？\n\n我们传入的 useEffect 的函数是会被当做 effect 来触发的，因此想要避免 effect 在某些时机的执行，我们可以如官网的推荐使用条件 effect，就是在执行 effect 加入一些条件，来避免一些不需要的执行。 想要避免 useEffect 在 mount 时执行，我们也可以使用这种方式做到。\n\nconst didMount = useRef<boolean>(false);\n\nuseEffect(() => didMount.current = true, []);\n\nuseEffect(() => {\n  if(didMount.current) {\n    // Only run after mounted.\n  }\n}, [deps]);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# useEffect 调度执行\n\n看到这里，effect 的创建和管理是清晰了。但是在什么时机会调度执行 effect 呢？我们知道，effect 会在 mount 和 update 时执行。\n\n\n# useEffect 怎么模拟类组件 lifecycle Api?\n\n\n# 参看链接\n\n * 官方文档",normalizedContent:"# 目录\n\n\n\n * 目录\n * 定义\n * mount 阶段的 useeffect\n * update 阶段的 useeffect\n   * effect deps 是如何比较的？\n * useeffect 如何避免在 mount 时执行？\n * useeffect 调度执行\n * useeffect 怎么模拟类组件 lifecycle api?\n * 参看链接\n\n\n\n> useeffect 在 hooks 中通常被充当生命周期使用，相比于类组件的 lifecycle api，useeffect 的使用更加简洁精巧。其主要作用是对响应式的依赖项产生副作用。 在 useeffect 中通常是执行副作用的操作，包括数据更新、网络请求、数据存储等操作。\n\n\n# 定义\n\n在 react 包 reacthooks.js 文件中，有 useeffect 的定义。\n\nexport function useeffect(\n  create: () => (() => void) | void,\n  inputs: array<mixed> | void | null,\n) {\n  const dispatcher = resolvedispatcher();\n  return dispatcher.useeffect(create, inputs);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由这个可知：\n\n * useeffect 同样是由 dispatcher 来管理的。\n * create 是一个函数，这个函数可以返回一个函数，返回的这个函数是一个 cleaner。\n * inputs 是依赖列表数组，依赖项必须是响应式的变量，如 props、state 或者依赖于二者的计算量。\n\n\n# mount 阶段的 useeffect\n\nuseeffect 在 hooksdispatcheronmount 中引用的是 mounteffect 函数，内部调用 mounteffectimpl 函数。\n\nfunction mounteffectimpl(fibereffecttag, hookeffecttag, create, deps): void {\n  const hook = mountworkinprogresshook();\n  const nextdeps = deps === undefined ? null : deps;\n  sideeffecttag |= fibereffecttag;\n  // pusheffect 返回当前生成的 effect，这个 effect 被挂载到 hook.memoizedstate 上。\n  hook.memoizedstate = pusheffect(hookeffecttag, create, undefined, nextdeps);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\npusheffect 函数将更新 effect 队列，将新的 effect 加入到队首。\n\nfunction pusheffect(tag, create, destroy, deps) {\n  // 创建一个 effect 对象，由于是 mount 阶段 next为 null.\n  const effect: effect = {\n    tag,\n    create,\n    destroy,\n    deps,\n    // circular\n    next: (null: any),\n  };\n  if (componentupdatequeue === null) {\n    // 如果更新队列为空，则创建更新队列，这个队列里只记载了 lasteffect。\n    componentupdatequeue = createfunctioncomponentupdatequeue();\n    // 记录当前的 effect\n    componentupdatequeue.lasteffect = effect.next = effect;\n  } else {\n    const lasteffect = componentupdatequeue.lasteffect;\n    if (lasteffect === null) {\n      componentupdatequeue.lasteffect = effect.next = effect;\n    } else {\n      // 将 firsteffect 指向 effect，effect 指向 firsteffect。即时将 effect 放到更新队列的队首。\n      const firsteffect = lasteffect.next;\n      lasteffect.next = effect;\n      effect.next = firsteffect;\n      componentupdatequeue.lasteffect = effect;\n    }\n  }\n  return effect;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n由这个函数可知：\n\n * effect 对象是由 componentupdatequeue 来管理的，其内部是一个链表。lasteffect 指向链首，链首永远指向新加入的 effect。\n * effect 的管理和调度执行是分离的，因为 effect 都需要在一定的渲染时机才能触发。\n * pusheffect 执行就会产生一个 effect，在 mount 阶段 pusheffect 必回执行一次，这说明 useeffect 在 mount 时一定会触发一次更新。\n\n\n# update 阶段的 useeffect\n\nupdate 阶段 useeffect 引用的是 updateeffect 函数，内部有 updateeffectimpl 实现。我们来看看这个函数：\n\nfunction updateeffectimpl(fibereffecttag, hookeffecttag, create, deps): void {\n  const hook = updateworkinprogresshook();\n  const nextdeps = deps === undefined ? null : deps;\n  let destroy = undefined;\n\n  if (currenthook !== null) {\n    // 取出上一次的 effect\n    const preveffect = currenthook.memoizedstate;\n    destroy = preveffect.destroy;\n    // 这里如果 prevdeps 不为空，则 nextdeps 一定不为空，因此如果为空，就不用产生 effect 了。\n    if (nextdeps !== null) {\n      const prevdeps = preveffect.deps;\n      // 比较 effect 是否发生了变化，只有 effect 变化，才生成 effect，否则 tag 为 nohookeffect\n      //  tag 标记为 nohookeffect 的 effect 不会被执行\n      if (arehookinputsequal(nextdeps, prevdeps)) {\n        pusheffect(nohookeffect, create, destroy, nextdeps);\n        return;\n      }\n    }\n  }\n  // 依赖项发生了变化时，生成 effect\n  sideeffecttag |= fibereffecttag;\n  hook.memoizedstate = pusheffect(hookeffecttag, create, destroy, nextdeps);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# effect deps 是如何比较的？\n\narehookinputsequal 函数比较依赖项是否发生了改变，这里我们来看下他的实现：\n\nfunction arehookinputsequal(\n  nextdeps: array<mixed>,\n  prevdeps: array<mixed> | null,\n) {\n  for (let i = 0; i < prevdeps.length && i < nextdeps.length; i++) {\n    if (is(nextdeps[i], prevdeps[i])) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\nfunction is(x: any, y: any) {\n  // 考虑两者都是 null 的情况\n  return (\n    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n可以看到：\n\n * arehookinputsequal 比较依赖项只是浅比较，并没有做深比较。\n * 对于 object 依赖而言，由于 useeffect 的依赖项通常是 state，而 usestate 内部是替换旧状态的机制，这时也能够触发 effect。但是使用依赖项时要格外注意此类问题。\n\n\n# useeffect 如何避免在 mount 时执行？\n\n我们传入的 useeffect 的函数是会被当做 effect 来触发的，因此想要避免 effect 在某些时机的执行，我们可以如官网的推荐使用条件 effect，就是在执行 effect 加入一些条件，来避免一些不需要的执行。 想要避免 useeffect 在 mount 时执行，我们也可以使用这种方式做到。\n\nconst didmount = useref<boolean>(false);\n\nuseeffect(() => didmount.current = true, []);\n\nuseeffect(() => {\n  if(didmount.current) {\n    // only run after mounted.\n  }\n}, [deps]);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# useeffect 调度执行\n\n看到这里，effect 的创建和管理是清晰了。但是在什么时机会调度执行 effect 呢？我们知道，effect 会在 mount 和 update 时执行。\n\n\n# useeffect 怎么模拟类组件 lifecycle api?\n\n\n# 参看链接\n\n * 官方文档",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"useRef 原理",frontmatter:{title:"useRef 原理",date:"2022-04-14T22:02:21.000Z",permalink:"/react/hooks/useRef/",categories:["react","hooks"],tags:[null]},regularPath:"/10.react/70.hooks%E5%8E%9F%E7%90%86/30.useRef.html",relativePath:"10.react/70.hooks原理/30.useRef.md",key:"v-2778a33b",path:"/react/hooks/useRef/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"useRef 定义",slug:"useref-定义",normalizedTitle:"useref 定义",charIndex:17},{level:2,title:"mountRef: useRef on mount phrase",slug:"mountref-useref-on-mount-phrase",normalizedTitle:"mountref: useref on mount phrase",charIndex:30},{level:2,title:"updateRef: useRef on update phrase",slug:"updateref-useref-on-update-phrase",normalizedTitle:"updateref: useref on update phrase",charIndex:66},{level:2,title:"Q&A",slug:"q-a",normalizedTitle:"q&amp;a",charIndex:null},{level:2,title:"参考文档",slug:"参考文档",normalizedTitle:"参考文档",charIndex:111}],readingTime:{text:"3 min read",minutes:2.16,time:129600.00000000003,words:432},headersStr:"目录 useRef 定义 mountRef: useRef on mount phrase updateRef: useRef on update phrase Q&A 参考文档",content:"# 目录\n\n\n\n * 目录\n * useRef 定义\n * mountRef: useRef on mount phrase\n * updateRef: useRef on update phrase\n * Q&A\n * 参考文档\n\n\n\n\n# useRef 定义\n\n首先我们来看一下 useRef 在 React 中的定义代码 (react package)：\n\nexport function useRef<T>(initialValue: T): {current: T} {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\n\n\n1\n2\n3\n4\n\n\n可以看出如下信息：\n\n * 接受初始值 initialValue，返回值携带在 current 上。\n * useRef 接受 dispatcher 的调度，在不同的环境可能有不同的实现。\n\n下面来看一下 useRef 在 dispatcher 上是如何实现的：\n\n在 HooksDispatcherOnMount 中 useRef 的实现为 mountRef，在 HooksDispatcherOnUpdate 中 useRef 实现为 updateRef。看来大多 hook 的实现模式与此类似。\n\n\n# mountRef: useRef on mount phrase\n\nmountRef 的实现很简单，基本上只是做初始化的工作。\n\nfunction mountRef<T>(initialValue: T): {current: T} {\n  // 获取当前正在执行的 hook\n  const hook = mountWorkInProgressHook();\n  const ref = {current: initialValue};\n  if (__DEV__) {\n    Object.seal(ref);\n  }\n  // 初始化 current 值到 hook\n  hook.memoizedState = ref;\n  return ref;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# updateRef: useRef on update phrase\n\n在更新阶段，只需将缓存的值取出即可，缓存的值存在 memoizedState 中。\n\nfunction updateRef<T>(initialValue: T): {current: T} {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n\n\n1\n2\n3\n4\n\n\n\n# Q&A\n\n看到这里，可能有以下几个问题：\n\n 1. 既然 useRef 只是在 render 过程中去缓存值，那么完全可以将之以变量的方式定义在组件前面，那个他存在的意义是什么？两者又有什么区别？\n\n首先，我们需要知道的是，useRef 其实是解决了 useState 闭包陷阱的问题。useState 一定能够更新值，但是有一种特例会使代码得不到 useState 更新后的值，那就是闭包环境，这种特例叫做闭包陷阱。\n\n这种现象的产生主要与 useState 更新 primitive value 有关，而更新 object 则不存在这种问题。主要原因是 object 是存在堆中的，变量的保存的只是 object 的引用，而 primitive value 则不同。\n\n闭包陷阱是如何产生的呢？请看下面的代码。\n\nfunction App(){\n    const [count, setCount] = useState(1);\n    useEffect(()=>{\n        setInterval(()=>{\n            console.log(count)\n        }, 1000)\n    }, [])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在这种情况下，无论 setCount 怎么执行，打印出的 count 值都是 1。我们来分析下程序执行的过程：\n\n首先，在 mount 阶段程序执行到 useState 会将 count 的初始值设置为 1，然后执行到 useEffect，则设置定时器。由于 useEffect 的依赖数组为 []，只会在 mount 时执行一次。然后通过应用的某些操作触发 setCount，count 的改变，因此在非闭包的环境下，count 的值更新无误，然而在定时器中由于形成的闭包环境，会记录 count 的值为 1，没有感知的 count 值的变化。如果此处将 count 写成对象的方式，在 setCount 时使用 Object.merge 不改变对象的引用，则即使在对象中也能感知到 count 的变化。\n\n那么闭包环境是如何形成的呢？\n\n> Closures from MDN:\n> \n> A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function’s scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time.\n> \n> 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。\n\n核心理解\n\nuseRef 是如何巧妙避免闭包陷阱的呢？原理正在 object 在变量中只保存引用，因此 useRef 正是在 React 内部维持了 {current: value} 的对象，我们在使用 current 中的值或者是给 current 赋值时，都不会导致包裹 current 的外层对象的引用变化，这就保证了外层的包括对象永远只存在内存的统一地方，而 current 作为引用永远会指向我们赋给 current 的任何值。\n\n回到主题，避免闭包陷阱有两种方式，一种是使用 useRef，另外一种就是使用组件外的变量。useRef 能避免闭包陷阱的原因上述已经解释清楚了，那么组件外的变量又为什么能解决这种问题呢？我们知道 FC 本质是函数，React 正在是靠执行 FC 来完成 render 过程的（从 renderWithHook 函数中 children = Component(props, refOrContext); 可以看出这一点）。我们可以把 React 的 render 过程看成是视频播放的帧。既然 React 是执行 FC 达到 render 的目的，而组件外层的变量则不会在 render 的过程中被反复执行，因此这些变量只执行一次，确实是可以达到缓存变量的目的。\n\n核心理解\n\n但是需要注意的是，useRef 的不可替代性正是体现在下面的两点：\n\n 1. useRef 的缓存作用，且不会引起 re-render;\n 2. useRef 是与组件实例挂钩的，不同组件实例中 useRef 互不干扰。\n\n我们知道，组件存在的最大目的就可复用性。组件从面向对象的层面思考就是一个对象，而组件的引用可以理解为一个对象实例。相同对象中不同实例之间的变量和函数互不影响。实际上，这正是由闭包机制形成的。\n\n 2. 为什么要把缓存的结构设置为 {current: value} 的结构？这和 vue3 中 ref () 的结构类似，两者有什么异同？\n\n从上一问题中，我们已经知道 useRef 解决闭包陷阱的关键就在于其对象结构，因此这里使用 primitive value 这种结构是绝对不可以的。因此写 current 也是十分必要的。\n\n至于 vue3 中 ref 需要使用 .value 也是类似的原因。虽然 Proxy API 支持 object 属性的 get、set 的监听，但是 ref 其实并不是 Proxy 实现的，通过源码可知，ref 是以 class 实现的 ref 对象，并且自定义拦截了 get 和 set 方法。因此 ref 一方面要保证 ref 对象的地址不会变化，以供我们随时的引用，同时提供了对 ref.value 属性做 get、set 的监听。 value 属性的 get 操作会被 track，其 set 操作则会被 trigger。相比于 React 中 useRef，vue3 中的 ref 通过实现对 .value 属性的 track 和 trigger 以实现其响应式。\n\n\n# 参考文档\n\n * 从 react hooks “闭包陷阱” 切入，浅谈 react hooks",normalizedContent:"# 目录\n\n\n\n * 目录\n * useref 定义\n * mountref: useref on mount phrase\n * updateref: useref on update phrase\n * q&a\n * 参考文档\n\n\n\n\n# useref 定义\n\n首先我们来看一下 useref 在 react 中的定义代码 (react package)：\n\nexport function useref<t>(initialvalue: t): {current: t} {\n  const dispatcher = resolvedispatcher();\n  return dispatcher.useref(initialvalue);\n}\n\n\n1\n2\n3\n4\n\n\n可以看出如下信息：\n\n * 接受初始值 initialvalue，返回值携带在 current 上。\n * useref 接受 dispatcher 的调度，在不同的环境可能有不同的实现。\n\n下面来看一下 useref 在 dispatcher 上是如何实现的：\n\n在 hooksdispatcheronmount 中 useref 的实现为 mountref，在 hooksdispatcheronupdate 中 useref 实现为 updateref。看来大多 hook 的实现模式与此类似。\n\n\n# mountref: useref on mount phrase\n\nmountref 的实现很简单，基本上只是做初始化的工作。\n\nfunction mountref<t>(initialvalue: t): {current: t} {\n  // 获取当前正在执行的 hook\n  const hook = mountworkinprogresshook();\n  const ref = {current: initialvalue};\n  if (__dev__) {\n    object.seal(ref);\n  }\n  // 初始化 current 值到 hook\n  hook.memoizedstate = ref;\n  return ref;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# updateref: useref on update phrase\n\n在更新阶段，只需将缓存的值取出即可，缓存的值存在 memoizedstate 中。\n\nfunction updateref<t>(initialvalue: t): {current: t} {\n  const hook = updateworkinprogresshook();\n  return hook.memoizedstate;\n}\n\n\n1\n2\n3\n4\n\n\n\n# q&a\n\n看到这里，可能有以下几个问题：\n\n 1. 既然 useref 只是在 render 过程中去缓存值，那么完全可以将之以变量的方式定义在组件前面，那个他存在的意义是什么？两者又有什么区别？\n\n首先，我们需要知道的是，useref 其实是解决了 usestate 闭包陷阱的问题。usestate 一定能够更新值，但是有一种特例会使代码得不到 usestate 更新后的值，那就是闭包环境，这种特例叫做闭包陷阱。\n\n这种现象的产生主要与 usestate 更新 primitive value 有关，而更新 object 则不存在这种问题。主要原因是 object 是存在堆中的，变量的保存的只是 object 的引用，而 primitive value 则不同。\n\n闭包陷阱是如何产生的呢？请看下面的代码。\n\nfunction app(){\n    const [count, setcount] = usestate(1);\n    useeffect(()=>{\n        setinterval(()=>{\n            console.log(count)\n        }, 1000)\n    }, [])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在这种情况下，无论 setcount 怎么执行，打印出的 count 值都是 1。我们来分析下程序执行的过程：\n\n首先，在 mount 阶段程序执行到 usestate 会将 count 的初始值设置为 1，然后执行到 useeffect，则设置定时器。由于 useeffect 的依赖数组为 []，只会在 mount 时执行一次。然后通过应用的某些操作触发 setcount，count 的改变，因此在非闭包的环境下，count 的值更新无误，然而在定时器中由于形成的闭包环境，会记录 count 的值为 1，没有感知的 count 值的变化。如果此处将 count 写成对象的方式，在 setcount 时使用 object.merge 不改变对象的引用，则即使在对象中也能感知到 count 的变化。\n\n那么闭包环境是如何形成的呢？\n\n> closures from mdn:\n> \n> a closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). in other words, a closure gives you access to an outer function’s scope from an inner function. in javascript, closures are created every time a function is created, at function creation time.\n> \n> 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 javascript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。\n\n核心理解\n\nuseref 是如何巧妙避免闭包陷阱的呢？原理正在 object 在变量中只保存引用，因此 useref 正是在 react 内部维持了 {current: value} 的对象，我们在使用 current 中的值或者是给 current 赋值时，都不会导致包裹 current 的外层对象的引用变化，这就保证了外层的包括对象永远只存在内存的统一地方，而 current 作为引用永远会指向我们赋给 current 的任何值。\n\n回到主题，避免闭包陷阱有两种方式，一种是使用 useref，另外一种就是使用组件外的变量。useref 能避免闭包陷阱的原因上述已经解释清楚了，那么组件外的变量又为什么能解决这种问题呢？我们知道 fc 本质是函数，react 正在是靠执行 fc 来完成 render 过程的（从 renderwithhook 函数中 children = component(props, reforcontext); 可以看出这一点）。我们可以把 react 的 render 过程看成是视频播放的帧。既然 react 是执行 fc 达到 render 的目的，而组件外层的变量则不会在 render 的过程中被反复执行，因此这些变量只执行一次，确实是可以达到缓存变量的目的。\n\n核心理解\n\n但是需要注意的是，useref 的不可替代性正是体现在下面的两点：\n\n 1. useref 的缓存作用，且不会引起 re-render;\n 2. useref 是与组件实例挂钩的，不同组件实例中 useref 互不干扰。\n\n我们知道，组件存在的最大目的就可复用性。组件从面向对象的层面思考就是一个对象，而组件的引用可以理解为一个对象实例。相同对象中不同实例之间的变量和函数互不影响。实际上，这正是由闭包机制形成的。\n\n 2. 为什么要把缓存的结构设置为 {current: value} 的结构？这和 vue3 中 ref () 的结构类似，两者有什么异同？\n\n从上一问题中，我们已经知道 useref 解决闭包陷阱的关键就在于其对象结构，因此这里使用 primitive value 这种结构是绝对不可以的。因此写 current 也是十分必要的。\n\n至于 vue3 中 ref 需要使用 .value 也是类似的原因。虽然 proxy api 支持 object 属性的 get、set 的监听，但是 ref 其实并不是 proxy 实现的，通过源码可知，ref 是以 class 实现的 ref 对象，并且自定义拦截了 get 和 set 方法。因此 ref 一方面要保证 ref 对象的地址不会变化，以供我们随时的引用，同时提供了对 ref.value 属性做 get、set 的监听。 value 属性的 get 操作会被 track，其 set 操作则会被 trigger。相比于 react 中 useref，vue3 中的 ref 通过实现对 .value 属性的 track 和 trigger 以实现其响应式。\n\n\n# 参考文档\n\n * 从 react hooks “闭包陷阱” 切入，浅谈 react hooks",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-14T22:02:21.000Z",permalink:"/react/summary/index/",categories:["react","summary"],tags:[null]},regularPath:"/10.react/80.%E6%80%BB%E7%BB%93/0.index.html",relativePath:"10.react/80.总结/0.index.md",key:"v-230de106",path:"/react/summary/index/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"React 核心包结构图",slug:"react-核心包结构图",normalizedTitle:"react 核心包结构图",charIndex:17},{level:2,title:"核心包",slug:"核心包",normalizedTitle:"核心包",charIndex:23},{level:2,title:"架构分层",slug:"架构分层",normalizedTitle:"架构分层",charIndex:40},{level:2,title:"内核层模块的主要作用",slug:"内核层模块的主要作用",normalizedTitle:"内核层模块的主要作用",charIndex:48}],readingTime:{text:"1 min read",minutes:.885,time:53100,words:177},headersStr:"目录 React 核心包结构图 核心包 架构分层 内核层模块的主要作用",content:"# 目录\n\n\n\n * 目录\n * React 核心包结构图\n * 核心包\n * 架构分层\n * 内核层模块的主要作用\n\n\n\n\n# React 核心包结构图\n\n下面是 react 是 4 个核心包的调度关系。\n\n\n# 核心包\n\nreact 中的核心包包括四个：\n\n * react：导出 react 基础 api 的基础包，常与相应的渲染包（如 react-dom、react-native）一起使用。属于应用层。\n * react-dom：react 针对 web 的渲染包，负责将 react-reconciler 构造的 VNodeTree 渲染为 DOM Tree。提供 render 方法实现 VNode (jsx -> babel -> createElement -> ReactElement ) 到 DOM Node 的飞跃。属于内核层平台包。\n * react-reconciler\n   * 负责协调 react、react-dom、scheduler 包的协调配合\n   * 跨穿 react 应用构建和更新的始终。\n   * 管理 react 应用从输入到输出的状态变化，将输入信息转化为输出信号传递给 react-dom 渲染器。\n   * 属于内核层核心包。\n * scheduler\n   * 创建和调度渲染任务。\n   * 掌握渲染回调（执行更新）的时机。\n   * 属于内核层核心包。\n\n\n# 架构分层\n\n * 应用层：提供开发 react 应用的 API，包括 react 包和 react-dom 包中部分 API，作为应用开发的上层工具。主要包括 ReactElement、ReactChildren、Component API、Hooks API、Render API 等。\n\n * 内核层\n   \n   * 调和器（Reconciler）\n   * 调度器（Scheduler）\n   * 更新器（Updater）\n   * 渲染器（Render）\n\n\n# 内核层模块的主要作用\n\n 1. 调和器（Reconciler）\n\n调和器的主要作用是：协同调度器、渲染器和更新器的工作，维护 react 的从信息输入到信号输出的更新流程。\n\n * 接受来自于应用层（react-dom 的初次渲染，react 的更新渲染）的更新请求，维护一整套的更新流程。\n * 协调调度器的运行，包装更新回调并交由调度器进行任务调度，并且接受调度器基于优先级调度的执行回调。\n * 调度更新器来完成 react 组件上的组件渲染、更新和卸载任务，间接实现 react 组件层面的掌控。\n * 输出端与渲染器相连，将 VNodeTree 输出到渲染器构建 DOM Tree（ssr: 渲染字符），实现 UI 上的更新。\n\n 2. 调度器（Scheduler）\n\n调和器的主要作用是：封装任务、调度和执行回调。\n\n * 接受来自调和器的异步渲染回调，将之包装成渲染任务。\n * 内部维护一个一个基于任务优先级的任务队列，优先级较高的任务优先执行回调。\n * 调度队列中的任务（循环消费渲染任务，直到队列为空），适时执行回调，将回调任务交还调和器。\n\n 3. 更新器（Updater）\n\n更新器的主要作用是：维护 react 组件的渲染、更新和卸载等组件层面的工作。\n\n * 包装在调和器内部，由调和器直接调度以完成组件层面上的渲染任务。\n * 实现 diff 算法。\n\n 4. 渲染器（Render）\n\n渲染器的主要作用是：将 VNodeTree 转化为 DOMTree 进行 UI 渲染工作。\n\n * 提供 react 应用的启动入口（ReactDOM.render 方法），初次渲染时跳过调度（同步调度），直接 commitRoot 渲染整棵 VNode 树。\n * 实现 HostConfig 协议，抹平平台之间的渲染差异，将 FiberTree 转化为 DOMTree 更新至页面。",normalizedContent:"# 目录\n\n\n\n * 目录\n * react 核心包结构图\n * 核心包\n * 架构分层\n * 内核层模块的主要作用\n\n\n\n\n# react 核心包结构图\n\n下面是 react 是 4 个核心包的调度关系。\n\n\n# 核心包\n\nreact 中的核心包包括四个：\n\n * react：导出 react 基础 api 的基础包，常与相应的渲染包（如 react-dom、react-native）一起使用。属于应用层。\n * react-dom：react 针对 web 的渲染包，负责将 react-reconciler 构造的 vnodetree 渲染为 dom tree。提供 render 方法实现 vnode (jsx -> babel -> createelement -> reactelement ) 到 dom node 的飞跃。属于内核层平台包。\n * react-reconciler\n   * 负责协调 react、react-dom、scheduler 包的协调配合\n   * 跨穿 react 应用构建和更新的始终。\n   * 管理 react 应用从输入到输出的状态变化，将输入信息转化为输出信号传递给 react-dom 渲染器。\n   * 属于内核层核心包。\n * scheduler\n   * 创建和调度渲染任务。\n   * 掌握渲染回调（执行更新）的时机。\n   * 属于内核层核心包。\n\n\n# 架构分层\n\n * 应用层：提供开发 react 应用的 api，包括 react 包和 react-dom 包中部分 api，作为应用开发的上层工具。主要包括 reactelement、reactchildren、component api、hooks api、render api 等。\n\n * 内核层\n   \n   * 调和器（reconciler）\n   * 调度器（scheduler）\n   * 更新器（updater）\n   * 渲染器（render）\n\n\n# 内核层模块的主要作用\n\n 1. 调和器（reconciler）\n\n调和器的主要作用是：协同调度器、渲染器和更新器的工作，维护 react 的从信息输入到信号输出的更新流程。\n\n * 接受来自于应用层（react-dom 的初次渲染，react 的更新渲染）的更新请求，维护一整套的更新流程。\n * 协调调度器的运行，包装更新回调并交由调度器进行任务调度，并且接受调度器基于优先级调度的执行回调。\n * 调度更新器来完成 react 组件上的组件渲染、更新和卸载任务，间接实现 react 组件层面的掌控。\n * 输出端与渲染器相连，将 vnodetree 输出到渲染器构建 dom tree（ssr: 渲染字符），实现 ui 上的更新。\n\n 2. 调度器（scheduler）\n\n调和器的主要作用是：封装任务、调度和执行回调。\n\n * 接受来自调和器的异步渲染回调，将之包装成渲染任务。\n * 内部维护一个一个基于任务优先级的任务队列，优先级较高的任务优先执行回调。\n * 调度队列中的任务（循环消费渲染任务，直到队列为空），适时执行回调，将回调任务交还调和器。\n\n 3. 更新器（updater）\n\n更新器的主要作用是：维护 react 组件的渲染、更新和卸载等组件层面的工作。\n\n * 包装在调和器内部，由调和器直接调度以完成组件层面上的渲染任务。\n * 实现 diff 算法。\n\n 4. 渲染器（render）\n\n渲染器的主要作用是：将 vnodetree 转化为 domtree 进行 ui 渲染工作。\n\n * 提供 react 应用的启动入口（reactdom.render 方法），初次渲染时跳过调度（同步调度），直接 commitroot 渲染整棵 vnode 树。\n * 实现 hostconfig 协议，抹平平台之间的渲染差异，将 fibertree 转化为 domtree 更新至页面。",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"位运算初探",frontmatter:{title:"位运算初探",date:"2022-04-14T22:02:21.000Z",permalink:"/react/summary/bitOperation/",categories:["react","summary"],tags:[null]},regularPath:"/10.react/80.%E6%80%BB%E7%BB%93/10.bitOperation.html",relativePath:"10.react/80.总结/10.bitOperation.md",key:"v-1154a3c8",path:"/react/summary/bitOperation/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"运算规则",slug:"运算规则",normalizedTitle:"运算规则",charIndex:17},{level:2,title:"常用的技巧",slug:"常用的技巧",normalizedTitle:"常用的技巧",charIndex:25},{level:3,title:"按位与(&)",slug:"按位与",normalizedTitle:"按位与 (&amp;)",charIndex:null},{level:3,title:"按位或(|)",slug:"按位或",normalizedTitle:"按位或 (|)",charIndex:725},{level:3,title:"按位亦或(^)",slug:"按位亦或",normalizedTitle:"按位亦或 (^)",charIndex:868},{level:3,title:"按位取反(~)",slug:"按位取反",normalizedTitle:"按位取反 (~)",charIndex:1082},{level:3,title:"左移（<<）",slug:"左移",normalizedTitle:"左移（&lt;&lt;）",charIndex:null},{level:3,title:"右移（>>）",slug:"右移",normalizedTitle:"右移（&gt;&gt;）",charIndex:null},{level:2,title:"参考链接",slug:"参考链接",normalizedTitle:"参考链接",charIndex:108}],readingTime:{text:"2 min read",minutes:1.12,time:67200,words:224},headersStr:"目录 运算规则 常用的技巧 按位与(&) 按位或(|) 按位亦或(^) 按位取反(~) 左移（<<） 右移（>>） 参考链接",content:"# 目录\n\n\n\n * 目录\n * 运算规则\n * 常用的技巧\n   * 按位与(&)\n   * 按位或(|)\n   * 按位亦或(^)\n   * 按位取反(~)\n   * 左移（<<）\n   * 右移（>>）\n * 参考链接\n\n\n\n\n# 运算规则\n\n符号   描述   运算规则\n&    与    两个位都为 1 时，结果才为 1\n|    或    两个位都为 0 时，结果才为 0\n^    异或   两个位相同为 0，相异为 1\n~    取反   0 变 1，1 变 0\n<<   左移   各二进位全部左移若干位，高位丢弃，低位补 0\n>>   右移   各二进位全部右移若干位，对无符号数，高位补 0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补\n          0（逻辑右移）\n\n\n# 常用的技巧\n\n\n# 按位与 (&)\n\n * 清零。任何数与 0 结果都是 0.\n * 取二进制数的指定位：0、1 与 1 与都是其本身，因此只要将需要取得二进制数位为 1，需要舍弃的位置为 0，如 00001111，取二进制数后四位。\n * 判断奇偶：任何偶数的二进制的最后一位都是 0，任何奇数的二进制的最后一位都是 1。因此可以用 (x&1)===0 判断偶数，(x&1)===1 判断奇数，但是注意得是整数。\n * x & (x - 1) 用于消去二进制中 x 最后一位的 1。\n * 位操作统计二进制中 1 的个数：\n\nlet count = 0  \nwhile(a){  \n  a &= (a - 1);  // 每计算一次二进制中就少了一个 1\n  count++;  \n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 按位或 (|)\n\n * 将二进制的某些位置置为 1：0、1 与 1 或都是 1，因此可以将需要置为 1 的位置为 1，如 00001111 将后四位置为 1。\n * 将偶数变成奇数（整数）：将整数的二进制最后一位置为 1 就变成了奇数，如 (-4|1)=-3、(4|1)=5。\n\n\n# 按位亦或 (^)\n\n * 翻转指定位：0/1 与 1 亦或就会翻转，与 0 亦或则会保持不变。按照这个规则，将需要翻转的位置 1，不需要翻转的位置 0 即可，如 00001111 将翻转后四位。\n * 两数交换：\n\na ^= b;\nb ^= a;\na ^= b;\n\n\n1\n2\n3\n\n\n我们可以从某一个二进制位的变化来理解这个问题：\n\na:0 b:1\na:1 b:1\na:1 b:0\na:1 b:0\n\n\n1\n2\n3\n4\n\n\n\n# 按位取反 (~)\n\nx 按位取反相当于 -(x+1)。\n\n * 交互正负：a=~a + 1。\n * 取绝对值：a=a>=0?a:~a+1。\n\n\n# 左移（<<）\n\n * 每左移一位，相当于该数乘以 2。\n\n\n# 右移（>>）\n\n * 每右移一位，相当于该数除以 2。\n * 正整数和 0 右移 31 位是 0，负整数右移 31 位是 - 1。\n * 16 位的无符号整数，将其高 8 位与低 8 位进行交换，求出交换后的值: a = (a>> 8) | (a << 8)。\n\n\n# 参考链接\n\n * 位运算有什么奇技淫巧？",normalizedContent:"# 目录\n\n\n\n * 目录\n * 运算规则\n * 常用的技巧\n   * 按位与(&)\n   * 按位或(|)\n   * 按位亦或(^)\n   * 按位取反(~)\n   * 左移（<<）\n   * 右移（>>）\n * 参考链接\n\n\n\n\n# 运算规则\n\n符号   描述   运算规则\n&    与    两个位都为 1 时，结果才为 1\n|    或    两个位都为 0 时，结果才为 0\n^    异或   两个位相同为 0，相异为 1\n~    取反   0 变 1，1 变 0\n<<   左移   各二进位全部左移若干位，高位丢弃，低位补 0\n>>   右移   各二进位全部右移若干位，对无符号数，高位补 0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补\n          0（逻辑右移）\n\n\n# 常用的技巧\n\n\n# 按位与 (&)\n\n * 清零。任何数与 0 结果都是 0.\n * 取二进制数的指定位：0、1 与 1 与都是其本身，因此只要将需要取得二进制数位为 1，需要舍弃的位置为 0，如 00001111，取二进制数后四位。\n * 判断奇偶：任何偶数的二进制的最后一位都是 0，任何奇数的二进制的最后一位都是 1。因此可以用 (x&1)===0 判断偶数，(x&1)===1 判断奇数，但是注意得是整数。\n * x & (x - 1) 用于消去二进制中 x 最后一位的 1。\n * 位操作统计二进制中 1 的个数：\n\nlet count = 0  \nwhile(a){  \n  a &= (a - 1);  // 每计算一次二进制中就少了一个 1\n  count++;  \n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 按位或 (|)\n\n * 将二进制的某些位置置为 1：0、1 与 1 或都是 1，因此可以将需要置为 1 的位置为 1，如 00001111 将后四位置为 1。\n * 将偶数变成奇数（整数）：将整数的二进制最后一位置为 1 就变成了奇数，如 (-4|1)=-3、(4|1)=5。\n\n\n# 按位亦或 (^)\n\n * 翻转指定位：0/1 与 1 亦或就会翻转，与 0 亦或则会保持不变。按照这个规则，将需要翻转的位置 1，不需要翻转的位置 0 即可，如 00001111 将翻转后四位。\n * 两数交换：\n\na ^= b;\nb ^= a;\na ^= b;\n\n\n1\n2\n3\n\n\n我们可以从某一个二进制位的变化来理解这个问题：\n\na:0 b:1\na:1 b:1\na:1 b:0\na:1 b:0\n\n\n1\n2\n3\n4\n\n\n\n# 按位取反 (~)\n\nx 按位取反相当于 -(x+1)。\n\n * 交互正负：a=~a + 1。\n * 取绝对值：a=a>=0?a:~a+1。\n\n\n# 左移（<<）\n\n * 每左移一位，相当于该数乘以 2。\n\n\n# 右移（>>）\n\n * 每右移一位，相当于该数除以 2。\n * 正整数和 0 右移 31 位是 0，负整数右移 31 位是 - 1。\n * 16 位的无符号整数，将其高 8 位与低 8 位进行交换，求出交换后的值: a = (a>> 8) | (a << 8)。\n\n\n# 参考链接\n\n * 位运算有什么奇技淫巧？",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"React 首次渲染过程",frontmatter:{title:"React 首次渲染过程",date:"2022-04-14T22:02:21.000Z",permalink:"/react/summary/first-render/",categories:["react","summary"],tags:[null]},regularPath:"/10.react/80.%E6%80%BB%E7%BB%93/20.first-render.html",relativePath:"10.react/80.总结/20.first-render.md",key:"v-35203ba8",path:"/react/summary/first-render/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"ReactDOM.render",slug:"reactdom-render",normalizedTitle:"reactdom.render",charIndex:17},{level:3,title:"jsxWithValidation",slug:"jsxwithvalidation",normalizedTitle:"jsxwithvalidation",charIndex:38},{level:3,title:"render",slug:"render",normalizedTitle:"render",charIndex:26},{level:2,title:"legacyRenderSubtreeIntoContainer",slug:"legacyrendersubtreeintocontainer",normalizedTitle:"legacyrendersubtreeintocontainer",charIndex:71},{level:4,title:"legacyCreateRootFromDOMContainer",slug:"legacycreaterootfromdomcontainer",normalizedTitle:"legacycreaterootfromdomcontainer",charIndex:9819},{level:4,title:"listenToAllSupportedEvents",slug:"listentoallsupportedevents",normalizedTitle:"listentoallsupportedevents",charIndex:12912},{level:2,title:"createFiberRoot",slug:"createfiberroot",normalizedTitle:"createfiberroot",charIndex:107},{level:2,title:"createHostRootFiber",slug:"createhostrootfiber",normalizedTitle:"createhostrootfiber",charIndex:126},{level:2,title:"flushSync",slug:"flushsync",normalizedTitle:"flushsync",charIndex:149},{level:3,title:"flushPassiveEffects",slug:"flushpassiveeffects",normalizedTitle:"flushpassiveeffects",charIndex:164},{level:3,title:"flushSyncCallbacks",slug:"flushsynccallbacks",normalizedTitle:"flushsynccallbacks",charIndex:189},{level:2,title:"updateContainer",slug:"updatecontainer",normalizedTitle:"updatecontainer",charIndex:211},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:230},{level:2,title:"Q&A",slug:"q-a",normalizedTitle:"q&amp;a",charIndex:null},{level:3,title:"executionContext 有哪几种？",slug:"executioncontext-有哪几种",normalizedTitle:"executioncontext 有哪几种？",charIndex:245},{level:3,title:"使用位运算提高枚举计算效率",slug:"使用位运算提高枚举计算效率",normalizedTitle:"使用位运算提高枚举计算效率",charIndex:273},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:290}],readingTime:{text:"24 min read",minutes:23.56,time:1413600,words:4712},headersStr:"目录 ReactDOM.render jsxWithValidation render legacyRenderSubtreeIntoContainer legacyCreateRootFromDOMContainer listenToAllSupportedEvents createFiberRoot createHostRootFiber flushSync flushPassiveEffects flushSyncCallbacks updateContainer 小结 Q&A executionContext 有哪几种？ 使用位运算提高枚举计算效率 参考资料",content:"# 目录\n\n\n\n * 目录\n * ReactDOM.render\n   * jsxWithValidation\n   * render\n * legacyRenderSubtreeIntoContainer\n * createFiberRoot\n * createHostRootFiber\n * flushSync\n   * flushPassiveEffects\n   * flushSyncCallbacks\n * updateContainer\n * 小结\n * Q&A\n   * executionContext 有哪几种？\n   * 使用位运算提高枚举计算效率\n * 参考资料\n\n\n\n注意\n\n * 本文的代码去除了 dev 环境的部分代码。\n\n\n# ReactDOM.render\n\n通过在 ReactDOM.render 语句添加断点，我们来追溯一下 React 的首次渲染过程。\n\n\n# jsxWithValidation\n\n首先开始验证 <App /> 组件是否是合法的 jsx 组件。如果不合法，就打印错误消息和错误栈信息。\n\n// src/react/fixtures/legacy-jsx-runtimes/react-17/cjs/react-jsx-dev-runtime.development.js\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      // pass \n      // 报错处理\n    }\n\n    // 返回一个 ReactElement 对象\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        // isStaticChildren 则校验 key 值\n        if (isStaticChildren) {\n          if (Array.isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (type === exports.Fragment) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n}\n// Local Stack\n// {\n//   \"props\": {},\n//   \"isStaticChildren\": false,\n//   \"source\": {\n//     \"fileName\": \"/Users/jonsam/Projects/update_in_github/react-source-reading/src/index.js\",\n//     \"lineNumber\": 9,\n//     \"columnNumber\": 5\n//   },\n//   \"validType\": true,\n//   \"element\": {\n//     \"key\": null,\n//     \"ref\": null,\n//     \"props\": {},\n//     \"_owner\": null,\n//     \"_store\": {}\n//   }\n// }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n那么如何判断是否是合法的 Element 呢？\n\nfunction isValidElementType(type) {\n  // 如果是 string 和 function 是合法的 Element，分别代表着文本节点和 FC\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n  // 判断 type 是否为 Fragment，profiler，suspense 之类的特殊类型\n  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {\n    return true;\n  }\n\n  // 判断 $$typeof 书否为内部类型，LAZY、MEMO、PROVIDER、CONTEXT、FORWARD_REF 等\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\njsxDEV 如何返回一个 ReactElement 呢？\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    // 添加 ReactElement 的 $$typeof 类型\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    // 节点实际的类型，此处为 function\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    // 使用外部的代码块防止变量因为 _store 的引用而不能释放，可以放 weakMap 代替，给 element 添加类似于 weakMap 的 _store 属性\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n// Local Stack\n// {\n//   \"config\": {},\n//   \"source\": {\n//     \"fileName\": \"/Users/jonsam/Projects/update_in_github/react-source-reading/src/index.js\",\n//     \"lineNumber\": 9,\n//     \"columnNumber\": 5\n//   },\n//   \"props\": {},\n//   \"key\": null,\n//   \"ref\": null\n// }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n * ReactElement 是一个工厂函数，传入相关的属性，生成 ReactElement 对象。\n * ReactElement 中 $$typeof 是指内部的节点类型，ReactElement 的内部类型为 REACT_ELEMENT_TYPE ，type 是指实际的节点类型，此处是一个 function。\n * 在测试环境下会在 ReactElement 上挂载 _store 属性，类似于 weakMap 是为了节省内存，目的是为了开发环境中测试提速。\n\n\n# render\n\n// src/react/packages/react-dom/src/client/ReactDOMLegacy.js\nfunction render(\n  element: React$Element<any>,\n  container: Container,\n  callback: ?Function,\n){\n  if (!isValidContainerLegacy(container)) {\n    throw new Error('Target container is not a DOM element.');\n  }\n  return legacyRenderSubtreeIntoContainer(\n    null,\n    element,\n    container,\n    false,\n    callback,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nLocal Stack\n\n生成 ReactElement 之后调用 render 方法，内部判断是否是合法的 container，然后调用 legacyRenderSubtreeIntoContainer 方法将 subTree 渲染到 container 中。\n\n怎么判断是否是合法的 container 呢？\n\n// We only use it in places that are currently more relaxed.\nexport function isValidContainerLegacy(node: any): boolean {\n  // 通过 node.nodeType 来判断 node 是否是已知的类型\n  return !!(\n    node &&\n    (node.nodeType === ELEMENT_NODE ||\n      node.nodeType === DOCUMENT_NODE ||\n      node.nodeType === DOCUMENT_FRAGMENT_NODE ||\n      (node.nodeType === COMMENT_NODE &&\n        (node: any).nodeValue === ' react-mount-point-unstable '))\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nLocal Stack\n\n去除可访问性和事件之后的属性：\n\nassignedSlot: null\nattributeStyleMap: StylePropertyMap {size: 0}\nattributes: NamedNodeMap {0: id, id: id, length: 1}\nautocapitalize: \"\"\nautofocus: false\nbaseURI: \"http://localhost:3001/\"\nchildElementCount: 0\nchildNodes: NodeList []\nchildren: HTMLCollection []\nclassList: DOMTokenList [value: '']\nclassName: \"\"\nclientHeight: 0\nclientLeft: 0\nclientTop: 0\nclientWidth: 1792\ncontentEditable: \"inherit\"\ndataset: DOMStringMap {}\ndir: \"\"\ndraggable: false\nelementTiming: \"\"\nenterKeyHint: \"\"\nfirstChild: null\nfirstElementChild: null\nhidden: false\nid: \"root\"\ninnerHTML: \"\"\ninnerText: \"\"\ninputMode: \"\"\nisConnected: true\nisContentEditable: false\nlang: \"\"\nlastChild: null\nlastElementChild: null\nlocalName: \"div\"\nnamespaceURI: \"http://www.w3.org/1999/xhtml\"\nnextElementSibling: null\nnextSibling: text\nnodeName: \"DIV\"\nnodeType: 1\nnodeValue: null\nnonce: \"\"\noffsetHeight: 0\noffsetLeft: 0\noffsetParent: body\noffsetTop: 0\noffsetWidth: 1792\nouterHTML: \"<div id=\\\"root\\\"></div>\"\nouterText: \"\"\nownerDocument: document\nparentElement: body\nparentNode: body\npart: DOMTokenList [value: '']\nprefix: null\npreviousElementSibling: noscript\npreviousSibling: text\nscrollHeight: 0\nscrollLeft: 0\nscrollTop: 0\nscrollWidth: 1792\nshadowRoot: null\nslot: \"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n可以看到，这里 nodeType: 1，即为 ELEMENT_NODE。\n\n\n# legacyRenderSubtreeIntoContainer\n\n// src/react/packages/react-dom/src/client/ReactDOMLegacy.js\nfunction legacyRenderSubtreeIntoContainer(\n  parentComponent: ?React$Component<any, any>,\n  children: ReactNodeList,\n  container: Container,\n  forceHydrate: boolean,\n  callback: ?Function,\n) {\n  // 判断是否已经创建过 RootContainer \n  // _reactRootContainer 标记为 container 上的 FiberRoot 对象\n  let root = container._reactRootContainer;\n  let fiberRoot: FiberRoot;\n  if (!root) {\n    // Initial mount\n    // RootContainer 未创建则为首次挂载应用，调用 legacyCreateRootFromDOMContainer 创建 Root \n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(\n      container,\n      forceHydrate,\n    );\n    fiberRoot = root;\n    // 如果在 render 函数中传入了 callback，需要调用 callback\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Initial mount should not be batched.\n    // 在 mount 阶段，以最高优先级同步的执行所有的更新\n    flushSync(() => {\n      updateContainer(children, fiberRoot, parentComponent, callback);\n    });\n  } else {\n    fiberRoot = root;\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Update\n    updateContainer(children, fiberRoot, parentComponent, callback);\n  }\n  return getPublicRootInstance(fiberRoot);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\nLocal Stack\n\n当前传入的变量：\n\ncallback: undefined\nchildren: {$$typeof: Symbol(react.element), type: Symbol(react.strict_mode), key: null, ref: null, props: {…}, …}\ncontainer: div#root\nfiberRoot: undefined\nforceHydrate: false\noriginalCallback: undefined\nparentComponent: null\nroot: undefined\n_originalCallback: undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nrender 函数中 callback 返回当前容器（container）中的 FiberRoot 对象，由下面这个递归的函数可见：\n\nexport function getPublicRootInstance(\n  container: OpaqueRoot,\n): React$Component<any, any> | PublicInstance | null {\n  const containerFiber = container.current;\n  if (!containerFiber.child) {\n    return null;\n  }\n  switch (containerFiber.child.tag) {\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n    default:\n      // 最终返回的有效的 instance 是 Fiber.child.stateNode 刚好是 RootFiber\n      return containerFiber.child.stateNode;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# legacyCreateRootFromDOMContainer\n\nRootContainer 是如何根据 container 创建的呢？我们来追溯下 legacyCreateRootFromDOMContainer 函数：\n\nfunction legacyCreateRootFromDOMContainer(\n  container: Container,\n  forceHydrate: boolean,\n): FiberRoot {\n  // First clear any existing content.\n  // 如果不是 SSR，就清空 container 中所有的节点\n  if (!forceHydrate) {\n    let rootSibling;\n    while ((rootSibling = container.lastChild)) {\n      container.removeChild(rootSibling);\n    }\n  }\n\n  // 调用 createContainer 创建 RootContainer\n  const root = createContainer(\n    container,\n    // export const LegacyRoot = 0;\n    // export const ConcurrentRoot = 1;\n    LegacyRoot,\n    forceHydrate,\n    null, // hydrationCallbacks\n    false, // isStrictMode\n    false, // concurrentUpdatesByDefaultOverride,\n    '', // identifierPrefix\n  );\n  // 将 FiberRoot 挂载到 container 上，便于下次使用\n  markContainerAsRoot(root.current, container);\n\n  const rootContainerElement =\n    container.nodeType === COMMENT_NODE ? container.parentNode : container;\n  // 开启 container 上所支持的事件监听\n  listenToAllSupportedEvents(rootContainerElement);\n\n  return root;\n}\n\n// src/react/packages/react-reconciler/src/ReactFiberReconciler.new.js\nexport function createContainer(\n  containerInfo: Container,\n  tag: RootTag,\n  hydrate: boolean,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n  isStrictMode: boolean,\n  concurrentUpdatesByDefaultOverride: null | boolean,\n  identifierPrefix: string,\n): OpaqueRoot {\n  return createFiberRoot(\n    containerInfo,\n    tag,\n    hydrate,\n    hydrationCallbacks,\n    isStrictMode,\n    concurrentUpdatesByDefaultOverride,\n    identifierPrefix,\n  );\n}\n\n// src/react/packages/react-dom/src/client/ReactDOMComponentTree.js\nexport function markContainerAsRoot(hostRoot: Fiber, node: Container): void {\n  // 将 FiberRoot 挂载到相应的 container 上\n  // internalContainerInstanceKey： \"__reactFiber$9yvlviys3ft\"\n  node[internalContainerInstanceKey] = hostRoot;\n}\n// randomKey 是每次启动应用生成的随机的 key 值，被应用在内部一些 key 值的使用上\nconst randomKey = Math.random()\n  .toString(36)\n  .slice(2);\nconst internalContainerInstanceKey = '__reactContainer$' + randomKey;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n * RootContainer 分为了两种：LegacyRoot 和 ConcurrentRoot。分别代表着这 React 运行的两种模式：Legacy Mode 和 Concurrent Mode。\n * RootContainer 实际上就是 FiberRoot。这里开始了从 ReactElement 到 FiberRoot 的创建过程。注意 FiberRoot（HostRoot） 本质上是 Root，不是 Fiber；而 RootFiber 才是 Fiber，才是 FiberTree 的根。\n * randomKey 之所以要随机生成，有以下两点原因：标记是打在 node 这样的原生节点上的，随机的标记名可以防止将用户或者其他库所生成的标记覆盖，同时加上 __reactContainer$ 这样的特征串更能防止重复；随机的标记更加安全，防止被其他程序更改或者恶意篡改造成程序崩溃。\n\n# listenToAllSupportedEvents\n\ncontainer 上的事件是如何委托监听的呢，我们来看下 listenToAllSupportedEvents 这个函数：\n\n// src/react/packages/react-dom/src/events/DOMPluginEventSystem.js\n// 为当前的应用生成随机的监听器标记\nconst listeningMarker =\n  '_reactListening' +\n  Math.random()\n    .toString(36)\n    .slice(2);\n// We should not delegate these events to the container, but rather\n// set them on the actual target element itself. This is primarily\n// because these events do not consistently bubble in the DOM.\n// 如下事件不能委托在 container 上，需要设置在实际的 target element 上，这是因为他们不能持续的冒泡。\n// 不能持续冒泡的事件的集合\nexport const nonDelegatedEvents: Set<DOMEventName> = new Set([\n  'cancel',\n  'close',\n  'invalid',\n  'load',\n  'scroll',\n  'toggle',\n  // In order to reduce bytes, we insert the above array of media events\n  // into this Set. Note: the \"error\" event isn't an exclusive media event,\n  // and can occur on other elements too. Rather than duplicate that event,\n  // we just take it from the media events array.\n  // 将媒体先关的事件加入这里以节省内存。\n  ...mediaEventTypes,\n]);\n// List of events that need to be individually attached to media elements.\nexport const mediaEventTypes: Array<DOMEventName> = [\n  'abort',\n  'canplay',\n  'canplaythrough',\n  'durationchange',\n  'emptied',\n  'encrypted',\n  'ended',\n  'error',\n  'loadeddata',\n  'loadedmetadata',\n  'loadstart',\n  'pause',\n  'play',\n  'playing',\n  'progress',\n  'ratechange',\n  'resize',\n  'seeked',\n  'seeking',\n  'stalled',\n  'suspend',\n  'timeupdate',\n  'volumechange',\n  'waiting',\n];\nexport function listenToAllSupportedEvents(rootContainerElement: EventTarget) {\n  if (!(rootContainerElement: any)[listeningMarker]) {\n    // 将事件监听标记设为 true，防止重复监听\n    (rootContainerElement: any)[listeningMarker] = true;\n    allNativeEvents.forEach(domEventName => {\n      // We handle selectionchange separately because it\n      // doesn't bubble and needs to be on the document.\n      // 除 selectionchange 事件之外，其余事件如果可以持续的冒泡，就开启原生事件监听，从冒泡阶段监听；如果无法持续冒泡，从捕获阶段监听。\n      // selectionchange 将会单独处理，因为此事件不允许冒泡，而且必须在 document 上监听\n      if (domEventName !== 'selectionchange') {\n        if (!nonDelegatedEvents.has(domEventName)) {\n          listenToNativeEvent(domEventName, false, rootContainerElement);\n        }\n        listenToNativeEvent(domEventName, true, rootContainerElement);\n      }\n    });\n    // 获取 container 所在的 document \n    const ownerDocument =\n      (rootContainerElement: any).nodeType === DOCUMENT_NODE\n        ? rootContainerElement\n        : (rootContainerElement: any).ownerDocument;\n    if (ownerDocument !== null) {\n      // The selectionchange event also needs deduplication\n      // but it is attached to the document.\n      if (!(ownerDocument: any)[listeningMarker]) {\n        // 在 container 所在的 document 上单独监听 selectionchange 事件\n        (ownerDocument: any)[listeningMarker] = true;\n        listenToNativeEvent('selectionchange', false, ownerDocument);\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n先总结一下如上的代码：\n\n * react 中为提高应用的性能，采用了事件委托机制来来统一处理事件。事件被委托到 container 上或者是 document 上。\n * react 将事件分为三类，一类是可以在冒泡过程中监听的，一类是可以在冒泡过程中监听需要在捕获中监听的，还有一类是在 document 上监听的，如 selectionchange。\n * react 将所有的原生事件都委托了一遍，原因在于基于 react 子树的时间监听将统一由受委托的容器来进行监听。\n\n以上是 react 事件监听的策略，真正的时间监听在函数 listenToNativeEvent 实现。那么 listenToNativeEvent 是如何监听原生事件的呢？请参见 React 中的事件监听机制\n\n\n# createFiberRoot\n\nexport function createFiberRoot(\n  containerInfo: any,\n  tag: RootTag,\n  hydrate: boolean,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n  isStrictMode: boolean,\n  concurrentUpdatesByDefaultOverride: null | boolean,\n  identifierPrefix: string,\n): FiberRoot {\n  // 根据 containerInfo 等信息创建 FiberRoot 对象\n  const root: FiberRoot = (new FiberRootNode(\n    containerInfo,\n    tag,\n    hydrate,\n    identifierPrefix,\n  ): any);\n  if (enableSuspenseCallback) {\n    root.hydrationCallbacks = hydrationCallbacks;\n  }\n\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  // 创建与 HostRoot 强关联的 RootFiber\n  const uninitializedFiber = createHostRootFiber(\n    tag,\n    isStrictMode,\n    concurrentUpdatesByDefaultOverride,\n  );\n  // HostRoot 与 RootFiber 双向链接 HostRoot.current = RootFiber; RootFiber.stateNode = HostRoot\n  root.current = uninitializedFiber;\n  uninitializedFiber.stateNode = root;\n\n  // 初始化 RootFiber 上的更新队列\n  initializeUpdateQueue(uninitializedFiber);\n\n  return root;\n}\nfunction FiberRootNode(containerInfo, tag, hydrate, identifierPrefix) {\n  this.tag = tag;\n  this.containerInfo = containerInfo;\n  this.pendingChildren = null;\n  this.current = null;\n  this.pingCache = null;\n  this.finishedWork = null;\n  this.timeoutHandle = noTimeout;\n  this.context = null;\n  this.pendingContext = null;\n  this.isDehydrated = hydrate;\n  this.callbackNode = null;\n  this.callbackPriority = NoLane;\n  this.eventTimes = createLaneMap(NoLanes);\n  this.expirationTimes = createLaneMap(NoTimestamp);\n\n  this.pendingLanes = NoLanes;\n  this.suspendedLanes = NoLanes;\n  this.pingedLanes = NoLanes;\n  this.expiredLanes = NoLanes;\n  this.mutableReadLanes = NoLanes;\n  this.finishedLanes = NoLanes;\n\n  this.entangledLanes = NoLanes;\n  this.entanglements = createLaneMap(NoLanes);\n\n  this.identifierPrefix = identifierPrefix;\n\n  if (enableCache) {\n    this.pooledCache = null;\n    this.pooledCacheLanes = NoLanes;\n  }\n\n  if (supportsHydration) {\n    this.mutableSourceEagerHydrationData = null;\n  }\n\n  if (enableSuspenseCallback) {\n    this.hydrationCallbacks = null;\n  }\n\n  if (enableProfilerTimer && enableProfilerCommitHooks) {\n    this.effectDuration = 0;\n    this.passiveEffectDuration = 0;\n  }\n\n  if (enableUpdaterTracking) {\n    this.memoizedUpdaters = new Set();\n    const pendingUpdatersLaneMap = (this.pendingUpdatersLaneMap = []);\n    for (let i = 0; i < TotalLanes; i++) {\n      pendingUpdatersLaneMap.push(new Set());\n    }\n  }\n}\n// 在 fiber 上初始化一个更新队列\nexport function initializeUpdateQueue<State>(fiber: Fiber): void {\n  const queue: UpdateQueue<State> = {\n    baseState: fiber.memoizedState,\n    firstBaseUpdate: null,\n    lastBaseUpdate: null,\n    shared: {\n      pending: null,\n      interleaved: null,\n      lanes: NoLanes,\n    },\n    effects: null,\n  };\n  fiber.updateQueue = queue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n\n\nLocal Stack\n\ncreateFiberRoot 函数的变量栈：\n\ncontainerInfo: div#root\nhydrate: false\nhydrationCallbacks: undefined\nroot: FiberRootNode\ncallbackNode: null\ncallbackPriority: 0\ncontainerInfo: div#root\ncontext: null\ncurrent: FiberNode\nactualDuration: 0\nactualStartTime: -1\nalternate: null\nchild: null\nchildLanes: 0\ndependencies: null\nelementType: null\nfirstEffect: null\nflags: 0\nindex: 0\nkey: null\nlanes: 0\nlastEffect: null\nmemoizedProps: null\nmemoizedState: null\nmode: 8\nnextEffect: null\npendingProps: null\nref: null\nreturn: null\nselfBaseDuration: 0\nsibling: null\nstateNode: FiberRootNode {tag: 0, containerInfo: div#root, pendingChildren: null, current: FiberNode, pingCache: null, …}\ntag: 3\ntreeBaseDuration: 0\ntype: null\nupdateQueue:\nbaseState: null\neffects: null\nfirstBaseUpdate: null\nlastBaseUpdate: null\nshared: {pending: null}\n[[Prototype]]: Object\n_debugHookTypes: null\n_debugID: 1\n_debugNeedsRemount: false\n_debugOwner: null\n_debugSource: null\n[[Prototype]]: Object\nentangledLanes: 0\nentanglements: (31) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\neventTimes: (31) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nexpirationTimes: (31) [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]\nexpiredLanes: 0\nfinishedLanes: 0\nfinishedWork: null\nhydrate: false\ninteractionThreadID: 1\nmemoizedInteractions: Set(0) {size: 0}\nmutableReadLanes: 0\nmutableSourceEagerHydrationData: null\npendingChildren: null\npendingContext: null\npendingInteractionMap: Map(0) {size: 0}\npendingLanes: 0\npingCache: null\npingedLanes: 0\nsuspendedLanes: 0\ntag: 0\ntimeoutHandle: -1\n_debugRootType: \"createLegacyRoot()\"\n[[Prototype]]: Object\ntag: 0\nuninitializedFiber: FiberNode {tag: 3, key: null, elementType: null, type: null, stateNode: FiberRootNode, …}\nClosure\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# createHostRootFiber\n\nexport function createHostRootFiber(\n  tag: RootTag,\n  isStrictMode: boolean,\n  concurrentUpdatesByDefaultOverride: null | boolean,\n): Fiber {\n  let mode;\n  if (tag === ConcurrentRoot) {\n    mode = ConcurrentMode;\n    if (isStrictMode === true) {\n      mode |= StrictLegacyMode;\n\n      if (enableStrictEffects) {\n        mode |= StrictEffectsMode;\n      }\n    } else if (enableStrictEffects && createRootStrictEffectsByDefault) {\n      mode |= StrictLegacyMode | StrictEffectsMode;\n    }\n    if (\n      // We only use this flag for our repo tests to check both behaviors.\n      // TODO: Flip this flag and rename it something like \"forceConcurrentByDefaultForTesting\"\n      !enableSyncDefaultUpdates ||\n      // Only for internal experiments.\n      (allowConcurrentByDefault && concurrentUpdatesByDefaultOverride)\n    ) {\n      mode |= ConcurrentUpdatesByDefaultMode;\n    }\n  } else {\n    mode = NoMode;\n  }\n\n  if (enableProfilerTimer && isDevToolsPresent) {\n    // Always collect profile timings when DevTools are present.\n    // This enables DevTools to start capturing timing at any point–\n    // Without some nodes in the tree having empty base times.\n    mode |= ProfileMode;\n  }\n\n  return createFiber(HostRoot, null, null, mode);\n}\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\n// createFiber 是一个工厂函数，不支持构造器、instanceof 语法\nconst createFiber = function(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n): Fiber {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\nfunction FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.elementType = null;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n\n  this.mode = mode;\n\n  // Effects\n  this.flags = NoFlags;\n  this.subtreeFlags = NoFlags;\n  this.deletions = null;\n\n  this.lanes = NoLanes;\n  this.childLanes = NoLanes;\n\n  this.alternate = null;\n\n  if (enableProfilerTimer) {\n    // Note: The following is done to avoid a v8 performance cliff.\n    //\n    // Initializing the fields below to smis and later updating them with\n    // double values will cause Fibers to end up having separate shapes.\n    // This behavior/bug has something to do with Object.preventExtension().\n    // Fortunately this only impacts DEV builds.\n    // Unfortunately it makes React unusably slow for some applications.\n    // To work around this, initialize the fields below with doubles.\n    //\n    // Learn more about this here:\n    // https://github.com/facebook/react/issues/14365\n    // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n    this.actualDuration = Number.NaN;\n    this.actualStartTime = Number.NaN;\n    this.selfBaseDuration = Number.NaN;\n    this.treeBaseDuration = Number.NaN;\n\n    // It's okay to replace the initial doubles with smis after initialization.\n    // This won't trigger the performance cliff mentioned above,\n    // and it simplifies other profiler code (including DevTools).\n    this.actualDuration = 0;\n    this.actualStartTime = -1;\n    this.selfBaseDuration = 0;\n    this.treeBaseDuration = 0;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n\n * RootFiber 本质上是 Fiber 的原因是调用了 createFiber 来构造 Fiber，同时传入的 tag 为 HostRoot 保证了 Fiber 的独特性。\n * Fiber 的本质是一个对象。Fiber 上的重要属性大致分为三类：Instance 相关、Fiber 相关、Effects 相关、lanes 相关。instance 相关为 Fiber 对象实例的属性，tag 为 fiber 上节点类型标记。Fiber 相关为 FiberTree 的必要指针；Effects 相关为 render 过程中副作用的标记。lanes 为优先级相关的属性，alternate 则是版本记录的属性。\n * uninitializedFiber 不是完整的 RootFiber，其中只初始化了 Instance 相关 的属性。\n\n注意\n\n * tag 不是 Fiber 的类型，而是 Fiber 上标记的节点的类型。\n\nLocal Stack\n\nReturn value: FiberNode\nactualDuration: 0\nactualStartTime: -1\nalternate: null\nchild: null\nchildLanes: 0\ndependencies: null\nelementType: null\nfirstEffect: null\nflags: 0\nindex: 0\nkey: null\nlanes: 0\nlastEffect: null\nmemoizedProps: null\nmemoizedState: null\nmode: 8\nnextEffect: null\npendingProps: null\nref: null\nreturn: null\nselfBaseDuration: 0\nsibling: null\nstateNode: null\ntag: 3\ntreeBaseDuration: 0\ntype: null\nupdateQueue: null\n_debugHookTypes: null\n_debugID: 1\n_debugNeedsRemount: false\n_debugOwner: null\n_debugSource: null\n[[Prototype]]: Object\nthis: undefined\nmode: 8\ntag: 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\nWorkTag 是怎么分类的，Fiber 标记了哪些类型？\n\n// src/react/packages/react-reconciler/src/ReactWorkTags.js\nexport type WorkTag =\n  | 0\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12\n  | 13\n  | 14\n  | 15\n  | 16\n  | 17\n  | 18\n  | 19\n  | 20\n  | 21\n  | 22\n  | 23\n  | 24;\n\nexport const FunctionComponent = 0; // 函数组件\nexport const ClassComponent = 1; // 类组件\nexport const IndeterminateComponent = 2; // Before we know whether it is function or class // 未知类型组件，在未知为函数组件还是类组件时使用\nexport const HostRoot = 3; // Root of a host tree. Could be nested inside another node. // HostRoot 是包含 RootFiber 信息的容器\nexport const HostPortal = 4; // A subtree. Could be an entry point to a different renderer. // HostPortal 是类型为 Portal 的 HostRoot\nexport const HostComponent = 5;\nexport const HostText = 6;\nexport const Fragment = 7; // React.Fragment 类型\nexport const Mode = 8;\nexport const ContextConsumer = 9; // context.Consumer 类型\nexport const ContextProvider = 10; //  context.Provider 类型\nexport const ForwardRef = 11; // React.forwardRef 类型\nexport const Profiler = 12; \nexport const SuspenseComponent = 13; // suspense 组件类型\nexport const MemoComponent = 14; // memo 组件类型\nexport const SimpleMemoComponent = 15; // 没有 compare 的简单的 memo 组件类型\nexport const LazyComponent = 16; // react.lazy 的组件类型\nexport const IncompleteClassComponent = 17;\nexport const DehydratedFragment = 18;\nexport const SuspenseListComponent = 19;\nexport const ScopeComponent = 21;\nexport const OffscreenComponent = 22;\nexport const LegacyHiddenComponent = 23;\nexport const CacheComponent = 24;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\nFiberNode 中 Fiber 相关的属性构成了怎样的 FiberTree 的关系？\n\n我们从这张图可以看出：\n\n * FiberRoot 和 RootFiber 的双向链接关系。\n * Fiber 中 child 为子节点指针，sibling 为兄弟节点指针，return 为父节点指针，这三个指针共同构成了 FiberTree 的数据结构。注意 sibling 只指向下一个兄弟节点。\n * 从整体上看，child 指针和 return 指针决定了深度关系，而 sibling 指针决定了广度关系。return 指针决定了 FiberTree 的可逆性。\n\nLocal Stack\n\n到目前为止，我们来看一下目前的调用栈：\n\n过程如下： render -> legacyRenderSubtreeIntoContainer -> legacyCreateRootFromDOMContainer -> createContainer -> createFiberRoot -> createHostRootFiber -> createFiber -> ...\n\n\n# flushSync\n\n从上面的过程，已经创建了 HostRoot 和 RootFiber，以及\n\nflushSync(() => {\n  updateContainer(children, fiberRoot, parentComponent, callback);\n});\n\n\n1\n2\n3\n\n\nflushSync 函数处理同步渲染，在传入的回调中调用了 updateContainer 函数。\n\n下面是 flushSync 函数：\n\n// Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\ndeclare function flushSync<R>(fn: () => R): R;\n// eslint-disable-next-line no-redeclare\ndeclare function flushSync(): void;\n// eslint-disable-next-line no-redeclare\nexport function flushSync(fn) {\n  // In legacy mode, we flush pending passive effects at the beginning of the\n  // next event, not at the end of the previous one.\n  // rootWithPendingPassiveEffects 表示当前已经 commit 的 HostRoot\n  // 如果当前已存在 commit 的 HostRoot，且当前执行阶段不是 RenderContext 或者 CommitContext，则 flush 所有待渲染的副作用\n  if (\n    rootWithPendingPassiveEffects !== null &&\n    rootWithPendingPassiveEffects.tag === LegacyRoot &&\n    (executionContext & (RenderContext | CommitContext)) === NoContext\n  ) {\n    flushPassiveEffects();\n  }\n\n  const prevExecutionContext = executionContext;\n  // executionContext 指向 BatchedContext\n  executionContext |= BatchedContext;\n\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  const previousPriority = getCurrentUpdatePriority();\n  try {\n    ReactCurrentBatchConfig.transition = 0;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    if (fn) {\n      return fn();\n    } else {\n      return undefined;\n    }\n  } finally {\n    // 如果 fn 执行 抛出了错误，则回退至之前的状态\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n    executionContext = prevExecutionContext;\n    // Flush the immediate callbacks that were scheduled during this batch.\n    // Note that this will happen even if batchedUpdates is higher up\n    // the stack.\n    // flush 本次 batch 中高优先级的 callbacks\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n      flushSyncCallbacks();\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n * flushSync 使用了 ts 的函数重载，如果传入回调，会执行这个回调。\n * 从整体来看，flushSync 主要调用了 flushPassiveEffects 函数来处理已经 commit 的 HostRoot 上的待执行的副作用。\n * flushSync 会先对已经 commit 的内容执行 flushPassiveEffects，执行完毕后才进入 BatchedContext 阶段。\n * 注意，在首次渲染时 rootWithPendingPassiveEffects 应该为 null，也就是说 flushPassiveEffects 不会被执行到，但是我们仍然来分析下 flushPassiveEffects 会做些什么事情。\n\n\n# flushPassiveEffects\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nexport function flushPassiveEffects(): boolean {\n  // Returns whether passive effects were flushed.\n  // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n  // probably just combine the two functions. I believe they were only separate\n  // in the first place because we used to wrap it with\n  // `Scheduler.runWithPriority`, which accepts a function. But now we track the\n  // priority within React itself, so we can mutate the variable directly.\n  if (rootWithPendingPassiveEffects !== null) {\n    // Cache the root since rootWithPendingPassiveEffects is cleared in\n    // flushPassiveEffectsImpl\n    // 这里缓存 root 是为了在发生错误回滚时即时释放缓存池\n    const root = rootWithPendingPassiveEffects;\n    // Cache and clear the remaining lanes flag; it must be reset since this\n    // method can be called from various places, not always from commitRoot\n    // where the remaining lanes are known\n    // 重置 remainingLanes\n    const remainingLanes = pendingPassiveEffectsRemainingLanes;\n    pendingPassiveEffectsRemainingLanes = NoLanes;\n\n    const renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n    const priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    const previousPriority = getCurrentUpdatePriority();\n    try {\n      ReactCurrentBatchConfig.transition = 0;\n      setCurrentUpdatePriority(priority);\n      return flushPassiveEffectsImpl();\n    } finally {\n      // flushPassiveEffectsImpl 发生错误后回滚只上一状态\n      setCurrentUpdatePriority(previousPriority);\n      ReactCurrentBatchConfig.transition = prevTransition;\n\n      // Once passive effects have run for the tree - giving components a\n      // chance to retain cache instances they use - release the pooled\n      // cache at the root (if there is one)\n      releaseRootPooledCache(root, remainingLanes);\n    }\n  }\n  return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n这个函数主要调用 flushPassiveEffectsImpl 函数。\n\nfunction flushPassiveEffectsImpl() {\n  if (rootWithPendingPassiveEffects === null) {\n    return false;\n  }\n\n  const root = rootWithPendingPassiveEffects;\n  const lanes = pendingPassiveEffectsLanes;\n  // 由于这里的 PassiveEffects 将会被 flush，这里将之清空\n  rootWithPendingPassiveEffects = null;\n  // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n  // Figure out why and fix it. It's not causing any known issues (probably\n  // because it's only used for profiling), but it's a refactor hazard.\n  pendingPassiveEffectsLanes = NoLanes;\n\n  // Render 阶段和 Commit 阶段是不能 flush 的\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Cannot flush passive effects while already rendering.');\n  }\n\n  const prevExecutionContext = executionContext;\n  // 将 executionContext 更新为 CommitContext，因为现在进入了 Commit 阶段\n  executionContext |= CommitContext;\n\n  // 这里将 passiveEffects 分成了 Mount 和 Unmount 阶段，这两类都需要 commit，但是处理的逻辑不同\n  commitPassiveUnmountEffects(root.current);\n  commitPassiveMountEffects(root, root.current);\n\n  executionContext = prevExecutionContext;\n\n  // 所有的同步的 callback 都需要 flush\n  flushSyncCallbacks();\n\n  // If additional passive effects were scheduled, increment a counter. If this\n  // exceeds the limit, we'll fire a warning.\n  // nestedPassiveUpdateCount 计数器递增，防止造成死循环\n  nestedPassiveUpdateCount =\n    rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;\n  return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n * flush effects 的目的是 commit effects。\n\n\n# flushSyncCallbacks\n\n// src/react/packages/react-reconciler/src/ReactFiberSyncTaskQueue.new.js\nexport function flushSyncCallbacks() {\n  // isFlushingSyncQueue 是 syncQueue 的互斥锁 \n  if (!isFlushingSyncQueue && syncQueue !== null) {\n    // Prevent re-entrance.\n    isFlushingSyncQueue = true;\n    let i = 0;\n    const previousUpdatePriority = getCurrentUpdatePriority();\n    try {\n      const isSync = true;\n      const queue = syncQueue;\n      // TODO: Is this necessary anymore? The only user code that runs in this\n      // queue is in the render or commit phases.\n      setCurrentUpdatePriority(DiscreteEventPriority);\n      // flush syncQueue，每个 callback 可以返回一个新的 callback\n      for (; i < queue.length; i++) {\n        let callback = queue[i];\n        do {\n          callback = callback(isSync);\n        } while (callback !== null);\n      }\n      // 重置 syncQueue\n      syncQueue = null;\n      includesLegacySyncCallbacks = false;\n    } catch (error) {\n      // If something throws, leave the remaining callbacks on the queue.\n      // 如果syncQueue 中每个 RootCallback 发生了错误，则跳过此项\n      if (syncQueue !== null) {\n        syncQueue = syncQueue.slice(i + 1);\n      }\n      // Resume flushing in the next tick\n      // 调度在下一个 tick 中继续执行\n      scheduleCallback(ImmediatePriority, flushSyncCallbacks);\n      throw error;\n    } finally {\n      setCurrentUpdatePriority(previousUpdatePriority);\n      isFlushingSyncQueue = false;\n    }\n  }\n  return null;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n可以看到，flushSyncCallbacks 主要是在执行完 syncQueue 中的所有的回调，syncQueue 中的 callback 可以返回一个新的 callback，这种结构类似于数组 + 链表和结构，很是巧妙。这段代码中 syncQueue 的数据结构、flush syncQueue 的处理方式和错误处理方式，值得我们借鉴。这种消费 effect 的方式和 react 中响应式 effect 的消费很像。\n\n * 因为 syncQueue 是公共资源，而 flushSyncCallbacks 是其消费者，因此消费者在消费 syncQueue 时需要添加互斥锁，以免造成资源争夺。\n * 出现错误时并不是直接继续执行，而是放到了 next tick 中继续消费，提高了 syncQueue 消费的效率。\n\n\n# updateContainer\n\nupdateContainer 是首次渲染中重要工作中的一项。\n\nexport function updateContainer(\n  element: ReactNodeList,\n  container: OpaqueRoot,\n  parentComponent: ?React$Component<any, any>,\n  callback: ?Function,\n): Lane {\n  // 获取 RootFiber\n  const current = container.current;\n  const eventTime = requestEventTime();\n  const lane = requestUpdateLane(current);\n\n  // 更新 container 的 context 信息\n  const context = getContextForSubtree(parentComponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  // 创建一个更新\n  const update = createUpdate(eventTime, lane);\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = {element};\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    update.callback = callback;\n  }\n\n  // 将新建的更新入栈\n  enqueueUpdate(current, update, lane);\n  // 请求一次调度更新\n  const root = scheduleUpdateOnFiber(current, lane, eventTime);\n  if (root !== null) {\n    entangleTransitions(root, current, lane);\n  }\n\n  return lane;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\nupdateContainer 函数中主要是针对 RootFiber 创建了一次更新，加入到更新队列，并且请求调度器进行调度。调度更新部分，请参照 scheduleWork 与调度过程 。\n\n\n# 小结\n\n通过上面的分析过程可知，React 的首次渲染的流程如下：首先执行一系列的初始化工作，包括创建 HostRoot 和 FiberRoot 以及建立两者之间的关联、初始化事件委托系统，然后创建一个同步的更新并向调度器提交调度请求。\n\n\n# Q&A\n\n\n# executionContext 有哪几种？\n\nexecutionContext 表示 React 当前执行的上下文阶段，通过 executionContext 我们可以大致分出其总体渲染流程的不同阶段。\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nexport const NoContext = /*             */ 0b0000;\nconst BatchedContext = /*               */ 0b0001; // Batch(批处理)阶段\nconst RenderContext = /*                */ 0b0010; // Render(渲染)阶段\nconst CommitContext = /*                */ 0b0100; // Commit(提交)阶段\nexport const RetryAfterError = /*       */ 0b1000; // 错误重试阶段\n\n// Describes where we are in the React execution stack\nlet executionContext: ExecutionContext = NoContext;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n全局变量 executionContext 代表当前的执行上下文，初始化为 NoContent。下面是这四个阶段的对照表格:\n\nCONTEXT           所在函数                                       阶段               备注\nNoContext                                                    初始化              初始阶段\nBatchedContext    flushSync、batchedUpdates、flushControlled   Batch (批处理) 阶段   RenderSubtreeIntoContainer 之后，renderRoot 之前\nRenderContext     renderRootSync、renderRootConcurrent        Render (渲染) 阶段   renderRoot 之后，commitRoot 之前\nCommitContext     commitRootImpl、flushPassiveEffectsImpl     Commit (提交) 阶段   commitRoot 之后\nRetryAfterError   recoverFromConcurrentError                 Error 阶段         发生错误需要恢复之后\n\n从表格可以总结出，React 的渲染总共分为 NoContext、BatchedContext、RenderContext、CommitContext、RetryAfterError 五个阶段。关于更新阶段的更多内容，请移步 React 更新周期。\n\n\n# 使用位运算提高枚举计算效率\n\nReact 中多处使用位运算进行枚举计算，使用位运算可以有效提交运行效率，尤其是大型的状态繁多的项目。在 react 源码中有很多类似的位运算，比如 effectTag，workTag 和上文中的 executionContext。\n\n下面我们来看看 React 中位运算枚举风格：\n\nconst NoContext = 0b0000;\nconst BatchedContext =  0b0001; \nconst RenderContext =  0b0010; \nconst CommitContext =  0b0100;\nconst RetryAfterError = 0b1000;\n\nlet executionContext = NoContext;\n\n// 如果现在开始 RenderContainer，进入 Batch 阶段\n// 增加枚举值\nexecutionContext |= BatchedContext; // 1\n// 判断是否在 Batch 阶段\n// 消费枚举值：0 表示没有枚举值，1 表示有枚举值。这里我们直接跟为 0 的 NoContext 作比较。\n(executionContext & BatchedContext) !== NoContext; // true\n// 判断是否处于 Render 阶段\n(executionContext & RenderContext) !== NoContext; // false\n// 现在开始 RenderRoot，进入 Render 阶段\nexecutionContext |= RenderContext;\n// 判断是否处于 Batch 阶段或者 Render 阶段\n(executionContext & (BatchedContext | RenderContext)) !== NoContext; // true\n// 判断是否不处于 Commit 阶段或者 Error 阶段\n(executionContext & (CommitContext | RetryAfterError)) === NoContext; // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n下面我们再来对比一些 Vue 源码中使用位运算的风格。\n\nconst enum ShapeFlags {\n  ELEMENT = 1,\n  FUNCTIONAL_COMPONENT = 1 << 1,\n  STATEFUL_COMPONENT = 1 << 2,\n  TEXT_CHILDREN = 1 << 3,\n  ARRAY_CHILDREN = 1 << 4,\n  SLOTS_CHILDREN = 1 << 5,\n  TELEPORT = 1 << 6,\n  SUSPENSE = 1 << 7,\n  COMPONENT_SHOULD_KEEP_ALIVE = 1 << 8,\n  COMPONENT_KEPT_ALIVE = 1 << 9,\n  COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n写法不一样，使用的方法是一样的。\n\n这种原理是什么？这是因为这些枚举数字是互相正交的（可以从数学上垂直的概念来理解），也可以从二进制为进行理解，没加入一个枚举值，在相应的下标出置为 1（按位或运算），判断是否有这个枚举值的时候，就可以那要判断的值与枚举值对齐比对（按位与运算）。\n\n位运算的更多技巧请参考文章：位运算初探\n\n\n# 参考资料\n\n * 深入理解 React 源码 - 首次渲染\n * 深入剖析 React Concurrent\n * React 的第一次渲染过程浅析",normalizedContent:"# 目录\n\n\n\n * 目录\n * reactdom.render\n   * jsxwithvalidation\n   * render\n * legacyrendersubtreeintocontainer\n * createfiberroot\n * createhostrootfiber\n * flushsync\n   * flushpassiveeffects\n   * flushsynccallbacks\n * updatecontainer\n * 小结\n * q&a\n   * executioncontext 有哪几种？\n   * 使用位运算提高枚举计算效率\n * 参考资料\n\n\n\n注意\n\n * 本文的代码去除了 dev 环境的部分代码。\n\n\n# reactdom.render\n\n通过在 reactdom.render 语句添加断点，我们来追溯一下 react 的首次渲染过程。\n\n\n# jsxwithvalidation\n\n首先开始验证 <app /> 组件是否是合法的 jsx 组件。如果不合法，就打印错误消息和错误栈信息。\n\n// src/react/fixtures/legacy-jsx-runtimes/react-17/cjs/react-jsx-dev-runtime.development.js\nfunction jsxwithvalidation(type, props, key, isstaticchildren, source, self) {\n  {\n    var validtype = isvalidelementtype(type); // we warn in this case but don't throw. we expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validtype) {\n      // pass \n      // 报错处理\n    }\n\n    // 返回一个 reactelement 对象\n    var element = jsxdev(type, props, key, source, self); // the result can be nullish if a mock or a custom function is used.\n    // todo: drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // we don't want exception behavior to differ between dev and prod.\n    // (rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validtype) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        // isstaticchildren 则校验 key 值\n        if (isstaticchildren) {\n          if (array.isarray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validatechildkeys(children[i], type);\n            }\n\n            if (object.freeze) {\n              object.freeze(children);\n            }\n          } else {\n            error('react.jsx: static children should always be an array. ' + 'you are likely explicitly calling react.jsxs or react.jsxdev. ' + 'use the babel transform instead.');\n          }\n        } else {\n          validatechildkeys(children, type);\n        }\n      }\n    }\n\n    if (type === exports.fragment) {\n      validatefragmentprops(element);\n    } else {\n      validateproptypes(element);\n    }\n\n    return element;\n  }\n}\n// local stack\n// {\n//   \"props\": {},\n//   \"isstaticchildren\": false,\n//   \"source\": {\n//     \"filename\": \"/users/jonsam/projects/update_in_github/react-source-reading/src/index.js\",\n//     \"linenumber\": 9,\n//     \"columnnumber\": 5\n//   },\n//   \"validtype\": true,\n//   \"element\": {\n//     \"key\": null,\n//     \"ref\": null,\n//     \"props\": {},\n//     \"_owner\": null,\n//     \"_store\": {}\n//   }\n// }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n那么如何判断是否是合法的 element 呢？\n\nfunction isvalidelementtype(type) {\n  // 如果是 string 和 function 是合法的 element，分别代表着文本节点和 fc\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n  // 判断 type 是否为 fragment，profiler，suspense 之类的特殊类型\n  if (type === exports.fragment || type === react_profiler_type || type === react_debug_tracing_mode_type || type === react_strict_mode_type || type === react_suspense_type || type === react_suspense_list_type || type === react_legacy_hidden_type || enablescopeapi ) {\n    return true;\n  }\n\n  // 判断 $$typeof 书否为内部类型，lazy、memo、provider、context、forward_ref 等\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === react_lazy_type || type.$$typeof === react_memo_type || type.$$typeof === react_provider_type || type.$$typeof === react_context_type || type.$$typeof === react_forward_ref_type || type.$$typeof === react_fundamental_type || type.$$typeof === react_block_type || type[0] === react_server_block_type) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\njsxdev 如何返回一个 reactelement 呢？\n\nvar reactelement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // this tag allows us to uniquely identify this as a react element\n    // 添加 reactelement 的 $$typeof 类型\n    $$typeof: react_element_type,\n    // built-in properties that belong on the element\n    // 节点实际的类型，此处为 function\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // the validation flag is currently mutative. we put it on\n    // an external backing store so that we can freeze the whole object.\n    // this can be replaced with a weakmap once they are implemented in\n    // commonly used development environments.\n    // 使用外部的代码块防止变量因为 _store 的引用而不能释放，可以放 weakmap 代替，给 element 添加类似于 weakmap 的 _store 属性\n    element._store = {}; // to make comparing reactelements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    object.defineproperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are dev only properties.\n\n    object.defineproperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    object.defineproperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (object.freeze) {\n      object.freeze(element.props);\n      object.freeze(element);\n    }\n  }\n\n  return element;\n};\n// local stack\n// {\n//   \"config\": {},\n//   \"source\": {\n//     \"filename\": \"/users/jonsam/projects/update_in_github/react-source-reading/src/index.js\",\n//     \"linenumber\": 9,\n//     \"columnnumber\": 5\n//   },\n//   \"props\": {},\n//   \"key\": null,\n//   \"ref\": null\n// }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n * reactelement 是一个工厂函数，传入相关的属性，生成 reactelement 对象。\n * reactelement 中 $$typeof 是指内部的节点类型，reactelement 的内部类型为 react_element_type ，type 是指实际的节点类型，此处是一个 function。\n * 在测试环境下会在 reactelement 上挂载 _store 属性，类似于 weakmap 是为了节省内存，目的是为了开发环境中测试提速。\n\n\n# render\n\n// src/react/packages/react-dom/src/client/reactdomlegacy.js\nfunction render(\n  element: react$element<any>,\n  container: container,\n  callback: ?function,\n){\n  if (!isvalidcontainerlegacy(container)) {\n    throw new error('target container is not a dom element.');\n  }\n  return legacyrendersubtreeintocontainer(\n    null,\n    element,\n    container,\n    false,\n    callback,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nlocal stack\n\n生成 reactelement 之后调用 render 方法，内部判断是否是合法的 container，然后调用 legacyrendersubtreeintocontainer 方法将 subtree 渲染到 container 中。\n\n怎么判断是否是合法的 container 呢？\n\n// we only use it in places that are currently more relaxed.\nexport function isvalidcontainerlegacy(node: any): boolean {\n  // 通过 node.nodetype 来判断 node 是否是已知的类型\n  return !!(\n    node &&\n    (node.nodetype === element_node ||\n      node.nodetype === document_node ||\n      node.nodetype === document_fragment_node ||\n      (node.nodetype === comment_node &&\n        (node: any).nodevalue === ' react-mount-point-unstable '))\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nlocal stack\n\n去除可访问性和事件之后的属性：\n\nassignedslot: null\nattributestylemap: stylepropertymap {size: 0}\nattributes: namednodemap {0: id, id: id, length: 1}\nautocapitalize: \"\"\nautofocus: false\nbaseuri: \"http://localhost:3001/\"\nchildelementcount: 0\nchildnodes: nodelist []\nchildren: htmlcollection []\nclasslist: domtokenlist [value: '']\nclassname: \"\"\nclientheight: 0\nclientleft: 0\nclienttop: 0\nclientwidth: 1792\ncontenteditable: \"inherit\"\ndataset: domstringmap {}\ndir: \"\"\ndraggable: false\nelementtiming: \"\"\nenterkeyhint: \"\"\nfirstchild: null\nfirstelementchild: null\nhidden: false\nid: \"root\"\ninnerhtml: \"\"\ninnertext: \"\"\ninputmode: \"\"\nisconnected: true\niscontenteditable: false\nlang: \"\"\nlastchild: null\nlastelementchild: null\nlocalname: \"div\"\nnamespaceuri: \"http://www.w3.org/1999/xhtml\"\nnextelementsibling: null\nnextsibling: text\nnodename: \"div\"\nnodetype: 1\nnodevalue: null\nnonce: \"\"\noffsetheight: 0\noffsetleft: 0\noffsetparent: body\noffsettop: 0\noffsetwidth: 1792\nouterhtml: \"<div id=\\\"root\\\"></div>\"\noutertext: \"\"\nownerdocument: document\nparentelement: body\nparentnode: body\npart: domtokenlist [value: '']\nprefix: null\npreviouselementsibling: noscript\nprevioussibling: text\nscrollheight: 0\nscrollleft: 0\nscrolltop: 0\nscrollwidth: 1792\nshadowroot: null\nslot: \"\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n可以看到，这里 nodetype: 1，即为 element_node。\n\n\n# legacyrendersubtreeintocontainer\n\n// src/react/packages/react-dom/src/client/reactdomlegacy.js\nfunction legacyrendersubtreeintocontainer(\n  parentcomponent: ?react$component<any, any>,\n  children: reactnodelist,\n  container: container,\n  forcehydrate: boolean,\n  callback: ?function,\n) {\n  // 判断是否已经创建过 rootcontainer \n  // _reactrootcontainer 标记为 container 上的 fiberroot 对象\n  let root = container._reactrootcontainer;\n  let fiberroot: fiberroot;\n  if (!root) {\n    // initial mount\n    // rootcontainer 未创建则为首次挂载应用，调用 legacycreaterootfromdomcontainer 创建 root \n    root = container._reactrootcontainer = legacycreaterootfromdomcontainer(\n      container,\n      forcehydrate,\n    );\n    fiberroot = root;\n    // 如果在 render 函数中传入了 callback，需要调用 callback\n    if (typeof callback === 'function') {\n      const originalcallback = callback;\n      callback = function() {\n        const instance = getpublicrootinstance(fiberroot);\n        originalcallback.call(instance);\n      };\n    }\n    // initial mount should not be batched.\n    // 在 mount 阶段，以最高优先级同步的执行所有的更新\n    flushsync(() => {\n      updatecontainer(children, fiberroot, parentcomponent, callback);\n    });\n  } else {\n    fiberroot = root;\n    if (typeof callback === 'function') {\n      const originalcallback = callback;\n      callback = function() {\n        const instance = getpublicrootinstance(fiberroot);\n        originalcallback.call(instance);\n      };\n    }\n    // update\n    updatecontainer(children, fiberroot, parentcomponent, callback);\n  }\n  return getpublicrootinstance(fiberroot);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\nlocal stack\n\n当前传入的变量：\n\ncallback: undefined\nchildren: {$$typeof: symbol(react.element), type: symbol(react.strict_mode), key: null, ref: null, props: {…}, …}\ncontainer: div#root\nfiberroot: undefined\nforcehydrate: false\noriginalcallback: undefined\nparentcomponent: null\nroot: undefined\n_originalcallback: undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nrender 函数中 callback 返回当前容器（container）中的 fiberroot 对象，由下面这个递归的函数可见：\n\nexport function getpublicrootinstance(\n  container: opaqueroot,\n): react$component<any, any> | publicinstance | null {\n  const containerfiber = container.current;\n  if (!containerfiber.child) {\n    return null;\n  }\n  switch (containerfiber.child.tag) {\n    case hostcomponent:\n      return getpublicinstance(containerfiber.child.statenode);\n    default:\n      // 最终返回的有效的 instance 是 fiber.child.statenode 刚好是 rootfiber\n      return containerfiber.child.statenode;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# legacycreaterootfromdomcontainer\n\nrootcontainer 是如何根据 container 创建的呢？我们来追溯下 legacycreaterootfromdomcontainer 函数：\n\nfunction legacycreaterootfromdomcontainer(\n  container: container,\n  forcehydrate: boolean,\n): fiberroot {\n  // first clear any existing content.\n  // 如果不是 ssr，就清空 container 中所有的节点\n  if (!forcehydrate) {\n    let rootsibling;\n    while ((rootsibling = container.lastchild)) {\n      container.removechild(rootsibling);\n    }\n  }\n\n  // 调用 createcontainer 创建 rootcontainer\n  const root = createcontainer(\n    container,\n    // export const legacyroot = 0;\n    // export const concurrentroot = 1;\n    legacyroot,\n    forcehydrate,\n    null, // hydrationcallbacks\n    false, // isstrictmode\n    false, // concurrentupdatesbydefaultoverride,\n    '', // identifierprefix\n  );\n  // 将 fiberroot 挂载到 container 上，便于下次使用\n  markcontainerasroot(root.current, container);\n\n  const rootcontainerelement =\n    container.nodetype === comment_node ? container.parentnode : container;\n  // 开启 container 上所支持的事件监听\n  listentoallsupportedevents(rootcontainerelement);\n\n  return root;\n}\n\n// src/react/packages/react-reconciler/src/reactfiberreconciler.new.js\nexport function createcontainer(\n  containerinfo: container,\n  tag: roottag,\n  hydrate: boolean,\n  hydrationcallbacks: null | suspensehydrationcallbacks,\n  isstrictmode: boolean,\n  concurrentupdatesbydefaultoverride: null | boolean,\n  identifierprefix: string,\n): opaqueroot {\n  return createfiberroot(\n    containerinfo,\n    tag,\n    hydrate,\n    hydrationcallbacks,\n    isstrictmode,\n    concurrentupdatesbydefaultoverride,\n    identifierprefix,\n  );\n}\n\n// src/react/packages/react-dom/src/client/reactdomcomponenttree.js\nexport function markcontainerasroot(hostroot: fiber, node: container): void {\n  // 将 fiberroot 挂载到相应的 container 上\n  // internalcontainerinstancekey： \"__reactfiber$9yvlviys3ft\"\n  node[internalcontainerinstancekey] = hostroot;\n}\n// randomkey 是每次启动应用生成的随机的 key 值，被应用在内部一些 key 值的使用上\nconst randomkey = math.random()\n  .tostring(36)\n  .slice(2);\nconst internalcontainerinstancekey = '__reactcontainer$' + randomkey;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n * rootcontainer 分为了两种：legacyroot 和 concurrentroot。分别代表着这 react 运行的两种模式：legacy mode 和 concurrent mode。\n * rootcontainer 实际上就是 fiberroot。这里开始了从 reactelement 到 fiberroot 的创建过程。注意 fiberroot（hostroot） 本质上是 root，不是 fiber；而 rootfiber 才是 fiber，才是 fibertree 的根。\n * randomkey 之所以要随机生成，有以下两点原因：标记是打在 node 这样的原生节点上的，随机的标记名可以防止将用户或者其他库所生成的标记覆盖，同时加上 __reactcontainer$ 这样的特征串更能防止重复；随机的标记更加安全，防止被其他程序更改或者恶意篡改造成程序崩溃。\n\n# listentoallsupportedevents\n\ncontainer 上的事件是如何委托监听的呢，我们来看下 listentoallsupportedevents 这个函数：\n\n// src/react/packages/react-dom/src/events/domplugineventsystem.js\n// 为当前的应用生成随机的监听器标记\nconst listeningmarker =\n  '_reactlistening' +\n  math.random()\n    .tostring(36)\n    .slice(2);\n// we should not delegate these events to the container, but rather\n// set them on the actual target element itself. this is primarily\n// because these events do not consistently bubble in the dom.\n// 如下事件不能委托在 container 上，需要设置在实际的 target element 上，这是因为他们不能持续的冒泡。\n// 不能持续冒泡的事件的集合\nexport const nondelegatedevents: set<domeventname> = new set([\n  'cancel',\n  'close',\n  'invalid',\n  'load',\n  'scroll',\n  'toggle',\n  // in order to reduce bytes, we insert the above array of media events\n  // into this set. note: the \"error\" event isn't an exclusive media event,\n  // and can occur on other elements too. rather than duplicate that event,\n  // we just take it from the media events array.\n  // 将媒体先关的事件加入这里以节省内存。\n  ...mediaeventtypes,\n]);\n// list of events that need to be individually attached to media elements.\nexport const mediaeventtypes: array<domeventname> = [\n  'abort',\n  'canplay',\n  'canplaythrough',\n  'durationchange',\n  'emptied',\n  'encrypted',\n  'ended',\n  'error',\n  'loadeddata',\n  'loadedmetadata',\n  'loadstart',\n  'pause',\n  'play',\n  'playing',\n  'progress',\n  'ratechange',\n  'resize',\n  'seeked',\n  'seeking',\n  'stalled',\n  'suspend',\n  'timeupdate',\n  'volumechange',\n  'waiting',\n];\nexport function listentoallsupportedevents(rootcontainerelement: eventtarget) {\n  if (!(rootcontainerelement: any)[listeningmarker]) {\n    // 将事件监听标记设为 true，防止重复监听\n    (rootcontainerelement: any)[listeningmarker] = true;\n    allnativeevents.foreach(domeventname => {\n      // we handle selectionchange separately because it\n      // doesn't bubble and needs to be on the document.\n      // 除 selectionchange 事件之外，其余事件如果可以持续的冒泡，就开启原生事件监听，从冒泡阶段监听；如果无法持续冒泡，从捕获阶段监听。\n      // selectionchange 将会单独处理，因为此事件不允许冒泡，而且必须在 document 上监听\n      if (domeventname !== 'selectionchange') {\n        if (!nondelegatedevents.has(domeventname)) {\n          listentonativeevent(domeventname, false, rootcontainerelement);\n        }\n        listentonativeevent(domeventname, true, rootcontainerelement);\n      }\n    });\n    // 获取 container 所在的 document \n    const ownerdocument =\n      (rootcontainerelement: any).nodetype === document_node\n        ? rootcontainerelement\n        : (rootcontainerelement: any).ownerdocument;\n    if (ownerdocument !== null) {\n      // the selectionchange event also needs deduplication\n      // but it is attached to the document.\n      if (!(ownerdocument: any)[listeningmarker]) {\n        // 在 container 所在的 document 上单独监听 selectionchange 事件\n        (ownerdocument: any)[listeningmarker] = true;\n        listentonativeevent('selectionchange', false, ownerdocument);\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n\n先总结一下如上的代码：\n\n * react 中为提高应用的性能，采用了事件委托机制来来统一处理事件。事件被委托到 container 上或者是 document 上。\n * react 将事件分为三类，一类是可以在冒泡过程中监听的，一类是可以在冒泡过程中监听需要在捕获中监听的，还有一类是在 document 上监听的，如 selectionchange。\n * react 将所有的原生事件都委托了一遍，原因在于基于 react 子树的时间监听将统一由受委托的容器来进行监听。\n\n以上是 react 事件监听的策略，真正的时间监听在函数 listentonativeevent 实现。那么 listentonativeevent 是如何监听原生事件的呢？请参见 react 中的事件监听机制\n\n\n# createfiberroot\n\nexport function createfiberroot(\n  containerinfo: any,\n  tag: roottag,\n  hydrate: boolean,\n  hydrationcallbacks: null | suspensehydrationcallbacks,\n  isstrictmode: boolean,\n  concurrentupdatesbydefaultoverride: null | boolean,\n  identifierprefix: string,\n): fiberroot {\n  // 根据 containerinfo 等信息创建 fiberroot 对象\n  const root: fiberroot = (new fiberrootnode(\n    containerinfo,\n    tag,\n    hydrate,\n    identifierprefix,\n  ): any);\n  if (enablesuspensecallback) {\n    root.hydrationcallbacks = hydrationcallbacks;\n  }\n\n  // cyclic construction. this cheats the type system right now because\n  // statenode is any.\n  // 创建与 hostroot 强关联的 rootfiber\n  const uninitializedfiber = createhostrootfiber(\n    tag,\n    isstrictmode,\n    concurrentupdatesbydefaultoverride,\n  );\n  // hostroot 与 rootfiber 双向链接 hostroot.current = rootfiber; rootfiber.statenode = hostroot\n  root.current = uninitializedfiber;\n  uninitializedfiber.statenode = root;\n\n  // 初始化 rootfiber 上的更新队列\n  initializeupdatequeue(uninitializedfiber);\n\n  return root;\n}\nfunction fiberrootnode(containerinfo, tag, hydrate, identifierprefix) {\n  this.tag = tag;\n  this.containerinfo = containerinfo;\n  this.pendingchildren = null;\n  this.current = null;\n  this.pingcache = null;\n  this.finishedwork = null;\n  this.timeouthandle = notimeout;\n  this.context = null;\n  this.pendingcontext = null;\n  this.isdehydrated = hydrate;\n  this.callbacknode = null;\n  this.callbackpriority = nolane;\n  this.eventtimes = createlanemap(nolanes);\n  this.expirationtimes = createlanemap(notimestamp);\n\n  this.pendinglanes = nolanes;\n  this.suspendedlanes = nolanes;\n  this.pingedlanes = nolanes;\n  this.expiredlanes = nolanes;\n  this.mutablereadlanes = nolanes;\n  this.finishedlanes = nolanes;\n\n  this.entangledlanes = nolanes;\n  this.entanglements = createlanemap(nolanes);\n\n  this.identifierprefix = identifierprefix;\n\n  if (enablecache) {\n    this.pooledcache = null;\n    this.pooledcachelanes = nolanes;\n  }\n\n  if (supportshydration) {\n    this.mutablesourceeagerhydrationdata = null;\n  }\n\n  if (enablesuspensecallback) {\n    this.hydrationcallbacks = null;\n  }\n\n  if (enableprofilertimer && enableprofilercommithooks) {\n    this.effectduration = 0;\n    this.passiveeffectduration = 0;\n  }\n\n  if (enableupdatertracking) {\n    this.memoizedupdaters = new set();\n    const pendingupdaterslanemap = (this.pendingupdaterslanemap = []);\n    for (let i = 0; i < totallanes; i++) {\n      pendingupdaterslanemap.push(new set());\n    }\n  }\n}\n// 在 fiber 上初始化一个更新队列\nexport function initializeupdatequeue<state>(fiber: fiber): void {\n  const queue: updatequeue<state> = {\n    basestate: fiber.memoizedstate,\n    firstbaseupdate: null,\n    lastbaseupdate: null,\n    shared: {\n      pending: null,\n      interleaved: null,\n      lanes: nolanes,\n    },\n    effects: null,\n  };\n  fiber.updatequeue = queue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n\n\nlocal stack\n\ncreatefiberroot 函数的变量栈：\n\ncontainerinfo: div#root\nhydrate: false\nhydrationcallbacks: undefined\nroot: fiberrootnode\ncallbacknode: null\ncallbackpriority: 0\ncontainerinfo: div#root\ncontext: null\ncurrent: fibernode\nactualduration: 0\nactualstarttime: -1\nalternate: null\nchild: null\nchildlanes: 0\ndependencies: null\nelementtype: null\nfirsteffect: null\nflags: 0\nindex: 0\nkey: null\nlanes: 0\nlasteffect: null\nmemoizedprops: null\nmemoizedstate: null\nmode: 8\nnexteffect: null\npendingprops: null\nref: null\nreturn: null\nselfbaseduration: 0\nsibling: null\nstatenode: fiberrootnode {tag: 0, containerinfo: div#root, pendingchildren: null, current: fibernode, pingcache: null, …}\ntag: 3\ntreebaseduration: 0\ntype: null\nupdatequeue:\nbasestate: null\neffects: null\nfirstbaseupdate: null\nlastbaseupdate: null\nshared: {pending: null}\n[[prototype]]: object\n_debughooktypes: null\n_debugid: 1\n_debugneedsremount: false\n_debugowner: null\n_debugsource: null\n[[prototype]]: object\nentangledlanes: 0\nentanglements: (31) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\neventtimes: (31) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nexpirationtimes: (31) [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]\nexpiredlanes: 0\nfinishedlanes: 0\nfinishedwork: null\nhydrate: false\ninteractionthreadid: 1\nmemoizedinteractions: set(0) {size: 0}\nmutablereadlanes: 0\nmutablesourceeagerhydrationdata: null\npendingchildren: null\npendingcontext: null\npendinginteractionmap: map(0) {size: 0}\npendinglanes: 0\npingcache: null\npingedlanes: 0\nsuspendedlanes: 0\ntag: 0\ntimeouthandle: -1\n_debugroottype: \"createlegacyroot()\"\n[[prototype]]: object\ntag: 0\nuninitializedfiber: fibernode {tag: 3, key: null, elementtype: null, type: null, statenode: fiberrootnode, …}\nclosure\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# createhostrootfiber\n\nexport function createhostrootfiber(\n  tag: roottag,\n  isstrictmode: boolean,\n  concurrentupdatesbydefaultoverride: null | boolean,\n): fiber {\n  let mode;\n  if (tag === concurrentroot) {\n    mode = concurrentmode;\n    if (isstrictmode === true) {\n      mode |= strictlegacymode;\n\n      if (enablestricteffects) {\n        mode |= stricteffectsmode;\n      }\n    } else if (enablestricteffects && createrootstricteffectsbydefault) {\n      mode |= strictlegacymode | stricteffectsmode;\n    }\n    if (\n      // we only use this flag for our repo tests to check both behaviors.\n      // todo: flip this flag and rename it something like \"forceconcurrentbydefaultfortesting\"\n      !enablesyncdefaultupdates ||\n      // only for internal experiments.\n      (allowconcurrentbydefault && concurrentupdatesbydefaultoverride)\n    ) {\n      mode |= concurrentupdatesbydefaultmode;\n    }\n  } else {\n    mode = nomode;\n  }\n\n  if (enableprofilertimer && isdevtoolspresent) {\n    // always collect profile timings when devtools are present.\n    // this enables devtools to start capturing timing at any point–\n    // without some nodes in the tree having empty base times.\n    mode |= profilemode;\n  }\n\n  return createfiber(hostroot, null, null, mode);\n}\n// this is a constructor function, rather than a pojo constructor, still\n// please ensure we do the following:\n// 1) nobody should add any instance methods on this. instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) nobody should rely on `instanceof fiber` for type testing. we should\n//    always know when it is a fiber.\n// 3) we might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-jit environment.\n// 4) we can easily go from a constructor to a createfiber object literal if that\n//    is faster.\n// 5) it should be easy to port this to a c struct and keep a c implementation\n//    compatible.\n// createfiber 是一个工厂函数，不支持构造器、instanceof 语法\nconst createfiber = function(\n  tag: worktag,\n  pendingprops: mixed,\n  key: null | string,\n  mode: typeofmode,\n): fiber {\n  // $flowfixme: the shapes are exact here but flow doesn't like constructors\n  return new fibernode(tag, pendingprops, key, mode);\n};\nfunction fibernode(\n  tag: worktag,\n  pendingprops: mixed,\n  key: null | string,\n  mode: typeofmode,\n) {\n  // instance\n  this.tag = tag;\n  this.key = key;\n  this.elementtype = null;\n  this.type = null;\n  this.statenode = null;\n\n  // fiber\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingprops = pendingprops;\n  this.memoizedprops = null;\n  this.updatequeue = null;\n  this.memoizedstate = null;\n  this.dependencies = null;\n\n  this.mode = mode;\n\n  // effects\n  this.flags = noflags;\n  this.subtreeflags = noflags;\n  this.deletions = null;\n\n  this.lanes = nolanes;\n  this.childlanes = nolanes;\n\n  this.alternate = null;\n\n  if (enableprofilertimer) {\n    // note: the following is done to avoid a v8 performance cliff.\n    //\n    // initializing the fields below to smis and later updating them with\n    // double values will cause fibers to end up having separate shapes.\n    // this behavior/bug has something to do with object.preventextension().\n    // fortunately this only impacts dev builds.\n    // unfortunately it makes react unusably slow for some applications.\n    // to work around this, initialize the fields below with doubles.\n    //\n    // learn more about this here:\n    // https://github.com/facebook/react/issues/14365\n    // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n    this.actualduration = number.nan;\n    this.actualstarttime = number.nan;\n    this.selfbaseduration = number.nan;\n    this.treebaseduration = number.nan;\n\n    // it's okay to replace the initial doubles with smis after initialization.\n    // this won't trigger the performance cliff mentioned above,\n    // and it simplifies other profiler code (including devtools).\n    this.actualduration = 0;\n    this.actualstarttime = -1;\n    this.selfbaseduration = 0;\n    this.treebaseduration = 0;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n\n * rootfiber 本质上是 fiber 的原因是调用了 createfiber 来构造 fiber，同时传入的 tag 为 hostroot 保证了 fiber 的独特性。\n * fiber 的本质是一个对象。fiber 上的重要属性大致分为三类：instance 相关、fiber 相关、effects 相关、lanes 相关。instance 相关为 fiber 对象实例的属性，tag 为 fiber 上节点类型标记。fiber 相关为 fibertree 的必要指针；effects 相关为 render 过程中副作用的标记。lanes 为优先级相关的属性，alternate 则是版本记录的属性。\n * uninitializedfiber 不是完整的 rootfiber，其中只初始化了 instance 相关 的属性。\n\n注意\n\n * tag 不是 fiber 的类型，而是 fiber 上标记的节点的类型。\n\nlocal stack\n\nreturn value: fibernode\nactualduration: 0\nactualstarttime: -1\nalternate: null\nchild: null\nchildlanes: 0\ndependencies: null\nelementtype: null\nfirsteffect: null\nflags: 0\nindex: 0\nkey: null\nlanes: 0\nlasteffect: null\nmemoizedprops: null\nmemoizedstate: null\nmode: 8\nnexteffect: null\npendingprops: null\nref: null\nreturn: null\nselfbaseduration: 0\nsibling: null\nstatenode: null\ntag: 3\ntreebaseduration: 0\ntype: null\nupdatequeue: null\n_debughooktypes: null\n_debugid: 1\n_debugneedsremount: false\n_debugowner: null\n_debugsource: null\n[[prototype]]: object\nthis: undefined\nmode: 8\ntag: 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\nworktag 是怎么分类的，fiber 标记了哪些类型？\n\n// src/react/packages/react-reconciler/src/reactworktags.js\nexport type worktag =\n  | 0\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12\n  | 13\n  | 14\n  | 15\n  | 16\n  | 17\n  | 18\n  | 19\n  | 20\n  | 21\n  | 22\n  | 23\n  | 24;\n\nexport const functioncomponent = 0; // 函数组件\nexport const classcomponent = 1; // 类组件\nexport const indeterminatecomponent = 2; // before we know whether it is function or class // 未知类型组件，在未知为函数组件还是类组件时使用\nexport const hostroot = 3; // root of a host tree. could be nested inside another node. // hostroot 是包含 rootfiber 信息的容器\nexport const hostportal = 4; // a subtree. could be an entry point to a different renderer. // hostportal 是类型为 portal 的 hostroot\nexport const hostcomponent = 5;\nexport const hosttext = 6;\nexport const fragment = 7; // react.fragment 类型\nexport const mode = 8;\nexport const contextconsumer = 9; // context.consumer 类型\nexport const contextprovider = 10; //  context.provider 类型\nexport const forwardref = 11; // react.forwardref 类型\nexport const profiler = 12; \nexport const suspensecomponent = 13; // suspense 组件类型\nexport const memocomponent = 14; // memo 组件类型\nexport const simplememocomponent = 15; // 没有 compare 的简单的 memo 组件类型\nexport const lazycomponent = 16; // react.lazy 的组件类型\nexport const incompleteclasscomponent = 17;\nexport const dehydratedfragment = 18;\nexport const suspenselistcomponent = 19;\nexport const scopecomponent = 21;\nexport const offscreencomponent = 22;\nexport const legacyhiddencomponent = 23;\nexport const cachecomponent = 24;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\nfibernode 中 fiber 相关的属性构成了怎样的 fibertree 的关系？\n\n我们从这张图可以看出：\n\n * fiberroot 和 rootfiber 的双向链接关系。\n * fiber 中 child 为子节点指针，sibling 为兄弟节点指针，return 为父节点指针，这三个指针共同构成了 fibertree 的数据结构。注意 sibling 只指向下一个兄弟节点。\n * 从整体上看，child 指针和 return 指针决定了深度关系，而 sibling 指针决定了广度关系。return 指针决定了 fibertree 的可逆性。\n\nlocal stack\n\n到目前为止，我们来看一下目前的调用栈：\n\n过程如下： render -> legacyrendersubtreeintocontainer -> legacycreaterootfromdomcontainer -> createcontainer -> createfiberroot -> createhostrootfiber -> createfiber -> ...\n\n\n# flushsync\n\n从上面的过程，已经创建了 hostroot 和 rootfiber，以及\n\nflushsync(() => {\n  updatecontainer(children, fiberroot, parentcomponent, callback);\n});\n\n\n1\n2\n3\n\n\nflushsync 函数处理同步渲染，在传入的回调中调用了 updatecontainer 函数。\n\n下面是 flushsync 函数：\n\n// overload the definition to the two valid signatures.\n// warning, this opts-out of checking the function body.\ndeclare function flushsync<r>(fn: () => r): r;\n// eslint-disable-next-line no-redeclare\ndeclare function flushsync(): void;\n// eslint-disable-next-line no-redeclare\nexport function flushsync(fn) {\n  // in legacy mode, we flush pending passive effects at the beginning of the\n  // next event, not at the end of the previous one.\n  // rootwithpendingpassiveeffects 表示当前已经 commit 的 hostroot\n  // 如果当前已存在 commit 的 hostroot，且当前执行阶段不是 rendercontext 或者 commitcontext，则 flush 所有待渲染的副作用\n  if (\n    rootwithpendingpassiveeffects !== null &&\n    rootwithpendingpassiveeffects.tag === legacyroot &&\n    (executioncontext & (rendercontext | commitcontext)) === nocontext\n  ) {\n    flushpassiveeffects();\n  }\n\n  const prevexecutioncontext = executioncontext;\n  // executioncontext 指向 batchedcontext\n  executioncontext |= batchedcontext;\n\n  const prevtransition = reactcurrentbatchconfig.transition;\n  const previouspriority = getcurrentupdatepriority();\n  try {\n    reactcurrentbatchconfig.transition = 0;\n    setcurrentupdatepriority(discreteeventpriority);\n    if (fn) {\n      return fn();\n    } else {\n      return undefined;\n    }\n  } finally {\n    // 如果 fn 执行 抛出了错误，则回退至之前的状态\n    setcurrentupdatepriority(previouspriority);\n    reactcurrentbatchconfig.transition = prevtransition;\n    executioncontext = prevexecutioncontext;\n    // flush the immediate callbacks that were scheduled during this batch.\n    // note that this will happen even if batchedupdates is higher up\n    // the stack.\n    // flush 本次 batch 中高优先级的 callbacks\n    if ((executioncontext & (rendercontext | commitcontext)) === nocontext) {\n      flushsynccallbacks();\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n * flushsync 使用了 ts 的函数重载，如果传入回调，会执行这个回调。\n * 从整体来看，flushsync 主要调用了 flushpassiveeffects 函数来处理已经 commit 的 hostroot 上的待执行的副作用。\n * flushsync 会先对已经 commit 的内容执行 flushpassiveeffects，执行完毕后才进入 batchedcontext 阶段。\n * 注意，在首次渲染时 rootwithpendingpassiveeffects 应该为 null，也就是说 flushpassiveeffects 不会被执行到，但是我们仍然来分析下 flushpassiveeffects 会做些什么事情。\n\n\n# flushpassiveeffects\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nexport function flushpassiveeffects(): boolean {\n  // returns whether passive effects were flushed.\n  // todo: combine this check with the one in flushpassiveeffectsimpl. we should\n  // probably just combine the two functions. i believe they were only separate\n  // in the first place because we used to wrap it with\n  // `scheduler.runwithpriority`, which accepts a function. but now we track the\n  // priority within react itself, so we can mutate the variable directly.\n  if (rootwithpendingpassiveeffects !== null) {\n    // cache the root since rootwithpendingpassiveeffects is cleared in\n    // flushpassiveeffectsimpl\n    // 这里缓存 root 是为了在发生错误回滚时即时释放缓存池\n    const root = rootwithpendingpassiveeffects;\n    // cache and clear the remaining lanes flag; it must be reset since this\n    // method can be called from various places, not always from commitroot\n    // where the remaining lanes are known\n    // 重置 remaininglanes\n    const remaininglanes = pendingpassiveeffectsremaininglanes;\n    pendingpassiveeffectsremaininglanes = nolanes;\n\n    const renderpriority = lanestoeventpriority(pendingpassiveeffectslanes);\n    const priority = lowereventpriority(defaulteventpriority, renderpriority);\n    const prevtransition = reactcurrentbatchconfig.transition;\n    const previouspriority = getcurrentupdatepriority();\n    try {\n      reactcurrentbatchconfig.transition = 0;\n      setcurrentupdatepriority(priority);\n      return flushpassiveeffectsimpl();\n    } finally {\n      // flushpassiveeffectsimpl 发生错误后回滚只上一状态\n      setcurrentupdatepriority(previouspriority);\n      reactcurrentbatchconfig.transition = prevtransition;\n\n      // once passive effects have run for the tree - giving components a\n      // chance to retain cache instances they use - release the pooled\n      // cache at the root (if there is one)\n      releaserootpooledcache(root, remaininglanes);\n    }\n  }\n  return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n这个函数主要调用 flushpassiveeffectsimpl 函数。\n\nfunction flushpassiveeffectsimpl() {\n  if (rootwithpendingpassiveeffects === null) {\n    return false;\n  }\n\n  const root = rootwithpendingpassiveeffects;\n  const lanes = pendingpassiveeffectslanes;\n  // 由于这里的 passiveeffects 将会被 flush，这里将之清空\n  rootwithpendingpassiveeffects = null;\n  // todo: this is sometimes out of sync with rootwithpendingpassiveeffects.\n  // figure out why and fix it. it's not causing any known issues (probably\n  // because it's only used for profiling), but it's a refactor hazard.\n  pendingpassiveeffectslanes = nolanes;\n\n  // render 阶段和 commit 阶段是不能 flush 的\n  if ((executioncontext & (rendercontext | commitcontext)) !== nocontext) {\n    throw new error('cannot flush passive effects while already rendering.');\n  }\n\n  const prevexecutioncontext = executioncontext;\n  // 将 executioncontext 更新为 commitcontext，因为现在进入了 commit 阶段\n  executioncontext |= commitcontext;\n\n  // 这里将 passiveeffects 分成了 mount 和 unmount 阶段，这两类都需要 commit，但是处理的逻辑不同\n  commitpassiveunmounteffects(root.current);\n  commitpassivemounteffects(root, root.current);\n\n  executioncontext = prevexecutioncontext;\n\n  // 所有的同步的 callback 都需要 flush\n  flushsynccallbacks();\n\n  // if additional passive effects were scheduled, increment a counter. if this\n  // exceeds the limit, we'll fire a warning.\n  // nestedpassiveupdatecount 计数器递增，防止造成死循环\n  nestedpassiveupdatecount =\n    rootwithpendingpassiveeffects === null ? 0 : nestedpassiveupdatecount + 1;\n  return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n * flush effects 的目的是 commit effects。\n\n\n# flushsynccallbacks\n\n// src/react/packages/react-reconciler/src/reactfibersynctaskqueue.new.js\nexport function flushsynccallbacks() {\n  // isflushingsyncqueue 是 syncqueue 的互斥锁 \n  if (!isflushingsyncqueue && syncqueue !== null) {\n    // prevent re-entrance.\n    isflushingsyncqueue = true;\n    let i = 0;\n    const previousupdatepriority = getcurrentupdatepriority();\n    try {\n      const issync = true;\n      const queue = syncqueue;\n      // todo: is this necessary anymore? the only user code that runs in this\n      // queue is in the render or commit phases.\n      setcurrentupdatepriority(discreteeventpriority);\n      // flush syncqueue，每个 callback 可以返回一个新的 callback\n      for (; i < queue.length; i++) {\n        let callback = queue[i];\n        do {\n          callback = callback(issync);\n        } while (callback !== null);\n      }\n      // 重置 syncqueue\n      syncqueue = null;\n      includeslegacysynccallbacks = false;\n    } catch (error) {\n      // if something throws, leave the remaining callbacks on the queue.\n      // 如果syncqueue 中每个 rootcallback 发生了错误，则跳过此项\n      if (syncqueue !== null) {\n        syncqueue = syncqueue.slice(i + 1);\n      }\n      // resume flushing in the next tick\n      // 调度在下一个 tick 中继续执行\n      schedulecallback(immediatepriority, flushsynccallbacks);\n      throw error;\n    } finally {\n      setcurrentupdatepriority(previousupdatepriority);\n      isflushingsyncqueue = false;\n    }\n  }\n  return null;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n可以看到，flushsynccallbacks 主要是在执行完 syncqueue 中的所有的回调，syncqueue 中的 callback 可以返回一个新的 callback，这种结构类似于数组 + 链表和结构，很是巧妙。这段代码中 syncqueue 的数据结构、flush syncqueue 的处理方式和错误处理方式，值得我们借鉴。这种消费 effect 的方式和 react 中响应式 effect 的消费很像。\n\n * 因为 syncqueue 是公共资源，而 flushsynccallbacks 是其消费者，因此消费者在消费 syncqueue 时需要添加互斥锁，以免造成资源争夺。\n * 出现错误时并不是直接继续执行，而是放到了 next tick 中继续消费，提高了 syncqueue 消费的效率。\n\n\n# updatecontainer\n\nupdatecontainer 是首次渲染中重要工作中的一项。\n\nexport function updatecontainer(\n  element: reactnodelist,\n  container: opaqueroot,\n  parentcomponent: ?react$component<any, any>,\n  callback: ?function,\n): lane {\n  // 获取 rootfiber\n  const current = container.current;\n  const eventtime = requesteventtime();\n  const lane = requestupdatelane(current);\n\n  // 更新 container 的 context 信息\n  const context = getcontextforsubtree(parentcomponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingcontext = context;\n  }\n\n  // 创建一个更新\n  const update = createupdate(eventtime, lane);\n  // caution: react devtools currently depends on this property\n  // being called \"element\".\n  update.payload = {element};\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    update.callback = callback;\n  }\n\n  // 将新建的更新入栈\n  enqueueupdate(current, update, lane);\n  // 请求一次调度更新\n  const root = scheduleupdateonfiber(current, lane, eventtime);\n  if (root !== null) {\n    entangletransitions(root, current, lane);\n  }\n\n  return lane;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\nupdatecontainer 函数中主要是针对 rootfiber 创建了一次更新，加入到更新队列，并且请求调度器进行调度。调度更新部分，请参照 schedulework 与调度过程 。\n\n\n# 小结\n\n通过上面的分析过程可知，react 的首次渲染的流程如下：首先执行一系列的初始化工作，包括创建 hostroot 和 fiberroot 以及建立两者之间的关联、初始化事件委托系统，然后创建一个同步的更新并向调度器提交调度请求。\n\n\n# q&a\n\n\n# executioncontext 有哪几种？\n\nexecutioncontext 表示 react 当前执行的上下文阶段，通过 executioncontext 我们可以大致分出其总体渲染流程的不同阶段。\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nexport const nocontext = /*             */ 0b0000;\nconst batchedcontext = /*               */ 0b0001; // batch(批处理)阶段\nconst rendercontext = /*                */ 0b0010; // render(渲染)阶段\nconst commitcontext = /*                */ 0b0100; // commit(提交)阶段\nexport const retryaftererror = /*       */ 0b1000; // 错误重试阶段\n\n// describes where we are in the react execution stack\nlet executioncontext: executioncontext = nocontext;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n全局变量 executioncontext 代表当前的执行上下文，初始化为 nocontent。下面是这四个阶段的对照表格:\n\ncontext           所在函数                                       阶段               备注\nnocontext                                                    初始化              初始阶段\nbatchedcontext    flushsync、batchedupdates、flushcontrolled   batch (批处理) 阶段   rendersubtreeintocontainer 之后，renderroot 之前\nrendercontext     renderrootsync、renderrootconcurrent        render (渲染) 阶段   renderroot 之后，commitroot 之前\ncommitcontext     commitrootimpl、flushpassiveeffectsimpl     commit (提交) 阶段   commitroot 之后\nretryaftererror   recoverfromconcurrenterror                 error 阶段         发生错误需要恢复之后\n\n从表格可以总结出，react 的渲染总共分为 nocontext、batchedcontext、rendercontext、commitcontext、retryaftererror 五个阶段。关于更新阶段的更多内容，请移步 react 更新周期。\n\n\n# 使用位运算提高枚举计算效率\n\nreact 中多处使用位运算进行枚举计算，使用位运算可以有效提交运行效率，尤其是大型的状态繁多的项目。在 react 源码中有很多类似的位运算，比如 effecttag，worktag 和上文中的 executioncontext。\n\n下面我们来看看 react 中位运算枚举风格：\n\nconst nocontext = 0b0000;\nconst batchedcontext =  0b0001; \nconst rendercontext =  0b0010; \nconst commitcontext =  0b0100;\nconst retryaftererror = 0b1000;\n\nlet executioncontext = nocontext;\n\n// 如果现在开始 rendercontainer，进入 batch 阶段\n// 增加枚举值\nexecutioncontext |= batchedcontext; // 1\n// 判断是否在 batch 阶段\n// 消费枚举值：0 表示没有枚举值，1 表示有枚举值。这里我们直接跟为 0 的 nocontext 作比较。\n(executioncontext & batchedcontext) !== nocontext; // true\n// 判断是否处于 render 阶段\n(executioncontext & rendercontext) !== nocontext; // false\n// 现在开始 renderroot，进入 render 阶段\nexecutioncontext |= rendercontext;\n// 判断是否处于 batch 阶段或者 render 阶段\n(executioncontext & (batchedcontext | rendercontext)) !== nocontext; // true\n// 判断是否不处于 commit 阶段或者 error 阶段\n(executioncontext & (commitcontext | retryaftererror)) === nocontext; // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n下面我们再来对比一些 vue 源码中使用位运算的风格。\n\nconst enum shapeflags {\n  element = 1,\n  functional_component = 1 << 1,\n  stateful_component = 1 << 2,\n  text_children = 1 << 3,\n  array_children = 1 << 4,\n  slots_children = 1 << 5,\n  teleport = 1 << 6,\n  suspense = 1 << 7,\n  component_should_keep_alive = 1 << 8,\n  component_kept_alive = 1 << 9,\n  component = shapeflags.stateful_component | shapeflags.functional_component\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n写法不一样，使用的方法是一样的。\n\n这种原理是什么？这是因为这些枚举数字是互相正交的（可以从数学上垂直的概念来理解），也可以从二进制为进行理解，没加入一个枚举值，在相应的下标出置为 1（按位或运算），判断是否有这个枚举值的时候，就可以那要判断的值与枚举值对齐比对（按位与运算）。\n\n位运算的更多技巧请参考文章：位运算初探\n\n\n# 参考资料\n\n * 深入理解 react 源码 - 首次渲染\n * 深入剖析 react concurrent\n * react 的第一次渲染过程浅析",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"React 中的事件监听机制",frontmatter:{title:"React 中的事件监听机制",date:"2022-04-14T22:02:21.000Z",permalink:"/react/summary/event-listener/",categories:["react","summary"],tags:[null]},regularPath:"/10.react/80.%E6%80%BB%E7%BB%93/30.event-listener.html",relativePath:"10.react/80.总结/30.event-listener.md",key:"v-59f008fe",path:"/react/summary/event-listener/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2}],readingTime:{text:"1 min read",minutes:.25,time:15e3,words:50},headersStr:"目录",content:"# 目录\n\n\n\n * 目录\n\n\n\n// src/react/packages/react-dom/src/events/DOMPluginEventSystem.js\nexport function listenToNativeEvent(\n  // 监听的时间名称\n  domEventName: DOMEventName,\n  // 是否是在捕获过程键监听\n  isCapturePhaseListener: boolean,\n  // 时间委托监听的对象（container 或者 document）\n  target: EventTarget,\n): void {\n\n  let eventSystemFlags = 0;\n  if (isCapturePhaseListener) {\n    eventSystemFlags |= IS_CAPTURE_PHASE;\n  }\n  addTrappedEventListener(\n    target,\n    domEventName,\n    eventSystemFlags,\n    isCapturePhaseListener,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# 目录\n\n\n\n * 目录\n\n\n\n// src/react/packages/react-dom/src/events/domplugineventsystem.js\nexport function listentonativeevent(\n  // 监听的时间名称\n  domeventname: domeventname,\n  // 是否是在捕获过程键监听\n  iscapturephaselistener: boolean,\n  // 时间委托监听的对象（container 或者 document）\n  target: eventtarget,\n): void {\n\n  let eventsystemflags = 0;\n  if (iscapturephaselistener) {\n    eventsystemflags |= is_capture_phase;\n  }\n  addtrappedeventlistener(\n    target,\n    domeventname,\n    eventsystemflags,\n    iscapturephaselistener,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"30 分钟看懂 React 框架原理",frontmatter:{title:"30 分钟看懂 React 框架原理",date:"2022-04-14T22:02:21.000Z",permalink:"/react/summary/10-min-react/",categories:["react","summary"],tags:[null]},regularPath:"/10.react/80.%E6%80%BB%E7%BB%93/40.10-min-react.html",relativePath:"10.react/80.总结/40.10-min-react.md",key:"v-5de90ac4",path:"/react/summary/10-min-react/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"ReactDOMHostConfig",slug:"reactdomhostconfig",normalizedTitle:"reactdomhostconfig",charIndex:17},{level:2,title:"updateContainer",slug:"updatecontainer",normalizedTitle:"updatecontainer",charIndex:39},{level:2,title:"scheduleUpdateOnFiber",slug:"scheduleupdateonfiber",normalizedTitle:"scheduleupdateonfiber",charIndex:58},{level:3,title:"一个闭环",slug:"一个闭环",normalizedTitle:"一个闭环",charIndex:85},{level:3,title:"更新的来源",slug:"更新的来源",normalizedTitle:"更新的来源",charIndex:95},{level:2,title:"ensureRootIsScheduled",slug:"ensurerootisscheduled",normalizedTitle:"ensurerootisscheduled",charIndex:104},{level:3,title:"DiscreteEventPriority 和 ContinuousEventPriority",slug:"discreteeventpriority-和-continuouseventpriority",normalizedTitle:"discreteeventpriority 和 continuouseventpriority",charIndex:131},{level:3,title:"scheduleMicrotask 与 queueMicrotask",slug:"schedulemicrotask-与-queuemicrotask",normalizedTitle:"schedulemicrotask 与 queuemicrotask",charIndex:184},{level:2,title:"scheduleSyncCallback 和 scheduleCallback",slug:"schedulesynccallback-和-schedulecallback",normalizedTitle:"schedulesynccallback 和 schedulecallback",charIndex:222},{level:3,title:"scheduleSyncCallback 和 flushSyncCallbacks",slug:"schedulesynccallback-和-flushsynccallbacks",normalizedTitle:"schedulesynccallback 和 flushsynccallbacks",charIndex:267},{level:3,title:"scheduleCallback",slug:"schedulecallback",normalizedTitle:"schedulecallback",charIndex:245},{level:2,title:"performSyncWorkOnRoot",slug:"performsyncworkonroot",normalizedTitle:"performsyncworkonroot",charIndex:334},{level:2,title:"performConcurrentWorkOnRoot",slug:"performconcurrentworkonroot",normalizedTitle:"performconcurrentworkonroot",charIndex:359},{level:3,title:"finishConcurrentRender",slug:"finishconcurrentrender",normalizedTitle:"finishconcurrentrender",charIndex:392},{level:2,title:"renderRootSync",slug:"renderrootsync",normalizedTitle:"renderrootsync",charIndex:418},{level:2,title:"renderRootConcurrent",slug:"renderrootconcurrent",normalizedTitle:"renderrootconcurrent",charIndex:436},{level:3,title:"handleError",slug:"handleerror",normalizedTitle:"handleerror",charIndex:462},{level:2,title:"workLoopSync",slug:"workloopsync",normalizedTitle:"workloopsync",charIndex:477},{level:2,title:"workLoopConcurrent",slug:"workloopconcurrent",normalizedTitle:"workloopconcurrent",charIndex:493},{level:2,title:"performUnitOfWork",slug:"performunitofwork",normalizedTitle:"performunitofwork",charIndex:515},{level:2,title:"beginWork",slug:"beginwork",normalizedTitle:"beginwork",charIndex:536},{level:2,title:"completeUnitOfWork",slug:"completeunitofwork",normalizedTitle:"completeunitofwork",charIndex:549},{level:2,title:"completeWork",slug:"completework",normalizedTitle:"completework",charIndex:571},{level:2,title:"commitRoot",slug:"commitroot",normalizedTitle:"commitroot",charIndex:587}],readingTime:{text:"29 min read",minutes:28.035,time:1682100,words:5607},headersStr:"目录 ReactDOMHostConfig updateContainer scheduleUpdateOnFiber 一个闭环 更新的来源 ensureRootIsScheduled DiscreteEventPriority 和 ContinuousEventPriority scheduleMicrotask 与 queueMicrotask scheduleSyncCallback 和 scheduleCallback scheduleSyncCallback 和 flushSyncCallbacks scheduleCallback performSyncWorkOnRoot performConcurrentWorkOnRoot finishConcurrentRender renderRootSync renderRootConcurrent handleError workLoopSync workLoopConcurrent performUnitOfWork beginWork completeUnitOfWork completeWork commitRoot",content:"# 目录\n\n\n\n * 目录\n * ReactDOMHostConfig\n * updateContainer\n * scheduleUpdateOnFiber\n   * 一个闭环\n   * 更新的来源\n * ensureRootIsScheduled\n   * DiscreteEventPriority 和 ContinuousEventPriority\n   * scheduleMicrotask 与 queueMicrotask\n * scheduleSyncCallback 和 scheduleCallback\n   * scheduleSyncCallback 和 flushSyncCallbacks\n   * scheduleCallback\n * performSyncWorkOnRoot\n * performConcurrentWorkOnRoot\n   * finishConcurrentRender\n * renderRootSync\n * renderRootConcurrent\n   * handleError\n * workLoopSync\n * workLoopConcurrent\n * performUnitOfWork\n * beginWork\n * completeUnitOfWork\n * completeWork\n * commitRoot\n\n\n\n\n# ReactDOMHostConfig\n\n下面我们先探究一下生产更新的来源，主要分析 updateContainer 和 scheduleUpdateOnFiber 两个函数。\n\n\n# updateContainer\n\n更新是如何开始的？我们首先从 updateContainer 的调用来源开始追溯。\n\n调用 updateContainer 的函数包括： legacyRenderSubtreeIntoContainer、ReactDOMRoot.prototype.render、ReactDOMRoot.prototype.unmount、hydrateRoot、scheduleRoot。ReactDOMRoot 由 ReactDOM.createRoot 创建。scheduleRoot 在 src/react/packages/react-reconciler/src/ReactFiberHotReloading.new.js 文件中。\n\n// 应用层 API\nlegacyRenderSubtreeIntoContainer <- ReactDOM.hydrate\n                                 <- ReactDOM.render\n                                 <- ReactDOM.unmountComponentAtNode\n\n\n1\n2\n3\n4\n\n\n由上面的分析可以看出，updateContainer 主要来源于应用层 API 的调用，这种调用生产了更新渲染的需求。那么 updateContainer 主要做了什么？\n\n// src/react/packages/react-reconciler/src/ReactFiberReconciler.new.js\nexport function updateContainer(\n  // 待挂载的组件\n  element: ReactNodeList,\n  // 挂载容器\n  container: OpaqueRoot,\n  parentComponent: ?React$Component<any, any>,\n  callback: ?Function,\n): Lane {\n  // 获取 RootFiber\n  const current = container.current;\n  const eventTime = requestEventTime();\n  const lane = requestUpdateLane(current);\n\n  // 更新 container 的 context 信息\n  const context = getContextForSubtree(parentComponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  // 创建一个更新\n  const update = createUpdate(eventTime, lane);\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = {element};\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    update.callback = callback;\n  }\n\n  // 将新建的更新入栈\n  enqueueUpdate(current, update, lane);\n  // 请求一次调度更新\n  const root = scheduleUpdateOnFiber(current, lane, eventTime);\n  if (root !== null) {\n    entangleTransitions(root, current, lane);\n  }\n\n  return lane;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\nupdateContainer 关键功能如下：\n\n * 继续完善 FiberRoot 信息：context、pendingContext。\n * 初始化创建一个更新对象，添加属性 payload、callback，并且将更新加入更新队列。\n * 调用 scheduleUpdateOnFiber，(向调度器) 发出一次调度的请求。\n\n扩展\n\n 1. createUpdate 创建更新在组件的生命周期或者用户行为中也会产生，如函数式组件（FC）中的 setState、useContext 的 dispatchAction、类组件的 this.setState 中，两种不同之处在于前者是应用层面的调用，后者则是组件层面的调用。\n 2. 注意，scheduleUpdateOnFiber 的调度请求并不一定经过调度器，同步更新可能会跳过调度器的调度，后面会说明这一点。\n\n\n# scheduleUpdateOnFiber\n\n在 updateContainer 中，调用了 scheduleUpdateOnFiber 以在 fiber（此处指的是 RootFiber） 上调度一次更新，那么调度更新是如何在 fiber 上展开的呢？\n\n首先来分析一下代码：\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\n// Lanes that were updated during the render phase (*not* an interleaved event).\nlet workInProgressRootRenderPhaseUpdatedLanes: Lanes = NoLanes;\n// Whether to root completed, errored, suspended, etc.\nlet workInProgressRootExitStatus: RootExitStatus = RootIncomplete;\n\nexport function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {\n  return a | b;\n}\n\nexport function scheduleUpdateOnFiber(\n  //  RootFiber\n  fiber: Fiber,\n  // 调度优先级\n  lane: Lane,\n  eventTime: number,\n): FiberRoot | null {\n  // 检查嵌套更新，防止死循环\n  checkForNestedUpdates();\n  // 从 fiber 向上收集 lanes，root：FiberRoot = fiber.stateNode。对于 updateContainer 来说，这里 fiber 就是 RootFiber。\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\n  // FiberRoot 不存在，说明 FiberTree 可能已经被废弃，不用更新\n  if (root === null) {\n    return null;\n  }\n\n  // Mark that the root has a pending update.\n  // 标记 root 即将更新，root.pendingLanes |= lane\n  markRootUpdated(root, lane, eventTime);\n  // 如果当前已经是 Render 阶段，且 root 是待处理的 HostRoot，这时跳过渲染的调度请求，并且追踪 lane，加入到 Render 阶段的 lanes，就在在当前调度的回调中参与渲染，或者等待下次渲染。\n  if (\n    (executionContext & RenderContext) !== NoLanes &&\n    root === workInProgressRoot\n  ) {\n    // Track lanes that were updated during the render phase\n    // 收集当前的 lane 到 workInProgressRootRenderPhaseUpdatedLanes，表示在当前 render 中当前正在渲染的 RootFiber 上的优先级队列。\n    workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(\n      workInProgressRootRenderPhaseUpdatedLanes,\n      lane,\n    );\n    // 这里是正常的请求渲染调度的流程\n  } else {\n    if (root === workInProgressRoot) {\n      // 如果 workInProgressRootExitStatus 为 RootSuspendedWithDelay，则标记 root 为 suspend。这里是处理 suspended 组件。向 root 做标记以在后面的渲染中加以区分。\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // TODO: Make sure this doesn't override pings that happen while we've\n        // already started rendering.\n        markRootSuspended(root, workInProgressRootRenderLanes);\n      }\n    }\n    // 确保 HostRoot （向调度器）发起调度请求，\n    ensureRootIsScheduled(root, eventTime);\n    if (\n      lane === SyncLane &&\n      executionContext === NoContext &&\n      (fiber.mode & ConcurrentMode) === NoMode &&\n      // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n      !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)\n    ) {\n      // 如果是同步更新，context 还是 NoContext 阶段，fiber.mode 不是 ConcurrentMode，且 prd 环境 ReactCurrentActQueue.isBatchingLegacy 为 true\n      // 在初次加载时重置 workInProgressRootRenderTargetTime 并且 flushSyncCallbacks。\n      // 只在初始化应用时执行\n      // Flush the synchronous work now, unless we're already working or inside\n      // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n      // scheduleCallbackForFiber to preserve the ability to schedule a callback\n      // without immediately flushing it. We only do this for user-initiated\n      // updates, to preserve historical behavior of legacy mode.\n      resetRenderTimer();\n      flushSyncCallbacksOnlyInLegacyMode();\n    }\n  }\n  return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n这个函数的核心功能如下：\n\n * 从 fiber 向父级收集 lanes，并且计算出 HostRoot。\n * 调用 ensureRootIsScheduled，确保 HostRoot 发起同步或者异步调度。\n * 如果是初次启动应用，执行一些初始化工作。\n\n下面我们将以 scheduleUpdateOnFiber 函数作为突破口，一层层的往下追溯，看看 React 的更新具体是怎样的流程，以及更新产生的来源到底是什么？\n\n图注\n\n<- 表示代码向下追溯，即前面的函数被后面的函数调用或者使用。<<< 表示省略追溯过程，因为从前面的过程中可以推出。... 表示忽略此过程。\n\nscheduleUpdateOnFiber <- updateDehydratedSuspenseComponent <- updateSuspenseComponent <- attemptEarlyBailoutIfNoScheduledUpdate <- beginWork\n                                                                                      <- beginWork\n                      <- classComponentUpdater[enqueueSetState、enqueueReplaceState、enqueueForceUpdate] <- adoptClassInstance <- mountIndeterminateComponent <- beginWork\n                                                                                                                              <- constructClassInstance <- updateClassComponent <- mountLazyComponent <- beginWork\n                                                                                                                                                                                <- beginWork\n                                                                                                                                                        <- mountIncompleteClassComponent <- beginWork\n                                                                                                        <- callComponentWillMount <- mountClassInstance <- updateClassComponent <- mountLazyComponent <- beginWork\n                                                                                                                                                                                <- beginWork\n                                                                                                                                                        <- mountIncompleteClassComponent <- beginWork\n                                                                                                        <- callComponentWillReceiveProps <- resumeMountClassInstance <- updateClassComponent <<< beginWork\n                                                                                                                                         <- updateClassInstance <<< beginWork\n                      <- [DEV]forceStoreRerender <- updateStoreInstance <- mountSyncExternalStore ...\n                                                                   <- updateSyncExternalStore ...\n                                            <- subscribeToStore ...\n                      <- [enableCache]refreshCache <- mountRefresh ...\n                      <- dispatchReducerAction <- mountReducer <- reducer.dispatch[useReducer]\n                      <- dispatchSetState <- useMutableSource <- stateHook.queue.dispatch <- dispatchAction[queue.reducer(state, dispatch)]  <- useState\n                                          <- mountState <- HooksDispatcherOnMount.useState <- ReactCurrentDispatcher.current <- useState\n                                                        <- mountTransition <- HooksDispatcherOnMount.useTransition <- useTransition\n                                                        <- mountDeferredValue <- HooksDispatcherOnMount.useDeferredValue <- useDeferredValue\n                      <- updateContainer <<< ReactDOM[hydrate、render、unmountComponentAtNode、createRoot、hydrateRoot、scheduleRoot]\n                      \x3c!-- <- attemptSynchronousHydration --\x3e\n                      \x3c!-- <- attemptDiscreteHydration --\x3e\n                      \x3c!-- <- attemptContinuousHydration --\x3e\n                      \x3c!-- <- attemptHydrationAtCurrentPriority --\x3e\n\nbeginWork <- workLoopConcurrent <- renderRootConcurrent <- performConcurrentWorkOnRoot <- ensureRootIsScheduled[root.callbackNode] <- scheduleUpdateOnFiber <<< beginWork\n          <- performUnitOfWork <- workLoopSync <- renderRootSync <- performConcurrentWorkOnRoot <<< beginWork\n                               <- workLoopConcurrent <- renderRootConcurrent <- performConcurrentWorkOnRoot <<< beginWork\n\ncommitRoot <- finishConcurrentRender[RootErrored、RootSuspended、RootSuspendedWithDelay、RootCompleted] <- performConcurrentWorkOnRoot\n           <- performSyncWorkOnRoot\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n从上面的分析过程，我们可以得出很多重要的信息，总结如下：\n\n\n# 一个闭环\n\n从上面可以清晰的看出，从 scheduleUpdateOnFiber 往上追溯时，最终追溯到了 beginWork，然后从 beginWork 继续追溯，最终追溯到 scheduleUpdateOnFiber。大致过程如下：\n\n钩子（生命周期）和事件系统 -> 应用层行为：dispatchSetState、classComponentUpdater、dispatchReducerAction、updateContainer \n-> scheduleUpdateOnFiber -> ensureRootIsScheduled -> performSyncWorkOnRoot、performConcurrentWorkOnRoot \n-> renderRootSync、renderRootConcurrent -> workLoopSync、workLoopConcurrent \n-> performUnitOfWork -> beginWork -> mount、update 组件 -> 调用生命周期函数、响应事件系统 -> commitRoot -> ...\n\n\n1\n2\n3\n4\n\n\n有以下几点需要注意：\n\n * 应用层行为分别可以对应 FC setState、类组件 this.setState、useReducer 的 dispatch 和 ReactDOM 的一系列操作，如 hydrate、render、unmountComponentAtNode、createRoot、hydrateRoot、scheduleRoot。\n * 从 ensureRootIsScheduled -> performConcurrentWorkOnRoot 中间还有调度器的调度过程，包括 scheduleSyncCallback 和 scheduleCallback，分别对应同步任务的调度和异步任务的调度。\n * 在 performSyncWorkOnRoot、performConcurrentWorkOnRoot 执行之后，有一个 commitRoot 的操作。\n * beginWork -> mount、update 组件 这个过程中涉及的内容较为繁琐，可以参考更新器的部分，本文不在赘述细节。\n * commitRoot 在 performSyncWorkOnRoot（同步渲染）、或者 finishConcurrentRender（异步渲染）中调用。这并不是说在同步渲染中 commitRoot 和后面的 renderRootSync 是同时进行的，而是说 renderRootSync 是同步的，renderRootSync 执行完之后直接就执行了 commitRoot。从只有 finishConcurrentRender，而没有类似于 finishSyncRender 可以印证这一点。\n\n一个完整的同步的渲染回调的调用函数栈，可以参考下图：\n\n\n# 更新的来源\n\n更新主要来源于应用层的一些行为：dispatchSetState、classComponentUpdater、dispatchReducerAction、updateContainer 和 ReactDOM 的一系列操作，如 hydrate、render、unmountComponentAtNode、createRoot、hydrateRoot、scheduleRoot。大致包括应用 mount 阶段对 ReactDOM API 调用引起的同步更新，类组件和 FC 状态更新、useReducer 的 dispatch 的调用，以及最新 ConcurrentAPI 如 useTransition、useDeferredValue 等。\n\n下面我们从一个更为直接的角度来探究 React 更新的来源。现在我们知道，如果需要更新，则会将更新入栈，我们从这个角度来分析一下，在代码中搜索 enqueueUpdate( ：\n\n调用 enqueueUpdate( 主要在如下几个模块：\n\n * src/react/packages/react-reconciler/src/ReactFiberClassComponent.new.js\n * src/react/packages/react-reconciler/src/ReactFiberHooks.new.js\n * src/react/packages/react-reconciler/src/ReactFiberReconciler.new.js\n * src/react/packages/react-reconciler/src/ReactFiberThrow.new.js\n * src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\n然后分析下分别在哪些函数中出现：\n\n>> ReactFiberClassComponent\nclassComponentUpdater[enqueueSetState、enqueueReplaceState、enqueueForceUpdate]\n\n>> ReactFiberHooks\ndispatchReducerAction\ndispatchSetState\n\n>> ReactFiberReconciler\nupdateContainer\n\n// 以下的 Update 为 ErrorUpdate\n\n>> ReactFiberThrow\nmarkSuspenseBoundaryShouldCapture <- throwException <- handleError <- renderRootSync/renderRootConcurrent\n\n>> ReactFiberWorkLoop\ncaptureCommitPhaseErrorOnRoot <- captureCommitPhaseError <- safelyCallCommitHookLayoutEffectListMount/safelyCallComponentWillUnmount/safelyCallComponentDidMount/safelyAttachRef/safelyDetachRef/safelyCallDestroy/commitBeforeMutationEffects_complete/commitMutationEffects_begin/commitMutationEffects_complete/commitLayoutMountEffects_complete/reappearLayoutEffects_complete/commitPassiveMountEffects_complete\ncaptureCommitPhaseError <<< ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n可以看出，与前文的分析基本一致。\n\n关于 useTransition、useDeferredValue 可以参考：淺談 React Concurrent Mode & 相關功能 (Fiber、Suspense、useTransition、useDeferredValue)\n\n扩展\n\n 1. scheduleUpdateOnFiber 一方面被 updateContainer 这样间接被外部应用层 API 调用，另一方面在组件层面由组件状态更新、context 更新、props 更新等行为在 react 内部调用（可以参考上文 scheduleUpdateOnFiber 调用来源）。\n 2. checkForNestedUpdates 函数是为了防止行为更新的死循环，因为更新都要经过 scheduleUpdateOnFiber 函数提交调度更新，scheduleUpdateOnFiber 在 react 内部还是外部都会被频繁调用。checkForNestedUpdates 在内部维护变量 nestedUpdateCount 表示在当前的 commit 中 FiberRoot 更新的循环请求次数。\n 3. 关于 react 中常见的位运算，可以参考 位运算初探 和 使用位运算提高枚举计算效率。\n 4. 这里判断 root === workInProgressRoot 执行 suspended 组件的一些逻辑是因为，正常情况下这里 workInProgressRoot 应该为 null，只有当前的 FiberRoot 被标记为 workInProgressRoot 再回在这里特殊处理。正常情况下，workInProgressRoot 只有在 prepareFreshStack 函数被赋值为 root 的，而 prepareFreshStack 只有在 renderRootSync、renderRootConcurrent、pingSuspendedRoot 函数中正常执行或者在 performConcurrentWorkOnRoot、performSyncWorkOnRoot 中发生 FatalError 时执行。\n\n\n# ensureRootIsScheduled\n\n在上面对 scheduleUpdateOnFiber 的分析中，最重要的就是调用 ensureRootIsScheduled，以保证在 fiber 所在的 HostRoot 上调度更新，那么 HostRoot 上是如何继续调度的呢？\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\n  const existingCallbackNode = root.callbackNode;\n\n  // Check if any lanes are being starved by other work. If so, mark them as\n  // expired so we know to work on those next.\n  // 将饿死的 lanes 标记为超时以一并更新，超时的任务立即执行。\n  markStarvedLanesAsExpired(root, currentTime);\n\n  // Determine the next lanes to work on, and their priority.\n  // 计算将要渲染的 lanes\n  const nextLanes = getNextLanes(\n    root,\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\n  );\n  // 无需要渲染的 lanes\n  if (nextLanes === NoLanes) {\n    // Special case: There's nothing to work on.\n    if (existingCallbackNode !== null) {\n      cancelCallback(existingCallbackNode);\n    }\n    root.callbackNode = null;\n    root.callbackPriority = NoLane;\n    return;\n  }\n\n  // We use the highest priority lane to represent the priority of the callback.\n  // 获取 lanes 中优先级最高的 lane 作为 callback 的优先级\n  const newCallbackPriority = getHighestPriorityLane(nextLanes);\n\n  // Check if there's an existing task. We may be able to reuse it.\n  const existingCallbackPriority = root.callbackPriority;\n  // 由于即将要生成新的 callback，先将现在的 callback 取消掉\n  if (existingCallbackNode != null) {\n    // Cancel the existing callback. We'll schedule a new one below.\n    cancelCallback(existingCallbackNode);\n  }\n\n  // Schedule a new callback.\n  let newCallbackNode;\n  // 如果是同步更新任务\n  if (newCallbackPriority === SyncLane) {\n    // Special case: Sync React callbacks are scheduled on a special\n    // internal queue\n    // LegacyRoot 需要单独处理\n    if (root.tag === LegacyRoot) {\n      scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));\n    } else {\n      // 请求同步调度回调 performSyncWorkOnRoot，将该回调加入同步回调队列\n      scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n    }\n    if (supportsMicrotasks) {\n     // Flush the queue in a microtask.\n     //  支持微任务的浏览器不用再请求调度器的回调\n     scheduleMicrotask(() => {\n       // In Safari, appending an iframe forces microtasks to run.\n       // https://github.com/facebook/react/issues/22459\n       // We don't support running callbacks in the middle of render\n       // or commit so we need to check against that.\n       if (executionContext === NoContext) {\n         // It's only safe to do this conditionally because we always\n         // check for pending work before we exit the task.\n         // 消费完同步回调队列\n         flushSyncCallbacks();\n       }\n     });\n    } else {\n      // Flush the queue in an Immediate task.\n      // 向调度器请求回调，优先级 ImmediatePriority（立即回调），回调后执行 flushSyncCallbacks 将同步回调队列消费完\n      scheduleCallback(ImmediateSchedulerPriority, flushSyncCallbacks);\n    }\n    // 同步更新执行完毕，将 newCallbackNode 置为 null，performSyncWorkOnRoot 不会用到此值\n    newCallbackNode = null;\n  } else {\n    let schedulerPriorityLevel;\n    // 将 lanes 转化为事件优先级\n    switch (lanesToEventPriority(nextLanes)) {\n      // 离散事件优先级：ImmediateSchedulerPriority\n      case DiscreteEventPriority:\n        schedulerPriorityLevel = ImmediateSchedulerPriority;\n        break;\n      // 连续事件优先级：UserBlockingSchedulerPriority\n      case ContinuousEventPriority:\n        schedulerPriorityLevel = UserBlockingSchedulerPriority;\n        break;\n      // 默认事件优先级：NormalSchedulerPriority\n      case DefaultEventPriority:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n      // Idle 事件优先级：IdleSchedulerPriority\n      case IdleEventPriority:\n        schedulerPriorityLevel = IdleSchedulerPriority;\n        break;\n      default:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n    }\n    // 向调度器请求相应优先级的异步回调，回调后执行 performConcurrentWorkOnRoot，Scheduler.scheduleCallback 返回调度的 callbackNode(newTask)\n    newCallbackNode = scheduleCallback(\n      schedulerPriorityLevel,\n      performConcurrentWorkOnRoot.bind(null, root),\n    );\n  }\n  // 更新 callbackPriority 和 callbackNode 注意，此时异步回调并未执行\n  root.callbackPriority = newCallbackPriority;\n  root.callbackNode = newCallbackNode;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n\n这个函数有以下几个关键作用：\n\n * 更新 root 的 callbackNode、callbackPriority 属性。\n * 同步更新调度：支持微任务的直接在微任务的回调执行 flushSyncCallbacks；调用 scheduleSyncCallback 将同步回调 performSyncWorkOnRoot 推入同步回调队列 syncQueue，并且以 ImmediateSchedulerPriority 的优先级向调度器请求同步回调，回调时执行 flushSyncCallbacks 消费同步队列中所有的同步回调。\n * 异步更新调度：根据 nextLanes 计算事件优先级，并且转化为调度优先级，以相应的调度优先级向调度器发起异步回调，回调时执行 performConcurrentWorkOnRoot。\n * 注意同步调度中调用了 scheduleSyncCallback、scheduleCallback 两个函数不可混淆，scheduleCallback 只是 Scheduler 提供的一种基于优先级机制的任务（回调）调度手段，performSyncWorkOnRoot 和 performConcurrentWorkOnRoot 才是真正要通过调度执行的任务。同步的任务通过同步回调队列的方式进行了优化处理。scheduleSyncCallback 是将同步的任务加入同步任务队列。调度器不是不可替换的，如果浏览器支持微任务，同步任务的处理就可以交给微任务处理，而不经过调度器。\n\nnextLanes 优先级是如何计算的？参见 Lane 与优先级\n\n新知\n\n * 调度更新都是通过 HostRoot 实现的，从 ensureRootIsScheduled 中之传入 root ，而没有传入 fiber 可见 HostRoot 对于 react 中整个调和过程的重要性。\n\n\n# DiscreteEventPriority 和 ContinuousEventPriority\n\n * 离散事件：discreteEvent，常见的如：click, keyup, change；\n * 用户阻塞事件：userBlocking，常见的如：dragEnter, mouseMove, scroll；\n * 连续事件：continuous，常见的如：error, progress, load；\n\n更多解析可以参考：React 中的事件监听机制\n\n\n# scheduleMicrotask 与 queueMicrotask\n\n可以看到，如果浏览器支持 queueMicrotask，同步调度就不用经过调度器，而是直接交由微任务处理，这样既减少了 performSyncWorkOnRoot 执行的压力，同时又要比 setTimeout 这样的宏任务更快的执行。queueMicrotask 可以由 Promise 来模拟。queueMicrotask () 方法将微任务排队以调用 callback。\n\n什么是 queueMicrotask？\n\n> queueMicrotask adds the function (task) into a queue and each function is executed one by one (FIFO) after the current task has completed its work and when there is no other code waiting to be run before control of the execution context is returned to the browser's event loop.\n\nreact 中 queueMicrotask 的使用：\n\nconst localPromise = typeof Promise === 'function' ? Promise : undefined;\nexport const supportsMicrotasks = true;\nexport const scheduleTimeout: any =\n  typeof setTimeout === 'function' ? setTimeout : (undefined: any);\n\nexport const scheduleMicrotask: any =\n  typeof queueMicrotask === 'function'\n    ? queueMicrotask\n    : typeof localPromise !== 'undefined'\n    ? callback =>\n        localPromise\n          .resolve(null)\n          .then(callback)\n          .catch(handleErrorInNextTick)\n    : scheduleTimeout; // TODO: Determine the best fallback here.\n\nfunction handleErrorInNextTick(error) {\n  setTimeout(() => {\n    throw error;\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n了解更多关于微任务可以参考：\n\n * 在 JavaScript 中通过 queueMicrotask () 使用微任务\n * An Introduction to JavaScript's queueMicrotask\n * caniuse: queueMicrotask API\n\n\n# scheduleSyncCallback 和 scheduleCallback\n\n在上面对 ensureRootIsScheduled 的分析中我们知道，ensureRootIsScheduled 对同步任务和异步任务分别进行了同步调度和异步调度，分别调用 scheduleSyncCallback 和 scheduleCallback，那么具体同步调度和异步调度是如何进行的呢？\n\n\n# scheduleSyncCallback 和 flushSyncCallbacks\n\nscheduleSyncCallback 维护一个同步更新的任务队列，调用 flushSyncCallbacks 可全数消费任务任务中的所有任务。\n\n// src/react/packages/react-reconciler/src/ReactFiberSyncTaskQueue.new.js\nexport function scheduleSyncCallback(callback: SchedulerCallback) {\n  // Push this callback into an internal queue. We'll flush these either in\n  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.\n  if (syncQueue === null) {\n    syncQueue = [callback];\n  } else {\n    // Push onto existing queue. Don't need to schedule a callback because\n    // we already scheduled one when we created the queue.\n    syncQueue.push(callback);\n  }\n}\n\nexport function flushSyncCallbacks() {\n  // isFlushingSyncQueue 是 syncQueue 的互斥锁，消费 callbacks 是一个互斥操作\n  if (!isFlushingSyncQueue && syncQueue !== null) {\n    // Prevent re-entrance.\n    isFlushingSyncQueue = true;\n    let i = 0;\n    const previousUpdatePriority = getCurrentUpdatePriority();\n    try {\n      const isSync = true;\n      const queue = syncQueue;\n      // TODO: Is this necessary anymore? The only user code that runs in this\n      // queue is in the render or commit phases.\n      setCurrentUpdatePriority(DiscreteEventPriority);\n      // flush syncQueue，每个 callback 可以返回一个新的 callback\n      for (; i < queue.length; i++) {\n        let callback = queue[i];\n        do {\n          callback = callback(isSync);\n        } while (callback !== null);\n      }\n      // 重置 syncQueue\n      syncQueue = null;\n      includesLegacySyncCallbacks = false;\n    } catch (error) {\n      // If something throws, leave the remaining callbacks on the queue.\n      // 如果syncQueue 中每个 RootCallback 发生了错误，则跳过此项\n      if (syncQueue !== null) {\n        syncQueue = syncQueue.slice(i + 1);\n      }\n      // Resume flushing in the next tick\n      // 调度在下一个同步调度中继续执行\n      scheduleCallback(ImmediatePriority, flushSyncCallbacks);\n      throw error;\n    } finally {\n      setCurrentUpdatePriority(previousUpdatePriority);\n      isFlushingSyncQueue = false;\n    }\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n这两个函数有如下关键作用：\n\n * 维护同步回调的 syncQueue，以在同步回调到来时 flush syncQueue。\n\n更多分析，请参考 React 首次渲染过程 中的 flushSyncCallbacks 函数分析。\n\n\n# scheduleCallback\n\n这部分会与调度器交互，在 react 中，调度器是一个单独的模块，这里不再展开。现在需要知道的是，调度器会根据各种异步任务的优先级选择高优先级的任务进行回调，回调中执行 performSyncWorkOnRoot。\n\n调度器详细可以参考调度器章节内容。\n\n\n# performSyncWorkOnRoot\n\n从上面的分析中，我们已经知道了调度器同步调度的回调（可以不通过调度器）是由 performSyncWorkOnRoot 函数来处理的，下面我们来具体探究下这个函数：\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\n// This is the entry point for synchronous tasks that don't go\n// through Scheduler\nfunction performSyncWorkOnRoot(root) {\n  // 如果当前是 Render 阶段或者 Commit 阶段就报错，因为此时应该还在 Batch 阶段\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n  // 进入 Render 阶段前，先把 effects 和 callbacks 都消费掉。\n  flushPassiveEffects();\n  // 获取即将渲染的 lanes\n  let lanes = getNextLanes(root, NoLanes);\n  // 如果 lanes 中不包含 SyncLane，这说明没有同步的任务需要 renderRootSync，返回 ensureRootIsScheduled 重新调度一次\n  if (!includesSomeLane(lanes, SyncLane)) {\n    // There's no remaining sync work left.\n    ensureRootIsScheduled(root, now());\n    return null;\n  }\n  // 同步的 render HostRoot，返回 workInProgressRootExitStatus 表示退出时执行的状态，\n  // 包括 RootIncomplete、RootFatalErrored、RootErrored、RootSuspended、RootSuspendedWithDelay、RootCompleted\n  let exitStatus = renderRootSync(root, lanes);\n  // 如果发生普通错误，重试同步渲染，最多重试 50 次\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\n    // If something threw an error, try rendering one more time. We'll render\n    // synchronously to block concurrent data mutations, and we'll includes\n    // all pending updates are included. If it still fails after the second\n    // attempt, we'll give up and commit the resulting tree.\n    const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n    if (errorRetryLanes !== NoLanes) {\n      lanes = errorRetryLanes;\n      exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n    }\n  }\n  // 如果发生了致命错误，重置到非错误的状态，将 HostRoot 标记为 suspend 并且重新调度一次\n  if (exitStatus === RootFatalErrored) {\n    const fatalError = workInProgressRootFatalError;\n    prepareFreshStack(root, NoLanes);\n    markRootSuspended(root, lanes);\n    ensureRootIsScheduled(root, now());\n    throw fatalError;\n  }\n\n  // We now have a consistent tree. Because this is a sync render, we\n  // will commit it even if something suspended.\n  // 将渲染后的 RootFiber 和 lanes 更新到 HostRoot 上\n  const finishedWork: Fiber = (root.current.alternate: any);\n  root.finishedWork = finishedWork;\n  root.finishedLanes = lanes;\n  // 提交 HostRoot 上的更新，通知调度器在帧尾 yield 一次，浏览器重绘。\n  commitRoot(root);\n\n  // Before exiting, make sure there's a callback scheduled for the next\n  // pending level.\n  // 保证每次 renderSync 之后，调度不会闲置\n  ensureRootIsScheduled(root, now());\n\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n分析一下这个函数：\n\n * flushPassiveEffects 中主要调用 flushSyncCallbacks、commitPassiveUnmountEffects、commitPassiveMountEffects 这三个函数。调用这个函数的目的是什么？我们注意到， performSyncWorkOnRoot 会随着 scheduleSyncCallback 的调用而被执行，因此在 performSyncWorkOnRoot 执行时，很可能又有新的同步任务加入到同步回调队列中，所以为了提高同步渲染的效率，同时满足同步任务今早执行的目的，在 renderRootSync 之前，重新消费 SyncCallbacks。\n * 调用 renderRootSync 渲染合同更新。返回一个退出状态，如果发生普通错误，采取重试策略；如果发生了致命错误，则采取重置策略。即使发生了普通的错误，本次 render 仍然被 commit，除非发生了 致命的错误，将抛出一个错误。\n * commitRoot 需要调度器的支持，需要调度器在 raf 的帧的末尾提交浏览器绘制。\n * performSyncWorkOnRoot 中任何情况的退出都要调用 ensureRootIsScheduled，保证调度不会被闲置。\n * performSyncWorkOnRoot 可以不通过 Scheduler 的调度。\n\n这个函数的关键作用如下：\n\n * 调用 renderRootSync 同步渲染更新。\n * 普通错误和致命错误的处理。\n * 调用 commitRoot 提交 HostRoot 上的更新，触发浏览器 paint。\n\n\n# performConcurrentWorkOnRoot\n\n在上面的分析中，我们知道调度器异步任务调度的回调是由 performConcurrentWorkOnRoot 来处理的，下面我们具体来看下 performConcurrentWorkOnRoot 这个函数，并且与 performSyncWorkOnRoot 进行对比。\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\n// If two updates are scheduled within the same event, we should treat their\n// event times as simultaneous, even if the actual clock time has advanced\n// between the first and second call.\nlet currentEventTime: number = NoTimestamp;\n\n// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  // Since we know we're in a React event, we can clear the current\n  // event time. The next update will compute a new event time.\n  currentEventTime = NoTimestamp;\n  currentEventTransitionLane = NoLanes;\n  // 如果当前是 Render 阶段或者 Commit 阶段就报错，因为当前应该还在 Batch 阶段\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  // Flush any pending passive effects before deciding which lanes to work on,\n  // in case they schedule additional work.\n  const originalCallbackNode = root.callbackNode;\n  // 在 RenderConcurrent 之前再次消费完 callbacks 和 effects。\n  const didFlushPassiveEffects = flushPassiveEffects();\n  if (didFlushPassiveEffects) {\n    // Something in the passive effect phase may have canceled the current task.\n    // Check if the task node for this root was changed.\n    // 检查 flushPassiveEffects 之后 callbackNode 是否改变，如果变化了，舍弃之后的渲染工作，因为新的调度已经来临\n    if (root.callbackNode !== originalCallbackNode) {\n      // The current task was canceled. Exit. We don't need to call\n      // `ensureRootIsScheduled` because the check above implies either that\n      // there's a new task, or that there's no remaining work on this root.\n      return null;\n    } else {\n      // Current task was not canceled. Continue.\n    }\n  }\n\n  // Determine the next lanes to work on, using the fields stored\n  // on the root.\n  // 计算当前要渲染的 lanes\n  let lanes = getNextLanes(\n    root,\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\n  );\n  if (lanes === NoLanes) {\n    // Defensive coding. This is never expected to happen.\n    return null;\n  }\n\n  // We disable time-slicing in some cases: if the work has been CPU-bound\n  // for too long (\"expired\" work, to prevent starvation), or we're in\n  // sync-updates-by-default mode.\n  // 判断是否要进行时间切片，这决定是改用同步 Render 还是继续异步 Render\n  // 包含有 Blocking 优先级的 lane 的任务，或者包含有过时 line 的任务要改为同步 Render \n  const shouldTimeSlice =\n    !includesBlockingLane(root, lanes) &&\n    !includesExpiredLane(root, lanes) &&\n    (disableSchedulerTimeoutInWorkLoop || !didTimeout);\n  let exitStatus = shouldTimeSlice\n    ? renderRootConcurrent(root, lanes)\n    : renderRootSync(root, lanes);\n  // 如果 Render 的结果不是 RootIncomplete，说明出现了异常情况\n  if (exitStatus !== RootIncomplete) {\n    if (exitStatus === RootErrored) {\n      // If something threw an error, try rendering one more time. We'll\n      // render synchronously to block concurrent data mutations, and we'll\n      // includes all pending updates are included. If it still fails after\n      // the second attempt, we'll give up and commit the resulting tree.\n      // 如果是普通错误，重试若干次\n      const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n      if (errorRetryLanes !== NoLanes) {\n        lanes = errorRetryLanes;\n        exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n      }\n    }\n    if (exitStatus === RootFatalErrored) {\n      const fatalError = workInProgressRootFatalError;\n      prepareFreshStack(root, NoLanes);\n      markRootSuspended(root, lanes);\n      ensureRootIsScheduled(root, now());\n      throw fatalError;\n    }\n\n    // Check if this render may have yielded to a concurrent event, and if so,\n    // confirm that any newly rendered stores are consistent.\n    const renderWasConcurrent = !includesBlockingLane(root, lanes);\n    const finishedWork: Fiber = (root.current.alternate: any);\n    if (\n      renderWasConcurrent &&\n      !isRenderConsistentWithExternalStores(finishedWork)\n    ) {\n      // A store was mutated in an interleaved event. Render again,\n      // synchronously, to block further mutations.\n      exitStatus = renderRootSync(root, lanes);\n\n      // We need to check again if something threw\n      if (exitStatus === RootErrored) {\n        const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n        if (errorRetryLanes !== NoLanes) {\n          lanes = errorRetryLanes;\n          exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n          // We assume the tree is now consistent because we didn't yield to any\n          // concurrent events.\n        }\n      }\n      if (exitStatus === RootFatalErrored) {\n        const fatalError = workInProgressRootFatalError;\n        prepareFreshStack(root, NoLanes);\n        markRootSuspended(root, lanes);\n        ensureRootIsScheduled(root, now());\n        throw fatalError;\n      }\n    }\n\n    // We now have a consistent tree. The next step is either to commit it,\n    // or, if something suspended, wait to commit it after a timeout.\n    root.finishedWork = finishedWork;\n    root.finishedLanes = lanes;\n    finishConcurrentRender(root, exitStatus, lanes);\n  }\n  // 完成 Render 之后，重新发起一次调度，以保证调度不会被中断\n  ensureRootIsScheduled(root, now());\n  // 如果新的新的调度节点将仍然发生在相同的 HostRoot，那就不用等调度器的调度，直接继续 performConcurrentWorkOnRoot\n  // 注意：ensureRootIsScheduled 会产生一个 newCallbackNode，更新 root.callbackNode\n  if (root.callbackNode === originalCallbackNode) {\n    // The task node scheduled for this root is the same one that's\n    // currently executed. Need to return a continuation.\n    return performConcurrentWorkOnRoot.bind(null, root);\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n\n * currentEventTime 在 scheduleUpdateOnFiber 和 createUpdate 之前生成，即创建更新时生成，到 performConcurrentWorkOnRoot 被重置。每个 update 对象中有 eventTime。\n * performConcurrentWorkOnRoot 必须通过 Scheduler 的调度才有机会执行。这与 performSyncWorkOnRoot 有所不同。\n * 从整体来看，performSyncWorkOnRoot 和 performConcurrentWorkOnRoot 流程是相似的，包括 executionContext 的判断、调用 renderRoot、错误判断等。\n * 在 RenderConcurrent 之前再次消费完 callbacks 和 effects，原因是为了节省调度资源，同时保证更新被尽快的处理。当然，这里有一个细节，如果在 消费完 callbacks 和 effects 的过程中，root.callbackNode 发生了变化，则舍弃当前的 RenderRoot 等后续流程，因为新的调度即将来临。之所以舍弃当前的调度是因为，新的任务具有更高的优先级或者当前的调度已经没有任务可执行了。\n * 在 RenderRoot 之前，仍然对 lanes 做了判断，如果 lanes 中有 blocking 优先级的任务或者过时的任务（过时的任务具有立即执行的优先级）就会使用同步渲染，没有上述的情况才会使用异步渲染。同步渲染和异步渲染分别调用 renderRootSync 和 renderRootConcurrent 执行。\n * 在错误处理方面，对待普通的错误容忍度还是比较高的，recoverFromConcurrentError 将对错误执行之多 50 次的重试，注意，重试时是以 renderRootSync 即同步渲染执行的。\n * 在 RenderRoot 之后，无论错误与否，都需要调用 ensureRootIsScheduled 以保证调度不会被闲置。由于异步渲染需要调度器调度的时间相对于同步渲染要长，这里做了一个优化处理，如果预知到新的调度仍然会出现在同一个 HostRoot 上，就可以直接继续调用自身以继续完成 HostRoot 上的渲染任务。\n\n\n# finishConcurrentRender\n\n在这个函数中，会根据 exitStatus 的状态执行不同的处理操作，主要是 commitRoot 操作。\n\nfunction finishConcurrentRender(root, exitStatus, lanes) {\n  switch (exitStatus) {\n    // 这两种情况在 performConcurrentWorkOnRoot 中已经处理了，应该不会被执行到\n    case RootIncomplete:\n    case RootFatalErrored: {\n      throw new Error('Root did not complete. This is a bug in React.');\n    }\n    // RootErrored 的情况在 performConcurrentWorkOnRoot 中已经对错误情况重试了，这里将直接 commitRoot\n    case RootErrored: {\n      // We should have already attempted to retry this tree. If we reached\n      // this point, it errored again. Commit it.\n      commitRoot(root);\n      break;\n    }\n    // 如果 renderRoot 退出后返回 RootSuspended，则将当前的 HostRoot 标记为 suspended\n    case RootSuspended: {\n      markRootSuspended(root, lanes);\n\n      // We have an acceptable loading state. We need to figure out if we\n      // should immediately commit it or wait a bit.\n\n      if (\n        includesOnlyRetries(lanes) &&\n        // do not delay if we're inside an act() scope\n        !shouldForceFlushFallbacksInDEV()\n      ) {\n        // This render only included retries, no updates. Throttle committing\n        // retries so that we don't show too many loading states too quickly.\n        const msUntilTimeout =\n          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\n        // Don't bother with a very short suspense time.\n        if (msUntilTimeout > 10) {\n          const nextLanes = getNextLanes(root, NoLanes);\n          if (nextLanes !== NoLanes) {\n            // There's additional work on this root.\n            break;\n          }\n          const suspendedLanes = root.suspendedLanes;\n          if (!isSubsetOfLanes(suspendedLanes, lanes)) {\n            // We should prefer to render the fallback of at the last\n            // suspended level. Ping the last suspended level to try\n            // rendering it again.\n            // FIXME: What if the suspended lanes are Idle? Should not restart.\n            const eventTime = requestEventTime();\n            markRootPinged(root, suspendedLanes, eventTime);\n            break;\n          }\n\n          // The render is suspended, it hasn't timed out, and there's no\n          // lower priority work to do. Instead of committing the fallback\n          // immediately, wait for more data to arrive.\n          // 在 root.timeoutHandle 挂载延时器，延迟执行 commitRoot\n          root.timeoutHandle = scheduleTimeout(\n            commitRoot.bind(null, root),\n            msUntilTimeout,\n          );\n          break;\n        }\n      }\n      // The work expired. Commit immediately.\n      commitRoot(root);\n      break;\n    }\n    case RootSuspendedWithDelay: {\n      markRootSuspended(root, lanes);\n\n      if (includesOnlyTransitions(lanes)) {\n        // This is a transition, so we should exit without committing a\n        // placeholder and without scheduling a timeout. Delay indefinitely\n        // until we receive more data.\n        break;\n      }\n\n      if (!shouldForceFlushFallbacksInDEV()) {\n        // This is not a transition, but we did trigger an avoided state.\n        // Schedule a placeholder to display after a short delay, using the Just\n        // Noticeable Difference.\n        // TODO: Is the JND optimization worth the added complexity? If this is\n        // the only reason we track the event time, then probably not.\n        // Consider removing.\n\n        const mostRecentEventTime = getMostRecentEventTime(root, lanes);\n        const eventTimeMs = mostRecentEventTime;\n        const timeElapsedMs = now() - eventTimeMs;\n        const msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\n\n        // Don't bother with a very short suspense time.\n        if (msUntilTimeout > 10) {\n          // Instead of committing the fallback immediately, wait for more data\n          // to arrive.\n          root.timeoutHandle = scheduleTimeout(\n            commitRoot.bind(null, root),\n            msUntilTimeout,\n          );\n          break;\n        }\n      }\n\n      // Commit the placeholder.\n      commitRoot(root);\n      break;\n    }\n    // 如果渲染任务退出状态为 RootCompleted，直接 commitRoot\n    case RootCompleted: {\n      // The work completed. Ready to commit.\n      commitRoot(root);\n      break;\n    }\n    default: {\n      throw new Error('Unknown root exit status.');\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n\n\n\n# renderRootSync\n\n在上面的分析中，我们已经知道 performSyncWorkOnRoot 和 performConcurrentWorkOnRoot 将会调用 renderRootSync 以完成同步渲染的任务，那么在 commitRoot 之前，同步渲染任务是如何完成的呢？\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\n  // 先缓存下 executionContext，以便于错误恢复\n  const prevExecutionContext = executionContext;\n  // 将 RenderContext 加入 executionContext 中\n  executionContext |= RenderContext;\n  // 推出 ReactCurrentDispatcher.current，ReactCurrentDispatcher.current 将被重置为 ContextOnlyDispatcher\n  const prevDispatcher = pushDispatcher();\n\n  // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n  // 如果发现 workInProgressRoot 和 workInProgressRootRenderLanes 已经不要将要渲染的 root 和 lanes 了，将对 root 和 workInProgress 等变量执行清理和重置工作\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    prepareFreshStack(root, lanes);\n  }\n  // 开启一个 workLoopSync 循环，handleError 将捕获和处理 workLoopSync 执行中的错误。\n  do {\n    try {\n      workLoopSync();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n  // 当 workLoopSync 的循环退出后，所有渲染工作就执行完毕，\n  resetContextDependencies();\n  // 将 executionContext 恢复至渲染之前的状态，这表明 RenderContext 和 CommitContext（将在后文中加入） 将会被移除，之所以可以这样做，是因为我们刚好需要重置到 BatchedContext\n  executionContext = prevExecutionContext;\n  // 推入 ReactCurrentDispatcher.current，ReactCurrentDispatcher.current 将置为 prevDispatcher\n  popDispatcher(prevDispatcher);\n  // workLoopSync 循环执行完之后，workInProgress 应该置空，否则说明可能有工作没有执行完，所以报错\n  if (workInProgress !== null) {\n    // This is a sync render, so we should have finished the whole tree.\n    throw new Error(\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\n        'bug in React. Please file an issue.',\n    );\n  }\n  // 继 workInProgress 置空之后，也重置 workInProgressRoot 和 workInProgressRootRenderLanes，这表明没有任何任务正在被渲染。\n  // Set this to null to indicate there's no in-progress render.\n  workInProgressRoot = null;\n  workInProgressRootRenderLanes = NoLanes;\n  // workInProgressRootExitStatus 是文件中的一个全局变量，表示 HostRoot 渲染之后退出时的状态，workLoopSync 会更新这个值。\n  return workInProgressRootExitStatus;\n}\n\nexport function resetContextDependencies(): void {\n  // This is called right before React yields execution, to ensure `readContext`\n  // cannot be called outside the render phase.\n  currentlyRenderingFiber = null;\n  lastContextDependency = null;\n  lastFullyObservedContext = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n * 这里 executionContext 使用很巧妙，这里直接缓存了 executionContext 的值，并在执行完 workLoopSync 之后恢复。这是因为 renderRoot 中会在 executionContext 加入 RenderContext，而在 workLoop 中，则会在 executionContext 加入 CommitContext。因此这里直接将 executionContext 恢复至 BatchContext。\n * 在执行 renderRoot 时，ReactCurrentDispatcher.current 将被重置为 ContextOnlyDispatcher，在执行完毕后恢复原值，这以为这什么呢？在 useState 和 useReducer 原理探析 一文中已经套就过 ReactCurrentDispatcher.current 中挂载的不同类型的 dispatcher 将会使用不同实现的 hooks。从下面的代码可以看出，在此阶段，所有的 hook 调用都会由 throwInvalidHookError 报错。\n * 具体的渲染工作 workLoopSync 完成的，这是一个死循环，直到 workLoopSync 正常执行时退出。\n * 渲染完毕后会执行一些重置工作，包括 workInProgress、workInProgressRoot、workInProgressRootRenderLanes 等。\n\nexport const ContextOnlyDispatcher: Dispatcher = {\n  readContext,\n\n  useCallback: throwInvalidHookError,\n  useContext: throwInvalidHookError,\n  useEffect: throwInvalidHookError,\n  useImperativeHandle: throwInvalidHookError,\n  useInsertionEffect: throwInvalidHookError,\n  useLayoutEffect: throwInvalidHookError,\n  useMemo: throwInvalidHookError,\n  useReducer: throwInvalidHookError,\n  useRef: throwInvalidHookError,\n  useState: throwInvalidHookError,\n  useDebugValue: throwInvalidHookError,\n  useDeferredValue: throwInvalidHookError,\n  useTransition: throwInvalidHookError,\n  useMutableSource: throwInvalidHookError,\n  useSyncExternalStore: throwInvalidHookError,\n  useId: throwInvalidHookError,\n\n  unstable_isNewReconciler: enableNewReconciler,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# renderRootConcurrent\n\n在前面的分析中，我们知道 performConcurrentWorkOnRoot 函数会调用 renderRootConcurrent 去完成异步任务的渲染工作。现在我们来看下异步任务是如何完成的？这里与 renderRootSync 类似，将简略分析。\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\n  const prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  const prevDispatcher = pushDispatcher();\n\n  // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    resetRenderTimer();\n    prepareFreshStack(root, lanes);\n  }\n\n  do {\n    try {\n      workLoopConcurrent();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n  resetContextDependencies();\n\n  popDispatcher(prevDispatcher);\n  executionContext = prevExecutionContext;\n\n  // Check if the tree has completed.\n  if (workInProgress !== null) {\n    return RootIncomplete;\n  } else {\n    // Set this to null to indicate there's no in-progress render.\n    workInProgressRoot = null;\n    workInProgressRootRenderLanes = NoLanes;\n\n    // Return the final exit status.\n    return workInProgressRootExitStatus;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n * 这里调用了 workLoopConcurrent 以完成异步渲染任务，同样是死循环的设计，直到 workLoopConcurrent 执行成功。\n * 不同的是，在 renderRootConcurrent 中，workLoopConcurrent 循环执行之后，workInProgress 是可以不为 null 的，在 中，workLoopSync 中将直接报错。需要注意的是，异步任务是可以不完成的，这时会返回 exitStatus 为 RootIncomplete。\n\n\n# handleError\n\nfunction handleError(root, thrownValue): void {\n  do {\n    let erroredWork = workInProgress;\n    try {\n      // Reset module-level state that was set during the render phase.\n      resetContextDependencies();\n      resetHooksAfterThrow();\n      // TODO: I found and added this missing line while investigating a\n      // separate issue. Write a regression test using string refs.\n      ReactCurrentOwner.current = null;\n\n      // 如果 workInProgress 不存在，或者 workInProgress.return 不存在则视为致命错误\n      if (erroredWork === null || erroredWork.return === null) {\n        // Expected to be working on a non-root fiber. This is a fatal error\n        // because there's no ancestor that can handle it; the root is\n        // supposed to capture all errors that weren't caught by an error\n        // boundary.\n        workInProgressRootExitStatus = RootFatalErrored;\n        workInProgressRootFatalError = thrownValue;\n        // Set `workInProgress` to null. This represents advancing to the next\n        // sibling, or the parent if there are no siblings. But since the root\n        // has no siblings nor a parent, we set it to null. Usually this is\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n        // intentionally not calling those, we need set it here.\n        // TODO: Consider calling `unwindWork` to pop the contexts.\n        workInProgress = null;\n        return;\n      }\n\n      // 非致命错误将抛出异常、直接跳到完成渲染的回调\n      throwException(\n        root,\n        erroredWork.return,\n        erroredWork,\n        thrownValue,\n        workInProgressRootRenderLanes,\n      );\n      completeUnitOfWork(erroredWork);\n    } catch (yetAnotherThrownValue) {\n      // Something in the return path also threw.\n      // 如果 workInProgress 上处理错误仍然抛出错误，找到 workInProgress.return 将其设置 erroredWork，错误将抛到父级处理。\n      thrownValue = yetAnotherThrownValue;\n      if (workInProgress === erroredWork && erroredWork !== null) {\n        // If this boundary has already errored, then we had trouble processing\n        // the error. Bubble it to the next boundary.\n        erroredWork = erroredWork.return;\n        workInProgress = erroredWork;\n      } else {\n        erroredWork = workInProgress;\n      }\n      continue;\n    }\n    // 只有没有 yetAnotherThrownValue 时才正常退出到 work loop\n    // Return to the normal work loop.\n    return;\n  } while (true);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n * 对于致命错误将直接将 workInProgress 置为 null，exitStatus 将抛出致命错误。\n * 对于普通错误，抛出异常并且调用 completeUnitOfWork 执行渲染完毕的逻辑，这里 workInProgress 也会被值为 null。无论是致命错误还是普通错误都会正常跳出 workLoop。\n * 对于处理过程中仍然抛出错误的错误，将向父级冒泡处理错误，知道错误被解决。\n\n\n# workLoopSync\n\n通过上面的分析可以知道，renderRootSync 会调用 workLoopSync 完成同步任务的渲染，现在我们来看下 workLoopSync 函数。\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\n// The work loop is an extremely hot path. Tell Closure not to inline it.\n/** @noinline */\nfunction workLoopSync() {\n  // Already timed out, so perform work without checking if we need to yield.\n  while (workInProgress !== null) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 这个函数就是在 workInProgress 还有值的时候执行 performUnitOfWork 消费 workInProgress。同步渲染会完成所有的任务，即处理 HostRoot 上所有 Fiber 上的同步更新。\n * @noinline 是 chrome 浏览器的一种优化标注。 Google Closure Compiler 使用此标注是函数或者标注不被转换成 inline。详见：@noinline。浏览器 js 引擎通过 inline 优化提升代码解析效率，这通常对一些常量、不太执行的函数（如工厂函数，我们将在 vue 源码中看到）有效，对执行频率较高的函数和变量反而效率很低。这里 @noinline 标注意思是不要使用 inline 优化，以免降低代码执行效率。\n\n提示\n\ninline 优化是什么？\n\nIn computing, inline expansion, or inlining, is a manual or compiler optimization that replaces a function call site with the body of the called function. Inline expansion is similar to macro expansion, but occurs during compilation, without changing the source code (the text), while macro expansion occurs prior to compilation, and results in different text that is then processed by the compiler.\n\n * Inline expansion\n\n\n# workLoopConcurrent\n\n在 renderRootConcurrent 函数中会调用 workLoopConcurrent 以完成异步渲染任务。workLoopConcurrent 与 workLoopSync 类似，不在赘述。\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\n/** @noinline */\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * workInProgress 为 null 是会直接跳出，或者 shouldYield 时也会跳出。因此跳出 workLoopConcurrent 有两种情况，一是所有任务都执行完了，二是调度器即将产生 (yield) 新回调了。\n\n\n# performUnitOfWork\n\n从上面的分析中，我们已经知道无论是 workLoopSync 还是 workLoopConcurrent 最终都会调用 performUnitOfWork，这说明同步任务和异步任务的分发，最终都是通过 performUnitOfWork 来真正执行的。也就是说，对于执行渲染任务而言，performUnitOfWork 才是背后默默干活的工人。下面我们着重分析下这个函数。\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n\nfunction performUnitOfWork(unitOfWork: Fiber): void {\n  // The current, flushed, state of this fiber is the alternate. Ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  const current = unitOfWork.alternate;\n\n  let next;\n \n  next = beginWork(current, unitOfWork, subtreeRenderLanes);\n\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n\n  ReactCurrentOwner.current = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * 在 fiber 与 Reconciliation 探析疑问中，我们分析过 Fiber 的结构，其中 fiber.alternate 是 fiber 上的一个版本池，当 fiber 更新以后会更新到 fiber.alternate 上。unitOfWork 本质是一个 fiber，其中 current 代表了 fiber 上一次更新的结果。\n * beginWork 对当前的 workInProgress 进行 render，渲染后返回下一个需要更新的 fiber。在 beginWork 中，我们将具体探讨 fiber 的遍历的方法和结构。\n * 当 next 为 null 时，所有 fiber render 完毕，因此执行 completeUnitOfWork。上一次执行 completeUnitOfWork 还是在 renderRootSync 和 renderRootConcurrent 的 handlerError 中遇到普通错误时。如果任务还没有完成，将 next 设置为 workInProgress，下次 performUnitOfWork 就会针对 next 进行 render。\n\n\n# beginWork\n\n在上面的分析中，我们已经知道 performUnitOfWork 会调用 beginWork 来执行 RootFiber 以及其下每一个 fiber 的渲染工作。那么具体执行了哪些工作呢？FiberTree 的遍历是如何进行呢？下面我们来看下 beginWork：\n\n// src/react/packages/react-reconciler/src/ReactFiberBeginWork.new.js\n\nfunction beginWork(\n  // 上次渲染的 fiber\n  current: Fiber | null,\n  // 本次要渲染的 fiber\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  // 非初次渲染\n  if (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n\n    if (\n      oldProps !== newProps ||\n      hasLegacyContextChanged() ||\n      // Force a re-render if the implementation changed due to hot reload:\n      (__DEV__ ? workInProgress.type !== current.type : false)\n    ) {\n      // If props or context changed, mark the fiber as having performed work.\n      // This may be unset if the props are determined to be equal later (memo).\n      didReceiveUpdate = true;\n    } else {\n      // Neither props nor legacy context changes. Check if there's a pending\n      // update or context change.\n      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(\n        current,\n        renderLanes,\n      );\n      if (\n        !hasScheduledUpdateOrContext &&\n        // If this is the second pass of an error or suspense boundary, there\n        // may not be work scheduled on `current`, so we check for this flag.\n        (workInProgress.flags & DidCapture) === NoFlags\n      ) {\n        // No pending updates or context. Bail out now.\n        didReceiveUpdate = false;\n        return attemptEarlyBailoutIfNoScheduledUpdate(\n          current,\n          workInProgress,\n          renderLanes,\n        );\n      }\n      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      } else {\n        // An update was scheduled on this fiber, but there are no new props\n        // nor legacy context. Set this to false. If an update queue or context\n        // consumer produces a changed value, it will set this to true. Otherwise,\n        // the component will assume the children have not changed and bail out.\n        didReceiveUpdate = false;\n      }\n    }\n  } else {\n    didReceiveUpdate = false;\n\n    if (getIsHydrating() && isForkedChild(workInProgress)) {\n      // Check if this child belongs to a list of muliple children in\n      // its parent.\n      //\n      // In a true multi-threaded implementation, we would render children on\n      // parallel threads. This would represent the beginning of a new render\n      // thread for this subtree.\n      //\n      // We only use this for id generation during hydration, which is why the\n      // logic is located in this special branch.\n      // index 记录了当前 fiber 排在父列表中的下标\n      const slotIndex = workInProgress.index;\n      const numberOfForks = getForksAtLevel(workInProgress);\n      pushTreeId(workInProgress, numberOfForks, slotIndex);\n    }\n  }\n\n  // Before entering the begin phase, clear pending update priority.\n  // TODO: This assumes that we're about to evaluate the component and process\n  // the update queue. However, there's an exception: SimpleMemoComponent\n  // sometimes bails out later in the begin phase. This indicates that we should\n  // move this assignment out of the common path and into each branch.\n  // 因为如下要真正渲染了，可以将优先级信息清空\n  workInProgress.lanes = NoLanes;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent: {\n      return mountIndeterminateComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        renderLanes,\n      );\n    }\n    case LazyComponent: {\n      const elementType = workInProgress.elementType;\n      return mountLazyComponent(\n        current,\n        workInProgress,\n        elementType,\n        renderLanes,\n      );\n    }\n    case FunctionComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateFunctionComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderLanes);\n    case HostComponent:\n      return updateHostComponent(current, workInProgress, renderLanes);\n    case HostText:\n      return updateHostText(current, workInProgress);\n    case SuspenseComponent:\n      return updateSuspenseComponent(current, workInProgress, renderLanes);\n    case HostPortal:\n      return updatePortalComponent(current, workInProgress, renderLanes);\n    case ForwardRef: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === type\n          ? unresolvedProps\n          : resolveDefaultProps(type, unresolvedProps);\n      return updateForwardRef(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case Fragment:\n      return updateFragment(current, workInProgress, renderLanes);\n    case Mode:\n      return updateMode(current, workInProgress, renderLanes);\n    case Profiler:\n      return updateProfiler(current, workInProgress, renderLanes);\n    case ContextProvider:\n      return updateContextProvider(current, workInProgress, renderLanes);\n    case ContextConsumer:\n      return updateContextConsumer(current, workInProgress, renderLanes);\n    case MemoComponent: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      // Resolve outer props first, then resolve inner props.\n      let resolvedProps = resolveDefaultProps(type, unresolvedProps);\n      if (__DEV__) {\n        if (workInProgress.type !== workInProgress.elementType) {\n          const outerPropTypes = type.propTypes;\n          if (outerPropTypes) {\n            checkPropTypes(\n              outerPropTypes,\n              resolvedProps, // Resolved for outer only\n              'prop',\n              getComponentNameFromType(type),\n            );\n          }\n        }\n      }\n      resolvedProps = resolveDefaultProps(type.type, resolvedProps);\n      return updateMemoComponent(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case SimpleMemoComponent: {\n      return updateSimpleMemoComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes,\n      );\n    }\n    case IncompleteClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return mountIncompleteClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case SuspenseListComponent: {\n      return updateSuspenseListComponent(current, workInProgress, renderLanes);\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        return updateScopeComponent(current, workInProgress, renderLanes);\n      }\n      break;\n    }\n    case OffscreenComponent: {\n      return updateOffscreenComponent(current, workInProgress, renderLanes);\n    }\n    case LegacyHiddenComponent: {\n      return updateLegacyHiddenComponent(current, workInProgress, renderLanes);\n    }\n    case CacheComponent: {\n      if (enableCache) {\n        return updateCacheComponent(current, workInProgress, renderLanes);\n      }\n      break;\n    }\n  }\n\n  throw new Error(\n    `Unknown unit of work tag (${workInProgress.tag}). This error is likely caused by a bug in ` +\n      'React. Please file an issue.',\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n\n * didReceiveUpdate 标记是否有属性或者 context 的更新，因为这两种情况会引发 re-render。\n * 重要环境在于根据 workInProgress.tag 类别创建或者更新不同的组件，这里具体过程不在赘述，可以参考 workLoop 和 performUnitOfWork 探析一文。\n * 需要注意的是，在上面 updateXXXComponent 的之后，会返回 workInProgress.child ，作为 performUnitOfWork 中的 next。根据这个线索，可以知道 react 中 performUnitOfWork 中是根据深度优先搜索（DFS）来进行遍历渲染的，那么这种遍历怎么扩展到兄弟节点呢？\n\n\n# completeUnitOfWork\n\n\n# completeWork\n\n\n# commitRoot",normalizedContent:"# 目录\n\n\n\n * 目录\n * reactdomhostconfig\n * updatecontainer\n * scheduleupdateonfiber\n   * 一个闭环\n   * 更新的来源\n * ensurerootisscheduled\n   * discreteeventpriority 和 continuouseventpriority\n   * schedulemicrotask 与 queuemicrotask\n * schedulesynccallback 和 schedulecallback\n   * schedulesynccallback 和 flushsynccallbacks\n   * schedulecallback\n * performsyncworkonroot\n * performconcurrentworkonroot\n   * finishconcurrentrender\n * renderrootsync\n * renderrootconcurrent\n   * handleerror\n * workloopsync\n * workloopconcurrent\n * performunitofwork\n * beginwork\n * completeunitofwork\n * completework\n * commitroot\n\n\n\n\n# reactdomhostconfig\n\n下面我们先探究一下生产更新的来源，主要分析 updatecontainer 和 scheduleupdateonfiber 两个函数。\n\n\n# updatecontainer\n\n更新是如何开始的？我们首先从 updatecontainer 的调用来源开始追溯。\n\n调用 updatecontainer 的函数包括： legacyrendersubtreeintocontainer、reactdomroot.prototype.render、reactdomroot.prototype.unmount、hydrateroot、scheduleroot。reactdomroot 由 reactdom.createroot 创建。scheduleroot 在 src/react/packages/react-reconciler/src/reactfiberhotreloading.new.js 文件中。\n\n// 应用层 api\nlegacyrendersubtreeintocontainer <- reactdom.hydrate\n                                 <- reactdom.render\n                                 <- reactdom.unmountcomponentatnode\n\n\n1\n2\n3\n4\n\n\n由上面的分析可以看出，updatecontainer 主要来源于应用层 api 的调用，这种调用生产了更新渲染的需求。那么 updatecontainer 主要做了什么？\n\n// src/react/packages/react-reconciler/src/reactfiberreconciler.new.js\nexport function updatecontainer(\n  // 待挂载的组件\n  element: reactnodelist,\n  // 挂载容器\n  container: opaqueroot,\n  parentcomponent: ?react$component<any, any>,\n  callback: ?function,\n): lane {\n  // 获取 rootfiber\n  const current = container.current;\n  const eventtime = requesteventtime();\n  const lane = requestupdatelane(current);\n\n  // 更新 container 的 context 信息\n  const context = getcontextforsubtree(parentcomponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingcontext = context;\n  }\n\n  // 创建一个更新\n  const update = createupdate(eventtime, lane);\n  // caution: react devtools currently depends on this property\n  // being called \"element\".\n  update.payload = {element};\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    update.callback = callback;\n  }\n\n  // 将新建的更新入栈\n  enqueueupdate(current, update, lane);\n  // 请求一次调度更新\n  const root = scheduleupdateonfiber(current, lane, eventtime);\n  if (root !== null) {\n    entangletransitions(root, current, lane);\n  }\n\n  return lane;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\nupdatecontainer 关键功能如下：\n\n * 继续完善 fiberroot 信息：context、pendingcontext。\n * 初始化创建一个更新对象，添加属性 payload、callback，并且将更新加入更新队列。\n * 调用 scheduleupdateonfiber，(向调度器) 发出一次调度的请求。\n\n扩展\n\n 1. createupdate 创建更新在组件的生命周期或者用户行为中也会产生，如函数式组件（fc）中的 setstate、usecontext 的 dispatchaction、类组件的 this.setstate 中，两种不同之处在于前者是应用层面的调用，后者则是组件层面的调用。\n 2. 注意，scheduleupdateonfiber 的调度请求并不一定经过调度器，同步更新可能会跳过调度器的调度，后面会说明这一点。\n\n\n# scheduleupdateonfiber\n\n在 updatecontainer 中，调用了 scheduleupdateonfiber 以在 fiber（此处指的是 rootfiber） 上调度一次更新，那么调度更新是如何在 fiber 上展开的呢？\n\n首先来分析一下代码：\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\n// lanes that were updated during the render phase (*not* an interleaved event).\nlet workinprogressrootrenderphaseupdatedlanes: lanes = nolanes;\n// whether to root completed, errored, suspended, etc.\nlet workinprogressrootexitstatus: rootexitstatus = rootincomplete;\n\nexport function mergelanes(a: lanes | lane, b: lanes | lane): lanes {\n  return a | b;\n}\n\nexport function scheduleupdateonfiber(\n  //  rootfiber\n  fiber: fiber,\n  // 调度优先级\n  lane: lane,\n  eventtime: number,\n): fiberroot | null {\n  // 检查嵌套更新，防止死循环\n  checkfornestedupdates();\n  // 从 fiber 向上收集 lanes，root：fiberroot = fiber.statenode。对于 updatecontainer 来说，这里 fiber 就是 rootfiber。\n  const root = markupdatelanefromfibertoroot(fiber, lane);\n  // fiberroot 不存在，说明 fibertree 可能已经被废弃，不用更新\n  if (root === null) {\n    return null;\n  }\n\n  // mark that the root has a pending update.\n  // 标记 root 即将更新，root.pendinglanes |= lane\n  markrootupdated(root, lane, eventtime);\n  // 如果当前已经是 render 阶段，且 root 是待处理的 hostroot，这时跳过渲染的调度请求，并且追踪 lane，加入到 render 阶段的 lanes，就在在当前调度的回调中参与渲染，或者等待下次渲染。\n  if (\n    (executioncontext & rendercontext) !== nolanes &&\n    root === workinprogressroot\n  ) {\n    // track lanes that were updated during the render phase\n    // 收集当前的 lane 到 workinprogressrootrenderphaseupdatedlanes，表示在当前 render 中当前正在渲染的 rootfiber 上的优先级队列。\n    workinprogressrootrenderphaseupdatedlanes = mergelanes(\n      workinprogressrootrenderphaseupdatedlanes,\n      lane,\n    );\n    // 这里是正常的请求渲染调度的流程\n  } else {\n    if (root === workinprogressroot) {\n      // 如果 workinprogressrootexitstatus 为 rootsuspendedwithdelay，则标记 root 为 suspend。这里是处理 suspended 组件。向 root 做标记以在后面的渲染中加以区分。\n      if (workinprogressrootexitstatus === rootsuspendedwithdelay) {\n        // the root already suspended with a delay, which means this render\n        // definitely won't finish. since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. this has the\n        // effect of interrupting the current render and switching to the update.\n        // todo: make sure this doesn't override pings that happen while we've\n        // already started rendering.\n        markrootsuspended(root, workinprogressrootrenderlanes);\n      }\n    }\n    // 确保 hostroot （向调度器）发起调度请求，\n    ensurerootisscheduled(root, eventtime);\n    if (\n      lane === synclane &&\n      executioncontext === nocontext &&\n      (fiber.mode & concurrentmode) === nomode &&\n      // treat `act` as if it's inside `batchedupdates`, even in legacy mode.\n      !(__dev__ && reactcurrentactqueue.isbatchinglegacy)\n    ) {\n      // 如果是同步更新，context 还是 nocontext 阶段，fiber.mode 不是 concurrentmode，且 prd 环境 reactcurrentactqueue.isbatchinglegacy 为 true\n      // 在初次加载时重置 workinprogressrootrendertargettime 并且 flushsynccallbacks。\n      // 只在初始化应用时执行\n      // flush the synchronous work now, unless we're already working or inside\n      // a batch. this is intentionally inside scheduleupdateonfiber instead of\n      // schedulecallbackforfiber to preserve the ability to schedule a callback\n      // without immediately flushing it. we only do this for user-initiated\n      // updates, to preserve historical behavior of legacy mode.\n      resetrendertimer();\n      flushsynccallbacksonlyinlegacymode();\n    }\n  }\n  return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n这个函数的核心功能如下：\n\n * 从 fiber 向父级收集 lanes，并且计算出 hostroot。\n * 调用 ensurerootisscheduled，确保 hostroot 发起同步或者异步调度。\n * 如果是初次启动应用，执行一些初始化工作。\n\n下面我们将以 scheduleupdateonfiber 函数作为突破口，一层层的往下追溯，看看 react 的更新具体是怎样的流程，以及更新产生的来源到底是什么？\n\n图注\n\n<- 表示代码向下追溯，即前面的函数被后面的函数调用或者使用。<<< 表示省略追溯过程，因为从前面的过程中可以推出。... 表示忽略此过程。\n\nscheduleupdateonfiber <- updatedehydratedsuspensecomponent <- updatesuspensecomponent <- attemptearlybailoutifnoscheduledupdate <- beginwork\n                                                                                      <- beginwork\n                      <- classcomponentupdater[enqueuesetstate、enqueuereplacestate、enqueueforceupdate] <- adoptclassinstance <- mountindeterminatecomponent <- beginwork\n                                                                                                                              <- constructclassinstance <- updateclasscomponent <- mountlazycomponent <- beginwork\n                                                                                                                                                                                <- beginwork\n                                                                                                                                                        <- mountincompleteclasscomponent <- beginwork\n                                                                                                        <- callcomponentwillmount <- mountclassinstance <- updateclasscomponent <- mountlazycomponent <- beginwork\n                                                                                                                                                                                <- beginwork\n                                                                                                                                                        <- mountincompleteclasscomponent <- beginwork\n                                                                                                        <- callcomponentwillreceiveprops <- resumemountclassinstance <- updateclasscomponent <<< beginwork\n                                                                                                                                         <- updateclassinstance <<< beginwork\n                      <- [dev]forcestorererender <- updatestoreinstance <- mountsyncexternalstore ...\n                                                                   <- updatesyncexternalstore ...\n                                            <- subscribetostore ...\n                      <- [enablecache]refreshcache <- mountrefresh ...\n                      <- dispatchreduceraction <- mountreducer <- reducer.dispatch[usereducer]\n                      <- dispatchsetstate <- usemutablesource <- statehook.queue.dispatch <- dispatchaction[queue.reducer(state, dispatch)]  <- usestate\n                                          <- mountstate <- hooksdispatcheronmount.usestate <- reactcurrentdispatcher.current <- usestate\n                                                        <- mounttransition <- hooksdispatcheronmount.usetransition <- usetransition\n                                                        <- mountdeferredvalue <- hooksdispatcheronmount.usedeferredvalue <- usedeferredvalue\n                      <- updatecontainer <<< reactdom[hydrate、render、unmountcomponentatnode、createroot、hydrateroot、scheduleroot]\n                      \x3c!-- <- attemptsynchronoushydration --\x3e\n                      \x3c!-- <- attemptdiscretehydration --\x3e\n                      \x3c!-- <- attemptcontinuoushydration --\x3e\n                      \x3c!-- <- attempthydrationatcurrentpriority --\x3e\n\nbeginwork <- workloopconcurrent <- renderrootconcurrent <- performconcurrentworkonroot <- ensurerootisscheduled[root.callbacknode] <- scheduleupdateonfiber <<< beginwork\n          <- performunitofwork <- workloopsync <- renderrootsync <- performconcurrentworkonroot <<< beginwork\n                               <- workloopconcurrent <- renderrootconcurrent <- performconcurrentworkonroot <<< beginwork\n\ncommitroot <- finishconcurrentrender[rooterrored、rootsuspended、rootsuspendedwithdelay、rootcompleted] <- performconcurrentworkonroot\n           <- performsyncworkonroot\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n从上面的分析过程，我们可以得出很多重要的信息，总结如下：\n\n\n# 一个闭环\n\n从上面可以清晰的看出，从 scheduleupdateonfiber 往上追溯时，最终追溯到了 beginwork，然后从 beginwork 继续追溯，最终追溯到 scheduleupdateonfiber。大致过程如下：\n\n钩子（生命周期）和事件系统 -> 应用层行为：dispatchsetstate、classcomponentupdater、dispatchreduceraction、updatecontainer \n-> scheduleupdateonfiber -> ensurerootisscheduled -> performsyncworkonroot、performconcurrentworkonroot \n-> renderrootsync、renderrootconcurrent -> workloopsync、workloopconcurrent \n-> performunitofwork -> beginwork -> mount、update 组件 -> 调用生命周期函数、响应事件系统 -> commitroot -> ...\n\n\n1\n2\n3\n4\n\n\n有以下几点需要注意：\n\n * 应用层行为分别可以对应 fc setstate、类组件 this.setstate、usereducer 的 dispatch 和 reactdom 的一系列操作，如 hydrate、render、unmountcomponentatnode、createroot、hydrateroot、scheduleroot。\n * 从 ensurerootisscheduled -> performconcurrentworkonroot 中间还有调度器的调度过程，包括 schedulesynccallback 和 schedulecallback，分别对应同步任务的调度和异步任务的调度。\n * 在 performsyncworkonroot、performconcurrentworkonroot 执行之后，有一个 commitroot 的操作。\n * beginwork -> mount、update 组件 这个过程中涉及的内容较为繁琐，可以参考更新器的部分，本文不在赘述细节。\n * commitroot 在 performsyncworkonroot（同步渲染）、或者 finishconcurrentrender（异步渲染）中调用。这并不是说在同步渲染中 commitroot 和后面的 renderrootsync 是同时进行的，而是说 renderrootsync 是同步的，renderrootsync 执行完之后直接就执行了 commitroot。从只有 finishconcurrentrender，而没有类似于 finishsyncrender 可以印证这一点。\n\n一个完整的同步的渲染回调的调用函数栈，可以参考下图：\n\n\n# 更新的来源\n\n更新主要来源于应用层的一些行为：dispatchsetstate、classcomponentupdater、dispatchreduceraction、updatecontainer 和 reactdom 的一系列操作，如 hydrate、render、unmountcomponentatnode、createroot、hydrateroot、scheduleroot。大致包括应用 mount 阶段对 reactdom api 调用引起的同步更新，类组件和 fc 状态更新、usereducer 的 dispatch 的调用，以及最新 concurrentapi 如 usetransition、usedeferredvalue 等。\n\n下面我们从一个更为直接的角度来探究 react 更新的来源。现在我们知道，如果需要更新，则会将更新入栈，我们从这个角度来分析一下，在代码中搜索 enqueueupdate( ：\n\n调用 enqueueupdate( 主要在如下几个模块：\n\n * src/react/packages/react-reconciler/src/reactfiberclasscomponent.new.js\n * src/react/packages/react-reconciler/src/reactfiberhooks.new.js\n * src/react/packages/react-reconciler/src/reactfiberreconciler.new.js\n * src/react/packages/react-reconciler/src/reactfiberthrow.new.js\n * src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\n然后分析下分别在哪些函数中出现：\n\n>> reactfiberclasscomponent\nclasscomponentupdater[enqueuesetstate、enqueuereplacestate、enqueueforceupdate]\n\n>> reactfiberhooks\ndispatchreduceraction\ndispatchsetstate\n\n>> reactfiberreconciler\nupdatecontainer\n\n// 以下的 update 为 errorupdate\n\n>> reactfiberthrow\nmarksuspenseboundaryshouldcapture <- throwexception <- handleerror <- renderrootsync/renderrootconcurrent\n\n>> reactfiberworkloop\ncapturecommitphaseerroronroot <- capturecommitphaseerror <- safelycallcommithooklayouteffectlistmount/safelycallcomponentwillunmount/safelycallcomponentdidmount/safelyattachref/safelydetachref/safelycalldestroy/commitbeforemutationeffects_complete/commitmutationeffects_begin/commitmutationeffects_complete/commitlayoutmounteffects_complete/reappearlayouteffects_complete/commitpassivemounteffects_complete\ncapturecommitphaseerror <<< ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n可以看出，与前文的分析基本一致。\n\n关于 usetransition、usedeferredvalue 可以参考：淺談 react concurrent mode & 相關功能 (fiber、suspense、usetransition、usedeferredvalue)\n\n扩展\n\n 1. scheduleupdateonfiber 一方面被 updatecontainer 这样间接被外部应用层 api 调用，另一方面在组件层面由组件状态更新、context 更新、props 更新等行为在 react 内部调用（可以参考上文 scheduleupdateonfiber 调用来源）。\n 2. checkfornestedupdates 函数是为了防止行为更新的死循环，因为更新都要经过 scheduleupdateonfiber 函数提交调度更新，scheduleupdateonfiber 在 react 内部还是外部都会被频繁调用。checkfornestedupdates 在内部维护变量 nestedupdatecount 表示在当前的 commit 中 fiberroot 更新的循环请求次数。\n 3. 关于 react 中常见的位运算，可以参考 位运算初探 和 使用位运算提高枚举计算效率。\n 4. 这里判断 root === workinprogressroot 执行 suspended 组件的一些逻辑是因为，正常情况下这里 workinprogressroot 应该为 null，只有当前的 fiberroot 被标记为 workinprogressroot 再回在这里特殊处理。正常情况下，workinprogressroot 只有在 preparefreshstack 函数被赋值为 root 的，而 preparefreshstack 只有在 renderrootsync、renderrootconcurrent、pingsuspendedroot 函数中正常执行或者在 performconcurrentworkonroot、performsyncworkonroot 中发生 fatalerror 时执行。\n\n\n# ensurerootisscheduled\n\n在上面对 scheduleupdateonfiber 的分析中，最重要的就是调用 ensurerootisscheduled，以保证在 fiber 所在的 hostroot 上调度更新，那么 hostroot 上是如何继续调度的呢？\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\nfunction ensurerootisscheduled(root: fiberroot, currenttime: number) {\n  const existingcallbacknode = root.callbacknode;\n\n  // check if any lanes are being starved by other work. if so, mark them as\n  // expired so we know to work on those next.\n  // 将饿死的 lanes 标记为超时以一并更新，超时的任务立即执行。\n  markstarvedlanesasexpired(root, currenttime);\n\n  // determine the next lanes to work on, and their priority.\n  // 计算将要渲染的 lanes\n  const nextlanes = getnextlanes(\n    root,\n    root === workinprogressroot ? workinprogressrootrenderlanes : nolanes,\n  );\n  // 无需要渲染的 lanes\n  if (nextlanes === nolanes) {\n    // special case: there's nothing to work on.\n    if (existingcallbacknode !== null) {\n      cancelcallback(existingcallbacknode);\n    }\n    root.callbacknode = null;\n    root.callbackpriority = nolane;\n    return;\n  }\n\n  // we use the highest priority lane to represent the priority of the callback.\n  // 获取 lanes 中优先级最高的 lane 作为 callback 的优先级\n  const newcallbackpriority = gethighestprioritylane(nextlanes);\n\n  // check if there's an existing task. we may be able to reuse it.\n  const existingcallbackpriority = root.callbackpriority;\n  // 由于即将要生成新的 callback，先将现在的 callback 取消掉\n  if (existingcallbacknode != null) {\n    // cancel the existing callback. we'll schedule a new one below.\n    cancelcallback(existingcallbacknode);\n  }\n\n  // schedule a new callback.\n  let newcallbacknode;\n  // 如果是同步更新任务\n  if (newcallbackpriority === synclane) {\n    // special case: sync react callbacks are scheduled on a special\n    // internal queue\n    // legacyroot 需要单独处理\n    if (root.tag === legacyroot) {\n      schedulelegacysynccallback(performsyncworkonroot.bind(null, root));\n    } else {\n      // 请求同步调度回调 performsyncworkonroot，将该回调加入同步回调队列\n      schedulesynccallback(performsyncworkonroot.bind(null, root));\n    }\n    if (supportsmicrotasks) {\n     // flush the queue in a microtask.\n     //  支持微任务的浏览器不用再请求调度器的回调\n     schedulemicrotask(() => {\n       // in safari, appending an iframe forces microtasks to run.\n       // https://github.com/facebook/react/issues/22459\n       // we don't support running callbacks in the middle of render\n       // or commit so we need to check against that.\n       if (executioncontext === nocontext) {\n         // it's only safe to do this conditionally because we always\n         // check for pending work before we exit the task.\n         // 消费完同步回调队列\n         flushsynccallbacks();\n       }\n     });\n    } else {\n      // flush the queue in an immediate task.\n      // 向调度器请求回调，优先级 immediatepriority（立即回调），回调后执行 flushsynccallbacks 将同步回调队列消费完\n      schedulecallback(immediateschedulerpriority, flushsynccallbacks);\n    }\n    // 同步更新执行完毕，将 newcallbacknode 置为 null，performsyncworkonroot 不会用到此值\n    newcallbacknode = null;\n  } else {\n    let schedulerprioritylevel;\n    // 将 lanes 转化为事件优先级\n    switch (lanestoeventpriority(nextlanes)) {\n      // 离散事件优先级：immediateschedulerpriority\n      case discreteeventpriority:\n        schedulerprioritylevel = immediateschedulerpriority;\n        break;\n      // 连续事件优先级：userblockingschedulerpriority\n      case continuouseventpriority:\n        schedulerprioritylevel = userblockingschedulerpriority;\n        break;\n      // 默认事件优先级：normalschedulerpriority\n      case defaulteventpriority:\n        schedulerprioritylevel = normalschedulerpriority;\n        break;\n      // idle 事件优先级：idleschedulerpriority\n      case idleeventpriority:\n        schedulerprioritylevel = idleschedulerpriority;\n        break;\n      default:\n        schedulerprioritylevel = normalschedulerpriority;\n        break;\n    }\n    // 向调度器请求相应优先级的异步回调，回调后执行 performconcurrentworkonroot，scheduler.schedulecallback 返回调度的 callbacknode(newtask)\n    newcallbacknode = schedulecallback(\n      schedulerprioritylevel,\n      performconcurrentworkonroot.bind(null, root),\n    );\n  }\n  // 更新 callbackpriority 和 callbacknode 注意，此时异步回调并未执行\n  root.callbackpriority = newcallbackpriority;\n  root.callbacknode = newcallbacknode;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n\n这个函数有以下几个关键作用：\n\n * 更新 root 的 callbacknode、callbackpriority 属性。\n * 同步更新调度：支持微任务的直接在微任务的回调执行 flushsynccallbacks；调用 schedulesynccallback 将同步回调 performsyncworkonroot 推入同步回调队列 syncqueue，并且以 immediateschedulerpriority 的优先级向调度器请求同步回调，回调时执行 flushsynccallbacks 消费同步队列中所有的同步回调。\n * 异步更新调度：根据 nextlanes 计算事件优先级，并且转化为调度优先级，以相应的调度优先级向调度器发起异步回调，回调时执行 performconcurrentworkonroot。\n * 注意同步调度中调用了 schedulesynccallback、schedulecallback 两个函数不可混淆，schedulecallback 只是 scheduler 提供的一种基于优先级机制的任务（回调）调度手段，performsyncworkonroot 和 performconcurrentworkonroot 才是真正要通过调度执行的任务。同步的任务通过同步回调队列的方式进行了优化处理。schedulesynccallback 是将同步的任务加入同步任务队列。调度器不是不可替换的，如果浏览器支持微任务，同步任务的处理就可以交给微任务处理，而不经过调度器。\n\nnextlanes 优先级是如何计算的？参见 lane 与优先级\n\n新知\n\n * 调度更新都是通过 hostroot 实现的，从 ensurerootisscheduled 中之传入 root ，而没有传入 fiber 可见 hostroot 对于 react 中整个调和过程的重要性。\n\n\n# discreteeventpriority 和 continuouseventpriority\n\n * 离散事件：discreteevent，常见的如：click, keyup, change；\n * 用户阻塞事件：userblocking，常见的如：dragenter, mousemove, scroll；\n * 连续事件：continuous，常见的如：error, progress, load；\n\n更多解析可以参考：react 中的事件监听机制\n\n\n# schedulemicrotask 与 queuemicrotask\n\n可以看到，如果浏览器支持 queuemicrotask，同步调度就不用经过调度器，而是直接交由微任务处理，这样既减少了 performsyncworkonroot 执行的压力，同时又要比 settimeout 这样的宏任务更快的执行。queuemicrotask 可以由 promise 来模拟。queuemicrotask () 方法将微任务排队以调用 callback。\n\n什么是 queuemicrotask？\n\n> queuemicrotask adds the function (task) into a queue and each function is executed one by one (fifo) after the current task has completed its work and when there is no other code waiting to be run before control of the execution context is returned to the browser's event loop.\n\nreact 中 queuemicrotask 的使用：\n\nconst localpromise = typeof promise === 'function' ? promise : undefined;\nexport const supportsmicrotasks = true;\nexport const scheduletimeout: any =\n  typeof settimeout === 'function' ? settimeout : (undefined: any);\n\nexport const schedulemicrotask: any =\n  typeof queuemicrotask === 'function'\n    ? queuemicrotask\n    : typeof localpromise !== 'undefined'\n    ? callback =>\n        localpromise\n          .resolve(null)\n          .then(callback)\n          .catch(handleerrorinnexttick)\n    : scheduletimeout; // todo: determine the best fallback here.\n\nfunction handleerrorinnexttick(error) {\n  settimeout(() => {\n    throw error;\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n了解更多关于微任务可以参考：\n\n * 在 javascript 中通过 queuemicrotask () 使用微任务\n * an introduction to javascript's queuemicrotask\n * caniuse: queuemicrotask api\n\n\n# schedulesynccallback 和 schedulecallback\n\n在上面对 ensurerootisscheduled 的分析中我们知道，ensurerootisscheduled 对同步任务和异步任务分别进行了同步调度和异步调度，分别调用 schedulesynccallback 和 schedulecallback，那么具体同步调度和异步调度是如何进行的呢？\n\n\n# schedulesynccallback 和 flushsynccallbacks\n\nschedulesynccallback 维护一个同步更新的任务队列，调用 flushsynccallbacks 可全数消费任务任务中的所有任务。\n\n// src/react/packages/react-reconciler/src/reactfibersynctaskqueue.new.js\nexport function schedulesynccallback(callback: schedulercallback) {\n  // push this callback into an internal queue. we'll flush these either in\n  // the next tick, or earlier if something calls `flushsynccallbackqueue`.\n  if (syncqueue === null) {\n    syncqueue = [callback];\n  } else {\n    // push onto existing queue. don't need to schedule a callback because\n    // we already scheduled one when we created the queue.\n    syncqueue.push(callback);\n  }\n}\n\nexport function flushsynccallbacks() {\n  // isflushingsyncqueue 是 syncqueue 的互斥锁，消费 callbacks 是一个互斥操作\n  if (!isflushingsyncqueue && syncqueue !== null) {\n    // prevent re-entrance.\n    isflushingsyncqueue = true;\n    let i = 0;\n    const previousupdatepriority = getcurrentupdatepriority();\n    try {\n      const issync = true;\n      const queue = syncqueue;\n      // todo: is this necessary anymore? the only user code that runs in this\n      // queue is in the render or commit phases.\n      setcurrentupdatepriority(discreteeventpriority);\n      // flush syncqueue，每个 callback 可以返回一个新的 callback\n      for (; i < queue.length; i++) {\n        let callback = queue[i];\n        do {\n          callback = callback(issync);\n        } while (callback !== null);\n      }\n      // 重置 syncqueue\n      syncqueue = null;\n      includeslegacysynccallbacks = false;\n    } catch (error) {\n      // if something throws, leave the remaining callbacks on the queue.\n      // 如果syncqueue 中每个 rootcallback 发生了错误，则跳过此项\n      if (syncqueue !== null) {\n        syncqueue = syncqueue.slice(i + 1);\n      }\n      // resume flushing in the next tick\n      // 调度在下一个同步调度中继续执行\n      schedulecallback(immediatepriority, flushsynccallbacks);\n      throw error;\n    } finally {\n      setcurrentupdatepriority(previousupdatepriority);\n      isflushingsyncqueue = false;\n    }\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n这两个函数有如下关键作用：\n\n * 维护同步回调的 syncqueue，以在同步回调到来时 flush syncqueue。\n\n更多分析，请参考 react 首次渲染过程 中的 flushsynccallbacks 函数分析。\n\n\n# schedulecallback\n\n这部分会与调度器交互，在 react 中，调度器是一个单独的模块，这里不再展开。现在需要知道的是，调度器会根据各种异步任务的优先级选择高优先级的任务进行回调，回调中执行 performsyncworkonroot。\n\n调度器详细可以参考调度器章节内容。\n\n\n# performsyncworkonroot\n\n从上面的分析中，我们已经知道了调度器同步调度的回调（可以不通过调度器）是由 performsyncworkonroot 函数来处理的，下面我们来具体探究下这个函数：\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\n// this is the entry point for synchronous tasks that don't go\n// through scheduler\nfunction performsyncworkonroot(root) {\n  // 如果当前是 render 阶段或者 commit 阶段就报错，因为此时应该还在 batch 阶段\n  if ((executioncontext & (rendercontext | commitcontext)) !== nocontext) {\n    throw new error('should not already be working.');\n  }\n  // 进入 render 阶段前，先把 effects 和 callbacks 都消费掉。\n  flushpassiveeffects();\n  // 获取即将渲染的 lanes\n  let lanes = getnextlanes(root, nolanes);\n  // 如果 lanes 中不包含 synclane，这说明没有同步的任务需要 renderrootsync，返回 ensurerootisscheduled 重新调度一次\n  if (!includessomelane(lanes, synclane)) {\n    // there's no remaining sync work left.\n    ensurerootisscheduled(root, now());\n    return null;\n  }\n  // 同步的 render hostroot，返回 workinprogressrootexitstatus 表示退出时执行的状态，\n  // 包括 rootincomplete、rootfatalerrored、rooterrored、rootsuspended、rootsuspendedwithdelay、rootcompleted\n  let exitstatus = renderrootsync(root, lanes);\n  // 如果发生普通错误，重试同步渲染，最多重试 50 次\n  if (root.tag !== legacyroot && exitstatus === rooterrored) {\n    // if something threw an error, try rendering one more time. we'll render\n    // synchronously to block concurrent data mutations, and we'll includes\n    // all pending updates are included. if it still fails after the second\n    // attempt, we'll give up and commit the resulting tree.\n    const errorretrylanes = getlanestoretrysynchronouslyonerror(root);\n    if (errorretrylanes !== nolanes) {\n      lanes = errorretrylanes;\n      exitstatus = recoverfromconcurrenterror(root, errorretrylanes);\n    }\n  }\n  // 如果发生了致命错误，重置到非错误的状态，将 hostroot 标记为 suspend 并且重新调度一次\n  if (exitstatus === rootfatalerrored) {\n    const fatalerror = workinprogressrootfatalerror;\n    preparefreshstack(root, nolanes);\n    markrootsuspended(root, lanes);\n    ensurerootisscheduled(root, now());\n    throw fatalerror;\n  }\n\n  // we now have a consistent tree. because this is a sync render, we\n  // will commit it even if something suspended.\n  // 将渲染后的 rootfiber 和 lanes 更新到 hostroot 上\n  const finishedwork: fiber = (root.current.alternate: any);\n  root.finishedwork = finishedwork;\n  root.finishedlanes = lanes;\n  // 提交 hostroot 上的更新，通知调度器在帧尾 yield 一次，浏览器重绘。\n  commitroot(root);\n\n  // before exiting, make sure there's a callback scheduled for the next\n  // pending level.\n  // 保证每次 rendersync 之后，调度不会闲置\n  ensurerootisscheduled(root, now());\n\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n分析一下这个函数：\n\n * flushpassiveeffects 中主要调用 flushsynccallbacks、commitpassiveunmounteffects、commitpassivemounteffects 这三个函数。调用这个函数的目的是什么？我们注意到， performsyncworkonroot 会随着 schedulesynccallback 的调用而被执行，因此在 performsyncworkonroot 执行时，很可能又有新的同步任务加入到同步回调队列中，所以为了提高同步渲染的效率，同时满足同步任务今早执行的目的，在 renderrootsync 之前，重新消费 synccallbacks。\n * 调用 renderrootsync 渲染合同更新。返回一个退出状态，如果发生普通错误，采取重试策略；如果发生了致命错误，则采取重置策略。即使发生了普通的错误，本次 render 仍然被 commit，除非发生了 致命的错误，将抛出一个错误。\n * commitroot 需要调度器的支持，需要调度器在 raf 的帧的末尾提交浏览器绘制。\n * performsyncworkonroot 中任何情况的退出都要调用 ensurerootisscheduled，保证调度不会被闲置。\n * performsyncworkonroot 可以不通过 scheduler 的调度。\n\n这个函数的关键作用如下：\n\n * 调用 renderrootsync 同步渲染更新。\n * 普通错误和致命错误的处理。\n * 调用 commitroot 提交 hostroot 上的更新，触发浏览器 paint。\n\n\n# performconcurrentworkonroot\n\n在上面的分析中，我们知道调度器异步任务调度的回调是由 performconcurrentworkonroot 来处理的，下面我们具体来看下 performconcurrentworkonroot 这个函数，并且与 performsyncworkonroot 进行对比。\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\n// if two updates are scheduled within the same event, we should treat their\n// event times as simultaneous, even if the actual clock time has advanced\n// between the first and second call.\nlet currenteventtime: number = notimestamp;\n\n// this is the entry point for every concurrent task, i.e. anything that\n// goes through scheduler.\nfunction performconcurrentworkonroot(root, didtimeout) {\n  // since we know we're in a react event, we can clear the current\n  // event time. the next update will compute a new event time.\n  currenteventtime = notimestamp;\n  currenteventtransitionlane = nolanes;\n  // 如果当前是 render 阶段或者 commit 阶段就报错，因为当前应该还在 batch 阶段\n  if ((executioncontext & (rendercontext | commitcontext)) !== nocontext) {\n    throw new error('should not already be working.');\n  }\n\n  // flush any pending passive effects before deciding which lanes to work on,\n  // in case they schedule additional work.\n  const originalcallbacknode = root.callbacknode;\n  // 在 renderconcurrent 之前再次消费完 callbacks 和 effects。\n  const didflushpassiveeffects = flushpassiveeffects();\n  if (didflushpassiveeffects) {\n    // something in the passive effect phase may have canceled the current task.\n    // check if the task node for this root was changed.\n    // 检查 flushpassiveeffects 之后 callbacknode 是否改变，如果变化了，舍弃之后的渲染工作，因为新的调度已经来临\n    if (root.callbacknode !== originalcallbacknode) {\n      // the current task was canceled. exit. we don't need to call\n      // `ensurerootisscheduled` because the check above implies either that\n      // there's a new task, or that there's no remaining work on this root.\n      return null;\n    } else {\n      // current task was not canceled. continue.\n    }\n  }\n\n  // determine the next lanes to work on, using the fields stored\n  // on the root.\n  // 计算当前要渲染的 lanes\n  let lanes = getnextlanes(\n    root,\n    root === workinprogressroot ? workinprogressrootrenderlanes : nolanes,\n  );\n  if (lanes === nolanes) {\n    // defensive coding. this is never expected to happen.\n    return null;\n  }\n\n  // we disable time-slicing in some cases: if the work has been cpu-bound\n  // for too long (\"expired\" work, to prevent starvation), or we're in\n  // sync-updates-by-default mode.\n  // 判断是否要进行时间切片，这决定是改用同步 render 还是继续异步 render\n  // 包含有 blocking 优先级的 lane 的任务，或者包含有过时 line 的任务要改为同步 render \n  const shouldtimeslice =\n    !includesblockinglane(root, lanes) &&\n    !includesexpiredlane(root, lanes) &&\n    (disableschedulertimeoutinworkloop || !didtimeout);\n  let exitstatus = shouldtimeslice\n    ? renderrootconcurrent(root, lanes)\n    : renderrootsync(root, lanes);\n  // 如果 render 的结果不是 rootincomplete，说明出现了异常情况\n  if (exitstatus !== rootincomplete) {\n    if (exitstatus === rooterrored) {\n      // if something threw an error, try rendering one more time. we'll\n      // render synchronously to block concurrent data mutations, and we'll\n      // includes all pending updates are included. if it still fails after\n      // the second attempt, we'll give up and commit the resulting tree.\n      // 如果是普通错误，重试若干次\n      const errorretrylanes = getlanestoretrysynchronouslyonerror(root);\n      if (errorretrylanes !== nolanes) {\n        lanes = errorretrylanes;\n        exitstatus = recoverfromconcurrenterror(root, errorretrylanes);\n      }\n    }\n    if (exitstatus === rootfatalerrored) {\n      const fatalerror = workinprogressrootfatalerror;\n      preparefreshstack(root, nolanes);\n      markrootsuspended(root, lanes);\n      ensurerootisscheduled(root, now());\n      throw fatalerror;\n    }\n\n    // check if this render may have yielded to a concurrent event, and if so,\n    // confirm that any newly rendered stores are consistent.\n    const renderwasconcurrent = !includesblockinglane(root, lanes);\n    const finishedwork: fiber = (root.current.alternate: any);\n    if (\n      renderwasconcurrent &&\n      !isrenderconsistentwithexternalstores(finishedwork)\n    ) {\n      // a store was mutated in an interleaved event. render again,\n      // synchronously, to block further mutations.\n      exitstatus = renderrootsync(root, lanes);\n\n      // we need to check again if something threw\n      if (exitstatus === rooterrored) {\n        const errorretrylanes = getlanestoretrysynchronouslyonerror(root);\n        if (errorretrylanes !== nolanes) {\n          lanes = errorretrylanes;\n          exitstatus = recoverfromconcurrenterror(root, errorretrylanes);\n          // we assume the tree is now consistent because we didn't yield to any\n          // concurrent events.\n        }\n      }\n      if (exitstatus === rootfatalerrored) {\n        const fatalerror = workinprogressrootfatalerror;\n        preparefreshstack(root, nolanes);\n        markrootsuspended(root, lanes);\n        ensurerootisscheduled(root, now());\n        throw fatalerror;\n      }\n    }\n\n    // we now have a consistent tree. the next step is either to commit it,\n    // or, if something suspended, wait to commit it after a timeout.\n    root.finishedwork = finishedwork;\n    root.finishedlanes = lanes;\n    finishconcurrentrender(root, exitstatus, lanes);\n  }\n  // 完成 render 之后，重新发起一次调度，以保证调度不会被中断\n  ensurerootisscheduled(root, now());\n  // 如果新的新的调度节点将仍然发生在相同的 hostroot，那就不用等调度器的调度，直接继续 performconcurrentworkonroot\n  // 注意：ensurerootisscheduled 会产生一个 newcallbacknode，更新 root.callbacknode\n  if (root.callbacknode === originalcallbacknode) {\n    // the task node scheduled for this root is the same one that's\n    // currently executed. need to return a continuation.\n    return performconcurrentworkonroot.bind(null, root);\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n\n * currenteventtime 在 scheduleupdateonfiber 和 createupdate 之前生成，即创建更新时生成，到 performconcurrentworkonroot 被重置。每个 update 对象中有 eventtime。\n * performconcurrentworkonroot 必须通过 scheduler 的调度才有机会执行。这与 performsyncworkonroot 有所不同。\n * 从整体来看，performsyncworkonroot 和 performconcurrentworkonroot 流程是相似的，包括 executioncontext 的判断、调用 renderroot、错误判断等。\n * 在 renderconcurrent 之前再次消费完 callbacks 和 effects，原因是为了节省调度资源，同时保证更新被尽快的处理。当然，这里有一个细节，如果在 消费完 callbacks 和 effects 的过程中，root.callbacknode 发生了变化，则舍弃当前的 renderroot 等后续流程，因为新的调度即将来临。之所以舍弃当前的调度是因为，新的任务具有更高的优先级或者当前的调度已经没有任务可执行了。\n * 在 renderroot 之前，仍然对 lanes 做了判断，如果 lanes 中有 blocking 优先级的任务或者过时的任务（过时的任务具有立即执行的优先级）就会使用同步渲染，没有上述的情况才会使用异步渲染。同步渲染和异步渲染分别调用 renderrootsync 和 renderrootconcurrent 执行。\n * 在错误处理方面，对待普通的错误容忍度还是比较高的，recoverfromconcurrenterror 将对错误执行之多 50 次的重试，注意，重试时是以 renderrootsync 即同步渲染执行的。\n * 在 renderroot 之后，无论错误与否，都需要调用 ensurerootisscheduled 以保证调度不会被闲置。由于异步渲染需要调度器调度的时间相对于同步渲染要长，这里做了一个优化处理，如果预知到新的调度仍然会出现在同一个 hostroot 上，就可以直接继续调用自身以继续完成 hostroot 上的渲染任务。\n\n\n# finishconcurrentrender\n\n在这个函数中，会根据 exitstatus 的状态执行不同的处理操作，主要是 commitroot 操作。\n\nfunction finishconcurrentrender(root, exitstatus, lanes) {\n  switch (exitstatus) {\n    // 这两种情况在 performconcurrentworkonroot 中已经处理了，应该不会被执行到\n    case rootincomplete:\n    case rootfatalerrored: {\n      throw new error('root did not complete. this is a bug in react.');\n    }\n    // rooterrored 的情况在 performconcurrentworkonroot 中已经对错误情况重试了，这里将直接 commitroot\n    case rooterrored: {\n      // we should have already attempted to retry this tree. if we reached\n      // this point, it errored again. commit it.\n      commitroot(root);\n      break;\n    }\n    // 如果 renderroot 退出后返回 rootsuspended，则将当前的 hostroot 标记为 suspended\n    case rootsuspended: {\n      markrootsuspended(root, lanes);\n\n      // we have an acceptable loading state. we need to figure out if we\n      // should immediately commit it or wait a bit.\n\n      if (\n        includesonlyretries(lanes) &&\n        // do not delay if we're inside an act() scope\n        !shouldforceflushfallbacksindev()\n      ) {\n        // this render only included retries, no updates. throttle committing\n        // retries so that we don't show too many loading states too quickly.\n        const msuntiltimeout =\n          globalmostrecentfallbacktime + fallback_throttle_ms - now();\n        // don't bother with a very short suspense time.\n        if (msuntiltimeout > 10) {\n          const nextlanes = getnextlanes(root, nolanes);\n          if (nextlanes !== nolanes) {\n            // there's additional work on this root.\n            break;\n          }\n          const suspendedlanes = root.suspendedlanes;\n          if (!issubsetoflanes(suspendedlanes, lanes)) {\n            // we should prefer to render the fallback of at the last\n            // suspended level. ping the last suspended level to try\n            // rendering it again.\n            // fixme: what if the suspended lanes are idle? should not restart.\n            const eventtime = requesteventtime();\n            markrootpinged(root, suspendedlanes, eventtime);\n            break;\n          }\n\n          // the render is suspended, it hasn't timed out, and there's no\n          // lower priority work to do. instead of committing the fallback\n          // immediately, wait for more data to arrive.\n          // 在 root.timeouthandle 挂载延时器，延迟执行 commitroot\n          root.timeouthandle = scheduletimeout(\n            commitroot.bind(null, root),\n            msuntiltimeout,\n          );\n          break;\n        }\n      }\n      // the work expired. commit immediately.\n      commitroot(root);\n      break;\n    }\n    case rootsuspendedwithdelay: {\n      markrootsuspended(root, lanes);\n\n      if (includesonlytransitions(lanes)) {\n        // this is a transition, so we should exit without committing a\n        // placeholder and without scheduling a timeout. delay indefinitely\n        // until we receive more data.\n        break;\n      }\n\n      if (!shouldforceflushfallbacksindev()) {\n        // this is not a transition, but we did trigger an avoided state.\n        // schedule a placeholder to display after a short delay, using the just\n        // noticeable difference.\n        // todo: is the jnd optimization worth the added complexity? if this is\n        // the only reason we track the event time, then probably not.\n        // consider removing.\n\n        const mostrecenteventtime = getmostrecenteventtime(root, lanes);\n        const eventtimems = mostrecenteventtime;\n        const timeelapsedms = now() - eventtimems;\n        const msuntiltimeout = jnd(timeelapsedms) - timeelapsedms;\n\n        // don't bother with a very short suspense time.\n        if (msuntiltimeout > 10) {\n          // instead of committing the fallback immediately, wait for more data\n          // to arrive.\n          root.timeouthandle = scheduletimeout(\n            commitroot.bind(null, root),\n            msuntiltimeout,\n          );\n          break;\n        }\n      }\n\n      // commit the placeholder.\n      commitroot(root);\n      break;\n    }\n    // 如果渲染任务退出状态为 rootcompleted，直接 commitroot\n    case rootcompleted: {\n      // the work completed. ready to commit.\n      commitroot(root);\n      break;\n    }\n    default: {\n      throw new error('unknown root exit status.');\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n\n\n\n# renderrootsync\n\n在上面的分析中，我们已经知道 performsyncworkonroot 和 performconcurrentworkonroot 将会调用 renderrootsync 以完成同步渲染的任务，那么在 commitroot 之前，同步渲染任务是如何完成的呢？\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\nfunction renderrootsync(root: fiberroot, lanes: lanes) {\n  // 先缓存下 executioncontext，以便于错误恢复\n  const prevexecutioncontext = executioncontext;\n  // 将 rendercontext 加入 executioncontext 中\n  executioncontext |= rendercontext;\n  // 推出 reactcurrentdispatcher.current，reactcurrentdispatcher.current 将被重置为 contextonlydispatcher\n  const prevdispatcher = pushdispatcher();\n\n  // if the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. otherwise we'll continue where we left off.\n  // 如果发现 workinprogressroot 和 workinprogressrootrenderlanes 已经不要将要渲染的 root 和 lanes 了，将对 root 和 workinprogress 等变量执行清理和重置工作\n  if (workinprogressroot !== root || workinprogressrootrenderlanes !== lanes) {\n    preparefreshstack(root, lanes);\n  }\n  // 开启一个 workloopsync 循环，handleerror 将捕获和处理 workloopsync 执行中的错误。\n  do {\n    try {\n      workloopsync();\n      break;\n    } catch (thrownvalue) {\n      handleerror(root, thrownvalue);\n    }\n  } while (true);\n  // 当 workloopsync 的循环退出后，所有渲染工作就执行完毕，\n  resetcontextdependencies();\n  // 将 executioncontext 恢复至渲染之前的状态，这表明 rendercontext 和 commitcontext（将在后文中加入） 将会被移除，之所以可以这样做，是因为我们刚好需要重置到 batchedcontext\n  executioncontext = prevexecutioncontext;\n  // 推入 reactcurrentdispatcher.current，reactcurrentdispatcher.current 将置为 prevdispatcher\n  popdispatcher(prevdispatcher);\n  // workloopsync 循环执行完之后，workinprogress 应该置空，否则说明可能有工作没有执行完，所以报错\n  if (workinprogress !== null) {\n    // this is a sync render, so we should have finished the whole tree.\n    throw new error(\n      'cannot commit an incomplete root. this error is likely caused by a ' +\n        'bug in react. please file an issue.',\n    );\n  }\n  // 继 workinprogress 置空之后，也重置 workinprogressroot 和 workinprogressrootrenderlanes，这表明没有任何任务正在被渲染。\n  // set this to null to indicate there's no in-progress render.\n  workinprogressroot = null;\n  workinprogressrootrenderlanes = nolanes;\n  // workinprogressrootexitstatus 是文件中的一个全局变量，表示 hostroot 渲染之后退出时的状态，workloopsync 会更新这个值。\n  return workinprogressrootexitstatus;\n}\n\nexport function resetcontextdependencies(): void {\n  // this is called right before react yields execution, to ensure `readcontext`\n  // cannot be called outside the render phase.\n  currentlyrenderingfiber = null;\n  lastcontextdependency = null;\n  lastfullyobservedcontext = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n * 这里 executioncontext 使用很巧妙，这里直接缓存了 executioncontext 的值，并在执行完 workloopsync 之后恢复。这是因为 renderroot 中会在 executioncontext 加入 rendercontext，而在 workloop 中，则会在 executioncontext 加入 commitcontext。因此这里直接将 executioncontext 恢复至 batchcontext。\n * 在执行 renderroot 时，reactcurrentdispatcher.current 将被重置为 contextonlydispatcher，在执行完毕后恢复原值，这以为这什么呢？在 usestate 和 usereducer 原理探析 一文中已经套就过 reactcurrentdispatcher.current 中挂载的不同类型的 dispatcher 将会使用不同实现的 hooks。从下面的代码可以看出，在此阶段，所有的 hook 调用都会由 throwinvalidhookerror 报错。\n * 具体的渲染工作 workloopsync 完成的，这是一个死循环，直到 workloopsync 正常执行时退出。\n * 渲染完毕后会执行一些重置工作，包括 workinprogress、workinprogressroot、workinprogressrootrenderlanes 等。\n\nexport const contextonlydispatcher: dispatcher = {\n  readcontext,\n\n  usecallback: throwinvalidhookerror,\n  usecontext: throwinvalidhookerror,\n  useeffect: throwinvalidhookerror,\n  useimperativehandle: throwinvalidhookerror,\n  useinsertioneffect: throwinvalidhookerror,\n  uselayouteffect: throwinvalidhookerror,\n  usememo: throwinvalidhookerror,\n  usereducer: throwinvalidhookerror,\n  useref: throwinvalidhookerror,\n  usestate: throwinvalidhookerror,\n  usedebugvalue: throwinvalidhookerror,\n  usedeferredvalue: throwinvalidhookerror,\n  usetransition: throwinvalidhookerror,\n  usemutablesource: throwinvalidhookerror,\n  usesyncexternalstore: throwinvalidhookerror,\n  useid: throwinvalidhookerror,\n\n  unstable_isnewreconciler: enablenewreconciler,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# renderrootconcurrent\n\n在前面的分析中，我们知道 performconcurrentworkonroot 函数会调用 renderrootconcurrent 去完成异步任务的渲染工作。现在我们来看下异步任务是如何完成的？这里与 renderrootsync 类似，将简略分析。\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\nfunction renderrootconcurrent(root: fiberroot, lanes: lanes) {\n  const prevexecutioncontext = executioncontext;\n  executioncontext |= rendercontext;\n  const prevdispatcher = pushdispatcher();\n\n  // if the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. otherwise we'll continue where we left off.\n  if (workinprogressroot !== root || workinprogressrootrenderlanes !== lanes) {\n    resetrendertimer();\n    preparefreshstack(root, lanes);\n  }\n\n  do {\n    try {\n      workloopconcurrent();\n      break;\n    } catch (thrownvalue) {\n      handleerror(root, thrownvalue);\n    }\n  } while (true);\n  resetcontextdependencies();\n\n  popdispatcher(prevdispatcher);\n  executioncontext = prevexecutioncontext;\n\n  // check if the tree has completed.\n  if (workinprogress !== null) {\n    return rootincomplete;\n  } else {\n    // set this to null to indicate there's no in-progress render.\n    workinprogressroot = null;\n    workinprogressrootrenderlanes = nolanes;\n\n    // return the final exit status.\n    return workinprogressrootexitstatus;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n * 这里调用了 workloopconcurrent 以完成异步渲染任务，同样是死循环的设计，直到 workloopconcurrent 执行成功。\n * 不同的是，在 renderrootconcurrent 中，workloopconcurrent 循环执行之后，workinprogress 是可以不为 null 的，在 中，workloopsync 中将直接报错。需要注意的是，异步任务是可以不完成的，这时会返回 exitstatus 为 rootincomplete。\n\n\n# handleerror\n\nfunction handleerror(root, thrownvalue): void {\n  do {\n    let erroredwork = workinprogress;\n    try {\n      // reset module-level state that was set during the render phase.\n      resetcontextdependencies();\n      resethooksafterthrow();\n      // todo: i found and added this missing line while investigating a\n      // separate issue. write a regression test using string refs.\n      reactcurrentowner.current = null;\n\n      // 如果 workinprogress 不存在，或者 workinprogress.return 不存在则视为致命错误\n      if (erroredwork === null || erroredwork.return === null) {\n        // expected to be working on a non-root fiber. this is a fatal error\n        // because there's no ancestor that can handle it; the root is\n        // supposed to capture all errors that weren't caught by an error\n        // boundary.\n        workinprogressrootexitstatus = rootfatalerrored;\n        workinprogressrootfatalerror = thrownvalue;\n        // set `workinprogress` to null. this represents advancing to the next\n        // sibling, or the parent if there are no siblings. but since the root\n        // has no siblings nor a parent, we set it to null. usually this is\n        // handled by `completeunitofwork` or `unwindwork`, but since we're\n        // intentionally not calling those, we need set it here.\n        // todo: consider calling `unwindwork` to pop the contexts.\n        workinprogress = null;\n        return;\n      }\n\n      // 非致命错误将抛出异常、直接跳到完成渲染的回调\n      throwexception(\n        root,\n        erroredwork.return,\n        erroredwork,\n        thrownvalue,\n        workinprogressrootrenderlanes,\n      );\n      completeunitofwork(erroredwork);\n    } catch (yetanotherthrownvalue) {\n      // something in the return path also threw.\n      // 如果 workinprogress 上处理错误仍然抛出错误，找到 workinprogress.return 将其设置 erroredwork，错误将抛到父级处理。\n      thrownvalue = yetanotherthrownvalue;\n      if (workinprogress === erroredwork && erroredwork !== null) {\n        // if this boundary has already errored, then we had trouble processing\n        // the error. bubble it to the next boundary.\n        erroredwork = erroredwork.return;\n        workinprogress = erroredwork;\n      } else {\n        erroredwork = workinprogress;\n      }\n      continue;\n    }\n    // 只有没有 yetanotherthrownvalue 时才正常退出到 work loop\n    // return to the normal work loop.\n    return;\n  } while (true);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n * 对于致命错误将直接将 workinprogress 置为 null，exitstatus 将抛出致命错误。\n * 对于普通错误，抛出异常并且调用 completeunitofwork 执行渲染完毕的逻辑，这里 workinprogress 也会被值为 null。无论是致命错误还是普通错误都会正常跳出 workloop。\n * 对于处理过程中仍然抛出错误的错误，将向父级冒泡处理错误，知道错误被解决。\n\n\n# workloopsync\n\n通过上面的分析可以知道，renderrootsync 会调用 workloopsync 完成同步任务的渲染，现在我们来看下 workloopsync 函数。\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\n// the work loop is an extremely hot path. tell closure not to inline it.\n/** @noinline */\nfunction workloopsync() {\n  // already timed out, so perform work without checking if we need to yield.\n  while (workinprogress !== null) {\n    performunitofwork(workinprogress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 这个函数就是在 workinprogress 还有值的时候执行 performunitofwork 消费 workinprogress。同步渲染会完成所有的任务，即处理 hostroot 上所有 fiber 上的同步更新。\n * @noinline 是 chrome 浏览器的一种优化标注。 google closure compiler 使用此标注是函数或者标注不被转换成 inline。详见：@noinline。浏览器 js 引擎通过 inline 优化提升代码解析效率，这通常对一些常量、不太执行的函数（如工厂函数，我们将在 vue 源码中看到）有效，对执行频率较高的函数和变量反而效率很低。这里 @noinline 标注意思是不要使用 inline 优化，以免降低代码执行效率。\n\n提示\n\ninline 优化是什么？\n\nin computing, inline expansion, or inlining, is a manual or compiler optimization that replaces a function call site with the body of the called function. inline expansion is similar to macro expansion, but occurs during compilation, without changing the source code (the text), while macro expansion occurs prior to compilation, and results in different text that is then processed by the compiler.\n\n * inline expansion\n\n\n# workloopconcurrent\n\n在 renderrootconcurrent 函数中会调用 workloopconcurrent 以完成异步渲染任务。workloopconcurrent 与 workloopsync 类似，不在赘述。\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\n/** @noinline */\nfunction workloopconcurrent() {\n  // perform work until scheduler asks us to yield\n  while (workinprogress !== null && !shouldyield()) {\n    performunitofwork(workinprogress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * workinprogress 为 null 是会直接跳出，或者 shouldyield 时也会跳出。因此跳出 workloopconcurrent 有两种情况，一是所有任务都执行完了，二是调度器即将产生 (yield) 新回调了。\n\n\n# performunitofwork\n\n从上面的分析中，我们已经知道无论是 workloopsync 还是 workloopconcurrent 最终都会调用 performunitofwork，这说明同步任务和异步任务的分发，最终都是通过 performunitofwork 来真正执行的。也就是说，对于执行渲染任务而言，performunitofwork 才是背后默默干活的工人。下面我们着重分析下这个函数。\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n\nfunction performunitofwork(unitofwork: fiber): void {\n  // the current, flushed, state of this fiber is the alternate. ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  const current = unitofwork.alternate;\n\n  let next;\n \n  next = beginwork(current, unitofwork, subtreerenderlanes);\n\n  unitofwork.memoizedprops = unitofwork.pendingprops;\n  if (next === null) {\n    // if this doesn't spawn new work, complete the current work.\n    completeunitofwork(unitofwork);\n  } else {\n    workinprogress = next;\n  }\n\n  reactcurrentowner.current = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * 在 fiber 与 reconciliation 探析疑问中，我们分析过 fiber 的结构，其中 fiber.alternate 是 fiber 上的一个版本池，当 fiber 更新以后会更新到 fiber.alternate 上。unitofwork 本质是一个 fiber，其中 current 代表了 fiber 上一次更新的结果。\n * beginwork 对当前的 workinprogress 进行 render，渲染后返回下一个需要更新的 fiber。在 beginwork 中，我们将具体探讨 fiber 的遍历的方法和结构。\n * 当 next 为 null 时，所有 fiber render 完毕，因此执行 completeunitofwork。上一次执行 completeunitofwork 还是在 renderrootsync 和 renderrootconcurrent 的 handlererror 中遇到普通错误时。如果任务还没有完成，将 next 设置为 workinprogress，下次 performunitofwork 就会针对 next 进行 render。\n\n\n# beginwork\n\n在上面的分析中，我们已经知道 performunitofwork 会调用 beginwork 来执行 rootfiber 以及其下每一个 fiber 的渲染工作。那么具体执行了哪些工作呢？fibertree 的遍历是如何进行呢？下面我们来看下 beginwork：\n\n// src/react/packages/react-reconciler/src/reactfiberbeginwork.new.js\n\nfunction beginwork(\n  // 上次渲染的 fiber\n  current: fiber | null,\n  // 本次要渲染的 fiber\n  workinprogress: fiber,\n  renderlanes: lanes,\n): fiber | null {\n  // 非初次渲染\n  if (current !== null) {\n    const oldprops = current.memoizedprops;\n    const newprops = workinprogress.pendingprops;\n\n    if (\n      oldprops !== newprops ||\n      haslegacycontextchanged() ||\n      // force a re-render if the implementation changed due to hot reload:\n      (__dev__ ? workinprogress.type !== current.type : false)\n    ) {\n      // if props or context changed, mark the fiber as having performed work.\n      // this may be unset if the props are determined to be equal later (memo).\n      didreceiveupdate = true;\n    } else {\n      // neither props nor legacy context changes. check if there's a pending\n      // update or context change.\n      const hasscheduledupdateorcontext = checkscheduledupdateorcontext(\n        current,\n        renderlanes,\n      );\n      if (\n        !hasscheduledupdateorcontext &&\n        // if this is the second pass of an error or suspense boundary, there\n        // may not be work scheduled on `current`, so we check for this flag.\n        (workinprogress.flags & didcapture) === noflags\n      ) {\n        // no pending updates or context. bail out now.\n        didreceiveupdate = false;\n        return attemptearlybailoutifnoscheduledupdate(\n          current,\n          workinprogress,\n          renderlanes,\n        );\n      }\n      if ((current.flags & forceupdateforlegacysuspense) !== noflags) {\n        // this is a special case that only exists for legacy mode.\n        // see https://github.com/facebook/react/pull/19216.\n        didreceiveupdate = true;\n      } else {\n        // an update was scheduled on this fiber, but there are no new props\n        // nor legacy context. set this to false. if an update queue or context\n        // consumer produces a changed value, it will set this to true. otherwise,\n        // the component will assume the children have not changed and bail out.\n        didreceiveupdate = false;\n      }\n    }\n  } else {\n    didreceiveupdate = false;\n\n    if (getishydrating() && isforkedchild(workinprogress)) {\n      // check if this child belongs to a list of muliple children in\n      // its parent.\n      //\n      // in a true multi-threaded implementation, we would render children on\n      // parallel threads. this would represent the beginning of a new render\n      // thread for this subtree.\n      //\n      // we only use this for id generation during hydration, which is why the\n      // logic is located in this special branch.\n      // index 记录了当前 fiber 排在父列表中的下标\n      const slotindex = workinprogress.index;\n      const numberofforks = getforksatlevel(workinprogress);\n      pushtreeid(workinprogress, numberofforks, slotindex);\n    }\n  }\n\n  // before entering the begin phase, clear pending update priority.\n  // todo: this assumes that we're about to evaluate the component and process\n  // the update queue. however, there's an exception: simplememocomponent\n  // sometimes bails out later in the begin phase. this indicates that we should\n  // move this assignment out of the common path and into each branch.\n  // 因为如下要真正渲染了，可以将优先级信息清空\n  workinprogress.lanes = nolanes;\n\n  switch (workinprogress.tag) {\n    case indeterminatecomponent: {\n      return mountindeterminatecomponent(\n        current,\n        workinprogress,\n        workinprogress.type,\n        renderlanes,\n      );\n    }\n    case lazycomponent: {\n      const elementtype = workinprogress.elementtype;\n      return mountlazycomponent(\n        current,\n        workinprogress,\n        elementtype,\n        renderlanes,\n      );\n    }\n    case functioncomponent: {\n      const component = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      const resolvedprops =\n        workinprogress.elementtype === component\n          ? unresolvedprops\n          : resolvedefaultprops(component, unresolvedprops);\n      return updatefunctioncomponent(\n        current,\n        workinprogress,\n        component,\n        resolvedprops,\n        renderlanes,\n      );\n    }\n    case classcomponent: {\n      const component = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      const resolvedprops =\n        workinprogress.elementtype === component\n          ? unresolvedprops\n          : resolvedefaultprops(component, unresolvedprops);\n      return updateclasscomponent(\n        current,\n        workinprogress,\n        component,\n        resolvedprops,\n        renderlanes,\n      );\n    }\n    case hostroot:\n      return updatehostroot(current, workinprogress, renderlanes);\n    case hostcomponent:\n      return updatehostcomponent(current, workinprogress, renderlanes);\n    case hosttext:\n      return updatehosttext(current, workinprogress);\n    case suspensecomponent:\n      return updatesuspensecomponent(current, workinprogress, renderlanes);\n    case hostportal:\n      return updateportalcomponent(current, workinprogress, renderlanes);\n    case forwardref: {\n      const type = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      const resolvedprops =\n        workinprogress.elementtype === type\n          ? unresolvedprops\n          : resolvedefaultprops(type, unresolvedprops);\n      return updateforwardref(\n        current,\n        workinprogress,\n        type,\n        resolvedprops,\n        renderlanes,\n      );\n    }\n    case fragment:\n      return updatefragment(current, workinprogress, renderlanes);\n    case mode:\n      return updatemode(current, workinprogress, renderlanes);\n    case profiler:\n      return updateprofiler(current, workinprogress, renderlanes);\n    case contextprovider:\n      return updatecontextprovider(current, workinprogress, renderlanes);\n    case contextconsumer:\n      return updatecontextconsumer(current, workinprogress, renderlanes);\n    case memocomponent: {\n      const type = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      // resolve outer props first, then resolve inner props.\n      let resolvedprops = resolvedefaultprops(type, unresolvedprops);\n      if (__dev__) {\n        if (workinprogress.type !== workinprogress.elementtype) {\n          const outerproptypes = type.proptypes;\n          if (outerproptypes) {\n            checkproptypes(\n              outerproptypes,\n              resolvedprops, // resolved for outer only\n              'prop',\n              getcomponentnamefromtype(type),\n            );\n          }\n        }\n      }\n      resolvedprops = resolvedefaultprops(type.type, resolvedprops);\n      return updatememocomponent(\n        current,\n        workinprogress,\n        type,\n        resolvedprops,\n        renderlanes,\n      );\n    }\n    case simplememocomponent: {\n      return updatesimplememocomponent(\n        current,\n        workinprogress,\n        workinprogress.type,\n        workinprogress.pendingprops,\n        renderlanes,\n      );\n    }\n    case incompleteclasscomponent: {\n      const component = workinprogress.type;\n      const unresolvedprops = workinprogress.pendingprops;\n      const resolvedprops =\n        workinprogress.elementtype === component\n          ? unresolvedprops\n          : resolvedefaultprops(component, unresolvedprops);\n      return mountincompleteclasscomponent(\n        current,\n        workinprogress,\n        component,\n        resolvedprops,\n        renderlanes,\n      );\n    }\n    case suspenselistcomponent: {\n      return updatesuspenselistcomponent(current, workinprogress, renderlanes);\n    }\n    case scopecomponent: {\n      if (enablescopeapi) {\n        return updatescopecomponent(current, workinprogress, renderlanes);\n      }\n      break;\n    }\n    case offscreencomponent: {\n      return updateoffscreencomponent(current, workinprogress, renderlanes);\n    }\n    case legacyhiddencomponent: {\n      return updatelegacyhiddencomponent(current, workinprogress, renderlanes);\n    }\n    case cachecomponent: {\n      if (enablecache) {\n        return updatecachecomponent(current, workinprogress, renderlanes);\n      }\n      break;\n    }\n  }\n\n  throw new error(\n    `unknown unit of work tag (${workinprogress.tag}). this error is likely caused by a bug in ` +\n      'react. please file an issue.',\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n\n * didreceiveupdate 标记是否有属性或者 context 的更新，因为这两种情况会引发 re-render。\n * 重要环境在于根据 workinprogress.tag 类别创建或者更新不同的组件，这里具体过程不在赘述，可以参考 workloop 和 performunitofwork 探析一文。\n * 需要注意的是，在上面 updatexxxcomponent 的之后，会返回 workinprogress.child ，作为 performunitofwork 中的 next。根据这个线索，可以知道 react 中 performunitofwork 中是根据深度优先搜索（dfs）来进行遍历渲染的，那么这种遍历怎么扩展到兄弟节点呢？\n\n\n# completeunitofwork\n\n\n# completework\n\n\n# commitroot",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-14T22:02:21.000Z",permalink:"/react/tour/index/",categories:["react","React源码漂流记"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/0.index.html",relativePath:"10.react/90.React源码漂流记/0.index.md",key:"v-071d800b",path:"/react/tour/index/",headers:[{level:2,title:"为什么要有React 源码漂流记？",slug:"为什么要有react-源码漂流记",normalizedTitle:"为什么要有 react 源码漂流记？",charIndex:2},{level:2,title:"文章结构",slug:"文章结构",normalizedTitle:"文章结构",charIndex:509},{level:2,title:"文章标记",slug:"文章标记",normalizedTitle:"文章标记",charIndex:686}],readingTime:{text:"1 min read",minutes:.25,time:15e3,words:50},headersStr:"为什么要有React 源码漂流记？ 文章结构 文章标记",content:"# 为什么要有 React 源码漂流记？\n\n * 旧的文章有较多需要改进的地方，一方面解读过于细致入微，另一方面也不乏部分理解也不够深入的情况，其实是不利于读者阅读的。因此这个新的系列将会赵忠去解决这些问题，重新整理旧有的源码笔记，温故而知新，目的是形成成一份成体系的、利于阅读的、易理解的源码笔记。\n * 在阅读过程中我陆续产生了新的体会，这些内容如果穿插在旧的笔记中比较难以维护，所以索性以新的系列的方式再次重温之前的代码并且索性更新 React 的版本，从新的代码阅读中获得新知。这本身也是个温故知新的过程。\n * 收到反馈之前的文章比较难以理解，新的文章将更加注重知识体系的构建，以更顺的思路编写，视角也不再纠结于琐碎的细节，而是以全局的视野去分析问题。\n * 之前文章的关注点更多在于 笔记 两个字，新的系列将把关注点移到 文章 。所谓文章而言，关注点会更多的倾向于让读者知道我在说什么而不是只有我自己理解我在说什么。\n * 新的系列将会以更加宽广的视野来解析源码，期间可能会把 React 源码跟 Vue 的源码或者其他框架的思路进行比较和扩展。\n * 新的文章思路会更加清晰，语言也会尽量易懂。\n\n\n# 文章结构\n\n * 目录\n * 前言：总结前文，并且对本文的内容做导引。\n * 内容：尽量间接易懂，去除干扰阅读的内容。\n * 扩展：对文章内容的扩展知识，更加细节的内容或者思路。不需要的关注的读者可以直接忽略。\n * 问题：阅读本文可能会有的问题及解答，以及后续文章的预告。\n * 总结：对本篇文章的内容进行概括性的总结，帮助读者进行知识归纳。\n\n\n# 文章标记\n\n文章标题下会有一些提示性的标记，如核心、重点、了解、React 版本等。\n\n文章重要性标记：\n\n * P0: 源码阅读初级和中级内容。\n * P1: 源码阅读扩展性内容。\n * P2、P3: 源码阅读进阶内容。\n\n本标记分类为个人观点，读者可根据需要自行选择阅读。",normalizedContent:"# 为什么要有 react 源码漂流记？\n\n * 旧的文章有较多需要改进的地方，一方面解读过于细致入微，另一方面也不乏部分理解也不够深入的情况，其实是不利于读者阅读的。因此这个新的系列将会赵忠去解决这些问题，重新整理旧有的源码笔记，温故而知新，目的是形成成一份成体系的、利于阅读的、易理解的源码笔记。\n * 在阅读过程中我陆续产生了新的体会，这些内容如果穿插在旧的笔记中比较难以维护，所以索性以新的系列的方式再次重温之前的代码并且索性更新 react 的版本，从新的代码阅读中获得新知。这本身也是个温故知新的过程。\n * 收到反馈之前的文章比较难以理解，新的文章将更加注重知识体系的构建，以更顺的思路编写，视角也不再纠结于琐碎的细节，而是以全局的视野去分析问题。\n * 之前文章的关注点更多在于 笔记 两个字，新的系列将把关注点移到 文章 。所谓文章而言，关注点会更多的倾向于让读者知道我在说什么而不是只有我自己理解我在说什么。\n * 新的系列将会以更加宽广的视野来解析源码，期间可能会把 react 源码跟 vue 的源码或者其他框架的思路进行比较和扩展。\n * 新的文章思路会更加清晰，语言也会尽量易懂。\n\n\n# 文章结构\n\n * 目录\n * 前言：总结前文，并且对本文的内容做导引。\n * 内容：尽量间接易懂，去除干扰阅读的内容。\n * 扩展：对文章内容的扩展知识，更加细节的内容或者思路。不需要的关注的读者可以直接忽略。\n * 问题：阅读本文可能会有的问题及解答，以及后续文章的预告。\n * 总结：对本篇文章的内容进行概括性的总结，帮助读者进行知识归纳。\n\n\n# 文章标记\n\n文章标题下会有一些提示性的标记，如核心、重点、了解、react 版本等。\n\n文章重要性标记：\n\n * p0: 源码阅读初级和中级内容。\n * p1: 源码阅读扩展性内容。\n * p2、p3: 源码阅读进阶内容。\n\n本标记分类为个人观点，读者可根据需要自行选择阅读。",charsets:{cjk:!0},lastUpdated:"2022/08/24, 18:21:13",lastUpdatedTimestamp:1661336473e3},{title:"Plan 计划",frontmatter:{title:"Plan 计划",date:"2022-04-15T10:00:16.000Z",permalink:"/react/tour/plan/",categories:["react","React源码漂流记"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/1.Plan.html",relativePath:"10.react/90.React源码漂流记/1.Plan.md",key:"v-7532101f",path:"/react/tour/plan/",headers:[{level:2,title:"Plan 与计划时间",slug:"plan-与计划时间",normalizedTitle:"plan 与计划时间",charIndex:2},{level:2,title:"TODO",slug:"todo",normalizedTitle:"todo",charIndex:999}],readingTime:{text:"2 min read",minutes:1.085,time:65099.99999999999,words:217},headersStr:"Plan 与计划时间 TODO",content:"# Plan 与计划时间\n\n * React 源码基础\n   * ReactElement 与基础概念 P0\n   * ReactChildren 与节点操纵 P0\n   * React 整体结构和理念初认识 P0\n   * React 首次渲染过程解读 P0\n   * React 中的位运算技巧 P1\n   * React 组件机制解读 P2\n   * React 组件生命周期原理探讨 P2（舍弃）：主要用于类组件，不在关注。\n   * React 组件副作用原理探讨 P2\n * React 调和器核心源码解读\n   * Fiber 与调和基础 P0\n   * React 调和器核心源码解读（一）P0\n   * React 调和器核心源码解读（二）P0\n   * React 调和器核心源码解读（三）P0\n   * React 调和器核心源码解读（四）P0\n   * React 调和器核心源码解读（五）P0\n   * React 调和器核心源码解读（六）P0\n   * React 调和器核心源码解读（七）P0\n   * React 调和器核心源码解读（八）P0\n   * React 调和器核心源码解读（九）P0\n   * React 调和器核心源码解读（十）P0\n   * React 调和器核心原理串讲 P0\n   * expirationTime 与优先级 P1（舍弃，React 官方已经舍弃）\n   * lane 与优先级 P1\n * React 调度器核心源码解读\n   * React 调度器核心源码解读（一）P0\n   * React 调度器核心源码解读（二）P0\n * React Hooks 原理解读\n   * useState 和 useReducer 原理解读 P0\n   * useEffect 原理解读 P0\n   * useMemo 和 useCallback 原理解读 P0\n * React 源码进阶\n   * React 总体流程探讨 P2\n   * React 中的更新循环探讨 P2\n   * React 中的事件系统原理 P2\n   * React 中的数据结构总结 P2\n   * React 中的 Lazy 组件探讨 P3\n   * 带着原理重读 React 官方文档 P3\n\n提醒：[] 为未完成文章， [x] 为已完成文章。\n\n\n# TODO\n\n * 加入面试专题",normalizedContent:"# plan 与计划时间\n\n * react 源码基础\n   * reactelement 与基础概念 p0\n   * reactchildren 与节点操纵 p0\n   * react 整体结构和理念初认识 p0\n   * react 首次渲染过程解读 p0\n   * react 中的位运算技巧 p1\n   * react 组件机制解读 p2\n   * react 组件生命周期原理探讨 p2（舍弃）：主要用于类组件，不在关注。\n   * react 组件副作用原理探讨 p2\n * react 调和器核心源码解读\n   * fiber 与调和基础 p0\n   * react 调和器核心源码解读（一）p0\n   * react 调和器核心源码解读（二）p0\n   * react 调和器核心源码解读（三）p0\n   * react 调和器核心源码解读（四）p0\n   * react 调和器核心源码解读（五）p0\n   * react 调和器核心源码解读（六）p0\n   * react 调和器核心源码解读（七）p0\n   * react 调和器核心源码解读（八）p0\n   * react 调和器核心源码解读（九）p0\n   * react 调和器核心源码解读（十）p0\n   * react 调和器核心原理串讲 p0\n   * expirationtime 与优先级 p1（舍弃，react 官方已经舍弃）\n   * lane 与优先级 p1\n * react 调度器核心源码解读\n   * react 调度器核心源码解读（一）p0\n   * react 调度器核心源码解读（二）p0\n * react hooks 原理解读\n   * usestate 和 usereducer 原理解读 p0\n   * useeffect 原理解读 p0\n   * usememo 和 usecallback 原理解读 p0\n * react 源码进阶\n   * react 总体流程探讨 p2\n   * react 中的更新循环探讨 p2\n   * react 中的事件系统原理 p2\n   * react 中的数据结构总结 p2\n   * react 中的 lazy 组件探讨 p3\n   * 带着原理重读 react 官方文档 p3\n\n提醒：[] 为未完成文章， [x] 为已完成文章。\n\n\n# todo\n\n * 加入面试专题",charsets:{cjk:!0},lastUpdated:"2022/10/28, 18:38:54",lastUpdatedTimestamp:1666953534e3},{title:"React 源码漂流记：ReactElement 与基础概念",frontmatter:{title:"React 源码漂流记：ReactElement 与基础概念",date:"2022-04-14T22:02:21.000Z",permalink:"/react/tour/react-basic-element/",categories:["react","React源码漂流记"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/10.react-basic-element.html",relativePath:"10.react/90.React源码漂流记/10.react-basic-element.md",key:"v-05b01242",path:"/react/tour/react-basic-element/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:3,title:"学习目标",slug:"学习目标",normalizedTitle:"学习目标",charIndex:19},{level:2,title:"源码结构",slug:"源码结构",normalizedTitle:"源码结构",charIndex:27},{level:2,title:"React API 概况",slug:"react-api-概况",normalizedTitle:"react api 概况",charIndex:35},{level:2,title:"JSX",slug:"jsx",normalizedTitle:"jsx",charIndex:51},{level:3,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:60},{level:3,title:"为什么使用 JSX？",slug:"为什么使用-jsx",normalizedTitle:"为什么使用 jsx？",charIndex:68},{level:3,title:"JSX 如何 解析为 JS？",slug:"jsx-如何-解析为-js",normalizedTitle:"jsx 如何 解析为 js？",charIndex:84},{level:2,title:"ReactElement",slug:"reactelement",normalizedTitle:"reactelement",charIndex:102},{level:3,title:"createElement",slug:"createelement",normalizedTitle:"createelement",charIndex:120},{level:2,title:"isValidElement",slug:"isvalidelement",normalizedTitle:"isvalidelement",charIndex:137},{level:2,title:"VDOM",slug:"vdom",normalizedTitle:"vdom",charIndex:155},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:163},{level:3,title:"React 的详细目录结构和作用",slug:"react-的详细目录结构和作用",normalizedTitle:"react 的详细目录结构和作用",charIndex:171},{level:3,title:"为什么 React 17 之前需要显式引入 React，17 版本就不需要了呢？",slug:"为什么-react-17-之前需要显式引入-react-17-版本就不需要了呢",normalizedTitle:"为什么 react 17 之前需要显式引入 react，17 版本就不需要了呢？",charIndex:193},{level:3,title:"React 中的 VDOM 是 ReactElement 吗？",slug:"react-中的-vdom-是-reactelement-吗",normalizedTitle:"react 中的 vdom 是 reactelement 吗？",charIndex:239},{level:3,title:"owner 是如何连接 ReactElement 和 Fiber 的？owner 有什么作用？",slug:"owner-是如何连接-reactelement-和-fiber-的-owner-有什么作用",normalizedTitle:"owner 是如何连接 reactelement 和 fiber 的？owner 有什么作用？",charIndex:276},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:327},{level:3,title:"VDOM Tree 和 Fiber Tree 是如何连接的？",slug:"vdom-tree-和-fiber-tree-是如何连接的",normalizedTitle:"vdom tree 和 fiber tree 是如何连接的？",charIndex:335},{level:3,title:"为什么用 className?",slug:"为什么用-classname",normalizedTitle:"为什么用 classname?",charIndex:371},{level:3,title:"ReactElement Tree、Fiber Tree 和 DOM Tree 的关系？",slug:"reactelement-tree、fiber-tree-和-dom-tree-的关系",normalizedTitle:"reactelement tree、fiber tree 和 dom tree 的关系？",charIndex:392},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:440}],readingTime:{text:"8 min read",minutes:7.695,time:461700.00000000006,words:1539},headersStr:"目录 学习目标 源码结构 React API 概况 JSX 介绍 为什么使用 JSX？ JSX 如何 解析为 JS？ ReactElement createElement isValidElement VDOM 扩展 React 的详细目录结构和作用 为什么 React 17 之前需要显式引入 React，17 版本就不需要了呢？ React 中的 VDOM 是 ReactElement 吗？ owner 是如何连接 ReactElement 和 Fiber 的？owner 有什么作用？ 问题 VDOM Tree 和 Fiber Tree 是如何连接的？ 为什么用 className? ReactElement Tree、Fiber Tree 和 DOM Tree 的关系？ 总结",content:'# 目录\n\n\n\n * 目录\n   * 学习目标\n * 源码结构\n * React API 概况\n * JSX\n   * 介绍\n   * 为什么使用 JSX？\n   * JSX 如何 解析为 JS？\n * ReactElement\n   * createElement\n * isValidElement\n * VDOM\n * 扩展\n   * React 的详细目录结构和作用\n   * 为什么 React 17 之前需要显式引入 React，17 版本就不需要了呢？\n   * React 中的 VDOM 是 ReactElement 吗？\n   * owner 是如何连接 ReactElement 和 Fiber 的？owner 有什么作用？\n * 问题\n   * VDOM Tree 和 Fiber Tree 是如何连接的？\n   * 为什么用 className?\n   * ReactElement Tree、Fiber Tree 和 DOM Tree 的关系？\n * 总结\n\n\n\n\n# 学习目标\n\n * 学习 React 的整体目录结构、API 概况、核心包的作用。\n * 学习 JSX、ReactElement、VDOM 等概念，了解 JSX 的解析原理。\n * 了解 React 选择 JSX 和 VDOM 的原因。\n\n\n# 源码结构\n\n熟悉 React 的小伙伴可能都知道，React 大致上可以分成调和器、调度器、渲染器几个部分。对应到 React 的源码里，最重要的就是有四个包，分别是 react、react-dom、scheduler、react-reconciler。克隆下源码，大概像是这样：\n\n上述几个包的核心作用：\n\n * react：导出 React 的核心 API，供外部应用使用。比如 Fragment、forwardRef、memo、hook 全家桶等。\n * react-dom：React 基于 web 的渲染层，导出一些渲染相关的 API，比如说 render、createPortal、createRoot 等。\n * scheduler：React 中的调度器，负责任务队列的维护，基于优先级调度任务。\n * react-reconciler：React 中的调和器，负责 React 渲染的整体流程，包括 FiberTree 的调和等，与调度器配合完成更新任务的包装与调度、捕获与冒泡过程、DIFF 算法、EffectTag List 的维护、维护 FiberTree 双缓存结构、组件生命周期的调用、配合渲染器完成 DOM 渲染等。\n\n\n# React API 概况\n\n在 react 包中 React.js 文件中对 React 有如下定义，通过这个定义，我们可以对 React 的核心 API 初步认识。\n\nconst React = {\n  // 提供了用于处理 children 不透明数据结构的实用方法。\n  // 操作 ReactChildren 的方法。ReactChildren不是数组。这里模拟数组的一些方法。\n  Children: { \n    map,\n    forEach,\n    count,\n    toArray,\n    only,\n  },\n  // 创建一个能够通过 ref 属性附加到 React 元素的 ref。\n  createRef, \n  // 定义类组件需集成自 Component\n  Component,\n  // PureComponent 以浅层对比 prop 和 state 的方式来实现 shouldComponentUpdate 函数。\n  PureComponent, \n  // 创建一个 Context 对象。当组件订阅了这个 Context 对象，组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。\n  createContext,\n  // forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。\n  forwardRef, \n  // lazy 函数能让你像渲染常规组件一样处理动态引入（的组件）。\n  lazy, \n  // memo 检查 props 变更，以此通过记忆组件渲染结果的方式来提高组件的性能表现。\n  memo,\n  // Hook API\n  // 返回一个 memoized 回调函数。\n  useCallback,\n  // 接收一个 context 对象，并返回距离 <MyContext.Provider> 最近的 context 的当前值。\n  useContext,\n  // 接收一个包含命令式、且可能有副作用代码的函数完成副作用操作。React 的纯函数式世界通往命令式世界的逃生通道\n  useEffect,\n  // 在使用 ref 时自定义暴露给父组件的实例值。\n  useImperativeHandle,\n  // 可用于在 React 开发者工具中显示自定义 hook 的标签。\n  useDebugValue,\n  // 所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。\n  useLayoutEffect,\n  // 返回一个 memoized 值。\n  useMemo,\n  // useState 的替代方案。它接收一个 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。\n  useReducer,\n  // useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数，返回的 ref 对象在组件的整个生命周期内持续存在。\n  useRef,\n  // 返回一个 state，以及更新 state 的函数。\n  useState,\n  // Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。\n  Fragment: REACT_FRAGMENT_TYPE,\n  // Profiler 测量一个 React 应用多久渲染一次以及渲染一次的“代价”。\n  Profiler: REACT_PROFILER_TYPE,\n  // StrictMode 是一个用来突出显示应用程序中潜在问题的工具。\n  StrictMode: REACT_STRICT_MODE_TYPE, \n  // Suspense 可以指定加载指示器，以防其组件树中的某些子组件尚未具备渲染条件。\n  Suspense: REACT_SUSPENSE_TYPE, // 与lazy结合使用，指定一个feedback。\n  // 创建并返回指定类型的新 React 元素。\n  createElement: __DEV__ ? createElementWithValidation : createElement,\n  // 以 element 元素为样板克隆并返回新的 React 元素。\n  cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement,\n  // 验证对象是否为 React 元素\n  isValidElement: isValidElement,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n其中比较重要的大致为：\n\n * 元素相关：Children、createElement、cloneElement。\n * 组件相关：Component、PureComponent、createRef、Fragment、forwardRef\n * hooks api: useCallback,useContext,useEffect,useImperativeHandle,useDebugValue,useLayoutEffect,useMemo,useReducer,useRef,useState。\n * 优化相关：lazy、memo、Suspense。\n * 其他：createContext。\n\n\n# JSX\n\n\n# 介绍\n\n什么是 JSX？\n\n> JSX (JavaScript Syntax Extension，JavaScript 语法扩展) 是 JavaScript 语法的扩展，最初用于 React，它提供一种类似于 HTML 的语法来 结构化的编写组件。【来自 JSX】\n\n文档\n\nJSX 可以生成 React “元素”，可以很好地描述 UI 应该呈现出它应有交互的本质形式，具有 JavaScript 的全部功能。\n\nReact 开发者对于 JSX 应该是很熟悉了，更专业一点来说：\n\n * JSX 是一种将 JS 和 HTML 混合编写组件的语法糖，其语法需要通过 babel 解析之后才能被浏览器识别。\n * JSX 语法可以通过 @babel/plugin-transform-react-jsx-source 插件进行解析。\n\n\n# 为什么使用 JSX？\n\n关于 JSX 更详细的内容，React 官方文档中 JSX 简介 已经讲的很清楚了，此处不再赘述。但是我想浅谈一下我对 React 选择 JSX 背后的哲学原因的理解。\n\n> React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合。\n> \n> React 并没有采用将标记与逻辑进行分离到不同文件这种人为地分离方式，而是通过将二者共同存放在称之为 “组件” 的松散耦合单元之中，来实现关注点分离。【来自 React 官方文档：为什么使用 JSX？】\n\n * 渲染逻辑与 UI 逻辑耦合 是 React、Vue 等框架流行带来的组件化理念的必然结果。组件化要求我们将样式（UI 逻辑）与行为（渲染逻辑）封装到组件中已达到代码复用之目的，这也是组件化开发带来的最大的红利。\n * 将标记与逻辑进行分离到不同文件 这种思维方式在框架诞生之前编写原生 JS 时最常用的代码分离的手段，当然框架的组件化驱动的理念促使这种做法被放弃，取而代之的有如下的两种常见的新的理念，这两种理念都达到了 将二者共同存放在称之为“组件”的松散耦合单元之中，来实现关注点分离 的目的。\n   * JSX：以 React.js、Solid.js 框架为代表。将 HTML 和 JavaScript 混合编写组件。\n   * SFC：以 Vue.js 和 svelte.js 框架为代表。单文件组件将组件分为 template 、 style 和 script 三个部分。\n\n\n# JSX 如何 解析为 JS？\n\n让我们使用 babel-transform-react-jsx 对如下的代码进行转换：\n\nconst work = () => {dosomething();}\nconst Conponent = () => {\n return (\n    <div style={{color: \'#ffffff\'}}>\n      <h1 class="title">heading</h1>\n      <div class="body" onClick={work}>content</div>\n    </div>\n    )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n转换结果如下：\n\nconst work = () => {\n  dosomething();\n};\n\nconst Conponent = () => {\n  return /*#__PURE__*/ React.createElement(\n    "div",\n    {\n      style: {\n        color: "#ffffff"\n      }\n    },\n    /*#__PURE__*/ React.createElement(\n      "h1",\n      {\n        class: "title"\n      },\n      "heading"\n    ),\n    /*#__PURE__*/ React.createElement(\n      "div",\n      {\n        class: "body",\n        onClick: work\n      },\n      "content"\n    )\n  );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n分析上面的解析过程可知：\n\n * babel 插件在解析 jsx 代码时，js 部分是不需要解析的，html 部分会被解析为 React.createElement 语法。\n * React.createElement 会被加上 /*#__PURE__*/ 的静态内容标记。\n * 多个子节点并不是通过数组传入而是以多个参数的形式传入的，这个可以通过 rest 运算符处理。\n\nJSX 会将代码中 html 转化为渲染函数（如 vue 中的 h 函数、createElement 函数）的语法糖，以方便框架对 JSX 的内容进行处理。这实际上使得 JSX 语法与框架解耦，使 JSX 能够运用到各种实现了渲染函数的框架之中。\n\n\n# ReactElement\n\n下面将介绍 ReactElement 以及 VDOM 的概念。\n\n\n# createElement\n\ncreateElement 创建 React 元素（ReactElement）。先来看一个例子，假如一个经过 babel 解析过的 JSX 代码如下：\n\nReact.createElement("div", {\n    class: "class_name",\n    id: "id_name",\n    key: "key_name",\n    ref: "ref_name"\n}, React.createElement("span", null, "Tom"), React.createElement("span", null, "Jerry"));\n\n\n1\n2\n3\n4\n5\n6\n\n\n以上的执行结果如下：\n\n{\n    $$typeof: REACT_ELEMENT_TYPE,\n    type：\'div\'，\n    key: \'key_name\',\n    ref: "ref_name",\n    props: {\n        class: "class_name",\n        id: "id_name",\n        children: [\n            React.createElement("span", null, "Tom"),\n            React.createElement("span", null, "Jerry")\n        ]\n    }\n     _owner: ReactCurrentOwner.current,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这便是 ReactElement 的真面目了。React 是基于 VDOM 的运行时框架，其内部节点的创建、更新、patch、删除都是通过 VDOM 来实现的。\n\n我们通常熟知的 VDOM 节点，包括 type、attr、children 三个元素，那么我们再来看 ReactElement 的特征，ReactElement 对象也包含了这三个属性，只不过 attr 和 children 是放在 props 中的，我们知道 React 组件的设计哲学是 组件是依赖 props 和 state更新，props 关注组件与外部的状态，state 关注组件内部的状态 ，这一点也是符合理念的。\n\n下面的内容我们将从源码的角度继续探究：\n\ncreateElement 的源码：\n\n// src/react/packages/react/src/ReactElement.js\n// 根据元素类型 type，元素属性 config 和元素子节点（数组） children 创建 react 元素\nexport function createElement(type, config, children) {\n  let propName;\n  const props = {};\n\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n\n  if (config != null) {\n    // 检查是否添加了 ref 属性\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    // 检查是否添加了 key 属性\n    if (hasValidKey(config)) {\n      key = \'\' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // 添加至属性对象\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        !RESERVED_PROPS.hasOwnProperty(propName)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n  // 计算 children 的长度，children 是作为剩余参数传入的\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    // 单一子节点直接赋值\n    // children 是放到 props 上的，因此可以通过 props 的 children 获得组件内部内容\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    // 多个子节点转为数组\n    props.children = childArray;\n  }\n\n  // 元素默认的属性\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  // 调用工厂函数创建 ReactElement。\n  return ReactElement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    ReactCurrentOwner.current,\n    props,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n如上函数具有如下的核心功能：\n\n * 计算 key、ref、self、source 属性。\n * 计算 props，包括 configs 中除 RESERVED_PROPS 之外的属性、children 属性、当前类型的 ReactElement 所应该具有的默认属性 (如 \'div\' 元素的默认属性)。\n * 调用 ReactElement 创建 ReactElement。\n\n下面我们接着看下 ReactElement 工厂函数，这对于我们了解 React 虚拟 DOM 的结构至关重要:\n\nconst ReactElement = function (type, key, ref, self, source, owner, props) {\n  // 新建一个ReactElement对象\n  const element = {\n    // ReactElement 的独一无二的标志，用来判断 element 是否是 ReactElement。\n    $$typeof: REACT_ELEMENT_TYPE,\n    // element 的类型\n    type: type,\n    // element 的 key 值，这对 React 复用元素很重要\n    key: key,\n    // element 的 ref 属性，元素的引用\n    ref: ref,\n    // element 的属性，包括了 children、class、id 等\n    props: props,\n    // element 的属主，当前元素所属于的 Fiber，由哪一个 Fiber 所创建。\n    _owner: owner,\n  };\n\n  return element;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * $$typeof ：ReactElement 的独一无二的标志，用来判断 element 是否是 ReactElement， REACT_ELEMENT_TYPE = symbolFor(\'react.element\') 。\n * type：element 的类型，注意如 \'div\'、\'span\' 等。\n * key：element 的 key 值，这对 React 复用元素很重要。\n * ref:：element 的 ref 属性，元素的引用。\n * props：element 的属性，包括了 children、class、id 等。\n * _owner：element 的属主，当前元素所属于的 Fiber，由哪一个 Fiber 所创建。\n\n\n# isValidElement\n\nisValidElement 判断 element 是否是合法的 ReactElement。\n\nexport function isValidElement(object) {\n  return (\n    typeof object === \'object\' &&\n    object !== null &&\n    // $$typeof: Symbol(react.element)\n    object.$$typeof === REACT_ELEMENT_TYPE \n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# VDOM\n\nVDOM 是对 DOM（Document Object Model）的一种轻量级的 JavaScript 呈现方式，多用于 React、Vue 等声明式的前端框架中。使用 VDOM 有如下的优点：\n\n * 轻量级。VDOM 只需要记录很少的信息就能展示 DOM 呈现方式和结构。\n * 速度更快。VDOM 能够对连续更新做批量处理，减少 reflow 和 repaint。\n * 抽象层，跨平台。VDOM 在 DOM Tree 的基础上抽象出 VDOM Tree，VDOM Tree 是一种数据结构，不依赖于平台特性。这使得核心逻辑能够运行在不同的平台上，屏蔽掉平台的兼容性。\n * 可控制，可优化。因为 VDOM 足够简单，JavaScript 能够很方便的操纵和控制 UI 展现，如删除、增加、更新、移动节点等。同时，对于页面状态的更新有了更加可控的优化手段，如 DIFF 算法、节点复用。\n\n当然 VDOM 也存在一些问题：\n\n * 初始化的时间成本。初始化时需要将 UI 的展现转化为具体的 VDOM Tree，这部分的转换需要一定的时间成本。\n * DIFF 算法的成本。尽管 JavaScript 操作 VDOM 的效率足够高，但是在非常大的 VDOM Tree 的结构面前，DIFF 的成本就显得很重要。尽管各个框架针对 VDOM 使用了各种的优化手段，如 React 中基于链表的单向 DIFF、Vue 中基于数组的双向 DIFF、基于 key 和 type 比较的节点复用等，DIFF 的成本都是 VDOM 的速度瓶颈所在。\n\n下图是某个节点的全部属性，可见 DOM 是很 “重” 的。\n\n\n# 扩展\n\n\n# React 的详细目录结构和作用\n\npackages.\n├── create-subscription\n├── dom-event-testing-library\n├── eslint-plugin-react-hooks\n├── jest-mock-scheduler\n├── jest-react\n├── react // 核心 API\n├── react-art // 平台相关，用于 canvas, svg\n├── react-cache\n├── react-client\n├── react-debug-tools\n\x3c!-- devtools 相关 --\x3e\n├── react-devtools\n├── react-devtools-core\n├── react-devtools-extensions\n├── react-devtools-inline\n├── react-devtools-shared\n├── react-devtools-shell\n├── react-devtools-timeline\n├── react-dom // 平台相关，用于 web 环境\n├── react-fetch\n├── react-fs\n├── react-interactions\n├── react-is\n├── react-native-renderer // 平台相关，用于 ReactNative\n├── react-noop-renderer\n├── react-pg\n├── react-reconciler // 调和器相关\n├── react-refresh\n\x3c!-- SSR 相关 --\x3e\n├── react-server\n├── react-server-dom-relay\n├── react-server-dom-webpack\n├── react-server-native-relay\n├── react-suspense-test-utils\n├── react-test-renderer\n├── scheduler // 调度器相关\n├── shared\n├── use-subscription\n└── use-sync-external-store\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 为什么 React 17 之前需要显式引入 React，17 版本就不需要了呢？\n\n在上面 JSX 的编译过程中，我们可以看到到，JSX 实际上不是浏览器所能够识别的，需要 babel、或者 TS 等工具来进行解析，那么解析之后的结果当然就是带着渲染函数语法糖的 JS 代码，所以如果没引入 React，通常会报 ReferenceError： React is not defined 的错误。\n\n在 React17 中官方与 babel 合作，引入了全新的的 JSX 的转化。\n\n> React 17 在 React 的 package 中引入了两个新入口，这些入口只会被 Babel 和 TypeScript 等编译器使用。新的 JSX 转换不会将 JSX 转换为 React.createElement，而是自动从 React 的 package 中引入新的入口函数并调用。【参考：React 官网：介绍全新的 JSX 转换】\n\n这里将渲染函数与 React 框架进行了解耦，由编译工具从 React 中引入渲染函数，完成编译 JSX 的目标。\n\n// 由编译器引入（禁止自己引入！）\nimport {jsx as _jsx} from \'react/jsx-runtime\';\n\nfunction App() {\n  return _jsx(\'h1\', { children: \'Hello world\' });\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n编译 JSX 的工具会自动引入渲染函数 jsx ，我们不在需要自己引入。\n\n\n# React 中的 VDOM 是 ReactElement 吗？\n\n个人认为，ReactElement 只是 React 中 VDOM 的一部分，另外一部分是后面要展开的 Fiber。React 依赖 Fiber 来达到异步可中断的 concurrent 模式更新的目标，同时依赖 ReactDOM 来描述组件 UI 的状态。\n\nVDOM 本质上是 DOM 元素的 JavaScript 抽象和描述。ReactElement 描述了 DOM 的静态类型、属性和结构，Fiber 则在此基础上描述组件的渲染状态、更新链表、针对 DOM 的 Effect Tag、调度更新的优先级等。\n\n\n# _owner 是如何连接 ReactElement 和 Fiber 的？_owner 有什么作用？\n\n由上面的分析可以看出，_owner 的赋值其实是 ReactCurrentOwner.current 的值，对 ReactCurrentOwner.current 的赋值可以追到 finishClassComponent 函数中：\n\n// src/react/packages/react-reconciler/src/ReactFiberBeginWork.new.js\nReactCurrentOwner.current = workInProgress;\n\n\n1\n2\n\n\n而 finishClassComponent 主要在 updateClassComponent 、 mountIncompleteClassComponent 和 mountIndeterminateComponent 中 ClassComponent 的部分中调用，可见 _owner 实际上是用于类组件的。继续追 workInProgress，发现 workInProgress 是在 performUnitOfWork 函数中赋值的：\n\nfunction performUnitOfWork(unitOfWork: Fiber): void {\n  let next;\n  next = beginWork(current, unitOfWork, subtreeRenderLanes);\n\n  if (next === null) {\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n\n  ReactCurrentOwner.current = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这个函数将在调和器的部分详细讲，现在可以清楚的是 workInProgress 表示当前调和器正在处理的 Fiber，在渲染类组件时将 workInProgress 记录到 React 内部共享变量 ReactCurrentOwner.current 中，此时 createElement 时就能够获取到当前 ReactElement 所属的 Fiber 了。\n\n_owner 的作用：\n\n 1. 通过 element._owner 查询到 element 所属的 Fiber 和 组件。\n\n例如，在检查 element.children 的子元素是否具有 key 值的 validateExplicitKey 函数中有如下代码：\n\nif (\n    element &&\n    element._owner &&\n    element._owner !== ReactCurrentOwner.current\n  ) {\n    // 获取此元素所属的组件的名称\n    childOwner = ` It was passed a child from ${getComponentNameFromType(\n      element._owner.type,\n    )}.`;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 问题\n\n\n# VDOM Tree 和 Fiber Tree 是如何连接的？\n\nFiber 中有一个属性 stateNode 存储当前 Fiber 所对应的组件的渲染模板，执行这个模板就可以得到 VDOM Tree。后文详述。\n\n下面以首次渲染过程为例说明两者之间的关系：\n\n 1. JSX 组件将会编译为带渲染函数的 js 模板（渲染模板）；\n 2. 调用 ReactDOM.render 创建 FiberRoot 和 HostRootFiber，并生成首次更新的同步任务，同步任务立即执行；\n 3. 渲染任务被回调，开始渲染，调和 FiberTree，挂载（更新）组件树；\n 4. 在挂载（更新）组件时执行渲染模板，createElement 在运行时被层层调用，生成 ReactElement Tree，也就是 VDOM Tree；\n 5. VDOM Tree 转化为 DOM Tree，渲染节点到屏幕。\n 6. 新的渲染任务被回调时，回到 3。\n\n\n# 为什么用 className?\n\n参考：为什么 Vue 的 JSX 中的 class 属性用了 class，而 React 却用了 className？\n\n\n# ReactElement Tree、Fiber Tree 和 DOM Tree 的关系？\n\n\n# 总结\n\n本文主要讲解 React Element 与基础概念，总结重点如下：\n\n * 阅读 React 源码的原因、方法和意义。\n * React 中源码的目录结构和核心包的作用。\n * React API 的概况。\n * JSX 的解析原理。\n * ReactElement 创建过程，以及各个属性的含义。\n * VDOM 的概念和优缺点。',normalizedContent:'# 目录\n\n\n\n * 目录\n   * 学习目标\n * 源码结构\n * react api 概况\n * jsx\n   * 介绍\n   * 为什么使用 jsx？\n   * jsx 如何 解析为 js？\n * reactelement\n   * createelement\n * isvalidelement\n * vdom\n * 扩展\n   * react 的详细目录结构和作用\n   * 为什么 react 17 之前需要显式引入 react，17 版本就不需要了呢？\n   * react 中的 vdom 是 reactelement 吗？\n   * owner 是如何连接 reactelement 和 fiber 的？owner 有什么作用？\n * 问题\n   * vdom tree 和 fiber tree 是如何连接的？\n   * 为什么用 classname?\n   * reactelement tree、fiber tree 和 dom tree 的关系？\n * 总结\n\n\n\n\n# 学习目标\n\n * 学习 react 的整体目录结构、api 概况、核心包的作用。\n * 学习 jsx、reactelement、vdom 等概念，了解 jsx 的解析原理。\n * 了解 react 选择 jsx 和 vdom 的原因。\n\n\n# 源码结构\n\n熟悉 react 的小伙伴可能都知道，react 大致上可以分成调和器、调度器、渲染器几个部分。对应到 react 的源码里，最重要的就是有四个包，分别是 react、react-dom、scheduler、react-reconciler。克隆下源码，大概像是这样：\n\n上述几个包的核心作用：\n\n * react：导出 react 的核心 api，供外部应用使用。比如 fragment、forwardref、memo、hook 全家桶等。\n * react-dom：react 基于 web 的渲染层，导出一些渲染相关的 api，比如说 render、createportal、createroot 等。\n * scheduler：react 中的调度器，负责任务队列的维护，基于优先级调度任务。\n * react-reconciler：react 中的调和器，负责 react 渲染的整体流程，包括 fibertree 的调和等，与调度器配合完成更新任务的包装与调度、捕获与冒泡过程、diff 算法、effecttag list 的维护、维护 fibertree 双缓存结构、组件生命周期的调用、配合渲染器完成 dom 渲染等。\n\n\n# react api 概况\n\n在 react 包中 react.js 文件中对 react 有如下定义，通过这个定义，我们可以对 react 的核心 api 初步认识。\n\nconst react = {\n  // 提供了用于处理 children 不透明数据结构的实用方法。\n  // 操作 reactchildren 的方法。reactchildren不是数组。这里模拟数组的一些方法。\n  children: { \n    map,\n    foreach,\n    count,\n    toarray,\n    only,\n  },\n  // 创建一个能够通过 ref 属性附加到 react 元素的 ref。\n  createref, \n  // 定义类组件需集成自 component\n  component,\n  // purecomponent 以浅层对比 prop 和 state 的方式来实现 shouldcomponentupdate 函数。\n  purecomponent, \n  // 创建一个 context 对象。当组件订阅了这个 context 对象，组件会从组件树中离自身最近的那个匹配的 provider 中读取到当前的 context 值。\n  createcontext,\n  // forwardref 会创建一个react组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。\n  forwardref, \n  // lazy 函数能让你像渲染常规组件一样处理动态引入（的组件）。\n  lazy, \n  // memo 检查 props 变更，以此通过记忆组件渲染结果的方式来提高组件的性能表现。\n  memo,\n  // hook api\n  // 返回一个 memoized 回调函数。\n  usecallback,\n  // 接收一个 context 对象，并返回距离 <mycontext.provider> 最近的 context 的当前值。\n  usecontext,\n  // 接收一个包含命令式、且可能有副作用代码的函数完成副作用操作。react 的纯函数式世界通往命令式世界的逃生通道\n  useeffect,\n  // 在使用 ref 时自定义暴露给父组件的实例值。\n  useimperativehandle,\n  // 可用于在 react 开发者工具中显示自定义 hook 的标签。\n  usedebugvalue,\n  // 所有的 dom 变更之后同步调用 effect。可以使用它来读取 dom 布局并同步触发重渲染。在浏览器执行绘制之前，uselayouteffect 内部的更新计划将被同步刷新。\n  uselayouteffect,\n  // 返回一个 memoized 值。\n  usememo,\n  // usestate 的替代方案。它接收一个 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。\n  usereducer,\n  // useref 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数，返回的 ref 对象在组件的整个生命周期内持续存在。\n  useref,\n  // 返回一个 state，以及更新 state 的函数。\n  usestate,\n  // fragments 允许你将子列表分组，而无需向 dom 添加额外节点。\n  fragment: react_fragment_type,\n  // profiler 测量一个 react 应用多久渲染一次以及渲染一次的“代价”。\n  profiler: react_profiler_type,\n  // strictmode 是一个用来突出显示应用程序中潜在问题的工具。\n  strictmode: react_strict_mode_type, \n  // suspense 可以指定加载指示器，以防其组件树中的某些子组件尚未具备渲染条件。\n  suspense: react_suspense_type, // 与lazy结合使用，指定一个feedback。\n  // 创建并返回指定类型的新 react 元素。\n  createelement: __dev__ ? createelementwithvalidation : createelement,\n  // 以 element 元素为样板克隆并返回新的 react 元素。\n  cloneelement: __dev__ ? cloneelementwithvalidation : cloneelement,\n  // 验证对象是否为 react 元素\n  isvalidelement: isvalidelement,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n其中比较重要的大致为：\n\n * 元素相关：children、createelement、cloneelement。\n * 组件相关：component、purecomponent、createref、fragment、forwardref\n * hooks api: usecallback,usecontext,useeffect,useimperativehandle,usedebugvalue,uselayouteffect,usememo,usereducer,useref,usestate。\n * 优化相关：lazy、memo、suspense。\n * 其他：createcontext。\n\n\n# jsx\n\n\n# 介绍\n\n什么是 jsx？\n\n> jsx (javascript syntax extension，javascript 语法扩展) 是 javascript 语法的扩展，最初用于 react，它提供一种类似于 html 的语法来 结构化的编写组件。【来自 jsx】\n\n文档\n\njsx 可以生成 react “元素”，可以很好地描述 ui 应该呈现出它应有交互的本质形式，具有 javascript 的全部功能。\n\nreact 开发者对于 jsx 应该是很熟悉了，更专业一点来说：\n\n * jsx 是一种将 js 和 html 混合编写组件的语法糖，其语法需要通过 babel 解析之后才能被浏览器识别。\n * jsx 语法可以通过 @babel/plugin-transform-react-jsx-source 插件进行解析。\n\n\n# 为什么使用 jsx？\n\n关于 jsx 更详细的内容，react 官方文档中 jsx 简介 已经讲的很清楚了，此处不再赘述。但是我想浅谈一下我对 react 选择 jsx 背后的哲学原因的理解。\n\n> react 认为渲染逻辑本质上与其他 ui 逻辑内在耦合。\n> \n> react 并没有采用将标记与逻辑进行分离到不同文件这种人为地分离方式，而是通过将二者共同存放在称之为 “组件” 的松散耦合单元之中，来实现关注点分离。【来自 react 官方文档：为什么使用 jsx？】\n\n * 渲染逻辑与 ui 逻辑耦合 是 react、vue 等框架流行带来的组件化理念的必然结果。组件化要求我们将样式（ui 逻辑）与行为（渲染逻辑）封装到组件中已达到代码复用之目的，这也是组件化开发带来的最大的红利。\n * 将标记与逻辑进行分离到不同文件 这种思维方式在框架诞生之前编写原生 js 时最常用的代码分离的手段，当然框架的组件化驱动的理念促使这种做法被放弃，取而代之的有如下的两种常见的新的理念，这两种理念都达到了 将二者共同存放在称之为“组件”的松散耦合单元之中，来实现关注点分离 的目的。\n   * jsx：以 react.js、solid.js 框架为代表。将 html 和 javascript 混合编写组件。\n   * sfc：以 vue.js 和 svelte.js 框架为代表。单文件组件将组件分为 template 、 style 和 script 三个部分。\n\n\n# jsx 如何 解析为 js？\n\n让我们使用 babel-transform-react-jsx 对如下的代码进行转换：\n\nconst work = () => {dosomething();}\nconst conponent = () => {\n return (\n    <div style={{color: \'#ffffff\'}}>\n      <h1 class="title">heading</h1>\n      <div class="body" onclick={work}>content</div>\n    </div>\n    )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n转换结果如下：\n\nconst work = () => {\n  dosomething();\n};\n\nconst conponent = () => {\n  return /*#__pure__*/ react.createelement(\n    "div",\n    {\n      style: {\n        color: "#ffffff"\n      }\n    },\n    /*#__pure__*/ react.createelement(\n      "h1",\n      {\n        class: "title"\n      },\n      "heading"\n    ),\n    /*#__pure__*/ react.createelement(\n      "div",\n      {\n        class: "body",\n        onclick: work\n      },\n      "content"\n    )\n  );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n分析上面的解析过程可知：\n\n * babel 插件在解析 jsx 代码时，js 部分是不需要解析的，html 部分会被解析为 react.createelement 语法。\n * react.createelement 会被加上 /*#__pure__*/ 的静态内容标记。\n * 多个子节点并不是通过数组传入而是以多个参数的形式传入的，这个可以通过 rest 运算符处理。\n\njsx 会将代码中 html 转化为渲染函数（如 vue 中的 h 函数、createelement 函数）的语法糖，以方便框架对 jsx 的内容进行处理。这实际上使得 jsx 语法与框架解耦，使 jsx 能够运用到各种实现了渲染函数的框架之中。\n\n\n# reactelement\n\n下面将介绍 reactelement 以及 vdom 的概念。\n\n\n# createelement\n\ncreateelement 创建 react 元素（reactelement）。先来看一个例子，假如一个经过 babel 解析过的 jsx 代码如下：\n\nreact.createelement("div", {\n    class: "class_name",\n    id: "id_name",\n    key: "key_name",\n    ref: "ref_name"\n}, react.createelement("span", null, "tom"), react.createelement("span", null, "jerry"));\n\n\n1\n2\n3\n4\n5\n6\n\n\n以上的执行结果如下：\n\n{\n    $$typeof: react_element_type,\n    type：\'div\'，\n    key: \'key_name\',\n    ref: "ref_name",\n    props: {\n        class: "class_name",\n        id: "id_name",\n        children: [\n            react.createelement("span", null, "tom"),\n            react.createelement("span", null, "jerry")\n        ]\n    }\n     _owner: reactcurrentowner.current,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这便是 reactelement 的真面目了。react 是基于 vdom 的运行时框架，其内部节点的创建、更新、patch、删除都是通过 vdom 来实现的。\n\n我们通常熟知的 vdom 节点，包括 type、attr、children 三个元素，那么我们再来看 reactelement 的特征，reactelement 对象也包含了这三个属性，只不过 attr 和 children 是放在 props 中的，我们知道 react 组件的设计哲学是 组件是依赖 props 和 state更新，props 关注组件与外部的状态，state 关注组件内部的状态 ，这一点也是符合理念的。\n\n下面的内容我们将从源码的角度继续探究：\n\ncreateelement 的源码：\n\n// src/react/packages/react/src/reactelement.js\n// 根据元素类型 type，元素属性 config 和元素子节点（数组） children 创建 react 元素\nexport function createelement(type, config, children) {\n  let propname;\n  const props = {};\n\n  let key = null;\n  let ref = null;\n  let self = null;\n  let source = null;\n\n  if (config != null) {\n    // 检查是否添加了 ref 属性\n    if (hasvalidref(config)) {\n      ref = config.ref;\n    }\n    // 检查是否添加了 key 属性\n    if (hasvalidkey(config)) {\n      key = \'\' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // 添加至属性对象\n    for (propname in config) {\n      if (\n        hasownproperty.call(config, propname) &&\n        !reserved_props.hasownproperty(propname)\n      ) {\n        props[propname] = config[propname];\n      }\n    }\n  }\n  // 计算 children 的长度，children 是作为剩余参数传入的\n  const childrenlength = arguments.length - 2;\n  if (childrenlength === 1) {\n    // 单一子节点直接赋值\n    // children 是放到 props 上的，因此可以通过 props 的 children 获得组件内部内容\n    props.children = children;\n  } else if (childrenlength > 1) {\n    const childarray = array(childrenlength);\n    for (let i = 0; i < childrenlength; i++) {\n      childarray[i] = arguments[i + 2];\n    }\n    // 多个子节点转为数组\n    props.children = childarray;\n  }\n\n  // 元素默认的属性\n  if (type && type.defaultprops) {\n    const defaultprops = type.defaultprops;\n    for (propname in defaultprops) {\n      if (props[propname] === undefined) {\n        props[propname] = defaultprops[propname];\n      }\n    }\n  }\n  // 调用工厂函数创建 reactelement。\n  return reactelement(\n    type,\n    key,\n    ref,\n    self,\n    source,\n    reactcurrentowner.current,\n    props,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n如上函数具有如下的核心功能：\n\n * 计算 key、ref、self、source 属性。\n * 计算 props，包括 configs 中除 reserved_props 之外的属性、children 属性、当前类型的 reactelement 所应该具有的默认属性 (如 \'div\' 元素的默认属性)。\n * 调用 reactelement 创建 reactelement。\n\n下面我们接着看下 reactelement 工厂函数，这对于我们了解 react 虚拟 dom 的结构至关重要:\n\nconst reactelement = function (type, key, ref, self, source, owner, props) {\n  // 新建一个reactelement对象\n  const element = {\n    // reactelement 的独一无二的标志，用来判断 element 是否是 reactelement。\n    $$typeof: react_element_type,\n    // element 的类型\n    type: type,\n    // element 的 key 值，这对 react 复用元素很重要\n    key: key,\n    // element 的 ref 属性，元素的引用\n    ref: ref,\n    // element 的属性，包括了 children、class、id 等\n    props: props,\n    // element 的属主，当前元素所属于的 fiber，由哪一个 fiber 所创建。\n    _owner: owner,\n  };\n\n  return element;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * $$typeof ：reactelement 的独一无二的标志，用来判断 element 是否是 reactelement， react_element_type = symbolfor(\'react.element\') 。\n * type：element 的类型，注意如 \'div\'、\'span\' 等。\n * key：element 的 key 值，这对 react 复用元素很重要。\n * ref:：element 的 ref 属性，元素的引用。\n * props：element 的属性，包括了 children、class、id 等。\n * _owner：element 的属主，当前元素所属于的 fiber，由哪一个 fiber 所创建。\n\n\n# isvalidelement\n\nisvalidelement 判断 element 是否是合法的 reactelement。\n\nexport function isvalidelement(object) {\n  return (\n    typeof object === \'object\' &&\n    object !== null &&\n    // $$typeof: symbol(react.element)\n    object.$$typeof === react_element_type \n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# vdom\n\nvdom 是对 dom（document object model）的一种轻量级的 javascript 呈现方式，多用于 react、vue 等声明式的前端框架中。使用 vdom 有如下的优点：\n\n * 轻量级。vdom 只需要记录很少的信息就能展示 dom 呈现方式和结构。\n * 速度更快。vdom 能够对连续更新做批量处理，减少 reflow 和 repaint。\n * 抽象层，跨平台。vdom 在 dom tree 的基础上抽象出 vdom tree，vdom tree 是一种数据结构，不依赖于平台特性。这使得核心逻辑能够运行在不同的平台上，屏蔽掉平台的兼容性。\n * 可控制，可优化。因为 vdom 足够简单，javascript 能够很方便的操纵和控制 ui 展现，如删除、增加、更新、移动节点等。同时，对于页面状态的更新有了更加可控的优化手段，如 diff 算法、节点复用。\n\n当然 vdom 也存在一些问题：\n\n * 初始化的时间成本。初始化时需要将 ui 的展现转化为具体的 vdom tree，这部分的转换需要一定的时间成本。\n * diff 算法的成本。尽管 javascript 操作 vdom 的效率足够高，但是在非常大的 vdom tree 的结构面前，diff 的成本就显得很重要。尽管各个框架针对 vdom 使用了各种的优化手段，如 react 中基于链表的单向 diff、vue 中基于数组的双向 diff、基于 key 和 type 比较的节点复用等，diff 的成本都是 vdom 的速度瓶颈所在。\n\n下图是某个节点的全部属性，可见 dom 是很 “重” 的。\n\n\n# 扩展\n\n\n# react 的详细目录结构和作用\n\npackages.\n├── create-subscription\n├── dom-event-testing-library\n├── eslint-plugin-react-hooks\n├── jest-mock-scheduler\n├── jest-react\n├── react // 核心 api\n├── react-art // 平台相关，用于 canvas, svg\n├── react-cache\n├── react-client\n├── react-debug-tools\n\x3c!-- devtools 相关 --\x3e\n├── react-devtools\n├── react-devtools-core\n├── react-devtools-extensions\n├── react-devtools-inline\n├── react-devtools-shared\n├── react-devtools-shell\n├── react-devtools-timeline\n├── react-dom // 平台相关，用于 web 环境\n├── react-fetch\n├── react-fs\n├── react-interactions\n├── react-is\n├── react-native-renderer // 平台相关，用于 reactnative\n├── react-noop-renderer\n├── react-pg\n├── react-reconciler // 调和器相关\n├── react-refresh\n\x3c!-- ssr 相关 --\x3e\n├── react-server\n├── react-server-dom-relay\n├── react-server-dom-webpack\n├── react-server-native-relay\n├── react-suspense-test-utils\n├── react-test-renderer\n├── scheduler // 调度器相关\n├── shared\n├── use-subscription\n└── use-sync-external-store\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 为什么 react 17 之前需要显式引入 react，17 版本就不需要了呢？\n\n在上面 jsx 的编译过程中，我们可以看到到，jsx 实际上不是浏览器所能够识别的，需要 babel、或者 ts 等工具来进行解析，那么解析之后的结果当然就是带着渲染函数语法糖的 js 代码，所以如果没引入 react，通常会报 referenceerror： react is not defined 的错误。\n\n在 react17 中官方与 babel 合作，引入了全新的的 jsx 的转化。\n\n> react 17 在 react 的 package 中引入了两个新入口，这些入口只会被 babel 和 typescript 等编译器使用。新的 jsx 转换不会将 jsx 转换为 react.createelement，而是自动从 react 的 package 中引入新的入口函数并调用。【参考：react 官网：介绍全新的 jsx 转换】\n\n这里将渲染函数与 react 框架进行了解耦，由编译工具从 react 中引入渲染函数，完成编译 jsx 的目标。\n\n// 由编译器引入（禁止自己引入！）\nimport {jsx as _jsx} from \'react/jsx-runtime\';\n\nfunction app() {\n  return _jsx(\'h1\', { children: \'hello world\' });\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n编译 jsx 的工具会自动引入渲染函数 jsx ，我们不在需要自己引入。\n\n\n# react 中的 vdom 是 reactelement 吗？\n\n个人认为，reactelement 只是 react 中 vdom 的一部分，另外一部分是后面要展开的 fiber。react 依赖 fiber 来达到异步可中断的 concurrent 模式更新的目标，同时依赖 reactdom 来描述组件 ui 的状态。\n\nvdom 本质上是 dom 元素的 javascript 抽象和描述。reactelement 描述了 dom 的静态类型、属性和结构，fiber 则在此基础上描述组件的渲染状态、更新链表、针对 dom 的 effect tag、调度更新的优先级等。\n\n\n# _owner 是如何连接 reactelement 和 fiber 的？_owner 有什么作用？\n\n由上面的分析可以看出，_owner 的赋值其实是 reactcurrentowner.current 的值，对 reactcurrentowner.current 的赋值可以追到 finishclasscomponent 函数中：\n\n// src/react/packages/react-reconciler/src/reactfiberbeginwork.new.js\nreactcurrentowner.current = workinprogress;\n\n\n1\n2\n\n\n而 finishclasscomponent 主要在 updateclasscomponent 、 mountincompleteclasscomponent 和 mountindeterminatecomponent 中 classcomponent 的部分中调用，可见 _owner 实际上是用于类组件的。继续追 workinprogress，发现 workinprogress 是在 performunitofwork 函数中赋值的：\n\nfunction performunitofwork(unitofwork: fiber): void {\n  let next;\n  next = beginwork(current, unitofwork, subtreerenderlanes);\n\n  if (next === null) {\n    completeunitofwork(unitofwork);\n  } else {\n    workinprogress = next;\n  }\n\n  reactcurrentowner.current = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这个函数将在调和器的部分详细讲，现在可以清楚的是 workinprogress 表示当前调和器正在处理的 fiber，在渲染类组件时将 workinprogress 记录到 react 内部共享变量 reactcurrentowner.current 中，此时 createelement 时就能够获取到当前 reactelement 所属的 fiber 了。\n\n_owner 的作用：\n\n 1. 通过 element._owner 查询到 element 所属的 fiber 和 组件。\n\n例如，在检查 element.children 的子元素是否具有 key 值的 validateexplicitkey 函数中有如下代码：\n\nif (\n    element &&\n    element._owner &&\n    element._owner !== reactcurrentowner.current\n  ) {\n    // 获取此元素所属的组件的名称\n    childowner = ` it was passed a child from ${getcomponentnamefromtype(\n      element._owner.type,\n    )}.`;\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 问题\n\n\n# vdom tree 和 fiber tree 是如何连接的？\n\nfiber 中有一个属性 statenode 存储当前 fiber 所对应的组件的渲染模板，执行这个模板就可以得到 vdom tree。后文详述。\n\n下面以首次渲染过程为例说明两者之间的关系：\n\n 1. jsx 组件将会编译为带渲染函数的 js 模板（渲染模板）；\n 2. 调用 reactdom.render 创建 fiberroot 和 hostrootfiber，并生成首次更新的同步任务，同步任务立即执行；\n 3. 渲染任务被回调，开始渲染，调和 fibertree，挂载（更新）组件树；\n 4. 在挂载（更新）组件时执行渲染模板，createelement 在运行时被层层调用，生成 reactelement tree，也就是 vdom tree；\n 5. vdom tree 转化为 dom tree，渲染节点到屏幕。\n 6. 新的渲染任务被回调时，回到 3。\n\n\n# 为什么用 classname?\n\n参考：为什么 vue 的 jsx 中的 class 属性用了 class，而 react 却用了 classname？\n\n\n# reactelement tree、fiber tree 和 dom tree 的关系？\n\n\n# 总结\n\n本文主要讲解 react element 与基础概念，总结重点如下：\n\n * 阅读 react 源码的原因、方法和意义。\n * react 中源码的目录结构和核心包的作用。\n * react api 的概况。\n * jsx 的解析原理。\n * reactelement 创建过程，以及各个属性的含义。\n * vdom 的概念和优缺点。',charsets:{cjk:!0},lastUpdated:"2022/08/24, 18:21:13",lastUpdatedTimestamp:1661336473e3},{title:"React 源码漂流记：React 调和器核心源码解读（二）",frontmatter:{title:"React 源码漂流记：React 调和器核心源码解读（二）",date:"2022-04-14T22:02:21.000Z",permalink:"/react/tour/react-reconciliation-2/",categories:["react","React源码漂流记"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/100.react-reconciliation-2.html",relativePath:"10.react/90.React源码漂流记/100.react-reconciliation-2.md",key:"v-1e97eeff",path:"/react/tour/react-reconciliation-2/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:17},{level:2,title:"scheduleSyncCallback",slug:"schedulesynccallback",normalizedTitle:"schedulesynccallback",charIndex:23},{level:3,title:"flushSyncCallbacks",slug:"flushsynccallbacks",normalizedTitle:"flushsynccallbacks",charIndex:49},{level:2,title:"scheduleCallback",slug:"schedulecallback",normalizedTitle:"schedulecallback",charIndex:71},{level:2,title:"performSyncWorkOnRoot",slug:"performsyncworkonroot",normalizedTitle:"performsyncworkonroot",charIndex:91},{level:2,title:"performConcurrentWorkOnRoot",slug:"performconcurrentworkonroot",normalizedTitle:"performconcurrentworkonroot",charIndex:116},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:147},{level:3,title:"从 scheduleSyncCallback 看任务队列",slug:"从-schedulesynccallback-看任务队列",normalizedTitle:"从 schedulesynccallback 看任务队列",charIndex:155},{level:3,title:"宽松的错误处理机制",slug:"宽松的错误处理机制",normalizedTitle:"宽松的错误处理机制",charIndex:189},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:202},{level:3,title:"如何理解 performSyncWorkOnRoot 和 performConcurrentWorkOnRoot 两个函数在调和器中的位置和作用？",slug:"如何理解-performsyncworkonroot-和-performconcurrentworkonroot-两个函数在调和器中的位置和作用",normalizedTitle:"如何理解 performsyncworkonroot 和 performconcurrentworkonroot 两个函数在调和器中的位置和作用？",charIndex:210},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:287}],readingTime:{text:"5 min read",minutes:4.89,time:293400,words:978},headersStr:"目录 前言 scheduleSyncCallback flushSyncCallbacks scheduleCallback performSyncWorkOnRoot performConcurrentWorkOnRoot 扩展 从 scheduleSyncCallback 看任务队列 宽松的错误处理机制 问题 如何理解 performSyncWorkOnRoot 和 performConcurrentWorkOnRoot 两个函数在调和器中的位置和作用？ 总结",content:"# 目录\n\n\n\n * 目录\n * 前言\n * scheduleSyncCallback\n   * flushSyncCallbacks\n * scheduleCallback\n * performSyncWorkOnRoot\n * performConcurrentWorkOnRoot\n * 扩展\n   * 从 scheduleSyncCallback 看任务队列\n   * 宽松的错误处理机制\n * 问题\n   * 如何理解 performSyncWorkOnRoot 和 performConcurrentWorkOnRoot 两个函数在调和器中的位置和作用？\n * 总结\n\n\n\n\n# 前言\n\n在上一篇文章中，我们探讨了 updateContainer 、 scheduleUpdateOnFiber 和 ensureRootIsScheduled 三个核心函数的原理和作用。如果从整个渲染任务周期来看，主要涉及到生产首次渲染任务、任务在容器上的调度、任务基于调度器的分发几个过程。\n\n细心的同学可能已经发现，在 ensureRootIsScheduled 中已经涉及到调度器的内容了，即 scheduleCallback 向调度器发起的调度请求。但是基于分层阅读的原则，本篇文章将不会讲解调度器的内容，我们只需要了解到异步任务是在调度器在合适的时间时回调执行的即可。这样，本文将继续调和器的解读，探讨同步任务和异步任务的调度和 Batch 阶段向 Render 阶段的过渡的过程。\n\n----------------------------------------\n\n在上一篇文章中对 ensureRootIsScheduled 的分析中我们了解到，ensureRootIsScheduled 对同步任务和异步任务分别进行了同步调度和异步调度的分发，分别调用 scheduleSyncCallback 和 scheduleCallback 这两个函数。现在我们就来具体分析这两个函数：\n\n\n# scheduleSyncCallback\n\n同步调度和异步调度相比有两个明显的不同之处：\n\n 1. 同步调度一般不会经过调度器。\n 2. 同步调度在调度器之外维护同步任务队列。\n\n在下面的探讨中，我们会逐渐体会到这两点不同。\n\n// src/react/packages/react-reconciler/src/ReactFiberSyncTaskQueue.new.js\nexport function scheduleSyncCallback(callback: SchedulerCallback) {\n  // 如果任务队列未初始化则初始化队列，将当前的任务加入同步任务队列\n  if (syncQueue === null) {\n    syncQueue = [callback];\n  } else {\n    syncQueue.push(callback);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nscheduleSyncCallback 维护同步任务队列，在微任务的回调中执行 flushSyncCallbacks，此函数将全数消费同步任务队列。\n\n\n# flushSyncCallbacks\n\n此函数的主要作用是消费同步任务队列。\n\n// src/react/packages/react-reconciler/src/ReactFiberSyncTaskQueue.new.js\nexport function flushSyncCallbacks() {\n  // isFlushingSyncQueue 是 syncQueue 的互斥锁，消费 callbacks 是一个互斥操作\n  if (!isFlushingSyncQueue && syncQueue !== null) {\n    // 关闭互斥锁\n    isFlushingSyncQueue = true;\n    let i = 0;\n    const previousUpdatePriority = getCurrentUpdatePriority();\n    try {\n      const isSync = true;\n      const queue = syncQueue;\n      setCurrentUpdatePriority(DiscreteEventPriority);\n      // flush syncQueue，每个 callback 可以返回一个新的 callback\n      for (; i < queue.length; i++) {\n        let callback = queue[i];\n        do {\n          callback = callback(isSync);\n        } while (callback !== null);\n      }\n      // 重置 syncQueue\n      syncQueue = null;\n      includesLegacySyncCallbacks = false;\n    } catch (error) {\n      // If something throws, leave the remaining callbacks on the queue.\n      // 如果syncQueue 中某个 Callback 发生了错误，则跳过此项\n      if (syncQueue !== null) {\n        syncQueue = syncQueue.slice(i + 1);\n      }\n      // Resume flushing in the next tick\n      // 调度在下一个调度中继续执行\n      scheduleCallback(ImmediatePriority, flushSyncCallbacks);\n      throw error;\n    } finally {\n      setCurrentUpdatePriority(previousUpdatePriority);\n      isFlushingSyncQueue = false;\n    }\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n现在让我们回到上文所讲的同步任务相比于异步任务的区别，从宏观上上看，同步调度这样设计有如下的原因：\n\n 1. 同步调度优先级最高，具有充足的原因绕过调度器使任务尽快的得到执行。至于使用微任务或者宏任务和间接达到调度的目的，是为了减小消费同步任务队列时产生的执行代码的压力。同时，同步任务队列在每次执行同步任务时将任务全数消费，也能够间接看出这一点。\n 2. 同步调度具有较好的容错性，当某一个任务抛出了错误，程序会跳过错误的任务，并且在下一次 ImmediatePriority 优先级的异步调度中继续执行。\n\n\n# scheduleCallback\n\n这部分会与调度器交互，在 react 中，调度器是一个单独的模块，这里不再展开。现在需要知道的是，调度器会根据各种异步任务的优先级选择高优先级的任务进行回调，回调中执行 performSyncWorkOnRoot。\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nfunction scheduleCallback(priorityLevel, callback) {\n // In production, always call Scheduler. This function will be stripped out.\n return Scheduler_scheduleCallback(priorityLevel, callback);\n}\n\n\n1\n2\n3\n4\n5\n\n\n其中， Scheduler_scheduleCallback 是调度器提供的方法。\n\n\n# performSyncWorkOnRoot\n\n在上文的探讨中，我们知道了同步任务和异步任务是如何通过调度器进行回调来执行任务的，下面我们来看看具体同步任务是如何执行的。\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n// This is the entry point for synchronous tasks that don't go\n// through Scheduler\nfunction performSyncWorkOnRoot(root) {\n  // 如果当前是 Render 节点或者 Commit 阶段就报错，因为当前应该处于 Batch 阶段\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n  // ......\n  // 获取 FiberRoot 上下一次执行的 lanes\n  let lanes = getNextLanes(root, NoLanes);\n  // 如果 lanes 中没有同步的 lanes\n  if (!includesSomeLane(lanes, SyncLane)) {\n    // There's no remaining sync work left.\n    ensureRootIsScheduled(root, now());\n    return null;\n  }\n  // 同步渲染 FiberRoot，并且返回渲染结果 exitStatus\n  let exitStatus = renderRootSync(root, lanes);\n  // 如果发生了普通错误，即 RootErrored，获取重试的优先级，并同步重试渲染  50 次\n  // ......\n  // 如果发生了严重错误，即 RootFatalErrored，抛出错误，将 FiberRoot 标记为 suspend\n  // ......\n\n  // We now have a consistent tree. Because this is a sync render, we\n  // will commit it even if something suspended.\n  // 渲染完毕，标记 finishedWork 和 finishedLanes，并且 Commit 当前的 FiberRoot\n  const finishedWork: Fiber = (root.current.alternate: any);\n  root.finishedWork = finishedWork;\n  root.finishedLanes = lanes;\n  commitRoot(root);\n\n  // Before exiting, make sure there's a callback scheduled for the next\n  // pending level.\n  ensureRootIsScheduled(root, now());\n\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n这个函数的主要作用如下：\n\n * 调用 renderRootSync 在 FiberRoot 上进行渲染。根据返回的结果进行错误处理，根据错误的类型选择不同的错误处理策略。\n * 标记 finishedWork 和 finishedLanes 用于下次调度。\n * 调用 commitRoot 在 FiberRoot 上 Commit 此次渲染。\n * 调用 ensureRootIsScheduled 确保 FiberRoot 上下一次被调度。\n\n\n# performConcurrentWorkOnRoot\n\n同步任务和异步任务的回调，无外乎是要进行两个最为重要的任务，一个是 Render ，一个是 Commit 。同步任务回调思路较为清晰，这两个过程也都是同步完成的。下面我们来看看异步任务回调会是怎样的情况。\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  // ......\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  // ......\n\n  // Determine the next lanes to work on, using the fields stored\n  // on the root.\n  let lanes = getNextLanes(\n    root,\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\n  );\n  // ......\n\n  // We disable time-slicing in some cases: if the work has been CPU-bound\n  // for too long (\"expired\" work, to prevent starvation), or we're in\n  // sync-updates-by-default mode.\n  // 在某些情况下并不会采用时间切片，如不包含阻塞或者过时的任务，转而采用同步渲染\n  const shouldTimeSlice =\n    !includesBlockingLane(root, lanes) &&\n    !includesExpiredLane(root, lanes);\n  let exitStatus = shouldTimeSlice\n    ? renderRootConcurrent(root, lanes)\n    : renderRootSync(root, lanes);\n  if (exitStatus !== RootIncomplete) {\n    // ......\n    const finishedWork: Fiber = (root.current.alternate: any);\n    // We now have a consistent tree. The next step is either to commit it,\n    // or, if something suspended, wait to commit it after a timeout.\n    root.finishedWork = finishedWork;\n    root.finishedLanes = lanes;\n    finishConcurrentRender(root, exitStatus, lanes);\n  }\n  ensureRootIsScheduled(root, now());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n总体过程与同步回调类似，不同的是这里调用了 finishConcurrentRender 来单独处理 Commit 的部分。\n\n\n# 扩展\n\n\n# 从 scheduleSyncCallback 看任务队列\n\n同步任务队列是在调度器之外维护的一个简单的任务队列，下面我们来探讨一下这块的内容，可以为我们需要任务队列的场景做一些参考。\n\n一个简单的任务队列包含两个部分的功能，一个是入队列（生产者），一个是消费队列（消费者）。这种生成和消费的思想，在队列中极为常见。生产者对应 scheduleSyncCallback 函数，消费者则对应 flushSyncCallbacks 函数。通过 OOP 的思想，我们可以据此完成下面的原型：\n\nclass Queue{\n  private queue = [];\n  private lock = true;\n  \n  add(task) {\n    this.queue.push(task);\n  }\n\n  flush() {\n    if(!this.lock || !this.queue.length) return this;\n    this.lock = false;\n    const queue = this.queue;\n    let i = 0;\n    try {\n      // do tasks from the queue\n      for (; i < queue.length; i++) {\n        let task = queue[i];\n        do {\n          task = task();\n        } while (task !== null);\n      }\n      this.queue = [];\n    } catch (error) {\n      // process errors\n    } finally {\n       this.lock =  true;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n关于任务队列，这里有几个重点需要注意：\n\n * 消费锁：防止任务池被两个消费者同时消费造成资源争抢。\n * 使用任务快照：先获取任务快照再进行消费，消费期间生产的任务应该等到下次消费。\n * 这里有一个问题，消费完毕之后直接把队列清空，可能造成消费期间生产的任务被丢失。\n * 任务可以返回新任务，直到不在返回任务为止。\n * 任务是同步执行的，任务被执行的顺序是可以保证的。\n * 任务执行错误捕获和处理。\n\n\n# 宽松的错误处理机制\n\nreact 本身是一个 UI 库，用于线上环境的视图的渲染必须要具有较为宽松的容错机制。其实我们可以从 Render 过程的错误处理来看出这一点。\n\n以 renderRootSync 为例，上文中我们已知 renderRootSync 会返回 exitStatus 作为 Render 结果的执行状态。下面我们来探讨下这块的错误的处理机制（部分代码有简化）。\n\n// 同步渲染 FiberRoot，并且返回渲染结果 exitStatus\nlet exitStatus = renderRootSync(root, lanes);\n// 如果发生了普通错误，即 RootErrored\nif (exitStatus === RootErrored) {\n  // If something threw an error, try rendering one more time. We'll render\n  // synchronously to block concurrent data mutations, and we'll includes\n  // all pending updates are included. If it still fails after the second\n  // attempt, we'll give up and commit the resulting tree.\n  // 获取重试的优先级，并同步重试渲染  50 次\n  const errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n  if (errorRetryLanes !== NoLanes) {\n    lanes = errorRetryLanes;\n    exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n  }\n}\n// 如果发生了严重错误，即 RootFatalErrored，抛出错误，将 FiberRoot 标记为 suspend\nif (exitStatus === RootFatalErrored) {\n  const fatalError = workInProgressRootFatalError;\n  // 清理执行栈\n  prepareFreshStack(root, NoLanes);\n  markRootSuspended(root, lanes);\n  ensureRootIsScheduled(root, now());\n  throw fatalError;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n处理机制总结如下：\n\n * 普通错误：同步渲染重试最多 50 次，如果重试过程中遇到致命错误，由致命错误处理，否则放弃重试，并且提交 FiberTree。\n * 致命错误：清理执行栈，将 FiberRoot 标记为 suspended，并且抛出这个错误。\n\n可见只有遇到致命错误才会阻断程序执行。在后文中我们会详细探讨 exitStatus 的含义。\n\n\n# 问题\n\n\n# 如何理解 performSyncWorkOnRoot 和 performConcurrentWorkOnRoot 两个函数在调和器中的位置和作用？\n\n * 从整体上看，这两个函数是作为同步任务或者异步任务的任务本身（内容）而存在的，也就是说，所谓调度的最终目标（也就是调度器的回调），就是要执行预设的任务。而这两个函数，正是任务本身，也是从 Batch 阶段向 Render 阶段再向 Commit 阶段过渡的入口。我们可能也注意到源码对于这两个函数的注释:\n\n// This is the entry point for synchronous tasks that don't go\n// through Scheduler\nfunction performSyncWorkOnRoot() {}\n// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\nfunction performConcurrentWorkOnRoot() {}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这里作为同步任务或者异步任务的 entry point 体现的正是如此。\n\n * 从整体函数结构上看，这两个函数的结构高度的类似，这是因为此二者是针对同步任务和异步任务的后续处理过程的高度抽象。这是两个提纲挈领的、高度抽象的函数，而后续的同步渲染和异步任务也就此展开。\n\n\n# 总结\n\n通过本篇文章的探讨，有如下的重点内容需要关注：\n\n * 调度是 React 中为达到 基于优先级调度任务 的目的的一个技巧，在 React 的调度中，有两处任务的调度，一处是用于处理同步任务的简单的任务队列，一处是用于处理异步任务的较为复杂的调度器。\n * 调度的目的是执行任务，在执行的任务中，最重要的就是要完成后续的 Render 过程和 Commit 过程。本文虽然只有四个函数，却分别对应了同步任务和异步任务的调度和回调任务的核心过程。对于核心函数的理解，要从函数在整体中所出的位置和所发挥的作用来理解，也要从核心的逻辑内容来理解。\n * performWork 是执行回调的任务，而这个过程也是从 FiberRoot 上进行。可见， FiberRoot 对于 FiberTree 的整体的结构至关重要。",normalizedContent:"# 目录\n\n\n\n * 目录\n * 前言\n * schedulesynccallback\n   * flushsynccallbacks\n * schedulecallback\n * performsyncworkonroot\n * performconcurrentworkonroot\n * 扩展\n   * 从 schedulesynccallback 看任务队列\n   * 宽松的错误处理机制\n * 问题\n   * 如何理解 performsyncworkonroot 和 performconcurrentworkonroot 两个函数在调和器中的位置和作用？\n * 总结\n\n\n\n\n# 前言\n\n在上一篇文章中，我们探讨了 updatecontainer 、 scheduleupdateonfiber 和 ensurerootisscheduled 三个核心函数的原理和作用。如果从整个渲染任务周期来看，主要涉及到生产首次渲染任务、任务在容器上的调度、任务基于调度器的分发几个过程。\n\n细心的同学可能已经发现，在 ensurerootisscheduled 中已经涉及到调度器的内容了，即 schedulecallback 向调度器发起的调度请求。但是基于分层阅读的原则，本篇文章将不会讲解调度器的内容，我们只需要了解到异步任务是在调度器在合适的时间时回调执行的即可。这样，本文将继续调和器的解读，探讨同步任务和异步任务的调度和 batch 阶段向 render 阶段的过渡的过程。\n\n----------------------------------------\n\n在上一篇文章中对 ensurerootisscheduled 的分析中我们了解到，ensurerootisscheduled 对同步任务和异步任务分别进行了同步调度和异步调度的分发，分别调用 schedulesynccallback 和 schedulecallback 这两个函数。现在我们就来具体分析这两个函数：\n\n\n# schedulesynccallback\n\n同步调度和异步调度相比有两个明显的不同之处：\n\n 1. 同步调度一般不会经过调度器。\n 2. 同步调度在调度器之外维护同步任务队列。\n\n在下面的探讨中，我们会逐渐体会到这两点不同。\n\n// src/react/packages/react-reconciler/src/reactfibersynctaskqueue.new.js\nexport function schedulesynccallback(callback: schedulercallback) {\n  // 如果任务队列未初始化则初始化队列，将当前的任务加入同步任务队列\n  if (syncqueue === null) {\n    syncqueue = [callback];\n  } else {\n    syncqueue.push(callback);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nschedulesynccallback 维护同步任务队列，在微任务的回调中执行 flushsynccallbacks，此函数将全数消费同步任务队列。\n\n\n# flushsynccallbacks\n\n此函数的主要作用是消费同步任务队列。\n\n// src/react/packages/react-reconciler/src/reactfibersynctaskqueue.new.js\nexport function flushsynccallbacks() {\n  // isflushingsyncqueue 是 syncqueue 的互斥锁，消费 callbacks 是一个互斥操作\n  if (!isflushingsyncqueue && syncqueue !== null) {\n    // 关闭互斥锁\n    isflushingsyncqueue = true;\n    let i = 0;\n    const previousupdatepriority = getcurrentupdatepriority();\n    try {\n      const issync = true;\n      const queue = syncqueue;\n      setcurrentupdatepriority(discreteeventpriority);\n      // flush syncqueue，每个 callback 可以返回一个新的 callback\n      for (; i < queue.length; i++) {\n        let callback = queue[i];\n        do {\n          callback = callback(issync);\n        } while (callback !== null);\n      }\n      // 重置 syncqueue\n      syncqueue = null;\n      includeslegacysynccallbacks = false;\n    } catch (error) {\n      // if something throws, leave the remaining callbacks on the queue.\n      // 如果syncqueue 中某个 callback 发生了错误，则跳过此项\n      if (syncqueue !== null) {\n        syncqueue = syncqueue.slice(i + 1);\n      }\n      // resume flushing in the next tick\n      // 调度在下一个调度中继续执行\n      schedulecallback(immediatepriority, flushsynccallbacks);\n      throw error;\n    } finally {\n      setcurrentupdatepriority(previousupdatepriority);\n      isflushingsyncqueue = false;\n    }\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n现在让我们回到上文所讲的同步任务相比于异步任务的区别，从宏观上上看，同步调度这样设计有如下的原因：\n\n 1. 同步调度优先级最高，具有充足的原因绕过调度器使任务尽快的得到执行。至于使用微任务或者宏任务和间接达到调度的目的，是为了减小消费同步任务队列时产生的执行代码的压力。同时，同步任务队列在每次执行同步任务时将任务全数消费，也能够间接看出这一点。\n 2. 同步调度具有较好的容错性，当某一个任务抛出了错误，程序会跳过错误的任务，并且在下一次 immediatepriority 优先级的异步调度中继续执行。\n\n\n# schedulecallback\n\n这部分会与调度器交互，在 react 中，调度器是一个单独的模块，这里不再展开。现在需要知道的是，调度器会根据各种异步任务的优先级选择高优先级的任务进行回调，回调中执行 performsyncworkonroot。\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nfunction schedulecallback(prioritylevel, callback) {\n // in production, always call scheduler. this function will be stripped out.\n return scheduler_schedulecallback(prioritylevel, callback);\n}\n\n\n1\n2\n3\n4\n5\n\n\n其中， scheduler_schedulecallback 是调度器提供的方法。\n\n\n# performsyncworkonroot\n\n在上文的探讨中，我们知道了同步任务和异步任务是如何通过调度器进行回调来执行任务的，下面我们来看看具体同步任务是如何执行的。\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n// this is the entry point for synchronous tasks that don't go\n// through scheduler\nfunction performsyncworkonroot(root) {\n  // 如果当前是 render 节点或者 commit 阶段就报错，因为当前应该处于 batch 阶段\n  if ((executioncontext & (rendercontext | commitcontext)) !== nocontext) {\n    throw new error('should not already be working.');\n  }\n  // ......\n  // 获取 fiberroot 上下一次执行的 lanes\n  let lanes = getnextlanes(root, nolanes);\n  // 如果 lanes 中没有同步的 lanes\n  if (!includessomelane(lanes, synclane)) {\n    // there's no remaining sync work left.\n    ensurerootisscheduled(root, now());\n    return null;\n  }\n  // 同步渲染 fiberroot，并且返回渲染结果 exitstatus\n  let exitstatus = renderrootsync(root, lanes);\n  // 如果发生了普通错误，即 rooterrored，获取重试的优先级，并同步重试渲染  50 次\n  // ......\n  // 如果发生了严重错误，即 rootfatalerrored，抛出错误，将 fiberroot 标记为 suspend\n  // ......\n\n  // we now have a consistent tree. because this is a sync render, we\n  // will commit it even if something suspended.\n  // 渲染完毕，标记 finishedwork 和 finishedlanes，并且 commit 当前的 fiberroot\n  const finishedwork: fiber = (root.current.alternate: any);\n  root.finishedwork = finishedwork;\n  root.finishedlanes = lanes;\n  commitroot(root);\n\n  // before exiting, make sure there's a callback scheduled for the next\n  // pending level.\n  ensurerootisscheduled(root, now());\n\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n这个函数的主要作用如下：\n\n * 调用 renderrootsync 在 fiberroot 上进行渲染。根据返回的结果进行错误处理，根据错误的类型选择不同的错误处理策略。\n * 标记 finishedwork 和 finishedlanes 用于下次调度。\n * 调用 commitroot 在 fiberroot 上 commit 此次渲染。\n * 调用 ensurerootisscheduled 确保 fiberroot 上下一次被调度。\n\n\n# performconcurrentworkonroot\n\n同步任务和异步任务的回调，无外乎是要进行两个最为重要的任务，一个是 render ，一个是 commit 。同步任务回调思路较为清晰，这两个过程也都是同步完成的。下面我们来看看异步任务回调会是怎样的情况。\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n// this is the entry point for every concurrent task, i.e. anything that\n// goes through scheduler.\nfunction performconcurrentworkonroot(root, didtimeout) {\n  // ......\n\n  if ((executioncontext & (rendercontext | commitcontext)) !== nocontext) {\n    throw new error('should not already be working.');\n  }\n\n  // ......\n\n  // determine the next lanes to work on, using the fields stored\n  // on the root.\n  let lanes = getnextlanes(\n    root,\n    root === workinprogressroot ? workinprogressrootrenderlanes : nolanes,\n  );\n  // ......\n\n  // we disable time-slicing in some cases: if the work has been cpu-bound\n  // for too long (\"expired\" work, to prevent starvation), or we're in\n  // sync-updates-by-default mode.\n  // 在某些情况下并不会采用时间切片，如不包含阻塞或者过时的任务，转而采用同步渲染\n  const shouldtimeslice =\n    !includesblockinglane(root, lanes) &&\n    !includesexpiredlane(root, lanes);\n  let exitstatus = shouldtimeslice\n    ? renderrootconcurrent(root, lanes)\n    : renderrootsync(root, lanes);\n  if (exitstatus !== rootincomplete) {\n    // ......\n    const finishedwork: fiber = (root.current.alternate: any);\n    // we now have a consistent tree. the next step is either to commit it,\n    // or, if something suspended, wait to commit it after a timeout.\n    root.finishedwork = finishedwork;\n    root.finishedlanes = lanes;\n    finishconcurrentrender(root, exitstatus, lanes);\n  }\n  ensurerootisscheduled(root, now());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n总体过程与同步回调类似，不同的是这里调用了 finishconcurrentrender 来单独处理 commit 的部分。\n\n\n# 扩展\n\n\n# 从 schedulesynccallback 看任务队列\n\n同步任务队列是在调度器之外维护的一个简单的任务队列，下面我们来探讨一下这块的内容，可以为我们需要任务队列的场景做一些参考。\n\n一个简单的任务队列包含两个部分的功能，一个是入队列（生产者），一个是消费队列（消费者）。这种生成和消费的思想，在队列中极为常见。生产者对应 schedulesynccallback 函数，消费者则对应 flushsynccallbacks 函数。通过 oop 的思想，我们可以据此完成下面的原型：\n\nclass queue{\n  private queue = [];\n  private lock = true;\n  \n  add(task) {\n    this.queue.push(task);\n  }\n\n  flush() {\n    if(!this.lock || !this.queue.length) return this;\n    this.lock = false;\n    const queue = this.queue;\n    let i = 0;\n    try {\n      // do tasks from the queue\n      for (; i < queue.length; i++) {\n        let task = queue[i];\n        do {\n          task = task();\n        } while (task !== null);\n      }\n      this.queue = [];\n    } catch (error) {\n      // process errors\n    } finally {\n       this.lock =  true;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n关于任务队列，这里有几个重点需要注意：\n\n * 消费锁：防止任务池被两个消费者同时消费造成资源争抢。\n * 使用任务快照：先获取任务快照再进行消费，消费期间生产的任务应该等到下次消费。\n * 这里有一个问题，消费完毕之后直接把队列清空，可能造成消费期间生产的任务被丢失。\n * 任务可以返回新任务，直到不在返回任务为止。\n * 任务是同步执行的，任务被执行的顺序是可以保证的。\n * 任务执行错误捕获和处理。\n\n\n# 宽松的错误处理机制\n\nreact 本身是一个 ui 库，用于线上环境的视图的渲染必须要具有较为宽松的容错机制。其实我们可以从 render 过程的错误处理来看出这一点。\n\n以 renderrootsync 为例，上文中我们已知 renderrootsync 会返回 exitstatus 作为 render 结果的执行状态。下面我们来探讨下这块的错误的处理机制（部分代码有简化）。\n\n// 同步渲染 fiberroot，并且返回渲染结果 exitstatus\nlet exitstatus = renderrootsync(root, lanes);\n// 如果发生了普通错误，即 rooterrored\nif (exitstatus === rooterrored) {\n  // if something threw an error, try rendering one more time. we'll render\n  // synchronously to block concurrent data mutations, and we'll includes\n  // all pending updates are included. if it still fails after the second\n  // attempt, we'll give up and commit the resulting tree.\n  // 获取重试的优先级，并同步重试渲染  50 次\n  const errorretrylanes = getlanestoretrysynchronouslyonerror(root);\n  if (errorretrylanes !== nolanes) {\n    lanes = errorretrylanes;\n    exitstatus = recoverfromconcurrenterror(root, errorretrylanes);\n  }\n}\n// 如果发生了严重错误，即 rootfatalerrored，抛出错误，将 fiberroot 标记为 suspend\nif (exitstatus === rootfatalerrored) {\n  const fatalerror = workinprogressrootfatalerror;\n  // 清理执行栈\n  preparefreshstack(root, nolanes);\n  markrootsuspended(root, lanes);\n  ensurerootisscheduled(root, now());\n  throw fatalerror;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n处理机制总结如下：\n\n * 普通错误：同步渲染重试最多 50 次，如果重试过程中遇到致命错误，由致命错误处理，否则放弃重试，并且提交 fibertree。\n * 致命错误：清理执行栈，将 fiberroot 标记为 suspended，并且抛出这个错误。\n\n可见只有遇到致命错误才会阻断程序执行。在后文中我们会详细探讨 exitstatus 的含义。\n\n\n# 问题\n\n\n# 如何理解 performsyncworkonroot 和 performconcurrentworkonroot 两个函数在调和器中的位置和作用？\n\n * 从整体上看，这两个函数是作为同步任务或者异步任务的任务本身（内容）而存在的，也就是说，所谓调度的最终目标（也就是调度器的回调），就是要执行预设的任务。而这两个函数，正是任务本身，也是从 batch 阶段向 render 阶段再向 commit 阶段过渡的入口。我们可能也注意到源码对于这两个函数的注释:\n\n// this is the entry point for synchronous tasks that don't go\n// through scheduler\nfunction performsyncworkonroot() {}\n// this is the entry point for every concurrent task, i.e. anything that\n// goes through scheduler.\nfunction performconcurrentworkonroot() {}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这里作为同步任务或者异步任务的 entry point 体现的正是如此。\n\n * 从整体函数结构上看，这两个函数的结构高度的类似，这是因为此二者是针对同步任务和异步任务的后续处理过程的高度抽象。这是两个提纲挈领的、高度抽象的函数，而后续的同步渲染和异步任务也就此展开。\n\n\n# 总结\n\n通过本篇文章的探讨，有如下的重点内容需要关注：\n\n * 调度是 react 中为达到 基于优先级调度任务 的目的的一个技巧，在 react 的调度中，有两处任务的调度，一处是用于处理同步任务的简单的任务队列，一处是用于处理异步任务的较为复杂的调度器。\n * 调度的目的是执行任务，在执行的任务中，最重要的就是要完成后续的 render 过程和 commit 过程。本文虽然只有四个函数，却分别对应了同步任务和异步任务的调度和回调任务的核心过程。对于核心函数的理解，要从函数在整体中所出的位置和所发挥的作用来理解，也要从核心的逻辑内容来理解。\n * performwork 是执行回调的任务，而这个过程也是从 fiberroot 上进行。可见， fiberroot 对于 fibertree 的整体的结构至关重要。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 14:56:40",lastUpdatedTimestamp:1658473e6},{title:"React 源码漂流记：React 调和器核心源码解读（三）",frontmatter:{title:"React 源码漂流记：React 调和器核心源码解读（三）",date:"2022-07-12T12:02:21.000Z",permalink:"/react/tour/react-reconciliation-3/",categories:["react","React源码漂流记"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/110.react-reconciliation-3.html",relativePath:"10.react/90.React源码漂流记/110.react-reconciliation-3.md",key:"v-5962efbf",path:"/react/tour/react-reconciliation-3/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:17},{level:2,title:"renderRootSync",slug:"renderrootsync",normalizedTitle:"renderrootsync",charIndex:23},{level:2,title:"renderRootConcurrent",slug:"renderrootconcurrent",normalizedTitle:"renderrootconcurrent",charIndex:41},{level:2,title:"workLoopSync",slug:"workloopsync",normalizedTitle:"workloopsync",charIndex:65},{level:2,title:"workLoopConcurrent",slug:"workloopconcurrent",normalizedTitle:"workloopconcurrent",charIndex:81},{level:2,title:"performUnitOfWork",slug:"performunitofwork",normalizedTitle:"performunitofwork",charIndex:103},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:124},{level:3,title:"如何理解 WorkLoop?",slug:"如何理解-workloop",normalizedTitle:"如何理解 workloop?",charIndex:132},{level:3,title:"如何理解 workLoop 和 performUnitOfWork 的关系？",slug:"如何理解-workloop-和-performunitofwork-的关系",normalizedTitle:"如何理解 workloop 和 performunitofwork 的关系？",charIndex:152},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:194},{level:3,title:"workInProgress 是如何初始化的？",slug:"workinprogress-是如何初始化的",normalizedTitle:"workinprogress 是如何初始化的？",charIndex:202},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:229}],readingTime:{text:"6 min read",minutes:5.29,time:317400,words:1058},headersStr:"目录 前言 renderRootSync renderRootConcurrent workLoopSync workLoopConcurrent performUnitOfWork 扩展 如何理解 WorkLoop? 如何理解 workLoop 和 performUnitOfWork 的关系？ 问题 workInProgress 是如何初始化的？ 总结",content:"# 目录\n\n\n\n * 目录\n * 前言\n * renderRootSync\n * renderRootConcurrent\n * workLoopSync\n * workLoopConcurrent\n * performUnitOfWork\n * 扩展\n   * 如何理解 WorkLoop?\n   * 如何理解 workLoop 和 performUnitOfWork 的关系？\n * 问题\n   * workInProgress 是如何初始化的？\n * 总结\n\n\n\n\n# 前言\n\n在上一篇文章中，我们探讨了 React 调和器中 scheduleSyncCallback 、 scheduleCallback 、 performSyncWorkOnRoot 和 performConcurrentWorkOnRoot 四个核心函数，概括而言，其作用是：同步任务和异步任务的调度和任务回调。在本篇文章中我们就沿着上文中任务回调的入口继续深入，探讨调和器中 Render 的过程。\n\n\n# renderRootSync\n\n这个函数是在同步任务的回调的 Render 阶段调用，目的是对当前的 FiberRoot 进行渲染。\n\n注意\n\n这里所谓的渲染，并不是浏览器的渲染，即将 VDOM 转化为 DOM 并绘制到浏览器的过程。需要注意的是，此处 Render 过程，指的是 React 内部的 ExecutionContext 中的 RenderContext ， 即渲染过程实际上是一棵 FiberTree 真正调和的过程。所谓调和，就是新的 FiberTree 替代旧的 FiberTree，成为 currentFiberTree 的过程（FiberTree 的双缓存结构，后文详述）。而真正将 VDOM 转化为 DOM（或者 Render String），则是在 Commit 过程之后完成的。\n\n下面我们来看下源码：\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nfunction renderRootSync(root: FiberRoot, lanes: Lanes) {\n  const prevExecutionContext = executionContext;\n  // executionContext 添加 RenderContext\n  executionContext |= RenderContext;\n  // 更改当前 dispatcher 为 contextOnlyDispatcher，并且返回原来的 dispatcher\n  const prevDispatcher = pushDispatcher();\n  // ......\n  do {\n    try {\n      // 启动 workLoop\n      workLoopSync();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n  // ......\n  // Render 阶段结束，恢复之后的 dispatcher\n  executionContext = prevExecutionContext;\n  popDispatcher(prevDispatcher);\n  // ......\n\n  // Set this to null to indicate there's no in-progress render.\n  workInProgressRoot = null;\n  workInProgressRootRenderLanes = NoLanes;\n\n  return workInProgressRootExitStatus;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n这里有几点核心的内容：\n\n * workLoopSync 开启了一个渲染循环，这样一个循环就体现在遍历的思想上，是对 FiberTree 进行一个深度优先遍历（DFS）。我们将在后文进行详细的探讨。\n * 返回 workInProgressRootExitStatus 是在整个 src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js 文件中维护的，也就是在整个 ReactFiberWorkLoop 中维护的。在 workLoop 的执行过程中， exitStatus 总能保持最新的执行状态。\n * 在执行到 renderRootSync 函数中时， executionContext 被更新到 RenderContext 状态。这里有位运算的内容，详细可参见位运算怎么理解？。\n\n另外，还有一些值得注意的问题：\n\n * pushDispatcher 和 popDispatcher 是在做什么？dispatcher 实际上是和 hook 相关的内容，在 pushDispatcher 中将 ReactCurrentDispatcher.current 设置为 ContextOnlyDispatcher ，这种状态下的 hook 在调用时会报错。这是因为 hook 在 Render 阶段是不可调用的。我们在 hook 原理相关的章节会详细介绍。\n * 在执行完 Render 过程之后， executionContext 恢复了之前的状态，即 Batch 状态。这也是为什么在进入 Render 状态和 Commit 状态之前都要检查是否不是已经处于这两种状态。\n\n\n# renderRootConcurrent\n\n这个函数是在异步任务的回调的 Render 阶段调用，目的是对当前的 FiberRoot 进行渲染。\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nfunction renderRootConcurrent(root: FiberRoot, lanes: Lanes) {\n  const prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  const prevDispatcher = pushDispatcher();\n\n  // ......\n  do {\n    try {\n      workLoopConcurrent();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n  // ......\n\n  popDispatcher(prevDispatcher);\n  executionContext = prevExecutionContext;\n\n  // Set this to null to indicate there's no in-progress render.\n  workInProgressRoot = null;\n  workInProgressRootRenderLanes = NoLanes;\n\n  // Return the final exit status.\n  return workInProgressRootExitStatus;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n总体流程与 renderRootSync 一致，只是在 workLoop 函数使用了 workLoopConcurrent 。不再赘述。\n\n另外，我们来探讨下这里的错误处理机制，即 handleError 函数。\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nfunction handleError(root, thrownValue): void {\n  do {\n    // 当前的 workInProgress 即为出错的 Fiber\n    let erroredWork = workInProgress;\n    try {\n      // ......\n      if (erroredWork === null || erroredWork.return === null) {\n        // Expected to be working on a non-root fiber. This is a fatal error\n        // because there's no ancestor that can handle it; the root is\n        // supposed to capture all errors that weren't caught by an error\n        // boundary.\n        // 这是一个致命错误，因为这是一个没有父节点的 Fiber。因此，此 Fiber 上出现的错误不可冒泡处理。\n        workInProgressRootExitStatus = RootFatalErrored;\n        workInProgressRootFatalError = thrownValue;\n        workInProgress = null;\n        return;\n      }\n      // ......\n\n      throwException(\n        root,\n        erroredWork.return,\n        erroredWork,\n        thrownValue,\n        workInProgressRootRenderLanes,\n      );\n      // 结束 workLoop\n      completeUnitOfWork(erroredWork);\n    } catch (yetAnotherThrownValue) {\n      // ......\n    }\n    // Return to the normal work loop.\n    return;\n  } while (true);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n * 如果发生错误的 Fiber 没有父节点则为致命错误，因为无法通过冒泡机制找到捕获错误的目标。\n * 如果是普通错误，则结束本次 Fiber Work （当前 Fiber 上的调和工作）。\n\n\n# workLoopSync\n\n对于同步渲染的 WorkLoop 而言，只需判断 workInProgress （表示当前正在处理（调和）的 Fiber，即 workInProgress Fiber）不是悬空的即可。不必判断是否是 shouldYield 的时机，因为同步渲染具有最高的优先级，当做 TimeOut 的任务来看待。\n\n提示\n\n悬空本身是指针的概念， workInProgress 表示当前正在处理的 FiberNode 的引用，本质上也是 “指针”，故采用此说法。\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n// The work loop is an extremely hot path. Tell Closure not to inline it.\n/** @noinline */\nfunction workLoopSync() {\n  // Already timed out, so perform work without checking if we need to yield.\n  while (workInProgress !== null) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这里的 while loop 体现的就是 work loop 的思想，即是对 workInProgress FiberTree 数据结构的遍历过程（后文详述）， performUnitOfWork 则是体现为在 traverse 的过程中对当前的 FiberNode 进行操作（Work）的过程。\n\ntraverse 遍历\n\ntraverse 的概念来源于编译原理中 compile （编译）、 traverse （遍历）、 generate （生成）的三个步骤。这里的遍历是指将对 FiberTree 的数据结构进行遍历，并且对 FiberNode 进行处理的过程。\n\n@noinline annotation\n\n编译注解其实就是在编译时进行一些特殊的操作，很多是针对 Java 的概念提出的。注解针对普通的类、变量、方法等，能让编译器支持特殊的操作。注解通常使用的场景是类、方法、字段、局部变量和参数等。\n\n * @inline：标记编译器内联；\n * @noinline：标记编译器不要内联，防止因优化器过于智能而过度优化，反而伤害效能。\n\n由于在 WHILE 循环中， performUnitOfWork 会反复被调用，属于是 hot path ， @noinline 的标记告知 JavaScript 编译器，不要将即函数做内联优化处理，以免过度优化伤害程序性能。\n\n参考：\n\n * Automatic Inlining in JavaScript Engines · ariya.io\n * Optimizing for V8 - Inlining, Deoptimizations | Codegen::RecordSafepoint\n\n\n# workLoopConcurrent\n\n对于异步渲染的 WorkLoop 而言，除了需要确保 workInProgress 不能悬空之外，还需要确保调度器没有更高优先级的回调，即 shouldYield 。如果调度器需要打断本次回调，则放弃此次 WorkLoop。\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\n/** @noinline */\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n还需要注意的是，无论是同步渲染还是异步渲染的 WorkLoop 都是通过 performUnitOfWork 来处理的。这是因为所谓同步和异步渲染的区别，归根结底是请求渲染时机的区别，而真正的 WorkLoop 的过程（渲染过程，即调和过程）是一样的。\n\nshouldYield：即 shouldYieldToHost，用于判断是否有任务超时，需要打断调和过程，重新回调。\n\n\n# performUnitOfWork\n\n在上文中，我们探讨了同步渲染和异步渲染时如何通过调度器的回调（注：此处是简便说法，同步调度实际上是不通过调度器回调的，后文将沿用此说法，且不再重复说明）来启动 WorkLoop 的，而且了解到 WorkLoop 是通过 performUnitOfWork 以在 traverse 过程中对 FiberNode 进行 Work 的。下面我们就来详细探讨 performUnitOfWork 函数，了解此函数是如何遍历 FiberTree 并且对 FiberNode 进行调和的。\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nfunction performUnitOfWork(unitOfWork: Fiber): void {\n  // The current, flushed, state of this fiber is the alternate. \n  // 获取 Fiber 在 currentFiberTree 上的当前渲染版本的 Fiber\n  const current = unitOfWork.alternate;\n  // 调和 Fiber，并返回下一个需要调和的 Fiber（DFS）\n  const next = beginWork(current, unitOfWork, subtreeRenderLanes);\n  // 将 pendingProps 缓存到 memoizedProps，因为此 Fiber 已经调和完毕\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    // 如果没有下一个 Fiber 需要调和，则捕获完毕开始冒泡\n    completeUnitOfWork(unitOfWork);\n  } else {\n    // workInProgress 指针移动到下一个需要调和的 Fiber\n    workInProgress = next;\n  }\n  // ReactCurrentOwner.current 是指当前正处于构建过程中的组件。\n  ReactCurrentOwner.current = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n有以下的问题需要重点关注一下：\n\n 1. Fiber 的结构。理解 Fiber 的结构对于理解此函数至关重要。在前文关于 Fiber 和调和基础 的探讨中，我们已经知道了 Fiber 具有如下的结构：\n\ntype Fiber = {\n  // 这个Fiber 的版本池，每个更新的 fiber 都会有一个相对的 alternate fiber。\n  alternate: Fiber | null,\n  // Input is the data coming into process this fiber. Arguments. Props.\n  // 当前 work-in-progress 的组件 props。\n  pendingProps: any,\n  // 缓存之前的组件的 props。\n  memoizedProps: any,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n当前的 WorkLoop 处理的是 WorkInProgress FiberTree，因此， unitOfWork 指的是 WorkInProgress FiberNode。另外，根据 FiberTree 的双缓存的结构， unitOfWork.alternate 指向的是 currentFiberTree 上与之相对应的 FiberNode。简单理解之， current 是当前已经渲染的稳定的 FiberNode， unitOfWork 是即将要渲染的需要调和的 FiberNode。\n\n 2. 调用 beginWork 调和当前 Fiber 节点， completeUnitOfWork 完成 Fiber 的调和过程（从 beginWork 到 completeWork 的过程）。注意 next === null 是从捕获到冒泡的转折点，并不是要退出 WorkLoop。\n 3. 指针的移动： beginWork 会返回下一个需要被调和的 FiberNode， workInProgress 会指向该节点，在 WorkLoop 中继续完成调和过程。如果没有下一个需要调和的节点，说明已经遍历到叶子节点，此时转入冒泡过程，转而执行 completeUnitOfWork 。\n 4. ReactCurrentOwner.current 的含义： ReactCurrentOwner.current 是指当前正处于构建过程中的组件。这个变量实际上相当于是一个存在于 React 作用域全局的一个缓存变量。\n 5. 从 performUnitOfWork 开始，将不在遵循兵分两路的方式，即同步模式和异步模式（上文常提到同步调度和异步调度，同步渲染和异步渲染。）需要注意的是，这里提到的同步和异步表示一种属性而非方式，是一种优先级高低的体现，即调度是同步的或者说渲染是同步的，与编程中 同步执行和异步执行 的概念不同。渲染本身并无同步异步之分，渲染的时机（由优先级控制）才有同步和异步之别。\n\nReactCurrentOwner.current为什么重要?\n\n因为它是自定义节点的指针。所有的 ReactCompositeComponent 最终 render 之后都变成了干干净净的 ReactDomComponent 节点组成的 DOM 树，但是如何分辨哪些是 ReactCompositeComponent 生成的呢？这就依赖这些 ReactDomComponent 节点上的 owner 变量。而 ReactCurrentOwner.current 正是维护这个在构建虚拟 DOM 过程中，随时会变动的变量的临时保存位置所在。\n\n这个值会被缓存到 ReactElement.__owner 中。\n\n参考：\n\n * React ReactCurrentOwner | Que's Blog\n * _owner 是如何连接 ReactElement 和 Fiber 的？_owner 有什么作用？\n\n\n# 扩展\n\n\n# 如何理解 WorkLoop?\n\n从过程来来看，WorkLoop 是对 workInProgress FiberTree 的遍历与回溯（捕获和冒泡）的过程，在此二者过程中，分别对 FiberNode 做 beginWork 和 completeWork 的工作，以达到挂载、更新和标记 EffectTag （后文可能会直接称之为 ETag） 的目的。\n\n从功能上来看，WorkLoop 的目的是对 workInProgress FiberTree 进行调和（针对 VDOM 的组件的挂载和更新，针对 DOM 转化的 ETag 的标记），这是一次从 workInProgress FiberTree 到 current FiberTree 的构造、加工和飞跃的过程。WorkLoop 的工作是 Render 阶段的核心工作，也是实质性的工作，这为 fiberRoot.current 的迁移工作打下了夯实的基础。\n\n下面是一次从 RootFiber 开始的 WorkLoop 的过程，您可以根据此图了解 FiberTree 的结构以及 WorkLoop 捕获与冒泡的过程。关于 WorkLoop 的详细的工作流程，在后文中会进行更详细的探讨。\n\n\n# 如何理解 workLoop 和 performUnitOfWork 的关系？\n\nworkLoop 是整个调和工作的控制器，是控制遍历 FiberTree 的引擎，也可以称之为调和工厂，相应的， performUnitOfWork 是调和 FiberNode 的具体工作者，也可以称之为调和工作的工人，具体控制着 beginWork 和 completeWork 的职责。二者在 FiberTree 这个指针结构的协助下，共同完成调和 FiberTree 的任务。\n\n在 performUnitOfWork 和 workLoopConcurrent 中添加 @noinline 的非内联标记，也能体现这一思想。因为对于 workLoop 而言， performUnitOfWork 必然是多实例的，内联编译则破坏了这一思路。虽然非内联函数在函数的启动、缓存时必然耗费了更多的内存，但是这样反而是正确的方式，这是因为空间换时间的方式能够提高程序的执行效率。\n\n\n# 问题\n\n\n# workInProgress 是如何初始化的？\n\n我们可能会有这样的疑问， workInProgress 在应用挂载时是悬空的，而在 WorkLoop 中确是对 workInProgress 进行操作，那么 workInProgress 是如何初始化的呢？\n\n事实上，在 renderRootSync 和 renderRootConcurrent 中都有如下的一段逻辑：\n\n// If the root or lanes have changed, throw out the existing stack\n// and prepare a fresh one. Otherwise we'll continue where we left off.\nif (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n  // ......\n  prepareFreshStack(root, lanes);\n}\n\nfunction prepareFreshStack(root: FiberRoot, lanes: Lanes) {\n  // ......\n  workInProgressRoot = root;\n  workInProgress = createWorkInProgress(root.current, null);\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\n  // ......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果 workInProgressRoot 即当前处理的 FiberTree 的根节点（或者渲染优先级）发生了变化，则清理 workInProgressStack 的内容，包括重新创建 workInProgress 节点。因此在应用挂载时， workInProgress 实际上是根据 root.current 的 FiberNode 而创建的。\n\n\n# 总结\n\n通过本篇文章的探讨，有如下的重点内容需要关注：\n\n * Render 的过程本质上是 WorkLoop 的过程， WorkLoop 的错误处理具有较好的容错度。\n * workLoopSync 和 workLoopConcurrent 本质上都是捕获和冒泡调和 FiberTree 的过程， 也都是通过 performUnitOfWork 函数调和 FiberNode。二者唯一的不同是跳出时机的不同， workLoopConcurrent 除了要判断 workInProgress 未悬空之外，还需要判断调度器是否需要打断调和过程。\n * performUnitOfWork 独立控制着 beginWork 和 completeWork 即 completeUnitOfWork 的流程。",normalizedContent:"# 目录\n\n\n\n * 目录\n * 前言\n * renderrootsync\n * renderrootconcurrent\n * workloopsync\n * workloopconcurrent\n * performunitofwork\n * 扩展\n   * 如何理解 workloop?\n   * 如何理解 workloop 和 performunitofwork 的关系？\n * 问题\n   * workinprogress 是如何初始化的？\n * 总结\n\n\n\n\n# 前言\n\n在上一篇文章中，我们探讨了 react 调和器中 schedulesynccallback 、 schedulecallback 、 performsyncworkonroot 和 performconcurrentworkonroot 四个核心函数，概括而言，其作用是：同步任务和异步任务的调度和任务回调。在本篇文章中我们就沿着上文中任务回调的入口继续深入，探讨调和器中 render 的过程。\n\n\n# renderrootsync\n\n这个函数是在同步任务的回调的 render 阶段调用，目的是对当前的 fiberroot 进行渲染。\n\n注意\n\n这里所谓的渲染，并不是浏览器的渲染，即将 vdom 转化为 dom 并绘制到浏览器的过程。需要注意的是，此处 render 过程，指的是 react 内部的 executioncontext 中的 rendercontext ， 即渲染过程实际上是一棵 fibertree 真正调和的过程。所谓调和，就是新的 fibertree 替代旧的 fibertree，成为 currentfibertree 的过程（fibertree 的双缓存结构，后文详述）。而真正将 vdom 转化为 dom（或者 render string），则是在 commit 过程之后完成的。\n\n下面我们来看下源码：\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nfunction renderrootsync(root: fiberroot, lanes: lanes) {\n  const prevexecutioncontext = executioncontext;\n  // executioncontext 添加 rendercontext\n  executioncontext |= rendercontext;\n  // 更改当前 dispatcher 为 contextonlydispatcher，并且返回原来的 dispatcher\n  const prevdispatcher = pushdispatcher();\n  // ......\n  do {\n    try {\n      // 启动 workloop\n      workloopsync();\n      break;\n    } catch (thrownvalue) {\n      handleerror(root, thrownvalue);\n    }\n  } while (true);\n  // ......\n  // render 阶段结束，恢复之后的 dispatcher\n  executioncontext = prevexecutioncontext;\n  popdispatcher(prevdispatcher);\n  // ......\n\n  // set this to null to indicate there's no in-progress render.\n  workinprogressroot = null;\n  workinprogressrootrenderlanes = nolanes;\n\n  return workinprogressrootexitstatus;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n这里有几点核心的内容：\n\n * workloopsync 开启了一个渲染循环，这样一个循环就体现在遍历的思想上，是对 fibertree 进行一个深度优先遍历（dfs）。我们将在后文进行详细的探讨。\n * 返回 workinprogressrootexitstatus 是在整个 src/react/packages/react-reconciler/src/reactfiberworkloop.new.js 文件中维护的，也就是在整个 reactfiberworkloop 中维护的。在 workloop 的执行过程中， exitstatus 总能保持最新的执行状态。\n * 在执行到 renderrootsync 函数中时， executioncontext 被更新到 rendercontext 状态。这里有位运算的内容，详细可参见位运算怎么理解？。\n\n另外，还有一些值得注意的问题：\n\n * pushdispatcher 和 popdispatcher 是在做什么？dispatcher 实际上是和 hook 相关的内容，在 pushdispatcher 中将 reactcurrentdispatcher.current 设置为 contextonlydispatcher ，这种状态下的 hook 在调用时会报错。这是因为 hook 在 render 阶段是不可调用的。我们在 hook 原理相关的章节会详细介绍。\n * 在执行完 render 过程之后， executioncontext 恢复了之前的状态，即 batch 状态。这也是为什么在进入 render 状态和 commit 状态之前都要检查是否不是已经处于这两种状态。\n\n\n# renderrootconcurrent\n\n这个函数是在异步任务的回调的 render 阶段调用，目的是对当前的 fiberroot 进行渲染。\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nfunction renderrootconcurrent(root: fiberroot, lanes: lanes) {\n  const prevexecutioncontext = executioncontext;\n  executioncontext |= rendercontext;\n  const prevdispatcher = pushdispatcher();\n\n  // ......\n  do {\n    try {\n      workloopconcurrent();\n      break;\n    } catch (thrownvalue) {\n      handleerror(root, thrownvalue);\n    }\n  } while (true);\n  // ......\n\n  popdispatcher(prevdispatcher);\n  executioncontext = prevexecutioncontext;\n\n  // set this to null to indicate there's no in-progress render.\n  workinprogressroot = null;\n  workinprogressrootrenderlanes = nolanes;\n\n  // return the final exit status.\n  return workinprogressrootexitstatus;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n总体流程与 renderrootsync 一致，只是在 workloop 函数使用了 workloopconcurrent 。不再赘述。\n\n另外，我们来探讨下这里的错误处理机制，即 handleerror 函数。\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nfunction handleerror(root, thrownvalue): void {\n  do {\n    // 当前的 workinprogress 即为出错的 fiber\n    let erroredwork = workinprogress;\n    try {\n      // ......\n      if (erroredwork === null || erroredwork.return === null) {\n        // expected to be working on a non-root fiber. this is a fatal error\n        // because there's no ancestor that can handle it; the root is\n        // supposed to capture all errors that weren't caught by an error\n        // boundary.\n        // 这是一个致命错误，因为这是一个没有父节点的 fiber。因此，此 fiber 上出现的错误不可冒泡处理。\n        workinprogressrootexitstatus = rootfatalerrored;\n        workinprogressrootfatalerror = thrownvalue;\n        workinprogress = null;\n        return;\n      }\n      // ......\n\n      throwexception(\n        root,\n        erroredwork.return,\n        erroredwork,\n        thrownvalue,\n        workinprogressrootrenderlanes,\n      );\n      // 结束 workloop\n      completeunitofwork(erroredwork);\n    } catch (yetanotherthrownvalue) {\n      // ......\n    }\n    // return to the normal work loop.\n    return;\n  } while (true);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n * 如果发生错误的 fiber 没有父节点则为致命错误，因为无法通过冒泡机制找到捕获错误的目标。\n * 如果是普通错误，则结束本次 fiber work （当前 fiber 上的调和工作）。\n\n\n# workloopsync\n\n对于同步渲染的 workloop 而言，只需判断 workinprogress （表示当前正在处理（调和）的 fiber，即 workinprogress fiber）不是悬空的即可。不必判断是否是 shouldyield 的时机，因为同步渲染具有最高的优先级，当做 timeout 的任务来看待。\n\n提示\n\n悬空本身是指针的概念， workinprogress 表示当前正在处理的 fibernode 的引用，本质上也是 “指针”，故采用此说法。\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n// the work loop is an extremely hot path. tell closure not to inline it.\n/** @noinline */\nfunction workloopsync() {\n  // already timed out, so perform work without checking if we need to yield.\n  while (workinprogress !== null) {\n    performunitofwork(workinprogress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这里的 while loop 体现的就是 work loop 的思想，即是对 workinprogress fibertree 数据结构的遍历过程（后文详述）， performunitofwork 则是体现为在 traverse 的过程中对当前的 fibernode 进行操作（work）的过程。\n\ntraverse 遍历\n\ntraverse 的概念来源于编译原理中 compile （编译）、 traverse （遍历）、 generate （生成）的三个步骤。这里的遍历是指将对 fibertree 的数据结构进行遍历，并且对 fibernode 进行处理的过程。\n\n@noinline annotation\n\n编译注解其实就是在编译时进行一些特殊的操作，很多是针对 java 的概念提出的。注解针对普通的类、变量、方法等，能让编译器支持特殊的操作。注解通常使用的场景是类、方法、字段、局部变量和参数等。\n\n * @inline：标记编译器内联；\n * @noinline：标记编译器不要内联，防止因优化器过于智能而过度优化，反而伤害效能。\n\n由于在 while 循环中， performunitofwork 会反复被调用，属于是 hot path ， @noinline 的标记告知 javascript 编译器，不要将即函数做内联优化处理，以免过度优化伤害程序性能。\n\n参考：\n\n * automatic inlining in javascript engines · ariya.io\n * optimizing for v8 - inlining, deoptimizations | codegen::recordsafepoint\n\n\n# workloopconcurrent\n\n对于异步渲染的 workloop 而言，除了需要确保 workinprogress 不能悬空之外，还需要确保调度器没有更高优先级的回调，即 shouldyield 。如果调度器需要打断本次回调，则放弃此次 workloop。\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\n/** @noinline */\nfunction workloopconcurrent() {\n  // perform work until scheduler asks us to yield\n  while (workinprogress !== null && !shouldyield()) {\n    performunitofwork(workinprogress);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n还需要注意的是，无论是同步渲染还是异步渲染的 workloop 都是通过 performunitofwork 来处理的。这是因为所谓同步和异步渲染的区别，归根结底是请求渲染时机的区别，而真正的 workloop 的过程（渲染过程，即调和过程）是一样的。\n\nshouldyield：即 shouldyieldtohost，用于判断是否有任务超时，需要打断调和过程，重新回调。\n\n\n# performunitofwork\n\n在上文中，我们探讨了同步渲染和异步渲染时如何通过调度器的回调（注：此处是简便说法，同步调度实际上是不通过调度器回调的，后文将沿用此说法，且不再重复说明）来启动 workloop 的，而且了解到 workloop 是通过 performunitofwork 以在 traverse 过程中对 fibernode 进行 work 的。下面我们就来详细探讨 performunitofwork 函数，了解此函数是如何遍历 fibertree 并且对 fibernode 进行调和的。\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nfunction performunitofwork(unitofwork: fiber): void {\n  // the current, flushed, state of this fiber is the alternate. \n  // 获取 fiber 在 currentfibertree 上的当前渲染版本的 fiber\n  const current = unitofwork.alternate;\n  // 调和 fiber，并返回下一个需要调和的 fiber（dfs）\n  const next = beginwork(current, unitofwork, subtreerenderlanes);\n  // 将 pendingprops 缓存到 memoizedprops，因为此 fiber 已经调和完毕\n  unitofwork.memoizedprops = unitofwork.pendingprops;\n  if (next === null) {\n    // if this doesn't spawn new work, complete the current work.\n    // 如果没有下一个 fiber 需要调和，则捕获完毕开始冒泡\n    completeunitofwork(unitofwork);\n  } else {\n    // workinprogress 指针移动到下一个需要调和的 fiber\n    workinprogress = next;\n  }\n  // reactcurrentowner.current 是指当前正处于构建过程中的组件。\n  reactcurrentowner.current = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n有以下的问题需要重点关注一下：\n\n 1. fiber 的结构。理解 fiber 的结构对于理解此函数至关重要。在前文关于 fiber 和调和基础 的探讨中，我们已经知道了 fiber 具有如下的结构：\n\ntype fiber = {\n  // 这个fiber 的版本池，每个更新的 fiber 都会有一个相对的 alternate fiber。\n  alternate: fiber | null,\n  // input is the data coming into process this fiber. arguments. props.\n  // 当前 work-in-progress 的组件 props。\n  pendingprops: any,\n  // 缓存之前的组件的 props。\n  memoizedprops: any,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n当前的 workloop 处理的是 workinprogress fibertree，因此， unitofwork 指的是 workinprogress fibernode。另外，根据 fibertree 的双缓存的结构， unitofwork.alternate 指向的是 currentfibertree 上与之相对应的 fibernode。简单理解之， current 是当前已经渲染的稳定的 fibernode， unitofwork 是即将要渲染的需要调和的 fibernode。\n\n 2. 调用 beginwork 调和当前 fiber 节点， completeunitofwork 完成 fiber 的调和过程（从 beginwork 到 completework 的过程）。注意 next === null 是从捕获到冒泡的转折点，并不是要退出 workloop。\n 3. 指针的移动： beginwork 会返回下一个需要被调和的 fibernode， workinprogress 会指向该节点，在 workloop 中继续完成调和过程。如果没有下一个需要调和的节点，说明已经遍历到叶子节点，此时转入冒泡过程，转而执行 completeunitofwork 。\n 4. reactcurrentowner.current 的含义： reactcurrentowner.current 是指当前正处于构建过程中的组件。这个变量实际上相当于是一个存在于 react 作用域全局的一个缓存变量。\n 5. 从 performunitofwork 开始，将不在遵循兵分两路的方式，即同步模式和异步模式（上文常提到同步调度和异步调度，同步渲染和异步渲染。）需要注意的是，这里提到的同步和异步表示一种属性而非方式，是一种优先级高低的体现，即调度是同步的或者说渲染是同步的，与编程中 同步执行和异步执行 的概念不同。渲染本身并无同步异步之分，渲染的时机（由优先级控制）才有同步和异步之别。\n\nreactcurrentowner.current为什么重要?\n\n因为它是自定义节点的指针。所有的 reactcompositecomponent 最终 render 之后都变成了干干净净的 reactdomcomponent 节点组成的 dom 树，但是如何分辨哪些是 reactcompositecomponent 生成的呢？这就依赖这些 reactdomcomponent 节点上的 owner 变量。而 reactcurrentowner.current 正是维护这个在构建虚拟 dom 过程中，随时会变动的变量的临时保存位置所在。\n\n这个值会被缓存到 reactelement.__owner 中。\n\n参考：\n\n * react reactcurrentowner | que's blog\n * _owner 是如何连接 reactelement 和 fiber 的？_owner 有什么作用？\n\n\n# 扩展\n\n\n# 如何理解 workloop?\n\n从过程来来看，workloop 是对 workinprogress fibertree 的遍历与回溯（捕获和冒泡）的过程，在此二者过程中，分别对 fibernode 做 beginwork 和 completework 的工作，以达到挂载、更新和标记 effecttag （后文可能会直接称之为 etag） 的目的。\n\n从功能上来看，workloop 的目的是对 workinprogress fibertree 进行调和（针对 vdom 的组件的挂载和更新，针对 dom 转化的 etag 的标记），这是一次从 workinprogress fibertree 到 current fibertree 的构造、加工和飞跃的过程。workloop 的工作是 render 阶段的核心工作，也是实质性的工作，这为 fiberroot.current 的迁移工作打下了夯实的基础。\n\n下面是一次从 rootfiber 开始的 workloop 的过程，您可以根据此图了解 fibertree 的结构以及 workloop 捕获与冒泡的过程。关于 workloop 的详细的工作流程，在后文中会进行更详细的探讨。\n\n\n# 如何理解 workloop 和 performunitofwork 的关系？\n\nworkloop 是整个调和工作的控制器，是控制遍历 fibertree 的引擎，也可以称之为调和工厂，相应的， performunitofwork 是调和 fibernode 的具体工作者，也可以称之为调和工作的工人，具体控制着 beginwork 和 completework 的职责。二者在 fibertree 这个指针结构的协助下，共同完成调和 fibertree 的任务。\n\n在 performunitofwork 和 workloopconcurrent 中添加 @noinline 的非内联标记，也能体现这一思想。因为对于 workloop 而言， performunitofwork 必然是多实例的，内联编译则破坏了这一思路。虽然非内联函数在函数的启动、缓存时必然耗费了更多的内存，但是这样反而是正确的方式，这是因为空间换时间的方式能够提高程序的执行效率。\n\n\n# 问题\n\n\n# workinprogress 是如何初始化的？\n\n我们可能会有这样的疑问， workinprogress 在应用挂载时是悬空的，而在 workloop 中确是对 workinprogress 进行操作，那么 workinprogress 是如何初始化的呢？\n\n事实上，在 renderrootsync 和 renderrootconcurrent 中都有如下的一段逻辑：\n\n// if the root or lanes have changed, throw out the existing stack\n// and prepare a fresh one. otherwise we'll continue where we left off.\nif (workinprogressroot !== root || workinprogressrootrenderlanes !== lanes) {\n  // ......\n  preparefreshstack(root, lanes);\n}\n\nfunction preparefreshstack(root: fiberroot, lanes: lanes) {\n  // ......\n  workinprogressroot = root;\n  workinprogress = createworkinprogress(root.current, null);\n  workinprogressrootrenderlanes = subtreerenderlanes = workinprogressrootincludedlanes = lanes;\n  // ......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果 workinprogressroot 即当前处理的 fibertree 的根节点（或者渲染优先级）发生了变化，则清理 workinprogressstack 的内容，包括重新创建 workinprogress 节点。因此在应用挂载时， workinprogress 实际上是根据 root.current 的 fibernode 而创建的。\n\n\n# 总结\n\n通过本篇文章的探讨，有如下的重点内容需要关注：\n\n * render 的过程本质上是 workloop 的过程， workloop 的错误处理具有较好的容错度。\n * workloopsync 和 workloopconcurrent 本质上都是捕获和冒泡调和 fibertree 的过程， 也都是通过 performunitofwork 函数调和 fibernode。二者唯一的不同是跳出时机的不同， workloopconcurrent 除了要判断 workinprogress 未悬空之外，还需要判断调度器是否需要打断调和过程。\n * performunitofwork 独立控制着 beginwork 和 completework 即 completeunitofwork 的流程。",charsets:{cjk:!0},lastUpdated:"2022/07/28, 09:19:48",lastUpdatedTimestamp:1658971188e3},{title:"React 源码漂流记：React 调和器核心源码解读（四）",frontmatter:{title:"React 源码漂流记：React 调和器核心源码解读（四）",date:"2022-07-20T12:02:21.000Z",permalink:"/react/tour/react-reconciliation-4/",categories:["react","React源码漂流记"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/120.react-reconciliation-4.html",relativePath:"10.react/90.React源码漂流记/120.react-reconciliation-4.md",key:"v-d7a41f02",path:"/react/tour/react-reconciliation-4/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:17},{level:2,title:"beginWork",slug:"beginwork",normalizedTitle:"beginwork",charIndex:23},{level:3,title:"didReceiveUpdate",slug:"didreceiveupdate",normalizedTitle:"didreceiveupdate",charIndex:38},{level:3,title:"beginWork",slug:"beginwork-2",normalizedTitle:"beginwork",charIndex:23},{level:2,title:"mountIndeterminateComponent",slug:"mountindeterminatecomponent",normalizedTitle:"mountindeterminatecomponent",charIndex:73},{level:2,title:"mountLazyComponent",slug:"mountlazycomponent",normalizedTitle:"mountlazycomponent",charIndex:104},{level:2,title:"updateFunctionComponent",slug:"updatefunctioncomponent",normalizedTitle:"updatefunctioncomponent",charIndex:126},{level:2,title:"updateClassComponent",slug:"updateclasscomponent",normalizedTitle:"updateclasscomponent",charIndex:153},{level:2,title:"updateHostRoot",slug:"updatehostroot",normalizedTitle:"updatehostroot",charIndex:177},{level:2,title:"updateHostComponent",slug:"updatehostcomponent",normalizedTitle:"updatehostcomponent",charIndex:195},{level:2,title:"updateHostText",slug:"updatehosttext",normalizedTitle:"updatehosttext",charIndex:218},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:236},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:242},{level:3,title:"Component 即 workInProgress.type 是如何初始化的？",slug:"component-即-workinprogress-type-是如何初始化的",normalizedTitle:"component 即 workinprogress.type 是如何初始化的？",charIndex:250},{level:3,title:"mountIndeterminateComponent为什么都能够执行 Component(props, context)?",slug:"mountindeterminatecomponent为什么都能够执行-component-props-context",normalizedTitle:"mountindeterminatecomponent 为什么都能够执行 component (props, context)?",charIndex:null},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:362}],readingTime:{text:"6 min read",minutes:5.285,time:317100,words:1057},headersStr:"目录 前言 beginWork didReceiveUpdate beginWork mountIndeterminateComponent mountLazyComponent updateFunctionComponent updateClassComponent updateHostRoot updateHostComponent updateHostText 扩展 问题 Component 即 workInProgress.type 是如何初始化的？ mountIndeterminateComponent为什么都能够执行 Component(props, context)? 总结",content:"# 目录\n\n\n\n * 目录\n * 前言\n * beginWork\n   * didReceiveUpdate\n   * beginWork\n * mountIndeterminateComponent\n * mountLazyComponent\n * updateFunctionComponent\n * updateClassComponent\n * updateHostRoot\n * updateHostComponent\n * updateHostText\n * 扩展\n * 问题\n   * Component 即 workInProgress.type 是如何初始化的？\n   * mountIndeterminateComponent为什么都能够执行 Component(props, context)?\n * 总结\n\n\n\n\n# 前言\n\n在上一篇文章中，我们探讨了 React 调和器中 renderRootSync 、 renderRootConcurrent 、 workLoopSync 、 workLoopConcurrent 、 performUnitOfWork 5 个核心函数，整体过程偏于梗概和流程，虽然过程较为简单，但是对于理解整体调和的过程却是至关重要的。因此，上文与本文的衔接较为紧密。\n\n先回顾一下上文的情节，5 个函数，从 Render 阶段的开始，到 WorkLoop 的启动，再到 performUnitOfWork 的具体的调和工作，整个调和过程其实比较清晰。在以下几篇文章中，将着重分析调和中的捕获和冒泡过程，即单个 Fiber 节点的调和过程。\n\n注意\n\n因篇幅限制，本文只探讨重要类型的组件的调和过程的梗概，具体组件的调和过程细节不探讨，后文详述。\n\n\n# beginWork\n\n从整体上看， beginWork 是根据 workInProgress Fiber 的类型，而决定采取不同的 mount 或者 update 的策略。\n\n\n# didReceiveUpdate\n\ndidReceiveUpdate 对于理解这部分代码很重要，因此我们先来分析下 didReceiveUpdate 的含义和意义。 didReceiveUpdate 表示是否接收到变化（更新），如果未接收到更新则可以复用 Fiber 节点（意思是复用下一级的子节点提前返回 null 阻断后续的捕获过程）。\n\n简化代码如下：\n\nif (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n    if (oldProps !== newProps) {\n      // 如果有 props 变化，则标记接收到更新\n      didReceiveUpdate = true;\n    } else {\n      // ......\n      didReceiveUpdate = false;\n    }\n  } else {\n    didReceiveUpdate = false;\n    // ......\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n分析如下：\n\n * 参数含义：通过上文中的探讨，我们可以明了的是： current 表示 current FiberTree 的 FiberNode，是已经渲染过的节点； workInProgress 是 workInProgress FiberTree 的 FiberNode，是即将要被渲染的节点。\n * current === null 可以区分 mount 阶段和 update 阶段（注意：这里不是指调和的阶段，而是指从 React 的应用的渲染周期来看，包含初次渲染即 mount 阶段和更新渲染即 update 阶段）。\n\n注意\n\n这里为什么比较 Props 的引用而不是浅比较呢？为什么在执行 Component 之前需要比较 Props? 在 performUnitOfWork 中 unitOfWork.memoizedProps = unitOfWork.pendingProps 中有如下代码，那次此处 oldProps 大概率会与 newProps 相等？\n\n弄清楚 didReceiveUpdate 含义和复用节点的条件之后，下面我们再具体探讨 beginWork 的内容。\n\n\n# beginWork\n\n注意\n\n以下代码只保留了核心内容，细节内容有删改。\n\n// src/react/packages/react-reconciler/src/ReactFiberBeginWork.new.js\nfunction beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  switch (workInProgress.tag) {\n    case IndeterminateComponent: \n      return mountIndeterminateComponent(/*......*/);\n    case LazyComponent: \n      return mountLazyComponent(/*......*/);\n    case FunctionComponent: \n      return updateFunctionComponent(/*......*/);\n    case ClassComponent: \n      return updateClassComponent(/*......*/);\n    case HostRoot:\n      return updateHostRoot(/*......*/);\n    case HostComponent:\n      return updateHostComponent(/*......*/);\n    case HostText:\n      return updateHostText(/*......*/);\n    case SuspenseComponent:\n      return updateSuspenseComponent(/*......*/);\n    case HostPortal:\n      return updatePortalComponent(/*......*/);\n    case ForwardRef: \n      return updateForwardRef(/*......*/);\n    case Fragment:\n      return updateFragment(/*......*/);\n    // ......\n    case ContextProvider:\n      return updateContextProvider(/*......*/);\n    case ContextConsumer:\n      return updateContextConsumer(/*......*/);\n    case MemoComponent: \n      return updateMemoComponent(/*......*/);\n    case SimpleMemoComponent: \n      return updateSimpleMemoComponent(/*......*/);\n    case IncompleteClassComponent: \n      return mountIncompleteClassComponent(/*......*/);\n    // ......\n    case OffscreenComponent: \n      return updateOffscreenComponent(/*......*/);\n    // ......\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# mountIndeterminateComponent\n\n此函数针对首次渲染时的未知类型的组件（并且是立即挂载的组件）进行判断，区分函数式组件和 伪装成函数的类组件 进行相关处理，并且调和 ReactChildren（本质上是 ReactElement）。\n\n源码如下:\n\n// src/react/packages/react-reconciler/src/ReactFiberBeginWork.new.js\nfunction mountIndeterminateComponent(\n  _current,\n  workInProgress,\n  Component,\n  renderLanes,\n) {\n  // ......\n  const props = workInProgress.pendingProps;\n  // 清理 workInProgress context，即 workInProgress.dependencies.firstContext = null\n  prepareToReadContext(workInProgress, renderLanes);\n  // 执行 Component 并获得返回值，如果是类组件，value 是组件实例\n  const value = Component(props, context)\n\n  // 判断是否是合法的类组件\n  if (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.render === 'function' &&\n    value.$$typeof === undefined\n  ) {\n    // 将 workInProgress 标记为类组件\n    workInProgress.tag = ClassComponent;\n    workInProgress.updateQueue = null;\n    // ......\n    // 更新 state\n    workInProgress.memoizedState =\n      value.state !== null && value.state !== undefined ? value.state : null;\n    // 初始化 state 更新队列\n    initializeUpdateQueue(workInProgress);\n    // 将类组件实例设置到 workInProgress Fiber 上\n    adoptClassInstance(workInProgress, value);\n    // 挂载类组件实例，触发 `getDerivedStateFromProps` 和 `componentWillMount`\n    mountClassInstance(workInProgress, Component, props, renderLanes);\n    // 调和 ReactElement\n    return finishClassComponent(\n      null,\n      workInProgress,\n      Component,\n      true,\n      false,\n      renderLanes,\n    );\n  } else {\n    // 将 workInProgress 标记为 FunctionComponent\n    workInProgress.tag = FunctionComponent;\n    // ......\n    // 调和 ReactElement\n    reconcileChildren(null, workInProgress, value, renderLanes);\n    // 返回 child 节点\n    return workInProgress.child;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n需要注意一下几点：\n\n * 此处传入的 Component，实际上是 workInProgress.type ，在前文中我们已经了解到 Fiber.type 挂载着 fiber 所对应的 function/class/module 类型的组件，属于 Fiber 和 ReactElement 沟通的媒介。\n * 如果函数 Component 执行之后返回 object 且包含 render 方法，则会被当做类组件处理。\n * 注意：此函数只在初次渲染函数式组件或者 伪装成函数的类组件 时调用。调用之后，该组件会被判定为 ClassComponent 或者 FunctionComponent ，调用结束后返回 child 节点，以继续完成 WorkLoop 中的捕获过程。\n\n\n# mountLazyComponent\n\nmountLazyComponent 是针对 LazyComponent （延迟加载组件） 而言的，需要加载组件时本质上还是根据 beginWork 中的组件类型策略进行处理，因此此处不再赘述。Lazy 组件将在之后的章节单独探讨。\n\n提示\n\n在下文的几种类型的组件的处理中，我们需要强化两条思路，复用（简单的复用 current ChildrenFiberTree 以提前结束当前节点的捕获过程）和不复用。\n\n\n# updateFunctionComponent\n\nupdateFunctionComponent 函数调和 FunctionComponent 类型的组件（组件为函数式组件，一般非初次调和）。\n\nfunction updateFunctionComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps: any,\n  renderLanes,\n) {\n  // ......\n  // 获取 ReactChildren\n  const nextChildren = renderWithHooks(\n    current,\n    workInProgress,\n    Component,\n    nextProps,\n    undefined,\n    renderLanes,\n  );\n  // 如果非初次渲染且未接收到更新则复用 Fiber 节点，提前退出\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    // 调用 `cloneChildFibers` 复用节点，返回 child 节点\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n  // ......\n  // 调和 ReactChildren\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n从以上过程可以看出调和组件大概分为如下的步骤：\n\n 1. 获取组件的 ReactChildren。\n 2. 判断是否可以复用节点，如果可以则调用 cloneChildFibers 复用子层级节点并提前返回（返回子节点），否则则调用 reconcileChildren 重新调和子层级节点并返回子节点。\n\n\n# updateClassComponent\n\nupdateClassComponent 函数调和 ClassComponent 类型的组件（class 语法的类组件）。\n\nfunction updateClassComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps: any,\n  renderLanes: Lanes,\n) {\n  // ......\n  // 获取类组件实例\n  const instance = workInProgress.stateNode;\n  let shouldUpdate;\n  if (instance === null) {\n    // ......\n    // 若实例尚未创建，则构建组件实例，new Component(props, context)\n    constructClassInstance(workInProgress, Component, nextProps);\n    // 挂载组件，调用相关生命周期钩子\n    mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n    shouldUpdate = true;\n  } else if (current === null) {\n    // 应用加载时，如果已经有组件实例，则复用此实例，并且调用相关的生命周期钩子 `componentWillReceiveProps`、`getDerivedStateFromProps`\n    shouldUpdate = resumeMountClassInstance(\n      workInProgress,\n      Component,\n      nextProps,\n      renderLanes,\n    );\n  } else {\n    // 如果在更新阶段，且已经有组件实例，则更新组件实例，并且调用相关的生命周期函数 `componentWillReceiveProps`、`getDerivedStateFromProps`，同时更新实例的 props, state 和 context\n    shouldUpdate = updateClassInstance(\n      current,\n      workInProgress,\n      Component,\n      nextProps,\n      renderLanes,\n    );\n  }\n  // 根据 shouldUpdate 决定是否需要复用节点，reconcileChildren 或者 cloneChildFibers，并返回子节点\n  const nextUnitOfWork = finishClassComponent(\n    current,\n    workInProgress,\n    Component,\n    shouldUpdate,\n    false,\n    renderLanes,\n  );\n  // ......\n  return nextUnitOfWork;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n这里根据 instance 和 current 分成了 3 种情况，如下：\n\n阶段 / 有无实例   无实例                                有实例\nmount       构建实例，挂载实例（应用初始化，mount 钩子）          复用实例（update 钩子）\nupdate      构建实例，挂载实例（suspended 组件，mount 钩子）   更新实例（update 钩子）\n\n挂载或者更新完组件实例之后，根据 shouldUpdate 判断是否可以复用节点，复用则调用 cloneChildFibers ，否则调用 reconcileChildren （与 FunctionComponent 一致）。\n\n\n# updateHostRoot\n\nupdateHostRoot 处理 HostRootFiber 节点（FiberTree 的根节点，与 FiberRoot 容器双向链接）的调和过程。\n\nfunction updateHostRoot(current, workInProgress, renderLanes) {\n  // ......\n  const nextProps = workInProgress.pendingProps;\n  const prevChildren = workInProgress.memoizedState.element;\n  // 从 current 上复制 updateQueue 到 workInProgress\n  cloneUpdateQueue(current, workInProgress);\n  // 消费 workInProgress 上的 updateQueue 更新 workInProgress.memoizedState\n  processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n  const nextChildren = workInProgress.memoizedState.element;\n  // 判断消费 updateQueue 之后 children 是否发生了变化，如果没有发生变化则复用节点，否则重新调和子树，并返回子节点\n  if (nextChildren === prevChildren) {\n    // ......\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n  // ......\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  // ...... \n  return workInProgress.child;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * cloneUpdateQueue 从 current 复制 updateQueue 到 workInProgress ，以确保 processUpdateQueue 在处理时并不是直接在 current 上操作。 processUpdateQueue reduce updateQueue 中的 update，并且获得最新的 state 和 effect。\n * 在处理 updateQueue 前后，判断 children 是否发生变化，如未发生变化可直接复用节点。\n\n\n# updateHostComponent\n\nHostComponent 指原生的 HTML 节点。 updateHostComponent 调和原生的 HTML 节点。\n\nfunction updateHostComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n) {\n  // ......\n  const type = workInProgress.type;\n  const nextProps = workInProgress.pendingProps;\n  const prevProps = current !== null ? current.memoizedProps : null;\n  let nextChildren = nextProps.children;\n  // 判断该节点是否应该直接设置文本内容，如 textarea, noscript 等，对于此类节点不需要再建立 nextChildren \n  // 为 HostText 以节省性能\n  const isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    nextChildren = null;\n  // 如果原节点存在，原来是 DirectTextChild，现在不是了，标记 ContentReset，表示重置文本内容\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n    workInProgress.flags |= ContentReset;\n  }\n  // ......\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 对于 HostComponent 而言不需要复用节点，一律重新调和节点。\n\n\n# updateHostText\n\nupdateHostText 调和 HostText 节点。\n\nfunction updateHostText(current, workInProgress) {\n  // ......\n  return null;\n}\n\n\n1\n2\n3\n4\n\n\n文本节点一定是叶子节点，因此不需要再调和 children。注意：这里返回 null，会使捕获过程暂时结束，在 performUnitOfWork 函数中，会进而转入冒泡阶段。\n\n\n# 扩展\n\n\n# 问题\n\n\n# Component 即 workInProgress.type 是如何初始化的？\n\n在应用挂载阶段， Component 所对应的 FiberNode 是在 prepareFreshStack 函数中创建的，参见 workInProgress 是如何初始化的？，而具体的 Fiber.type 的初始化请参见 React 首次渲染过程解读。\n\n\n# mountIndeterminateComponent 为什么都能够执行 Component(props, context) ?\n\n在 mountIndeterminateComponent 是有做类组件和函数式组件的判断的，那么大家可能会有这样的疑问，类组件时 class ，应该是无法被执行的才对？ class 定义的类组件确实无法被执行，但是并非所有的类组件都是 class 定义的、都是无法执行的。\n\n * 利用 class 写类组件只是一种语法糖，并非只有这一种写法。其实，类组件还可以这样写：\n\nfunction TestIndeterminateComponent() {\n  return {\n    componentDidMount() {\n      console.log('componentDidMount')\n    },\n    state: { count: 1 },\n    updateCount() {\n     const { count } = this.state;\n     this.updater.enqueueSetState(\n      this,\n      { count: count + 1 },\n      undefined,\n      \"setState\"\n     );\n    },\n    render() {\n     return <div onClick={() => this.updateCount()}>{this.state.count}</div>;\n    },\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n我们可能注意到，在 mountIndeterminateComponent 判断为 function 语法的类组件 （暂时这样称呼）之后，相比于函数式组件，多出 initializeUpdateQueue 、 adoptClassInstance 、 mountClassInstance 的步骤，实际上是为了挂载相关的属性、调用声明周期钩子等以完成完成的类组件的行为。注意一下以下几点：\n\n * 类组件继承自 React.component 实际上是语法糖的实现，帮助我们初始化组件的必要属性如 props、state、updater 等，并且实现 setState 、 forceUpdate 等方法。（参见源码文件 src/react/packages/react/src/ReactBaseClasses.js ）\n * mountIndeterminateComponent 只在首次渲染时处理函数式组件或者像如上这种 伪装成函数式组件的类组件 。\n\n\n# 总结\n\n * 本文介绍了常用的组件类型的捕获过程。主要分成一下 3 个主要步骤：获取 Component 的 nextChildren ；采用一定的复用策略判断是否可以复用子节点调和过程，如果可以则通过复用子层级节点提前进入下一层的捕获，否则则重新调和子层级节点；返回 workInProgress.child 继续捕获过程。\n * beginWork 的返回值有两种情况：返回当前节点的子节点，然后会以该子节点作为下个工作单元继续 beginWork ，不断往下生成 fiber 节点，构建 workInProgress 树（捕获）；返回 null，当前 fiber 子树的遍历就此终止，从当前 fiber 节点开始往回进行 completeWork （冒泡）。\n * beginWork 主要作用就是针对当前捕获到的节点进行处理，并且返回子节点继续捕获，捕获过程中逐渐创建 workInProgress FiberTree。\n * 本文只是探讨 beginWork 的大致流程，具体的流程会在后文继续分析，包括状态的更新，fiber 的 diff 算法等。",normalizedContent:"# 目录\n\n\n\n * 目录\n * 前言\n * beginwork\n   * didreceiveupdate\n   * beginwork\n * mountindeterminatecomponent\n * mountlazycomponent\n * updatefunctioncomponent\n * updateclasscomponent\n * updatehostroot\n * updatehostcomponent\n * updatehosttext\n * 扩展\n * 问题\n   * component 即 workinprogress.type 是如何初始化的？\n   * mountindeterminatecomponent为什么都能够执行 component(props, context)?\n * 总结\n\n\n\n\n# 前言\n\n在上一篇文章中，我们探讨了 react 调和器中 renderrootsync 、 renderrootconcurrent 、 workloopsync 、 workloopconcurrent 、 performunitofwork 5 个核心函数，整体过程偏于梗概和流程，虽然过程较为简单，但是对于理解整体调和的过程却是至关重要的。因此，上文与本文的衔接较为紧密。\n\n先回顾一下上文的情节，5 个函数，从 render 阶段的开始，到 workloop 的启动，再到 performunitofwork 的具体的调和工作，整个调和过程其实比较清晰。在以下几篇文章中，将着重分析调和中的捕获和冒泡过程，即单个 fiber 节点的调和过程。\n\n注意\n\n因篇幅限制，本文只探讨重要类型的组件的调和过程的梗概，具体组件的调和过程细节不探讨，后文详述。\n\n\n# beginwork\n\n从整体上看， beginwork 是根据 workinprogress fiber 的类型，而决定采取不同的 mount 或者 update 的策略。\n\n\n# didreceiveupdate\n\ndidreceiveupdate 对于理解这部分代码很重要，因此我们先来分析下 didreceiveupdate 的含义和意义。 didreceiveupdate 表示是否接收到变化（更新），如果未接收到更新则可以复用 fiber 节点（意思是复用下一级的子节点提前返回 null 阻断后续的捕获过程）。\n\n简化代码如下：\n\nif (current !== null) {\n    const oldprops = current.memoizedprops;\n    const newprops = workinprogress.pendingprops;\n    if (oldprops !== newprops) {\n      // 如果有 props 变化，则标记接收到更新\n      didreceiveupdate = true;\n    } else {\n      // ......\n      didreceiveupdate = false;\n    }\n  } else {\n    didreceiveupdate = false;\n    // ......\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n分析如下：\n\n * 参数含义：通过上文中的探讨，我们可以明了的是： current 表示 current fibertree 的 fibernode，是已经渲染过的节点； workinprogress 是 workinprogress fibertree 的 fibernode，是即将要被渲染的节点。\n * current === null 可以区分 mount 阶段和 update 阶段（注意：这里不是指调和的阶段，而是指从 react 的应用的渲染周期来看，包含初次渲染即 mount 阶段和更新渲染即 update 阶段）。\n\n注意\n\n这里为什么比较 props 的引用而不是浅比较呢？为什么在执行 component 之前需要比较 props? 在 performunitofwork 中 unitofwork.memoizedprops = unitofwork.pendingprops 中有如下代码，那次此处 oldprops 大概率会与 newprops 相等？\n\n弄清楚 didreceiveupdate 含义和复用节点的条件之后，下面我们再具体探讨 beginwork 的内容。\n\n\n# beginwork\n\n注意\n\n以下代码只保留了核心内容，细节内容有删改。\n\n// src/react/packages/react-reconciler/src/reactfiberbeginwork.new.js\nfunction beginwork(\n  current: fiber | null,\n  workinprogress: fiber,\n  renderlanes: lanes,\n): fiber | null {\n  switch (workinprogress.tag) {\n    case indeterminatecomponent: \n      return mountindeterminatecomponent(/*......*/);\n    case lazycomponent: \n      return mountlazycomponent(/*......*/);\n    case functioncomponent: \n      return updatefunctioncomponent(/*......*/);\n    case classcomponent: \n      return updateclasscomponent(/*......*/);\n    case hostroot:\n      return updatehostroot(/*......*/);\n    case hostcomponent:\n      return updatehostcomponent(/*......*/);\n    case hosttext:\n      return updatehosttext(/*......*/);\n    case suspensecomponent:\n      return updatesuspensecomponent(/*......*/);\n    case hostportal:\n      return updateportalcomponent(/*......*/);\n    case forwardref: \n      return updateforwardref(/*......*/);\n    case fragment:\n      return updatefragment(/*......*/);\n    // ......\n    case contextprovider:\n      return updatecontextprovider(/*......*/);\n    case contextconsumer:\n      return updatecontextconsumer(/*......*/);\n    case memocomponent: \n      return updatememocomponent(/*......*/);\n    case simplememocomponent: \n      return updatesimplememocomponent(/*......*/);\n    case incompleteclasscomponent: \n      return mountincompleteclasscomponent(/*......*/);\n    // ......\n    case offscreencomponent: \n      return updateoffscreencomponent(/*......*/);\n    // ......\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# mountindeterminatecomponent\n\n此函数针对首次渲染时的未知类型的组件（并且是立即挂载的组件）进行判断，区分函数式组件和 伪装成函数的类组件 进行相关处理，并且调和 reactchildren（本质上是 reactelement）。\n\n源码如下:\n\n// src/react/packages/react-reconciler/src/reactfiberbeginwork.new.js\nfunction mountindeterminatecomponent(\n  _current,\n  workinprogress,\n  component,\n  renderlanes,\n) {\n  // ......\n  const props = workinprogress.pendingprops;\n  // 清理 workinprogress context，即 workinprogress.dependencies.firstcontext = null\n  preparetoreadcontext(workinprogress, renderlanes);\n  // 执行 component 并获得返回值，如果是类组件，value 是组件实例\n  const value = component(props, context)\n\n  // 判断是否是合法的类组件\n  if (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.render === 'function' &&\n    value.$$typeof === undefined\n  ) {\n    // 将 workinprogress 标记为类组件\n    workinprogress.tag = classcomponent;\n    workinprogress.updatequeue = null;\n    // ......\n    // 更新 state\n    workinprogress.memoizedstate =\n      value.state !== null && value.state !== undefined ? value.state : null;\n    // 初始化 state 更新队列\n    initializeupdatequeue(workinprogress);\n    // 将类组件实例设置到 workinprogress fiber 上\n    adoptclassinstance(workinprogress, value);\n    // 挂载类组件实例，触发 `getderivedstatefromprops` 和 `componentwillmount`\n    mountclassinstance(workinprogress, component, props, renderlanes);\n    // 调和 reactelement\n    return finishclasscomponent(\n      null,\n      workinprogress,\n      component,\n      true,\n      false,\n      renderlanes,\n    );\n  } else {\n    // 将 workinprogress 标记为 functioncomponent\n    workinprogress.tag = functioncomponent;\n    // ......\n    // 调和 reactelement\n    reconcilechildren(null, workinprogress, value, renderlanes);\n    // 返回 child 节点\n    return workinprogress.child;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n需要注意一下几点：\n\n * 此处传入的 component，实际上是 workinprogress.type ，在前文中我们已经了解到 fiber.type 挂载着 fiber 所对应的 function/class/module 类型的组件，属于 fiber 和 reactelement 沟通的媒介。\n * 如果函数 component 执行之后返回 object 且包含 render 方法，则会被当做类组件处理。\n * 注意：此函数只在初次渲染函数式组件或者 伪装成函数的类组件 时调用。调用之后，该组件会被判定为 classcomponent 或者 functioncomponent ，调用结束后返回 child 节点，以继续完成 workloop 中的捕获过程。\n\n\n# mountlazycomponent\n\nmountlazycomponent 是针对 lazycomponent （延迟加载组件） 而言的，需要加载组件时本质上还是根据 beginwork 中的组件类型策略进行处理，因此此处不再赘述。lazy 组件将在之后的章节单独探讨。\n\n提示\n\n在下文的几种类型的组件的处理中，我们需要强化两条思路，复用（简单的复用 current childrenfibertree 以提前结束当前节点的捕获过程）和不复用。\n\n\n# updatefunctioncomponent\n\nupdatefunctioncomponent 函数调和 functioncomponent 类型的组件（组件为函数式组件，一般非初次调和）。\n\nfunction updatefunctioncomponent(\n  current,\n  workinprogress,\n  component,\n  nextprops: any,\n  renderlanes,\n) {\n  // ......\n  // 获取 reactchildren\n  const nextchildren = renderwithhooks(\n    current,\n    workinprogress,\n    component,\n    nextprops,\n    undefined,\n    renderlanes,\n  );\n  // 如果非初次渲染且未接收到更新则复用 fiber 节点，提前退出\n  if (current !== null && !didreceiveupdate) {\n    bailouthooks(current, workinprogress, renderlanes);\n    // 调用 `clonechildfibers` 复用节点，返回 child 节点\n    return bailoutonalreadyfinishedwork(current, workinprogress, renderlanes);\n  }\n  // ......\n  // 调和 reactchildren\n  reconcilechildren(current, workinprogress, nextchildren, renderlanes);\n  return workinprogress.child;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n从以上过程可以看出调和组件大概分为如下的步骤：\n\n 1. 获取组件的 reactchildren。\n 2. 判断是否可以复用节点，如果可以则调用 clonechildfibers 复用子层级节点并提前返回（返回子节点），否则则调用 reconcilechildren 重新调和子层级节点并返回子节点。\n\n\n# updateclasscomponent\n\nupdateclasscomponent 函数调和 classcomponent 类型的组件（class 语法的类组件）。\n\nfunction updateclasscomponent(\n  current: fiber | null,\n  workinprogress: fiber,\n  component: any,\n  nextprops: any,\n  renderlanes: lanes,\n) {\n  // ......\n  // 获取类组件实例\n  const instance = workinprogress.statenode;\n  let shouldupdate;\n  if (instance === null) {\n    // ......\n    // 若实例尚未创建，则构建组件实例，new component(props, context)\n    constructclassinstance(workinprogress, component, nextprops);\n    // 挂载组件，调用相关生命周期钩子\n    mountclassinstance(workinprogress, component, nextprops, renderlanes);\n    shouldupdate = true;\n  } else if (current === null) {\n    // 应用加载时，如果已经有组件实例，则复用此实例，并且调用相关的生命周期钩子 `componentwillreceiveprops`、`getderivedstatefromprops`\n    shouldupdate = resumemountclassinstance(\n      workinprogress,\n      component,\n      nextprops,\n      renderlanes,\n    );\n  } else {\n    // 如果在更新阶段，且已经有组件实例，则更新组件实例，并且调用相关的生命周期函数 `componentwillreceiveprops`、`getderivedstatefromprops`，同时更新实例的 props, state 和 context\n    shouldupdate = updateclassinstance(\n      current,\n      workinprogress,\n      component,\n      nextprops,\n      renderlanes,\n    );\n  }\n  // 根据 shouldupdate 决定是否需要复用节点，reconcilechildren 或者 clonechildfibers，并返回子节点\n  const nextunitofwork = finishclasscomponent(\n    current,\n    workinprogress,\n    component,\n    shouldupdate,\n    false,\n    renderlanes,\n  );\n  // ......\n  return nextunitofwork;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n这里根据 instance 和 current 分成了 3 种情况，如下：\n\n阶段 / 有无实例   无实例                                有实例\nmount       构建实例，挂载实例（应用初始化，mount 钩子）          复用实例（update 钩子）\nupdate      构建实例，挂载实例（suspended 组件，mount 钩子）   更新实例（update 钩子）\n\n挂载或者更新完组件实例之后，根据 shouldupdate 判断是否可以复用节点，复用则调用 clonechildfibers ，否则调用 reconcilechildren （与 functioncomponent 一致）。\n\n\n# updatehostroot\n\nupdatehostroot 处理 hostrootfiber 节点（fibertree 的根节点，与 fiberroot 容器双向链接）的调和过程。\n\nfunction updatehostroot(current, workinprogress, renderlanes) {\n  // ......\n  const nextprops = workinprogress.pendingprops;\n  const prevchildren = workinprogress.memoizedstate.element;\n  // 从 current 上复制 updatequeue 到 workinprogress\n  cloneupdatequeue(current, workinprogress);\n  // 消费 workinprogress 上的 updatequeue 更新 workinprogress.memoizedstate\n  processupdatequeue(workinprogress, nextprops, null, renderlanes);\n  const nextchildren = workinprogress.memoizedstate.element;\n  // 判断消费 updatequeue 之后 children 是否发生了变化，如果没有发生变化则复用节点，否则重新调和子树，并返回子节点\n  if (nextchildren === prevchildren) {\n    // ......\n    return bailoutonalreadyfinishedwork(current, workinprogress, renderlanes);\n  }\n  // ......\n  reconcilechildren(current, workinprogress, nextchildren, renderlanes);\n  // ...... \n  return workinprogress.child;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * cloneupdatequeue 从 current 复制 updatequeue 到 workinprogress ，以确保 processupdatequeue 在处理时并不是直接在 current 上操作。 processupdatequeue reduce updatequeue 中的 update，并且获得最新的 state 和 effect。\n * 在处理 updatequeue 前后，判断 children 是否发生变化，如未发生变化可直接复用节点。\n\n\n# updatehostcomponent\n\nhostcomponent 指原生的 html 节点。 updatehostcomponent 调和原生的 html 节点。\n\nfunction updatehostcomponent(\n  current: fiber | null,\n  workinprogress: fiber,\n  renderlanes: lanes,\n) {\n  // ......\n  const type = workinprogress.type;\n  const nextprops = workinprogress.pendingprops;\n  const prevprops = current !== null ? current.memoizedprops : null;\n  let nextchildren = nextprops.children;\n  // 判断该节点是否应该直接设置文本内容，如 textarea, noscript 等，对于此类节点不需要再建立 nextchildren \n  // 为 hosttext 以节省性能\n  const isdirecttextchild = shouldsettextcontent(type, nextprops);\n\n  if (isdirecttextchild) {\n    nextchildren = null;\n  // 如果原节点存在，原来是 directtextchild，现在不是了，标记 contentreset，表示重置文本内容\n  } else if (prevprops !== null && shouldsettextcontent(type, prevprops)) {\n    workinprogress.flags |= contentreset;\n  }\n  // ......\n  reconcilechildren(current, workinprogress, nextchildren, renderlanes);\n  return workinprogress.child;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n * 对于 hostcomponent 而言不需要复用节点，一律重新调和节点。\n\n\n# updatehosttext\n\nupdatehosttext 调和 hosttext 节点。\n\nfunction updatehosttext(current, workinprogress) {\n  // ......\n  return null;\n}\n\n\n1\n2\n3\n4\n\n\n文本节点一定是叶子节点，因此不需要再调和 children。注意：这里返回 null，会使捕获过程暂时结束，在 performunitofwork 函数中，会进而转入冒泡阶段。\n\n\n# 扩展\n\n\n# 问题\n\n\n# component 即 workinprogress.type 是如何初始化的？\n\n在应用挂载阶段， component 所对应的 fibernode 是在 preparefreshstack 函数中创建的，参见 workinprogress 是如何初始化的？，而具体的 fiber.type 的初始化请参见 react 首次渲染过程解读。\n\n\n# mountindeterminatecomponent 为什么都能够执行 component(props, context) ?\n\n在 mountindeterminatecomponent 是有做类组件和函数式组件的判断的，那么大家可能会有这样的疑问，类组件时 class ，应该是无法被执行的才对？ class 定义的类组件确实无法被执行，但是并非所有的类组件都是 class 定义的、都是无法执行的。\n\n * 利用 class 写类组件只是一种语法糖，并非只有这一种写法。其实，类组件还可以这样写：\n\nfunction testindeterminatecomponent() {\n  return {\n    componentdidmount() {\n      console.log('componentdidmount')\n    },\n    state: { count: 1 },\n    updatecount() {\n     const { count } = this.state;\n     this.updater.enqueuesetstate(\n      this,\n      { count: count + 1 },\n      undefined,\n      \"setstate\"\n     );\n    },\n    render() {\n     return <div onclick={() => this.updatecount()}>{this.state.count}</div>;\n    },\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n我们可能注意到，在 mountindeterminatecomponent 判断为 function 语法的类组件 （暂时这样称呼）之后，相比于函数式组件，多出 initializeupdatequeue 、 adoptclassinstance 、 mountclassinstance 的步骤，实际上是为了挂载相关的属性、调用声明周期钩子等以完成完成的类组件的行为。注意一下以下几点：\n\n * 类组件继承自 react.component 实际上是语法糖的实现，帮助我们初始化组件的必要属性如 props、state、updater 等，并且实现 setstate 、 forceupdate 等方法。（参见源码文件 src/react/packages/react/src/reactbaseclasses.js ）\n * mountindeterminatecomponent 只在首次渲染时处理函数式组件或者像如上这种 伪装成函数式组件的类组件 。\n\n\n# 总结\n\n * 本文介绍了常用的组件类型的捕获过程。主要分成一下 3 个主要步骤：获取 component 的 nextchildren ；采用一定的复用策略判断是否可以复用子节点调和过程，如果可以则通过复用子层级节点提前进入下一层的捕获，否则则重新调和子层级节点；返回 workinprogress.child 继续捕获过程。\n * beginwork 的返回值有两种情况：返回当前节点的子节点，然后会以该子节点作为下个工作单元继续 beginwork ，不断往下生成 fiber 节点，构建 workinprogress 树（捕获）；返回 null，当前 fiber 子树的遍历就此终止，从当前 fiber 节点开始往回进行 completework （冒泡）。\n * beginwork 主要作用就是针对当前捕获到的节点进行处理，并且返回子节点继续捕获，捕获过程中逐渐创建 workinprogress fibertree。\n * 本文只是探讨 beginwork 的大致流程，具体的流程会在后文继续分析，包括状态的更新，fiber 的 diff 算法等。",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"React 源码漂流记：React 调和器核心源码解读（五）",frontmatter:{title:"React 源码漂流记：React 调和器核心源码解读（五）",date:"2022-07-25T12:02:21.000Z",permalink:"/react/tour/react-reconciliation-5/",categories:["react","React源码漂流记"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/130.react-reconciliation-5.html",relativePath:"10.react/90.React源码漂流记/130.react-reconciliation-5.md",key:"v-620e1d82",path:"/react/tour/react-reconciliation-5/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:17},{level:2,title:"bailoutOnAlreadyFinishedWork",slug:"bailoutonalreadyfinishedwork",normalizedTitle:"bailoutonalreadyfinishedwork",charIndex:23},{level:2,title:"cloneChildFibers",slug:"clonechildfibers",normalizedTitle:"clonechildfibers",charIndex:55},{level:2,title:"reconcileChildren",slug:"reconcilechildren",normalizedTitle:"reconcilechildren",charIndex:75},{level:2,title:"reconcileChildFibers",slug:"reconcilechildfibers",normalizedTitle:"reconcilechildfibers",charIndex:96},{level:2,title:"reconcileChildrenArray",slug:"reconcilechildrenarray",normalizedTitle:"reconcilechildrenarray",charIndex:120},{level:2,title:"reconcileSingleElement",slug:"reconcilesingleelement",normalizedTitle:"reconcilesingleelement",charIndex:146},{level:2,title:"reconcileSingleTextNode",slug:"reconcilesingletextnode",normalizedTitle:"reconcilesingletextnode",charIndex:172},{level:2,title:"placeSingleChild",slug:"placesinglechild",normalizedTitle:"placesinglechild",charIndex:199},{level:2,title:"updateSlot",slug:"updateslot",normalizedTitle:"updateslot",charIndex:219},{level:2,title:"updateFromMap",slug:"updatefrommap",normalizedTitle:"updatefrommap",charIndex:233},{level:2,title:"placeChild",slug:"placechild",normalizedTitle:"placechild",charIndex:250},{level:2,title:"deleteChild",slug:"deletechild",normalizedTitle:"deletechild",charIndex:264},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:279},{level:3,title:"函数式组件和类组件在 reconcileChildren 之前做了什么？",slug:"函数式组件和类组件在-reconcilechildren-之前做了什么",normalizedTitle:"函数式组件和类组件在 reconcilechildren 之前做了什么？",charIndex:287},{level:3,title:"workInProgress Tree 是如何初始化的？",slug:"workinprogress-tree-是如何初始化的",normalizedTitle:"workinprogress tree 是如何初始化的？",charIndex:329},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:361},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:367},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:373}],readingTime:{text:"9 min read",minutes:8.96,time:537600,words:1792},headersStr:"目录 前言 bailoutOnAlreadyFinishedWork cloneChildFibers reconcileChildren reconcileChildFibers reconcileChildrenArray reconcileSingleElement reconcileSingleTextNode placeSingleChild updateSlot updateFromMap placeChild deleteChild 扩展 函数式组件和类组件在 reconcileChildren 之前做了什么？ workInProgress Tree 是如何初始化的？ 问题 总结 参考",content:"# 目录\n\n\n\n * 目录\n * 前言\n * bailoutOnAlreadyFinishedWork\n * cloneChildFibers\n * reconcileChildren\n * reconcileChildFibers\n * reconcileChildrenArray\n * reconcileSingleElement\n * reconcileSingleTextNode\n * placeSingleChild\n * updateSlot\n * updateFromMap\n * placeChild\n * deleteChild\n * 扩展\n   * 函数式组件和类组件在 reconcileChildren 之前做了什么？\n   * workInProgress Tree 是如何初始化的？\n * 问题\n * 总结\n * 参考\n\n\n\n\n# 前言\n\n在上文中，我们探讨了在 beginWork 函数中针对不同的类型（内部类型）的 React 组件所采取的不同的调和策略：复用和重新调和。在本文中，我们继续来探讨在捕获阶段中组件的复用机制以及组件的具体的调和过程。本文将主要围绕着 cloneChildFibers 和 reconcileChildren 两个核心函数展开探讨。\n\n\n# bailoutOnAlreadyFinishedWork\n\n通过上文分析，我们已经了解了无论是函数式组件还是类组件，在提前退出时都是调用 bailoutOnAlreadyFinishedWork 函数。要想深入了解 cloneChildFibers 的作用，我们可能要先了解此函数的原理。\n\n// src/react/packages/react-reconciler/src/ReactFiberBeginWork.new.js\nfunction bailoutOnAlreadyFinishedWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  // ......\n  markSkippedUpdateLanes(workInProgress.lanes);\n\n  // Check if the children have any pending work.\n  // 检查子树是否有相应的更新，通过 childLanes 判断，如果没有更新，则可以提前结束子树的捕获过程，并开始向上冒泡\n  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n    // The children don't have any work either. We can skip them.\n    return null;\n  }\n  // This fiber doesn't have work, but its subtree does. Clone the child\n  // fibers and continue.\n  // 子树有更新，复制子树的 fibers 并返回子节点继续捕获\n  cloneChildFibers(current, workInProgress);\n  return workInProgress.child;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n分析如下：\n\n * markSkippedUpdateLanes 函数将本次渲染期间累计的未处理的更新的 lanes 合并到 workInProgress.lanes 中。这是因为在调度到真正渲染期间，可能会有新的 lanes 被收集到。\n * 这里有一个性能的优化，如果 renderLanes 中不包含 workInProgress 节点的 childLanes ，即子 FiberTree 没有更新，则可以通过返回 null ，提前结束捕获。\n\n\n# cloneChildFibers\n\n此函数将复用当前 Fiber 节点的所有下级子节点。\n\nexport function cloneChildFibers(\n  current: Fiber | null,\n  workInProgress: Fiber,\n): void {\n  // ......\n  let currentChild = workInProgress.child;\n  let newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n  workInProgress.child = newChild;\n  newChild.return = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(\n      currentChild,\n      currentChild.pendingProps,\n    );\n    newChild.return = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n下图是相关的数据结构的操作逻辑：\n\n分析如下：\n\n * createWorkInProgress 创建新的 workInProgress fiber 节点，并复用 current FiberNode 的属性（如果 workInProgress 节点是悬空的，则创建 Fiber 节点，见 createFiber 函数）。\n * newChild 指针不断向兄弟节点移动，直至遍历完所有的兄弟节点。\n\n\n# reconcileChildren\n\n此函数根据是否是首次渲染而决定是否追踪副作用，并且调用相应的函数对姐姐点进行调和。\n\nexport function reconcileChildren(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  nextChildren: any,\n  renderLanes: Lanes,\n) {\n  if (current === null) {\n    workInProgress.child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderLanes,\n    );\n  } else {\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      current.child,\n      nextChildren,\n      renderLanes,\n    );\n  }\n}\n\nconst reconcileChildFibers = ChildReconciler(true);\nconst mountChildFibers = ChildReconciler(false);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n分析如下：\n\n * 如果是首次渲染，则不必追踪副作用，调用 mountChildFibers ，否则则调用 reconcileChildFibers 。主要这两个函数都是调用包装函数 ChildReconciler 实现的。\n * reconcileChildren 调和子节点，并赋值给 workInProgress.child 。\n\n\n# reconcileChildFibers\n\n此函数对 workInProgress 节点的 children 节点进行调和，并且标记副作用。\n\n// src/react/packages/react-reconciler/src/ReactChildFiber.new.js\n// This API will tag the children with the side-effect of the reconciliation\n// itself. They will be added to the side-effect list as we pass through the\n// children and the parent.\nfunction reconcileChildFibers(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  newChild: any,\n  lanes: Lanes,\n): Fiber | null {\n  // 处理 Element Fragment 解包装，类型为 REACT_FRAGMENT_TYPE\n  const isUnkeyedTopLevelFragment =\n    typeof newChild === 'object' &&\n    newChild !== null &&\n    newChild.type === REACT_FRAGMENT_TYPE &&\n    newChild.key === null;\n  if (isUnkeyedTopLevelFragment) {\n    newChild = newChild.props.children;\n  }\n\n  // 非文本节点，包括数组和迭代器\n  if (typeof newChild === 'object' && newChild !== null) {\n    switch (newChild.$$typeof) {\n      case REACT_ELEMENT_TYPE:\n        return placeSingleChild(reconcileSingleElement(/*...*/));\n      case REACT_PORTAL_TYPE:\n        return placeSingleChild(reconcileSinglePortal(/*...*/));\n      case REACT_LAZY_TYPE:\n        return reconcileChildFibers(/*...*/);\n    }\n\n    if (isArray(newChild)) {\n      return reconcileChildrenArray(/*...*/);\n    }\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(/*...*/);\n    }\n    // ......\n  }\n  // 如果是文本节点\n  if (\n    (typeof newChild === 'string' && newChild !== '') ||\n    typeof newChild === 'number'\n  ) {\n    return placeSingleChild(reconcileSingleTextNode(/*...*/));\n  }\n\n  // 如果不符合上述情况，视为清空子节点\n  return deleteRemainingChildren(returnFiber, currentFirstChild);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n分析如下：\n\n * 明确 newChild 是什么？ newChild 本质上是 ReactElement，是 React.createElement 语法糖创建出来的对象，具体的结构可见参见 ReactElement 与基础概念。\n * React.Fragment 解包装之后成为节点链表。\n * 本函数处理合法的节点类型（注意，此处不是 Fiber 类型，而是 ReactElement 类型，根据 ReactElement.$$typeof 判断）：普通 Element、Portal、Lazy 节点、节点链表、节点迭代器、文本节点，其余的形式均视为非法清空所有子节点。\n * 从整体来看，子节点的处理分成两步：调和（reconcile）和置位（place）。调和的过程就是创建 workInProgress FiberTree 的 Fiber 节点的过程，而置位就是进行副作用标记的过程。\n * 对于 Lazy 节点，即延迟加载的节点，解包装出延迟的组件后，递归调用自身即可。\n * 注意： reconcileChildFibers 返回调和后的第一个子节点。\n * reconcileChildFibers 实现了从 ReactElement 到 Fiber 的飞跃。从入参 newChild 是 ReactElement，到返回值为 Fiber 可见一斑。\n\n下面我们分别来探讨下 Element 节点链表、 REACT_ELEMENT_TYPE 单一节点和 Element 文本节点的具体原理。\n\n\n# reconcileChildrenArray\n\n此函数对同级子节点应用 DIFF 算法，目的是通过 DIFF 算法根据 current Fiber 和 ReactElement 高效的创建 workInProgress Fiber。此过程可视为节点链表的调和过程。\n\n注意\n\n相关简写：\n\n * 原链表：current 节点链表。\n * 新数组：ReactElement 节点数组。\n * 原节点：current 节点链表中对应位置的节点（Fiber）。\n * 新节点：ReactElement 节点链表中对应位置的节点（ReactElement）。\n * 结果节点：经过 DIFF 后要置位于对应位置的节点（Fiber）。\n\n具体过程如下：\n\n// src/react/packages/react-reconciler/src/ReactChildFiber.new.js\nfunction reconcileChildrenArray(\n  // workInProgress Fiber\n  returnFiber: Fiber,\n  // current Fiber 上的第一个子节点\n  currentFirstChild: Fiber | null,\n  // 当前调和中的 ReactElement\n  newChildren: Array<*>,\n  // 调和节点的优先级\n  lanes: Lanes,\n): Fiber | null {\n  // ......\n  // 调和后的第一个子节点\n  let resultingFirstChild: Fiber | null = null;\n  // 上一个被置位的结果节点\n  let previousNewFiber: Fiber | null = null;\n  // 原节点指针，指向 current 节点链表中的节点\n  let oldFiber = currentFirstChild;\n  // 上一次置位的下标\n  let lastPlacedIndex = 0;\n  let newIdx = 0;\n  // 下一轮要比较的原节点指针\n  let nextOldFiber = null;\n  // 以下取原链表和新数组较短的长度的部分进行 DIFF（循环原链表和新数组，知道两者之一没有更多节点）\n  for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n    // 如果原节点的下标与当前置位的下标不一致，说明可能是在原节点的前面添加了新节点，因此\n    // 将原节点推迟到下一次比较，本次比较原节点则悬空\n    if (oldFiber.index > newIdx) {\n      nextOldFiber = oldFiber;\n      oldFiber = null;\n    } else {\n      // 如果下标一致，则下一个要比较的原节点则为当前原节点的兄弟节点\n      nextOldFiber = oldFiber.sibling;\n    }\n    // 根据当前比较，尝试从原链表中复用节点。\n    // 根据 children 的类型进行匹配，如果 key 值匹配则返回结果节点，否则返回 null。\n    const newFiber = updateSlot(\n      returnFiber,\n      // 本次比较的原节点，可能是 null\n      oldFiber,\n      // 本次比较的新节点\n      newChildren[newIdx],\n      lanes,\n    );\n    // 如果没有节点可复用，则跳出循环\n    if (newFiber === null) {\n      if (oldFiber === null) {\n        oldFiber = nextOldFiber;\n      }\n      break;\n    }\n    // 如果节点可以复用，且非初次渲染，原节点存在且未与新节点建立链接，则删除原节点\n    if (shouldTrackSideEffects) {\n      if (oldFiber && newFiber.alternate === null) {\n        deleteChild(returnFiber, oldFiber);\n      }\n    }\n    // 将更新后的新节点置位\n    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n    // 首个结果节点链接在 resultingFirstChild 上，后续结果结果连接在上个节点的 sibling 指针上\n    if (previousNewFiber === null) {\n      resultingFirstChild = newFiber;\n    } else {\n      previousNewFiber.sibling = newFiber;\n    }\n    previousNewFiber = newFiber;\n    // 原节点指针移动到下一个原节点\n    oldFiber = nextOldFiber;\n  }\n  // 如果经过上述复用之后已经没有更多新节点，DIFF 结束，删除剩余的原节点，并返回结果节点首节点\n  if (newIdx === newChildren.length) {\n    deleteRemainingChildren(returnFiber, oldFiber);\n    // ......\n    return resultingFirstChild;\n  }\n  // 如果没有更多原节点，后续结果无需 DIFF，可直接置位，并返回结果节点首节点\n  if (oldFiber === null) {\n    // 循环剩余的新节点\n    for (; newIdx < newChildren.length; newIdx++) {\n      // 根据新节点创建子节点\n      const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\n      if (newFiber === null) {\n        continue;\n      }\n      // 对子节点进行置位\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      // 将子节点链接到结果节点链表\n      if (previousNewFiber === null) {\n        resultingFirstChild = newFiber;\n      } else {\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n    }\n    // ......\n    return resultingFirstChild;\n  }\n\n  // 如果经过上述 DIFF，原节点和新节点均有剩余，说明提前退出了 DIFF 过程（遇到 key 值不匹配）\n  // 则更换 DIFF 策略，采用节点池的方式复用节点\n  const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n  // 循环剩余的待置位的新节点，寻求节点复用\n  for (; newIdx < newChildren.length; newIdx++) {\n    // 尝试从节点池复用节点\n    // 注意：这里仍然是 key 值匹配才可以复用，如果匹配不到则创建节点\n    const newFiber = updateFromMap(\n      existingChildren,\n      returnFiber,\n      newIdx,\n      newChildren[newIdx],\n      lanes,\n    );\n    // 如果有可复用节点（或者创建出节点），则复用节点并置位\n    if (newFiber !== null) {\n      if (shouldTrackSideEffects) {\n        // 非首次渲染时，如果该节点已经与原节点链接，则删除原节点\n        if (newFiber.alternate !== null) {\n          existingChildren.delete(\n            newFiber.key === null ? newIdx : newFiber.key,\n          );\n        }\n      }\n      // 对该节点进行置位，并链接到结果节点链表\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        resultingFirstChild = newFiber;\n      } else {\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n    }\n  }\n  // 删除未被消费的原节点\n  if (shouldTrackSideEffects) {\n    existingChildren.forEach(child => deleteChild(returnFiber, child));\n  }\n  // ......\n  // 返回首个结果节点\n  return resultingFirstChild;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n\n\n分析如下：\n\n * DIFF 过程总结如下：将相应下标的原节点用于新节点进行 DIFF（严格匹配 key 值），直到原链表或者新数组没有更多节点，或者首次遇到因无可匹配 key 值（ newChild.key === key ，考虑各自为 null 的情况）而无法复用节点的情况提前循环。退出循环分三种情况：如果没有更多的新节点，DIFF 结束，删除剩余的原节点，并返回结果节点首节点；如果没有更多原节点，后续结果无需 DIFF，可直接创建节点并置位，并返回结果节点首节点；如果原节点和新节点均有剩余，则采用节点池的方式复用节点，复用节点或者创建节点。\n * 节点的 DIFF 本质上是对同层级的节点的 DIFF。与 vue3 的 DIFF 算法相比，可能 vue3 的 DIFF 的效率要更高一些。React 目前的 DIFF 算法没有办法采用更高效的双向搜索（从两端同时 DIFF）的方式，这是因为 React 中同级子节点是以单向链表管理的，节点之间用 sibling 指针链接，没有反向指针导致节点无法反向回溯。那么为什么 Vue3 可以做到双向搜索呢？这是因为 vue3 的同级子节点使用数组管理的，数组原生支持正向和反向的遍历。\n * 为什么不合法的 key 值会在控制台打印警告？函数中 warnOnInvalidKey 会检查不合法的 key 值，包括重复的 key 值，并且打印警告信息。\n * 为什么 key 值很重要？因为 key 值对于复用节点很重要！更重 DIFF 算法都依赖 key 以复用原节点，以节省创建节点的内存的开销。\n\n\n# reconcileSingleElement\n\n此函数对单一 Element 子节点进行调和。\n\n// src/react/packages/react-reconciler/src/ReactChildFiber.new.js\nfunction reconcileSingleElement(\n    returnFiber: Fiber,\n    currentFirstChild: Fiber | null,\n    element: ReactElement,\n    lanes: Lanes,\n  ): Fiber {\n  const key = element.key;\n  let child = currentFirstChild;\n  // 遍历原节点链表寻求能够被新节点复用的原节点\n  while (child !== null) {\n    // 如果有key值匹配的原节点\n    if (child.key === key) {\n      const elementType = element.type;\n      // 如果 Element 是 Fragment，且可复用原节点也是 Fragment\n      // 在 reconcileChildFibers 中 Element 已经解包装过一次\n      if (elementType === REACT_FRAGMENT_TYPE) {\n        if (child.tag === Fragment) {\n          // 删除剩余的所有的节点，因为可复用的 child 已经缓存\n          deleteRemainingChildren(returnFiber, child.sibling);\n          // 复用 child 并对 Element 再做一次解包装，注意这里的复用节点会复用 child 和 sibling 指针\n          const existing = useFiber(child, element.props.children);\n          // 将 return 指针指向 returnFiber\n          existing.return = returnFiber;\n          // ......\n          return existing;\n        }\n      } else {\n        // 如果 Element 不是 Fragment，且可复用原节点的类型和 Element 相同\n        if (child.elementType === elementType /*......*/) {\n          // 删除剩余的所有节点\n          deleteRemainingChildren(returnFiber, child.sibling);\n          // 复用原节点\n          const existing = useFiber(child, element.props);\n          // 处理 string refs\n          existing.ref = coerceRef(returnFiber, child, element);\n          // 将 return 指针指向 returnFiber\n          existing.return = returnFiber;\n          // ......\n          return existing;\n        }\n      }\n      // Didn't match.\n      deleteRemainingChildren(returnFiber, child);\n      break;\n    } else {\n      // 旧节点如果不能被复用直接删除\n      deleteChild(returnFiber, child);\n    }\n    // 指针移到兄弟节点\n    child = child.sibling;\n  }\n  // 如果没有可复用的节点，根据 Element 类型创建新节点（Fiber），并将之返回\n  if (element.type === REACT_FRAGMENT_TYPE) {\n    const created = createFiberFromFragment(/*......*/);\n    created.return = returnFiber;\n    return created;\n  } else {\n    const created = createFiberFromElement(element, returnFiber.mode, lanes);\n    created.ref = coerceRef(returnFiber, currentFirstChild, element);\n    created.return = returnFiber;\n    return created;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n分析如下：\n\n * coerceRef 处理 String Refs ，参考 Legacy API: String Refs。\n * 对于单一单一 Element 子节点，在调和时需要根据 Element 的类型（Fragment 或者 普通 Element）采用不同的调和策略，如果有旧节点可复用，在调用 useFiber 复用之，如果没有则 createFiberFromFragment 或者 createFiberFromElement 创建新节点。\n\n\n# reconcileSingleTextNode\n\n此函数对单一 Element 文本子节点进行调和。\n\nfunction reconcileSingleTextNode(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  textContent: string,\n  lanes: Lanes,\n): Fiber {\n  // 如果原节点的首个节点刚好是文本节点，则删除其余的节点，并且复用这个文本节点\n  if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n    const existing = useFiber(currentFirstChild, textContent);\n    existing.return = returnFiber;\n    return existing;\n  }\n  // 如果首个节点不是文本节点，则删除所有节点，创建新节点\n  deleteRemainingChildren(returnFiber, currentFirstChild);\n  const created = createFiberFromText(textContent, returnFiber.mode, lanes);\n  created.return = returnFiber;\n  return created;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n因为这里 Element 是文本类型，所以调用 createFiberFromText 函数创建 FIber 节点。需要注意的是，创建的新节点需要把 return 指针指向父节点。\n\n\n# placeSingleChild\n\n此函数对 reconcileSingleElement 创建的节点进行置位（标记副作用，Effect Tag）。\n\n// src/react/packages/react-reconciler/src/ReactChildFiber.new.js\nfunction placeSingleChild(newFiber: Fiber): Fiber {\n  // 添加 Placement 标记\n  if (shouldTrackSideEffects && newFiber.alternate === null) {\n    newFiber.flags |= Placement;\n  }\n  return newFiber;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# updateSlot\n\n此函数对 reconcileChildrenArray 中可复用的节点进行更新复用。\n\nfunction updateSlot(\n    returnFiber: Fiber,\n    oldFiber: Fiber | null,\n    newChild: any,\n    lanes: Lanes,\n  ): Fiber | null {\n  const key = oldFiber !== null ? oldFiber.key : null;\n  // 如果是文本节点则调用 updateTextNode 复用节点\n  if (\n    (typeof newChild === 'string' && newChild !== '') ||\n    typeof newChild === 'number'\n  ) {\n    // ......\n    return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);\n  }\n\n  if (typeof newChild === 'object' && newChild !== null) {\n    switch (newChild.$$typeof) {\n      case REACT_ELEMENT_TYPE: {\n        if (newChild.key === key) {\n          return updateElement(returnFiber, oldFiber, newChild, lanes);\n        } else {\n          return null;\n        }\n      }\n      case REACT_PORTAL_TYPE: {\n        if (newChild.key === key) {\n          return updatePortal(returnFiber, oldFiber, newChild, lanes);\n        } else {\n          return null;\n        }\n      }\n      case REACT_LAZY_TYPE: {\n        const payload = newChild._payload;\n        const init = newChild._init;\n        return updateSlot(returnFiber, oldFiber, init(payload), lanes);\n      }\n    }\n    // 如果是 Fragment 或者是可迭代对象\n    if (isArray(newChild) || getIteratorFn(newChild)) {\n      // ......\n      return updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n    }\n    // ......\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n复用的策略可以总结如下：\n\n     TEXT             ELEMENT         PORTAL         LAZY         FRAGMENT\n方法   updateTextNode   updateElement   updatePortal   updateSlot   updateFragment\n\n注意这里是严格比对 key 值相等，否则一律返回 null。对于具体的复用细节，后文详述。\n\n\n# updateFromMap\n\n此函数对 reconcileChildrenArray 中节点池中可复用的节点进行更新复用。具体逻辑与 updateSlot 一致，不在赘述。\n\n\n# placeChild\n\n此函数对 reconcileChildrenArray 中调和的节点进行置位。\n\nfunction placeChild(\n  newFiber: Fiber,\n  lastPlacedIndex: number,\n  newIndex: number,\n): number {\n  // 缓存下标共下次调和使用\n  newFiber.index = newIndex;\n  const current = newFiber.alternate;\n  // ......\n  // current 存在说明 current 即是将被复用的原节点\n  // 如果非首次渲染，比较原节点与新节点的下标，如果新节点在原节点的后面，标记为 Placement，并返回置位的下标\n  // 如果新节点不在原节点的后面，则位置无需变化，保持原位置即可\n  if (current !== null) {\n    const oldIndex = current.index;\n    if (oldIndex < lastPlacedIndex) {\n      newFiber.flags |= Placement;\n      return lastPlacedIndex;\n    } else {\n      return oldIndex;\n    }\n  } else {\n    // 没有被复用的节点，添加 Placement 标记\n    newFiber.flags |= Placement;\n    return lastPlacedIndex;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# deleteChild\n\n此函数收集待删除的节点并且对 returnFiber 添加 ChildDeletion 副作用标记。\n\nfunction deleteChild(returnFiber: Fiber, childToDelete: Fiber): void {\n  // 初次渲染不需要 ChildDeletion 标记\n  if (!shouldTrackSideEffects) return;\n  // 将待删除的节点加入到 returnFiber.deletions 数组中，并且在 returnFiber 上添加 ChildDeletion 标记\n  const deletions = returnFiber.deletions;\n  if (deletions === null) {\n    returnFiber.deletions = [childToDelete];\n    returnFiber.flags |= ChildDeletion;\n  } else {\n    deletions.push(childToDelete);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 扩展\n\n\n# 函数式组件和类组件在 reconcileChildren 之前做了什么？\n\n本文中只大致介绍了函数式组件和类组件在捕获时调和过程的大致脉络，这个过程最终都会分成 cloneChildFibers 和 reconcileChildren ，而对于其中的细节只是一笔带过，如 renderWithHooks 、 constructClassInstance 、 mountClassInstance 、 updateClassInstance 、 finishClassComponent 等函数，这些逻辑跟相应的组件的关联比较大，与整个的调和过程关系不大，因此这部分内容将在后文组件机制的文章中陆续展开探讨。\n\n\n# workInProgress Tree 是如何初始化的？\n\n请看下面这个简易的获取冒泡的过程：\n\n\n\n可以看出，在 WorkLoop 的捕获和冒泡过程中， workInProgress 指针是在不停移动的。在应用挂载时，进入对 workInProgress 指针所指向的节点的 beginWork 过程会调用 reconcileChildren 函数，此函数判断到为挂载（mount）阶段则会在 reconcileChildFibers 中创建 workInProgress Fiber。\n\n\n# 问题\n\n\n# 总结\n\n本文介绍了 React 调和过程中冒泡阶段对 workInProgress 节点（换一种角度看也是子节点）进行调和的原理细节，包括子节点的创建和复用、DIFF 算法、副作用标记（Effect Tag）等。从整体上来看，workInProgress 的调和过程与 ReactElement 的抽象层是密不可分的，Fiber 的调和过程依赖于 ReactElement 对应用最新状态的榨取，这些最新的状态最终从内存中被收集起来，成为 Fiber 上可回溯的数据。整个捕获过程除了创建 workInProgress Fiber 之外，还担负着标记副作用的职责。副作用将为 DOM 的更新起到指导作用。\n\n有以下几点还需注意：\n\n * React DIFF 算法虽然在一定程度上已经做了一些优化，但是由于数据结构本身的限制，还是有一定的可优化的空间。\n * React 的更新粒度是 FiberRoot 为基础，虽然在调和期间有一定的优化措施，比如各种节点复用，甚至是提前跳出捕获过程，但是相对于 Vue3 中基于模板分析的组件粒度的更新机制，还是有一定的性能差距的。\n * React 中的 VDOM 如何理解？这里的 VDOM 不只是 ReactElement，还应该包括 FiberTree。这是因为 ReactElement 对于维持组件状态很重要，但是 React 应用的调度、更新和渲染离不开 FiberTree 的结构。因此可以将 ReactElement 理解为组件状态层面的 VDOM，而把 FiberTree 理解为应用层面上的 VDOM。\n * 本文中已经接触到的副作用包括 Placement 、 ChildDeletion 和 ContentReset 。从理论上来说，DOM 的更新只需要两个副作用，“更新”（重新调整位置，包括插入）、“删除”。在后文中，我们将针对更新的副作用进行更深入的探究。此处 Placement 意即更新节点位置， ChildDeletion 意即删除节点， ContentReset 意即针对可视为文本节点 HostComponent 节点重置其文本内容。\n\n\n# 参考\n\n * React 源码剖析系列 － 不可思议的 react diff",normalizedContent:"# 目录\n\n\n\n * 目录\n * 前言\n * bailoutonalreadyfinishedwork\n * clonechildfibers\n * reconcilechildren\n * reconcilechildfibers\n * reconcilechildrenarray\n * reconcilesingleelement\n * reconcilesingletextnode\n * placesinglechild\n * updateslot\n * updatefrommap\n * placechild\n * deletechild\n * 扩展\n   * 函数式组件和类组件在 reconcilechildren 之前做了什么？\n   * workinprogress tree 是如何初始化的？\n * 问题\n * 总结\n * 参考\n\n\n\n\n# 前言\n\n在上文中，我们探讨了在 beginwork 函数中针对不同的类型（内部类型）的 react 组件所采取的不同的调和策略：复用和重新调和。在本文中，我们继续来探讨在捕获阶段中组件的复用机制以及组件的具体的调和过程。本文将主要围绕着 clonechildfibers 和 reconcilechildren 两个核心函数展开探讨。\n\n\n# bailoutonalreadyfinishedwork\n\n通过上文分析，我们已经了解了无论是函数式组件还是类组件，在提前退出时都是调用 bailoutonalreadyfinishedwork 函数。要想深入了解 clonechildfibers 的作用，我们可能要先了解此函数的原理。\n\n// src/react/packages/react-reconciler/src/reactfiberbeginwork.new.js\nfunction bailoutonalreadyfinishedwork(\n  current: fiber | null,\n  workinprogress: fiber,\n  renderlanes: lanes,\n): fiber | null {\n  // ......\n  markskippedupdatelanes(workinprogress.lanes);\n\n  // check if the children have any pending work.\n  // 检查子树是否有相应的更新，通过 childlanes 判断，如果没有更新，则可以提前结束子树的捕获过程，并开始向上冒泡\n  if (!includessomelane(renderlanes, workinprogress.childlanes)) {\n    // the children don't have any work either. we can skip them.\n    return null;\n  }\n  // this fiber doesn't have work, but its subtree does. clone the child\n  // fibers and continue.\n  // 子树有更新，复制子树的 fibers 并返回子节点继续捕获\n  clonechildfibers(current, workinprogress);\n  return workinprogress.child;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n分析如下：\n\n * markskippedupdatelanes 函数将本次渲染期间累计的未处理的更新的 lanes 合并到 workinprogress.lanes 中。这是因为在调度到真正渲染期间，可能会有新的 lanes 被收集到。\n * 这里有一个性能的优化，如果 renderlanes 中不包含 workinprogress 节点的 childlanes ，即子 fibertree 没有更新，则可以通过返回 null ，提前结束捕获。\n\n\n# clonechildfibers\n\n此函数将复用当前 fiber 节点的所有下级子节点。\n\nexport function clonechildfibers(\n  current: fiber | null,\n  workinprogress: fiber,\n): void {\n  // ......\n  let currentchild = workinprogress.child;\n  let newchild = createworkinprogress(currentchild, currentchild.pendingprops);\n  workinprogress.child = newchild;\n  newchild.return = workinprogress;\n  while (currentchild.sibling !== null) {\n    currentchild = currentchild.sibling;\n    newchild = newchild.sibling = createworkinprogress(\n      currentchild,\n      currentchild.pendingprops,\n    );\n    newchild.return = workinprogress;\n  }\n  newchild.sibling = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n下图是相关的数据结构的操作逻辑：\n\n分析如下：\n\n * createworkinprogress 创建新的 workinprogress fiber 节点，并复用 current fibernode 的属性（如果 workinprogress 节点是悬空的，则创建 fiber 节点，见 createfiber 函数）。\n * newchild 指针不断向兄弟节点移动，直至遍历完所有的兄弟节点。\n\n\n# reconcilechildren\n\n此函数根据是否是首次渲染而决定是否追踪副作用，并且调用相应的函数对姐姐点进行调和。\n\nexport function reconcilechildren(\n  current: fiber | null,\n  workinprogress: fiber,\n  nextchildren: any,\n  renderlanes: lanes,\n) {\n  if (current === null) {\n    workinprogress.child = mountchildfibers(\n      workinprogress,\n      null,\n      nextchildren,\n      renderlanes,\n    );\n  } else {\n    workinprogress.child = reconcilechildfibers(\n      workinprogress,\n      current.child,\n      nextchildren,\n      renderlanes,\n    );\n  }\n}\n\nconst reconcilechildfibers = childreconciler(true);\nconst mountchildfibers = childreconciler(false);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n分析如下：\n\n * 如果是首次渲染，则不必追踪副作用，调用 mountchildfibers ，否则则调用 reconcilechildfibers 。主要这两个函数都是调用包装函数 childreconciler 实现的。\n * reconcilechildren 调和子节点，并赋值给 workinprogress.child 。\n\n\n# reconcilechildfibers\n\n此函数对 workinprogress 节点的 children 节点进行调和，并且标记副作用。\n\n// src/react/packages/react-reconciler/src/reactchildfiber.new.js\n// this api will tag the children with the side-effect of the reconciliation\n// itself. they will be added to the side-effect list as we pass through the\n// children and the parent.\nfunction reconcilechildfibers(\n  returnfiber: fiber,\n  currentfirstchild: fiber | null,\n  newchild: any,\n  lanes: lanes,\n): fiber | null {\n  // 处理 element fragment 解包装，类型为 react_fragment_type\n  const isunkeyedtoplevelfragment =\n    typeof newchild === 'object' &&\n    newchild !== null &&\n    newchild.type === react_fragment_type &&\n    newchild.key === null;\n  if (isunkeyedtoplevelfragment) {\n    newchild = newchild.props.children;\n  }\n\n  // 非文本节点，包括数组和迭代器\n  if (typeof newchild === 'object' && newchild !== null) {\n    switch (newchild.$$typeof) {\n      case react_element_type:\n        return placesinglechild(reconcilesingleelement(/*...*/));\n      case react_portal_type:\n        return placesinglechild(reconcilesingleportal(/*...*/));\n      case react_lazy_type:\n        return reconcilechildfibers(/*...*/);\n    }\n\n    if (isarray(newchild)) {\n      return reconcilechildrenarray(/*...*/);\n    }\n    if (getiteratorfn(newchild)) {\n      return reconcilechildreniterator(/*...*/);\n    }\n    // ......\n  }\n  // 如果是文本节点\n  if (\n    (typeof newchild === 'string' && newchild !== '') ||\n    typeof newchild === 'number'\n  ) {\n    return placesinglechild(reconcilesingletextnode(/*...*/));\n  }\n\n  // 如果不符合上述情况，视为清空子节点\n  return deleteremainingchildren(returnfiber, currentfirstchild);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n分析如下：\n\n * 明确 newchild 是什么？ newchild 本质上是 reactelement，是 react.createelement 语法糖创建出来的对象，具体的结构可见参见 reactelement 与基础概念。\n * react.fragment 解包装之后成为节点链表。\n * 本函数处理合法的节点类型（注意，此处不是 fiber 类型，而是 reactelement 类型，根据 reactelement.$$typeof 判断）：普通 element、portal、lazy 节点、节点链表、节点迭代器、文本节点，其余的形式均视为非法清空所有子节点。\n * 从整体来看，子节点的处理分成两步：调和（reconcile）和置位（place）。调和的过程就是创建 workinprogress fibertree 的 fiber 节点的过程，而置位就是进行副作用标记的过程。\n * 对于 lazy 节点，即延迟加载的节点，解包装出延迟的组件后，递归调用自身即可。\n * 注意： reconcilechildfibers 返回调和后的第一个子节点。\n * reconcilechildfibers 实现了从 reactelement 到 fiber 的飞跃。从入参 newchild 是 reactelement，到返回值为 fiber 可见一斑。\n\n下面我们分别来探讨下 element 节点链表、 react_element_type 单一节点和 element 文本节点的具体原理。\n\n\n# reconcilechildrenarray\n\n此函数对同级子节点应用 diff 算法，目的是通过 diff 算法根据 current fiber 和 reactelement 高效的创建 workinprogress fiber。此过程可视为节点链表的调和过程。\n\n注意\n\n相关简写：\n\n * 原链表：current 节点链表。\n * 新数组：reactelement 节点数组。\n * 原节点：current 节点链表中对应位置的节点（fiber）。\n * 新节点：reactelement 节点链表中对应位置的节点（reactelement）。\n * 结果节点：经过 diff 后要置位于对应位置的节点（fiber）。\n\n具体过程如下：\n\n// src/react/packages/react-reconciler/src/reactchildfiber.new.js\nfunction reconcilechildrenarray(\n  // workinprogress fiber\n  returnfiber: fiber,\n  // current fiber 上的第一个子节点\n  currentfirstchild: fiber | null,\n  // 当前调和中的 reactelement\n  newchildren: array<*>,\n  // 调和节点的优先级\n  lanes: lanes,\n): fiber | null {\n  // ......\n  // 调和后的第一个子节点\n  let resultingfirstchild: fiber | null = null;\n  // 上一个被置位的结果节点\n  let previousnewfiber: fiber | null = null;\n  // 原节点指针，指向 current 节点链表中的节点\n  let oldfiber = currentfirstchild;\n  // 上一次置位的下标\n  let lastplacedindex = 0;\n  let newidx = 0;\n  // 下一轮要比较的原节点指针\n  let nextoldfiber = null;\n  // 以下取原链表和新数组较短的长度的部分进行 diff（循环原链表和新数组，知道两者之一没有更多节点）\n  for (; oldfiber !== null && newidx < newchildren.length; newidx++) {\n    // 如果原节点的下标与当前置位的下标不一致，说明可能是在原节点的前面添加了新节点，因此\n    // 将原节点推迟到下一次比较，本次比较原节点则悬空\n    if (oldfiber.index > newidx) {\n      nextoldfiber = oldfiber;\n      oldfiber = null;\n    } else {\n      // 如果下标一致，则下一个要比较的原节点则为当前原节点的兄弟节点\n      nextoldfiber = oldfiber.sibling;\n    }\n    // 根据当前比较，尝试从原链表中复用节点。\n    // 根据 children 的类型进行匹配，如果 key 值匹配则返回结果节点，否则返回 null。\n    const newfiber = updateslot(\n      returnfiber,\n      // 本次比较的原节点，可能是 null\n      oldfiber,\n      // 本次比较的新节点\n      newchildren[newidx],\n      lanes,\n    );\n    // 如果没有节点可复用，则跳出循环\n    if (newfiber === null) {\n      if (oldfiber === null) {\n        oldfiber = nextoldfiber;\n      }\n      break;\n    }\n    // 如果节点可以复用，且非初次渲染，原节点存在且未与新节点建立链接，则删除原节点\n    if (shouldtracksideeffects) {\n      if (oldfiber && newfiber.alternate === null) {\n        deletechild(returnfiber, oldfiber);\n      }\n    }\n    // 将更新后的新节点置位\n    lastplacedindex = placechild(newfiber, lastplacedindex, newidx);\n    // 首个结果节点链接在 resultingfirstchild 上，后续结果结果连接在上个节点的 sibling 指针上\n    if (previousnewfiber === null) {\n      resultingfirstchild = newfiber;\n    } else {\n      previousnewfiber.sibling = newfiber;\n    }\n    previousnewfiber = newfiber;\n    // 原节点指针移动到下一个原节点\n    oldfiber = nextoldfiber;\n  }\n  // 如果经过上述复用之后已经没有更多新节点，diff 结束，删除剩余的原节点，并返回结果节点首节点\n  if (newidx === newchildren.length) {\n    deleteremainingchildren(returnfiber, oldfiber);\n    // ......\n    return resultingfirstchild;\n  }\n  // 如果没有更多原节点，后续结果无需 diff，可直接置位，并返回结果节点首节点\n  if (oldfiber === null) {\n    // 循环剩余的新节点\n    for (; newidx < newchildren.length; newidx++) {\n      // 根据新节点创建子节点\n      const newfiber = createchild(returnfiber, newchildren[newidx], lanes);\n      if (newfiber === null) {\n        continue;\n      }\n      // 对子节点进行置位\n      lastplacedindex = placechild(newfiber, lastplacedindex, newidx);\n      // 将子节点链接到结果节点链表\n      if (previousnewfiber === null) {\n        resultingfirstchild = newfiber;\n      } else {\n        previousnewfiber.sibling = newfiber;\n      }\n      previousnewfiber = newfiber;\n    }\n    // ......\n    return resultingfirstchild;\n  }\n\n  // 如果经过上述 diff，原节点和新节点均有剩余，说明提前退出了 diff 过程（遇到 key 值不匹配）\n  // 则更换 diff 策略，采用节点池的方式复用节点\n  const existingchildren = mapremainingchildren(returnfiber, oldfiber);\n\n  // 循环剩余的待置位的新节点，寻求节点复用\n  for (; newidx < newchildren.length; newidx++) {\n    // 尝试从节点池复用节点\n    // 注意：这里仍然是 key 值匹配才可以复用，如果匹配不到则创建节点\n    const newfiber = updatefrommap(\n      existingchildren,\n      returnfiber,\n      newidx,\n      newchildren[newidx],\n      lanes,\n    );\n    // 如果有可复用节点（或者创建出节点），则复用节点并置位\n    if (newfiber !== null) {\n      if (shouldtracksideeffects) {\n        // 非首次渲染时，如果该节点已经与原节点链接，则删除原节点\n        if (newfiber.alternate !== null) {\n          existingchildren.delete(\n            newfiber.key === null ? newidx : newfiber.key,\n          );\n        }\n      }\n      // 对该节点进行置位，并链接到结果节点链表\n      lastplacedindex = placechild(newfiber, lastplacedindex, newidx);\n      if (previousnewfiber === null) {\n        resultingfirstchild = newfiber;\n      } else {\n        previousnewfiber.sibling = newfiber;\n      }\n      previousnewfiber = newfiber;\n    }\n  }\n  // 删除未被消费的原节点\n  if (shouldtracksideeffects) {\n    existingchildren.foreach(child => deletechild(returnfiber, child));\n  }\n  // ......\n  // 返回首个结果节点\n  return resultingfirstchild;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n\n\n分析如下：\n\n * diff 过程总结如下：将相应下标的原节点用于新节点进行 diff（严格匹配 key 值），直到原链表或者新数组没有更多节点，或者首次遇到因无可匹配 key 值（ newchild.key === key ，考虑各自为 null 的情况）而无法复用节点的情况提前循环。退出循环分三种情况：如果没有更多的新节点，diff 结束，删除剩余的原节点，并返回结果节点首节点；如果没有更多原节点，后续结果无需 diff，可直接创建节点并置位，并返回结果节点首节点；如果原节点和新节点均有剩余，则采用节点池的方式复用节点，复用节点或者创建节点。\n * 节点的 diff 本质上是对同层级的节点的 diff。与 vue3 的 diff 算法相比，可能 vue3 的 diff 的效率要更高一些。react 目前的 diff 算法没有办法采用更高效的双向搜索（从两端同时 diff）的方式，这是因为 react 中同级子节点是以单向链表管理的，节点之间用 sibling 指针链接，没有反向指针导致节点无法反向回溯。那么为什么 vue3 可以做到双向搜索呢？这是因为 vue3 的同级子节点使用数组管理的，数组原生支持正向和反向的遍历。\n * 为什么不合法的 key 值会在控制台打印警告？函数中 warnoninvalidkey 会检查不合法的 key 值，包括重复的 key 值，并且打印警告信息。\n * 为什么 key 值很重要？因为 key 值对于复用节点很重要！更重 diff 算法都依赖 key 以复用原节点，以节省创建节点的内存的开销。\n\n\n# reconcilesingleelement\n\n此函数对单一 element 子节点进行调和。\n\n// src/react/packages/react-reconciler/src/reactchildfiber.new.js\nfunction reconcilesingleelement(\n    returnfiber: fiber,\n    currentfirstchild: fiber | null,\n    element: reactelement,\n    lanes: lanes,\n  ): fiber {\n  const key = element.key;\n  let child = currentfirstchild;\n  // 遍历原节点链表寻求能够被新节点复用的原节点\n  while (child !== null) {\n    // 如果有key值匹配的原节点\n    if (child.key === key) {\n      const elementtype = element.type;\n      // 如果 element 是 fragment，且可复用原节点也是 fragment\n      // 在 reconcilechildfibers 中 element 已经解包装过一次\n      if (elementtype === react_fragment_type) {\n        if (child.tag === fragment) {\n          // 删除剩余的所有的节点，因为可复用的 child 已经缓存\n          deleteremainingchildren(returnfiber, child.sibling);\n          // 复用 child 并对 element 再做一次解包装，注意这里的复用节点会复用 child 和 sibling 指针\n          const existing = usefiber(child, element.props.children);\n          // 将 return 指针指向 returnfiber\n          existing.return = returnfiber;\n          // ......\n          return existing;\n        }\n      } else {\n        // 如果 element 不是 fragment，且可复用原节点的类型和 element 相同\n        if (child.elementtype === elementtype /*......*/) {\n          // 删除剩余的所有节点\n          deleteremainingchildren(returnfiber, child.sibling);\n          // 复用原节点\n          const existing = usefiber(child, element.props);\n          // 处理 string refs\n          existing.ref = coerceref(returnfiber, child, element);\n          // 将 return 指针指向 returnfiber\n          existing.return = returnfiber;\n          // ......\n          return existing;\n        }\n      }\n      // didn't match.\n      deleteremainingchildren(returnfiber, child);\n      break;\n    } else {\n      // 旧节点如果不能被复用直接删除\n      deletechild(returnfiber, child);\n    }\n    // 指针移到兄弟节点\n    child = child.sibling;\n  }\n  // 如果没有可复用的节点，根据 element 类型创建新节点（fiber），并将之返回\n  if (element.type === react_fragment_type) {\n    const created = createfiberfromfragment(/*......*/);\n    created.return = returnfiber;\n    return created;\n  } else {\n    const created = createfiberfromelement(element, returnfiber.mode, lanes);\n    created.ref = coerceref(returnfiber, currentfirstchild, element);\n    created.return = returnfiber;\n    return created;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n分析如下：\n\n * coerceref 处理 string refs ，参考 legacy api: string refs。\n * 对于单一单一 element 子节点，在调和时需要根据 element 的类型（fragment 或者 普通 element）采用不同的调和策略，如果有旧节点可复用，在调用 usefiber 复用之，如果没有则 createfiberfromfragment 或者 createfiberfromelement 创建新节点。\n\n\n# reconcilesingletextnode\n\n此函数对单一 element 文本子节点进行调和。\n\nfunction reconcilesingletextnode(\n  returnfiber: fiber,\n  currentfirstchild: fiber | null,\n  textcontent: string,\n  lanes: lanes,\n): fiber {\n  // 如果原节点的首个节点刚好是文本节点，则删除其余的节点，并且复用这个文本节点\n  if (currentfirstchild !== null && currentfirstchild.tag === hosttext) {\n    deleteremainingchildren(returnfiber, currentfirstchild.sibling);\n    const existing = usefiber(currentfirstchild, textcontent);\n    existing.return = returnfiber;\n    return existing;\n  }\n  // 如果首个节点不是文本节点，则删除所有节点，创建新节点\n  deleteremainingchildren(returnfiber, currentfirstchild);\n  const created = createfiberfromtext(textcontent, returnfiber.mode, lanes);\n  created.return = returnfiber;\n  return created;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n因为这里 element 是文本类型，所以调用 createfiberfromtext 函数创建 fiber 节点。需要注意的是，创建的新节点需要把 return 指针指向父节点。\n\n\n# placesinglechild\n\n此函数对 reconcilesingleelement 创建的节点进行置位（标记副作用，effect tag）。\n\n// src/react/packages/react-reconciler/src/reactchildfiber.new.js\nfunction placesinglechild(newfiber: fiber): fiber {\n  // 添加 placement 标记\n  if (shouldtracksideeffects && newfiber.alternate === null) {\n    newfiber.flags |= placement;\n  }\n  return newfiber;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# updateslot\n\n此函数对 reconcilechildrenarray 中可复用的节点进行更新复用。\n\nfunction updateslot(\n    returnfiber: fiber,\n    oldfiber: fiber | null,\n    newchild: any,\n    lanes: lanes,\n  ): fiber | null {\n  const key = oldfiber !== null ? oldfiber.key : null;\n  // 如果是文本节点则调用 updatetextnode 复用节点\n  if (\n    (typeof newchild === 'string' && newchild !== '') ||\n    typeof newchild === 'number'\n  ) {\n    // ......\n    return updatetextnode(returnfiber, oldfiber, '' + newchild, lanes);\n  }\n\n  if (typeof newchild === 'object' && newchild !== null) {\n    switch (newchild.$$typeof) {\n      case react_element_type: {\n        if (newchild.key === key) {\n          return updateelement(returnfiber, oldfiber, newchild, lanes);\n        } else {\n          return null;\n        }\n      }\n      case react_portal_type: {\n        if (newchild.key === key) {\n          return updateportal(returnfiber, oldfiber, newchild, lanes);\n        } else {\n          return null;\n        }\n      }\n      case react_lazy_type: {\n        const payload = newchild._payload;\n        const init = newchild._init;\n        return updateslot(returnfiber, oldfiber, init(payload), lanes);\n      }\n    }\n    // 如果是 fragment 或者是可迭代对象\n    if (isarray(newchild) || getiteratorfn(newchild)) {\n      // ......\n      return updatefragment(returnfiber, oldfiber, newchild, lanes, null);\n    }\n    // ......\n  }\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n复用的策略可以总结如下：\n\n     text             element         portal         lazy         fragment\n方法   updatetextnode   updateelement   updateportal   updateslot   updatefragment\n\n注意这里是严格比对 key 值相等，否则一律返回 null。对于具体的复用细节，后文详述。\n\n\n# updatefrommap\n\n此函数对 reconcilechildrenarray 中节点池中可复用的节点进行更新复用。具体逻辑与 updateslot 一致，不在赘述。\n\n\n# placechild\n\n此函数对 reconcilechildrenarray 中调和的节点进行置位。\n\nfunction placechild(\n  newfiber: fiber,\n  lastplacedindex: number,\n  newindex: number,\n): number {\n  // 缓存下标共下次调和使用\n  newfiber.index = newindex;\n  const current = newfiber.alternate;\n  // ......\n  // current 存在说明 current 即是将被复用的原节点\n  // 如果非首次渲染，比较原节点与新节点的下标，如果新节点在原节点的后面，标记为 placement，并返回置位的下标\n  // 如果新节点不在原节点的后面，则位置无需变化，保持原位置即可\n  if (current !== null) {\n    const oldindex = current.index;\n    if (oldindex < lastplacedindex) {\n      newfiber.flags |= placement;\n      return lastplacedindex;\n    } else {\n      return oldindex;\n    }\n  } else {\n    // 没有被复用的节点，添加 placement 标记\n    newfiber.flags |= placement;\n    return lastplacedindex;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# deletechild\n\n此函数收集待删除的节点并且对 returnfiber 添加 childdeletion 副作用标记。\n\nfunction deletechild(returnfiber: fiber, childtodelete: fiber): void {\n  // 初次渲染不需要 childdeletion 标记\n  if (!shouldtracksideeffects) return;\n  // 将待删除的节点加入到 returnfiber.deletions 数组中，并且在 returnfiber 上添加 childdeletion 标记\n  const deletions = returnfiber.deletions;\n  if (deletions === null) {\n    returnfiber.deletions = [childtodelete];\n    returnfiber.flags |= childdeletion;\n  } else {\n    deletions.push(childtodelete);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 扩展\n\n\n# 函数式组件和类组件在 reconcilechildren 之前做了什么？\n\n本文中只大致介绍了函数式组件和类组件在捕获时调和过程的大致脉络，这个过程最终都会分成 clonechildfibers 和 reconcilechildren ，而对于其中的细节只是一笔带过，如 renderwithhooks 、 constructclassinstance 、 mountclassinstance 、 updateclassinstance 、 finishclasscomponent 等函数，这些逻辑跟相应的组件的关联比较大，与整个的调和过程关系不大，因此这部分内容将在后文组件机制的文章中陆续展开探讨。\n\n\n# workinprogress tree 是如何初始化的？\n\n请看下面这个简易的获取冒泡的过程：\n\n\n\n可以看出，在 workloop 的捕获和冒泡过程中， workinprogress 指针是在不停移动的。在应用挂载时，进入对 workinprogress 指针所指向的节点的 beginwork 过程会调用 reconcilechildren 函数，此函数判断到为挂载（mount）阶段则会在 reconcilechildfibers 中创建 workinprogress fiber。\n\n\n# 问题\n\n\n# 总结\n\n本文介绍了 react 调和过程中冒泡阶段对 workinprogress 节点（换一种角度看也是子节点）进行调和的原理细节，包括子节点的创建和复用、diff 算法、副作用标记（effect tag）等。从整体上来看，workinprogress 的调和过程与 reactelement 的抽象层是密不可分的，fiber 的调和过程依赖于 reactelement 对应用最新状态的榨取，这些最新的状态最终从内存中被收集起来，成为 fiber 上可回溯的数据。整个捕获过程除了创建 workinprogress fiber 之外，还担负着标记副作用的职责。副作用将为 dom 的更新起到指导作用。\n\n有以下几点还需注意：\n\n * react diff 算法虽然在一定程度上已经做了一些优化，但是由于数据结构本身的限制，还是有一定的可优化的空间。\n * react 的更新粒度是 fiberroot 为基础，虽然在调和期间有一定的优化措施，比如各种节点复用，甚至是提前跳出捕获过程，但是相对于 vue3 中基于模板分析的组件粒度的更新机制，还是有一定的性能差距的。\n * react 中的 vdom 如何理解？这里的 vdom 不只是 reactelement，还应该包括 fibertree。这是因为 reactelement 对于维持组件状态很重要，但是 react 应用的调度、更新和渲染离不开 fibertree 的结构。因此可以将 reactelement 理解为组件状态层面的 vdom，而把 fibertree 理解为应用层面上的 vdom。\n * 本文中已经接触到的副作用包括 placement 、 childdeletion 和 contentreset 。从理论上来说，dom 的更新只需要两个副作用，“更新”（重新调整位置，包括插入）、“删除”。在后文中，我们将针对更新的副作用进行更深入的探究。此处 placement 意即更新节点位置， childdeletion 意即删除节点， contentreset 意即针对可视为文本节点 hostcomponent 节点重置其文本内容。\n\n\n# 参考\n\n * react 源码剖析系列 － 不可思议的 react diff",charsets:{cjk:!0},lastUpdated:"2022/08/01, 20:37:47",lastUpdatedTimestamp:1659357467e3},{title:"React 源码漂流记：React 调和器核心源码解读（六）",frontmatter:{title:"React 源码漂流记：React 调和器核心源码解读（六）",date:"2022-07-30T12:02:21.000Z",permalink:"/react/tour/react-reconciliation-6/",categories:["react","React源码漂流记"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/140.react-reconciliation-6.html",relativePath:"10.react/90.React源码漂流记/140.react-reconciliation-6.md",key:"v-09c3f1ff",path:"/react/tour/react-reconciliation-6/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:17},{level:2,title:"completeUnitOfWork",slug:"completeunitofwork",normalizedTitle:"completeunitofwork",charIndex:23},{level:2,title:"completeWork",slug:"completework",normalizedTitle:"completework",charIndex:45},{level:2,title:"bubbleProperties",slug:"bubbleproperties",normalizedTitle:"bubbleproperties",charIndex:61},{level:2,title:"Render 阶段的终结",slug:"render-阶段的终结",normalizedTitle:"render 阶段的终结",charIndex:81},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:97},{level:3,title:"bubbleProperties 中为什么要收集 subtreeFlags?",slug:"bubbleproperties-中为什么要收集-subtreeflags",normalizedTitle:"bubbleproperties 中为什么要收集 subtreeflags?",charIndex:105},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:147},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:153},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:159}],readingTime:{text:"5 min read",minutes:4.32,time:259200.00000000006,words:864},headersStr:"目录 前言 completeUnitOfWork completeWork bubbleProperties Render 阶段的终结 扩展 bubbleProperties 中为什么要收集 subtreeFlags? 问题 总结 参考",content:"# 目录\n\n\n\n * 目录\n * 前言\n * completeUnitOfWork\n * completeWork\n * bubbleProperties\n * Render 阶段的终结\n * 扩展\n   * bubbleProperties 中为什么要收集 subtreeFlags?\n * 问题\n * 总结\n * 参考\n\n\n\n\n# 前言\n\n在上文中，我们探讨了 React 调和过程中捕获的详细过程和原理。在整体上而言，捕获过程分成两个步骤，“调和当前节点” 和 “调和子节点”，“调和当前节点” 就是对 workInProgress 的节点（ IndeterminateComponent 、 LazyComponent 、 FunctionComponent 、 ClassComponent 等）进行调和，不同的组件类型有不同的调和策略，“调和子节点” 就是对将 JSX 榨取出的 ReactElement 作为子节点进行调和，这其中大致又可分成两个步骤，即所谓 “调和” 和 “置位”，其中调和就是针对旧节点是否可复用而采取复用或者新建的方式获取子节点，应用最新的 state 和 props 等，最新获取整个调和完毕的 FiberTree，另外，“置位” 就是针对子节点标记副作用，这对本文或者后文中所述的副作用收集、DOM 的更新至关重要。\n\n在本文中，我们回转头来，从 “捕获过程” 的细节万花筒的浮出，继续深入探索 React 调和中的 “冒泡过程”。\n\n还记得 “捕获过程” 转换到 “冒泡过程” 的契机在哪里吗？\n\n在 performUnitOfWork 函数的分析中，有如下的关键代码：\n\nconst next = beginWork(current, unitOfWork, subtreeRenderLanes);\nif (next === null) {\n  completeUnitOfWork(unitOfWork);\n} else {\n  workInProgress = next;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在前文中我们已经知道，在捕获过程中，如果深入到叶子节点（没有子节点的节点）或者是因无更新而提前结束捕获过程时，都是将 next 悬空并返回，因此在函数 performUnitOfWork 中如果遇到 next 指针悬空的情况，则意味着捕获过程暂时结束了，可以进行冒泡了。 unitOfWork 本身就是 workInProgress 的节点。因此 completeUnitOfWork 函数即可看做是冒泡过程的入口。而本文的探讨也将由此展开。\n\n注意\n\n由捕获转到冒泡并不意味着不会再进行捕获。事实上，捕获冒泡的过程是对 FiberTree 的遍历的过程，因此，在冒泡时（优先遍历 sibling 节点，return 节点次之）遇到新的非叶子结点时，会再次转换到捕获过程。更多细节可参考如何理解 WorkLoop?。\n\n\n# completeUnitOfWork\n\n此函数在前置工作 beginWork 之后处理当前节点（workInProgress）的后置工作，即 completeWork 。同时与 performUnitOfWork 配合，共同完成 FiberTree 的遍历过程。\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nfunction completeUnitOfWork(unitOfWork: Fiber): void {\n  // Attempt to complete the current unit of work, then move to the next\n  // sibling. If there are no more siblings, return to the parent fiber.\n  let completedWork = unitOfWork;\n  do {\n    // 从 workInProgress Fiber 的 alternate 指针获取到 current Fiber\n    const current = completedWork.alternate;\n    // 从 workInProgress Fiber 的 return 指针获取到父节点\n    const returnFiber = completedWork.return;\n\n    // 检查 flags 上是否有 Incomplete 标记，无此标记即为没有未完成的工作（没有中断或者抛出错误）\n    if ((completedWork.flags & Incomplete) === NoFlags) {\n      // ......\n      // completeWork 在当前节点上完成工作，并且返回下一个节点（大多数情况下 next 都是 null）\n      const next = completeWork(current, completedWork, subtreeRenderLanes);\n      // workInProgress 指向下一个节点\n      if (next !== null) {\n        workInProgress = next;\n        return;\n      }\n    } else {\n      // Fiber 上前述任务未完成，可能有异常抛出，此时清理相关堆栈，进行错误冒泡捕获\n      // unwindWork 在少数清空下回抛出下个任务，如果抛出则继续执行此任务\n      // 注意，这里 return 后续才有可能有捕获过程\n      const next = unwindWork(completedWork, subtreeRenderLanes);\n      if (next !== null) {\n        next.flags &= HostEffectMask;\n        workInProgress = next;\n        return;\n      }\n      // ......\n      // 因当前 returnFiber 为 Incomplete 状态，因此添加相关标记\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its subtree flags.\n        returnFiber.flags |= Incomplete;\n        returnFiber.subtreeFlags = NoFlags;\n        returnFiber.deletions = null;\n      }\n    }\n    // 有兄弟节点时，移动到兄弟节点（有可能 beginWork 或者 completeWork）\n    const siblingFiber = completedWork.sibling;\n    if (siblingFiber !== null) {\n      workInProgress = siblingFiber;\n      return;\n    }\n    // 无兄弟节点时移动到父节点，将 completedWork 和 workInProgress 指针均移动到父节点\n    // 注意：这里并没有 return，这是因为父节点不需要重复捕获，继续冒泡即可，等移动到父节点的兄弟节点在考虑是否需要捕获\n    completedWork = returnFiber;\n    workInProgress = completedWork;\n  } while (completedWork !== null);\n\n  // 只要有兄弟节点或者父节点，上述循环就不会停止，如果退出循环，说明到达根节点\n  // 将退出状态改为 `RootCompleted`\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootCompleted;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n分析如下：\n\n * 前文中在 performUnitOfWork 中不断向子节点深入， completeUnitOfWork 中通过循环不断向兄弟节点扩展，这充分体现了 DFS 的原理。其中从代码逻辑上，也可以看出控制 child 、 sibling 、 return 三个指针的移动也是遵循一定的优先级的，DFS 所要求的优先级正是： child -> sibling -> return 。\n * 在当前节点执行 completeUnitOfWork 时，会根据节点上是否有 Incomplete 标记（是否 beginWork 的前置任务未完成），选择不同的策略。正常情况下，执行 completeWork 来完成节点上后续任务。\n * 当 WorkLoop 遍历完毕返回到根节点时，将退出状态改成 RootCompleted 。此状态将在 renderRootSync 或者 renderRootConcurrent 函数中被返回。在函数 performSyncWorkOnRoot 或者 performConcurrentWorkOnRoot 中，结束 Render 阶段进行 Commit 阶段。\n * workInProgressRootExitStatus 表示 workInProgress 的 RootFiber 在退出时的状态。WorkLoop 所展开的 “捕获与冒泡” 的遍历过程，最终会返回到根节点，此时整个过程执行的状态就标记于此。\n\n扩展\n\nRootExitStatus 有如下的状态：\n\ntype RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5;\nconst RootIncomplete = 0; // 任务尚未完成\nconst RootFatalErrored = 1; // 发生致命错误\nconst RootErrored = 2; // 发生错误\nconst RootSuspended = 3; // 任务被暂停\nconst RootSuspendedWithDelay = 4; // 任务被延迟\nconst RootCompleted = 5; // 任务已经完成\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# completeWork\n\n从 completeUnitOfWork 函数中，我们已经获知， completeWork 事实上是为了完成 workInProgress Fiber 节点上的后置工作。那么具体要哪些工作呢？我们继续往下看：\n\nfunction completeWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  const newProps = workInProgress.pendingProps;\n  // ......\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n    case LazyComponent:\n    case SimpleMemoComponent:\n    case FunctionComponent:\n    case ForwardRef:\n    case Fragment:\n    case Mode:\n    case Profiler:\n    case ContextConsumer:\n    case MemoComponent:\n      bubbleProperties(workInProgress);\n      return null;\n    case ClassComponent: {\n      // ......\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case HostRoot: {\n      // ......\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case HostComponent: {\n      // ......\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case HostText: {\n      // ......\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case SuspenseComponent: /*......*/\n    case HostPortal:\n      // ......\n      bubbleProperties(workInProgress);\n      return null;\n    case ContextProvider:\n      // ......\n      bubbleProperties(workInProgress);\n      return null;\n    case IncompleteClassComponent: {\n      // ......\n      bubbleProperties(workInProgress);\n      return null;\n    }\n    case SuspenseListComponent:  /*......*/\n    case ScopeComponent:  /*......*/\n    case OffscreenComponent:\n    case LegacyHiddenComponent:  /*......*/\n    case CacheComponent: /*......*/\n  }\n  // ......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n由上大致可以看出，最重要的内容是要执行 bubbleProperties 函数。其余细节不在赘述。\n\n\n# bubbleProperties\n\n此函数的目的是通过遍历节点下的下级子节点以收集节点的 childLanes 和 subtreeFlags 。结合整个冒泡过程来看，这实际上从 FiberTree 的底部向上冒泡以不断的更新属性。 childLanes 和 subtreeFlags 本别对应着节点的优先级和服副作用标记，都是极其重要的属性。\n\nfunction bubbleProperties(completedWork: Fiber) {\n  // 判断是否是根据 bailoutOnAlreadyFinishedWork 结束 beginWork 的\n  // child 相等说明复用了子树，见 cloneChildFibers\n  const didBailout =\n    completedWork.alternate !== null &&\n    completedWork.alternate.child === completedWork.child;\n  // ......\n  let newChildLanes = NoLanes;\n  let subtreeFlags = NoFlags;\n  let child = completedWork.child;\n  while (child !== null) {\n    newChildLanes = mergeLanes(\n      newChildLanes,\n      mergeLanes(child.lanes, child.childLanes),\n    );\n    subtreeFlags |= child.subtreeFlags;\n    subtreeFlags |= child.flags;\n    child.return = completedWork;\n    child = child.sibling;\n  }\n\n  completedWork.subtreeFlags |= subtreeFlags;\n  completedWork.childLanes = newChildLanes;\n\n  return didBailout;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n参见如下分析：\n\n * didBailout 是判断是否是通过 bailout （中文意思是 “保释”） 的方式退出捕获过程的， bailout 的方式和正常方式在此处有细微的区分，但是可以忽略。\n\n\n# Render 阶段的终结\n\nRender 阶段的终结，就意味着 Commit 阶段的开始。我们已经知道了一个正常的（忽略错误情况）渲染周期包括 Batch 阶段、 Render 阶段和 Commit 阶段，也就是所谓的 ExecutionContext 。 Batch 阶段主要是接受更新和调度请求， Render 阶段主要是对调度的回调做出反应，开启渲染（调和）的过程， Commit 阶段对 Render 阶段的调和结果进行确认，并且将更新落实到不同的 Host 宿主环境中，如 Web 环境、SSR 环境。\n\nReact 应用生命的大部分时间都是处于 batch 阶段，只有少部分时间切片分配给了 Render 阶段，并且 Render 阶段还可以被调度器通过 yield 的方式打断，极少部分的时间处于 Commit 阶段，且 Commit 阶段是不可打断的。这种情况也符合视图渲染框架的要求预期，因为 Batch 阶段才是最稳定的，是常态的； Render 的过程在调度器回调后产生，渲染的频率应当是高效且可控的，要把握更新频率和性能损耗的一个平衡（这里可以理解为刷新率的概念，后文我们将在调度器中体会这一点），最后 Commit 阶段是最不稳定的，因为这里涉及到 workInProgress FiberTree 和 current FiberTree 的交换过程，应当确保这个过程尽快完成，以免影响到页面渲染的平滑性。可以参考下图加深理解：\n\n本文分析到这里， Render 阶段大致就告一段落，更深入的细节可以另行探讨，但是整体的调和的脉络必须向前推进了。下面我们在来重温下此两阶段切换的细节。在 performSyncWorkOnRoot 和 performConcurrentWorkOnRoot 函数（参见：React 调和器核心源码解读（二））中有如下代码：\n\n// performSyncWorkOnRoot\nlet exitStatus = renderRootSync(root, lanes);\n// performConcurrentWorkOnRoot\nlet exitStatus = shouldTimeSlice\n    ? renderRootConcurrent(root, lanes)\n    : renderRootSync(root, lanes);\n\nconst finishedWork: Fiber = (root.current.alternate: any);\nroot.finishedWork = finishedWork;\nroot.finishedLanes = lanes;\n// performSyncWorkOnRoot\ncommitRoot(root);\n// performConcurrentWorkOnRoot\nfinishConcurrentRender(root, exitStatus, lanes);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n我们已经知道了，上述两个函数实际上控制着 Render 过程和 Commit 过程，在 Render 结束之后，最重要的是产生了 finishedWork 和 finishedLanes ，分别代表着调和完毕的 workInProgress FiberTree 和 lanes（优先级），在后文的 Commit 过程中，将会对此做进一步的处理。\n\n另外还有一点需要注意的是，React 整体的生命周期（注意，这里不是指组件的生命周期，而是指上述的三个阶段）的控制是在 root ，即 FiberRoot 容器上控制的，这也是由双缓存结构所决定的，因为 FiberRoot 上 current 和 finishedWork 指针分别指向两棵 FiberTree。相对应的 current 节点和 workInProgress 节点之间是通过 alternate 指针相连接的。\n\n在下一篇文章中，我们将继续探讨 Commit 阶段的原理，拭目以待吧。\n\n\n# 扩展\n\n\n# bubbleProperties 中为什么要收集 subtreeFlags ?\n\n在 React 旧版本中，在捕获时会将 Fiber 节点上的 EffectTag 进行收集，形成 Effect List 链表，因此，在 Commit 时，只需遍历 Effect List 链表，对链表中的副作用执行相应的 mutation 操作。在新版中 React 中去除了 Effect List 的概念，使用 subtreeFlags 的概念。 subtreeFlags 将子树的的 EffectTag 通过冒泡的方式收集到父节点（实际上是组件节点，参见 completeWork 函数）上，在 Commit 时，再根据收集到的 subtreeFlags 遍历子树，为子节点执行相应的 mutation 操作。\n\n具体的细节可以参考：React Effects List 大重构，是为了他？。\n\n\n# 问题\n\n\n# 总结\n\n本文主要讲述了 WorkLoop 过程中 “捕获” 与 “冒泡” 机理，以及在冒泡过程中所做的重要的后置工作。\n\n * completeUnitOfWork 函数的核心职责是控制冒泡的过程以及完成在冒泡过程中的后置工作。“冒泡” 是从当前节点向兄弟节点或者是父节点移动的过程，在整个 WorkLoop 中会遍历到每一个节点，并且在节点上一次执行 beginWork 和 completeWork 。 beginWork 执行的工作可称之为前置工作，主要是 Fiber 节点的调和和 EffectTag 的标记； completeWork 中执行的工作可称之为后置工作，主要是优先级和副作用的收集和更新。\n\n\n# 参考",normalizedContent:"# 目录\n\n\n\n * 目录\n * 前言\n * completeunitofwork\n * completework\n * bubbleproperties\n * render 阶段的终结\n * 扩展\n   * bubbleproperties 中为什么要收集 subtreeflags?\n * 问题\n * 总结\n * 参考\n\n\n\n\n# 前言\n\n在上文中，我们探讨了 react 调和过程中捕获的详细过程和原理。在整体上而言，捕获过程分成两个步骤，“调和当前节点” 和 “调和子节点”，“调和当前节点” 就是对 workinprogress 的节点（ indeterminatecomponent 、 lazycomponent 、 functioncomponent 、 classcomponent 等）进行调和，不同的组件类型有不同的调和策略，“调和子节点” 就是对将 jsx 榨取出的 reactelement 作为子节点进行调和，这其中大致又可分成两个步骤，即所谓 “调和” 和 “置位”，其中调和就是针对旧节点是否可复用而采取复用或者新建的方式获取子节点，应用最新的 state 和 props 等，最新获取整个调和完毕的 fibertree，另外，“置位” 就是针对子节点标记副作用，这对本文或者后文中所述的副作用收集、dom 的更新至关重要。\n\n在本文中，我们回转头来，从 “捕获过程” 的细节万花筒的浮出，继续深入探索 react 调和中的 “冒泡过程”。\n\n还记得 “捕获过程” 转换到 “冒泡过程” 的契机在哪里吗？\n\n在 performunitofwork 函数的分析中，有如下的关键代码：\n\nconst next = beginwork(current, unitofwork, subtreerenderlanes);\nif (next === null) {\n  completeunitofwork(unitofwork);\n} else {\n  workinprogress = next;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在前文中我们已经知道，在捕获过程中，如果深入到叶子节点（没有子节点的节点）或者是因无更新而提前结束捕获过程时，都是将 next 悬空并返回，因此在函数 performunitofwork 中如果遇到 next 指针悬空的情况，则意味着捕获过程暂时结束了，可以进行冒泡了。 unitofwork 本身就是 workinprogress 的节点。因此 completeunitofwork 函数即可看做是冒泡过程的入口。而本文的探讨也将由此展开。\n\n注意\n\n由捕获转到冒泡并不意味着不会再进行捕获。事实上，捕获冒泡的过程是对 fibertree 的遍历的过程，因此，在冒泡时（优先遍历 sibling 节点，return 节点次之）遇到新的非叶子结点时，会再次转换到捕获过程。更多细节可参考如何理解 workloop?。\n\n\n# completeunitofwork\n\n此函数在前置工作 beginwork 之后处理当前节点（workinprogress）的后置工作，即 completework 。同时与 performunitofwork 配合，共同完成 fibertree 的遍历过程。\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nfunction completeunitofwork(unitofwork: fiber): void {\n  // attempt to complete the current unit of work, then move to the next\n  // sibling. if there are no more siblings, return to the parent fiber.\n  let completedwork = unitofwork;\n  do {\n    // 从 workinprogress fiber 的 alternate 指针获取到 current fiber\n    const current = completedwork.alternate;\n    // 从 workinprogress fiber 的 return 指针获取到父节点\n    const returnfiber = completedwork.return;\n\n    // 检查 flags 上是否有 incomplete 标记，无此标记即为没有未完成的工作（没有中断或者抛出错误）\n    if ((completedwork.flags & incomplete) === noflags) {\n      // ......\n      // completework 在当前节点上完成工作，并且返回下一个节点（大多数情况下 next 都是 null）\n      const next = completework(current, completedwork, subtreerenderlanes);\n      // workinprogress 指向下一个节点\n      if (next !== null) {\n        workinprogress = next;\n        return;\n      }\n    } else {\n      // fiber 上前述任务未完成，可能有异常抛出，此时清理相关堆栈，进行错误冒泡捕获\n      // unwindwork 在少数清空下回抛出下个任务，如果抛出则继续执行此任务\n      // 注意，这里 return 后续才有可能有捕获过程\n      const next = unwindwork(completedwork, subtreerenderlanes);\n      if (next !== null) {\n        next.flags &= hosteffectmask;\n        workinprogress = next;\n        return;\n      }\n      // ......\n      // 因当前 returnfiber 为 incomplete 状态，因此添加相关标记\n      if (returnfiber !== null) {\n        // mark the parent fiber as incomplete and clear its subtree flags.\n        returnfiber.flags |= incomplete;\n        returnfiber.subtreeflags = noflags;\n        returnfiber.deletions = null;\n      }\n    }\n    // 有兄弟节点时，移动到兄弟节点（有可能 beginwork 或者 completework）\n    const siblingfiber = completedwork.sibling;\n    if (siblingfiber !== null) {\n      workinprogress = siblingfiber;\n      return;\n    }\n    // 无兄弟节点时移动到父节点，将 completedwork 和 workinprogress 指针均移动到父节点\n    // 注意：这里并没有 return，这是因为父节点不需要重复捕获，继续冒泡即可，等移动到父节点的兄弟节点在考虑是否需要捕获\n    completedwork = returnfiber;\n    workinprogress = completedwork;\n  } while (completedwork !== null);\n\n  // 只要有兄弟节点或者父节点，上述循环就不会停止，如果退出循环，说明到达根节点\n  // 将退出状态改为 `rootcompleted`\n  if (workinprogressrootexitstatus === rootincomplete) {\n    workinprogressrootexitstatus = rootcompleted;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n分析如下：\n\n * 前文中在 performunitofwork 中不断向子节点深入， completeunitofwork 中通过循环不断向兄弟节点扩展，这充分体现了 dfs 的原理。其中从代码逻辑上，也可以看出控制 child 、 sibling 、 return 三个指针的移动也是遵循一定的优先级的，dfs 所要求的优先级正是： child -> sibling -> return 。\n * 在当前节点执行 completeunitofwork 时，会根据节点上是否有 incomplete 标记（是否 beginwork 的前置任务未完成），选择不同的策略。正常情况下，执行 completework 来完成节点上后续任务。\n * 当 workloop 遍历完毕返回到根节点时，将退出状态改成 rootcompleted 。此状态将在 renderrootsync 或者 renderrootconcurrent 函数中被返回。在函数 performsyncworkonroot 或者 performconcurrentworkonroot 中，结束 render 阶段进行 commit 阶段。\n * workinprogressrootexitstatus 表示 workinprogress 的 rootfiber 在退出时的状态。workloop 所展开的 “捕获与冒泡” 的遍历过程，最终会返回到根节点，此时整个过程执行的状态就标记于此。\n\n扩展\n\nrootexitstatus 有如下的状态：\n\ntype rootexitstatus = 0 | 1 | 2 | 3 | 4 | 5;\nconst rootincomplete = 0; // 任务尚未完成\nconst rootfatalerrored = 1; // 发生致命错误\nconst rooterrored = 2; // 发生错误\nconst rootsuspended = 3; // 任务被暂停\nconst rootsuspendedwithdelay = 4; // 任务被延迟\nconst rootcompleted = 5; // 任务已经完成\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# completework\n\n从 completeunitofwork 函数中，我们已经获知， completework 事实上是为了完成 workinprogress fiber 节点上的后置工作。那么具体要哪些工作呢？我们继续往下看：\n\nfunction completework(\n  current: fiber | null,\n  workinprogress: fiber,\n  renderlanes: lanes,\n): fiber | null {\n  const newprops = workinprogress.pendingprops;\n  // ......\n  switch (workinprogress.tag) {\n    case indeterminatecomponent:\n    case lazycomponent:\n    case simplememocomponent:\n    case functioncomponent:\n    case forwardref:\n    case fragment:\n    case mode:\n    case profiler:\n    case contextconsumer:\n    case memocomponent:\n      bubbleproperties(workinprogress);\n      return null;\n    case classcomponent: {\n      // ......\n      bubbleproperties(workinprogress);\n      return null;\n    }\n    case hostroot: {\n      // ......\n      bubbleproperties(workinprogress);\n      return null;\n    }\n    case hostcomponent: {\n      // ......\n      bubbleproperties(workinprogress);\n      return null;\n    }\n    case hosttext: {\n      // ......\n      bubbleproperties(workinprogress);\n      return null;\n    }\n    case suspensecomponent: /*......*/\n    case hostportal:\n      // ......\n      bubbleproperties(workinprogress);\n      return null;\n    case contextprovider:\n      // ......\n      bubbleproperties(workinprogress);\n      return null;\n    case incompleteclasscomponent: {\n      // ......\n      bubbleproperties(workinprogress);\n      return null;\n    }\n    case suspenselistcomponent:  /*......*/\n    case scopecomponent:  /*......*/\n    case offscreencomponent:\n    case legacyhiddencomponent:  /*......*/\n    case cachecomponent: /*......*/\n  }\n  // ......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n由上大致可以看出，最重要的内容是要执行 bubbleproperties 函数。其余细节不在赘述。\n\n\n# bubbleproperties\n\n此函数的目的是通过遍历节点下的下级子节点以收集节点的 childlanes 和 subtreeflags 。结合整个冒泡过程来看，这实际上从 fibertree 的底部向上冒泡以不断的更新属性。 childlanes 和 subtreeflags 本别对应着节点的优先级和服副作用标记，都是极其重要的属性。\n\nfunction bubbleproperties(completedwork: fiber) {\n  // 判断是否是根据 bailoutonalreadyfinishedwork 结束 beginwork 的\n  // child 相等说明复用了子树，见 clonechildfibers\n  const didbailout =\n    completedwork.alternate !== null &&\n    completedwork.alternate.child === completedwork.child;\n  // ......\n  let newchildlanes = nolanes;\n  let subtreeflags = noflags;\n  let child = completedwork.child;\n  while (child !== null) {\n    newchildlanes = mergelanes(\n      newchildlanes,\n      mergelanes(child.lanes, child.childlanes),\n    );\n    subtreeflags |= child.subtreeflags;\n    subtreeflags |= child.flags;\n    child.return = completedwork;\n    child = child.sibling;\n  }\n\n  completedwork.subtreeflags |= subtreeflags;\n  completedwork.childlanes = newchildlanes;\n\n  return didbailout;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n参见如下分析：\n\n * didbailout 是判断是否是通过 bailout （中文意思是 “保释”） 的方式退出捕获过程的， bailout 的方式和正常方式在此处有细微的区分，但是可以忽略。\n\n\n# render 阶段的终结\n\nrender 阶段的终结，就意味着 commit 阶段的开始。我们已经知道了一个正常的（忽略错误情况）渲染周期包括 batch 阶段、 render 阶段和 commit 阶段，也就是所谓的 executioncontext 。 batch 阶段主要是接受更新和调度请求， render 阶段主要是对调度的回调做出反应，开启渲染（调和）的过程， commit 阶段对 render 阶段的调和结果进行确认，并且将更新落实到不同的 host 宿主环境中，如 web 环境、ssr 环境。\n\nreact 应用生命的大部分时间都是处于 batch 阶段，只有少部分时间切片分配给了 render 阶段，并且 render 阶段还可以被调度器通过 yield 的方式打断，极少部分的时间处于 commit 阶段，且 commit 阶段是不可打断的。这种情况也符合视图渲染框架的要求预期，因为 batch 阶段才是最稳定的，是常态的； render 的过程在调度器回调后产生，渲染的频率应当是高效且可控的，要把握更新频率和性能损耗的一个平衡（这里可以理解为刷新率的概念，后文我们将在调度器中体会这一点），最后 commit 阶段是最不稳定的，因为这里涉及到 workinprogress fibertree 和 current fibertree 的交换过程，应当确保这个过程尽快完成，以免影响到页面渲染的平滑性。可以参考下图加深理解：\n\n本文分析到这里， render 阶段大致就告一段落，更深入的细节可以另行探讨，但是整体的调和的脉络必须向前推进了。下面我们在来重温下此两阶段切换的细节。在 performsyncworkonroot 和 performconcurrentworkonroot 函数（参见：react 调和器核心源码解读（二））中有如下代码：\n\n// performsyncworkonroot\nlet exitstatus = renderrootsync(root, lanes);\n// performconcurrentworkonroot\nlet exitstatus = shouldtimeslice\n    ? renderrootconcurrent(root, lanes)\n    : renderrootsync(root, lanes);\n\nconst finishedwork: fiber = (root.current.alternate: any);\nroot.finishedwork = finishedwork;\nroot.finishedlanes = lanes;\n// performsyncworkonroot\ncommitroot(root);\n// performconcurrentworkonroot\nfinishconcurrentrender(root, exitstatus, lanes);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n我们已经知道了，上述两个函数实际上控制着 render 过程和 commit 过程，在 render 结束之后，最重要的是产生了 finishedwork 和 finishedlanes ，分别代表着调和完毕的 workinprogress fibertree 和 lanes（优先级），在后文的 commit 过程中，将会对此做进一步的处理。\n\n另外还有一点需要注意的是，react 整体的生命周期（注意，这里不是指组件的生命周期，而是指上述的三个阶段）的控制是在 root ，即 fiberroot 容器上控制的，这也是由双缓存结构所决定的，因为 fiberroot 上 current 和 finishedwork 指针分别指向两棵 fibertree。相对应的 current 节点和 workinprogress 节点之间是通过 alternate 指针相连接的。\n\n在下一篇文章中，我们将继续探讨 commit 阶段的原理，拭目以待吧。\n\n\n# 扩展\n\n\n# bubbleproperties 中为什么要收集 subtreeflags ?\n\n在 react 旧版本中，在捕获时会将 fiber 节点上的 effecttag 进行收集，形成 effect list 链表，因此，在 commit 时，只需遍历 effect list 链表，对链表中的副作用执行相应的 mutation 操作。在新版中 react 中去除了 effect list 的概念，使用 subtreeflags 的概念。 subtreeflags 将子树的的 effecttag 通过冒泡的方式收集到父节点（实际上是组件节点，参见 completework 函数）上，在 commit 时，再根据收集到的 subtreeflags 遍历子树，为子节点执行相应的 mutation 操作。\n\n具体的细节可以参考：react effects list 大重构，是为了他？。\n\n\n# 问题\n\n\n# 总结\n\n本文主要讲述了 workloop 过程中 “捕获” 与 “冒泡” 机理，以及在冒泡过程中所做的重要的后置工作。\n\n * completeunitofwork 函数的核心职责是控制冒泡的过程以及完成在冒泡过程中的后置工作。“冒泡” 是从当前节点向兄弟节点或者是父节点移动的过程，在整个 workloop 中会遍历到每一个节点，并且在节点上一次执行 beginwork 和 completework 。 beginwork 执行的工作可称之为前置工作，主要是 fiber 节点的调和和 effecttag 的标记； completework 中执行的工作可称之为后置工作，主要是优先级和副作用的收集和更新。\n\n\n# 参考",charsets:{cjk:!0},lastUpdated:"2022/08/01, 20:37:47",lastUpdatedTimestamp:1659357467e3},{title:"React 源码漂流记：React 调和器核心源码解读（七）",frontmatter:{title:"React 源码漂流记：React 调和器核心源码解读（七）",date:"2022-08-01T12:02:21.000Z",permalink:"/react/tour/react-reconciliation-7/",categories:["react","React源码漂流记"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/150.react-reconciliation-7.html",relativePath:"10.react/90.React源码漂流记/150.react-reconciliation-7.md",key:"v-448ef2bf",path:"/react/tour/react-reconciliation-7/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:17},{level:2,title:"finishConcurrentRender",slug:"finishconcurrentrender",normalizedTitle:"finishconcurrentrender",charIndex:23},{level:2,title:"commitRoot",slug:"commitroot",normalizedTitle:"commitroot",charIndex:49},{level:2,title:"EffectList 的遍历",slug:"effectlist-的遍历",normalizedTitle:"effectlist 的遍历",charIndex:63},{level:2,title:"commitBeforeMutationEffects",slug:"commitbeforemutationeffects",normalizedTitle:"commitbeforemutationeffects",charIndex:81},{level:2,title:"commitMutationEffects",slug:"commitmutationeffects",normalizedTitle:"commitmutationeffects",charIndex:112},{level:2,title:"commitLayoutEffects",slug:"commitlayouteffects",normalizedTitle:"commitlayouteffects",charIndex:137},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:160},{level:3,title:"commitRootImpl 三次执行 flushPassiveEffects 有何含义？",slug:"commitrootimpl-三次执行-flushpassiveeffects-有何含义",normalizedTitle:"commitrootimpl 三次执行 flushpassiveeffects 有何含义？",charIndex:168},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:217},{level:3,title:"为什么在 layout 阶段之后需要 requestPaint?",slug:"为什么在-layout-阶段之后需要-requestpaint",normalizedTitle:"为什么在 layout 阶段之后需要 requestpaint?",charIndex:225},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:261},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:267}],readingTime:{text:"8 min read",minutes:7.08,time:424800,words:1416},headersStr:"目录 前言 finishConcurrentRender commitRoot EffectList 的遍历 commitBeforeMutationEffects commitMutationEffects commitLayoutEffects 扩展 commitRootImpl 三次执行 flushPassiveEffects 有何含义？ 问题 为什么在 layout 阶段之后需要 requestPaint? 总结 参考",content:"# 目录\n\n\n\n * 目录\n * 前言\n * finishConcurrentRender\n * commitRoot\n * EffectList 的遍历\n * commitBeforeMutationEffects\n * commitMutationEffects\n * commitLayoutEffects\n * 扩展\n   * commitRootImpl 三次执行 flushPassiveEffects 有何含义？\n * 问题\n   * 为什么在 layout 阶段之后需要 requestPaint?\n * 总结\n * 参考\n\n\n\n\n# 前言\n\n在上篇文章中，我们对 React 渲染过程中的 “捕获” 与 “冒泡” 过程的理解有了更深一层的认识，并且从整体脉络上总结了 Batch 阶段和 Render 阶段的过程。从本文开始，我们将开始探讨 Commit 阶段的原理，逐步了解 FiberTree 向 DOMTree 飞跃的过程。\n\n渲染根据调度方式的不同被分成了同步渲染和异步渲染，在同步的渲染结束后调用 commitRoot 提交本次的调和结果，而在异步渲染结束后是通过 finishConcurrentRender 来处理后续的工作的。下面我们就从 finishConcurrentRender 函数开始深入分析。\n\n\n# finishConcurrentRender\n\n从本质上来说 finishConcurrentRender 的核心作用还是执行 commitRoot 以提交调和结果，但是相比同步渲染而言，异步渲染要更加复杂，换句话说， Render 结束后要视情况而定是否需要立即 Commit ，要根据 Render 阶段的执行情况（exitStatus）加以确认。 Commit 的操作应当足够高效，因为 DOM 的绘制过程成本不菲。\n\nfunction finishConcurrentRender(root, exitStatus, lanes) {\n  switch (exitStatus) {\n    // ......\n    case RootErrored: {\n      commitRoot(root);\n      break;\n    }\n    case RootSuspended:\n    case RootSuspendedWithDelay: {\n      markRootSuspended(root, lanes);\n      // ......\n      // The work expired. Commit immediately.\n      commitRoot(root);\n      break;\n    }\n    case RootCompleted: {\n      // The work completed. Ready to commit.\n      commitRoot(root);\n      break;\n    }\n    //  ......\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n分析如下：\n\n * 只有在发生普通错误的时候才允许提交， RootIncomplete (未完成状态) 和 RootFatalErrored （致命错误状态）是不允许提交的。这也很符合预期，因为在进入此函数之前，普通错误就已经重试多次了。\n * 对于 RootSuspended 和 RootSuspendedWithDelay ，必须等到任务超时，才能够进行提交。\n\n\n# commitRoot\n\ncommitRoot 主要调用 commitRootImpl 函数，源码如下：\n\nfunction commitRootImpl(root, renderPriorityLevel) {\n  do {\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n    // means `flushPassiveEffects` will sometimes result in additional\n    // passive effects. So we need to keep flushing in a loop until there are\n    // no more pending effects.\n    flushPassiveEffects();\n  } while (rootWithPendingPassiveEffects !== null);\n  // ......\n  // 确保当前是 Batch 状态\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n  const finishedWork = root.finishedWork;\n  // 当前 commit 的优先级\n  const lanes = root.finishedLanes;\n  // ......\n  // 合并finishedWork子树的 lanes，剩余的未处理的优先级\n  let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\n  // 将剩余未处理的优先级挂载到 root.pendingLanes 上\n  markRootFinished(root, remainingLanes);\n  // ......\n  // If there are pending passive effects, schedule a callback to process them.\n  // Do this as early as possible, so it is queued before anything else that\n  // might get scheduled in the commit phase. \n  // 确保子树有 PassiveMask 副作用时被调度以处理副作用\n  // const PassiveMask = Passive | ChildDeletion;\n  if (\n    (finishedWork.subtreeFlags & PassiveMask) !== NoFlags ||\n    (finishedWork.flags & PassiveMask) !== NoFlags\n  ) {\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      // ......\n      scheduleCallback(NormalSchedulerPriority, () => {\n        flushPassiveEffects();\n        // This render triggered passive effects\n        return null;\n      });\n    }\n  }\n\n  // Check if there are any effects in the whole tree.\n  // 判断子树是否有副作用\n  const subtreeHasEffects =\n    (finishedWork.subtreeFlags &\n      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==\n    NoFlags;\n  // 判断根节点是否有副作用\n  const rootHasEffect =\n    (finishedWork.flags &\n      (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==\n    NoFlags;\n  // 如果子树或者根节点有副作用，则处理之\n  if (subtreeHasEffects || rootHasEffect) {\n    // ......\n    const prevExecutionContext = executionContext;\n    // executionContext 更新为 CommitContext\n    executionContext |= CommitContext;\n    // ......\n    // The commit phase is broken into several sub-phases. We do a separate pass\n    // of the effect list for each phase: all mutation effects come before all\n    // layout effects, and so on.\n\n    // The first phase a \"before mutation\" phase. We use this phase to read the\n    // state of the host tree right before we mutate it. This is where\n    // getSnapshotBeforeUpdate is called.\n    // Commit  阶段分成三个步骤，分别是 before mutation, mutation 和 layout。\n    // before mutation 阶段在 mutation 之前读取旧状态，并调用相关的组件生命周期函数\n    const shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(\n      root,\n      finishedWork,\n    );\n    // ......\n    // The next phase is the mutation phase, where we mutate the host tree.\n    // mutation 阶段对副作用进行执行和更新，执行 DOM 操作，调用相关的生命周期函数\n    commitMutationEffects(root, finishedWork, lanes);\n    // ......\n    // The work-in-progress tree is now the current tree. This must come after\n    // the mutation phase, so that the previous tree is still current during\n    // componentWillUnmount, but before the layout phase, so that the finished\n    // work is current during componentDidMount/Update.\n    // workInProgress 树切换到current树的时机是在mutation结束后，layout开始前。\n    // 这样做的原因是在mutation阶段调用类组件的componentWillUnmount的时候，还可以获取到卸载前的组件信息；\n    // 在layout阶段调用componentDidMount/Update时，获取的组件信息更新后的。\n    root.current = finishedWork;\n    // The next phase is the layout phase, where we call effects that read\n    // the host tree after it's been mutated. The idiomatic use case for this is\n    // layout, but class component lifecycles also fire here for legacy reasons.\n    // layout 阶段在 mutation 阶段之后，读取组件的最新状态，并执行相关的生命周期函数\n    commitLayoutEffects(finishedWork, root, lanes);\n    // ......\n    // Tell Scheduler to yield at the end of the frame, so the browser has an\n    // opportunity to paint.\n    // 请求调度器在帧尾阻塞 `Render` 过程，以使浏览器有足够的空闲时间绘制视图\n    requestPaint();\n    // Commit 完毕后恢复  executionContext \n    executionContext = prevExecutionContext;\n    // ......\n  } \n  \n  if (\n    includesSomeLane(pendingPassiveEffectsLanes, SyncLane) &&\n    root.tag !== LegacyRoot\n  ) {\n    flushPassiveEffects();\n  }\n  // ......\n  // 退出 commitRoot 时调用，确保 Root 上新的任务会被调度\n  ensureRootIsScheduled(root, now());\n  // ......\n  // If layout work was scheduled, flush it now.\n  flushSyncCallbacks();\n  // ......\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n\n\n此函数涵盖了 Commit 阶段的整个过程，有一些细节问题分析如下：\n\n * flushPassiveEffects : flushPassiveEffects 主要与 useEffect 的副作用相关，此函数以同步或者异步的方式执行 useEffect 的销毁函数和回调函数。细节部分将在 hook 相关章节进行详细探讨。如果子树有 PassiveMask 标记，则在调度器的回调中调用 flushPassiveEffects 。\n * 有四种副作用标记被用来判断是否需要 Commit ，分别是： BeforeMutationMask 、 MutationMask 、 LayoutMask 、 PassiveMask 。当 finishedWork 根节点上或者子树上具有如上的副作用，则执行 Commit 操作。\n * Commit 过程分成三个步骤，分别是 beforeMutation 、 mutation 和 layout ，分别调用 commitBeforeMutationEffects 、 commitMutationEffects 和 commitLayoutEffects 。\n * workInProgress FiberTree 成为 current FiberTree 是在 mutation 阶段之后、layout 阶段之前完成的， root.current = finishedWork 。之前的 current FiberTree 现在利索当前的就成了 workInProgress FiberTree 。\n * 在 mutation 阶段，React 已经根据 EffectTag 操纵 JavaScript 对 DOM 进行了插入、更新、删除等操作，由于浏览器的空闲时间实际上是被调度器控制的，所以在 layout 阶段完成之后，需要通知调度器进行 yield（阻塞渲染回调），给浏览器重绘留下充足的时间。 requestPaint 函数将在调度器部分进行详细的分析。\n\n旧版本的执行逻辑\n\n三个阶段：\n\n * before mutation：读取组件变更前的状态，针对类组件，调用 getSnapshotBeforeUpdate，让我们可以在 DOM 变更前获取组件实例的信息；针对函数组件，异步调度 useEffect。\n * mutation：针对 HostComponent，进行相应的 DOM 操作；针对类组件，调用 componentWillUnmount；针对函数组件，执行 useLayoutEffect 的销毁函数。\n * layout：在 DOM 操作完成后，读取组件的状态，针对类组件，调用生命周期 componentDidMount 和 componentDidUpdate，调用 setState 的回调；针对函数组件填充 useEffect 的 effect 执行数组，并调度 useEffect。\n\n在进入下面三个核心函数的分析之前，我们需要先分析一下 FiberTree 上 Effect 的遍历过程。从上文中我们已经知道了，新版的 React 去除了 EffectList 的概念，将 Effect 冒泡收集到 subtreeFlags 标记上。因此，在对 EffectList 的遍历时，就不能直接使用旧版中链表的遍历方式。\n\n\n# EffectList 的遍历\n\n下面以 commitMutationEffects 探讨 FiberTree 中 EffectList 的遍历过程。这里同样分为 “捕获” 和 “冒泡” 的过程，将遍历过程穿插执行的工作可以理解为 beginWork 和 completeWork 。（注意，此时遍历的原理与调和 FiberTree 时遍历的原理一致）。\n\n// src/react/packages/react-reconciler/src/ReactFiberCommitWork.new.js\nfunction commitMutationEffects( \n  root: FiberRoot,\n  firstChild: Fiber,\n  ) {\n  nextEffect = firstChild;\n  commitMutationEffects_begin(root);\n}\n\nfunction commitMutationEffects_begin(root: FiberRoot) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n    // begin work......（beginWork插槽）\n    const child = fiber.child;\n    // MutationMask 或者 BeforeMutationMask 或者 LayoutMask\n    // 如果当前 Fiber 有 subtreeFlags，说明子树中有相应的 EffectTag\n    // 这里的判断决定是否需要继续捕获\n    if ((fiber.subtreeFlags & MutationMask) !== NoFlags && child !== null) {\n      // ......\n      // 将子节点作为下一个遍历的节点，向下捕获\n      nextEffect = child;\n    } else {\n      // 不符合上述条件，说明子树中无响应的 EffectTag，因此开始冒泡\n      commitMutationEffects_complete(root);\n    }\n  }\n}\n\nfunction commitMutationEffects_complete(root: FiberRoot) {\n  while (nextEffect !== null) {\n    const fiber = nextEffect;\n\n    // complete work......（completeWork插槽）\n    // 冒泡时先冒泡到兄弟节点，无兄弟节点时再冒泡到父节点\n    // 冒泡一次后需要仅此进行捕获的判断，因此需要 return\n    const sibling = fiber.sibling;\n    if (sibling !== null) {\n      // ......\n      nextEffect = sibling;\n      return;\n    }\n    nextEffect = fiber.return;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n弄清楚上述的 “捕获” 和 “冒泡” 的遍历过程之后，在下文中 commitBeforeMutationEffects 、 commitMutationEffects 和 commitLayoutEffects 三个函数中都是对此遍历方法的应用。因此在下文的分析中，我们将着重探讨 beginWork 和 completeWork 插槽中的工作细节。\n\n\n# commitBeforeMutationEffects\n\n// completeWork插槽\ncommitBeforeMutationEffectsOnFiber(fiber);\n\n\n1\n2\n\n\n分析如下：\n\n * 在冒泡阶段在 fiber 上执行 commitBeforeMutationEffectsOnFiber 。\n\n\n# commitMutationEffects\n\n// beginWork插槽\nconst deletions = fiber.deletions;\nif (deletions !== null) {\n  for (let i = 0; i < deletions.length; i++) {\n    const childToDelete = deletions[i];\n    commitDeletion(root, childToDelete, fiber);\n    // ......\n  }\n}\n// completeWork插槽\ncommitMutationEffectsOnFiber(fiber, root);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n分析如下：\n\n * 在捕获阶段查找 fiber 上 deletions 收集的待删除的节点，并且提交节点的删除。\n * 在冒泡阶段调用 commitMutationEffectsOnFiber 。\n * 为什么删除操作要在捕获阶段单独进行，而不是放在冒泡阶段一起处理？因为删除操作相对于更新操作（添加或者更新）而言要简单许多，在当前已经遍历到的节点上，只需将前置工作中收集到的待删除的节点进行处理即可；相对而言， commitMutationEffectsOnFiber 的处理过程则要复杂的多，需要通过不同的 EffectTag 以进行不同的处理，并且处理方式也与组件的类型有很大的关联。所以此处将删除操作在捕获时即执行，一是因为删除操纵本身与 EffectTag 类型、组件类型无关，而是因为提前处理能够避免 DOM 操作的混乱性。\n\n\n# commitLayoutEffects\n\n// completeWork插槽\nif ((fiber.flags & LayoutMask) !== NoFlags) {\n  const current = fiber.alternate;\n  // ......\n  commitLayoutEffectOnFiber(root, current, fiber, committedLanes);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n分析如下：\n\n * 在捕获阶段执行 commitLayoutEffectOnFiber ，但需使 fiber 上具有 LayoutMask 标记。\n\n我们可能已经注意到，在上述 commitBeforeMutationEffectsOnFiber 、 commitMutationEffectsOnFiber 函数中，都没有 EffectTag 的标记要求，而 commitLayoutEffectOnFiber 却要求 fiber 具有 LayoutMask 标记。事实上 MutationMask 、 BeforeMutationMask 或者 LayoutMask 都是 EffectTag 的集合：\n\n// Groups of flags that are used in the commit phase to skip over trees that\n// don't contain effects, by checking subtreeFlags.\nexport const BeforeMutationMask = Update | Snapshot | ChildDeletion | Visibility;\nexport const MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;\nexport const LayoutMask = Update | Callback | Ref | Visibility;\n\n\n1\n2\n3\n4\n5\n\n\n通过判断 subtreeFlags 上是否有这个 EffectTag 的组合，可以使捕获和冒泡的过程能够进行的针对需要进行操作的节点进行处理。\n\n\n# 扩展\n\n\n# commitRootImpl 三次执行 flushPassiveEffects 有何含义？\n\n首先需要明确的是， flushPassiveEffects 是与 useEffect 所产生的的副作用是密切相关的，在发生一次 “渲染” 的前后，需要对这种 Passive 的副作用进行处理，包括执行副作用的销毁函数和副作用函数。\n\n所谓副作用，是在某些触发渲染的时机上执行 DOM 操作、网络请求、日志打印、事件订阅、定时任务等行为。副作用是不能直接在组件主体（函数式组件）中执行的，因为 React 无法保证副作用在执行时所处的环境是正确的。事实上，在函数主体执行时，React 还处于调和阶段，并没有 Commit 下一次的渲染，况且直接在函数体中执行的副作用会极大的阻塞调和的效率（参照前文内容）。\n\n因此，在函数式组件的主体函数中应当遵循 “只定义组件的特性和行为方式（包括视图的定义、事件回调的定义、副作用的定义、状态和计算属性的定义，因此可以把函数式组件分成 Render 、 Callback/Handler 、 Effect 和 Props/State 四个部分），不进行高成本的计算 “的原则，“JSX” 本质上是一种动态的描述和定义组件的语法糖。组件的状态和行为的变化应该由副作用和事件机制来推动。（注意：副作用虽然可以用来模拟类似于类组件的生命周期，但是其理念是极为不同的，相比而言，副作用是函数式编程的产物，要更为灵活和高效，按照生命周期的想法去编写函数式组件是错误的，React 中提供的副作用钩子并不能准确的翻译 / 转化为类组件各种生命周期！参见 Hook 会因为在渲染时创建函数而变慢吗？。）\n\n回归整体， commitRootImpl 函数中共有三次 flushPassiveEffects 的调用：\n\n// [1]\ndo {flushPassiveEffects()} while (rootWithPendingPassiveEffects !== null); \n\n// [2]\nscheduleCallback(NormalSchedulerPriority, () => flushPassiveEffects());\n\n// [3]\nif (includesSomeLane(pendingPassiveEffectsLanes, SyncLane)) flushPassiveEffects();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 第一次执行 flushPassiveEffects 是在 Commit 三大步骤未开始之前执行的，目的是判断是否有残留的 passiveEffects （useEffect 的副作用） 未执行，如果有则调用 flushPassiveEffects 处理之。之所有用 while 循环是因为副作用有可能产生新的副作用（注意：在函数式组件中，应该避免副作用之间相互调用以免造成死循环）。\n * 第二次执行 flushPassiveEffects 是在 Commit 三大步骤未开始之前请求一次 flushPassiveEffects 的调度，从前文中我们已经知道， Commit 步骤中会阻塞 Render 过程，但是并不会阻塞调度过程，因此，此次 flushPassiveEffects 调度能够保证其执行时间能够在本次 Commit 阶段之后，也就是说 传给 useEffect 的函数会在浏览器完成布局与绘制之后，在一个延迟事件中被调用 ，参见 effect 的执行时机。\n * 第三次执行 flushPassiveEffects 是在 root.finishedLanes 中有同步的 lanes 的时机下，这说明本次副作用的处理的优先级较高，需同步执行。 从 React 18 开始，当它是离散的用户输入（如点击）的结果时，或者当它是由 flushSync 包装的更新结果时，传递给 useEffect 的函数将在屏幕布局和绘制之前同步执行 ，参见 effect 的执行时机。\n\n重点提示\n\n * flushPassiveEffects 的执行是异步的，是通过调度器的调度完成的，但是可以保证相关的副作用是在当前 Commit 之后，也即视图更新渲染之后执行。\n * useEffect 中的副作用的执行时机是： Commit 完成之后进入 Batch 阶段中的某一次调度器的回调中，进一步将就是，屏幕视图布局和绘制之后的一个延迟事件中。 useEffect 中副作用的执行是异步的。\n * useEffect 中的副作用也可以同步的执行（ useLayoutEffect 中副作用执行之后，在 Commit 完成之时），当然这需要特殊的条件。\n\n\n# 问题\n\n\n# 为什么在 layout 阶段之后需要 requestPaint ?\n\n提示\n\nBy default, the browser will wait until the current thread of execution finishes and do one consolidated reflow and repaint (as this is considered more efficient than doing many reflows and repaints). This is not specified in any specification so the browser can implement as it wants to.\n\nBut, there are some specific operations that will generally trigger a reflow (and sometimes a corresponding repaint). These operations are operations (requesting certain properties related to the position of elements) which can only be completed when an accurate reflow has been done. So, it is possible to manually trigger a reflow by requesting one of these properties.\n\n参见：html - When does the DOM repaint during Javascript routines? - Stack Overflow\n\n默认情况下，浏览器会在当前线程执行完成之后，执行一次合并的 reflow 和 repaint 。但是也存在一些特殊的情况会触发 reflow ，这就是执行那些只有在 reflow 之后才能完成的任务。因此，操纵 JavaScript 执行 DOM 操作并不是会立即促使浏览器进行 repaint ，这其中浏览器有诸多优化措施以保证 reflow 和 repaint 高效的进行。\n\n\n# 总结\n\n本文中最最要的内容是对 commitRoot 函数的分析。 commitRoot 是 Commit 阶段提纲挈领的函数，它将整个 Commit 的过程分成了最要的三个步骤，分别是 beforeMutation 、 mutation 和 layout 。这三个步骤分别调用 commitBeforeMutationEffects 、 commitMutationEffects 和 commitLayoutEffects 函数进行处理，总结其特性分别是 commitBeforeMutationEffects 提供组件更新之前的实例数据， commitMutationEffects 操作原生 JavaScript 更新 DOM 节点，处理组件销毁前的副作用， commitLayoutEffects 处理组件挂载后（更新后）的副作用。\n\n另外一个重点是， workInProgress 树切换为 current 树的过程是在 mutation 之后 layout 之前完成的。三个步骤完成之后需要通知调度器进行 yield （中断 Render 阶段的执行），从而使浏览器有足够的时间对 mutation 阶段造成的 DOM 更新进行重排（reflow）和重绘（repaint）。\n\n上述三个步骤追根究底还是在 EffectList （沿用旧版本的概念） 的遍历过程中执行的，其总体过程可归纳为 “跳跃式的”（可精准的针对有相关 EffectTagMask 的节点进行操作）“捕获与冒泡” 的过程，其内部逻辑同样可抽象为 beginWork 和 completeWork 的工作。上述三个步骤其实质是要执行 commitBeforeMutationEffectsOnFiber 、 commitMutationEffectsOnFiber 和 commitLayoutEffectOnFiber 函数。\n\n\n# 参考\n\n * 旧版本：React 源碼 commit 階段詳解",normalizedContent:"# 目录\n\n\n\n * 目录\n * 前言\n * finishconcurrentrender\n * commitroot\n * effectlist 的遍历\n * commitbeforemutationeffects\n * commitmutationeffects\n * commitlayouteffects\n * 扩展\n   * commitrootimpl 三次执行 flushpassiveeffects 有何含义？\n * 问题\n   * 为什么在 layout 阶段之后需要 requestpaint?\n * 总结\n * 参考\n\n\n\n\n# 前言\n\n在上篇文章中，我们对 react 渲染过程中的 “捕获” 与 “冒泡” 过程的理解有了更深一层的认识，并且从整体脉络上总结了 batch 阶段和 render 阶段的过程。从本文开始，我们将开始探讨 commit 阶段的原理，逐步了解 fibertree 向 domtree 飞跃的过程。\n\n渲染根据调度方式的不同被分成了同步渲染和异步渲染，在同步的渲染结束后调用 commitroot 提交本次的调和结果，而在异步渲染结束后是通过 finishconcurrentrender 来处理后续的工作的。下面我们就从 finishconcurrentrender 函数开始深入分析。\n\n\n# finishconcurrentrender\n\n从本质上来说 finishconcurrentrender 的核心作用还是执行 commitroot 以提交调和结果，但是相比同步渲染而言，异步渲染要更加复杂，换句话说， render 结束后要视情况而定是否需要立即 commit ，要根据 render 阶段的执行情况（exitstatus）加以确认。 commit 的操作应当足够高效，因为 dom 的绘制过程成本不菲。\n\nfunction finishconcurrentrender(root, exitstatus, lanes) {\n  switch (exitstatus) {\n    // ......\n    case rooterrored: {\n      commitroot(root);\n      break;\n    }\n    case rootsuspended:\n    case rootsuspendedwithdelay: {\n      markrootsuspended(root, lanes);\n      // ......\n      // the work expired. commit immediately.\n      commitroot(root);\n      break;\n    }\n    case rootcompleted: {\n      // the work completed. ready to commit.\n      commitroot(root);\n      break;\n    }\n    //  ......\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n分析如下：\n\n * 只有在发生普通错误的时候才允许提交， rootincomplete (未完成状态) 和 rootfatalerrored （致命错误状态）是不允许提交的。这也很符合预期，因为在进入此函数之前，普通错误就已经重试多次了。\n * 对于 rootsuspended 和 rootsuspendedwithdelay ，必须等到任务超时，才能够进行提交。\n\n\n# commitroot\n\ncommitroot 主要调用 commitrootimpl 函数，源码如下：\n\nfunction commitrootimpl(root, renderprioritylevel) {\n  do {\n    // `flushpassiveeffects` will call `flushsyncupdatequeue` at the end, which\n    // means `flushpassiveeffects` will sometimes result in additional\n    // passive effects. so we need to keep flushing in a loop until there are\n    // no more pending effects.\n    flushpassiveeffects();\n  } while (rootwithpendingpassiveeffects !== null);\n  // ......\n  // 确保当前是 batch 状态\n  if ((executioncontext & (rendercontext | commitcontext)) !== nocontext) {\n    throw new error('should not already be working.');\n  }\n  const finishedwork = root.finishedwork;\n  // 当前 commit 的优先级\n  const lanes = root.finishedlanes;\n  // ......\n  // 合并finishedwork子树的 lanes，剩余的未处理的优先级\n  let remaininglanes = mergelanes(finishedwork.lanes, finishedwork.childlanes);\n  // 将剩余未处理的优先级挂载到 root.pendinglanes 上\n  markrootfinished(root, remaininglanes);\n  // ......\n  // if there are pending passive effects, schedule a callback to process them.\n  // do this as early as possible, so it is queued before anything else that\n  // might get scheduled in the commit phase. \n  // 确保子树有 passivemask 副作用时被调度以处理副作用\n  // const passivemask = passive | childdeletion;\n  if (\n    (finishedwork.subtreeflags & passivemask) !== noflags ||\n    (finishedwork.flags & passivemask) !== noflags\n  ) {\n    if (!rootdoeshavepassiveeffects) {\n      rootdoeshavepassiveeffects = true;\n      // ......\n      schedulecallback(normalschedulerpriority, () => {\n        flushpassiveeffects();\n        // this render triggered passive effects\n        return null;\n      });\n    }\n  }\n\n  // check if there are any effects in the whole tree.\n  // 判断子树是否有副作用\n  const subtreehaseffects =\n    (finishedwork.subtreeflags &\n      (beforemutationmask | mutationmask | layoutmask | passivemask)) !==\n    noflags;\n  // 判断根节点是否有副作用\n  const roothaseffect =\n    (finishedwork.flags &\n      (beforemutationmask | mutationmask | layoutmask | passivemask)) !==\n    noflags;\n  // 如果子树或者根节点有副作用，则处理之\n  if (subtreehaseffects || roothaseffect) {\n    // ......\n    const prevexecutioncontext = executioncontext;\n    // executioncontext 更新为 commitcontext\n    executioncontext |= commitcontext;\n    // ......\n    // the commit phase is broken into several sub-phases. we do a separate pass\n    // of the effect list for each phase: all mutation effects come before all\n    // layout effects, and so on.\n\n    // the first phase a \"before mutation\" phase. we use this phase to read the\n    // state of the host tree right before we mutate it. this is where\n    // getsnapshotbeforeupdate is called.\n    // commit  阶段分成三个步骤，分别是 before mutation, mutation 和 layout。\n    // before mutation 阶段在 mutation 之前读取旧状态，并调用相关的组件生命周期函数\n    const shouldfireafteractiveinstanceblur = commitbeforemutationeffects(\n      root,\n      finishedwork,\n    );\n    // ......\n    // the next phase is the mutation phase, where we mutate the host tree.\n    // mutation 阶段对副作用进行执行和更新，执行 dom 操作，调用相关的生命周期函数\n    commitmutationeffects(root, finishedwork, lanes);\n    // ......\n    // the work-in-progress tree is now the current tree. this must come after\n    // the mutation phase, so that the previous tree is still current during\n    // componentwillunmount, but before the layout phase, so that the finished\n    // work is current during componentdidmount/update.\n    // workinprogress 树切换到current树的时机是在mutation结束后，layout开始前。\n    // 这样做的原因是在mutation阶段调用类组件的componentwillunmount的时候，还可以获取到卸载前的组件信息；\n    // 在layout阶段调用componentdidmount/update时，获取的组件信息更新后的。\n    root.current = finishedwork;\n    // the next phase is the layout phase, where we call effects that read\n    // the host tree after it's been mutated. the idiomatic use case for this is\n    // layout, but class component lifecycles also fire here for legacy reasons.\n    // layout 阶段在 mutation 阶段之后，读取组件的最新状态，并执行相关的生命周期函数\n    commitlayouteffects(finishedwork, root, lanes);\n    // ......\n    // tell scheduler to yield at the end of the frame, so the browser has an\n    // opportunity to paint.\n    // 请求调度器在帧尾阻塞 `render` 过程，以使浏览器有足够的空闲时间绘制视图\n    requestpaint();\n    // commit 完毕后恢复  executioncontext \n    executioncontext = prevexecutioncontext;\n    // ......\n  } \n  \n  if (\n    includessomelane(pendingpassiveeffectslanes, synclane) &&\n    root.tag !== legacyroot\n  ) {\n    flushpassiveeffects();\n  }\n  // ......\n  // 退出 commitroot 时调用，确保 root 上新的任务会被调度\n  ensurerootisscheduled(root, now());\n  // ......\n  // if layout work was scheduled, flush it now.\n  flushsynccallbacks();\n  // ......\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n\n\n此函数涵盖了 commit 阶段的整个过程，有一些细节问题分析如下：\n\n * flushpassiveeffects : flushpassiveeffects 主要与 useeffect 的副作用相关，此函数以同步或者异步的方式执行 useeffect 的销毁函数和回调函数。细节部分将在 hook 相关章节进行详细探讨。如果子树有 passivemask 标记，则在调度器的回调中调用 flushpassiveeffects 。\n * 有四种副作用标记被用来判断是否需要 commit ，分别是： beforemutationmask 、 mutationmask 、 layoutmask 、 passivemask 。当 finishedwork 根节点上或者子树上具有如上的副作用，则执行 commit 操作。\n * commit 过程分成三个步骤，分别是 beforemutation 、 mutation 和 layout ，分别调用 commitbeforemutationeffects 、 commitmutationeffects 和 commitlayouteffects 。\n * workinprogress fibertree 成为 current fibertree 是在 mutation 阶段之后、layout 阶段之前完成的， root.current = finishedwork 。之前的 current fibertree 现在利索当前的就成了 workinprogress fibertree 。\n * 在 mutation 阶段，react 已经根据 effecttag 操纵 javascript 对 dom 进行了插入、更新、删除等操作，由于浏览器的空闲时间实际上是被调度器控制的，所以在 layout 阶段完成之后，需要通知调度器进行 yield（阻塞渲染回调），给浏览器重绘留下充足的时间。 requestpaint 函数将在调度器部分进行详细的分析。\n\n旧版本的执行逻辑\n\n三个阶段：\n\n * before mutation：读取组件变更前的状态，针对类组件，调用 getsnapshotbeforeupdate，让我们可以在 dom 变更前获取组件实例的信息；针对函数组件，异步调度 useeffect。\n * mutation：针对 hostcomponent，进行相应的 dom 操作；针对类组件，调用 componentwillunmount；针对函数组件，执行 uselayouteffect 的销毁函数。\n * layout：在 dom 操作完成后，读取组件的状态，针对类组件，调用生命周期 componentdidmount 和 componentdidupdate，调用 setstate 的回调；针对函数组件填充 useeffect 的 effect 执行数组，并调度 useeffect。\n\n在进入下面三个核心函数的分析之前，我们需要先分析一下 fibertree 上 effect 的遍历过程。从上文中我们已经知道了，新版的 react 去除了 effectlist 的概念，将 effect 冒泡收集到 subtreeflags 标记上。因此，在对 effectlist 的遍历时，就不能直接使用旧版中链表的遍历方式。\n\n\n# effectlist 的遍历\n\n下面以 commitmutationeffects 探讨 fibertree 中 effectlist 的遍历过程。这里同样分为 “捕获” 和 “冒泡” 的过程，将遍历过程穿插执行的工作可以理解为 beginwork 和 completework 。（注意，此时遍历的原理与调和 fibertree 时遍历的原理一致）。\n\n// src/react/packages/react-reconciler/src/reactfibercommitwork.new.js\nfunction commitmutationeffects( \n  root: fiberroot,\n  firstchild: fiber,\n  ) {\n  nexteffect = firstchild;\n  commitmutationeffects_begin(root);\n}\n\nfunction commitmutationeffects_begin(root: fiberroot) {\n  while (nexteffect !== null) {\n    const fiber = nexteffect;\n    // begin work......（beginwork插槽）\n    const child = fiber.child;\n    // mutationmask 或者 beforemutationmask 或者 layoutmask\n    // 如果当前 fiber 有 subtreeflags，说明子树中有相应的 effecttag\n    // 这里的判断决定是否需要继续捕获\n    if ((fiber.subtreeflags & mutationmask) !== noflags && child !== null) {\n      // ......\n      // 将子节点作为下一个遍历的节点，向下捕获\n      nexteffect = child;\n    } else {\n      // 不符合上述条件，说明子树中无响应的 effecttag，因此开始冒泡\n      commitmutationeffects_complete(root);\n    }\n  }\n}\n\nfunction commitmutationeffects_complete(root: fiberroot) {\n  while (nexteffect !== null) {\n    const fiber = nexteffect;\n\n    // complete work......（completework插槽）\n    // 冒泡时先冒泡到兄弟节点，无兄弟节点时再冒泡到父节点\n    // 冒泡一次后需要仅此进行捕获的判断，因此需要 return\n    const sibling = fiber.sibling;\n    if (sibling !== null) {\n      // ......\n      nexteffect = sibling;\n      return;\n    }\n    nexteffect = fiber.return;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n弄清楚上述的 “捕获” 和 “冒泡” 的遍历过程之后，在下文中 commitbeforemutationeffects 、 commitmutationeffects 和 commitlayouteffects 三个函数中都是对此遍历方法的应用。因此在下文的分析中，我们将着重探讨 beginwork 和 completework 插槽中的工作细节。\n\n\n# commitbeforemutationeffects\n\n// completework插槽\ncommitbeforemutationeffectsonfiber(fiber);\n\n\n1\n2\n\n\n分析如下：\n\n * 在冒泡阶段在 fiber 上执行 commitbeforemutationeffectsonfiber 。\n\n\n# commitmutationeffects\n\n// beginwork插槽\nconst deletions = fiber.deletions;\nif (deletions !== null) {\n  for (let i = 0; i < deletions.length; i++) {\n    const childtodelete = deletions[i];\n    commitdeletion(root, childtodelete, fiber);\n    // ......\n  }\n}\n// completework插槽\ncommitmutationeffectsonfiber(fiber, root);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n分析如下：\n\n * 在捕获阶段查找 fiber 上 deletions 收集的待删除的节点，并且提交节点的删除。\n * 在冒泡阶段调用 commitmutationeffectsonfiber 。\n * 为什么删除操作要在捕获阶段单独进行，而不是放在冒泡阶段一起处理？因为删除操作相对于更新操作（添加或者更新）而言要简单许多，在当前已经遍历到的节点上，只需将前置工作中收集到的待删除的节点进行处理即可；相对而言， commitmutationeffectsonfiber 的处理过程则要复杂的多，需要通过不同的 effecttag 以进行不同的处理，并且处理方式也与组件的类型有很大的关联。所以此处将删除操作在捕获时即执行，一是因为删除操纵本身与 effecttag 类型、组件类型无关，而是因为提前处理能够避免 dom 操作的混乱性。\n\n\n# commitlayouteffects\n\n// completework插槽\nif ((fiber.flags & layoutmask) !== noflags) {\n  const current = fiber.alternate;\n  // ......\n  commitlayouteffectonfiber(root, current, fiber, committedlanes);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n分析如下：\n\n * 在捕获阶段执行 commitlayouteffectonfiber ，但需使 fiber 上具有 layoutmask 标记。\n\n我们可能已经注意到，在上述 commitbeforemutationeffectsonfiber 、 commitmutationeffectsonfiber 函数中，都没有 effecttag 的标记要求，而 commitlayouteffectonfiber 却要求 fiber 具有 layoutmask 标记。事实上 mutationmask 、 beforemutationmask 或者 layoutmask 都是 effecttag 的集合：\n\n// groups of flags that are used in the commit phase to skip over trees that\n// don't contain effects, by checking subtreeflags.\nexport const beforemutationmask = update | snapshot | childdeletion | visibility;\nexport const mutationmask = placement | update | childdeletion | contentreset | ref | hydrating | visibility;\nexport const layoutmask = update | callback | ref | visibility;\n\n\n1\n2\n3\n4\n5\n\n\n通过判断 subtreeflags 上是否有这个 effecttag 的组合，可以使捕获和冒泡的过程能够进行的针对需要进行操作的节点进行处理。\n\n\n# 扩展\n\n\n# commitrootimpl 三次执行 flushpassiveeffects 有何含义？\n\n首先需要明确的是， flushpassiveeffects 是与 useeffect 所产生的的副作用是密切相关的，在发生一次 “渲染” 的前后，需要对这种 passive 的副作用进行处理，包括执行副作用的销毁函数和副作用函数。\n\n所谓副作用，是在某些触发渲染的时机上执行 dom 操作、网络请求、日志打印、事件订阅、定时任务等行为。副作用是不能直接在组件主体（函数式组件）中执行的，因为 react 无法保证副作用在执行时所处的环境是正确的。事实上，在函数主体执行时，react 还处于调和阶段，并没有 commit 下一次的渲染，况且直接在函数体中执行的副作用会极大的阻塞调和的效率（参照前文内容）。\n\n因此，在函数式组件的主体函数中应当遵循 “只定义组件的特性和行为方式（包括视图的定义、事件回调的定义、副作用的定义、状态和计算属性的定义，因此可以把函数式组件分成 render 、 callback/handler 、 effect 和 props/state 四个部分），不进行高成本的计算 “的原则，“jsx” 本质上是一种动态的描述和定义组件的语法糖。组件的状态和行为的变化应该由副作用和事件机制来推动。（注意：副作用虽然可以用来模拟类似于类组件的生命周期，但是其理念是极为不同的，相比而言，副作用是函数式编程的产物，要更为灵活和高效，按照生命周期的想法去编写函数式组件是错误的，react 中提供的副作用钩子并不能准确的翻译 / 转化为类组件各种生命周期！参见 hook 会因为在渲染时创建函数而变慢吗？。）\n\n回归整体， commitrootimpl 函数中共有三次 flushpassiveeffects 的调用：\n\n// [1]\ndo {flushpassiveeffects()} while (rootwithpendingpassiveeffects !== null); \n\n// [2]\nschedulecallback(normalschedulerpriority, () => flushpassiveeffects());\n\n// [3]\nif (includessomelane(pendingpassiveeffectslanes, synclane)) flushpassiveeffects();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 第一次执行 flushpassiveeffects 是在 commit 三大步骤未开始之前执行的，目的是判断是否有残留的 passiveeffects （useeffect 的副作用） 未执行，如果有则调用 flushpassiveeffects 处理之。之所有用 while 循环是因为副作用有可能产生新的副作用（注意：在函数式组件中，应该避免副作用之间相互调用以免造成死循环）。\n * 第二次执行 flushpassiveeffects 是在 commit 三大步骤未开始之前请求一次 flushpassiveeffects 的调度，从前文中我们已经知道， commit 步骤中会阻塞 render 过程，但是并不会阻塞调度过程，因此，此次 flushpassiveeffects 调度能够保证其执行时间能够在本次 commit 阶段之后，也就是说 传给 useeffect 的函数会在浏览器完成布局与绘制之后，在一个延迟事件中被调用 ，参见 effect 的执行时机。\n * 第三次执行 flushpassiveeffects 是在 root.finishedlanes 中有同步的 lanes 的时机下，这说明本次副作用的处理的优先级较高，需同步执行。 从 react 18 开始，当它是离散的用户输入（如点击）的结果时，或者当它是由 flushsync 包装的更新结果时，传递给 useeffect 的函数将在屏幕布局和绘制之前同步执行 ，参见 effect 的执行时机。\n\n重点提示\n\n * flushpassiveeffects 的执行是异步的，是通过调度器的调度完成的，但是可以保证相关的副作用是在当前 commit 之后，也即视图更新渲染之后执行。\n * useeffect 中的副作用的执行时机是： commit 完成之后进入 batch 阶段中的某一次调度器的回调中，进一步将就是，屏幕视图布局和绘制之后的一个延迟事件中。 useeffect 中副作用的执行是异步的。\n * useeffect 中的副作用也可以同步的执行（ uselayouteffect 中副作用执行之后，在 commit 完成之时），当然这需要特殊的条件。\n\n\n# 问题\n\n\n# 为什么在 layout 阶段之后需要 requestpaint ?\n\n提示\n\nby default, the browser will wait until the current thread of execution finishes and do one consolidated reflow and repaint (as this is considered more efficient than doing many reflows and repaints). this is not specified in any specification so the browser can implement as it wants to.\n\nbut, there are some specific operations that will generally trigger a reflow (and sometimes a corresponding repaint). these operations are operations (requesting certain properties related to the position of elements) which can only be completed when an accurate reflow has been done. so, it is possible to manually trigger a reflow by requesting one of these properties.\n\n参见：html - when does the dom repaint during javascript routines? - stack overflow\n\n默认情况下，浏览器会在当前线程执行完成之后，执行一次合并的 reflow 和 repaint 。但是也存在一些特殊的情况会触发 reflow ，这就是执行那些只有在 reflow 之后才能完成的任务。因此，操纵 javascript 执行 dom 操作并不是会立即促使浏览器进行 repaint ，这其中浏览器有诸多优化措施以保证 reflow 和 repaint 高效的进行。\n\n\n# 总结\n\n本文中最最要的内容是对 commitroot 函数的分析。 commitroot 是 commit 阶段提纲挈领的函数，它将整个 commit 的过程分成了最要的三个步骤，分别是 beforemutation 、 mutation 和 layout 。这三个步骤分别调用 commitbeforemutationeffects 、 commitmutationeffects 和 commitlayouteffects 函数进行处理，总结其特性分别是 commitbeforemutationeffects 提供组件更新之前的实例数据， commitmutationeffects 操作原生 javascript 更新 dom 节点，处理组件销毁前的副作用， commitlayouteffects 处理组件挂载后（更新后）的副作用。\n\n另外一个重点是， workinprogress 树切换为 current 树的过程是在 mutation 之后 layout 之前完成的。三个步骤完成之后需要通知调度器进行 yield （中断 render 阶段的执行），从而使浏览器有足够的时间对 mutation 阶段造成的 dom 更新进行重排（reflow）和重绘（repaint）。\n\n上述三个步骤追根究底还是在 effectlist （沿用旧版本的概念） 的遍历过程中执行的，其总体过程可归纳为 “跳跃式的”（可精准的针对有相关 effecttagmask 的节点进行操作）“捕获与冒泡” 的过程，其内部逻辑同样可抽象为 beginwork 和 completework 的工作。上述三个步骤其实质是要执行 commitbeforemutationeffectsonfiber 、 commitmutationeffectsonfiber 和 commitlayouteffectonfiber 函数。\n\n\n# 参考\n\n * 旧版本：react 源碼 commit 階段詳解",charsets:{cjk:!0},lastUpdated:"2022/08/08, 19:51:35",lastUpdatedTimestamp:1659959495e3},{title:"React 源码漂流记：React 调和器核心源码解读（八）",frontmatter:{title:"React 源码漂流记：React 调和器核心源码解读（八）",date:"2022-08-05T12:02:21.000Z",permalink:"/react/tour/react-reconciliation-8/",categories:["react","React源码漂流记"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/160.react-reconciliation-8.html",relativePath:"10.react/90.React源码漂流记/160.react-reconciliation-8.md",key:"v-7f59f37f",path:"/react/tour/react-reconciliation-8/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:17},{level:2,title:"commitBeforeMutationEffectsOnFiber",slug:"commitbeforemutationeffectsonfiber",normalizedTitle:"commitbeforemutationeffectsonfiber",charIndex:23},{level:2,title:"commitMutationEffectsOnFiber",slug:"commitmutationeffectsonfiber",normalizedTitle:"commitmutationeffectsonfiber",charIndex:61},{level:2,title:"commitLayoutEffectOnFiber",slug:"commitlayouteffectonfiber",normalizedTitle:"commitlayouteffectonfiber",charIndex:93},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:122},{level:3,title:"useLayoutEffect 中 layout 含义是什么？",slug:"uselayouteffect-中-layout-含义是什么",normalizedTitle:"uselayouteffect 中 layout 含义是什么？",charIndex:130},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:165},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:171},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:177}],readingTime:{text:"6 min read",minutes:5.495,time:329700,words:1099},headersStr:"目录 前言 commitBeforeMutationEffectsOnFiber commitMutationEffectsOnFiber commitLayoutEffectOnFiber 扩展 useLayoutEffect 中 layout 含义是什么？ 问题 总结 参考",content:'# 目录\n\n\n\n * 目录\n * 前言\n * commitBeforeMutationEffectsOnFiber\n * commitMutationEffectsOnFiber\n * commitLayoutEffectOnFiber\n * 扩展\n   * useLayoutEffect 中 layout 含义是什么？\n * 问题\n * 总结\n * 参考\n\n\n\n\n# 前言\n\n在上文中，我们探讨了 Commit 过程的三大步骤，以及完成这三大步骤所采用的遍历方式。 beforeMutation 、 mutation 和 layout 此三大步骤归根结底是对 workInProgress FiberTree 的应用，是两个重要跳跃的基石：一是从 WorkInProgress FiberTree 向 current FiberTree 的跳跃，二是从 EffectList 向 DOM 更新 的跳跃。\n\n扩展来说，有以下几点值得我们思考：\n\n * FiberTree 、 ReactElementTree 和 DOMTree 在 React 中的关系是相当复杂的。总结来说， DOMTree 是页面视图的状态， ReactElementTree 是逻辑视图的状态，它包含了组件层面的状态变化（setState）、视图更新（JSX 更新）和事件响应（Event Listener），而 FiberTree 是数据层面的状态，它是应用层面的（或者说是 FiberRoot 容器层面的）数据的生态，是对状态变化（updateQueue）、视图更新（EffectList）、事件响应（事件委托系统）的数据抽象。我们可以从整个调和器的大循环中进行体会。\n * “捕获和冒泡” 是 React 中针对 Tree 数据结构的一种通用的遍历方式，其本质是 DFS（深度优先遍历）的模型，React 将调和 FiberTree、消费 EffectList 的逻辑注入到 DFS 的过程之中，并针对 Tree 结构的特性进行性能和效率的优化。为什么采用 DFS 的方式呢？一是足够高效，DFS 对每个节点访问（visit ）两次；而是足够灵活，DFS 可以跳过某些不需要遍历的子树从而提升遍历效率。\n\n\n# commitBeforeMutationEffectsOnFiber\n\n此函数在 mutation 阶段之前执行类组件的 getSnapshotBeforeUpdate 函数。\n\nfunction commitBeforeMutationEffectsOnFiber(finishedWork: Fiber) {\n  const current = finishedWork.alternate;\n  const flags = finishedWork.flags;\n  // ......\n  // Snapshot EffectTag 标记在具有 getSnapshotBeforeUpdate 函数的类组件上或者 `HostRoot` 上\n  if ((flags & Snapshot) !== NoFlags) {\n    // ......\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent: {\n        break;\n      }\n      case ClassComponent: {\n        // 如果非首次渲染\n        if (current !== null) {\n          // 当前 current Fiber 上的 prop、state 和组件实例\n          const prevProps = current.memoizedProps;\n          const prevState = current.memoizedState;\n          const instance = finishedWork.stateNode;\n          // ......\n          // 调用 getSnapshotBeforeUpdate，see https://zh-hans.reactjs.org/docs/react-component.html#getsnapshotbeforeupdate\n          const snapshot = instance.getSnapshotBeforeUpdate(\n            // 如果 elementType 和 type 不一致，则可能是 lazyComponent，需要\n            // 将 ReactElement 上的默认 props 同步到组件实例上，see https://zh-hans.reactjs.org/docs/react-component.html#defaultprops\n            finishedWork.elementType === finishedWork.type\n              ? prevProps\n              : resolveDefaultProps(finishedWork.type, prevProps),\n            prevState,\n          );\n          // ......\n          // 缓存 snapshot 值以在 componentDidUpdate 中使用\n          instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n        }\n        break;\n      }\n      case HostRoot: {\n        // 如果是 HostRoot 组件，说明是首次渲染，清空容器\n        const root = finishedWork.stateNode;\n        clearContainer(root.containerInfo);\n        break;\n      }\n      case HostComponent:\n      case HostText:\n      case HostPortal:\n      case IncompleteClassComponent:\n        break;\n      // ......\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n大家可能已经注意到了，如上的代码都是针对有 Snapshot 标记的 fiber 节点执行的， Snapshot 标记用于有 getSnapshotBeforeUpdate 的函数的类组件和 HostRoot 组件，用于对需要在 DOM 操作之前操作原来的实例信息、DOM 节点的场景做标记。 HostRoot 节点是 ReactDOM.render 中挂载到 root 容器中的 RootFiber 节点，一般情况下 HostRoot 在非首次渲染时并不会发生变化，至首次渲染时则需要对对所挂载的容器进行节点清空。\n\n此函数有如下作用：\n\n * 针对类组件，执行 getSnapshotBeforeUpdate(prevProps, prevState) 生命周期函数，并且将 snapshot 传递给 componentDidUpdate(prevProps, prevState, snapshot) 。\n * 针对 HostRoot 节点，清空 root 容器中的 DOM 节点。\n\n\n# commitMutationEffectsOnFiber\n\n此函数对移位（placement）、update（更新）等操作提交相应的 mutation 操作，此 mutation 操作将会操纵 JavaScript 进行 DOM 节点的更新。\n\nfunction commitMutationEffectsOnFiber(finishedWork: Fiber, root: FiberRoot) {\n  const flags = finishedWork.flags;\n  // 如果有 ContentReset 标记，清空节点中的文本内容\n  if (flags & ContentReset) {\n    commitResetTextContent(finishedWork);\n  }\n  // 如果有 Ref 标记，则将对应的 current 节点上的 Ref 关联去除\n  if (flags & Ref) {\n    const current = finishedWork.alternate;\n    if (current !== null) {\n      commitDetachRef(current);\n    }\n    // ......\n  }\n  // ......\n\n  // The following switch statement is only concerned about placement,\n  // updates, and deletions. To avoid needing to add a case for every possible\n  // bitmap value, we remove the secondary effects from the effect tag and\n  // switch on that value.\n  // 由于下面的处理只关心 placement、updates 和 deletions 相关的操作，因此将之作为一流标记保留，其余标记均删除\n  const primaryFlags = flags & (Placement | Update | Hydrating);\n  outer: switch (primaryFlags) {\n    // 如果包含 Placement（位置变化）标记，则提交 Placement 的 mutation 操作\n    case Placement: {\n      commitPlacement(finishedWork);\n      // Clear the "placement" from effect tag so that we know that this is\n      // inserted, before any life-cycles like componentDidMount gets called.\n      // 清理标记\n      finishedWork.flags &= ~Placement;\n      break;\n    }\n    // 如果包含 PlacementAndUpdate（位置变化和节点更新）标记，则提交 Placement 和 update 的 mutation 操作\n    case PlacementAndUpdate: {\n      // Placement\n      commitPlacement(finishedWork);\n      finishedWork.flags &= ~Placement;\n      // 提交 update 操作\n      const current = finishedWork.alternate;\n      commitWork(current, finishedWork);\n      break;\n    }\n    case Hydrating: {\n      // SSR 无需 DOM 操作\n      finishedWork.flags &= ~Hydrating;\n      break;\n    }\n    case HydratingAndUpdate: {\n      finishedWork.flags &= ~Hydrating;\n      const current = finishedWork.alternate;\n      commitWork(current, finishedWork);\n      break;\n    }\n    case Update: {\n      const current = finishedWork.alternate;\n      commitWork(current, finishedWork);\n      break;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n此函数核心作用是对具有 primaryFlags（一流的标记）的节点提交相应的 mutation 操作。细节内容如下：\n\n * 处理 ContentReset 和 Ref 标记。如果节点有 ContentReset 标记，则清空节点内部的文本内容，如果节点有 Ref 标记，则解除该节点相对应的 current 节点上 Ref 的联结（注意当前节点上并没有 Ref 的联结），因为节点在 layout 过程中会重新建立 Ref 联结。Ref 的原理将在 hook 相关章节详述。\n * commitMutationEffectsOnFiber 只关心与 placement、update 和 hydrating（水合）相关的遗留标记（注意：删除操作已经移到冒泡过程中处理，此处不再处理）， primaryFlags 的位运算计算原理不再赘述。需要特别交代的是：为什么 PlacementAndUpdate 和 PlacementAndUpdate 也能被处理，事实上这两个标记是复合标记，见下：\n\nconst PlacementAndUpdate = Placement | Update;\nconst HydratingAndUpdate = Hydrating | Update;\n\n\n1\n2\n\n * 如果有 Placement 标记，则调用 commitPlacement 提交移位的 mutation 操作。\n * 如果有 Update 标记，则调用 commitWork 提交更新的 mutation 操作。\n\n\n# commitLayoutEffectOnFiber\n\n这个函数主要是针对不同的组件类型执行不同的处理，包括生命周期的处理、副作用的处理等。\n\n// src/react/packages/react-reconciler/src/ReactFiberCommitWork.new.js\nconst LayoutMask = Update | Callback | Ref | Visibility;\n\nfunction commitLayoutEffectOnFiber(\n  finishedRoot: FiberRoot, \n  current: Fiber | null,\n  finishedWork: Fiber,\n  committedLanes: Lanes,\n): void {\n  if ((finishedWork.flags & LayoutMask) !== NoFlags) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent: {\n        // ......\n        // 调用 useLayoutEffect 的回调函数，并且缓存销毁函数\n        commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);\n        break;\n      }\n      case ClassComponent: {\n        const instance = finishedWork.stateNode;\n        // 如果组件发生了更新\n        if (finishedWork.flags & Update) {\n          // 如果有 `Update` 标记，在首次渲染时执行实例的 componentDidMount 生命周期函数，\n          // 否则执行 componentDidUpdate 生命周期函数\n          if (current === null) {\n            // ......\n            instance.componentDidMount();\n          } else {\n            // 因为此处 workProgress 已经与 current 交换，所以 current 上具有最新的 props 和 state\n            const prevProps =\n              finishedWork.elementType === finishedWork.type\n                ? current.memoizedProps\n                : resolveDefaultProps(\n                    finishedWork.type,\n                    current.memoizedProps,\n                  );\n            const prevState = current.memoizedState;\n            // ......\n            // 成为了 current fiber 之后，相对于 workInProgress fiber 而言，其 props 和 state 就是之前的。\n            // see https://zh-hans.reactjs.org/docs/react-component.html#componentdidupdate\n            instance.componentDidUpdate(\n              prevProps,\n              prevState,\n              instance.__reactInternalSnapshotBeforeUpdate, // getSnapshotBeforeUpdate 返回的 snapshot\n            );\n          }\n        }\n        const updateQueue: UpdateQueue<*,> | null = (finishedWork.updateQueue: any);\n        if (updateQueue !== null) {\n          // ......\n          // 消费 updateQueue 中的副作用回调\n          commitUpdateQueue(finishedWork, updateQueue, instance);\n        }\n        break;\n      }\n      case HostRoot: {\n        // 如果 HostRoot 上有 updateQueue（注意 updateQueue 是一个 object）,可能有 callback effect，因此\n        // 提交 commitUpdateQueue 消费这些 effect，注意这里传递给 effect 的 context 是 HostRoot 下直系的的叶子节点\n        const updateQueue: UpdateQueue<*,> | null = (finishedWork.updateQueue: any);\n        if (updateQueue !== null) {\n          let instance = null;\n          if (finishedWork.child !== null) {\n            switch (finishedWork.child.tag) {\n              case HostComponent:\n                // getPublicInstance 兼容不同 HOST 环境\n                instance = getPublicInstance(finishedWork.child.stateNode);\n                break;\n              case ClassComponent:\n                instance = finishedWork.child.stateNode;\n                break;\n            }\n          }\n          commitUpdateQueue(finishedWork, updateQueue, instance);\n        }\n        break;\n      }\n      case HostComponent:\n      case HostText: \n      case HostPortal:\n      case Profiler: \n      case SuspenseComponent: \n      case SuspenseListComponent:\n      case IncompleteClassComponent:\n      case ScopeComponent:\n      case OffscreenComponent:\n      case LegacyHiddenComponent:\n        break;\n      // ......\n    }\n  }\n\n  // ......\n  // 如果 fiber 上有 Ref 标记，则重新建立 Ref 联结\n  if (finishedWork.flags & Ref) {\n    commitAttachRef(finishedWork);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\n分析如下：\n\n注意此函数的执行时机， mutation 阶段之后表示 DOM 的更改已经提交了， requestPaint 之前，表示浏览器很有可能并没有实现视图的绘制，但是这不影响相关的生命周期函数在 layout 期间可以获取到最新的 DOM 属性、组件状态和属性。\n\n * 对于 FunctionComponent 、 ForwardRef （接受一个参数 render，即为函数式组件或者类组件的 render 函数，返回一个可传递 Refs 的函数）、 SimpleMemoComponent （接受一个函数式组件，返回一个可缓存 props（浅比较） 的函数式组件） 这些函数式组件而言，执行 commitHookEffectListMount 处理 useLayoutEffect 中的副作用回调，并且缓存其销毁回调。\n * 对于 ClassComponent 而言，需要处理类组件的生命周期函数，如果是初次渲染则调用 componentDidMount ，否则就调用 componentDidUpdate 。 commitUpdateQueue 会消费掉 setState 中传入的回调函数，即 setState(updater[, callback]) 中的 callback。因此可以看出，这些 setState 中的回调并不是在 updater 执行后调用的，而是收集起来在 layout 阶段批量消费的，这样可以保证 callback 执行之时 state 是已经更新过的，也可以提高回调执行的效率（事实上，state 的更新也是批量完成的）。\n * 对于 HostRoot （RootFiber） 而言，也需要执行 commitUpdateQueue 消费回调，此回调来自于 render(element, container[, callback]) 中的 callback 。 Callback 标记不止用类组件中 setState 的回调，也用于 HostRoot 上 render 或者 hydrate 的回调。\n\n\n# 扩展\n\n\n# useLayoutEffect 中 layout 含义是什么？\n\n此 layout 正是来源于 layout 阶段中的这个 layout 的概念，中文意为 “布局”。我们可以结合 commitLayoutEffectOnFiber 这个函数的具体内容来分析 layout 的含义。其实，无论是 useLayoutEffect 的处理，还是类组件生命周期钩子 componentDidMount 或 componentDidUpdate 的处理，还是对各种 Callback 副作用的处理，都离不开一个词，即是 “副作用”。具体而言， layout 所处理的正是组件挂载（或者更新）时的各种同步的副作用。这些副作用依赖于 mutation 阶段完成 DOM 操作这个时机，对组件的状态和行为产生一定的影响，进而影响对组件后续的渲染。\n\n因为 layout 中副作用的执行是同步的、阻塞渲染的，因此也就可以在渲染之前对 DOM 进行更改，从而使浏览器可以一并完成重排和重绘。从这个角度来看，颇有 “布局” 的含义。以 DOM 更新的视角而言， useLayoutEffect 可以减少浏览器的绘制成本，如果不涉及到阻塞更新的缺陷（具有较小的阻塞成本，并且多为 DOM 操作），则可以考虑使用 useLayoutEffect 。\n\n\n# 问题\n\n\n# 总结\n\n本文承接上文中 EffectList 循环的内容，讲解在其循环过程中的 “冒泡” 阶段所执行的三个核心函数的内容。现对此三个函数总结如下：\n\n * commitBeforeMutationEffectsOnFiber : 执行于 beforeMutation 阶段，主要是针对具有 Snapshot 标记的节点做处理。 Snapshot 意为 “快照”，在 mutation 阶段变回执行真正的 DOM 操作，因此趁此 mutation 未处理尚可以操作旧 DOM 节点之际，对依靠 Snapshot 的相关逻辑进行处理。例如类组件 getSnapshotBeforeUpdate 钩子函数。\n * commitMutationEffectsOnFiber : 执行于 mutation 阶段，主要对具有 Update 和 Placement 标记的节点进行处理。 Update 和 Placement 分别对应节点的 “更新” 和 “替换” 行为，因此此过程主要对节点进行 DOM 修正（即 mutation ）。由于组件是 DOM 节点组织形式的抽象，因此无论是函数式组件、类组件还是其他，一律不考虑组件类型，提交相应的 mutation 操作即可（事实上，在提交此操作后真正执行修正过程中才会针对组件类型进行区分处理）。\n * commitLayoutEffectOnFiber : 执行于 layout 阶段，主要针对有 LayoutMask 标记的节点做处理（注意：实际上没有这个标记，这是一个标记集合，或者成为遮罩标记）。由于位于 mutation 阶段之后，因此此过程主要对依赖于新的 DOM 状态或者组件挂载（或者更新）的逻辑进行处理。其中比较重要的包括三个方面：\n   1. useLayoutEffect 的调用。 useLayoutEffect 的调用时机是 DOM 更新之后，浏览器未渲染之前，其调用要早于 useEffect ，其内部的更新计划为同步刷新。事实上， useLayoutEffect 与类组件中 componentDidMount 和 componentDidUpdate 调用时间是一致的，也都是同步刷新。相对而言，React 官网会推荐使用 useEffect 来替代 useLayoutEffect 。原因有三：两者执行时 DOM 都已经加载完毕，其中 useEffect 执行时，浏览器基本已经渲染完毕，不存在各种副作用执行的误差； useEffect 是经过调度器的回调在浏览器的空闲时机单独处理副作用的，其不会阻塞渲染（或者说不会提升渲染的执行成本）因此效率更高； useEffect 对 SSR 更加友好，不容易出现问题。参见 Hook API 索引：useLayoutEffect。\n   2. 类组件生命周期 componentDidMount 或者 componentDidUpdate 的调用。类组件生命周期的调用都是同步的，因此生命周期的内容的执行实际上是会对渲染的过程具有一定的阻塞作用的。因此，对于组件中生命周期的设计而言，天然就具有这样的劣势，因为要想维护生命周期时机的正确性，必须要容忍其同步性。相对于言，副作用思想的组件设计就突破了这种劣势，因为副作用的执行是异步的、非阻塞式的，这也是函数式组件针对类组件的具有的优势之一。副作用天然就具有对执行时机的低耦合性，也就是说，在大部分场景下，我们所需要的副作用的场景并不需要阻塞渲染，因此，React 为我们提供了灵活的副作用的执行方式， useEffect 和 useLayoutEffect 的设计正是为此而生。\n   3. 执行 Callback 副作用。使用 Callback 标记的各种 Callback 副作用本质上是批量同步执行的，包括类组件 setState 产生的回调副作用和 ReactDOM 中 render 函数或 hydrate 函数产生的回调副作用。\n\n从整体上看，这三个函数除了对生命周期和副作用处理之外，其核心还是对照 EffectTag 以对 DOM 的各种操作进行提交，此部分内容将在下文详述。\n\n\n# 参考\n\n * React 新旧生命周期的思考理解',normalizedContent:'# 目录\n\n\n\n * 目录\n * 前言\n * commitbeforemutationeffectsonfiber\n * commitmutationeffectsonfiber\n * commitlayouteffectonfiber\n * 扩展\n   * uselayouteffect 中 layout 含义是什么？\n * 问题\n * 总结\n * 参考\n\n\n\n\n# 前言\n\n在上文中，我们探讨了 commit 过程的三大步骤，以及完成这三大步骤所采用的遍历方式。 beforemutation 、 mutation 和 layout 此三大步骤归根结底是对 workinprogress fibertree 的应用，是两个重要跳跃的基石：一是从 workinprogress fibertree 向 current fibertree 的跳跃，二是从 effectlist 向 dom 更新 的跳跃。\n\n扩展来说，有以下几点值得我们思考：\n\n * fibertree 、 reactelementtree 和 domtree 在 react 中的关系是相当复杂的。总结来说， domtree 是页面视图的状态， reactelementtree 是逻辑视图的状态，它包含了组件层面的状态变化（setstate）、视图更新（jsx 更新）和事件响应（event listener），而 fibertree 是数据层面的状态，它是应用层面的（或者说是 fiberroot 容器层面的）数据的生态，是对状态变化（updatequeue）、视图更新（effectlist）、事件响应（事件委托系统）的数据抽象。我们可以从整个调和器的大循环中进行体会。\n * “捕获和冒泡” 是 react 中针对 tree 数据结构的一种通用的遍历方式，其本质是 dfs（深度优先遍历）的模型，react 将调和 fibertree、消费 effectlist 的逻辑注入到 dfs 的过程之中，并针对 tree 结构的特性进行性能和效率的优化。为什么采用 dfs 的方式呢？一是足够高效，dfs 对每个节点访问（visit ）两次；而是足够灵活，dfs 可以跳过某些不需要遍历的子树从而提升遍历效率。\n\n\n# commitbeforemutationeffectsonfiber\n\n此函数在 mutation 阶段之前执行类组件的 getsnapshotbeforeupdate 函数。\n\nfunction commitbeforemutationeffectsonfiber(finishedwork: fiber) {\n  const current = finishedwork.alternate;\n  const flags = finishedwork.flags;\n  // ......\n  // snapshot effecttag 标记在具有 getsnapshotbeforeupdate 函数的类组件上或者 `hostroot` 上\n  if ((flags & snapshot) !== noflags) {\n    // ......\n    switch (finishedwork.tag) {\n      case functioncomponent:\n      case forwardref:\n      case simplememocomponent: {\n        break;\n      }\n      case classcomponent: {\n        // 如果非首次渲染\n        if (current !== null) {\n          // 当前 current fiber 上的 prop、state 和组件实例\n          const prevprops = current.memoizedprops;\n          const prevstate = current.memoizedstate;\n          const instance = finishedwork.statenode;\n          // ......\n          // 调用 getsnapshotbeforeupdate，see https://zh-hans.reactjs.org/docs/react-component.html#getsnapshotbeforeupdate\n          const snapshot = instance.getsnapshotbeforeupdate(\n            // 如果 elementtype 和 type 不一致，则可能是 lazycomponent，需要\n            // 将 reactelement 上的默认 props 同步到组件实例上，see https://zh-hans.reactjs.org/docs/react-component.html#defaultprops\n            finishedwork.elementtype === finishedwork.type\n              ? prevprops\n              : resolvedefaultprops(finishedwork.type, prevprops),\n            prevstate,\n          );\n          // ......\n          // 缓存 snapshot 值以在 componentdidupdate 中使用\n          instance.__reactinternalsnapshotbeforeupdate = snapshot;\n        }\n        break;\n      }\n      case hostroot: {\n        // 如果是 hostroot 组件，说明是首次渲染，清空容器\n        const root = finishedwork.statenode;\n        clearcontainer(root.containerinfo);\n        break;\n      }\n      case hostcomponent:\n      case hosttext:\n      case hostportal:\n      case incompleteclasscomponent:\n        break;\n      // ......\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n大家可能已经注意到了，如上的代码都是针对有 snapshot 标记的 fiber 节点执行的， snapshot 标记用于有 getsnapshotbeforeupdate 的函数的类组件和 hostroot 组件，用于对需要在 dom 操作之前操作原来的实例信息、dom 节点的场景做标记。 hostroot 节点是 reactdom.render 中挂载到 root 容器中的 rootfiber 节点，一般情况下 hostroot 在非首次渲染时并不会发生变化，至首次渲染时则需要对对所挂载的容器进行节点清空。\n\n此函数有如下作用：\n\n * 针对类组件，执行 getsnapshotbeforeupdate(prevprops, prevstate) 生命周期函数，并且将 snapshot 传递给 componentdidupdate(prevprops, prevstate, snapshot) 。\n * 针对 hostroot 节点，清空 root 容器中的 dom 节点。\n\n\n# commitmutationeffectsonfiber\n\n此函数对移位（placement）、update（更新）等操作提交相应的 mutation 操作，此 mutation 操作将会操纵 javascript 进行 dom 节点的更新。\n\nfunction commitmutationeffectsonfiber(finishedwork: fiber, root: fiberroot) {\n  const flags = finishedwork.flags;\n  // 如果有 contentreset 标记，清空节点中的文本内容\n  if (flags & contentreset) {\n    commitresettextcontent(finishedwork);\n  }\n  // 如果有 ref 标记，则将对应的 current 节点上的 ref 关联去除\n  if (flags & ref) {\n    const current = finishedwork.alternate;\n    if (current !== null) {\n      commitdetachref(current);\n    }\n    // ......\n  }\n  // ......\n\n  // the following switch statement is only concerned about placement,\n  // updates, and deletions. to avoid needing to add a case for every possible\n  // bitmap value, we remove the secondary effects from the effect tag and\n  // switch on that value.\n  // 由于下面的处理只关心 placement、updates 和 deletions 相关的操作，因此将之作为一流标记保留，其余标记均删除\n  const primaryflags = flags & (placement | update | hydrating);\n  outer: switch (primaryflags) {\n    // 如果包含 placement（位置变化）标记，则提交 placement 的 mutation 操作\n    case placement: {\n      commitplacement(finishedwork);\n      // clear the "placement" from effect tag so that we know that this is\n      // inserted, before any life-cycles like componentdidmount gets called.\n      // 清理标记\n      finishedwork.flags &= ~placement;\n      break;\n    }\n    // 如果包含 placementandupdate（位置变化和节点更新）标记，则提交 placement 和 update 的 mutation 操作\n    case placementandupdate: {\n      // placement\n      commitplacement(finishedwork);\n      finishedwork.flags &= ~placement;\n      // 提交 update 操作\n      const current = finishedwork.alternate;\n      commitwork(current, finishedwork);\n      break;\n    }\n    case hydrating: {\n      // ssr 无需 dom 操作\n      finishedwork.flags &= ~hydrating;\n      break;\n    }\n    case hydratingandupdate: {\n      finishedwork.flags &= ~hydrating;\n      const current = finishedwork.alternate;\n      commitwork(current, finishedwork);\n      break;\n    }\n    case update: {\n      const current = finishedwork.alternate;\n      commitwork(current, finishedwork);\n      break;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n此函数核心作用是对具有 primaryflags（一流的标记）的节点提交相应的 mutation 操作。细节内容如下：\n\n * 处理 contentreset 和 ref 标记。如果节点有 contentreset 标记，则清空节点内部的文本内容，如果节点有 ref 标记，则解除该节点相对应的 current 节点上 ref 的联结（注意当前节点上并没有 ref 的联结），因为节点在 layout 过程中会重新建立 ref 联结。ref 的原理将在 hook 相关章节详述。\n * commitmutationeffectsonfiber 只关心与 placement、update 和 hydrating（水合）相关的遗留标记（注意：删除操作已经移到冒泡过程中处理，此处不再处理）， primaryflags 的位运算计算原理不再赘述。需要特别交代的是：为什么 placementandupdate 和 placementandupdate 也能被处理，事实上这两个标记是复合标记，见下：\n\nconst placementandupdate = placement | update;\nconst hydratingandupdate = hydrating | update;\n\n\n1\n2\n\n * 如果有 placement 标记，则调用 commitplacement 提交移位的 mutation 操作。\n * 如果有 update 标记，则调用 commitwork 提交更新的 mutation 操作。\n\n\n# commitlayouteffectonfiber\n\n这个函数主要是针对不同的组件类型执行不同的处理，包括生命周期的处理、副作用的处理等。\n\n// src/react/packages/react-reconciler/src/reactfibercommitwork.new.js\nconst layoutmask = update | callback | ref | visibility;\n\nfunction commitlayouteffectonfiber(\n  finishedroot: fiberroot, \n  current: fiber | null,\n  finishedwork: fiber,\n  committedlanes: lanes,\n): void {\n  if ((finishedwork.flags & layoutmask) !== noflags) {\n    switch (finishedwork.tag) {\n      case functioncomponent:\n      case forwardref:\n      case simplememocomponent: {\n        // ......\n        // 调用 uselayouteffect 的回调函数，并且缓存销毁函数\n        commithookeffectlistmount(hooklayout | hookhaseffect, finishedwork);\n        break;\n      }\n      case classcomponent: {\n        const instance = finishedwork.statenode;\n        // 如果组件发生了更新\n        if (finishedwork.flags & update) {\n          // 如果有 `update` 标记，在首次渲染时执行实例的 componentdidmount 生命周期函数，\n          // 否则执行 componentdidupdate 生命周期函数\n          if (current === null) {\n            // ......\n            instance.componentdidmount();\n          } else {\n            // 因为此处 workprogress 已经与 current 交换，所以 current 上具有最新的 props 和 state\n            const prevprops =\n              finishedwork.elementtype === finishedwork.type\n                ? current.memoizedprops\n                : resolvedefaultprops(\n                    finishedwork.type,\n                    current.memoizedprops,\n                  );\n            const prevstate = current.memoizedstate;\n            // ......\n            // 成为了 current fiber 之后，相对于 workinprogress fiber 而言，其 props 和 state 就是之前的。\n            // see https://zh-hans.reactjs.org/docs/react-component.html#componentdidupdate\n            instance.componentdidupdate(\n              prevprops,\n              prevstate,\n              instance.__reactinternalsnapshotbeforeupdate, // getsnapshotbeforeupdate 返回的 snapshot\n            );\n          }\n        }\n        const updatequeue: updatequeue<*,> | null = (finishedwork.updatequeue: any);\n        if (updatequeue !== null) {\n          // ......\n          // 消费 updatequeue 中的副作用回调\n          commitupdatequeue(finishedwork, updatequeue, instance);\n        }\n        break;\n      }\n      case hostroot: {\n        // 如果 hostroot 上有 updatequeue（注意 updatequeue 是一个 object）,可能有 callback effect，因此\n        // 提交 commitupdatequeue 消费这些 effect，注意这里传递给 effect 的 context 是 hostroot 下直系的的叶子节点\n        const updatequeue: updatequeue<*,> | null = (finishedwork.updatequeue: any);\n        if (updatequeue !== null) {\n          let instance = null;\n          if (finishedwork.child !== null) {\n            switch (finishedwork.child.tag) {\n              case hostcomponent:\n                // getpublicinstance 兼容不同 host 环境\n                instance = getpublicinstance(finishedwork.child.statenode);\n                break;\n              case classcomponent:\n                instance = finishedwork.child.statenode;\n                break;\n            }\n          }\n          commitupdatequeue(finishedwork, updatequeue, instance);\n        }\n        break;\n      }\n      case hostcomponent:\n      case hosttext: \n      case hostportal:\n      case profiler: \n      case suspensecomponent: \n      case suspenselistcomponent:\n      case incompleteclasscomponent:\n      case scopecomponent:\n      case offscreencomponent:\n      case legacyhiddencomponent:\n        break;\n      // ......\n    }\n  }\n\n  // ......\n  // 如果 fiber 上有 ref 标记，则重新建立 ref 联结\n  if (finishedwork.flags & ref) {\n    commitattachref(finishedwork);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\n分析如下：\n\n注意此函数的执行时机， mutation 阶段之后表示 dom 的更改已经提交了， requestpaint 之前，表示浏览器很有可能并没有实现视图的绘制，但是这不影响相关的生命周期函数在 layout 期间可以获取到最新的 dom 属性、组件状态和属性。\n\n * 对于 functioncomponent 、 forwardref （接受一个参数 render，即为函数式组件或者类组件的 render 函数，返回一个可传递 refs 的函数）、 simplememocomponent （接受一个函数式组件，返回一个可缓存 props（浅比较） 的函数式组件） 这些函数式组件而言，执行 commithookeffectlistmount 处理 uselayouteffect 中的副作用回调，并且缓存其销毁回调。\n * 对于 classcomponent 而言，需要处理类组件的生命周期函数，如果是初次渲染则调用 componentdidmount ，否则就调用 componentdidupdate 。 commitupdatequeue 会消费掉 setstate 中传入的回调函数，即 setstate(updater[, callback]) 中的 callback。因此可以看出，这些 setstate 中的回调并不是在 updater 执行后调用的，而是收集起来在 layout 阶段批量消费的，这样可以保证 callback 执行之时 state 是已经更新过的，也可以提高回调执行的效率（事实上，state 的更新也是批量完成的）。\n * 对于 hostroot （rootfiber） 而言，也需要执行 commitupdatequeue 消费回调，此回调来自于 render(element, container[, callback]) 中的 callback 。 callback 标记不止用类组件中 setstate 的回调，也用于 hostroot 上 render 或者 hydrate 的回调。\n\n\n# 扩展\n\n\n# uselayouteffect 中 layout 含义是什么？\n\n此 layout 正是来源于 layout 阶段中的这个 layout 的概念，中文意为 “布局”。我们可以结合 commitlayouteffectonfiber 这个函数的具体内容来分析 layout 的含义。其实，无论是 uselayouteffect 的处理，还是类组件生命周期钩子 componentdidmount 或 componentdidupdate 的处理，还是对各种 callback 副作用的处理，都离不开一个词，即是 “副作用”。具体而言， layout 所处理的正是组件挂载（或者更新）时的各种同步的副作用。这些副作用依赖于 mutation 阶段完成 dom 操作这个时机，对组件的状态和行为产生一定的影响，进而影响对组件后续的渲染。\n\n因为 layout 中副作用的执行是同步的、阻塞渲染的，因此也就可以在渲染之前对 dom 进行更改，从而使浏览器可以一并完成重排和重绘。从这个角度来看，颇有 “布局” 的含义。以 dom 更新的视角而言， uselayouteffect 可以减少浏览器的绘制成本，如果不涉及到阻塞更新的缺陷（具有较小的阻塞成本，并且多为 dom 操作），则可以考虑使用 uselayouteffect 。\n\n\n# 问题\n\n\n# 总结\n\n本文承接上文中 effectlist 循环的内容，讲解在其循环过程中的 “冒泡” 阶段所执行的三个核心函数的内容。现对此三个函数总结如下：\n\n * commitbeforemutationeffectsonfiber : 执行于 beforemutation 阶段，主要是针对具有 snapshot 标记的节点做处理。 snapshot 意为 “快照”，在 mutation 阶段变回执行真正的 dom 操作，因此趁此 mutation 未处理尚可以操作旧 dom 节点之际，对依靠 snapshot 的相关逻辑进行处理。例如类组件 getsnapshotbeforeupdate 钩子函数。\n * commitmutationeffectsonfiber : 执行于 mutation 阶段，主要对具有 update 和 placement 标记的节点进行处理。 update 和 placement 分别对应节点的 “更新” 和 “替换” 行为，因此此过程主要对节点进行 dom 修正（即 mutation ）。由于组件是 dom 节点组织形式的抽象，因此无论是函数式组件、类组件还是其他，一律不考虑组件类型，提交相应的 mutation 操作即可（事实上，在提交此操作后真正执行修正过程中才会针对组件类型进行区分处理）。\n * commitlayouteffectonfiber : 执行于 layout 阶段，主要针对有 layoutmask 标记的节点做处理（注意：实际上没有这个标记，这是一个标记集合，或者成为遮罩标记）。由于位于 mutation 阶段之后，因此此过程主要对依赖于新的 dom 状态或者组件挂载（或者更新）的逻辑进行处理。其中比较重要的包括三个方面：\n   1. uselayouteffect 的调用。 uselayouteffect 的调用时机是 dom 更新之后，浏览器未渲染之前，其调用要早于 useeffect ，其内部的更新计划为同步刷新。事实上， uselayouteffect 与类组件中 componentdidmount 和 componentdidupdate 调用时间是一致的，也都是同步刷新。相对而言，react 官网会推荐使用 useeffect 来替代 uselayouteffect 。原因有三：两者执行时 dom 都已经加载完毕，其中 useeffect 执行时，浏览器基本已经渲染完毕，不存在各种副作用执行的误差； useeffect 是经过调度器的回调在浏览器的空闲时机单独处理副作用的，其不会阻塞渲染（或者说不会提升渲染的执行成本）因此效率更高； useeffect 对 ssr 更加友好，不容易出现问题。参见 hook api 索引：uselayouteffect。\n   2. 类组件生命周期 componentdidmount 或者 componentdidupdate 的调用。类组件生命周期的调用都是同步的，因此生命周期的内容的执行实际上是会对渲染的过程具有一定的阻塞作用的。因此，对于组件中生命周期的设计而言，天然就具有这样的劣势，因为要想维护生命周期时机的正确性，必须要容忍其同步性。相对于言，副作用思想的组件设计就突破了这种劣势，因为副作用的执行是异步的、非阻塞式的，这也是函数式组件针对类组件的具有的优势之一。副作用天然就具有对执行时机的低耦合性，也就是说，在大部分场景下，我们所需要的副作用的场景并不需要阻塞渲染，因此，react 为我们提供了灵活的副作用的执行方式， useeffect 和 uselayouteffect 的设计正是为此而生。\n   3. 执行 callback 副作用。使用 callback 标记的各种 callback 副作用本质上是批量同步执行的，包括类组件 setstate 产生的回调副作用和 reactdom 中 render 函数或 hydrate 函数产生的回调副作用。\n\n从整体上看，这三个函数除了对生命周期和副作用处理之外，其核心还是对照 effecttag 以对 dom 的各种操作进行提交，此部分内容将在下文详述。\n\n\n# 参考\n\n * react 新旧生命周期的思考理解',charsets:{cjk:!0},lastUpdated:"2022/08/08, 19:51:35",lastUpdatedTimestamp:1659959495e3},{title:"React 源码漂流记：React 调和器核心源码解读（九）",frontmatter:{title:"React 源码漂流记：React 调和器核心源码解读（九）",date:"2022-08-08T12:02:21.000Z",permalink:"/react/tour/react-reconciliation-9/",categories:["react","React源码漂流记"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/170.react-reconciliation-9.html",relativePath:"10.react/90.React源码漂流记/170.react-reconciliation-9.md",key:"v-8bb61782",path:"/react/tour/react-reconciliation-9/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:17},{level:2,title:"commitDeletion",slug:"commitdeletion",normalizedTitle:"commitdeletion",charIndex:23},{level:3,title:"unmountHostComponents",slug:"unmounthostcomponents",normalizedTitle:"unmounthostcomponents",charIndex:43},{level:3,title:"commitUnmount",slug:"commitunmount",normalizedTitle:"commitunmount",charIndex:70},{level:3,title:"detachFiberMutation",slug:"detachfibermutation",normalizedTitle:"detachfibermutation",charIndex:89},{level:2,title:"commitPlacement",slug:"commitplacement",normalizedTitle:"commitplacement",charIndex:112},{level:3,title:"insertOrAppendPlacementNode",slug:"insertorappendplacementnode",normalizedTitle:"insertorappendplacementnode",charIndex:133},{level:2,title:"commitWork",slug:"commitwork",normalizedTitle:"commitwork",charIndex:164},{level:2,title:"commitHookEffectListMount",slug:"commithookeffectlistmount",normalizedTitle:"commithookeffectlistmount",charIndex:178},{level:2,title:"commitDetachRef",slug:"commitdetachref",normalizedTitle:"commitdetachref",charIndex:207},{level:2,title:"commitAttachRef",slug:"commitattachref",normalizedTitle:"commitattachref",charIndex:226},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:245},{level:3,title:"“置位”是如何解决 DOM 节点的插入和移位问题的？",slug:"置位-是如何解决-dom-节点的插入和移位问题的",normalizedTitle:"“置位” 是如何解决 dom 节点的插入和移位问题的？",charIndex:15939},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:275},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:289},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:295}],readingTime:{text:"9 min read",minutes:8.68,time:520799.99999999994,words:1736},headersStr:"目录 前言 commitDeletion unmountHostComponents commitUnmount detachFiberMutation commitPlacement insertOrAppendPlacementNode commitWork commitHookEffectListMount commitDetachRef commitAttachRef 扩展 “置位”是如何解决 DOM 节点的插入和移位问题的？ 问题 总结 参考",content:"# 目录\n\n\n\n * 目录\n * 前言\n * commitDeletion\n   * unmountHostComponents\n   * commitUnmount\n   * detachFiberMutation\n * commitPlacement\n   * insertOrAppendPlacementNode\n * commitWork\n * commitHookEffectListMount\n * commitDetachRef\n * commitAttachRef\n * 扩展\n   * “置位”是如何解决 DOM 节点的插入和移位问题的？\n * 问题\n * 总结\n * 参考\n\n\n\n\n# 前言\n\n在上文中，我们探讨了在 Commit 阶段的三个核心步骤中的三个核心函数 commitBeforeMutationEffects 、 commitMutationEffects 和 commitLayoutEffects 。此三个函数的主要作用就是同步执行 layout 步骤中的生命周期函数和副作用，为浏览器开始绘制视图作准备。截止到上文，从整体流程上来看，React 调和过程的 Commit 阶段就已经完成了，浏览器得到时间切片绘制了视图，新的渲染成果得以落地。\n\n在本文中，我们将重点关注 Commit 阶段的针对 DOM 节点更新的 mutation 操作的细节，所有提交的 mutation 操作最终都要落实到具体的 DOM 节点上，那么从提交 mutation 操作到真正的节点更新细节还是比较复杂的，我们大概会分成两篇文章对其中的细节部分进行探讨。本篇文章我们将探讨 mutation 操作的细节原理，在下文中我们将继续探讨 HostConfig 的 DOM 操纵原理。\n\n\n# commitDeletion\n\n此函数提交了节点删除操作，其核心工作是从祖先节点开始迭代子节点对待删除的节点的子节点执行以下操作：移除 Refs 引用的联结、调用卸载相关的生命周期函数、删除 return 指针等。\n\n源码如下：\n\n// src/react/packages/react-reconciler/src/ReactFiberCommitWork.new.js\nfunction commitDeletion(\n  finishedRoot: FiberRoot,\n  // 待操作的节点\n  current: Fiber,\n  // 检测到删除标记的祖先节点\n  nearestMountedAncestor: Fiber,\n): void {\n  // ......\n  // Recursively delete all host nodes from the parent.\n  // Detach refs and call componentWillUnmount() on the whole subtree.\n  // 从父节点迭代删除所有的子节点，移除 Refs 联结，并且调用相关的卸载生命周期函数\n  unmountHostComponents(finishedRoot, current, nearestMountedAncestor);\n  // 删除节点上的 return 指针，注意其他指针如 child、sibling、alternate 指针并不会被删除\n  // 节点将会在下一次渲染后 GC\n  detachFiberMutation(current);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# unmountHostComponents\n\n此函数找到待删除节点下的所有 Host 节点（HostComponent 或者 HostText）提交删除操作，并将之从 fiberTree 中移除。\n\nfunction unmountHostComponents(\n  finishedRoot: FiberRoot,\n  current: Fiber,\n  nearestMountedAncestor: Fiber,\n): void {\n  let node: Fiber = current;\n  let currentParent;\n  // 父节点是否是 FiberRoot，即是否待删除的节点是 RootFiber\n  let currentParentIsContainer;\n  // ......\n\n  while (true) {\n    // ......\n    // 如果是 HostComponent 或者 HostText 节点，则将之删除\n    if (node.tag === HostComponent || node.tag === HostText) {\n      // 提交删除待删除节点下所有的子节点\n      commitNestedUnmounts(finishedRoot, node, nearestMountedAncestor);\n      // 将待删除节点从 DOM Tree 中移除\n      if (currentParentIsContainer) {\n        removeChildFromContainer(\n          ((currentParent: any): Container),\n          (node.stateNode: Instance | TextInstance),\n        );\n      } else {\n        removeChild(\n          ((currentParent: any): Instance),\n          (node.stateNode: Instance | TextInstance),\n        );\n      }\n    } /*......*/else {\n      // 提交删除待删除的节点\n      commitUnmount(finishedRoot, node, nearestMountedAncestor);\n      // 继续向子节点捕获\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    }\n    // 如果已经捕获冒泡完成，则退出\n    if (node === current) {\n      return;\n    }\n    // 如果无法在继续捕获，且没有兄弟节点，尝试向父节点冒泡\n    while (node.sibling === null) {\n      // 如果冒泡到根节点，则退出\n      if (node.return === null || node.return === current) {\n        return;\n      }\n      node = node.return;\n      // ......\n    }\n    // 如果无法继续捕获，有兄弟节点，尝试向兄弟节点冒泡\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n这里的总流程仍然是嵌套在一个 “捕获和冒泡” 的遍历过程之中，其核心目的是找到与 DOM 节点有关联性的 HOST 节点提交删除操作，包括 HostComponent 和 HostText 节点。具体的遍历过程不在赘述。有以下几点需要注意：\n\n * commitNestedUnmounts : 此函数以 “捕获和冒泡” 方式遍历子节点，对每一个子节点执行 commitUnmount 提交节点的删除任务。注意，这里是用于迭代删除 HOST 节点及其子节点。（注意：迭代不同于递归，迭代可以平替递归并获得更高的执行效率和更低的内存占用）。\n * removeChildFromContainer 和 removeChild 是由 HostConfig 提供，提供原生 JavaScript 删除节点。注意：只有 HOST 节点才会被执行此 DOM 删除操作，其他类型的节点不与 DOM 节点对应。\n * commitUnmount 针对组件类型执行一些清理工作和相关生命周期的调用。\n\n\n# commitUnmount\n\n此函数针对组件类型执行清理工作和相关生命周期的调用，如函数式组件中副作用的销毁函数的调用、类组件中 componentWillUnmount 生命周期函数的调用等。其他的组件类型的处理不在赘述。\n\nfunction commitUnmount(\n  finishedRoot: FiberRoot,\n  current: Fiber,\n  nearestMountedAncestor: Fiber,\n): void {\n  // ......\n  switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent: {\n      const updateQueue: FunctionComponentUpdateQueue | null = (current.updateQueue: any);\n      if (updateQueue !== null) {\n        const lastEffect = updateQueue.lastEffect;\n        // 循环 updateQueue 上的 effect 环形链表\n        if (lastEffect !== null) {\n          const firstEffect = lastEffect.next;\n          let effect = firstEffect;\n          do {\n            // 调用副作用中的销毁函数\n            const {destroy, tag} = effect;\n            if (destroy !== undefined) {\n              // HookInsertion 和 HookLayout 标记分别对应 useInsertionEffect 和 useLayoutEffect \n              if ((tag & HookInsertion) !== NoHookEffect) {\n                safelyCallDestroy(current, nearestMountedAncestor, destroy);\n              } else if ((tag & HookLayout) !== NoHookEffect) {\n                // ......\n                safelyCallDestroy(current, nearestMountedAncestor, destroy);\n              }\n            }\n            effect = effect.next;\n          } while (effect !== firstEffect);\n        }\n      }\n      return;\n    }\n    case ClassComponent: {\n      // 移除 Refs 引用的联结\n      safelyDetachRef(current, nearestMountedAncestor);\n      const instance = current.stateNode;\n      // 调用类组件 componentWillUnmount 函数\n      if (typeof instance.componentWillUnmount === 'function') {\n        safelyCallComponentWillUnmount(\n          current,\n          nearestMountedAncestor,\n          instance,\n        );\n      }\n      return;\n    }\n    case HostComponent: \n    case HostPortal:\n    case DehydratedFragment: \n    case ScopeComponent: {\n      // ......\n      return;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n分析如下：\n\n * 针对函数式组价：遍历 updateQueue 上的 effect 环形链表，执行每个 effect 的销毁函数。其中 useInsertionEffect 类型副作用是通过 HookInsertion 标记辨识的， useLayoutEffect 类型副作用时通过 HookLayout 标记辨识的。关于 effect 环形链表我们将在 Hook 相关章节详述。\n * 针对类组件：安全的触发 componentWillUnmount 生命周期函数。所谓安全触发就是使用 tryCatch 语句捕获其中的错误。 为什么在 commitUnmount 中需要强调 safely 呢？这是因为删除节点的操作应当是比较宽容的，不应该阻塞后续的真正的节点删除的 DOM 操作，捕获到相关的错误之后能够向上冒泡被上级节点捕获到即可。\n\n\n# detachFiberMutation\n\n此函数删除待删除节点和对应的 alternate 节点的 return 指针。因为 return 指针被删除，被删除的节点及其下的子节点所触发的事件将不能够冒泡到上方的节点树中，且其中的产生的更新也将被检测到并抛出警告。\n\nfunction detachFiberMutation(fiber: Fiber) {\n  // Cut off the return pointer to disconnect it from the tree.\n  // This enables us to detect and warn against state updates on an unmounted component.\n  // It also prevents events from bubbling from within disconnected components.\n  //\n  // Ideally, we should also clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child.\n  // This child itself will be GC:ed when the parent updates the next time.\n  //\n  // Note that we can't clear child or sibling pointers yet.\n  // They're needed for passive effects and for findDOMNode.\n  // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n  //\n  // Don't reset the alternate yet, either. We need that so we can detach the\n  // alternate's fields in the passive phase. Clearing the return pointer is\n  // sufficient for findDOMNode semantics.\n  // 断开 workInProgress fiber 和 current fiber 上的 return 指针，但是此时其父节点指向该节点的 child 指针并没有断开，\n  // 因此 GC 将不会在本次渲染中清理这些删除的节点，在下次渲染时（调和 FiberTree 时）将清理这些悬空的节点（无 return 指针）\n  const alternate = fiber.alternate;\n  if (alternate !== null) {\n    alternate.return = null;\n  }\n  fiber.return = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# commitPlacement\n\n此函数主要作用是计算待置位节点的父节点和待插入位置的兄弟节点。\n\nfunction commitPlacement(finishedWork: Fiber): void {\n  // ......\n  // 查找距离移位节点的最近的 HOST 祖先节点（标记为 HostComponent、HostRoot、HostPortal）\n  const parentFiber = getHostParentFiber(finishedWork);\n\n  let parent;\n  // 是否是 HostRoot 或者 HostPortal\n  let isContainer;\n  // stateNode 表示当前 fiber 节点对应的 DOM 节点或者是组件实例对象\n  const parentStateNode = parentFiber.stateNode;\n  switch (parentFiber.tag) {\n    case HostComponent:\n      parent = parentStateNode;\n      isContainer = false;\n      break;\n    case HostRoot:\n      parent = parentStateNode.containerInfo;\n      isContainer = true;\n      break;\n    case HostPortal:\n      parent = parentStateNode.containerInfo;\n      isContainer = true;\n      break;\n    // ......\n  }\n  // ......\n  // 查找距离待移位节点最近的兄弟 HOST 节点\n  // 待移位的节点将插入到查找到的节点之后\n  const before = getHostSibling(finishedWork);\n  // We only have the top Fiber that was inserted but we need to recurse down its\n  // children to find all the terminal nodes.\n  if (isContainer) {\n    insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);\n  } else {\n    insertOrAppendPlacementNode(finishedWork, before, parent);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n分析如下：\n\n * getHostParentFiber 查找距离节点最近的 HOST 类型 的祖先节点。注意：无论是删除节点还是移位节点（包括添加节点），都是针对 HOST 节点进行操作。HOST 节点包括 HostComponent 、 HostRoot 、 HostPortal 三种。 Fiber.stateNode 在 HOST 类型的 Fiber 存储的是其相对应的 DOM 节点。\n * getHostSibling 查找距离节点最近的 HOST 类型的兄弟节点（不能包含 Placement 标记，因为其位置不稳定），如果没有兄弟节点且没有父节点或者父节点也是 HOST 节点，则返回 null，否则将继续上父节点追溯，因为非 HOST 类型的组件不对应 DOM 结构，需要向上解包装，在这种情况下查找的效率会大大降低。\n * insertOrAppendPlacementNode 将会根据查找到的父节点和兄弟节点的执行置位操作。\n\n\n# insertOrAppendPlacementNode\n\n此函数对待置位的节点进行置位（插入或者移位）。\n\nfunction insertOrAppendPlacementNode(\n  node: Fiber,\n  before: ?Instance,\n  parent: Instance,\n): void {\n  const {tag} = node;\n  const isHost = tag === HostComponent || tag === HostText;\n  // 如果待置位节点是 HOST 类型的节点，有 before 节点则在 before 节点前插入，\n  // 否则则追加到末尾\n  if (isHost) {\n    const stateNode = node.stateNode;\n    if (before) {\n      insertBefore(parent, stateNode, before);\n    } else {\n      appendChild(parent, stateNode);\n    }\n  } /*......*/ else {\n    const child = node.child;\n    // 如果该节点不是 HOST 节点，则对组件进行解包装，取其子节点即子节点的兄弟节点依次置位\n    if (child !== null) {\n      insertOrAppendPlacementNode(child, before, parent);\n      let sibling = child.sibling;\n      while (sibling !== null) {\n        insertOrAppendPlacementNode(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n函数中对待置位的节点是否是 HOST 类型的节点分成两种情况处理。\n\n * 如果待置位的节点是 HOST 节点，且已经找到稳定的兄弟节点，则将该节点插入到此节点的前面，否则说明父节点下无稳定节点，则将该节点追加到末尾。\n * 如果待置位的节点不是 HOST 节点，则需要对该节点进行解包装，对该节点的子节点即子节点的所有兄弟节点进行递归置位。\n\n\n# commitWork\n\n此函数对 HostComponent 、 HostText 等 HOST 类型的节点提交更新操作，同时针对函数式组件处理相关副作用。\n\n// src/react/packages/react-reconciler/src/ReactFiberCommitWork.new.js\nfunction commitWork(current: Fiber | null, finishedWork: Fiber): void {\n  // ......\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent: {\n      // 如果是函数式组件（或者 fc-like 型组件），在组件更新之前，先执行 useInsertionEffect 的销毁函数\n      commitHookEffectListUnmount(\n        HookInsertion | HookHasEffect,\n        finishedWork,\n        finishedWork.return,\n      );\n      // 执行 useInsertionEffect 的副作用函数，see https://zh-hans.reactjs.org/docs/hooks-reference.html#useinsertioneffect\n      commitHookEffectListMount(HookInsertion | HookHasEffect, finishedWork);\n      // Layout effects are destroyed during the mutation phase so that all\n      // destroy functions for all fibers are called before any create functions.\n      // This prevents sibling component effects from interfering with each other,\n      // e.g. a destroy function in one component should never override a ref set\n      // by a create function in another component during the same commit.\n      // ......\n      // 执行 useLayoutEffect 的销毁函数\n      commitHookEffectListUnmount(\n        HookLayout | HookHasEffect,\n        finishedWork,\n        finishedWork.return,\n      );\n      return;\n    }\n    case HostComponent: {\n      const instance: Instance = finishedWork.stateNode;\n      if (instance != null) {\n        // Commit the work prepared earlier.\n        const newProps = finishedWork.memoizedProps;\n        // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n        const oldProps = current !== null ? current.memoizedProps : newProps;\n        const type = finishedWork.type;\n        const updatePayload: null | UpdatePayload = (finishedWork.updateQueue: any);\n        finishedWork.updateQueue = null;\n        if (updatePayload !== null) {\n          // 提交节点上的更新\n          commitUpdate(\n            instance,\n            updatePayload,\n            type,\n            oldProps,\n            newProps,\n            finishedWork,\n          );\n        }\n      }\n      return;\n    }\n    case HostText: {\n      // ......\n      const textInstance: TextInstance = finishedWork.stateNode;\n      const newText: string = finishedWork.memoizedProps;\n      // For hydration we reuse the update path but we treat the oldProps\n      // as the newProps. The updatePayload will contain the real change in\n      // this case.\n      const oldText: string =\n        current !== null ? current.memoizedProps : newText;\n      // 提交文本更新\n      commitTextUpdate(textInstance, oldText, newText);\n      return;\n    }\n    case ClassComponent: \n    case HostRoot: \n    case Profiler: \n    case SuspenseComponent: \n    case SuspenseListComponent: \n    case IncompleteClassComponent: {\n      // ......\n      return;\n    }\n    case ScopeComponent: {\n      // ......\n      break;\n    }\n  }\n  // ......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n * 对于函数式组件而言，本函数先执行 useInsertionEffect 的销毁函数，再执行 useInsertionEffect 的副作用函数。另外，执行 useLayoutEffect 的销毁函数，之所以在 mutation 阶段执行销毁函数，而非放到 layout 阶段在其副作用函数之前执行，是为了避免兄弟组件之间相互干扰。\n * useInsertionEffect 在所有 DOM 突变之前同步触发，应仅限于 css-in-js 库作者使用。使用它在读取 useLayoutEffect 中的布局之前将样式注入 DOM，确保在对 DOM 进行其他更改的同时操作 CSS 规则。参见 Hook API 索引 – useInsertionEffect。\n * 对于 HostComponent 而言，调用 commitUpdate 提交节点的更新。对于 HostText 而言，调用 commitTextUpdate 函数提交文本节点的更新。这两个函数均是由 HostConfig 提供，此部分 HOST 节点的更新将应用到 DOM 的更新上。\n\n\n# commitHookEffectListMount\n\n此函数执行副作用函数或者销毁函数，可用于 useEffect 、 useLayoutEffect 、 useInsertionEffect 等 Hook 中。其具体内容请参考 Hook 相关章节的详述，此处暂不赘述。\n\n\n# commitDetachRef\n\n此函数去除组件的 Ref 引用的联结。\n\nfunction commitDetachRef(current: Fiber) {\n  const currentRef = current.ref;\n  if (currentRef !== null) {\n    // 如果 ref 是 function ref，将之置为 null\n    if (typeof currentRef === 'function') {\n      currentRef(null);\n      // ......\n    } else {\n      // 普通 ref，置为 null 即可\n      currentRef.current = null;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# commitAttachRef\n\n此函数添加组件的 Ref 应用的联结。\n\nfunction commitAttachRef(finishedWork: Fiber) {\n  const ref = finishedWork.ref;\n  // 注意：上文 commitMutationEffectsOnFiber 中 detach 的是 current fiber 的 Ref，\n  // 并不是 workInProgress fiber 的 Ref，因此此时 Ref 必然不为空\n  if (ref !== null) {\n    // 获取组件实例或者 DOM 组件实例，`Fiber.stateNode` 对于 HOST 类型的组件缓存 DOM 组件实例，\n    // 否则则缓存组件的实例\n    const instance = finishedWork.stateNode;\n    let instanceToUse;\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n      default:\n        instanceToUse = instance;\n    }\n    // ......\n    // function ref 传递新的 ref\n    if (typeof ref === 'function') {\n      ref(instanceToUse);\n    } else {\n      // ......\n      ref.current = instanceToUse;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * 对于非 HOST 组件，Ref 是缓存的是组件的实例，对于 HOST 类型组件，如 HostComponent ，Ref 上缓存的是 DOM 组件实例。注意 HostText 、 HostRoot 、 HostPortal 没有 Ref，这是因为他们是两端的节点（根节点或者叶子节点），不存在传递 Ref 应用的需求。\n * Ref 分为普通的对象式 Ref 和回调式 Ref，参见 Refs and the DOM – 回调 Refs\n\n\n# 扩展\n\n\n# “置位” 是如何解决 DOM 节点的插入和移位问题的？\n\n在 insertOrAppendPlacementNode 函数中，我们可以看到 React 对于 HOST 节点的插入是通过 insertBefore 和 appendChild 来实现的，那么我们可能会有这样的疑问，这种方式是如何实现 “插入” 和 “移位” 的需求的呢？要弄清楚这个问题，我们需要先结合 placeChild 函数来看，在给同层级节点进行置位时，有如下的代码：\n\nif (current !== null) {\n  const oldIndex = current.index;\n  if (oldIndex < lastPlacedIndex) {\n    newFiber.flags |= Placement;\n    return lastPlacedIndex;\n  } else {\n    return oldIndex;\n  }\n} else {\n  newFiber.flags |= Placement;\n  return lastPlacedIndex\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n可以看待，要添加 Placement 置位标记，有以下两种情况：\n\n * 无可复用节点，即为 “插入” 的场景，添加置位标记。\n * 有可复用节点，且该节点原位置在上次置位位置的左侧（原位置比较靠左），即为需要 “移位” 场景，添加置位标记。\n\n参考如下图示：\n\n这其中包括两个步骤：\n\n * 生成 EffectTag List，在 FiberTree 的调和过程中（ Render 阶段）完成。\n * 根据 EffectTag List 操作（更新） DOM，在 Commit 阶段的 mutation 步骤中完成。\n\n结合这两个步骤的脉络，加之 “置位” 和 “提交置位” 的逻辑，便不难理解这个问题了。\n\n\n# 问题\n\n\n# 总结\n\n本文主要讲解了 commitDeletion 、 commitPlacement 和 commitWork 三个核心函数的原理。这三个函数都是在 mutation 过程中完成的，目的是向 DOM 提交 “删除”、“置位”、“更新” 等操作。可以此三个函数是 FiberTree 与 DOMTree 沟通的接口。FiberTree 相对于 DOMTree 具有更高层次的抽象意义，也就说 FiberTree 除了承担视图抽象之外和承担了数据抽象的责任。因此，FiberTree 与 DOMTree 交接时主要依赖于 Fiber.stateNode 和 Fiber.tag 这两个字段。\n\nFiber.tag 为 HOST 类型，典型为 HostComponent 和 HostText ，则表明该 Fiber 节点对应着 DOM 节点，则相应的 EffectTag 就需要在这些 HOST 节点上有所影响。 Fiber.stateNode 对于 HOST 节点而言缓存着对应的 DOM 节点，这为在节点上操作 DOM 提供了便利。\n\nReact 中 DOM 的处理（mutation）包括三个方面：\n\n * Deletion ，即删除，调用 removeChild 。\n * Placement ，即置位，包括插入和移位，调用 insertBefore 或者 appendChild 。\n * Update ，即更新，调用 commitUpdate 。\n\n在如上的过程中往往伴随着副作用的处理、生命周期函数的处理、Ref 引用的处理等工作。而真正的 DOM 操作则是由 HostConfig 所提供，如 removeChild 、 commitUpdate 等。 HostConfig 提供了防腐层以抹平不同 HOST 环境（平台）中对于节点操作的差异，这方面内容将在下文中详述。\n\n\n# 参考\n\n * Know about the useInsertionEffect hook in React 18 | Saeloun Blog\n * Library Upgrade Guide: style most CSS-in-JS libs · Discussion #110 · reactwg/react-18",normalizedContent:"# 目录\n\n\n\n * 目录\n * 前言\n * commitdeletion\n   * unmounthostcomponents\n   * commitunmount\n   * detachfibermutation\n * commitplacement\n   * insertorappendplacementnode\n * commitwork\n * commithookeffectlistmount\n * commitdetachref\n * commitattachref\n * 扩展\n   * “置位”是如何解决 dom 节点的插入和移位问题的？\n * 问题\n * 总结\n * 参考\n\n\n\n\n# 前言\n\n在上文中，我们探讨了在 commit 阶段的三个核心步骤中的三个核心函数 commitbeforemutationeffects 、 commitmutationeffects 和 commitlayouteffects 。此三个函数的主要作用就是同步执行 layout 步骤中的生命周期函数和副作用，为浏览器开始绘制视图作准备。截止到上文，从整体流程上来看，react 调和过程的 commit 阶段就已经完成了，浏览器得到时间切片绘制了视图，新的渲染成果得以落地。\n\n在本文中，我们将重点关注 commit 阶段的针对 dom 节点更新的 mutation 操作的细节，所有提交的 mutation 操作最终都要落实到具体的 dom 节点上，那么从提交 mutation 操作到真正的节点更新细节还是比较复杂的，我们大概会分成两篇文章对其中的细节部分进行探讨。本篇文章我们将探讨 mutation 操作的细节原理，在下文中我们将继续探讨 hostconfig 的 dom 操纵原理。\n\n\n# commitdeletion\n\n此函数提交了节点删除操作，其核心工作是从祖先节点开始迭代子节点对待删除的节点的子节点执行以下操作：移除 refs 引用的联结、调用卸载相关的生命周期函数、删除 return 指针等。\n\n源码如下：\n\n// src/react/packages/react-reconciler/src/reactfibercommitwork.new.js\nfunction commitdeletion(\n  finishedroot: fiberroot,\n  // 待操作的节点\n  current: fiber,\n  // 检测到删除标记的祖先节点\n  nearestmountedancestor: fiber,\n): void {\n  // ......\n  // recursively delete all host nodes from the parent.\n  // detach refs and call componentwillunmount() on the whole subtree.\n  // 从父节点迭代删除所有的子节点，移除 refs 联结，并且调用相关的卸载生命周期函数\n  unmounthostcomponents(finishedroot, current, nearestmountedancestor);\n  // 删除节点上的 return 指针，注意其他指针如 child、sibling、alternate 指针并不会被删除\n  // 节点将会在下一次渲染后 gc\n  detachfibermutation(current);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# unmounthostcomponents\n\n此函数找到待删除节点下的所有 host 节点（hostcomponent 或者 hosttext）提交删除操作，并将之从 fibertree 中移除。\n\nfunction unmounthostcomponents(\n  finishedroot: fiberroot,\n  current: fiber,\n  nearestmountedancestor: fiber,\n): void {\n  let node: fiber = current;\n  let currentparent;\n  // 父节点是否是 fiberroot，即是否待删除的节点是 rootfiber\n  let currentparentiscontainer;\n  // ......\n\n  while (true) {\n    // ......\n    // 如果是 hostcomponent 或者 hosttext 节点，则将之删除\n    if (node.tag === hostcomponent || node.tag === hosttext) {\n      // 提交删除待删除节点下所有的子节点\n      commitnestedunmounts(finishedroot, node, nearestmountedancestor);\n      // 将待删除节点从 dom tree 中移除\n      if (currentparentiscontainer) {\n        removechildfromcontainer(\n          ((currentparent: any): container),\n          (node.statenode: instance | textinstance),\n        );\n      } else {\n        removechild(\n          ((currentparent: any): instance),\n          (node.statenode: instance | textinstance),\n        );\n      }\n    } /*......*/else {\n      // 提交删除待删除的节点\n      commitunmount(finishedroot, node, nearestmountedancestor);\n      // 继续向子节点捕获\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    }\n    // 如果已经捕获冒泡完成，则退出\n    if (node === current) {\n      return;\n    }\n    // 如果无法在继续捕获，且没有兄弟节点，尝试向父节点冒泡\n    while (node.sibling === null) {\n      // 如果冒泡到根节点，则退出\n      if (node.return === null || node.return === current) {\n        return;\n      }\n      node = node.return;\n      // ......\n    }\n    // 如果无法继续捕获，有兄弟节点，尝试向兄弟节点冒泡\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n这里的总流程仍然是嵌套在一个 “捕获和冒泡” 的遍历过程之中，其核心目的是找到与 dom 节点有关联性的 host 节点提交删除操作，包括 hostcomponent 和 hosttext 节点。具体的遍历过程不在赘述。有以下几点需要注意：\n\n * commitnestedunmounts : 此函数以 “捕获和冒泡” 方式遍历子节点，对每一个子节点执行 commitunmount 提交节点的删除任务。注意，这里是用于迭代删除 host 节点及其子节点。（注意：迭代不同于递归，迭代可以平替递归并获得更高的执行效率和更低的内存占用）。\n * removechildfromcontainer 和 removechild 是由 hostconfig 提供，提供原生 javascript 删除节点。注意：只有 host 节点才会被执行此 dom 删除操作，其他类型的节点不与 dom 节点对应。\n * commitunmount 针对组件类型执行一些清理工作和相关生命周期的调用。\n\n\n# commitunmount\n\n此函数针对组件类型执行清理工作和相关生命周期的调用，如函数式组件中副作用的销毁函数的调用、类组件中 componentwillunmount 生命周期函数的调用等。其他的组件类型的处理不在赘述。\n\nfunction commitunmount(\n  finishedroot: fiberroot,\n  current: fiber,\n  nearestmountedancestor: fiber,\n): void {\n  // ......\n  switch (current.tag) {\n    case functioncomponent:\n    case forwardref:\n    case memocomponent:\n    case simplememocomponent: {\n      const updatequeue: functioncomponentupdatequeue | null = (current.updatequeue: any);\n      if (updatequeue !== null) {\n        const lasteffect = updatequeue.lasteffect;\n        // 循环 updatequeue 上的 effect 环形链表\n        if (lasteffect !== null) {\n          const firsteffect = lasteffect.next;\n          let effect = firsteffect;\n          do {\n            // 调用副作用中的销毁函数\n            const {destroy, tag} = effect;\n            if (destroy !== undefined) {\n              // hookinsertion 和 hooklayout 标记分别对应 useinsertioneffect 和 uselayouteffect \n              if ((tag & hookinsertion) !== nohookeffect) {\n                safelycalldestroy(current, nearestmountedancestor, destroy);\n              } else if ((tag & hooklayout) !== nohookeffect) {\n                // ......\n                safelycalldestroy(current, nearestmountedancestor, destroy);\n              }\n            }\n            effect = effect.next;\n          } while (effect !== firsteffect);\n        }\n      }\n      return;\n    }\n    case classcomponent: {\n      // 移除 refs 引用的联结\n      safelydetachref(current, nearestmountedancestor);\n      const instance = current.statenode;\n      // 调用类组件 componentwillunmount 函数\n      if (typeof instance.componentwillunmount === 'function') {\n        safelycallcomponentwillunmount(\n          current,\n          nearestmountedancestor,\n          instance,\n        );\n      }\n      return;\n    }\n    case hostcomponent: \n    case hostportal:\n    case dehydratedfragment: \n    case scopecomponent: {\n      // ......\n      return;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n分析如下：\n\n * 针对函数式组价：遍历 updatequeue 上的 effect 环形链表，执行每个 effect 的销毁函数。其中 useinsertioneffect 类型副作用是通过 hookinsertion 标记辨识的， uselayouteffect 类型副作用时通过 hooklayout 标记辨识的。关于 effect 环形链表我们将在 hook 相关章节详述。\n * 针对类组件：安全的触发 componentwillunmount 生命周期函数。所谓安全触发就是使用 trycatch 语句捕获其中的错误。 为什么在 commitunmount 中需要强调 safely 呢？这是因为删除节点的操作应当是比较宽容的，不应该阻塞后续的真正的节点删除的 dom 操作，捕获到相关的错误之后能够向上冒泡被上级节点捕获到即可。\n\n\n# detachfibermutation\n\n此函数删除待删除节点和对应的 alternate 节点的 return 指针。因为 return 指针被删除，被删除的节点及其下的子节点所触发的事件将不能够冒泡到上方的节点树中，且其中的产生的更新也将被检测到并抛出警告。\n\nfunction detachfibermutation(fiber: fiber) {\n  // cut off the return pointer to disconnect it from the tree.\n  // this enables us to detect and warn against state updates on an unmounted component.\n  // it also prevents events from bubbling from within disconnected components.\n  //\n  // ideally, we should also clear the child pointer of the parent alternate to let this\n  // get gc:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for gc:ing the subtree of this child.\n  // this child itself will be gc:ed when the parent updates the next time.\n  //\n  // note that we can't clear child or sibling pointers yet.\n  // they're needed for passive effects and for finddomnode.\n  // we defer those fields, and all other cleanup, to the passive phase (see detachfiberaftereffects).\n  //\n  // don't reset the alternate yet, either. we need that so we can detach the\n  // alternate's fields in the passive phase. clearing the return pointer is\n  // sufficient for finddomnode semantics.\n  // 断开 workinprogress fiber 和 current fiber 上的 return 指针，但是此时其父节点指向该节点的 child 指针并没有断开，\n  // 因此 gc 将不会在本次渲染中清理这些删除的节点，在下次渲染时（调和 fibertree 时）将清理这些悬空的节点（无 return 指针）\n  const alternate = fiber.alternate;\n  if (alternate !== null) {\n    alternate.return = null;\n  }\n  fiber.return = null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# commitplacement\n\n此函数主要作用是计算待置位节点的父节点和待插入位置的兄弟节点。\n\nfunction commitplacement(finishedwork: fiber): void {\n  // ......\n  // 查找距离移位节点的最近的 host 祖先节点（标记为 hostcomponent、hostroot、hostportal）\n  const parentfiber = gethostparentfiber(finishedwork);\n\n  let parent;\n  // 是否是 hostroot 或者 hostportal\n  let iscontainer;\n  // statenode 表示当前 fiber 节点对应的 dom 节点或者是组件实例对象\n  const parentstatenode = parentfiber.statenode;\n  switch (parentfiber.tag) {\n    case hostcomponent:\n      parent = parentstatenode;\n      iscontainer = false;\n      break;\n    case hostroot:\n      parent = parentstatenode.containerinfo;\n      iscontainer = true;\n      break;\n    case hostportal:\n      parent = parentstatenode.containerinfo;\n      iscontainer = true;\n      break;\n    // ......\n  }\n  // ......\n  // 查找距离待移位节点最近的兄弟 host 节点\n  // 待移位的节点将插入到查找到的节点之后\n  const before = gethostsibling(finishedwork);\n  // we only have the top fiber that was inserted but we need to recurse down its\n  // children to find all the terminal nodes.\n  if (iscontainer) {\n    insertorappendplacementnodeintocontainer(finishedwork, before, parent);\n  } else {\n    insertorappendplacementnode(finishedwork, before, parent);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n分析如下：\n\n * gethostparentfiber 查找距离节点最近的 host 类型 的祖先节点。注意：无论是删除节点还是移位节点（包括添加节点），都是针对 host 节点进行操作。host 节点包括 hostcomponent 、 hostroot 、 hostportal 三种。 fiber.statenode 在 host 类型的 fiber 存储的是其相对应的 dom 节点。\n * gethostsibling 查找距离节点最近的 host 类型的兄弟节点（不能包含 placement 标记，因为其位置不稳定），如果没有兄弟节点且没有父节点或者父节点也是 host 节点，则返回 null，否则将继续上父节点追溯，因为非 host 类型的组件不对应 dom 结构，需要向上解包装，在这种情况下查找的效率会大大降低。\n * insertorappendplacementnode 将会根据查找到的父节点和兄弟节点的执行置位操作。\n\n\n# insertorappendplacementnode\n\n此函数对待置位的节点进行置位（插入或者移位）。\n\nfunction insertorappendplacementnode(\n  node: fiber,\n  before: ?instance,\n  parent: instance,\n): void {\n  const {tag} = node;\n  const ishost = tag === hostcomponent || tag === hosttext;\n  // 如果待置位节点是 host 类型的节点，有 before 节点则在 before 节点前插入，\n  // 否则则追加到末尾\n  if (ishost) {\n    const statenode = node.statenode;\n    if (before) {\n      insertbefore(parent, statenode, before);\n    } else {\n      appendchild(parent, statenode);\n    }\n  } /*......*/ else {\n    const child = node.child;\n    // 如果该节点不是 host 节点，则对组件进行解包装，取其子节点即子节点的兄弟节点依次置位\n    if (child !== null) {\n      insertorappendplacementnode(child, before, parent);\n      let sibling = child.sibling;\n      while (sibling !== null) {\n        insertorappendplacementnode(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n函数中对待置位的节点是否是 host 类型的节点分成两种情况处理。\n\n * 如果待置位的节点是 host 节点，且已经找到稳定的兄弟节点，则将该节点插入到此节点的前面，否则说明父节点下无稳定节点，则将该节点追加到末尾。\n * 如果待置位的节点不是 host 节点，则需要对该节点进行解包装，对该节点的子节点即子节点的所有兄弟节点进行递归置位。\n\n\n# commitwork\n\n此函数对 hostcomponent 、 hosttext 等 host 类型的节点提交更新操作，同时针对函数式组件处理相关副作用。\n\n// src/react/packages/react-reconciler/src/reactfibercommitwork.new.js\nfunction commitwork(current: fiber | null, finishedwork: fiber): void {\n  // ......\n  switch (finishedwork.tag) {\n    case functioncomponent:\n    case forwardref:\n    case memocomponent:\n    case simplememocomponent: {\n      // 如果是函数式组件（或者 fc-like 型组件），在组件更新之前，先执行 useinsertioneffect 的销毁函数\n      commithookeffectlistunmount(\n        hookinsertion | hookhaseffect,\n        finishedwork,\n        finishedwork.return,\n      );\n      // 执行 useinsertioneffect 的副作用函数，see https://zh-hans.reactjs.org/docs/hooks-reference.html#useinsertioneffect\n      commithookeffectlistmount(hookinsertion | hookhaseffect, finishedwork);\n      // layout effects are destroyed during the mutation phase so that all\n      // destroy functions for all fibers are called before any create functions.\n      // this prevents sibling component effects from interfering with each other,\n      // e.g. a destroy function in one component should never override a ref set\n      // by a create function in another component during the same commit.\n      // ......\n      // 执行 uselayouteffect 的销毁函数\n      commithookeffectlistunmount(\n        hooklayout | hookhaseffect,\n        finishedwork,\n        finishedwork.return,\n      );\n      return;\n    }\n    case hostcomponent: {\n      const instance: instance = finishedwork.statenode;\n      if (instance != null) {\n        // commit the work prepared earlier.\n        const newprops = finishedwork.memoizedprops;\n        // for hydration we reuse the update path but we treat the oldprops\n        // as the newprops. the updatepayload will contain the real change in\n        // this case.\n        const oldprops = current !== null ? current.memoizedprops : newprops;\n        const type = finishedwork.type;\n        const updatepayload: null | updatepayload = (finishedwork.updatequeue: any);\n        finishedwork.updatequeue = null;\n        if (updatepayload !== null) {\n          // 提交节点上的更新\n          commitupdate(\n            instance,\n            updatepayload,\n            type,\n            oldprops,\n            newprops,\n            finishedwork,\n          );\n        }\n      }\n      return;\n    }\n    case hosttext: {\n      // ......\n      const textinstance: textinstance = finishedwork.statenode;\n      const newtext: string = finishedwork.memoizedprops;\n      // for hydration we reuse the update path but we treat the oldprops\n      // as the newprops. the updatepayload will contain the real change in\n      // this case.\n      const oldtext: string =\n        current !== null ? current.memoizedprops : newtext;\n      // 提交文本更新\n      committextupdate(textinstance, oldtext, newtext);\n      return;\n    }\n    case classcomponent: \n    case hostroot: \n    case profiler: \n    case suspensecomponent: \n    case suspenselistcomponent: \n    case incompleteclasscomponent: {\n      // ......\n      return;\n    }\n    case scopecomponent: {\n      // ......\n      break;\n    }\n  }\n  // ......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n\n * 对于函数式组件而言，本函数先执行 useinsertioneffect 的销毁函数，再执行 useinsertioneffect 的副作用函数。另外，执行 uselayouteffect 的销毁函数，之所以在 mutation 阶段执行销毁函数，而非放到 layout 阶段在其副作用函数之前执行，是为了避免兄弟组件之间相互干扰。\n * useinsertioneffect 在所有 dom 突变之前同步触发，应仅限于 css-in-js 库作者使用。使用它在读取 uselayouteffect 中的布局之前将样式注入 dom，确保在对 dom 进行其他更改的同时操作 css 规则。参见 hook api 索引 – useinsertioneffect。\n * 对于 hostcomponent 而言，调用 commitupdate 提交节点的更新。对于 hosttext 而言，调用 committextupdate 函数提交文本节点的更新。这两个函数均是由 hostconfig 提供，此部分 host 节点的更新将应用到 dom 的更新上。\n\n\n# commithookeffectlistmount\n\n此函数执行副作用函数或者销毁函数，可用于 useeffect 、 uselayouteffect 、 useinsertioneffect 等 hook 中。其具体内容请参考 hook 相关章节的详述，此处暂不赘述。\n\n\n# commitdetachref\n\n此函数去除组件的 ref 引用的联结。\n\nfunction commitdetachref(current: fiber) {\n  const currentref = current.ref;\n  if (currentref !== null) {\n    // 如果 ref 是 function ref，将之置为 null\n    if (typeof currentref === 'function') {\n      currentref(null);\n      // ......\n    } else {\n      // 普通 ref，置为 null 即可\n      currentref.current = null;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# commitattachref\n\n此函数添加组件的 ref 应用的联结。\n\nfunction commitattachref(finishedwork: fiber) {\n  const ref = finishedwork.ref;\n  // 注意：上文 commitmutationeffectsonfiber 中 detach 的是 current fiber 的 ref，\n  // 并不是 workinprogress fiber 的 ref，因此此时 ref 必然不为空\n  if (ref !== null) {\n    // 获取组件实例或者 dom 组件实例，`fiber.statenode` 对于 host 类型的组件缓存 dom 组件实例，\n    // 否则则缓存组件的实例\n    const instance = finishedwork.statenode;\n    let instancetouse;\n    switch (finishedwork.tag) {\n      case hostcomponent:\n        instancetouse = getpublicinstance(instance);\n        break;\n      default:\n        instancetouse = instance;\n    }\n    // ......\n    // function ref 传递新的 ref\n    if (typeof ref === 'function') {\n      ref(instancetouse);\n    } else {\n      // ......\n      ref.current = instancetouse;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * 对于非 host 组件，ref 是缓存的是组件的实例，对于 host 类型组件，如 hostcomponent ，ref 上缓存的是 dom 组件实例。注意 hosttext 、 hostroot 、 hostportal 没有 ref，这是因为他们是两端的节点（根节点或者叶子节点），不存在传递 ref 应用的需求。\n * ref 分为普通的对象式 ref 和回调式 ref，参见 refs and the dom – 回调 refs\n\n\n# 扩展\n\n\n# “置位” 是如何解决 dom 节点的插入和移位问题的？\n\n在 insertorappendplacementnode 函数中，我们可以看到 react 对于 host 节点的插入是通过 insertbefore 和 appendchild 来实现的，那么我们可能会有这样的疑问，这种方式是如何实现 “插入” 和 “移位” 的需求的呢？要弄清楚这个问题，我们需要先结合 placechild 函数来看，在给同层级节点进行置位时，有如下的代码：\n\nif (current !== null) {\n  const oldindex = current.index;\n  if (oldindex < lastplacedindex) {\n    newfiber.flags |= placement;\n    return lastplacedindex;\n  } else {\n    return oldindex;\n  }\n} else {\n  newfiber.flags |= placement;\n  return lastplacedindex\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n可以看待，要添加 placement 置位标记，有以下两种情况：\n\n * 无可复用节点，即为 “插入” 的场景，添加置位标记。\n * 有可复用节点，且该节点原位置在上次置位位置的左侧（原位置比较靠左），即为需要 “移位” 场景，添加置位标记。\n\n参考如下图示：\n\n这其中包括两个步骤：\n\n * 生成 effecttag list，在 fibertree 的调和过程中（ render 阶段）完成。\n * 根据 effecttag list 操作（更新） dom，在 commit 阶段的 mutation 步骤中完成。\n\n结合这两个步骤的脉络，加之 “置位” 和 “提交置位” 的逻辑，便不难理解这个问题了。\n\n\n# 问题\n\n\n# 总结\n\n本文主要讲解了 commitdeletion 、 commitplacement 和 commitwork 三个核心函数的原理。这三个函数都是在 mutation 过程中完成的，目的是向 dom 提交 “删除”、“置位”、“更新” 等操作。可以此三个函数是 fibertree 与 domtree 沟通的接口。fibertree 相对于 domtree 具有更高层次的抽象意义，也就说 fibertree 除了承担视图抽象之外和承担了数据抽象的责任。因此，fibertree 与 domtree 交接时主要依赖于 fiber.statenode 和 fiber.tag 这两个字段。\n\nfiber.tag 为 host 类型，典型为 hostcomponent 和 hosttext ，则表明该 fiber 节点对应着 dom 节点，则相应的 effecttag 就需要在这些 host 节点上有所影响。 fiber.statenode 对于 host 节点而言缓存着对应的 dom 节点，这为在节点上操作 dom 提供了便利。\n\nreact 中 dom 的处理（mutation）包括三个方面：\n\n * deletion ，即删除，调用 removechild 。\n * placement ，即置位，包括插入和移位，调用 insertbefore 或者 appendchild 。\n * update ，即更新，调用 commitupdate 。\n\n在如上的过程中往往伴随着副作用的处理、生命周期函数的处理、ref 引用的处理等工作。而真正的 dom 操作则是由 hostconfig 所提供，如 removechild 、 commitupdate 等。 hostconfig 提供了防腐层以抹平不同 host 环境（平台）中对于节点操作的差异，这方面内容将在下文中详述。\n\n\n# 参考\n\n * know about the useinsertioneffect hook in react 18 | saeloun blog\n * library upgrade guide: style most css-in-js libs · discussion #110 · reactwg/react-18",charsets:{cjk:!0},lastUpdated:"2022/08/09, 20:11:40",lastUpdatedTimestamp:16600471e5},{title:"React 源码漂流记：React 调和器核心源码解读（十）",frontmatter:{title:"React 源码漂流记：React 调和器核心源码解读（十）",date:"2022-08-09T12:02:21.000Z",permalink:"/react/tour/react-reconciliation-10/",categories:["react","React源码漂流记"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/180.react-reconciliation-10.html",relativePath:"10.react/90.React源码漂流记/180.react-reconciliation-10.md",key:"v-4079c547",path:"/react/tour/react-reconciliation-10/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:17},{level:2,title:"removeChild",slug:"removechild",normalizedTitle:"removechild",charIndex:23},{level:2,title:"insertBefore",slug:"insertbefore",normalizedTitle:"insertbefore",charIndex:38},{level:2,title:"appendChild",slug:"appendchild",normalizedTitle:"appendchild",charIndex:54},{level:2,title:"commitTextUpdate",slug:"committextupdate",normalizedTitle:"committextupdate",charIndex:69},{level:2,title:"commitUpdate",slug:"commitupdate",normalizedTitle:"commitupdate",charIndex:89},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:105},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:111},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:117},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:123}],readingTime:{text:"2 min read",minutes:1.23,time:73800,words:246},headersStr:"目录 前言 removeChild insertBefore appendChild commitTextUpdate commitUpdate 扩展 问题 总结 参考",content:'# 目录\n\n\n\n * 目录\n * 前言\n * removeChild\n * insertBefore\n * appendChild\n * commitTextUpdate\n * commitUpdate\n * 扩展\n * 问题\n * 总结\n * 参考\n\n\n\n\n# 前言\n\n在上文中，我们探讨了 mutation 过程中 EffectTag List 对 DOM 操作的影响，包括向 DOM 提交删除、置位、更新等操作。实际上这里讲 DOM 比较片面，因为 React 所支持的 HOST 环境包括 DOM, canvas, console、nodejs 等，而 DOM 只是其中最常用的一项而已。\n\nReact 中针对每个 HOST 运行环境（renderer）提供 HostConfig 的概念， HostConfig 提供了节点的具体的操作能力，不仅仅限于 DOM 环境。React 官方给出如下定义：\n\n提示\n\nA "host config" is an object that you need to provide, and that describes how to make something happen in the "host" environment (e.g. DOM, canvas, console, native, or whatever your rendering target is).\n\n在本文中我们以 DOM 环境为例，描述前文出现的节点操作的具体原理。\n\n\n# removeChild\n\n此函数删除节点。\n\nfunction removeChild(\n  parentInstance: Instance,\n  child: Instance | TextInstance | SuspenseInstance,\n): void {\n  parentInstance.removeChild(child);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# insertBefore\n\n此函数在指定节点之前插入节点。\n\nfunction insertBefore(\n  parentInstance: Instance,\n  child: Instance | TextInstance,\n  beforeChild: Instance | TextInstance | SuspenseInstance,\n): void {\n  parentInstance.insertBefore(child, beforeChild);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# appendChild\n\n此函数在节点末尾追加节点。\n\nfunction appendChild(\n  parentInstance: Instance,\n  child: Instance | TextInstance,\n): void {\n  parentInstance.appendChild(child);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# commitTextUpdate\n\n此函数更新文本节点的内容。\n\nfunction commitTextUpdate(\n  textInstance: TextInstance,\n  oldText: string,\n  newText: string,\n): void {\n  textInstance.nodeValue = newText;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# commitUpdate\n\n此函数更新非文本节点的属性和内容。\n\nfunction commitUpdate(\n  domElement: Instance,\n  updatePayload: Array<mixed>,\n  type: string,\n  oldProps: Props,\n  newProps: Props,\n  internalInstanceHandle: Object,\n): void {\n  // src/react/packages/react-dom/src/client/ReactDOMComponent.js\n  // Apply the diff to the DOM node.\n  updateProperties(domElement, updatePayload, type, oldProps, newProps);\n  // Update the props handle so that we know which props are the ones with\n  // with current event handlers.\n  updateFiberProps(domElement, newProps);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 扩展\n\n\n# 问题\n\n\n# 总结\n\n\n# 参考\n\n * react/README.md at main · facebook/react',normalizedContent:'# 目录\n\n\n\n * 目录\n * 前言\n * removechild\n * insertbefore\n * appendchild\n * committextupdate\n * commitupdate\n * 扩展\n * 问题\n * 总结\n * 参考\n\n\n\n\n# 前言\n\n在上文中，我们探讨了 mutation 过程中 effecttag list 对 dom 操作的影响，包括向 dom 提交删除、置位、更新等操作。实际上这里讲 dom 比较片面，因为 react 所支持的 host 环境包括 dom, canvas, console、nodejs 等，而 dom 只是其中最常用的一项而已。\n\nreact 中针对每个 host 运行环境（renderer）提供 hostconfig 的概念， hostconfig 提供了节点的具体的操作能力，不仅仅限于 dom 环境。react 官方给出如下定义：\n\n提示\n\na "host config" is an object that you need to provide, and that describes how to make something happen in the "host" environment (e.g. dom, canvas, console, native, or whatever your rendering target is).\n\n在本文中我们以 dom 环境为例，描述前文出现的节点操作的具体原理。\n\n\n# removechild\n\n此函数删除节点。\n\nfunction removechild(\n  parentinstance: instance,\n  child: instance | textinstance | suspenseinstance,\n): void {\n  parentinstance.removechild(child);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# insertbefore\n\n此函数在指定节点之前插入节点。\n\nfunction insertbefore(\n  parentinstance: instance,\n  child: instance | textinstance,\n  beforechild: instance | textinstance | suspenseinstance,\n): void {\n  parentinstance.insertbefore(child, beforechild);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# appendchild\n\n此函数在节点末尾追加节点。\n\nfunction appendchild(\n  parentinstance: instance,\n  child: instance | textinstance,\n): void {\n  parentinstance.appendchild(child);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# committextupdate\n\n此函数更新文本节点的内容。\n\nfunction committextupdate(\n  textinstance: textinstance,\n  oldtext: string,\n  newtext: string,\n): void {\n  textinstance.nodevalue = newtext;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# commitupdate\n\n此函数更新非文本节点的属性和内容。\n\nfunction commitupdate(\n  domelement: instance,\n  updatepayload: array<mixed>,\n  type: string,\n  oldprops: props,\n  newprops: props,\n  internalinstancehandle: object,\n): void {\n  // src/react/packages/react-dom/src/client/reactdomcomponent.js\n  // apply the diff to the dom node.\n  updateproperties(domelement, updatepayload, type, oldprops, newprops);\n  // update the props handle so that we know which props are the ones with\n  // with current event handlers.\n  updatefiberprops(domelement, newprops);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 扩展\n\n\n# 问题\n\n\n# 总结\n\n\n# 参考\n\n * react/readme.md at main · facebook/react',charsets:{cjk:!0},lastUpdated:"2022/08/09, 20:11:40",lastUpdatedTimestamp:16600471e5},{title:"前言",frontmatter:{title:"前言",date:"2022-08-22T14:19:35.000Z",permalink:"/react/tour/talk/",categories:["react","React源码漂流记"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/2.talk.html",relativePath:"10.react/90.React源码漂流记/2.talk.md",key:"v-5585c5df",path:"/react/tour/talk/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"前置知识",slug:"前置知识",normalizedTitle:"前置知识",charIndex:17},{level:2,title:"为什么读 React 源码？",slug:"为什么读-react-源码",normalizedTitle:"为什么读 react 源码？",charIndex:25},{level:2,title:"怎么读 React 源码？",slug:"怎么读-react-源码",normalizedTitle:"怎么读 react 源码？",charIndex:43},{level:2,title:"我们能从 React 源码中学习到什么？",slug:"我们能从-react-源码中学习到什么",normalizedTitle:"我们能从 react 源码中学习到什么？",charIndex:60},{level:2,title:"本系列的文章怎么解读 React 源码？",slug:"本系列的文章怎么解读-react-源码",normalizedTitle:"本系列的文章怎么解读 react 源码？",charIndex:84},{level:2,title:"面试题热身",slug:"面试题热身",normalizedTitle:"面试题热身",charIndex:108},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:117}],readingTime:{text:"2 min read",minutes:1.205,time:72300.00000000001,words:241},headersStr:"目录 前置知识 为什么读 React 源码？ 怎么读 React 源码？ 我们能从 React 源码中学习到什么？ 本系列的文章怎么解读 React 源码？ 面试题热身 参考",content:"# 目录\n\n\n\n * 目录\n * 前置知识\n * 为什么读 React 源码？\n * 怎么读 React 源码？\n * 我们能从 React 源码中学习到什么？\n * 本系列的文章怎么解读 React 源码？\n * 面试题热身\n * 参考\n\n\n\n这是 React 源码漂流记系列文章的第一篇。从今天开始，开启我们的 React 源码阅读之旅。\n\n我阅读 React 的源码陆陆续续也有几个月之久，其间也有不少的收获和感悟，趁此机会，整理成文章，与大家分享和讨论，同时也可以给想要开始阅读源码的伙伴一些启发吧。\n\n开始今天的内容之前，我想先聊几个问题，因为这是 React 源码阅读系列的第一篇文章，我想先分享一下我对阅读源码的一下见解。\n\n\n# 前置知识\n\n * 熟悉 Javascript 语言。\n * 熟练使用 React 框架，并且有一定的开发经验。\n\n\n# 为什么读 React 源码？\n\n可能有如下的场景让你开始关注 React 源码：\n\n 1. React 的使用已经得心应手了，迫切的想知道这些每天使用的 API 到底是什么原理？比如每天都用到 useState，那么究竟 useState 是如何处理组件的状态的呢？\n 2. 需求开发中遇到奇怪的问题，怎么都找不到原因，是否是我对 API 的理解和使用有偏差？\n 3. 业务太复杂，我的组件遇到了性能瓶颈，能榨干性能的手段悉数用尽，关于性能问题，是否还有其他的灵感呢？\n 4. 我想写大型组件库，能够达到 antd 那样强大的功能，我需要对 React 以及更多更底层的 API 有更多的理解。\n 5. 我想写框架玩玩，能否参照下 React 框架的思路？……\n\n可能会遇到如下的问题，让你迫切的想要从 React 源码中找答案：\n\n 1. 我的 setState 为什么没有更新组件的状态？为什么我的组件渲染了这么多次？这会不会很消耗性能？\n 2. 为什么我需要给列表项设置 key 值，不设置 key 值会有什么问题？\n 3. 为什么需要使用 useRef，为什么要使用 useMemo、useCallback 进行性能优化？这种优化是否是越多越好？\n 4. 为什么 hook 只能在顶层使用，hook 为什么能够使业务逻辑得到复用？\n 5. 为什么我的数据丢失了响应性，闭包问题又如何解决？……\n\n不管你是为什么开始关注到 React 的原理，不管你是否开启了阅读 React 源码的计划，关注这个系列的文章，我们可以一起学习、成长与进步。\n\n\n# 怎么读 React 源码？\n\n我有如下的方法推荐给你：\n\n 1. 断点调试，搜索脉络。通过简单的案例，从源码中打断点，逐步深入探索。好的搜索技巧可能帮助你快速找到你需要查看的函数。\n 2. 由表及里，笔记加强。从 API 层，逐步向更深的实现逻辑追溯，直到形成知识的闭环。通过笔记记录自己的学习历程，不断更正和完善笔记内容。\n 3. 问题驱动，寻找答案。从业务需求中遇到的问题出发，从源码中寻找答案，直到解决疑惑为止。\n\n阅读源码的建议：\n\n 1. 先关注核心逻辑，然后在关注实现细节。React 中有很多 Dev 环境、插件的代码或者是兼容性考虑的代码，可能会对你的阅读产生影响，可以跳过这些逻辑，只关注核心骨架。\n 2. 分层阅读。React 内部分成了很多模块，可以根据阅读进度分层阅读，直到最终能够将各个模块的内容联动起来。\n 3. 关注注释。源码中有很多详细的注释，关注注释可以给你更深的理解。\n\n\n# 我们能从 React 源码中学习到什么？\n\n * 对框架更深入的理解和掌握。\n * 框架设计的思想和模式。\n * js 的高级应用。\n\n\n# 本系列的文章怎么解读 React 源码？\n\n * 源码：源码本身是最重要的，文章中列出的源码都是已经提炼处理的核心的代码，去除了 dev 环境、各种插件或者非核心的代码，防止对您阅读产生影响。\n * 篇幅：内容的篇幅不会很长，每篇文章会严格控制在 15 分钟阅读时间之内。如果您关注某些细节问题，可以参见【扩展】部分，这一部分会对本篇文章产生的若干细节问题进行扩展，当然如果您只关注骨干内容也可以跳过这一部分。\n * 内容：源码的解读难以逃脱个人理解的范围，所以如果有错误的地方、或者您有不同的见解、更多的问题，还请及时指正或者在评论区提出。当然也有一些问题，会在【问题】部分列出，作为对文章内容的消化。\n\n\n# 面试题热身\n\n如果能够在面试的过程中畅谈 React 的设计原理，那必然能给面试官留下深刻的印象。不要怀疑这一点，在前端的学习过程中，除了经历所带来的的经验的知识广度之外，知识深度却并非任何人都能够达到的。在任何的专业领域，除了得见多识广，还必须得意见深刻方可。原理的学习就是这样一个 “见底” 和 “打磨” 的过程，这虽然是一趟孤独之旅，但终将使你受益颇深。\n\n看源码本身就是跟专业的人、聪明的人对话的过程，虽然前期会觉得不知所云，但总有一天你也可以脱颖而出。关于 React 原理的面试题有很多经典的例子，大多是一些 “是什么” 的问题，关于这些问题我觉得你并不陌生，也没法难住你；然而本书的内容将要帮助你的，是解决 “为什么” 的问题。“为什么” 的问题才是最重要的问题，解决问题要从根上解决，看问题也需要从本质上去分析原因。下面列举一二，以供参考：\n\n * 类组件与函数组件有什么区别？为什么有这些区别？\n * 如何设计 React 组件？为什么？\n * setState 是同步还是异步更新？为什么？\n * Virtual DOM 的原理是什么？说说你对 React 中的 VDOM 的理解？\n * 与其他框架相比，React 的 Diff 算法有何不同？有哪些利弊？\n * 如何解释 React 的渲染流程？说说为什么采用这样的渲染流程？说说 React 的渲染方式与其他框架的异同？这样的渲染方式有何利弊？\n * 如何分析和调优性能瓶颈？优化的原理是什么？\n * React Hook 的使用限制有哪些？为什么？\n * useEffect 和 useLayoutEffect 区别在哪里？为什么会有这样的区别？\n * React Hooks 解决了哪些问题？怎么解决的？\n * React Hooks 和生命周期的关系？\n * React key 是干嘛用的 为什么要加？\n * 对 React 和 Vue 的理解，它们的异同？\n * React 设计思路，它的理念是什么？\n * React 必须使用 JSX 吗？为什么使用 JSX？\n * 谈一谈 react 事件机制？\n * 谈谈你对 React-Fiber 的理解，它解决了什么问题？\n * 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？\n * React 如何判断什么时候重新渲染组件？\n * ......\n\n您可以已经注意到了，这些问题都会强调 “为什么”，如果您现在不清楚应该怎么回答也没关系，本系列文章将会会娓娓道来，帮助大家从原理的角度去深层的思考这些问题。我希望经过本书的学习，您不仅仅可以完美的回答大部分关于 React 的问题，还能够谈笑风生，延伸到 “为什么会这样？”、“这样做有什么好处，有什么问题？” 这样的问题上，甚至能够对问题提出自己的改进措施和解决方案。\n\n关于 React 源码相关的面试题，会有单独的章节进行讲解。\n\n\n# 参考\n\n * 「React」面试口喷框架核心原理 - 掘金\n * 「2021」高频前端面试题汇总之 React 篇（下） - 掘金",normalizedContent:"# 目录\n\n\n\n * 目录\n * 前置知识\n * 为什么读 react 源码？\n * 怎么读 react 源码？\n * 我们能从 react 源码中学习到什么？\n * 本系列的文章怎么解读 react 源码？\n * 面试题热身\n * 参考\n\n\n\n这是 react 源码漂流记系列文章的第一篇。从今天开始，开启我们的 react 源码阅读之旅。\n\n我阅读 react 的源码陆陆续续也有几个月之久，其间也有不少的收获和感悟，趁此机会，整理成文章，与大家分享和讨论，同时也可以给想要开始阅读源码的伙伴一些启发吧。\n\n开始今天的内容之前，我想先聊几个问题，因为这是 react 源码阅读系列的第一篇文章，我想先分享一下我对阅读源码的一下见解。\n\n\n# 前置知识\n\n * 熟悉 javascript 语言。\n * 熟练使用 react 框架，并且有一定的开发经验。\n\n\n# 为什么读 react 源码？\n\n可能有如下的场景让你开始关注 react 源码：\n\n 1. react 的使用已经得心应手了，迫切的想知道这些每天使用的 api 到底是什么原理？比如每天都用到 usestate，那么究竟 usestate 是如何处理组件的状态的呢？\n 2. 需求开发中遇到奇怪的问题，怎么都找不到原因，是否是我对 api 的理解和使用有偏差？\n 3. 业务太复杂，我的组件遇到了性能瓶颈，能榨干性能的手段悉数用尽，关于性能问题，是否还有其他的灵感呢？\n 4. 我想写大型组件库，能够达到 antd 那样强大的功能，我需要对 react 以及更多更底层的 api 有更多的理解。\n 5. 我想写框架玩玩，能否参照下 react 框架的思路？……\n\n可能会遇到如下的问题，让你迫切的想要从 react 源码中找答案：\n\n 1. 我的 setstate 为什么没有更新组件的状态？为什么我的组件渲染了这么多次？这会不会很消耗性能？\n 2. 为什么我需要给列表项设置 key 值，不设置 key 值会有什么问题？\n 3. 为什么需要使用 useref，为什么要使用 usememo、usecallback 进行性能优化？这种优化是否是越多越好？\n 4. 为什么 hook 只能在顶层使用，hook 为什么能够使业务逻辑得到复用？\n 5. 为什么我的数据丢失了响应性，闭包问题又如何解决？……\n\n不管你是为什么开始关注到 react 的原理，不管你是否开启了阅读 react 源码的计划，关注这个系列的文章，我们可以一起学习、成长与进步。\n\n\n# 怎么读 react 源码？\n\n我有如下的方法推荐给你：\n\n 1. 断点调试，搜索脉络。通过简单的案例，从源码中打断点，逐步深入探索。好的搜索技巧可能帮助你快速找到你需要查看的函数。\n 2. 由表及里，笔记加强。从 api 层，逐步向更深的实现逻辑追溯，直到形成知识的闭环。通过笔记记录自己的学习历程，不断更正和完善笔记内容。\n 3. 问题驱动，寻找答案。从业务需求中遇到的问题出发，从源码中寻找答案，直到解决疑惑为止。\n\n阅读源码的建议：\n\n 1. 先关注核心逻辑，然后在关注实现细节。react 中有很多 dev 环境、插件的代码或者是兼容性考虑的代码，可能会对你的阅读产生影响，可以跳过这些逻辑，只关注核心骨架。\n 2. 分层阅读。react 内部分成了很多模块，可以根据阅读进度分层阅读，直到最终能够将各个模块的内容联动起来。\n 3. 关注注释。源码中有很多详细的注释，关注注释可以给你更深的理解。\n\n\n# 我们能从 react 源码中学习到什么？\n\n * 对框架更深入的理解和掌握。\n * 框架设计的思想和模式。\n * js 的高级应用。\n\n\n# 本系列的文章怎么解读 react 源码？\n\n * 源码：源码本身是最重要的，文章中列出的源码都是已经提炼处理的核心的代码，去除了 dev 环境、各种插件或者非核心的代码，防止对您阅读产生影响。\n * 篇幅：内容的篇幅不会很长，每篇文章会严格控制在 15 分钟阅读时间之内。如果您关注某些细节问题，可以参见【扩展】部分，这一部分会对本篇文章产生的若干细节问题进行扩展，当然如果您只关注骨干内容也可以跳过这一部分。\n * 内容：源码的解读难以逃脱个人理解的范围，所以如果有错误的地方、或者您有不同的见解、更多的问题，还请及时指正或者在评论区提出。当然也有一些问题，会在【问题】部分列出，作为对文章内容的消化。\n\n\n# 面试题热身\n\n如果能够在面试的过程中畅谈 react 的设计原理，那必然能给面试官留下深刻的印象。不要怀疑这一点，在前端的学习过程中，除了经历所带来的的经验的知识广度之外，知识深度却并非任何人都能够达到的。在任何的专业领域，除了得见多识广，还必须得意见深刻方可。原理的学习就是这样一个 “见底” 和 “打磨” 的过程，这虽然是一趟孤独之旅，但终将使你受益颇深。\n\n看源码本身就是跟专业的人、聪明的人对话的过程，虽然前期会觉得不知所云，但总有一天你也可以脱颖而出。关于 react 原理的面试题有很多经典的例子，大多是一些 “是什么” 的问题，关于这些问题我觉得你并不陌生，也没法难住你；然而本书的内容将要帮助你的，是解决 “为什么” 的问题。“为什么” 的问题才是最重要的问题，解决问题要从根上解决，看问题也需要从本质上去分析原因。下面列举一二，以供参考：\n\n * 类组件与函数组件有什么区别？为什么有这些区别？\n * 如何设计 react 组件？为什么？\n * setstate 是同步还是异步更新？为什么？\n * virtual dom 的原理是什么？说说你对 react 中的 vdom 的理解？\n * 与其他框架相比，react 的 diff 算法有何不同？有哪些利弊？\n * 如何解释 react 的渲染流程？说说为什么采用这样的渲染流程？说说 react 的渲染方式与其他框架的异同？这样的渲染方式有何利弊？\n * 如何分析和调优性能瓶颈？优化的原理是什么？\n * react hook 的使用限制有哪些？为什么？\n * useeffect 和 uselayouteffect 区别在哪里？为什么会有这样的区别？\n * react hooks 解决了哪些问题？怎么解决的？\n * react hooks 和生命周期的关系？\n * react key 是干嘛用的 为什么要加？\n * 对 react 和 vue 的理解，它们的异同？\n * react 设计思路，它的理念是什么？\n * react 必须使用 jsx 吗？为什么使用 jsx？\n * 谈一谈 react 事件机制？\n * 谈谈你对 react-fiber 的理解，它解决了什么问题？\n * 哪些方法会触发 react 重新渲染？重新渲染 render 会做些什么？\n * react 如何判断什么时候重新渲染组件？\n * ......\n\n您可以已经注意到了，这些问题都会强调 “为什么”，如果您现在不清楚应该怎么回答也没关系，本系列文章将会会娓娓道来，帮助大家从原理的角度去深层的思考这些问题。我希望经过本书的学习，您不仅仅可以完美的回答大部分关于 react 的问题，还能够谈笑风生，延伸到 “为什么会这样？”、“这样做有什么好处，有什么问题？” 这样的问题上，甚至能够对问题提出自己的改进措施和解决方案。\n\n关于 react 源码相关的面试题，会有单独的章节进行讲解。\n\n\n# 参考\n\n * 「react」面试口喷框架核心原理 - 掘金\n * 「2021」高频前端面试题汇总之 react 篇（下） - 掘金",charsets:{cjk:!0},lastUpdated:"2022/08/24, 18:21:13",lastUpdatedTimestamp:1661336473e3},{title:"React 源码漂流记：ReactChildren 与节点操纵",frontmatter:{title:"React 源码漂流记：ReactChildren 与节点操纵",date:"2022-04-14T22:02:21.000Z",permalink:"/react/tour/react-basic-children/",categories:["react","React源码漂流记"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/20.react-basic-children.html",relativePath:"10.react/90.React源码漂流记/20.react-basic-children.md",key:"v-50140a3b",path:"/react/tour/react-basic-children/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:17},{level:3,title:"学习目标",slug:"学习目标",normalizedTitle:"学习目标",charIndex:25},{level:2,title:"什么是 React.Children?",slug:"什么是-react-children",normalizedTitle:"什么是 react.children?",charIndex:33},{level:2,title:"map",slug:"map",normalizedTitle:"map",charIndex:56},{level:2,title:"forEach",slug:"foreach",normalizedTitle:"foreach",charIndex:63},{level:2,title:"count",slug:"count",normalizedTitle:"count",charIndex:74},{level:2,title:"toArray",slug:"toarray",normalizedTitle:"toarray",charIndex:83},{level:2,title:"only",slug:"only",normalizedTitle:"only",charIndex:94},{level:2,title:"cloneElement",slug:"cloneelement",normalizedTitle:"cloneelement",charIndex:102},{level:2,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:118},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:124},{level:3,title:"ChildrenKey 是如何生成的？",slug:"childrenkey-是如何生成的",normalizedTitle:"childrenkey 是如何生成的？",charIndex:132},{level:3,title:"ReactElement、JSX.Element 和 ReactNode 的区别",slug:"reactelement、jsx-element-和-reactnode-的区别",normalizedTitle:"reactelement、jsx.element 和 reactnode 的区别",charIndex:157},{level:3,title:"原版代码中的池化模式的应用",slug:"原版代码中的池化模式的应用",normalizedTitle:"原版代码中的池化模式的应用",charIndex:203},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:220}],readingTime:{text:"6 min read",minutes:5.55,time:333e3,words:1110},headersStr:"目录 前言 学习目标 什么是 React.Children? map forEach count toArray only cloneElement 应用 扩展 ChildrenKey 是如何生成的？ ReactElement、JSX.Element 和 ReactNode 的区别 原版代码中的池化模式的应用 总结",content:"# 目录\n\n\n\n * 目录\n * 前言\n   * 学习目标\n * 什么是 React.Children?\n * map\n * forEach\n * count\n * toArray\n * only\n * cloneElement\n * 应用\n * 扩展\n   * ChildrenKey 是如何生成的？\n   * ReactElement、JSX.Element 和 ReactNode 的区别\n   * 原版代码中的池化模式的应用\n * 总结\n\n\n\n\n# 前言\n\n在上一篇文章中，我们分享了 ReactElement 与基础概念 的话题，对 JSX、ReactElement、VDOM、Component 等概念有了一定了解。今天这篇文章，我们来分享跟 ReactNode 相关的 ReactChildren 的工具函数的实现原理。\n\n\n# 学习目标\n\n * 学习 ReactChildren 的工具函数的实现原理。\n * 加强对 ReactElement、ReactNode、ReactChildren、组件等概念的理解。\n * 学习使用 ReactChildren 工具函数操纵节点的进阶用法。\n\n\n# 什么是 React.Children?\n\n> React.Children 提供了用于处理 this.props.children 不透明数据结构的实用方法。\n\nChildren 指的就是组件中 props.children 的值。Children 的类型通常是 ReactNode。ReactNode 是组件的渲染模板执行后的结果（ClassComponent 中 render () 函数执行的结果或者 FunctionComponent 执行的结果）。\n\n由此我们就可以知道为什么 ReactChildren 需要使用工具函数来操作了，这是因为：\n\n * ReactNode 不是数组，ReactNode 的类型很复杂，不能用数组的方法进行遍历、map 等操作。\n * 需要相应的工具函数来提供操作 ReactNode 的能力。\n\n言归正传，从 React 的导出看，React Children 有如下四个方法：\n\n// 操作ReactChildren的方法。ReactChildren不是数组。模拟数组的一些方法。\n{ \n  map,\n  forEach,\n  count,\n  toArray,\n  only,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n下面我们来详细展开这几个函数的源码，了解其实现原理。\n\n\n# map\n\nmap 提供对 ReactChildren 的遍历映射操作。\n\nmap 内部由 mapChildren 函数实现。mapChildren 内部调用 mapIntoArray。\n\nfunction mapChildren(\n  children: ?ReactNodeList,\n  func: MapFunc,\n  context: mixed,\n): ?Array<React$Node> {\n  if (children == null) {\n    return children;\n  }\n  const result = [];\n  let count = 0;\n  // 调用 mapIntoArray 遍历 children，并在回调中调用 func，回调的结果放入 result\n  mapIntoArray(children, result, '', '', function(child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这个 mapIntoArray 比较复杂，它所支持的 children 的类型很多，基础类型包括 undefined、boolean、null、string、number 或者标记为 ReactElement 或者 ReactPortal 的 object。如果把基础类型标记为 T 的话，mapIntoArray 还支持 children 的类型为 T [] 或者迭代器 object。 后者是通过循环、迭代实现的，不再赘述，这里我们重点看基础类型。\n\nfunction mapIntoArray(\n  children: ?ReactNodeList,\n  array: Array<React$Node>,\n  escapedPrefix: string,\n  nameSoFar: string,\n  callback: (?React$Node) => ?ReactNodeList,\n): number {\n  // 如果是 undefined、boolean、null、string、number、标记为 object 的 ReactElement 或者 ReactPortal 等基础类型\n  // invokeCallback 为 true，执行如下的逻辑\n  if (invokeCallback) {\n    const child = children;\n    // 回调 callback\n    let mappedChild = callback(child);\n    // 当前层级的 key 的串\n    const childKey =\n      nameSoFar === '' ? SEPARATOR + getElementKey(child, 0) : nameSoFar;\n    // 如果 map 返回是一个数组，则需要对数组继续递归\n    if (isArray(mappedChild)) {\n      // ......\n      // 这里的 callback 是 c => c，说明返回的数组将会被 flat\n      mapIntoArray(mappedChild, array, escapedChildKey, '', c => c);\n    } else if (mappedChild != null) {\n      // 检查 mappedChild 是否是合法的 ReactElement\n      if (isValidElement(mappedChild)) {\n        // 规整 mappedChild 的 key 值\n        mappedChild = cloneAndReplaceKey(\n          mappedChild,\n          // 计算 mappedChild 的 key\n          escapedPrefix +\n            (mappedChild.key && (!child || child.key !== mappedChild.key)\n              ? escapeUserProvidedKey('' + mappedChild.key) + '/'\n              : '') +\n            childKey,\n        );\n      }\n      // 将 mappedChild 推入结果数组\n      array.push(mappedChild);\n    }\n    // 返回 count 次数，即 callback 被调用的次数\n    return 1;\n  }\n\n  // ......\n\n  return subtreeCount;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n总结一下如上的函数：\n\n * 主要运用了递归、循环、迭代的方法遍历 children，并且执行 callback，如果 callback 返回数组，则继续递归。注意，callback 返回的数组将会被摊平。这主要是因为在渲染节点的时候，节点的嵌套结构是由 ReactElement.props.children 决定的，所有的多维节点数组对会被摊平。\n * 因为 map 的返回结果 result 是一个数组，因此其中的节点都需要设置唯一的 key 值。\n\n\n# forEach\n\nforEach 提供对 ReactChildren 的遍历操作。\n\nforEach 是由 forEachChildren 实现的。有了上面 mapChildren 的基础，实现 forEach 就顺理成章了。\n\nfunction forEachChildren(\n  children: ?ReactNodeList,\n  forEachFunc: ForEachFunc,\n  forEachContext: mixed,\n): void {\n  mapChildren(\n    children,\n    function() {\n      // arguments 表示接受 callback 回调的所有参数\n      forEachFunc.apply(this, arguments);\n    },\n    forEachContext,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nforEach 只需要在调用 map 时，舍弃 map 的返回值就可以了。\n\n\n# count\n\ncount 计算 children 中的组件总数量。\n\ncount 内部由 countChildren 实现的。思路是在遍历过程中计算长度，除非传的是数组或者迭代器，否则返回的长度都是 1。\n\nfunction countChildren(children: ?ReactNodeList): number {\n  let n = 0;\n  mapChildren(children, () => {\n    n++;\n  });\n  return n;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# toArray\n\ntoArray 将 children 以数组形式返回。因为 mapChildren 的结果已经是数组了，所以直接返回。\n\nfunction toArray(children: ?ReactNodeList): Array<React$Node> {\n  return mapChildren(children, child => child) || [];\n}\n\n\n1\n2\n3\n\n\n\n# only\n\nonly 验证 children 是否是单节点，如果是单节点将之返回，否则报错。\n\nonly 内部由 onlyChild 实现。代码如下：\n\nfunction onlyChild<T>(children: T): T {\n  if (!isValidElement(children)) {\n    throw new Error(\n      'React.Children.only expected to receive a single React element child.',\n    );\n  }\n  return children;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# cloneElement\n\n\n# 应用\n\n在组件库等复杂的节点运用场景中常常会使用到 React.Children 工具，而且通常会与其他的节点操作 API 如 cloneElement 或者 createElement 一起使用。下面以 antd 代码中 Timeline 组件的一处使用场景作为示例：\n\n// components/timeline/Timeline.tsx\n// 对 truthyItems 中的节点进行修改\nconst items = React.Children.map(\n  truthyItems,\n  (ele: React.ReactElement<any>, idx) => {\n    const pendingClass = idx === itemsCount - 2 ? lastCls : \"\";\n    const readyClass = idx === itemsCount - 1 ? lastCls : \"\";\n    // 克隆原节点并覆盖 className 属性\n    return cloneElement(ele, {\n      className: classNames([\n        ele.props.className,\n        !reverse && !!pending ? pendingClass : readyClass,\n        getPositionCls(ele, idx),\n      ]),\n    });\n  }\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 扩展\n\n\n# ChildrenKey 是如何生成的？\n\n从 mapIntoArray 中传递给 cloneAndReplaceKey 的 key 值的计算逻辑：\n\n// key = \nconst SEPARATOR = '.';\nconst SUBSEPARATOR = ':';\n// 初始值为 ''，用于 mappedChild\nconst escapedPrefix = escapeUserProvidedKey(childKey) + '/';\nconst nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n// 初始值为 ''，用于数组和迭代器\nconst nameSoFar = nextNamePrefix + getElementKey(child, i);\nconst childKey = nameSoFar === '' ? SEPARATOR + getElementKey(child, 0) : nameSoFar;\nconst key = escapedPrefix +\n            (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey('' + mappedChild.key) + '/' : '') +\n            childKey;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n分成如下几种情况：\n\n * 如果是 children 是普通类型，key1 = escapeUserProvidedKey (mappedChild.key) + '/' + SEPARATOR + randomKey;\n * 如果是 mappedChild 数组下的 children，key2 = escapeUserProvidedKey (SEPARATOR + randomKey + '/') + '/' + key1;\n * 如果是数组或者迭代器，key3 = escapeUserProvidedKey (mappedChild.key) + '/' + SUBSEPARATOR + randomKey;\n * 如果是数组或者迭代器下的 mappedChild 数组下的 children，key4 = escapeUserProvidedKey (SUBSEPARATOR + randomKey + '/') + '/' + key3;\n\n这里的逻辑比较复杂，我们只需要知道 mapIntoArray 能够为结果数组中的节点生成唯一的 key 值即可。\n\n如何生成 randomKey？\n\nfunction getElementKey(element: any, index: number): string {\n  // 如果组件有 key 值则使用\n  if (typeof element === 'object' && element !== null && element.key != null) {\n    return escape('' + element.key);\n  }\n  // 使用 36 进制，即 0-9-a-z。如 (35).toString(36) === 'z'\n  return index.toString(36);\n}\n// 因为 key 中使用了固定的分隔符，所以用户传递的 key 需要 escape 做等意替换，并且添加前缀 `$`\nfunction escape(key: string): string {\n  const escapeRegex = /[=:]/g;\n  const escaperLookup = {\n    '=': '=0',\n    ':': '=2',\n  };\n  const escapedString = key.replace(escapeRegex, function(match) {\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n通过 36 进制生成随机字符串是比较常见的一种生成 id、key 标识的方式。例如下面这个示例：\n\n// 生成一个随机小写字母或者数字\nconst genSeed = () => (~~(Math.random()*36)).toString(36); // \"s\"\n\nfunction randomStringGenerator(length){\n   let s = '';\n   while(s.length < length) s += genSeed();\n   return s;\n}\nrandomStringGenerator(6); // \"6muky\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# ReactElement、JSX.Element 和 ReactNode 的区别\n\n要直观地理解三者的区别，需要我们从 React 的类型声明文件中去找答案。下面是一些类型：\n\ninterface ReactElement<P = any, T extends string | JSXElementConstructor<any> = string | JSXElementConstructor<any>> {\n  type: T;\n  props: P;\n  key: Key | null;\n}\ntype ReactText = string | number;\ntype ReactChild = ReactElement | ReactText;\ntype ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined;\n\nnamespace JSX {\n  interface Element extends React.ReactElement<any, any> { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n从这些类型可以看出来，三者是具有包含关系的，其中 ReactNode > JSX.Element > ReactElement 。\n\n * ReactNode：ReactNode 代表 React 节点，其类型中包含了 ReactChild，ReactChild 中又包含了 ReactElement。\n * JSX.Element：JSX.Element 和 ReactElement 基本一致，但是 JSX.Element 作为 JSX 的规范，它比 ReactNode 更加通用，因为 type 和 props 都被定义为 any。\n * ReactElement：ReactElement 是包含 type 、 props 、 key 等属性的 object，它是 DOM 的一种抽象表示，是 FunctionComponent （或者 ClassComponent 中 render 函数）执行的结果。\n\n\n# 原版代码中的池化模式的应用\n\nReact 17 中对 ReactChildren 中的代码进行了重构，在 React 16 的旧版代码中有一个对池化模式的应用，我觉得很有意思，作为扩展分享给大家。\n\n在源码中利用池化模式对 traverseContext 进行缓存，减少对象创建的成本。\n\n// traverseContextPool 的 size\nconst POOL_SIZE = 10;\nconst traverseContextPool = [];\n// 从 traverseContextPool 获取 traverseContext\nfunction getPooledTraverseContext(\n  mapResult, // 遍历结果数组\n  keyPrefix, // traverseContext 的 key\n  mapFunction, // 遍历回调函数\n  mapContext, // 遍历的 context\n) {\n  // 如果当前缓存池非空\n  if (traverseContextPool.length) {\n    // 取出队尾的traverseContext\n    const traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    // 返回缓存的 traverseContext\n    return traverseContext;\n  } else {\n    // 缓存池为空则新建一个 traverseContext，最多 10 个\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0,\n    };\n  }\n}\n// 释放 traverseContext 到 traverseContextPool\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n池化模式在需要频繁创建对象（连接）的场景中可以参考。缓存池大小 POOL_SIZE 需要权衡考虑效率和内存问题。如果 POOL_SIZE 太小，就不能很好的起到缓存的效果，如果太大缓存池本身就需要占用太多内存，而且用不完的 context 对象也容易造成浪费和低效。\n\n\n# 总结\n\n本篇文章包含了如下的核心知识点，总结如下：\n\n * ReactNode、ReactElement、ReactChildren 等概念的深入理解。\n * React.children 工具函数：map,forEach,count,toArray,only 的原理。\n * 使用 ReactChildren 工具函数应用到组件库等复杂场景中操作节点。",normalizedContent:"# 目录\n\n\n\n * 目录\n * 前言\n   * 学习目标\n * 什么是 react.children?\n * map\n * foreach\n * count\n * toarray\n * only\n * cloneelement\n * 应用\n * 扩展\n   * childrenkey 是如何生成的？\n   * reactelement、jsx.element 和 reactnode 的区别\n   * 原版代码中的池化模式的应用\n * 总结\n\n\n\n\n# 前言\n\n在上一篇文章中，我们分享了 reactelement 与基础概念 的话题，对 jsx、reactelement、vdom、component 等概念有了一定了解。今天这篇文章，我们来分享跟 reactnode 相关的 reactchildren 的工具函数的实现原理。\n\n\n# 学习目标\n\n * 学习 reactchildren 的工具函数的实现原理。\n * 加强对 reactelement、reactnode、reactchildren、组件等概念的理解。\n * 学习使用 reactchildren 工具函数操纵节点的进阶用法。\n\n\n# 什么是 react.children?\n\n> react.children 提供了用于处理 this.props.children 不透明数据结构的实用方法。\n\nchildren 指的就是组件中 props.children 的值。children 的类型通常是 reactnode。reactnode 是组件的渲染模板执行后的结果（classcomponent 中 render () 函数执行的结果或者 functioncomponent 执行的结果）。\n\n由此我们就可以知道为什么 reactchildren 需要使用工具函数来操作了，这是因为：\n\n * reactnode 不是数组，reactnode 的类型很复杂，不能用数组的方法进行遍历、map 等操作。\n * 需要相应的工具函数来提供操作 reactnode 的能力。\n\n言归正传，从 react 的导出看，react children 有如下四个方法：\n\n// 操作reactchildren的方法。reactchildren不是数组。模拟数组的一些方法。\n{ \n  map,\n  foreach,\n  count,\n  toarray,\n  only,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n下面我们来详细展开这几个函数的源码，了解其实现原理。\n\n\n# map\n\nmap 提供对 reactchildren 的遍历映射操作。\n\nmap 内部由 mapchildren 函数实现。mapchildren 内部调用 mapintoarray。\n\nfunction mapchildren(\n  children: ?reactnodelist,\n  func: mapfunc,\n  context: mixed,\n): ?array<react$node> {\n  if (children == null) {\n    return children;\n  }\n  const result = [];\n  let count = 0;\n  // 调用 mapintoarray 遍历 children，并在回调中调用 func，回调的结果放入 result\n  mapintoarray(children, result, '', '', function(child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这个 mapintoarray 比较复杂，它所支持的 children 的类型很多，基础类型包括 undefined、boolean、null、string、number 或者标记为 reactelement 或者 reactportal 的 object。如果把基础类型标记为 t 的话，mapintoarray 还支持 children 的类型为 t [] 或者迭代器 object。 后者是通过循环、迭代实现的，不再赘述，这里我们重点看基础类型。\n\nfunction mapintoarray(\n  children: ?reactnodelist,\n  array: array<react$node>,\n  escapedprefix: string,\n  namesofar: string,\n  callback: (?react$node) => ?reactnodelist,\n): number {\n  // 如果是 undefined、boolean、null、string、number、标记为 object 的 reactelement 或者 reactportal 等基础类型\n  // invokecallback 为 true，执行如下的逻辑\n  if (invokecallback) {\n    const child = children;\n    // 回调 callback\n    let mappedchild = callback(child);\n    // 当前层级的 key 的串\n    const childkey =\n      namesofar === '' ? separator + getelementkey(child, 0) : namesofar;\n    // 如果 map 返回是一个数组，则需要对数组继续递归\n    if (isarray(mappedchild)) {\n      // ......\n      // 这里的 callback 是 c => c，说明返回的数组将会被 flat\n      mapintoarray(mappedchild, array, escapedchildkey, '', c => c);\n    } else if (mappedchild != null) {\n      // 检查 mappedchild 是否是合法的 reactelement\n      if (isvalidelement(mappedchild)) {\n        // 规整 mappedchild 的 key 值\n        mappedchild = cloneandreplacekey(\n          mappedchild,\n          // 计算 mappedchild 的 key\n          escapedprefix +\n            (mappedchild.key && (!child || child.key !== mappedchild.key)\n              ? escapeuserprovidedkey('' + mappedchild.key) + '/'\n              : '') +\n            childkey,\n        );\n      }\n      // 将 mappedchild 推入结果数组\n      array.push(mappedchild);\n    }\n    // 返回 count 次数，即 callback 被调用的次数\n    return 1;\n  }\n\n  // ......\n\n  return subtreecount;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n总结一下如上的函数：\n\n * 主要运用了递归、循环、迭代的方法遍历 children，并且执行 callback，如果 callback 返回数组，则继续递归。注意，callback 返回的数组将会被摊平。这主要是因为在渲染节点的时候，节点的嵌套结构是由 reactelement.props.children 决定的，所有的多维节点数组对会被摊平。\n * 因为 map 的返回结果 result 是一个数组，因此其中的节点都需要设置唯一的 key 值。\n\n\n# foreach\n\nforeach 提供对 reactchildren 的遍历操作。\n\nforeach 是由 foreachchildren 实现的。有了上面 mapchildren 的基础，实现 foreach 就顺理成章了。\n\nfunction foreachchildren(\n  children: ?reactnodelist,\n  foreachfunc: foreachfunc,\n  foreachcontext: mixed,\n): void {\n  mapchildren(\n    children,\n    function() {\n      // arguments 表示接受 callback 回调的所有参数\n      foreachfunc.apply(this, arguments);\n    },\n    foreachcontext,\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nforeach 只需要在调用 map 时，舍弃 map 的返回值就可以了。\n\n\n# count\n\ncount 计算 children 中的组件总数量。\n\ncount 内部由 countchildren 实现的。思路是在遍历过程中计算长度，除非传的是数组或者迭代器，否则返回的长度都是 1。\n\nfunction countchildren(children: ?reactnodelist): number {\n  let n = 0;\n  mapchildren(children, () => {\n    n++;\n  });\n  return n;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# toarray\n\ntoarray 将 children 以数组形式返回。因为 mapchildren 的结果已经是数组了，所以直接返回。\n\nfunction toarray(children: ?reactnodelist): array<react$node> {\n  return mapchildren(children, child => child) || [];\n}\n\n\n1\n2\n3\n\n\n\n# only\n\nonly 验证 children 是否是单节点，如果是单节点将之返回，否则报错。\n\nonly 内部由 onlychild 实现。代码如下：\n\nfunction onlychild<t>(children: t): t {\n  if (!isvalidelement(children)) {\n    throw new error(\n      'react.children.only expected to receive a single react element child.',\n    );\n  }\n  return children;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# cloneelement\n\n\n# 应用\n\n在组件库等复杂的节点运用场景中常常会使用到 react.children 工具，而且通常会与其他的节点操作 api 如 cloneelement 或者 createelement 一起使用。下面以 antd 代码中 timeline 组件的一处使用场景作为示例：\n\n// components/timeline/timeline.tsx\n// 对 truthyitems 中的节点进行修改\nconst items = react.children.map(\n  truthyitems,\n  (ele: react.reactelement<any>, idx) => {\n    const pendingclass = idx === itemscount - 2 ? lastcls : \"\";\n    const readyclass = idx === itemscount - 1 ? lastcls : \"\";\n    // 克隆原节点并覆盖 classname 属性\n    return cloneelement(ele, {\n      classname: classnames([\n        ele.props.classname,\n        !reverse && !!pending ? pendingclass : readyclass,\n        getpositioncls(ele, idx),\n      ]),\n    });\n  }\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 扩展\n\n\n# childrenkey 是如何生成的？\n\n从 mapintoarray 中传递给 cloneandreplacekey 的 key 值的计算逻辑：\n\n// key = \nconst separator = '.';\nconst subseparator = ':';\n// 初始值为 ''，用于 mappedchild\nconst escapedprefix = escapeuserprovidedkey(childkey) + '/';\nconst nextnameprefix = namesofar === '' ? separator : namesofar + subseparator;\n// 初始值为 ''，用于数组和迭代器\nconst namesofar = nextnameprefix + getelementkey(child, i);\nconst childkey = namesofar === '' ? separator + getelementkey(child, 0) : namesofar;\nconst key = escapedprefix +\n            (mappedchild.key && (!child || child.key !== mappedchild.key) ? escapeuserprovidedkey('' + mappedchild.key) + '/' : '') +\n            childkey;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n分成如下几种情况：\n\n * 如果是 children 是普通类型，key1 = escapeuserprovidedkey (mappedchild.key) + '/' + separator + randomkey;\n * 如果是 mappedchild 数组下的 children，key2 = escapeuserprovidedkey (separator + randomkey + '/') + '/' + key1;\n * 如果是数组或者迭代器，key3 = escapeuserprovidedkey (mappedchild.key) + '/' + subseparator + randomkey;\n * 如果是数组或者迭代器下的 mappedchild 数组下的 children，key4 = escapeuserprovidedkey (subseparator + randomkey + '/') + '/' + key3;\n\n这里的逻辑比较复杂，我们只需要知道 mapintoarray 能够为结果数组中的节点生成唯一的 key 值即可。\n\n如何生成 randomkey？\n\nfunction getelementkey(element: any, index: number): string {\n  // 如果组件有 key 值则使用\n  if (typeof element === 'object' && element !== null && element.key != null) {\n    return escape('' + element.key);\n  }\n  // 使用 36 进制，即 0-9-a-z。如 (35).tostring(36) === 'z'\n  return index.tostring(36);\n}\n// 因为 key 中使用了固定的分隔符，所以用户传递的 key 需要 escape 做等意替换，并且添加前缀 `$`\nfunction escape(key: string): string {\n  const escaperegex = /[=:]/g;\n  const escaperlookup = {\n    '=': '=0',\n    ':': '=2',\n  };\n  const escapedstring = key.replace(escaperegex, function(match) {\n    return escaperlookup[match];\n  });\n\n  return '$' + escapedstring;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n通过 36 进制生成随机字符串是比较常见的一种生成 id、key 标识的方式。例如下面这个示例：\n\n// 生成一个随机小写字母或者数字\nconst genseed = () => (~~(math.random()*36)).tostring(36); // \"s\"\n\nfunction randomstringgenerator(length){\n   let s = '';\n   while(s.length < length) s += genseed();\n   return s;\n}\nrandomstringgenerator(6); // \"6muky\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# reactelement、jsx.element 和 reactnode 的区别\n\n要直观地理解三者的区别，需要我们从 react 的类型声明文件中去找答案。下面是一些类型：\n\ninterface reactelement<p = any, t extends string | jsxelementconstructor<any> = string | jsxelementconstructor<any>> {\n  type: t;\n  props: p;\n  key: key | null;\n}\ntype reacttext = string | number;\ntype reactchild = reactelement | reacttext;\ntype reactnode = reactchild | reactfragment | reactportal | boolean | null | undefined;\n\nnamespace jsx {\n  interface element extends react.reactelement<any, any> { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n从这些类型可以看出来，三者是具有包含关系的，其中 reactnode > jsx.element > reactelement 。\n\n * reactnode：reactnode 代表 react 节点，其类型中包含了 reactchild，reactchild 中又包含了 reactelement。\n * jsx.element：jsx.element 和 reactelement 基本一致，但是 jsx.element 作为 jsx 的规范，它比 reactnode 更加通用，因为 type 和 props 都被定义为 any。\n * reactelement：reactelement 是包含 type 、 props 、 key 等属性的 object，它是 dom 的一种抽象表示，是 functioncomponent （或者 classcomponent 中 render 函数）执行的结果。\n\n\n# 原版代码中的池化模式的应用\n\nreact 17 中对 reactchildren 中的代码进行了重构，在 react 16 的旧版代码中有一个对池化模式的应用，我觉得很有意思，作为扩展分享给大家。\n\n在源码中利用池化模式对 traversecontext 进行缓存，减少对象创建的成本。\n\n// traversecontextpool 的 size\nconst pool_size = 10;\nconst traversecontextpool = [];\n// 从 traversecontextpool 获取 traversecontext\nfunction getpooledtraversecontext(\n  mapresult, // 遍历结果数组\n  keyprefix, // traversecontext 的 key\n  mapfunction, // 遍历回调函数\n  mapcontext, // 遍历的 context\n) {\n  // 如果当前缓存池非空\n  if (traversecontextpool.length) {\n    // 取出队尾的traversecontext\n    const traversecontext = traversecontextpool.pop();\n    traversecontext.result = mapresult;\n    traversecontext.keyprefix = keyprefix;\n    traversecontext.func = mapfunction;\n    traversecontext.context = mapcontext;\n    traversecontext.count = 0;\n    // 返回缓存的 traversecontext\n    return traversecontext;\n  } else {\n    // 缓存池为空则新建一个 traversecontext，最多 10 个\n    return {\n      result: mapresult,\n      keyprefix: keyprefix,\n      func: mapfunction,\n      context: mapcontext,\n      count: 0,\n    };\n  }\n}\n// 释放 traversecontext 到 traversecontextpool\nfunction releasetraversecontext(traversecontext) {\n  traversecontext.result = null;\n  traversecontext.keyprefix = null;\n  traversecontext.func = null;\n  traversecontext.context = null;\n  traversecontext.count = 0;\n  if (traversecontextpool.length < pool_size) {\n    traversecontextpool.push(traversecontext);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n池化模式在需要频繁创建对象（连接）的场景中可以参考。缓存池大小 pool_size 需要权衡考虑效率和内存问题。如果 pool_size 太小，就不能很好的起到缓存的效果，如果太大缓存池本身就需要占用太多内存，而且用不完的 context 对象也容易造成浪费和低效。\n\n\n# 总结\n\n本篇文章包含了如下的核心知识点，总结如下：\n\n * reactnode、reactelement、reactchildren 等概念的深入理解。\n * react.children 工具函数：map,foreach,count,toarray,only 的原理。\n * 使用 reactchildren 工具函数应用到组件库等复杂场景中操作节点。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 14:56:40",lastUpdatedTimestamp:1658473e6},{title:"React 源码漂流记：React 整体结构和理念初认识",frontmatter:{title:"React 源码漂流记：React 整体结构和理念初认识",date:"2022-07-19T19:17:26.000Z",permalink:"/react/tour/react-basic-glimpse/",categories:["react","React源码漂流记"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/30.react-basic-view.html",relativePath:"10.react/90.React源码漂流记/30.react-basic-view.md",key:"v-ec07c126",path:"/react/tour/react-basic-glimpse/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:17},{level:2,title:"设计理念",slug:"设计理念",normalizedTitle:"设计理念",charIndex:23},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:31}],readingTime:{text:"1 min read",minutes:.165,time:9900,words:33},headersStr:"目录 前言 设计理念 参考",content:"# 目录\n\n\n\n * 目录\n * 前言\n * 设计理念\n * 参考\n\n\n\n\n# 前言\n\n\n# 设计理念\n\n\n# 参考\n\n * 通俗易懂的代数效应 — Overreacted\n * Algebraic Effects for Functional Programming\n * 代数效应的简单理解",normalizedContent:"# 目录\n\n\n\n * 目录\n * 前言\n * 设计理念\n * 参考\n\n\n\n\n# 前言\n\n\n# 设计理念\n\n\n# 参考\n\n * 通俗易懂的代数效应 — overreacted\n * algebraic effects for functional programming\n * 代数效应的简单理解",charsets:{cjk:!0},lastUpdated:"2022/08/24, 18:21:13",lastUpdatedTimestamp:1661336473e3},{title:"React 源码漂流记：React 调度器核心源码解读（一）",frontmatter:{title:"React 源码漂流记：React 调度器核心源码解读（一）",date:"2022-08-09T17:07:40.000Z",permalink:"/react/tour/react-scheduler-1/",categories:["react","React源码漂流记"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/300.react-scheduler-1.html",relativePath:"10.react/90.React源码漂流记/300.react-scheduler-1.md",key:"v-2d7c6c07",path:"/react/tour/react-scheduler-1/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2}],readingTime:{text:"1 min read",minutes:.075,time:4500,words:15},headersStr:"目录",content:"# 目录\n\n\n\n * 目录\n\n",normalizedContent:"# 目录\n\n\n\n * 目录\n\n",charsets:{cjk:!0},lastUpdated:"2022/08/09, 20:11:40",lastUpdatedTimestamp:16600471e5},{title:"React 源码漂流记：React 调和器核心源码解读（一）",frontmatter:{title:"React 源码漂流记：React 调和器核心源码解读（一）",date:"2022-04-14T22:02:21.000Z",permalink:"/react/tour/react-reconciliation-1/",categories:["react","React源码漂流记"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/90.react-reconciliation-1.html",relativePath:"10.react/90.React源码漂流记/90.react-reconciliation-1.md",key:"v-49f7f4ca",path:"/react/tour/react-reconciliation-1/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:17},{level:2,title:"updateContainer：星星之火，可以燎原",slug:"updatecontainer-星星之火-可以燎原",normalizedTitle:"updatecontainer：星星之火，可以燎原",charIndex:23},{level:2,title:"scheduleUpdateOnFiber：剥丝抽茧，追本溯源",slug:"scheduleupdateonfiber-剥丝抽茧-追本溯源",normalizedTitle:"scheduleupdateonfiber：剥丝抽茧，追本溯源",charIndex:52},{level:2,title:"ensureRootIsScheduled：一花开两叶，结果自然成",slug:"ensurerootisscheduled-一花开两叶-结果自然成",normalizedTitle:"ensurerootisscheduled：一花开两叶，结果自然成",charIndex:87},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:124},{level:3,title:"怎么理解 updateContainer 是“引擎“这件事？",slug:"怎么理解-updatecontainer-是-引擎-这件事",normalizedTitle:"怎么理解 updatecontainer 是 “引擎 “这件事？",charIndex:7130},{level:3,title:"scheduleMicrotask 与 queueMicrotask",slug:"schedulemicrotask-与-queuemicrotask",normalizedTitle:"schedulemicrotask 与 queuemicrotask",charIndex:168},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:206},{level:3,title:"位运算怎么理解？",slug:"位运算怎么理解",normalizedTitle:"位运算怎么理解？",charIndex:214},{level:3,title:"lanes 优先级怎么理解？",slug:"lanes-优先级怎么理解",normalizedTitle:"lanes 优先级怎么理解？",charIndex:228},{level:3,title:"FiberRoot 和 RootFiber 什么关系？",slug:"fiberroot-和-rootfiber-什么关系",normalizedTitle:"fiberroot 和 rootfiber 什么关系？",charIndex:248},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:279}],readingTime:{text:"5 min read",minutes:4.315,time:258900.00000000003,words:863},headersStr:"目录 前言 updateContainer：星星之火，可以燎原 scheduleUpdateOnFiber：剥丝抽茧，追本溯源 ensureRootIsScheduled：一花开两叶，结果自然成 扩展 怎么理解 updateContainer 是“引擎“这件事？ scheduleMicrotask 与 queueMicrotask 问题 位运算怎么理解？ lanes 优先级怎么理解？ FiberRoot 和 RootFiber 什么关系？ 总结",content:"# 目录\n\n\n\n * 目录\n * 前言\n * updateContainer：星星之火，可以燎原\n * scheduleUpdateOnFiber：剥丝抽茧，追本溯源\n * ensureRootIsScheduled：一花开两叶，结果自然成\n * 扩展\n   * 怎么理解 updateContainer 是“引擎“这件事？\n   * scheduleMicrotask 与 queueMicrotask\n * 问题\n   * 位运算怎么理解？\n   * lanes 优先级怎么理解？\n   * FiberRoot 和 RootFiber 什么关系？\n * 总结\n\n\n\n\n# 前言\n\n\n# updateContainer：星星之火，可以燎原\n\n> updateContainer 是燎原的第一颗火星。\n\n先看一段代码：\n\n// src/react/packages/react-reconciler/src/ReactFiberReconciler.new.js\nexport function updateContainer(\n  // 待挂载的组件\n  element: ReactNodeList,\n  // 挂载容器\n  container: OpaqueRoot,\n): Lane {\n  // 获取 RootFiber\n  const current = container.current;\n  const eventTime = requestEventTime();\n  const lane = requestUpdateLane(current);\n  // 更新 container 的 context 信息\n  const context = getContextForSubtree();\n  // 创建一个更新\n  const update = createUpdate(eventTime, lane);\n  // 将新建的更新入栈\n  enqueueUpdate(current, update, lane);\n  // 请求一次调度更新\n  const root = scheduleUpdateOnFiber(current, lane, eventTime);\n\n  return lane;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n如果你调试过 React 的首次更新过程，你会知道 React 会走到这里。如果你往前追溯 updateContainer 的调用链条，你会发现这些调度都来自于应用层 API。首次渲染是一次同步渲染，通过 updateContainer 这个函数，创建第一个 update 对象，将首个 update 对象入队列，发起首次调度。可以说，这里是 React 引擎的点火器。\n\n总结一下 updateContainer 核心功能：\n\n * 初始化创建一个更新对象，并且将更新加入更新队列。\n * 调用 scheduleUpdateOnFiber，(向调度器) 发出一次调度的请求。【注：向调度器有些不妥，因为同步任务一般不会经过调度器，这里暂且这么表述，便于理解】\n\n\n# scheduleUpdateOnFiber：剥丝抽茧，追本溯源\n\n> scheduleUpdateOnFiber 从 FiberTree 的枝繁叶茂中找到了当初的那枚种子。\n\n在 updateContainer 中，调用了 scheduleUpdateOnFiber 以在 fiber（此处指的是 RootFiber） 上调度一次更新，那么调度更新是如何在 fiber 上展开的呢？\n\n首先来分析一下代码：\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nlet workInProgressRootRenderPhaseUpdatedLanes: Lanes = NoLanes;\n\nexport function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {\n  return a | b;\n}\n\nexport function scheduleUpdateOnFiber(\n  //  RootFiber\n  fiber: Fiber,\n  // 调度优先级\n  lane: Lane,\n  eventTime: number,\n): FiberRoot | null {\n  // 检查嵌套更新，防止死循环\n  checkForNestedUpdates();\n  // 从 fiber 向上收集 lanes，root：FiberRoot = fiber.stateNode。对于 updateContainer 来说，这里 fiber 就是 RootFiber。\n  const root = markUpdateLaneFromFiberToRoot(fiber, lane);\n\n  // 标记 root 即将更新，root.pendingLanes |= lane\n  markRootUpdated(root, lane, eventTime);\n  // 如果当前已经是 Render 阶段，且 root 是待处理的 FiberRoot，这时跳过渲染的调度请求，并且追踪 lane，加入到 Render 阶段的 lanes，就在在当前调度的回调中参与渲染，或者等待下次渲染。\n  if (\n    (executionContext & RenderContext) !== NoLanes &&\n    root === workInProgressRoot\n  ) {\n    // 收集当前的 lane 到 workInProgressRootRenderPhaseUpdatedLanes，表示在当前 render 中当前正在渲染的 RootFiber 上的优先级队列。\n    workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(\n      workInProgressRootRenderPhaseUpdatedLanes,\n      lane,\n    );\n  } else {\n    // 确保 FiberRoot 发起调度请求\n    ensureRootIsScheduled(root, eventTime);\n  }\n  return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n关注入参的伙伴可能已经发现，这里传入的是 fiber，返回的和传递给 ensureRootIsScheduled 函数的却是 root。root 是 FiberRoot，并不是 Fiber。可以把 FiberRoot 理解为 FiberTree 的容器。FiberRoot 与 RootFiber 双向索引。之后会详细展开。\n\nmarkUpdateLaneFromFiberToRoot 向上收集优先级的同时寻找到了 FiberRoot 容器，因为渲染任务的调度是依托于容器的，而非 RootFiber。这个过程更像是一个抽丝剥茧的过程，root 才是被调度的目标。\n\n这个函数的核心功能如下：\n\n * 从 fiber 向父级收集 lanes，并且计算出 FiberRoot。\n * 调用 ensureRootIsScheduled，确保 FiberRoot 发起同步或者异步调度。\n\n\n# ensureRootIsScheduled：一花开两叶，结果自然成\n\n> ensureRootIsScheduled 是封装调度任务的双线流水车间。\n\n在上面对 scheduleUpdateOnFiber 的分析中，最重要的就是调用 ensureRootIsScheduled，以保证在 fiber 所在的 FiberRoot 上调度更新，那么 FiberRoot 上是如何继续调度的呢？继续来看代码。\n\n// src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\n  // 在本次调度之前的当前的记录的回调节点\n  const existingCallbackNode = root.callbackNode;\n\n  // 计算将要渲染的 lanes\n  const nextLanes = getNextLanes(\n    root,\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\n  );\n  // 无需要渲染的 lanes，直接重置退出\n  if (nextLanes === NoLanes) {\n    root.callbackNode = null;\n    root.callbackPriority = NoLane;\n    return;\n  }\n\n  // 获取 lanes 中优先级最高的 lane 作为本次调度的优先级\n  const newCallbackPriority = getHighestPriorityLane(nextLanes);\n\n  // 由于即将要生成新的调度，先将现在的调度节点上的回调取消掉\n  if (existingCallbackNode != null) {\n    cancelCallback(existingCallbackNode);\n  }\n\n  // 设置一个新的回调节点\n  let newCallbackNode;\n  // 如果是同步更新任务\n  if (newCallbackPriority === SyncLane) {\n      // 请求同步调度回调 performSyncWorkOnRoot，将该回调加入同步回调队列\n      scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n    if (supportsMicrotasks) {\n     // 支持微任务的浏览器不用再请求调度器的回调\n     scheduleMicrotask(() => {\n       if (executionContext === NoContext) {\n         // 消费完同步回调队列\n         flushSyncCallbacks();\n       }\n     });\n    } else {\n      // 不支持微任务则向调度器请求回调，优先级 ImmediatePriority（立即回调），回调后执行 flushSyncCallbacks 将同步回调队列消费完\n      scheduleCallback(ImmediateSchedulerPriority, flushSyncCallbacks);\n    }\n    // 同步更新执行完毕，将 newCallbackNode 置为 null，performSyncWorkOnRoot 不会用到此值\n    newCallbackNode = null;\n  } else {\n    let schedulerPriorityLevel;\n    // 将 lanes 转化为事件优先级，然后将事件优先级转化为调度优先级\n    switch (lanesToEventPriority(nextLanes)) {\n      // 离散事件优先级：ImmediateSchedulerPriority\n      case DiscreteEventPriority:\n        schedulerPriorityLevel = ImmediateSchedulerPriority;\n        break;\n      // 连续事件优先级：UserBlockingSchedulerPriority\n      case ContinuousEventPriority:\n        schedulerPriorityLevel = UserBlockingSchedulerPriority;\n        break;\n      // 默认事件优先级：NormalSchedulerPriority\n      case DefaultEventPriority:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n      // Idle 事件优先级：IdleSchedulerPriority\n      case IdleEventPriority:\n        schedulerPriorityLevel = IdleSchedulerPriority;\n        break;\n      default:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n    }\n    // 向调度器请求相应优先级的异步回调【也可能是立即执行的优先级】，回调后执行 performConcurrentWorkOnRoot，Scheduler.scheduleCallback 返回调度的 callbackNode(newTask)\n    newCallbackNode = scheduleCallback(\n      schedulerPriorityLevel,\n      performConcurrentWorkOnRoot.bind(null, root),\n    );\n  }\n  // 更新 callbackPriority 和 callbackNode 注意，此时只是发起调度，回调并未执行\n  root.callbackPriority = newCallbackPriority;\n  root.callbackNode = newCallbackNode;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\nensureRootIsScheduled 将 FiberRoot 上的调度任务区分为同步任务和异步任务。\n\n这个函数有以下几个核心作用：\n\n * 更新 root 的 callbackNode、callbackPriority 属性。下次 ensureRootIsScheduled 被调用会使用到。\n * 同步更新调度：调用 scheduleSyncCallback 将同步回调 performSyncWorkOnRoot 推入同步回调队列 syncQueue；支持微任务的直接在微任务的回调执行 flushSyncCallbacks；不支持微任务时以 ImmediateSchedulerPriority 的优先级向调度器请求同步回调，回调时执行 flushSyncCallbacks 消费同步队列中所有的同步回调。\n * 异步更新调度：根据 nextLanes 计算事件优先级，并且转化为调度优先级，以相应的调度优先级向调度器发起异步回调，回调时执行 performConcurrentWorkOnRoot。\n * 注意同步调度中调用了 scheduleSyncCallback、scheduleCallback 两个函数不可混淆，scheduleCallback 是 Scheduler 提供的一种基于优先级机制的任务（回调）调度手段，performSyncWorkOnRoot 和 performConcurrentWorkOnRoot 才是真正要通过调度执行的任务。同步的任务通过同步回调队列的方式进行了优化处理。scheduleSyncCallback 是将同步的任务加入同步任务队列。调度器不是不可缺少的，如果浏览器支持微任务，同步任务的处理就可以交给微任务处理，而不经过调度器。\n\n\n# 扩展\n\n\n# 怎么理解 updateContainer 是 “引擎 “这件事？\n\n我们可以从 updateContainer 的调用来源来展开下。\n\n调用 updateContainer 的函数包括： legacyRenderSubtreeIntoContainer、ReactDOMRoot.prototype.render、ReactDOMRoot.prototype.unmount、hydrateRoot、scheduleRoot。ReactDOMRoot 是由 ReactDOM.createRoot 创建的。\n\n// 应用层 API\nlegacyRenderSubtreeIntoContainer <- ReactDOM.hydrate\n                                 <- ReactDOM.render\n                                 <- ReactDOM.unmountComponentAtNode\n\n\n1\n2\n3\n4\n\n\n由上面对函数调用链的分析可以看出，updateContainer 主要来源于应用层 API 的调用，加上 updateContainer 跟 scheduleUpdateOnFiber 的关系，可以看出 updateContainer 确实是针对 container 这个容器上的调度更新的入口而存在的，而这个 container，就是 FiberRoot。\n\n\n# scheduleMicrotask 与 queueMicrotask\n\n上文我们已经了解到支持微任务的浏览器会使用微任务的形式消费完（flush）同步任务队列，那么这个微任务是什么呢？下面来展开一下 scheduleMicrotask 的代码：\n\nconst localPromise = typeof Promise === 'function' ? Promise : undefined;\nexport const scheduleTimeout: any =\n  typeof setTimeout === 'function' ? setTimeout : (undefined: any);\n\nexport const scheduleMicrotask: any =\n  typeof queueMicrotask === 'function'\n    ? queueMicrotask\n    : typeof localPromise !== 'undefined'\n    ? callback =>\n        localPromise\n          .resolve(null)\n          .then(callback)\n          .catch(handleErrorInNextTick)\n    : scheduleTimeout;\n\nfunction handleErrorInNextTick(error) {\n  // 非阻塞式抛出异常\n  setTimeout(() => {\n    throw error;\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n什么是 queueMicrotask？\n\n> queueMicrotask adds the function (task) into a queue and each function is executed one by one (FIFO) after the current task has completed its work and when there is no other code waiting to be run before control of the execution context is returned to the browser's event loop.【来自 MDN】\n\n微任务使用 queueMicrotask，同时 queueMicrotask 可以由 Promise 来模拟，或者使用 setTimeout 优雅替代。\n\n\n# 问题\n\n\n# 位运算怎么理解？\n\n关于 react 中常见的位运算，在之后的文章中会单独详解。本文主要用到 | 运算，按位或运算的规则是：两个位都为 0 时，结果才为 0。在这里举出一个例子，方便大家对文章的 |= 进行理解：\n\nconst NoContext = 0b0000;\nconst BatchedContext =  0b0001; \nconst RenderContext =  0b0010;\n\nlet executionContext = NoContext;\n\n// 如果现在开始 RenderContainer，进入 Batch 阶段\n// 增加枚举值\nexecutionContext |= BatchedContext; // 1\n\n// 判断是否在 Batch 阶段\n// 消费枚举值：0 表示没有枚举值，1 表示有枚举值。这里我们直接跟为 0 的 NoContext 作比较。\n(executionContext & BatchedContext) !== NoContext; // true\n// 判断是否处于 Render 阶段\n(executionContext & RenderContext) !== NoContext; // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# lanes 优先级怎么理解？\n\nReact 中需要基于优先级的调度机制以区分不同渲染任务的轻重缓急，在 v16 版本的 React 中还是使用 expirationTime 来管理优先级，在 v17 的版本中则采用了 lane 模型，相比于 expirationTime 模型，lane 模型有着更为细粒度、效率更高的特性。关于调度与优先级的内容，之后的文章会详述。\n\n\n# FiberRoot 和 RootFiber 什么关系？\n\n在本文中反复提到了 FiberRoot 和 RootFiber（HostRoot），关于两者的区别如下：\n\n * FiberRoot 和 RootFiber 具有双向链接关系。FiberRoot.current = RootFiber，RootFiber.stateNode = FiberRoot。\n * FiberRoot 是 FiberTree 的容器，记录 FiberTree 在渲染过程中的数据。\n * RootFiber 本质上是 Fiber，是 FiberTree 的根节点，是特殊的 Fiber。\n * HostRoot 也就是 HostRootFiber，RootFiber 被标记为 HostRoot。\n\n在之后的文章中会详述 Fiber、RootFiber 和 FiberRoot、以及 FiberTree 的结构。\n\n\n# 总结\n\n总结一下本文的内容：\n\n * updateContainer：初始化更新任务，调用 scheduleUpdateOnFiber 发出调度请求。\n * scheduleUpdateOnFiber：收集优先级，计算 FiberRoot。调用 ensureRootIsScheduled，确保 FiberRoot 发起同步或者异步调度。\n * ensureRootIsScheduled：包装同步更新任务和异步更新任务并采用不同的调度策略。同步更新任务入同步任务队列在微任务中执行，异步更新任务交给调度器进行调度与回调。",normalizedContent:"# 目录\n\n\n\n * 目录\n * 前言\n * updatecontainer：星星之火，可以燎原\n * scheduleupdateonfiber：剥丝抽茧，追本溯源\n * ensurerootisscheduled：一花开两叶，结果自然成\n * 扩展\n   * 怎么理解 updatecontainer 是“引擎“这件事？\n   * schedulemicrotask 与 queuemicrotask\n * 问题\n   * 位运算怎么理解？\n   * lanes 优先级怎么理解？\n   * fiberroot 和 rootfiber 什么关系？\n * 总结\n\n\n\n\n# 前言\n\n\n# updatecontainer：星星之火，可以燎原\n\n> updatecontainer 是燎原的第一颗火星。\n\n先看一段代码：\n\n// src/react/packages/react-reconciler/src/reactfiberreconciler.new.js\nexport function updatecontainer(\n  // 待挂载的组件\n  element: reactnodelist,\n  // 挂载容器\n  container: opaqueroot,\n): lane {\n  // 获取 rootfiber\n  const current = container.current;\n  const eventtime = requesteventtime();\n  const lane = requestupdatelane(current);\n  // 更新 container 的 context 信息\n  const context = getcontextforsubtree();\n  // 创建一个更新\n  const update = createupdate(eventtime, lane);\n  // 将新建的更新入栈\n  enqueueupdate(current, update, lane);\n  // 请求一次调度更新\n  const root = scheduleupdateonfiber(current, lane, eventtime);\n\n  return lane;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n如果你调试过 react 的首次更新过程，你会知道 react 会走到这里。如果你往前追溯 updatecontainer 的调用链条，你会发现这些调度都来自于应用层 api。首次渲染是一次同步渲染，通过 updatecontainer 这个函数，创建第一个 update 对象，将首个 update 对象入队列，发起首次调度。可以说，这里是 react 引擎的点火器。\n\n总结一下 updatecontainer 核心功能：\n\n * 初始化创建一个更新对象，并且将更新加入更新队列。\n * 调用 scheduleupdateonfiber，(向调度器) 发出一次调度的请求。【注：向调度器有些不妥，因为同步任务一般不会经过调度器，这里暂且这么表述，便于理解】\n\n\n# scheduleupdateonfiber：剥丝抽茧，追本溯源\n\n> scheduleupdateonfiber 从 fibertree 的枝繁叶茂中找到了当初的那枚种子。\n\n在 updatecontainer 中，调用了 scheduleupdateonfiber 以在 fiber（此处指的是 rootfiber） 上调度一次更新，那么调度更新是如何在 fiber 上展开的呢？\n\n首先来分析一下代码：\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nlet workinprogressrootrenderphaseupdatedlanes: lanes = nolanes;\n\nexport function mergelanes(a: lanes | lane, b: lanes | lane): lanes {\n  return a | b;\n}\n\nexport function scheduleupdateonfiber(\n  //  rootfiber\n  fiber: fiber,\n  // 调度优先级\n  lane: lane,\n  eventtime: number,\n): fiberroot | null {\n  // 检查嵌套更新，防止死循环\n  checkfornestedupdates();\n  // 从 fiber 向上收集 lanes，root：fiberroot = fiber.statenode。对于 updatecontainer 来说，这里 fiber 就是 rootfiber。\n  const root = markupdatelanefromfibertoroot(fiber, lane);\n\n  // 标记 root 即将更新，root.pendinglanes |= lane\n  markrootupdated(root, lane, eventtime);\n  // 如果当前已经是 render 阶段，且 root 是待处理的 fiberroot，这时跳过渲染的调度请求，并且追踪 lane，加入到 render 阶段的 lanes，就在在当前调度的回调中参与渲染，或者等待下次渲染。\n  if (\n    (executioncontext & rendercontext) !== nolanes &&\n    root === workinprogressroot\n  ) {\n    // 收集当前的 lane 到 workinprogressrootrenderphaseupdatedlanes，表示在当前 render 中当前正在渲染的 rootfiber 上的优先级队列。\n    workinprogressrootrenderphaseupdatedlanes = mergelanes(\n      workinprogressrootrenderphaseupdatedlanes,\n      lane,\n    );\n  } else {\n    // 确保 fiberroot 发起调度请求\n    ensurerootisscheduled(root, eventtime);\n  }\n  return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n关注入参的伙伴可能已经发现，这里传入的是 fiber，返回的和传递给 ensurerootisscheduled 函数的却是 root。root 是 fiberroot，并不是 fiber。可以把 fiberroot 理解为 fibertree 的容器。fiberroot 与 rootfiber 双向索引。之后会详细展开。\n\nmarkupdatelanefromfibertoroot 向上收集优先级的同时寻找到了 fiberroot 容器，因为渲染任务的调度是依托于容器的，而非 rootfiber。这个过程更像是一个抽丝剥茧的过程，root 才是被调度的目标。\n\n这个函数的核心功能如下：\n\n * 从 fiber 向父级收集 lanes，并且计算出 fiberroot。\n * 调用 ensurerootisscheduled，确保 fiberroot 发起同步或者异步调度。\n\n\n# ensurerootisscheduled：一花开两叶，结果自然成\n\n> ensurerootisscheduled 是封装调度任务的双线流水车间。\n\n在上面对 scheduleupdateonfiber 的分析中，最重要的就是调用 ensurerootisscheduled，以保证在 fiber 所在的 fiberroot 上调度更新，那么 fiberroot 上是如何继续调度的呢？继续来看代码。\n\n// src/react/packages/react-reconciler/src/reactfiberworkloop.new.js\nfunction ensurerootisscheduled(root: fiberroot, currenttime: number) {\n  // 在本次调度之前的当前的记录的回调节点\n  const existingcallbacknode = root.callbacknode;\n\n  // 计算将要渲染的 lanes\n  const nextlanes = getnextlanes(\n    root,\n    root === workinprogressroot ? workinprogressrootrenderlanes : nolanes,\n  );\n  // 无需要渲染的 lanes，直接重置退出\n  if (nextlanes === nolanes) {\n    root.callbacknode = null;\n    root.callbackpriority = nolane;\n    return;\n  }\n\n  // 获取 lanes 中优先级最高的 lane 作为本次调度的优先级\n  const newcallbackpriority = gethighestprioritylane(nextlanes);\n\n  // 由于即将要生成新的调度，先将现在的调度节点上的回调取消掉\n  if (existingcallbacknode != null) {\n    cancelcallback(existingcallbacknode);\n  }\n\n  // 设置一个新的回调节点\n  let newcallbacknode;\n  // 如果是同步更新任务\n  if (newcallbackpriority === synclane) {\n      // 请求同步调度回调 performsyncworkonroot，将该回调加入同步回调队列\n      schedulesynccallback(performsyncworkonroot.bind(null, root));\n    if (supportsmicrotasks) {\n     // 支持微任务的浏览器不用再请求调度器的回调\n     schedulemicrotask(() => {\n       if (executioncontext === nocontext) {\n         // 消费完同步回调队列\n         flushsynccallbacks();\n       }\n     });\n    } else {\n      // 不支持微任务则向调度器请求回调，优先级 immediatepriority（立即回调），回调后执行 flushsynccallbacks 将同步回调队列消费完\n      schedulecallback(immediateschedulerpriority, flushsynccallbacks);\n    }\n    // 同步更新执行完毕，将 newcallbacknode 置为 null，performsyncworkonroot 不会用到此值\n    newcallbacknode = null;\n  } else {\n    let schedulerprioritylevel;\n    // 将 lanes 转化为事件优先级，然后将事件优先级转化为调度优先级\n    switch (lanestoeventpriority(nextlanes)) {\n      // 离散事件优先级：immediateschedulerpriority\n      case discreteeventpriority:\n        schedulerprioritylevel = immediateschedulerpriority;\n        break;\n      // 连续事件优先级：userblockingschedulerpriority\n      case continuouseventpriority:\n        schedulerprioritylevel = userblockingschedulerpriority;\n        break;\n      // 默认事件优先级：normalschedulerpriority\n      case defaulteventpriority:\n        schedulerprioritylevel = normalschedulerpriority;\n        break;\n      // idle 事件优先级：idleschedulerpriority\n      case idleeventpriority:\n        schedulerprioritylevel = idleschedulerpriority;\n        break;\n      default:\n        schedulerprioritylevel = normalschedulerpriority;\n        break;\n    }\n    // 向调度器请求相应优先级的异步回调【也可能是立即执行的优先级】，回调后执行 performconcurrentworkonroot，scheduler.schedulecallback 返回调度的 callbacknode(newtask)\n    newcallbacknode = schedulecallback(\n      schedulerprioritylevel,\n      performconcurrentworkonroot.bind(null, root),\n    );\n  }\n  // 更新 callbackpriority 和 callbacknode 注意，此时只是发起调度，回调并未执行\n  root.callbackpriority = newcallbackpriority;\n  root.callbacknode = newcallbacknode;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\nensurerootisscheduled 将 fiberroot 上的调度任务区分为同步任务和异步任务。\n\n这个函数有以下几个核心作用：\n\n * 更新 root 的 callbacknode、callbackpriority 属性。下次 ensurerootisscheduled 被调用会使用到。\n * 同步更新调度：调用 schedulesynccallback 将同步回调 performsyncworkonroot 推入同步回调队列 syncqueue；支持微任务的直接在微任务的回调执行 flushsynccallbacks；不支持微任务时以 immediateschedulerpriority 的优先级向调度器请求同步回调，回调时执行 flushsynccallbacks 消费同步队列中所有的同步回调。\n * 异步更新调度：根据 nextlanes 计算事件优先级，并且转化为调度优先级，以相应的调度优先级向调度器发起异步回调，回调时执行 performconcurrentworkonroot。\n * 注意同步调度中调用了 schedulesynccallback、schedulecallback 两个函数不可混淆，schedulecallback 是 scheduler 提供的一种基于优先级机制的任务（回调）调度手段，performsyncworkonroot 和 performconcurrentworkonroot 才是真正要通过调度执行的任务。同步的任务通过同步回调队列的方式进行了优化处理。schedulesynccallback 是将同步的任务加入同步任务队列。调度器不是不可缺少的，如果浏览器支持微任务，同步任务的处理就可以交给微任务处理，而不经过调度器。\n\n\n# 扩展\n\n\n# 怎么理解 updatecontainer 是 “引擎 “这件事？\n\n我们可以从 updatecontainer 的调用来源来展开下。\n\n调用 updatecontainer 的函数包括： legacyrendersubtreeintocontainer、reactdomroot.prototype.render、reactdomroot.prototype.unmount、hydrateroot、scheduleroot。reactdomroot 是由 reactdom.createroot 创建的。\n\n// 应用层 api\nlegacyrendersubtreeintocontainer <- reactdom.hydrate\n                                 <- reactdom.render\n                                 <- reactdom.unmountcomponentatnode\n\n\n1\n2\n3\n4\n\n\n由上面对函数调用链的分析可以看出，updatecontainer 主要来源于应用层 api 的调用，加上 updatecontainer 跟 scheduleupdateonfiber 的关系，可以看出 updatecontainer 确实是针对 container 这个容器上的调度更新的入口而存在的，而这个 container，就是 fiberroot。\n\n\n# schedulemicrotask 与 queuemicrotask\n\n上文我们已经了解到支持微任务的浏览器会使用微任务的形式消费完（flush）同步任务队列，那么这个微任务是什么呢？下面来展开一下 schedulemicrotask 的代码：\n\nconst localpromise = typeof promise === 'function' ? promise : undefined;\nexport const scheduletimeout: any =\n  typeof settimeout === 'function' ? settimeout : (undefined: any);\n\nexport const schedulemicrotask: any =\n  typeof queuemicrotask === 'function'\n    ? queuemicrotask\n    : typeof localpromise !== 'undefined'\n    ? callback =>\n        localpromise\n          .resolve(null)\n          .then(callback)\n          .catch(handleerrorinnexttick)\n    : scheduletimeout;\n\nfunction handleerrorinnexttick(error) {\n  // 非阻塞式抛出异常\n  settimeout(() => {\n    throw error;\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n什么是 queuemicrotask？\n\n> queuemicrotask adds the function (task) into a queue and each function is executed one by one (fifo) after the current task has completed its work and when there is no other code waiting to be run before control of the execution context is returned to the browser's event loop.【来自 mdn】\n\n微任务使用 queuemicrotask，同时 queuemicrotask 可以由 promise 来模拟，或者使用 settimeout 优雅替代。\n\n\n# 问题\n\n\n# 位运算怎么理解？\n\n关于 react 中常见的位运算，在之后的文章中会单独详解。本文主要用到 | 运算，按位或运算的规则是：两个位都为 0 时，结果才为 0。在这里举出一个例子，方便大家对文章的 |= 进行理解：\n\nconst nocontext = 0b0000;\nconst batchedcontext =  0b0001; \nconst rendercontext =  0b0010;\n\nlet executioncontext = nocontext;\n\n// 如果现在开始 rendercontainer，进入 batch 阶段\n// 增加枚举值\nexecutioncontext |= batchedcontext; // 1\n\n// 判断是否在 batch 阶段\n// 消费枚举值：0 表示没有枚举值，1 表示有枚举值。这里我们直接跟为 0 的 nocontext 作比较。\n(executioncontext & batchedcontext) !== nocontext; // true\n// 判断是否处于 render 阶段\n(executioncontext & rendercontext) !== nocontext; // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# lanes 优先级怎么理解？\n\nreact 中需要基于优先级的调度机制以区分不同渲染任务的轻重缓急，在 v16 版本的 react 中还是使用 expirationtime 来管理优先级，在 v17 的版本中则采用了 lane 模型，相比于 expirationtime 模型，lane 模型有着更为细粒度、效率更高的特性。关于调度与优先级的内容，之后的文章会详述。\n\n\n# fiberroot 和 rootfiber 什么关系？\n\n在本文中反复提到了 fiberroot 和 rootfiber（hostroot），关于两者的区别如下：\n\n * fiberroot 和 rootfiber 具有双向链接关系。fiberroot.current = rootfiber，rootfiber.statenode = fiberroot。\n * fiberroot 是 fibertree 的容器，记录 fibertree 在渲染过程中的数据。\n * rootfiber 本质上是 fiber，是 fibertree 的根节点，是特殊的 fiber。\n * hostroot 也就是 hostrootfiber，rootfiber 被标记为 hostroot。\n\n在之后的文章中会详述 fiber、rootfiber 和 fiberroot、以及 fibertree 的结构。\n\n\n# 总结\n\n总结一下本文的内容：\n\n * updatecontainer：初始化更新任务，调用 scheduleupdateonfiber 发出调度请求。\n * scheduleupdateonfiber：收集优先级，计算 fiberroot。调用 ensurerootisscheduled，确保 fiberroot 发起同步或者异步调度。\n * ensurerootisscheduled：包装同步更新任务和异步更新任务并采用不同的调度策略。同步更新任务入同步任务队列在微任务中执行，异步更新任务交给调度器进行调度与回调。",charsets:{cjk:!0},lastUpdated:"2022/07/22, 14:56:40",lastUpdatedTimestamp:1658473e6},{title:"带着原理重读 React 官方文档（一）",frontmatter:{title:"带着原理重读 React 官方文档（一）",date:"2022-08-23T09:55:52.000Z",permalink:"/react/tour/dr-1/",categories:["react","React源码漂流记"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/900.react-docs-reading-1.html",relativePath:"10.react/90.React源码漂流记/900.react-docs-reading-1.md",key:"v-321a8dff",path:"/react/tour/dr-1/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"React 不是一个 MVC 框架",slug:"react-不是一个-mvc-框架",normalizedTitle:"react 不是一个 mvc 框架",charIndex:261},{level:3,title:"React 并不是一个 MVC 框架",slug:"react-并不是一个-mvc-框架",normalizedTitle:"react 并不是一个 mvc 框架",charIndex:528},{level:3,title:"React 也不是一个 MVVM 框架",slug:"react-也不是一个-mvvm-框架",normalizedTitle:"react 也不是一个 mvvm 框架",charIndex:659},{level:3,title:"React 创建呈现随时间变化数据的组件",slug:"react-创建呈现随时间变化数据的组件",normalizedTitle:"react 创建呈现随时间变化数据的组件",charIndex:1569},{level:3,title:"基于属性和状态的单向数据流的模型",slug:"基于属性和状态的单向数据流的模型",normalizedTitle:"基于属性和状态的单向数据流的模型",charIndex:1613},{level:3,title:"“寓动于静”的组件编写原则",slug:"寓动于静-的组件编写原则",normalizedTitle:"“寓动于静” 的组件编写原则",charIndex:3231},{level:4,title:"“万宗归静”",slug:"万宗归静",normalizedTitle:"“万宗归静”",charIndex:3283},{level:4,title:"“择机而动”",slug:"择机而动",normalizedTitle:"“择机而动”",charIndex:5068},{level:2,title:"React 为什么使用 JSX？",slug:"react-为什么使用-jsx",normalizedTitle:"react 为什么使用 jsx？",charIndex:6553},{level:3,title:"构建 UI",slug:"构建-ui",normalizedTitle:"构建 ui",charIndex:6574},{level:3,title:"渲染逻辑本质上与 UI 逻辑内在耦合",slug:"渲染逻辑本质上与-ui-逻辑内在耦合",normalizedTitle:"渲染逻辑本质上与 ui 逻辑内在耦合",charIndex:7030},{level:2,title:"Inline Functions",slug:"inline-functions",normalizedTitle:"inline functions",charIndex:7759},{level:2,title:"React 如何解释响应式更新？",slug:"react-如何解释响应式更新",normalizedTitle:"react 如何解释响应式更新？",charIndex:10101},{level:2,title:"JSX 中 XSS 处理",slug:"jsx-中-xss-处理",normalizedTitle:"jsx 中 xss 处理",charIndex:11076},{level:2,title:"ReactElement 与 DOM Element",slug:"reactelement-与-dom-element",normalizedTitle:"reactelement 与 dom element",charIndex:12229},{level:2,title:"React 元素是不可变对象",slug:"react-元素是不可变对象",normalizedTitle:"react 元素是不可变对象",charIndex:12763},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:9792}],readingTime:{text:"6 min read",minutes:5.53,time:331800,words:1106},headersStr:"前言 React 不是一个 MVC 框架 React 并不是一个 MVC 框架 React 也不是一个 MVVM 框架 React 创建呈现随时间变化数据的组件 基于属性和状态的单向数据流的模型 “寓动于静”的组件编写原则 “万宗归静” “择机而动” React 为什么使用 JSX？ 构建 UI 渲染逻辑本质上与 UI 逻辑内在耦合 Inline Functions React 如何解释响应式更新？ JSX 中 XSS 处理 ReactElement 与 DOM Element React 元素是不可变对象 参考",content:'# 前言\n\n带着原理重读 React 官方文档 系列文章并不是一个关注原理细节的文章系列，而是作为一个描述想法、思想和设计哲学的文章系列。在这里不会有太多的代码，但是会有大量的文字。\n\n本质上这个系列是对 React 官方文档的重温，从原理的角度去体会文档中的一些有价值的、可能会被大家所忽略的内容而细细嚼之。至此，文章难免有部分冗长无味、肆意扩展的部分。\n\n其实，我并非怀着正经技术文章的心态去写这个系列，而是想到何处便写到何处，写到尽兴为止。无论您是细读之，还是作为茶余饭后的消遣，我认为都无大碍。瑾以记之。\n\n\n# React 不是一个 MVC 框架\n\n原文\n\nReact 不是一个 MVC 框架。\n\nReact 是一个用于构建可组合用户界面的库。 它鼓励创建那些用于呈现随时间变化数据的、可复用的 UI 组件。\n\nReact is a library for building composable user interfaces. It encourages the creation of reusable UI components which present data that changes over time.\n\n参见：原文\n\n\n# React 并不是一个 MVC 框架\n\nReact 不存在所谓的 Controller 的概念，并非由 MVC 的架构思想所驱动。React 的目的是构建可组合用户界面，于视图库而言，MVC 并不适合，因为 Controller 并不具备响应式的特征。\n\n\n# React 也不是一个 MVVM 框架\n\nMVVM 与 MVC 最明显的区别是 VM 的概念，VM 即 ViewModel，是 View 和 Model 沟通的桥梁，既然是桥梁，必然具有重要的连接作用，也即是双向绑定。双向绑定是 MVVM 最大的特征，它体现一种双向数据流的思想，即数据的变化通过 ViewModel 的连接作用影响到视图，视图的变化反过来又会通过 ViewModel 的连接作用影响到数据。这种双向绑定的过程，即是所谓的响应性。\n\n双向绑定的特征要求 ViewModel 应该是可观测的、可响应的，即具有响应性。实现响应性的方法有很多，最简单的方式就是通过代理，可通过代理的方式观测和控制 ViewModel 内部发生的变化，对数据的流出和流入做一定的拦截和控制。这个道理也很简单，如果把数据看作是流水的话，若需要对水量进行观测和控制的话，我们只需要使用一个蓄水池并且使水流的流入和流水使用单独的通道，然后对水流的流入和流出进行流量和流速的观测即可。比如 Vue2 的响应式是通过 Object. defineProperty 实现的，vue3 的响应式是通过 Proxy API 实现的。所使用的 API 不同，无非是 API 实现的进步，但是万变不离其宗，其本质还是 “代理（Proxy）” 的思想。其实，如果细究起来，Vue 对于 MVVM 的应用也只是广义上的应用，因为 Model 在狭义上指的是 ORM 的模型，此为后端的概念，显然对于视图框架而言，“Model” 便延伸到广义的 “数据” 或者 “数据来源” 的意思。数据的来源有很多，如来源于 XHR 的请求、来源于 LocalStorage/indexedDB/Session/Cookie 等、来源于 Vuex 等状态管理工具等等，数据的作用也可能各有不同，有用作渲染的纯数据、控制视图变化的数据、需要被 ViewModel 分发的其他数据等等，这些都被抽象到 Model 中，因 ViewModel 的代理而具有响应性。\n\n但是，React 并非 MVVM 架构的框架。因为 React 中的响应式并没有双向绑定的特征。\n\n\n# React 创建呈现随时间变化数据的组件\n\n相反的，在 React 的响应式中，使用的是基于属性和状态的单向数据流的模型。当然这样说有点具象，这种单向数据流的响应式还需结合原理来看才显得透彻。但是我们可以从一个更为抽象和概括的视角去体会 React 响应式的特征：\n\nui = render (data)\n\n如果我们从视频的帧的角度去理解这样的渲染公式的话就能体会其中的深意。React 中写道： React 用于渲染 呈现随时间变化数据的 组件，这里所谓 随时间变化数据 有两层含义：一是时间的连续性，二是数据的呈现离散性质的变化。我们如果从数学上自变量和因变量的视角来看这个问题的话，大概可以总结出这样的规律： view=f(t,data) ，即视图是在因变量时间和数据作用下的结果。所谓的视图渲染，不过是将视图的变化呈现在屏幕（视图媒介）上而已，那么如何解决时间的连续性问题呢？看下视频渲染的思路我们大概就能清晰明了了，视频显然有着类似的规律 video=f(t,yuvData) ，（ yuvData 只是示例，也可以是其他格式的图像数据）同样的时间的连续性，视频组件采用了帧的概念，为什么采用帧的概念呢？这是因为对于连续的时间做出反应具有不可估量的高成本，然而任何视图媒介在人眼的物理缺陷下都有一定的极限，即人眼所能认知的变化是有限度的，屏幕是采用了这个原理，浏览器的绘制同样是采用了这样的原理，那么同等地，React 中也是借用了这样的原理。\n\n数据在通过 render 这样的一个渲染器的渲染下做出了响应性的反应，这种针对数据变化的响应是有一定的频率的，视图正在在这样的频率下借用浏览器的渲染机制展示在人眼前。大家可能会疑问这样一个帧率的机制是否会很复杂，其实不然，因为帧率本身就是浏览器的内部机制，而频率从本质上也就是一个定时器而已，React 要做的，无非就是在正确的时机去做正确的任务，如果你已经阅读过调度器的篇章，您可能会对此颇有感慨。\n\n我们可以明了的是， render 机制的核心便是调度器。那么如果撇开调度器不谈，从 data 到 ui 的这样一个单向的数据流是如何被实现的呢？\n\n\n# 基于属性和状态的单向数据流的模型\n\n我们知道，在 React 中，组件的视图是通过 JSX 所定义和描述的（注意，准确来讲是组件的视图，并非是组件），组件则是通过函数和闭包原理来定义和描述的。然而这样的描述本身是静态的，并不能满足组件的可交互性的需求，因此，属性和状态便由此产生。属性描述组件之间的动态的数据流，而状态则描述组件内部的动态的数据流。\n\nReact 中数据流是单向的，不可逆的！无论是属性还是状态，都必须遵循这个原则。属性是不可变的（从组件内部而言不可写），必须以组件树的顺序进行流动（即从父组件流向子组件，或者说从组件树的根部流向枝叶），状态是可变的（从组件内部而言可读且可写，Context 本质上是更高层组件的状态），但状态的变化必须从 setState 被收集（注意，以下皆以函数式组件为例，类组件可自行类比）由 React 中渲染层进行渲染（引用最新的状态渲染），以此循环往复。React 这样的响应性设计实际上有了更多的控制反转（IoC）的意味，这使得 React 对于整个渲染过程有了更多的控制权和灵活性以实现较为复杂的设计理念（如 fiber 与调和）和耳目一新的新特性（如 lazyComponent，suspense 等）。当然，这也使得 React 的源码更为复杂，代码量更为庞大。\n\n如果从这样的观点再来回看函数式组件的写法，其实更深刻的体现了 “定义” 组件的意味。我们可以慢慢的体会闭包和 JSX （ JavaScript Syntax Extension ）对于组件的这种定义性，包括模板、事件及事件处理、状态、属性、计算量等等。如果您已经对此有一定的体会之后，我们可以更深入的思考这样的特性对于我们编写 React 组件有什么启示，我觉得其中最为重要的启示就是 “寓动于静” 的组件编写原则，下面我会详细的解释这个原则。\n\n\n# “寓动于静” 的组件编写原则\n\n# “万宗归静”\n\n“寓动于静” 就是要回归静态，我称之为 “万宗归静”。\n\n动与静本身就是一对矛盾体，动态的内容相比于静态内容，自然具有更高的复杂性。复杂性越高则意味着我们可能需要更高的代价去完成同等的任务。下面我将举几个例子来说明这个观点。\n\n我们知道 Vue 中采用 SFC 的最重要的原因之一是 SFC 为组件的静态分析提供了便利。对于 ViewModel 而言，在追踪到副作用之后，如何以最小的代价根据副作用去更新视图就成了最为重要的优化方向之一。在 Vue 的响应式更新之中，除了采用更为高效的节点 DIFF 算法之外，从源头上减少节点的 DIFF 也是重要的优化手段。那么怎么减少需要 DIFF 的节点呢？SFC 的结构为 Vue 进行基于模板文件的组件的静态分析提供了便利，Vue 通过为模板节点打上静态标记以使 DIFF 的成本能够尽可能地降低。这是很好的手段，也是静态分析的优越性之一。\n\n同 Vue 中 SFC 类似，React 组件的编写也应该尽可能保持静态。我这里说的静态并非是说减少动态的内容、减少页面的交互性，而是说减少组件顶层的动态内容。闭包的高效就体现在空间换时间的特点上。React 在渲染的每一 “帧” 都会重新执行闭包，即 Component(props, context) ，如果顶层内容包含了过多的计算成本，很显然就会阻塞 React 中视图的渲染。就一个 React 组件而言，可以静态的将之分成五个部分：\n\n * Props&State : 属性、状态和计算量（props/state）等；\n * Handler : 事件处理函数或者业务处理函数；\n * Effect : 副作用部分；\n * Render : 视图模板；\n * Hook : Hook 可以包含 State 、 计算量 、 Effect 和 Handler 。注意： Hook 不应该包含视图。由此可知， Hook 本质上是对组件的 Mixin ，因为可以包含 Effect 使之比普通的 Mixin 要更加的强大。这也是 Hook 能够带来代码复用、逻辑复用的好处的原因。\n\n你可以在编写组件时清晰的标明这些模块以使你的代码的阅读性更好。\n\n现在我们从静态的视角来观察以上内容， Props&State 本身是变量，计算成本较小； Handler 是函数，如果没有包裹于 useCallback 中则会每次实例化，但是函数本身在闭包之中只在需要调用时执行，因此，应当按照依赖来决定是否需要实例化以减少成本； Render 部分经过 babel 处理变为 ReactElement ，成本较小，但是也需要考虑每次实例化模板时的计算成本，比如 inline handler 的问题； Effect 本质上是注册副作用，副作用在渲染时是批量执行的，因此只需控制好依赖项即可； Hook 本质上是对组件状态、副作用、业务逻辑等的混入，遵从上述原则即可。\n\n可以看到，组件本身是静态的，只有在数据流的驱动下 React 渲染之后才引起视图的更新，然而，更新后的视图又何尝不是静态的呢？所以，组件在单一帧的内部是完全静态的，稳定的！React 在时间切片的末尾对视图的更新，既兼顾了性能，也兼顾了页面的稳定性！再看看时间切片的思想是否如此熟悉？计算机的时间切片、JavaScript 事件循环的时间切片、任务队列的时间切片、React 调度器的时间切片......\n\n现在的问题就在于需要区分组件中哪些内容是顶层的，哪些内容是非顶层的？顶层的内容一定要遵循静态的规则，切不可插入高计算成本、高时间成本的内容，尤其是副作用，（副作用一定要包含在 useEffect 或者 useLayoutEffect 之中进行注册）。理解闭包的特性和 React 的原理或许对于理解这个问题有一定帮助。\n\n如果这还不能证明 “万宗归静” 的正确性？我这还有更多的例子，比如：\n\n * React 中对状态的收集（updateQueue）、对副作用的收集、对节点的 EffectTag 标记和冒泡等等。\n * 相同环境下，迭代往往比递归更为高效。\n * 在股市的分析中，往往也包括 “形态学” 和 “动力学”，但是 “动力学” 是通过 “形态学” 所表现的。\n * ......\n\n# “择机而动”\n\n“寓动于静” 就是要使动态的内容 “择机而动”。\n\n视图中绝不可能缺少动态的内容，主要原因是因为数据是动态的、交互也是动态的。动态的内容绝非不执行，也绝非立即执行，而是需要在适当的时间进行执行！这个适当的时间可能会有很多的场景，但最终目的是为了保证页面渲染的稳定性和高效性的平衡。\n\n怎么样才能使动态的内容能够 “择机而动” 呢？有很多的方法可以达到目的，比如说事件监听机制、事件委托机制、观察者模式、受调度的任务队列等。要理解这个问题，就需要深刻思考两个概念：任务（或者说产品）、生产者与消费者。任务可以由生产中心所生产，由运输中心所运输，由任务中心所管理，由调度中心所调度，由执行中心所执行......。当然这样的想法很抽象，但却很有用。思考清楚这些问题，我们就能把动态的内容（包括静态的内容）进行 “任务化”（或者说 “产品化”），使之能够实现更加丰富的特性，如批量消费、包装（代理）、装饰、质检（健康检查）、过滤、去重、排序、热化（使某些产品优先被消费）、冷化（降低某些产品的消费权重）、再加工、防伪（摘要）、持久化、序列化和反序列化、暂停生产或者继续生产、暂停消费或者继续消费、分类（聚类）、优先级处理、适配器（新旧产品适配）...... 实际上，发挥你的想象力，你所能做到的远远不止是这些！\n\n现在我要回归到 “择机而动” 的主题上来，我将从 React 中举例说明这个问题，这其中大部分问题都是优化的问题：\n\nReact 中的组件动态内容包含两个部分：\n\n * 事件驱动：由事件系统所驱动的组件状态、行为的变化。包括点击事件（onclick）、聚焦事件（onfocus）、输入内容事件（oninput）等等。\n * 副作用驱动：由副作用所驱动的组件的状态、行为的变化。包括网络请求、查询 localStorage 等等获取数据的行为、操作 DOM、添加订阅或者定时器、日志记录等其他可能影响组件状态的副作用。\n\n我们可能已经注意到了，无论是事件还是副作用，我们在组件中只有注册行为！事件和副作用的执行后果可能是动态的，但是其注册行为本身是静态的，因为 React 可以保证注册的行为不会引起组件状态或者行为的更新！这便是 “寓动于静” 的体现。\n\n现在让我们来着重体会 “时机” 这个词的重要性：\n\n * 在 React 中注册的事件会立即执行吗？当然不是，应当等到事件真正发生才行！那么事件真正发生了之后就会立即执行吗？当然不是，应当等到事件冒泡到事件所委托的节点才会真正执行！如果把事件处理当做是一项任务，那么被委托到的节点 FiberRoot 又何尝不是 “事件处理中心”？\n * 在 React 中副作用的执行时机是什么时候呢？我们已经知道副作用都会在 useEffect 或者 useLayoutEffect 中注册，那个两者的执行时机又是什么呢？事实上，调和器会在 Commit 阶段的 layout 步骤中执行 useLayoutEffect 所注册的副作用，在渲染结束的的首次调度中执行 useEffect 中注册的副作用。执行的时机不同才是两者针对副作用处理的最大的区别。重点是，两者执行的时机都是以一次渲染为粒度的，而且此处的副作用包含了组件中注册的所有同等类型的副作用，也就是说这不仅仅是时间分片上的批处理，而且是副作用任务本身的批处理！\n\n现在你知道了 “寓动于静” 的原理和强大的特性了吧。动静是对立统一的，以静为动，寓动于静，可能会是帮助您解决复杂问题的一大利器。“风动幡动，仁者心动” 何尝不是此理。\n\n\n# React 为什么使用 JSX？\n\n\n# 构建 UI\n\n原文\n\nReact 用了不同的方式构建 UI，把它们拆成组件。 这意味着 React 使用了一种真实的、具有各种特性的编程语言来渲染视图， 我们认为它相较于模板而言是一种优势的理由如下:\n\n * JavaScript 是一种灵活、强大的编程语言，具有构建抽象的能力， 这在大型应用中非常重要。\n * 通过将你的标记和其相对应的视图逻辑统一起来， React 实际上可以让视图变得更容易扩展和维护。\n * 通过把一种对标记和内容的理解融入 JavaScript， 不用手动连接字符串，因此 XSS 漏洞的表面积也更小。\n\n参见：原文\n\n我认为 React 此处所指的模板是指使用模板文件的方式来构建组件、使用 HTML 和指令来构建视图的组件描述方式，如 SFC。狭义的理解模板应该是指视图模板，我认为 Vue 中 template 里 HTML 和指令所描述的视图是模板，React 中函数式组件中返回的 JSX 的方式（结合 HTML 和 JS）描述的视图也是模板，是以广义概念理解之。\n\n\n# 渲染逻辑本质上与 UI 逻辑内在耦合\n\n原文\n\n * React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据。\n * React 将渲染逻辑和 UI 逻辑共同存放在称之为 “组件” 的松散耦合单元之中，来实现关注点分离。\n\n参见：为什么使用 JSX？\n\n对于组件而言，可以分成渲染逻辑和 UI 逻辑（也可以将样式包含在内），于 SFC 组件而言，区分则十分明显， template 、 script 和 style 分别与之对应。可见 React 对于组件的理解与 SFC 大为不同甚至可以说是刚好相反。至于组件是应该 “松散耦合” 还是应该 “解耦合”，我认为各有利弊。\n\n至于为什么 React 会有这种 “松散耦合” 的概念，我认为很有可能是受到原生 DOM 的影响。如果分开从 DOM 层面和 VDOM 层面去思考，JSX 所表征的 ReactElement 在组件层面上更接近于是对 DOM 的描述。之所以这么说是因为 ReactElement 总归是相对静态的，它虽然是符合 VDOM 的概念定义的，但是 VDOM 的一大特征是动态性，VDOM 是需要引入和依赖于 DIFF 算法的。在 ReactElement 中其实不存在 DIFF 算法，它只被上层 DIFF 的结果所影响从而做出应有的改变。从这个角度来看，JSX 以 “松散耦合” 的理念降低其 VDOM 的特性而更加贴近于 DOM 的特性是正确的，这也是降低 DOM 更新成本、提升 VDOM 应用效率的必然要求。\n\n还有一种问题是这种 “松散耦合” 所引入的，便是 Inline Functions 的问题。JSX 的灵活性允许我们在 React 中使用 Inline Functions ，但是其中另有区别。\n\n\n# Inline Functions\n\n不使用 Inline Functions :\n\nfunction Component() {\n  const handleClick = () => {handleThis();}\n  return <div onClick={handleClick}></div>\n}\n\n\n1\n2\n3\n4\n\n\n编译后：\n\nfunction Component() {\n  const handleClick = () => {\n    handleThis();\n  };\n\n  return /*#__PURE__*/ React.createElement("div", {\n    onClick: handleClick\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n使用 Inline Functions ：\n\nfunction Component() {\n  return <div onClick={() => {handleThis();}}></div>\n}\n\n\n1\n2\n3\n\n\n编译后：\n\nfunction Component() {\n  return /*#__PURE__*/ React.createElement("div", {\n    onClick: () => {\n      handleThis();\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以看出的是，行间的函数将会被编译到 ReactElement 之中。 Inline Functions 有如下两个最大的诟病：\n\n * 频繁实例化，频繁的 GC。React 在每次渲染时都会重复实例化函数，旧的函数也会立即被 GC，尽管这是无效的工作；如果是事件处理器的话则会更加明显，因为事件处理器一般是静态的，而这种每次删除处理器而重新绑定的行为必然会造成一定的花销。\n * 引用变化导致子组件无效的重新渲染。如果 Callback 是需要传递给子组件的话，使用 Inline Functions 则会导致引用不断改变，造成子组件的 Memo 失效，进行无效的重新渲染。\n\n注意，我们有 Function Ref (回调 Refs，参见: 回调 Refs) 的用法，也可以会有 Inline Functions 的写法。这种情况应当另加讨论，因为 Ref 引用节点的 DOM 元素或者 forwardRef ，每次渲染时都会有删除引用和重新引用的操作，情形并与上相同，也不存在造成无效渲染的问题。\n\n那么，是否应该放弃使用 Inline Functions 以规避以上的问题呢？（一些 Eslint 的规则提供了针对类组件的 Inline Functions 的检查，eslint-plugin-react/jsx-no-bind）实则不然：\n\n * FC 的本质是利用了闭包的封闭性以实现组件状态和属性的分发（注意：类组件基于 class 的写法本质上也是闭包！），类组件亦是如此。闭包模拟组件的好处在于其封闭性，即 闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。 这样的一个稳定的 Context 对于描述组件的属性和行为是十分有利的，但是别忘了闭包最大的缺点在于：\n\nMDN： 闭包的性能考量\n\n * 如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对性能具有负面影响。（关于这一点，React 与相关的观点：Hook 会因为在渲染时创建函数而变慢吗？ ）\n * 例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是说，对于每个对象的创建，方法都会被重新赋值）。\n\n闭包最大的开销在于其实例化的开销，FC 在每次渲染时都会实例化，即使不使用 Inline Functions ，而是将处理函数写在顶层的闭包中，在闭包实例化之时，函数同样会有实例化的过程！这部分实例化的开销同样无法避免！\n\n有一种可能性是将处理的函数包裹在 useCallback 中，但是需要注意的是， useCallback 和 useMemo 是一种反模式（anti-pattern）的写法，其本身也是有一定的花销的！\n\n所以，关于是否需要使用 Inline Functions 实际上是一种可读性、可维护性和性能的权衡（tradeOff），在社区中也有多种声音呼吁不要过早的对 React 进行性能优化，因为你也不知道优化后的应用是否会有实质的性能提升。\n\n参考：\n\n * How To Use Inline Functions In React Applications Efficiently\n * javascript - Need to understand inline function call with react FC - Stack Overflow\n * React, Inline Functions, and Performance | by Ryan Florence | Medium\n * When to useMemo and useCallback\n * Don’t over-engineer – Page Fault Blog\n\n\n# React 如何解释响应式更新？\n\n原文\n\n * 当你的组件首次初始化，组件的 render 方法会被调用， 对你的视图生成一个轻量化的表示。从那个表示生成一串标记， 并注入到文档中。当你的数据发生了变化， render 方法会再次被调用。为了尽可能高效地执行更新， 我们会对前一次调用 render 方法返回的结果和新的调用结果进行区分， 并生成一个要应用于 DOM 的最小更改集合。\n * render 返回的数据既不是一串字符串也不是一个 DOM 节点 —— 而是一种表示 DOM 应该是什么样子的轻量化描述。我们把这个过程称为协调。因为这样的重渲染实在太快了， 所以开发者不需要显式地指定数据绑定。\n * 在实践中，大多数 React 应用只会调用一次 root.render ()。参见：更新已渲染的元素。\n\n参见: 原文\n\n * render 方法 ：这里的 Render 方法必然不是指的是 ReactDOM.render （新版本为 ReactDOM.createRoot.render ） 这样的方法，我认为应该指的是 renderRootSync 和 renderRootConcurrent 方法。因为前者是针对 HOST 环境所提供的 Render 方法，只会在首次渲染时执行一次，而后者则会在调度器回调之后执行，即 数据发生了变化会再次被调用 。\n * 轻量化的表示 ：指的是 FiberTree 系统，数据结构总归是 轻量的 ，它体现了视图最新的状态和行为以及视图稳定的状态和行为。\n * 一串标记 ：指的是 EffectTag List ，当然这里做过一些重构，但是总体思想未变， EffectTag 体现对节点将要执行的增、删、改（mutation）操作，最终将应用到 DOM 节点上。\n * 对前一次调用 render 方法返回的结果和新的调用结果进行区分 ：指的是 workInProgress FiberTree 和 current FiberTree 调和的过程，当然也包括了节点的 DIFF 过程。\n * 应用于 DOM 的最小更改集合 ：指的是经过上述 DIFF 过程之后对 EffectTag List 的搜集过程。\n * 调和（或者协调）的过程是生成 DOM 的轻量化描述（VDOM）的过程。\n\n\n# JSX 中 XSS 处理\n\n原文\n\nReact DOM 在渲染所有输入内容之前，默认会进行转义。\n\n在 JSX 中插入字符内容时是做了转义（Escape）处理的，即将可能产生风险的特殊字符进行转义，参见：JSX 防止注入攻击。\n\n相反的，在向 JSX 中插入 HTML 时，如使用 dangerouslySetInnerHTML 时，React 并没有帮你将待插入的内容进行消毒，需要自行进行内容消毒。可以使用 jam3/no-sanitizer-with-danger 、theodo/RisXSS: RisXSS 规则以确保在使用 dangerouslySetInnerHTML 时正确的进行了消毒处理。\n\n原文\n\n"The prop name dangerouslySetInnerHTML is intentionally chosen to be frightening. ..."\n\n"After fully understanding the security ramifications and properly sanitizing the data..."\n\n使用如下的 sanitizer 处理消毒：\n\n * cure53/DOMPurify: DOMPurify - a DOM-only, super-fast, uber-tolerant XSS sanitizer for HTML, MathML and SVG. DOMPurify works with a secure default, but offers a lot of configurability and hooks. Demo:;\n\n * leizongmin/js-xss: Sanitize untrusted HTML (to prevent XSS) with a configuration specified by a Whitelist;\n\n * YahooArchive/xss-filters: Secure XSS Filters.;\n\n * Lodash Documentation - escape\n\n * milesj/interweave: 🌀 React library to safely render HTML, filter attributes, autowrap text with matchers, render emoji characters, and much more.\n\n * javascript - React.js: Set innerHTML vs dangerouslySetInnerHTML - Stack Overflow\n\n\n# ReactElement 与 DOM Element\n\n原文\n\n * 元素是构成 React 应用的最小砖块。\n * 元素描述了你在屏幕上想看到的内容。\n * 与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象。\n * React DOM 会负责更新 DOM 来与 React 元素保持一致。\n\nJSX 的元素，即 ReactElement，描述了最小视图渲染单元，其本质上是 JavaScript 对象所描述的虚拟节点，与 DOM 元素完全不同。简单来说，我们把 ReactElement 描述为 VDOM，尽管它并没有实质性的 DIFF 过程。\n\nVDOM 最大的特点是提供了开销较小的节点的逻辑抽象，这是众多的基于 VDOM 和 DIFF 算法理念以实现节点的响应式更新的框架的理论来源。同时，VDOM 本身也是防腐层（源于其抽象性），抹平了各种 HOST 环境的实现上的差异性。\n\nReactElement 将更新 DOM 使其与自己保持一致，这种更新是局部的、批量的，它以标记的形式展开。注意，这里所说的 其与自己保持一致 并非 ReactElement 与 DOM 与直接的关联，中间还需经过 FiberTree 的调和过程。\n\n\n# React 元素是不可变对象\n\n原文\n\nReact 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 UI。\n\n参见：元素渲染 – 更新已渲染的元素\n\nReactElement 是静态的，ReactElement 是不可变对象！\n\n要理解这个问题，先得理解前文所写的 React 渲染中的 “帧” 的概念，基于此，如果我们狭义的理解此 “帧” 即为 “视图帧” 的话，那么这里的 “帧” 就是通过 ReactElement 所表现的！\n\nReactElement 在 React 整个渲染循环中充当什么样的角色呢？ReactElement 提供了用户对想要的视图所有的静态的和可交互的描述和定义，这种组件的定义形式因 “寓动于静” 的原理而成为具有不同的状态和行为的视图的 “帧”。\n\nReactElement 在一次渲染之中是寂静的、静态的，它依托闭包的封闭特性而将此时此时的状态、属性、行为方式进行分发，或在视图中呈现，或成为视图交互时的行为绑定，这种静态所体现的正是组件或者组件视图的 “帧”。\n\n现在我们且聊一聊 “帧” 是如何被渲染的，由 ReactElement 所描述的静态的帧是如何成为屏幕的视图呈现的呢？\n\nReact 组件的状态和行为模式是在 React 调和中的 Batch 执行阶段被收集的，在这个阶段是页面视图最为稳定的时候，一个新的渲染或许已经被调度，但是被没有被调度器所回调。现在我们假设一个新的渲染回调将产生，现在浏览器将有足够的精力和时间去处理渲染的任务。在确认执行渲染任务时，组件的状态和行为模式将无法被继续收集，但是别担心，这个过程将会很短暂，并且渲染的任务是可以打断的，如果有高优先级的交互更新出现，我们可以给此次渲染按下暂停键。\n\n现在假设这次渲染并没有被打断，那个 React 将会去获取组件新的状态和行为模式了，ReactElement 将会被注入最新的状态和行为模式并且交给 React，这个过程正是通过闭包实现的。现在 React 通过 JSX 脱水了组件的信息量，那么这个信息量将如何被最小化的执行呢？双缓存的 FiberTree 的结构正是为此而生！\n\n我们从 ReactElement 中脱水的信息量必须要经过处理和计算，才能降低更新所带来的高成本。刚才的分析还是从组件的层面来展开，现在我们将视角扩展对整个应用。应用是由组件树所构成的，组件又是由 ReactElementTree 所构成的。React 并不从组件层面进行更新的原则决定了 React 必须对这样的树形结构采取更为有效的、低成本的数据结构进行处理。于是 Fiber 便产生了，从应用的容器开始，到每一个叶子节点，React 将之处理为一棵由 Fiber 节点所构成的树形结构，而且为了提升 DFS 的效率，除了 child 指针之外，FiberTree 还采用了 parent 指针和 sibling 指针。\n\nReact 将从 ReactElement 中获取的信息量注入到 Fiber 节点之中，通过这种方式，React 对节点有了更多的控制权，这使得很多激动人心的功能得以实现。如果是首次渲染的话，构建这样的一棵 FiberTree 确实将花费不菲，但是幸运的是 root.render 只会在应用挂载时执行一次，并且首次渲染也避开了 DIFF 过程节省了开销。\n\n如果是非首次渲染的话，那么内存中便存在两棵 FiberTree，其中一棵是表征当前正在显示在页面中的稳定版本的 FiberTree，我们可以理解为上一 “帧”，而另外一棵树则是要通过复用节点所构建的包含组件树最新状态和行为模式的 FiberTree，我们可以理解为下一 “帧”。下面便是相邻的两 “帧” 的 DIFF 过程了，这是一个捕获和冒泡的过程，这样的过程使我们知道了新的一 “帧” 需要有哪些 “改动点”，而这样的 “改动点” 的集合便构成了 “应用于 DOM 的最小更改集合”。至此， Render 过程便结束了。值得注意的是， Render 过程是在浏览器的空闲时间中完成的，而且此过程不会对当前所渲染的页面造成任何不稳定的影响！\n\n下面 Commit 阶段便开始了，React 在 mutation 阶段对以上的 “改动点集合” 进行了处理，从 fiber 节点中我们将创建、更新或者删除 DOM 节点的实例，两棵 FiberTree 也将交换自己的 “角色”。之后浏览器将在空闲时间对 DOM 树进行重排和重绘。这便是新的一 “帧” 真正落地的时刻。\n\n通过这样一个 “帧” 的渲染的过程，现在请你告诉我为什么 “React 元素是不可变对象”？因为 ReactElement 从被 “截取” 那一刻起，它必须是静态的、可分析的，因为 React 正是通过这个的 “帧” 的 “采样”，来实现其内部的渲染机制！\n\n\n# 参考\n\n * 我们为什么要构建 React? – React Blog\n * JSX',normalizedContent:'# 前言\n\n带着原理重读 react 官方文档 系列文章并不是一个关注原理细节的文章系列，而是作为一个描述想法、思想和设计哲学的文章系列。在这里不会有太多的代码，但是会有大量的文字。\n\n本质上这个系列是对 react 官方文档的重温，从原理的角度去体会文档中的一些有价值的、可能会被大家所忽略的内容而细细嚼之。至此，文章难免有部分冗长无味、肆意扩展的部分。\n\n其实，我并非怀着正经技术文章的心态去写这个系列，而是想到何处便写到何处，写到尽兴为止。无论您是细读之，还是作为茶余饭后的消遣，我认为都无大碍。瑾以记之。\n\n\n# react 不是一个 mvc 框架\n\n原文\n\nreact 不是一个 mvc 框架。\n\nreact 是一个用于构建可组合用户界面的库。 它鼓励创建那些用于呈现随时间变化数据的、可复用的 ui 组件。\n\nreact is a library for building composable user interfaces. it encourages the creation of reusable ui components which present data that changes over time.\n\n参见：原文\n\n\n# react 并不是一个 mvc 框架\n\nreact 不存在所谓的 controller 的概念，并非由 mvc 的架构思想所驱动。react 的目的是构建可组合用户界面，于视图库而言，mvc 并不适合，因为 controller 并不具备响应式的特征。\n\n\n# react 也不是一个 mvvm 框架\n\nmvvm 与 mvc 最明显的区别是 vm 的概念，vm 即 viewmodel，是 view 和 model 沟通的桥梁，既然是桥梁，必然具有重要的连接作用，也即是双向绑定。双向绑定是 mvvm 最大的特征，它体现一种双向数据流的思想，即数据的变化通过 viewmodel 的连接作用影响到视图，视图的变化反过来又会通过 viewmodel 的连接作用影响到数据。这种双向绑定的过程，即是所谓的响应性。\n\n双向绑定的特征要求 viewmodel 应该是可观测的、可响应的，即具有响应性。实现响应性的方法有很多，最简单的方式就是通过代理，可通过代理的方式观测和控制 viewmodel 内部发生的变化，对数据的流出和流入做一定的拦截和控制。这个道理也很简单，如果把数据看作是流水的话，若需要对水量进行观测和控制的话，我们只需要使用一个蓄水池并且使水流的流入和流水使用单独的通道，然后对水流的流入和流出进行流量和流速的观测即可。比如 vue2 的响应式是通过 object. defineproperty 实现的，vue3 的响应式是通过 proxy api 实现的。所使用的 api 不同，无非是 api 实现的进步，但是万变不离其宗，其本质还是 “代理（proxy）” 的思想。其实，如果细究起来，vue 对于 mvvm 的应用也只是广义上的应用，因为 model 在狭义上指的是 orm 的模型，此为后端的概念，显然对于视图框架而言，“model” 便延伸到广义的 “数据” 或者 “数据来源” 的意思。数据的来源有很多，如来源于 xhr 的请求、来源于 localstorage/indexeddb/session/cookie 等、来源于 vuex 等状态管理工具等等，数据的作用也可能各有不同，有用作渲染的纯数据、控制视图变化的数据、需要被 viewmodel 分发的其他数据等等，这些都被抽象到 model 中，因 viewmodel 的代理而具有响应性。\n\n但是，react 并非 mvvm 架构的框架。因为 react 中的响应式并没有双向绑定的特征。\n\n\n# react 创建呈现随时间变化数据的组件\n\n相反的，在 react 的响应式中，使用的是基于属性和状态的单向数据流的模型。当然这样说有点具象，这种单向数据流的响应式还需结合原理来看才显得透彻。但是我们可以从一个更为抽象和概括的视角去体会 react 响应式的特征：\n\nui = render (data)\n\n如果我们从视频的帧的角度去理解这样的渲染公式的话就能体会其中的深意。react 中写道： react 用于渲染 呈现随时间变化数据的 组件，这里所谓 随时间变化数据 有两层含义：一是时间的连续性，二是数据的呈现离散性质的变化。我们如果从数学上自变量和因变量的视角来看这个问题的话，大概可以总结出这样的规律： view=f(t,data) ，即视图是在因变量时间和数据作用下的结果。所谓的视图渲染，不过是将视图的变化呈现在屏幕（视图媒介）上而已，那么如何解决时间的连续性问题呢？看下视频渲染的思路我们大概就能清晰明了了，视频显然有着类似的规律 video=f(t,yuvdata) ，（ yuvdata 只是示例，也可以是其他格式的图像数据）同样的时间的连续性，视频组件采用了帧的概念，为什么采用帧的概念呢？这是因为对于连续的时间做出反应具有不可估量的高成本，然而任何视图媒介在人眼的物理缺陷下都有一定的极限，即人眼所能认知的变化是有限度的，屏幕是采用了这个原理，浏览器的绘制同样是采用了这样的原理，那么同等地，react 中也是借用了这样的原理。\n\n数据在通过 render 这样的一个渲染器的渲染下做出了响应性的反应，这种针对数据变化的响应是有一定的频率的，视图正在在这样的频率下借用浏览器的渲染机制展示在人眼前。大家可能会疑问这样一个帧率的机制是否会很复杂，其实不然，因为帧率本身就是浏览器的内部机制，而频率从本质上也就是一个定时器而已，react 要做的，无非就是在正确的时机去做正确的任务，如果你已经阅读过调度器的篇章，您可能会对此颇有感慨。\n\n我们可以明了的是， render 机制的核心便是调度器。那么如果撇开调度器不谈，从 data 到 ui 的这样一个单向的数据流是如何被实现的呢？\n\n\n# 基于属性和状态的单向数据流的模型\n\n我们知道，在 react 中，组件的视图是通过 jsx 所定义和描述的（注意，准确来讲是组件的视图，并非是组件），组件则是通过函数和闭包原理来定义和描述的。然而这样的描述本身是静态的，并不能满足组件的可交互性的需求，因此，属性和状态便由此产生。属性描述组件之间的动态的数据流，而状态则描述组件内部的动态的数据流。\n\nreact 中数据流是单向的，不可逆的！无论是属性还是状态，都必须遵循这个原则。属性是不可变的（从组件内部而言不可写），必须以组件树的顺序进行流动（即从父组件流向子组件，或者说从组件树的根部流向枝叶），状态是可变的（从组件内部而言可读且可写，context 本质上是更高层组件的状态），但状态的变化必须从 setstate 被收集（注意，以下皆以函数式组件为例，类组件可自行类比）由 react 中渲染层进行渲染（引用最新的状态渲染），以此循环往复。react 这样的响应性设计实际上有了更多的控制反转（ioc）的意味，这使得 react 对于整个渲染过程有了更多的控制权和灵活性以实现较为复杂的设计理念（如 fiber 与调和）和耳目一新的新特性（如 lazycomponent，suspense 等）。当然，这也使得 react 的源码更为复杂，代码量更为庞大。\n\n如果从这样的观点再来回看函数式组件的写法，其实更深刻的体现了 “定义” 组件的意味。我们可以慢慢的体会闭包和 jsx （ javascript syntax extension ）对于组件的这种定义性，包括模板、事件及事件处理、状态、属性、计算量等等。如果您已经对此有一定的体会之后，我们可以更深入的思考这样的特性对于我们编写 react 组件有什么启示，我觉得其中最为重要的启示就是 “寓动于静” 的组件编写原则，下面我会详细的解释这个原则。\n\n\n# “寓动于静” 的组件编写原则\n\n# “万宗归静”\n\n“寓动于静” 就是要回归静态，我称之为 “万宗归静”。\n\n动与静本身就是一对矛盾体，动态的内容相比于静态内容，自然具有更高的复杂性。复杂性越高则意味着我们可能需要更高的代价去完成同等的任务。下面我将举几个例子来说明这个观点。\n\n我们知道 vue 中采用 sfc 的最重要的原因之一是 sfc 为组件的静态分析提供了便利。对于 viewmodel 而言，在追踪到副作用之后，如何以最小的代价根据副作用去更新视图就成了最为重要的优化方向之一。在 vue 的响应式更新之中，除了采用更为高效的节点 diff 算法之外，从源头上减少节点的 diff 也是重要的优化手段。那么怎么减少需要 diff 的节点呢？sfc 的结构为 vue 进行基于模板文件的组件的静态分析提供了便利，vue 通过为模板节点打上静态标记以使 diff 的成本能够尽可能地降低。这是很好的手段，也是静态分析的优越性之一。\n\n同 vue 中 sfc 类似，react 组件的编写也应该尽可能保持静态。我这里说的静态并非是说减少动态的内容、减少页面的交互性，而是说减少组件顶层的动态内容。闭包的高效就体现在空间换时间的特点上。react 在渲染的每一 “帧” 都会重新执行闭包，即 component(props, context) ，如果顶层内容包含了过多的计算成本，很显然就会阻塞 react 中视图的渲染。就一个 react 组件而言，可以静态的将之分成五个部分：\n\n * props&state : 属性、状态和计算量（props/state）等；\n * handler : 事件处理函数或者业务处理函数；\n * effect : 副作用部分；\n * render : 视图模板；\n * hook : hook 可以包含 state 、 计算量 、 effect 和 handler 。注意： hook 不应该包含视图。由此可知， hook 本质上是对组件的 mixin ，因为可以包含 effect 使之比普通的 mixin 要更加的强大。这也是 hook 能够带来代码复用、逻辑复用的好处的原因。\n\n你可以在编写组件时清晰的标明这些模块以使你的代码的阅读性更好。\n\n现在我们从静态的视角来观察以上内容， props&state 本身是变量，计算成本较小； handler 是函数，如果没有包裹于 usecallback 中则会每次实例化，但是函数本身在闭包之中只在需要调用时执行，因此，应当按照依赖来决定是否需要实例化以减少成本； render 部分经过 babel 处理变为 reactelement ，成本较小，但是也需要考虑每次实例化模板时的计算成本，比如 inline handler 的问题； effect 本质上是注册副作用，副作用在渲染时是批量执行的，因此只需控制好依赖项即可； hook 本质上是对组件状态、副作用、业务逻辑等的混入，遵从上述原则即可。\n\n可以看到，组件本身是静态的，只有在数据流的驱动下 react 渲染之后才引起视图的更新，然而，更新后的视图又何尝不是静态的呢？所以，组件在单一帧的内部是完全静态的，稳定的！react 在时间切片的末尾对视图的更新，既兼顾了性能，也兼顾了页面的稳定性！再看看时间切片的思想是否如此熟悉？计算机的时间切片、javascript 事件循环的时间切片、任务队列的时间切片、react 调度器的时间切片......\n\n现在的问题就在于需要区分组件中哪些内容是顶层的，哪些内容是非顶层的？顶层的内容一定要遵循静态的规则，切不可插入高计算成本、高时间成本的内容，尤其是副作用，（副作用一定要包含在 useeffect 或者 uselayouteffect 之中进行注册）。理解闭包的特性和 react 的原理或许对于理解这个问题有一定帮助。\n\n如果这还不能证明 “万宗归静” 的正确性？我这还有更多的例子，比如：\n\n * react 中对状态的收集（updatequeue）、对副作用的收集、对节点的 effecttag 标记和冒泡等等。\n * 相同环境下，迭代往往比递归更为高效。\n * 在股市的分析中，往往也包括 “形态学” 和 “动力学”，但是 “动力学” 是通过 “形态学” 所表现的。\n * ......\n\n# “择机而动”\n\n“寓动于静” 就是要使动态的内容 “择机而动”。\n\n视图中绝不可能缺少动态的内容，主要原因是因为数据是动态的、交互也是动态的。动态的内容绝非不执行，也绝非立即执行，而是需要在适当的时间进行执行！这个适当的时间可能会有很多的场景，但最终目的是为了保证页面渲染的稳定性和高效性的平衡。\n\n怎么样才能使动态的内容能够 “择机而动” 呢？有很多的方法可以达到目的，比如说事件监听机制、事件委托机制、观察者模式、受调度的任务队列等。要理解这个问题，就需要深刻思考两个概念：任务（或者说产品）、生产者与消费者。任务可以由生产中心所生产，由运输中心所运输，由任务中心所管理，由调度中心所调度，由执行中心所执行......。当然这样的想法很抽象，但却很有用。思考清楚这些问题，我们就能把动态的内容（包括静态的内容）进行 “任务化”（或者说 “产品化”），使之能够实现更加丰富的特性，如批量消费、包装（代理）、装饰、质检（健康检查）、过滤、去重、排序、热化（使某些产品优先被消费）、冷化（降低某些产品的消费权重）、再加工、防伪（摘要）、持久化、序列化和反序列化、暂停生产或者继续生产、暂停消费或者继续消费、分类（聚类）、优先级处理、适配器（新旧产品适配）...... 实际上，发挥你的想象力，你所能做到的远远不止是这些！\n\n现在我要回归到 “择机而动” 的主题上来，我将从 react 中举例说明这个问题，这其中大部分问题都是优化的问题：\n\nreact 中的组件动态内容包含两个部分：\n\n * 事件驱动：由事件系统所驱动的组件状态、行为的变化。包括点击事件（onclick）、聚焦事件（onfocus）、输入内容事件（oninput）等等。\n * 副作用驱动：由副作用所驱动的组件的状态、行为的变化。包括网络请求、查询 localstorage 等等获取数据的行为、操作 dom、添加订阅或者定时器、日志记录等其他可能影响组件状态的副作用。\n\n我们可能已经注意到了，无论是事件还是副作用，我们在组件中只有注册行为！事件和副作用的执行后果可能是动态的，但是其注册行为本身是静态的，因为 react 可以保证注册的行为不会引起组件状态或者行为的更新！这便是 “寓动于静” 的体现。\n\n现在让我们来着重体会 “时机” 这个词的重要性：\n\n * 在 react 中注册的事件会立即执行吗？当然不是，应当等到事件真正发生才行！那么事件真正发生了之后就会立即执行吗？当然不是，应当等到事件冒泡到事件所委托的节点才会真正执行！如果把事件处理当做是一项任务，那么被委托到的节点 fiberroot 又何尝不是 “事件处理中心”？\n * 在 react 中副作用的执行时机是什么时候呢？我们已经知道副作用都会在 useeffect 或者 uselayouteffect 中注册，那个两者的执行时机又是什么呢？事实上，调和器会在 commit 阶段的 layout 步骤中执行 uselayouteffect 所注册的副作用，在渲染结束的的首次调度中执行 useeffect 中注册的副作用。执行的时机不同才是两者针对副作用处理的最大的区别。重点是，两者执行的时机都是以一次渲染为粒度的，而且此处的副作用包含了组件中注册的所有同等类型的副作用，也就是说这不仅仅是时间分片上的批处理，而且是副作用任务本身的批处理！\n\n现在你知道了 “寓动于静” 的原理和强大的特性了吧。动静是对立统一的，以静为动，寓动于静，可能会是帮助您解决复杂问题的一大利器。“风动幡动，仁者心动” 何尝不是此理。\n\n\n# react 为什么使用 jsx？\n\n\n# 构建 ui\n\n原文\n\nreact 用了不同的方式构建 ui，把它们拆成组件。 这意味着 react 使用了一种真实的、具有各种特性的编程语言来渲染视图， 我们认为它相较于模板而言是一种优势的理由如下:\n\n * javascript 是一种灵活、强大的编程语言，具有构建抽象的能力， 这在大型应用中非常重要。\n * 通过将你的标记和其相对应的视图逻辑统一起来， react 实际上可以让视图变得更容易扩展和维护。\n * 通过把一种对标记和内容的理解融入 javascript， 不用手动连接字符串，因此 xss 漏洞的表面积也更小。\n\n参见：原文\n\n我认为 react 此处所指的模板是指使用模板文件的方式来构建组件、使用 html 和指令来构建视图的组件描述方式，如 sfc。狭义的理解模板应该是指视图模板，我认为 vue 中 template 里 html 和指令所描述的视图是模板，react 中函数式组件中返回的 jsx 的方式（结合 html 和 js）描述的视图也是模板，是以广义概念理解之。\n\n\n# 渲染逻辑本质上与 ui 逻辑内在耦合\n\n原文\n\n * react 认为渲染逻辑本质上与其他 ui 逻辑内在耦合，比如，在 ui 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 ui，以及需要在 ui 中展示准备好的数据。\n * react 将渲染逻辑和 ui 逻辑共同存放在称之为 “组件” 的松散耦合单元之中，来实现关注点分离。\n\n参见：为什么使用 jsx？\n\n对于组件而言，可以分成渲染逻辑和 ui 逻辑（也可以将样式包含在内），于 sfc 组件而言，区分则十分明显， template 、 script 和 style 分别与之对应。可见 react 对于组件的理解与 sfc 大为不同甚至可以说是刚好相反。至于组件是应该 “松散耦合” 还是应该 “解耦合”，我认为各有利弊。\n\n至于为什么 react 会有这种 “松散耦合” 的概念，我认为很有可能是受到原生 dom 的影响。如果分开从 dom 层面和 vdom 层面去思考，jsx 所表征的 reactelement 在组件层面上更接近于是对 dom 的描述。之所以这么说是因为 reactelement 总归是相对静态的，它虽然是符合 vdom 的概念定义的，但是 vdom 的一大特征是动态性，vdom 是需要引入和依赖于 diff 算法的。在 reactelement 中其实不存在 diff 算法，它只被上层 diff 的结果所影响从而做出应有的改变。从这个角度来看，jsx 以 “松散耦合” 的理念降低其 vdom 的特性而更加贴近于 dom 的特性是正确的，这也是降低 dom 更新成本、提升 vdom 应用效率的必然要求。\n\n还有一种问题是这种 “松散耦合” 所引入的，便是 inline functions 的问题。jsx 的灵活性允许我们在 react 中使用 inline functions ，但是其中另有区别。\n\n\n# inline functions\n\n不使用 inline functions :\n\nfunction component() {\n  const handleclick = () => {handlethis();}\n  return <div onclick={handleclick}></div>\n}\n\n\n1\n2\n3\n4\n\n\n编译后：\n\nfunction component() {\n  const handleclick = () => {\n    handlethis();\n  };\n\n  return /*#__pure__*/ react.createelement("div", {\n    onclick: handleclick\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n使用 inline functions ：\n\nfunction component() {\n  return <div onclick={() => {handlethis();}}></div>\n}\n\n\n1\n2\n3\n\n\n编译后：\n\nfunction component() {\n  return /*#__pure__*/ react.createelement("div", {\n    onclick: () => {\n      handlethis();\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以看出的是，行间的函数将会被编译到 reactelement 之中。 inline functions 有如下两个最大的诟病：\n\n * 频繁实例化，频繁的 gc。react 在每次渲染时都会重复实例化函数，旧的函数也会立即被 gc，尽管这是无效的工作；如果是事件处理器的话则会更加明显，因为事件处理器一般是静态的，而这种每次删除处理器而重新绑定的行为必然会造成一定的花销。\n * 引用变化导致子组件无效的重新渲染。如果 callback 是需要传递给子组件的话，使用 inline functions 则会导致引用不断改变，造成子组件的 memo 失效，进行无效的重新渲染。\n\n注意，我们有 function ref (回调 refs，参见: 回调 refs) 的用法，也可以会有 inline functions 的写法。这种情况应当另加讨论，因为 ref 引用节点的 dom 元素或者 forwardref ，每次渲染时都会有删除引用和重新引用的操作，情形并与上相同，也不存在造成无效渲染的问题。\n\n那么，是否应该放弃使用 inline functions 以规避以上的问题呢？（一些 eslint 的规则提供了针对类组件的 inline functions 的检查，eslint-plugin-react/jsx-no-bind）实则不然：\n\n * fc 的本质是利用了闭包的封闭性以实现组件状态和属性的分发（注意：类组件基于 class 的写法本质上也是闭包！），类组件亦是如此。闭包模拟组件的好处在于其封闭性，即 闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。 这样的一个稳定的 context 对于描述组件的属性和行为是十分有利的，但是别忘了闭包最大的缺点在于：\n\nmdn： 闭包的性能考量\n\n * 如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对性能具有负面影响。（关于这一点，react 与相关的观点：hook 会因为在渲染时创建函数而变慢吗？ ）\n * 例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是说，对于每个对象的创建，方法都会被重新赋值）。\n\n闭包最大的开销在于其实例化的开销，fc 在每次渲染时都会实例化，即使不使用 inline functions ，而是将处理函数写在顶层的闭包中，在闭包实例化之时，函数同样会有实例化的过程！这部分实例化的开销同样无法避免！\n\n有一种可能性是将处理的函数包裹在 usecallback 中，但是需要注意的是， usecallback 和 usememo 是一种反模式（anti-pattern）的写法，其本身也是有一定的花销的！\n\n所以，关于是否需要使用 inline functions 实际上是一种可读性、可维护性和性能的权衡（tradeoff），在社区中也有多种声音呼吁不要过早的对 react 进行性能优化，因为你也不知道优化后的应用是否会有实质的性能提升。\n\n参考：\n\n * how to use inline functions in react applications efficiently\n * javascript - need to understand inline function call with react fc - stack overflow\n * react, inline functions, and performance | by ryan florence | medium\n * when to usememo and usecallback\n * don’t over-engineer – page fault blog\n\n\n# react 如何解释响应式更新？\n\n原文\n\n * 当你的组件首次初始化，组件的 render 方法会被调用， 对你的视图生成一个轻量化的表示。从那个表示生成一串标记， 并注入到文档中。当你的数据发生了变化， render 方法会再次被调用。为了尽可能高效地执行更新， 我们会对前一次调用 render 方法返回的结果和新的调用结果进行区分， 并生成一个要应用于 dom 的最小更改集合。\n * render 返回的数据既不是一串字符串也不是一个 dom 节点 —— 而是一种表示 dom 应该是什么样子的轻量化描述。我们把这个过程称为协调。因为这样的重渲染实在太快了， 所以开发者不需要显式地指定数据绑定。\n * 在实践中，大多数 react 应用只会调用一次 root.render ()。参见：更新已渲染的元素。\n\n参见: 原文\n\n * render 方法 ：这里的 render 方法必然不是指的是 reactdom.render （新版本为 reactdom.createroot.render ） 这样的方法，我认为应该指的是 renderrootsync 和 renderrootconcurrent 方法。因为前者是针对 host 环境所提供的 render 方法，只会在首次渲染时执行一次，而后者则会在调度器回调之后执行，即 数据发生了变化会再次被调用 。\n * 轻量化的表示 ：指的是 fibertree 系统，数据结构总归是 轻量的 ，它体现了视图最新的状态和行为以及视图稳定的状态和行为。\n * 一串标记 ：指的是 effecttag list ，当然这里做过一些重构，但是总体思想未变， effecttag 体现对节点将要执行的增、删、改（mutation）操作，最终将应用到 dom 节点上。\n * 对前一次调用 render 方法返回的结果和新的调用结果进行区分 ：指的是 workinprogress fibertree 和 current fibertree 调和的过程，当然也包括了节点的 diff 过程。\n * 应用于 dom 的最小更改集合 ：指的是经过上述 diff 过程之后对 effecttag list 的搜集过程。\n * 调和（或者协调）的过程是生成 dom 的轻量化描述（vdom）的过程。\n\n\n# jsx 中 xss 处理\n\n原文\n\nreact dom 在渲染所有输入内容之前，默认会进行转义。\n\n在 jsx 中插入字符内容时是做了转义（escape）处理的，即将可能产生风险的特殊字符进行转义，参见：jsx 防止注入攻击。\n\n相反的，在向 jsx 中插入 html 时，如使用 dangerouslysetinnerhtml 时，react 并没有帮你将待插入的内容进行消毒，需要自行进行内容消毒。可以使用 jam3/no-sanitizer-with-danger 、theodo/risxss: risxss 规则以确保在使用 dangerouslysetinnerhtml 时正确的进行了消毒处理。\n\n原文\n\n"the prop name dangerouslysetinnerhtml is intentionally chosen to be frightening. ..."\n\n"after fully understanding the security ramifications and properly sanitizing the data..."\n\n使用如下的 sanitizer 处理消毒：\n\n * cure53/dompurify: dompurify - a dom-only, super-fast, uber-tolerant xss sanitizer for html, mathml and svg. dompurify works with a secure default, but offers a lot of configurability and hooks. demo:;\n\n * leizongmin/js-xss: sanitize untrusted html (to prevent xss) with a configuration specified by a whitelist;\n\n * yahooarchive/xss-filters: secure xss filters.;\n\n * lodash documentation - escape\n\n * milesj/interweave: 🌀 react library to safely render html, filter attributes, autowrap text with matchers, render emoji characters, and much more.\n\n * javascript - react.js: set innerhtml vs dangerouslysetinnerhtml - stack overflow\n\n\n# reactelement 与 dom element\n\n原文\n\n * 元素是构成 react 应用的最小砖块。\n * 元素描述了你在屏幕上想看到的内容。\n * 与浏览器的 dom 元素不同，react 元素是创建开销极小的普通对象。\n * react dom 会负责更新 dom 来与 react 元素保持一致。\n\njsx 的元素，即 reactelement，描述了最小视图渲染单元，其本质上是 javascript 对象所描述的虚拟节点，与 dom 元素完全不同。简单来说，我们把 reactelement 描述为 vdom，尽管它并没有实质性的 diff 过程。\n\nvdom 最大的特点是提供了开销较小的节点的逻辑抽象，这是众多的基于 vdom 和 diff 算法理念以实现节点的响应式更新的框架的理论来源。同时，vdom 本身也是防腐层（源于其抽象性），抹平了各种 host 环境的实现上的差异性。\n\nreactelement 将更新 dom 使其与自己保持一致，这种更新是局部的、批量的，它以标记的形式展开。注意，这里所说的 其与自己保持一致 并非 reactelement 与 dom 与直接的关联，中间还需经过 fibertree 的调和过程。\n\n\n# react 元素是不可变对象\n\n原文\n\nreact 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性。一个元素就像电影的单帧：它代表了某个特定时刻的 ui。\n\n参见：元素渲染 – 更新已渲染的元素\n\nreactelement 是静态的，reactelement 是不可变对象！\n\n要理解这个问题，先得理解前文所写的 react 渲染中的 “帧” 的概念，基于此，如果我们狭义的理解此 “帧” 即为 “视图帧” 的话，那么这里的 “帧” 就是通过 reactelement 所表现的！\n\nreactelement 在 react 整个渲染循环中充当什么样的角色呢？reactelement 提供了用户对想要的视图所有的静态的和可交互的描述和定义，这种组件的定义形式因 “寓动于静” 的原理而成为具有不同的状态和行为的视图的 “帧”。\n\nreactelement 在一次渲染之中是寂静的、静态的，它依托闭包的封闭特性而将此时此时的状态、属性、行为方式进行分发，或在视图中呈现，或成为视图交互时的行为绑定，这种静态所体现的正是组件或者组件视图的 “帧”。\n\n现在我们且聊一聊 “帧” 是如何被渲染的，由 reactelement 所描述的静态的帧是如何成为屏幕的视图呈现的呢？\n\nreact 组件的状态和行为模式是在 react 调和中的 batch 执行阶段被收集的，在这个阶段是页面视图最为稳定的时候，一个新的渲染或许已经被调度，但是被没有被调度器所回调。现在我们假设一个新的渲染回调将产生，现在浏览器将有足够的精力和时间去处理渲染的任务。在确认执行渲染任务时，组件的状态和行为模式将无法被继续收集，但是别担心，这个过程将会很短暂，并且渲染的任务是可以打断的，如果有高优先级的交互更新出现，我们可以给此次渲染按下暂停键。\n\n现在假设这次渲染并没有被打断，那个 react 将会去获取组件新的状态和行为模式了，reactelement 将会被注入最新的状态和行为模式并且交给 react，这个过程正是通过闭包实现的。现在 react 通过 jsx 脱水了组件的信息量，那么这个信息量将如何被最小化的执行呢？双缓存的 fibertree 的结构正是为此而生！\n\n我们从 reactelement 中脱水的信息量必须要经过处理和计算，才能降低更新所带来的高成本。刚才的分析还是从组件的层面来展开，现在我们将视角扩展对整个应用。应用是由组件树所构成的，组件又是由 reactelementtree 所构成的。react 并不从组件层面进行更新的原则决定了 react 必须对这样的树形结构采取更为有效的、低成本的数据结构进行处理。于是 fiber 便产生了，从应用的容器开始，到每一个叶子节点，react 将之处理为一棵由 fiber 节点所构成的树形结构，而且为了提升 dfs 的效率，除了 child 指针之外，fibertree 还采用了 parent 指针和 sibling 指针。\n\nreact 将从 reactelement 中获取的信息量注入到 fiber 节点之中，通过这种方式，react 对节点有了更多的控制权，这使得很多激动人心的功能得以实现。如果是首次渲染的话，构建这样的一棵 fibertree 确实将花费不菲，但是幸运的是 root.render 只会在应用挂载时执行一次，并且首次渲染也避开了 diff 过程节省了开销。\n\n如果是非首次渲染的话，那么内存中便存在两棵 fibertree，其中一棵是表征当前正在显示在页面中的稳定版本的 fibertree，我们可以理解为上一 “帧”，而另外一棵树则是要通过复用节点所构建的包含组件树最新状态和行为模式的 fibertree，我们可以理解为下一 “帧”。下面便是相邻的两 “帧” 的 diff 过程了，这是一个捕获和冒泡的过程，这样的过程使我们知道了新的一 “帧” 需要有哪些 “改动点”，而这样的 “改动点” 的集合便构成了 “应用于 dom 的最小更改集合”。至此， render 过程便结束了。值得注意的是， render 过程是在浏览器的空闲时间中完成的，而且此过程不会对当前所渲染的页面造成任何不稳定的影响！\n\n下面 commit 阶段便开始了，react 在 mutation 阶段对以上的 “改动点集合” 进行了处理，从 fiber 节点中我们将创建、更新或者删除 dom 节点的实例，两棵 fibertree 也将交换自己的 “角色”。之后浏览器将在空闲时间对 dom 树进行重排和重绘。这便是新的一 “帧” 真正落地的时刻。\n\n通过这样一个 “帧” 的渲染的过程，现在请你告诉我为什么 “react 元素是不可变对象”？因为 reactelement 从被 “截取” 那一刻起，它必须是静态的、可分析的，因为 react 正是通过这个的 “帧” 的 “采样”，来实现其内部的渲染机制！\n\n\n# 参考\n\n * 我们为什么要构建 react? – react blog\n * jsx',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"带着原理重读 React 官方文档（二）",frontmatter:{title:"带着原理重读 React 官方文档（二）",date:"2022-08-23T09:55:52.000Z",permalink:"/react/tour/dr-2/",categories:["react","React源码漂流记"],tags:[null]},regularPath:"/10.react/90.React%E6%BA%90%E7%A0%81%E6%BC%82%E6%B5%81%E8%AE%B0/910.react-docs-reading-2.html",relativePath:"10.react/90.React源码漂流记/910.react-docs-reading-2.md",key:"v-2e216f3f",path:"/react/tour/dr-2/",headers:[{level:2,title:"Props 的只读性和 State 的响应性",slug:"props-的只读性和-state-的响应性",normalizedTitle:"props 的只读性和 state 的响应性",charIndex:2},{level:3,title:"Props 的只读性",slug:"props-的只读性",normalizedTitle:"props 的只读性",charIndex:2},{level:3,title:"Props 的变化可能来自于 State",slug:"props-的变化可能来自于-state",normalizedTitle:"props 的变化可能来自于 state",charIndex:1630},{level:3,title:"重新渲染 !== 重新渲染DOM视图",slug:"重新渲染-重新渲染dom视图",normalizedTitle:"重新渲染！== 重新渲染 dom 视图",charIndex:2085},{level:3,title:"State 的响应性",slug:"state-的响应性",normalizedTitle:"state 的响应性",charIndex:14},{level:3,title:"正确地使用 State",slug:"正确地使用-state",normalizedTitle:"正确地使用 state",charIndex:3414},{level:2,title:"数据是向下流动的",slug:"数据是向下流动的",normalizedTitle:"数据是向下流动的",charIndex:4068},{level:3,title:"组件间不关心组件的实现细节",slug:"组件间不关心组件的实现细节",normalizedTitle:"组件间不关心组件的实现细节",charIndex:4521},{level:3,title:"“自上而下”的数据流",slug:"自上而下-的数据流",normalizedTitle:"“自上而下” 的数据流",charIndex:4896},{level:3,title:"React 因 Props 和 State 的变化而重新渲染",slug:"react-因-props-和-state-的变化而重新渲染",normalizedTitle:"react 因 props 和 state 的变化而重新渲染",charIndex:5527},{level:3,title:"State 是局部的",slug:"state-是局部的",normalizedTitle:"state 是局部的",charIndex:5844},{level:2,title:"事件处理",slug:"事件处理",normalizedTitle:"事件处理",charIndex:5959},{level:2,title:"React 与 Rxjs",slug:"react-与-rxjs",normalizedTitle:"react 与 rxjs",charIndex:6262},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:132}],readingTime:{text:"4 min read",minutes:3.145,time:188700,words:629},headersStr:"Props 的只读性和 State 的响应性 Props 的只读性 Props 的变化可能来自于 State 重新渲染 !== 重新渲染DOM视图 State 的响应性 正确地使用 State 数据是向下流动的 组件间不关心组件的实现细节 “自上而下”的数据流 React 因 Props 和 State 的变化而重新渲染 State 是局部的 事件处理 React 与 Rxjs 参考",content:'# Props 的只读性和 State 的响应性\n\n\n# Props 的只读性\n\n原文\n\n * 组件无论是使用函数声明还是通过 class 声明，都绝不能修改自身的 props。\n * 所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。\n\n参考：Props 的只读性\n\n此处引用 “纯函数” 的概念来说明 Props 的值应该是不可更改的。什么是纯函数呢？\n\nWIKI: 纯函数\n\n在程序设计中，若一个函数符合以下要求，则它可能被认为是纯函数：\n\n * 此函数在相同的输入值时，需产生相同的输出。函数的输出和输入值以外的其他隐藏信息或状态无关，也和由 I/O 设备产生的外部输出无关。\n * 该函数不能有语义上可观察的函数副作用，诸如 “触发事件”，使输出设备输出，或更改输出值以外物件的内容等。\n\n纯函数具有两个特征：\n\n * 相同的输入，总是会得到相同的输出。\n * 执行过程中没有任何副作用。\n\n注意不要以此认为函数式组件是纯函数，即使无状态函数式组件（完全受控组件）也才勉强算做纯函数，即使如此，组件的顶层也无法保证没有任何的副作用、不受组件外部环境的影响。但是好在函数式组件并不依赖于纯函数的原理，组件的可交互性和复杂性根本无法以纯函数保证！\n\n但是我们可以从纯函数的角度去思考组件的优化方向，纯函数本质上是从静态的观点去思考，提供更好的性能和稳定性保障。下面我们就从这个角度出发再次剖析组件的优化理解：\n\n * 尽量减少属性的变化，尤其是无效的变化（对于 memo 组件而言）。保持相同的属性，可以一定程度上减少组件的重复渲染。从源码中有：\n\n// reconcileSingleElement: src/react/packages/react-reconciler/src/ReactChildFiber.new.js\n// 复用节点\nconst existing = useFiber(child, element.props);\n// 新建节点\nconst created = createFiberFromElement(element, returnFiber.mode, lanes);\n\n\n1\n2\n3\n4\n5\n\n\n可以看出，React 从 JSX 中获取 Props，显然 Props 的引用是每次都发生了变化。意思就是说，如果父组件发生了重新渲染，正常情况下子组件一定会发生重新渲染。React 默认并不会对 Props 做浅比较，如果需要的话，需使用 PureComponent 或者 memo 。注意，这只能作为一种优化的手段，不能对此形成依赖的范式，因为这可能会造成意想不到的 bug。\n\n综上来看，要想完全成为纯函数式的组件，除了需要是无状态，还需要经过 memo 的缓存处理以保证属性无变化，这样 React 才能避开重新渲染。但是这样的场景，实际上使用场景很有限。\n\n * 组件顶层不应暴露任何副作用！\n\n副作用指的是函数在执行过程中产生了外部可观察变化。这种变化导致纯函数所执行的结果不可预测。这对于函数式组件很有借鉴意义。任何副作用都应该在 useEffect 或者 useLayoutEffect 中注册，不能暴露在组件的顶层环境。\n\n参考：\n\n * 纯函数是什么？怎么合理运用纯函数？\n * javascript - Does React make any guarantees that the `props` object reference stays stable? - Stack Overflow\n * How to use React.memo() to improve performance\n * RFClarification: why is `setState` asynchronous? · Issue #11527 · facebook/react\n\n\n# Props 的变化可能来自于 State\n\nProps 的变化归根结底是因为组件感知到祖先组件的状态的变化（引用变化），这种状态的变化通过 props 或者 context 的方式传递，能够被组件所捕捉到。\n\nProps 的变化从 State 的变化而被感知。当 React 意识到 Props 的变化时，已经是在渲染的过程中了。React 并不会因为 Props 的变化做出立即反应，而是通过 State 的变化间接地感知 Props 的变化。当然 Props 的变化对于单一组件而言，在内部 State 未发生变化的情况下，React 必须对其做出反应。当然更多的情况是，React 会得到一个新的 Props 的对象引用，从而重新渲染子组件。虽然这种情况可以通过一些方式来阻止，如通过浅比较甚至深比较的方式比对 Props 的变化，我们仍然会对 React 重新渲染的花费感到担忧。一个可以让我们如释重负的事实是，重新渲染并不是意味着重新渲染视图，视图仍然是按需渲染，这是 React 的原则。\n\n\n# 重新渲染！== 重新渲染 DOM 视图\n\n我们从上所讲的 “重新渲染” 并不是代表着 React 将重新创建 DOM 结构并渲染视图。这里的 “重新渲染” 意为组件的重新渲染，当然渲染必须要走调和的流程，在调和的过程中，组件中的节点仍然会被复用，同样地副作用标记也会进行下去。但是很快 React 会意识到组件中并无需要实质更新的节点。如果说要计算这种 “重新渲染” 的成本的话，我认为就是一次 DFS 的成本。这种成本跟创建 DOM 节点实例和渲染 DOM 节点相比要小得多。所以，我们大可舒心。\n\n\n# State 的响应性\n\n与 Vue 响应式原理不同，React 中单向数据流的模型决定了 React 对于响应式更新是粗粒度的、合并的和异步的。React 的响应式是应用级的，响应式的节奏遵循调度器的调度。如果我们同样从 “帧” 的观点来理解这种响应式的话，在 “帧” 与 “帧” 之间实际上是响应性的收集阶段，从这阶段在 React 中被称为 Batch 阶段可见一二，在 “帧” 的绘制（渲染到屏幕）阶段实际上是消费响应式的阶段，从这阶段的源码中你能看到很多 flush 、 Effect 类似的字眼。\n\n任何的响应式系统都需要解决两个问题：\n\n * 副作用的追踪。\n * 副作用的消费。\n\n现在我们来就这一点对比下 React 和 Vue 的响应式系统。\n\nVue3 中的响应式系统：\n\n * 副作用的追踪：ViewModal（响应式系统，如 ref 和 reactive ） 会追踪响应式数据的变化，并收集与响应性相关联的副作用（收集响应式通常需要一定的 API 入口），称为 track ；\n * 副作用的消费：当响应式数据改变而被追踪时， trigger 会消费收集到的副作用，副作用的执行会对 DOM 视图执行细粒度的更新。\n\nReact 中的响应式系统：\n\n * 副作用的追踪： Batch 阶段中，React 将从 setState 收集到更新，并形成更新队列。这种更新即是响应式数据的变化状态，它们将缓存于 React 的 Fiber 系统中。\n * 副作用的消费： Render 阶段，React 将消费收集到的更新并进行调和过程，调和过程将会影响到视图的渲染。\n\n可以看到，在实现响应式的特性上，React 和 Vue 实际上采取了不同的方式。不同的方式之间，响应式的细粒度不同，当然也各有利弊。但是不论是何种方式，都必须要保证 DOM 更新是细粒度的，而不可是全量的。\n\n注意\n\n也有一些观点认为，React 其实并没有很 Reactive。甚至 React 官网中也明确表示 React 的设计理念并没有那么 Reactive，这其中调度器的存在有很大的影响。React 坚持 pull 的方式，而非 push 的方式。参见：\n\n * How React isn\'t reactive, and why you shouldn\'t care - DEV Community 👩‍💻👨‍💻\n * Design Principles – React\n * Core Concepts | React-RxJS\n\n\n# 正确地使用 State\n\n原文\n\n关于 setState () 你应该了解三件事：\n\n * 不要直接修改 State\n * State 的更新可能是异步的\n * State 的更新会被合并\n\n对于 State 的理解，此三点是重中之重。从原理来理解这三点可能会更加的深刻。\n\nReact 中的 State 状态必须经过 setState 的收集才能才能被响应。State 在稳定组件渲染中是静态的，React 需要状态的副作用被观测到才能在下一次渲染中对 State 做出正确的响应。直接修改 State 没有任何的作用，因为 State 的变化并不会被观测，而是被丢弃。另外，Props 也是不可修改的，因为在组件中 Props 实际上是受控的数据。这背后的根本原因还是在于 React 的受控的渲染机制。\n\nState 的更新是异步的，原因有二：一是状态的变化是通过状态链表管理的；二是状态的变化（副作用）需要通过调度器的回调才能在渲染过程中被消费。至于这里为什么是说是 “可能”，我还不清楚是否有一定的方法可以使状态同步的被跟踪。既然 State 的更新是通过链表（环形链表）管理的，在真正的渲染时机时状态变化的副作用将会被批量的消费，因此，State 的更新会被合并。\n\n参考：\n\n * reactjs - Why React say "State Updates May Be Asynchronous", "maybe" but not "must"? - Stack Overflow\n\n\n# 数据是向下流动的\n\nReact 中对于单向数据流的思想解释的非常巧妙和深刻。\n\n原文\n\n * 不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。但是组件可以选择把它的 state 作为 props 向下传递到它的子组件中。这通常会被叫做 “自上而下” 或是 “单向” 的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中 “低于” 它们的组件。\n * 如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。\n * 在 React 应用中，组件是有状态组件还是无状态组件属于组件实现的细节，它可能会随着时间的推移而改变。你可以在有状态的组件中使用无状态的组件，反之亦然。\n\n\n# 组件间不关心组件的实现细节\n\n按照 React 基于 Props 和 State 的反向数据流模型，组件之间并不关心其实现的细节，如组件的类型、组件的状态等。（这和 Flutter 不同，Flutter 会严格区分有状态组件和无状态组件）。组件的实现细节只是承载和传递数据流的一种方式，只要能够符合 React 总体的数据流的原理，其实现可以是多样的。从组件树的角度来看，React 最大程度上实现了组件间的逻辑解耦，使得我们可以将类组件和函数式组件进行混用，同时也不用关注组件是否是有状态组件，但是这样做的代价是，React 调和器必然要为这样的复杂性买单，这也是其源码看似很复杂的原因。\n\n事实上，这并不代表 React 不关心组件的实现细节，React 关心组件的类型并提供组件的渲染和数据流的机制，也关心组件的状态以实现状态的更新。\n\n\n# “自上而下” 的数据流\n\n“自上而下” 的数据流核心在于 Props 的流动性，Props 可以从父组件流向子组件，这是构成 React 中数据流从根组件（祖先组件）流向叶子组件（子组件）的根本原因。当然如果单凭 Props 流动性还不足以支撑交互的复杂性，因为在相邻的两次 “渲染” 之间，Props 是静态的，况且 React 从根本上缺少了更新的驱动力，于是 State 的概念便应运而生。State 允许组件内部存在单向的数据流，并且这样的数据流可以转化为 Props “向下传递”！State 如此重要，是因为：\n\n * State 是 Props 变化的 “驱动力”。\n * State 是 React 渲染的 “驱动力”。\n\n这两个 “驱动力” 使得 State 的重要性完全不亚于 Props。\n\n * 绝大部分的 Props 的变化来源于 State 的变化。当然也有可能来源于 Props 的变化，但是如果 Props 的流动超过三层组件，就应该反思组件的结构设计是否合理，是否考虑使用状态管理工具了。State 的变化导致 Props 的变化，同时 React 调和器会关心 Props 的变化（Props 的最新状态），这使得 Props 的变化可以向下传递。\n * State 的变化驱动着 React 的渲染。State 的变化会发起渲染的调度请求，促使调度器产生回调。如果没有 State，React 就不能实现更新渲染！\n\n\n# React 因 Props 和 State 的变化而重新渲染\n\n关于 Props 和 State 变化引起 React 重新渲染，有如下的区别：\n\n * Props 的变化是被动的被调和器所感知的，React 并不收集 Props 的变化。\n * State 的变化时主动的被调和器所感知的（经由调度器），React 会主动的收集 State 的变化。\n\n这两种的区别，便是 “主动” 和 “被动” 的区别，也是 “push” 和 “pull” 的区别。\n\nState 才是 React 重新渲染的根本原因。Props 的变化会是 React 重新渲染，但是 Props 的变化在大部分时间是还 State 的变化所影响的。\n\n\n# State 是局部的\n\nState 是局部的，是组件内部封闭的。但是 State 如果转化为 Context 就可以为组件树所公用，这得益于 context.Provider 实现了基于组件树的、局部的、封闭的状态共享。\n\n\n# 事件处理\n\n原文\n\n * 在 React 中另一个不同点是你不能通过返回 false 的方式阻止默认行为。你必须显式地使用 preventDefault。\n * e 是一个合成事件。React 根据 W3C 规范来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。React 事件与原生事件不完全相同。\n\nReact 中事件处理与原生 DOM 稍有不同，在原生的 DOM 中，通常需要操作 DOM 并通过 addEventListener 添加事件监听器。React 中有完整的事件系统，所有的事件均在 JSX 中显式地定义和绑定。事件绑定以 Props 的方式落实在 DOM 上，支持传递\n\n\n# React 与 Rxjs\n\n参考：\n\n * Rxjs + React 实战，看完你就知道为什么说 angular 在 5 年后等你 - 知乎\n * Reactive Programming with React and RxJs | Better Programming\n\n参考：\n\n * A Visual Guide to React Rendering - Props | Alex Sidorenko\n * reactjs - React: Parent component re-renders all children, even those that haven\'t changed on state change - Stack Overflow\n * State & 生命周期 – React\n\n\n# 参考',normalizedContent:'# props 的只读性和 state 的响应性\n\n\n# props 的只读性\n\n原文\n\n * 组件无论是使用函数声明还是通过 class 声明，都绝不能修改自身的 props。\n * 所有 react 组件都必须像纯函数一样保护它们的 props 不被更改。\n\n参考：props 的只读性\n\n此处引用 “纯函数” 的概念来说明 props 的值应该是不可更改的。什么是纯函数呢？\n\nwiki: 纯函数\n\n在程序设计中，若一个函数符合以下要求，则它可能被认为是纯函数：\n\n * 此函数在相同的输入值时，需产生相同的输出。函数的输出和输入值以外的其他隐藏信息或状态无关，也和由 i/o 设备产生的外部输出无关。\n * 该函数不能有语义上可观察的函数副作用，诸如 “触发事件”，使输出设备输出，或更改输出值以外物件的内容等。\n\n纯函数具有两个特征：\n\n * 相同的输入，总是会得到相同的输出。\n * 执行过程中没有任何副作用。\n\n注意不要以此认为函数式组件是纯函数，即使无状态函数式组件（完全受控组件）也才勉强算做纯函数，即使如此，组件的顶层也无法保证没有任何的副作用、不受组件外部环境的影响。但是好在函数式组件并不依赖于纯函数的原理，组件的可交互性和复杂性根本无法以纯函数保证！\n\n但是我们可以从纯函数的角度去思考组件的优化方向，纯函数本质上是从静态的观点去思考，提供更好的性能和稳定性保障。下面我们就从这个角度出发再次剖析组件的优化理解：\n\n * 尽量减少属性的变化，尤其是无效的变化（对于 memo 组件而言）。保持相同的属性，可以一定程度上减少组件的重复渲染。从源码中有：\n\n// reconcilesingleelement: src/react/packages/react-reconciler/src/reactchildfiber.new.js\n// 复用节点\nconst existing = usefiber(child, element.props);\n// 新建节点\nconst created = createfiberfromelement(element, returnfiber.mode, lanes);\n\n\n1\n2\n3\n4\n5\n\n\n可以看出，react 从 jsx 中获取 props，显然 props 的引用是每次都发生了变化。意思就是说，如果父组件发生了重新渲染，正常情况下子组件一定会发生重新渲染。react 默认并不会对 props 做浅比较，如果需要的话，需使用 purecomponent 或者 memo 。注意，这只能作为一种优化的手段，不能对此形成依赖的范式，因为这可能会造成意想不到的 bug。\n\n综上来看，要想完全成为纯函数式的组件，除了需要是无状态，还需要经过 memo 的缓存处理以保证属性无变化，这样 react 才能避开重新渲染。但是这样的场景，实际上使用场景很有限。\n\n * 组件顶层不应暴露任何副作用！\n\n副作用指的是函数在执行过程中产生了外部可观察变化。这种变化导致纯函数所执行的结果不可预测。这对于函数式组件很有借鉴意义。任何副作用都应该在 useeffect 或者 uselayouteffect 中注册，不能暴露在组件的顶层环境。\n\n参考：\n\n * 纯函数是什么？怎么合理运用纯函数？\n * javascript - does react make any guarantees that the `props` object reference stays stable? - stack overflow\n * how to use react.memo() to improve performance\n * rfclarification: why is `setstate` asynchronous? · issue #11527 · facebook/react\n\n\n# props 的变化可能来自于 state\n\nprops 的变化归根结底是因为组件感知到祖先组件的状态的变化（引用变化），这种状态的变化通过 props 或者 context 的方式传递，能够被组件所捕捉到。\n\nprops 的变化从 state 的变化而被感知。当 react 意识到 props 的变化时，已经是在渲染的过程中了。react 并不会因为 props 的变化做出立即反应，而是通过 state 的变化间接地感知 props 的变化。当然 props 的变化对于单一组件而言，在内部 state 未发生变化的情况下，react 必须对其做出反应。当然更多的情况是，react 会得到一个新的 props 的对象引用，从而重新渲染子组件。虽然这种情况可以通过一些方式来阻止，如通过浅比较甚至深比较的方式比对 props 的变化，我们仍然会对 react 重新渲染的花费感到担忧。一个可以让我们如释重负的事实是，重新渲染并不是意味着重新渲染视图，视图仍然是按需渲染，这是 react 的原则。\n\n\n# 重新渲染！== 重新渲染 dom 视图\n\n我们从上所讲的 “重新渲染” 并不是代表着 react 将重新创建 dom 结构并渲染视图。这里的 “重新渲染” 意为组件的重新渲染，当然渲染必须要走调和的流程，在调和的过程中，组件中的节点仍然会被复用，同样地副作用标记也会进行下去。但是很快 react 会意识到组件中并无需要实质更新的节点。如果说要计算这种 “重新渲染” 的成本的话，我认为就是一次 dfs 的成本。这种成本跟创建 dom 节点实例和渲染 dom 节点相比要小得多。所以，我们大可舒心。\n\n\n# state 的响应性\n\n与 vue 响应式原理不同，react 中单向数据流的模型决定了 react 对于响应式更新是粗粒度的、合并的和异步的。react 的响应式是应用级的，响应式的节奏遵循调度器的调度。如果我们同样从 “帧” 的观点来理解这种响应式的话，在 “帧” 与 “帧” 之间实际上是响应性的收集阶段，从这阶段在 react 中被称为 batch 阶段可见一二，在 “帧” 的绘制（渲染到屏幕）阶段实际上是消费响应式的阶段，从这阶段的源码中你能看到很多 flush 、 effect 类似的字眼。\n\n任何的响应式系统都需要解决两个问题：\n\n * 副作用的追踪。\n * 副作用的消费。\n\n现在我们来就这一点对比下 react 和 vue 的响应式系统。\n\nvue3 中的响应式系统：\n\n * 副作用的追踪：viewmodal（响应式系统，如 ref 和 reactive ） 会追踪响应式数据的变化，并收集与响应性相关联的副作用（收集响应式通常需要一定的 api 入口），称为 track ；\n * 副作用的消费：当响应式数据改变而被追踪时， trigger 会消费收集到的副作用，副作用的执行会对 dom 视图执行细粒度的更新。\n\nreact 中的响应式系统：\n\n * 副作用的追踪： batch 阶段中，react 将从 setstate 收集到更新，并形成更新队列。这种更新即是响应式数据的变化状态，它们将缓存于 react 的 fiber 系统中。\n * 副作用的消费： render 阶段，react 将消费收集到的更新并进行调和过程，调和过程将会影响到视图的渲染。\n\n可以看到，在实现响应式的特性上，react 和 vue 实际上采取了不同的方式。不同的方式之间，响应式的细粒度不同，当然也各有利弊。但是不论是何种方式，都必须要保证 dom 更新是细粒度的，而不可是全量的。\n\n注意\n\n也有一些观点认为，react 其实并没有很 reactive。甚至 react 官网中也明确表示 react 的设计理念并没有那么 reactive，这其中调度器的存在有很大的影响。react 坚持 pull 的方式，而非 push 的方式。参见：\n\n * how react isn\'t reactive, and why you shouldn\'t care - dev community 👩‍💻👨‍💻\n * design principles – react\n * core concepts | react-rxjs\n\n\n# 正确地使用 state\n\n原文\n\n关于 setstate () 你应该了解三件事：\n\n * 不要直接修改 state\n * state 的更新可能是异步的\n * state 的更新会被合并\n\n对于 state 的理解，此三点是重中之重。从原理来理解这三点可能会更加的深刻。\n\nreact 中的 state 状态必须经过 setstate 的收集才能才能被响应。state 在稳定组件渲染中是静态的，react 需要状态的副作用被观测到才能在下一次渲染中对 state 做出正确的响应。直接修改 state 没有任何的作用，因为 state 的变化并不会被观测，而是被丢弃。另外，props 也是不可修改的，因为在组件中 props 实际上是受控的数据。这背后的根本原因还是在于 react 的受控的渲染机制。\n\nstate 的更新是异步的，原因有二：一是状态的变化是通过状态链表管理的；二是状态的变化（副作用）需要通过调度器的回调才能在渲染过程中被消费。至于这里为什么是说是 “可能”，我还不清楚是否有一定的方法可以使状态同步的被跟踪。既然 state 的更新是通过链表（环形链表）管理的，在真正的渲染时机时状态变化的副作用将会被批量的消费，因此，state 的更新会被合并。\n\n参考：\n\n * reactjs - why react say "state updates may be asynchronous", "maybe" but not "must"? - stack overflow\n\n\n# 数据是向下流动的\n\nreact 中对于单向数据流的思想解释的非常巧妙和深刻。\n\n原文\n\n * 不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。但是组件可以选择把它的 state 作为 props 向下传递到它的子组件中。这通常会被叫做 “自上而下” 或是 “单向” 的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 ui 只能影响树中 “低于” 它们的组件。\n * 如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。\n * 在 react 应用中，组件是有状态组件还是无状态组件属于组件实现的细节，它可能会随着时间的推移而改变。你可以在有状态的组件中使用无状态的组件，反之亦然。\n\n\n# 组件间不关心组件的实现细节\n\n按照 react 基于 props 和 state 的反向数据流模型，组件之间并不关心其实现的细节，如组件的类型、组件的状态等。（这和 flutter 不同，flutter 会严格区分有状态组件和无状态组件）。组件的实现细节只是承载和传递数据流的一种方式，只要能够符合 react 总体的数据流的原理，其实现可以是多样的。从组件树的角度来看，react 最大程度上实现了组件间的逻辑解耦，使得我们可以将类组件和函数式组件进行混用，同时也不用关注组件是否是有状态组件，但是这样做的代价是，react 调和器必然要为这样的复杂性买单，这也是其源码看似很复杂的原因。\n\n事实上，这并不代表 react 不关心组件的实现细节，react 关心组件的类型并提供组件的渲染和数据流的机制，也关心组件的状态以实现状态的更新。\n\n\n# “自上而下” 的数据流\n\n“自上而下” 的数据流核心在于 props 的流动性，props 可以从父组件流向子组件，这是构成 react 中数据流从根组件（祖先组件）流向叶子组件（子组件）的根本原因。当然如果单凭 props 流动性还不足以支撑交互的复杂性，因为在相邻的两次 “渲染” 之间，props 是静态的，况且 react 从根本上缺少了更新的驱动力，于是 state 的概念便应运而生。state 允许组件内部存在单向的数据流，并且这样的数据流可以转化为 props “向下传递”！state 如此重要，是因为：\n\n * state 是 props 变化的 “驱动力”。\n * state 是 react 渲染的 “驱动力”。\n\n这两个 “驱动力” 使得 state 的重要性完全不亚于 props。\n\n * 绝大部分的 props 的变化来源于 state 的变化。当然也有可能来源于 props 的变化，但是如果 props 的流动超过三层组件，就应该反思组件的结构设计是否合理，是否考虑使用状态管理工具了。state 的变化导致 props 的变化，同时 react 调和器会关心 props 的变化（props 的最新状态），这使得 props 的变化可以向下传递。\n * state 的变化驱动着 react 的渲染。state 的变化会发起渲染的调度请求，促使调度器产生回调。如果没有 state，react 就不能实现更新渲染！\n\n\n# react 因 props 和 state 的变化而重新渲染\n\n关于 props 和 state 变化引起 react 重新渲染，有如下的区别：\n\n * props 的变化是被动的被调和器所感知的，react 并不收集 props 的变化。\n * state 的变化时主动的被调和器所感知的（经由调度器），react 会主动的收集 state 的变化。\n\n这两种的区别，便是 “主动” 和 “被动” 的区别，也是 “push” 和 “pull” 的区别。\n\nstate 才是 react 重新渲染的根本原因。props 的变化会是 react 重新渲染，但是 props 的变化在大部分时间是还 state 的变化所影响的。\n\n\n# state 是局部的\n\nstate 是局部的，是组件内部封闭的。但是 state 如果转化为 context 就可以为组件树所公用，这得益于 context.provider 实现了基于组件树的、局部的、封闭的状态共享。\n\n\n# 事件处理\n\n原文\n\n * 在 react 中另一个不同点是你不能通过返回 false 的方式阻止默认行为。你必须显式地使用 preventdefault。\n * e 是一个合成事件。react 根据 w3c 规范来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。react 事件与原生事件不完全相同。\n\nreact 中事件处理与原生 dom 稍有不同，在原生的 dom 中，通常需要操作 dom 并通过 addeventlistener 添加事件监听器。react 中有完整的事件系统，所有的事件均在 jsx 中显式地定义和绑定。事件绑定以 props 的方式落实在 dom 上，支持传递\n\n\n# react 与 rxjs\n\n参考：\n\n * rxjs + react 实战，看完你就知道为什么说 angular 在 5 年后等你 - 知乎\n * reactive programming with react and rxjs | better programming\n\n参考：\n\n * a visual guide to react rendering - props | alex sidorenko\n * reactjs - react: parent component re-renders all children, even those that haven\'t changed on state change - stack overflow\n * state & 生命周期 – react\n\n\n# 参考',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/index/",categories:["vue3"],tags:[null]},regularPath:"/20.vue3/0.index.html",relativePath:"20.vue3/0.index.md",key:"v-1d06307d",path:"/vue3/index/",headers:[{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:2},{level:2,title:"阅读方法",slug:"阅读方法",normalizedTitle:"阅读方法",charIndex:273},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:395},{level:2,title:"TODO 计划",slug:"todo-计划",normalizedTitle:"todo 计划",charIndex:436},{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:448}],readingTime:{text:"1 min read",minutes:.415,time:24900,words:83},headersStr:"说明 阅读方法 参考资料 TODO 计划 目录",content:"# 说明\n\n在这里我先要说明一些事项，以作为阅读之前的提醒。\n\n事项          描述\nvue3 版本     v3.1.4\nIDE         VScode\n静态生成器       VuePress\n源码 Repo     Repo\n笔记源码 Repo   jonsam-ng/fancy-front-end\n笔记地址        source.jonsam.site\n阅读重点        reactivity、runtime-core、runtime-dom\n阅读方式        运行源码、源码标注、笔记分析总结\n\n\n# 阅读方法\n\n 1. 运行和调试 vue 源码。\n\ngit clone https://github.com/jonsam-ng/vue-next.git\nyarn \n\n\n1\n2\n\n 2. 按照一定的阅读顺序阅读源码，请先阅读基础部分。\n\n\n# 参考资料\n\n * vue3js.cn\n * vue3 源码解析和最佳实践\n\n\n# TODO 计划\n\n\n# 目录",normalizedContent:"# 说明\n\n在这里我先要说明一些事项，以作为阅读之前的提醒。\n\n事项          描述\nvue3 版本     v3.1.4\nide         vscode\n静态生成器       vuepress\n源码 repo     repo\n笔记源码 repo   jonsam-ng/fancy-front-end\n笔记地址        source.jonsam.site\n阅读重点        reactivity、runtime-core、runtime-dom\n阅读方式        运行源码、源码标注、笔记分析总结\n\n\n# 阅读方法\n\n 1. 运行和调试 vue 源码。\n\ngit clone https://github.com/jonsam-ng/vue-next.git\nyarn \n\n\n1\n2\n\n 2. 按照一定的阅读顺序阅读源码，请先阅读基础部分。\n\n\n# 参考资料\n\n * vue3js.cn\n * vue3 源码解析和最佳实践\n\n\n# todo 计划\n\n\n# 目录",charsets:{cjk:!0},lastUpdated:"2022/07/13, 18:32:13",lastUpdatedTimestamp:1657708333e3},{title:"plan 计划",frontmatter:{title:"plan 计划",date:"2022-04-16T15:41:35.000Z",permalink:"/vue3/plan/",categories:["vue3"],tags:[null]},regularPath:"/20.vue3/1.plan.html",relativePath:"20.vue3/1.plan.md",key:"v-cecea10e",path:"/vue3/plan/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/16, 15:48:02",lastUpdatedTimestamp:1650095282e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/basic/index/",categories:["vue3","basic"],tags:[null]},regularPath:"/20.vue3/10.%E5%9F%BA%E7%A1%80/0.index.html",relativePath:"20.vue3/10.基础/0.index.md",key:"v-620539aa",path:"/vue3/basic/index/",readingTime:{text:"0 min read",minutes:0,time:0,words:0},headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/reactivity/index/",categories:["vue3","reactivity"],tags:[null]},regularPath:"/20.vue3/20.reactivity/0.index.html",relativePath:"20.vue3/20.reactivity/0.index.md",key:"v-5d322c1d",path:"/vue3/reactivity/index/",headers:[{level:2,title:"Reactivity Api",slug:"reactivity-api",normalizedTitle:"reactivity api",charIndex:120},{level:2,title:"文件及作用",slug:"文件及作用",normalizedTitle:"文件及作用",charIndex:2922},{level:2,title:"参考文档",slug:"参考文档",normalizedTitle:"参考文档",charIndex:3325}],readingTime:{text:"3 min read",minutes:2.345,time:140700.00000000003,words:469},headersStr:"Reactivity Api 文件及作用 参考文档",content:"reactivity 主要是关于 vue 中响应式的源码，源码在 reactivity 目录中。查看源码的导出情况响应式这块主要包含 ref、reactive、computed、effect 和 operations 5 个部分。\n\n\n# Reactivity Api\n\nexport {\n  ref, // Takes an inner value and returns a reactive and mutable ref object.The ref object has a single property .value that points to the inner value.\n  shallowRef, // Creates a ref that tracks its own .value mutation but doesn't make its value reactive.\n  isRef, // Checks if a value is a ref object.\n  toRef, // Can be used to create a ref for a property on a source reactive object.\n  toRefs, // Converts a reactive object to a plain object where each property of the resulting object is a ref pointing to the corresponding property of the original object.\n  unref, // Returns the inner value if the argument is a ref, otherwise return the argument itself.\n  proxyRefs,\n  customRef, // Creates a customized ref with explicit control over its dependency tracking and updates triggering. It expects a factory function, which receives track and trigger functions as arguments and should return an object with get and set.\n  triggerRef, // Execute any effects tied to a shallowRef manually.\n  Ref,\n  ToRefs,\n  UnwrapRef,\n  ShallowUnwrapRef,\n  RefUnwrapBailTypes\n} from './ref'\nexport {\n  reactive, // Returns a reactive copy of the object.\n  readonly, // Takes an object (reactive or plain) or a ref and returns a readonly proxy to the original.\n  isReactive, // Checks if an object is a reactive proxy created by reactive.\n  isReadonly, // Checks if an object is a readonly proxy created by readonly.\n  isProxy, // Checks if an object is a proxy created by reactive or readonly.\n  shallowReactive, // Creates a reactive proxy that tracks reactivity of its own properties but does not perform deep reactive conversion of nested objects (exposes raw values).\n  shallowReadonly, // Creates a proxy that makes its own properties readonly, but does not perform deep readonly conversion of nested objects (exposes raw values).\n  markRaw, // Marks an object so that it will never be converted to a proxy.\n  toRaw, // Returns the raw, original object of a reactive or readonly proxy.\n  ReactiveFlags,\n  DeepReadonly,\n  UnwrapNestedRefs\n} from './reactive'\nexport {\n  computed, // Takes a getter function and returns an immutable reactive ref object for the returned value from the getter.\n  ComputedRef,\n  WritableComputedRef,\n  WritableComputedOptions,\n  ComputedGetter,\n  ComputedSetter\n} from './computed'\nexport {\n  effect,\n  stop,\n  trigger,\n  track,\n  enableTracking,\n  pauseTracking,\n  resetTracking,\n  ITERATE_KEY,\n  ReactiveEffect,\n  ReactiveEffectOptions,\n  DebuggerEvent\n} from './effect'\nexport { TrackOpTypes, TriggerOpTypes } from './operations'\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n以上注释部分均属于 Reactivity Api，effect 部分属于副作用，这部分将在 runtime-core 中引用。\n\n\n# 文件及作用\n\nreactivity 模块中包括如下文件：\n\npackages/reactivity/src\n├── baseHandlers.ts // COMMON type: array/object proxy handlers.\n├── collectionHandlers.ts // COLLECTION type: map/set/weakSet/weakMap proxy handlers.\n├── computed.ts // 计算响应式\n├── effect.ts // 依赖（副作用）收集和管理\n├── index.ts // 导出 API\n├── operations.ts // operations 相关\n├── reactive.ts // reactive 相关 API\n└── ref.ts // ref 相关 API\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 参考文档\n\n * vue3 docs: Reactivity API\n * vue3 中文文档：响应式 API",normalizedContent:"reactivity 主要是关于 vue 中响应式的源码，源码在 reactivity 目录中。查看源码的导出情况响应式这块主要包含 ref、reactive、computed、effect 和 operations 5 个部分。\n\n\n# reactivity api\n\nexport {\n  ref, // takes an inner value and returns a reactive and mutable ref object.the ref object has a single property .value that points to the inner value.\n  shallowref, // creates a ref that tracks its own .value mutation but doesn't make its value reactive.\n  isref, // checks if a value is a ref object.\n  toref, // can be used to create a ref for a property on a source reactive object.\n  torefs, // converts a reactive object to a plain object where each property of the resulting object is a ref pointing to the corresponding property of the original object.\n  unref, // returns the inner value if the argument is a ref, otherwise return the argument itself.\n  proxyrefs,\n  customref, // creates a customized ref with explicit control over its dependency tracking and updates triggering. it expects a factory function, which receives track and trigger functions as arguments and should return an object with get and set.\n  triggerref, // execute any effects tied to a shallowref manually.\n  ref,\n  torefs,\n  unwrapref,\n  shallowunwrapref,\n  refunwrapbailtypes\n} from './ref'\nexport {\n  reactive, // returns a reactive copy of the object.\n  readonly, // takes an object (reactive or plain) or a ref and returns a readonly proxy to the original.\n  isreactive, // checks if an object is a reactive proxy created by reactive.\n  isreadonly, // checks if an object is a readonly proxy created by readonly.\n  isproxy, // checks if an object is a proxy created by reactive or readonly.\n  shallowreactive, // creates a reactive proxy that tracks reactivity of its own properties but does not perform deep reactive conversion of nested objects (exposes raw values).\n  shallowreadonly, // creates a proxy that makes its own properties readonly, but does not perform deep readonly conversion of nested objects (exposes raw values).\n  markraw, // marks an object so that it will never be converted to a proxy.\n  toraw, // returns the raw, original object of a reactive or readonly proxy.\n  reactiveflags,\n  deepreadonly,\n  unwrapnestedrefs\n} from './reactive'\nexport {\n  computed, // takes a getter function and returns an immutable reactive ref object for the returned value from the getter.\n  computedref,\n  writablecomputedref,\n  writablecomputedoptions,\n  computedgetter,\n  computedsetter\n} from './computed'\nexport {\n  effect,\n  stop,\n  trigger,\n  track,\n  enabletracking,\n  pausetracking,\n  resettracking,\n  iterate_key,\n  reactiveeffect,\n  reactiveeffectoptions,\n  debuggerevent\n} from './effect'\nexport { trackoptypes, triggeroptypes } from './operations'\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n以上注释部分均属于 reactivity api，effect 部分属于副作用，这部分将在 runtime-core 中引用。\n\n\n# 文件及作用\n\nreactivity 模块中包括如下文件：\n\npackages/reactivity/src\n├── basehandlers.ts // common type: array/object proxy handlers.\n├── collectionhandlers.ts // collection type: map/set/weakset/weakmap proxy handlers.\n├── computed.ts // 计算响应式\n├── effect.ts // 依赖（副作用）收集和管理\n├── index.ts // 导出 api\n├── operations.ts // operations 相关\n├── reactive.ts // reactive 相关 api\n└── ref.ts // ref 相关 api\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 参考文档\n\n * vue3 docs: reactivity api\n * vue3 中文文档：响应式 api",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"Ref",frontmatter:{title:"Ref",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/reactivity/ref/",categories:["vue3","reactivity"],tags:[null]},regularPath:"/20.vue3/20.reactivity/10.ref.html",relativePath:"20.vue3/20.reactivity/10.ref.md",key:"v-dcaaef7a",path:"/vue3/reactivity/ref/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"ref",slug:"ref",normalizedTitle:"ref",charIndex:17},{level:2,title:"shallowRef",slug:"shallowref",normalizedTitle:"shallowref",charIndex:24},{level:2,title:"isRef",slug:"isref",normalizedTitle:"isref",charIndex:38},{level:2,title:"toRef",slug:"toref",normalizedTitle:"toref",charIndex:47},{level:2,title:"toRefs",slug:"torefs",normalizedTitle:"torefs",charIndex:56},{level:2,title:"unref",slug:"unref",normalizedTitle:"unref",charIndex:66},{level:2,title:"customRef",slug:"customref",normalizedTitle:"customref",charIndex:75},{level:2,title:"triggerRef",slug:"triggerref",normalizedTitle:"triggerref",charIndex:88},{level:2,title:"文章小结",slug:"文章小结",normalizedTitle:"文章小结",charIndex:102}],readingTime:{text:"5 min read",minutes:4.8,time:288e3,words:960},headersStr:"目录 ref shallowRef isRef toRef toRefs unref customRef triggerRef 文章小结",content:"# 目录\n\n\n\n * 目录\n * ref\n * shallowRef\n * isRef\n * toRef\n * toRefs\n * unref\n * customRef\n * triggerRef\n * 文章小结\n\n\n\n\n# ref\n\n官网释义\n\nTakes an inner value and returns a reactive and mutable ref object. The ref object has a single property .value that points to the inner value.\n\n接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象具有指向内部值的单个 property .value。\n\n * ref 接受一个 unknown 类型的值，内部调用了 createRef 函数。\n * createRef 内部对于本身已经是 ref 的传值返回其本身，返回了一个 RefImpl 对象实例。有此可见一个 ref 兑现个，实际上是一个 RefImpl 的对象实例。同时我们注意到，ref 传入 RefImpl 中 shadow 的值是 false。也就是 ref 创建的响应式是 deep reactivity 的。\n\nexport function ref(value?: unknown) {\n  return createRef(value)\n}\nfunction createRef(rawValue: unknown, shallow = false) {\n  if (isRef(rawValue)) {\n    return rawValue\n  }\n  return new RefImpl(rawValue, shallow)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n接着我们来看下核心 class RefImpl:\n\nclass RefImpl<T> {\n  private _value: T\n\n  public readonly __v_isRef = true\n\n  // 如果 shadow 或者是不是对象 则 _rawValue，是对象就调 reactive。\n  // 这里给 _value 赋初始值\n  constructor(private _rawValue: T, public readonly _shallow: boolean) {\n    // 初始化设置值\n    this._value = _shallow ? _rawValue : convert(_rawValue)\n  }\n  \n  get value() {\n    // 初始化依赖收集，这里的 target 是 row target\n    track(toRaw(this), TrackOpTypes.GET, 'value')\n    return this._value\n  }\n\n  set value(newVal) {\n    // 检查值是否有变化，只有有变化时才出发 setter\n    // this._rawValue 是上一次 set 时传的 rowValue\n    if (hasChanged(toRaw(newVal), this._rawValue)) {\n      this._rawValue = newVal\n      this._value = this._shallow ? newVal : convert(newVal)\n      // 触发（消费）依赖集合，注意这里传入了 newVal\n      trigger(toRaw(this), TriggerOpTypes.SET, 'value', newVal)\n    }\n  }\n}\n// 如果是传入对象就简介调用 reactive\nconst convert = <T extends unknown>(val: T): T =>\n  isObject(val) ? reactive(val) : val\n// compare whether a value has changed, accounting for NaN.\n// 这里是考虑到 NaN 的情况，因为 NaN === NaN 是 false，但是 null === null 是 true。\nexport const hasChanged = (value: any, oldValue: any): boolean =>\n  value !== oldValue && (value === value || oldValue === oldValue)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n * 在这段代码中，实现了 ref 的响应式，我们知道 vue 的响应式都是基于对响应式 target 的值的 get 和 set 的拦截来实现的，简单的说就是 在 get 时对 target 进行依赖收集，在 set 时触发依赖回调集合来实现响应式的。在 vue2 中的 Object.defineProperty ()，以及 vue3 中的 Proxy 都是这样的原理。\n * _value 维护了 ref 中响应式的值，__v_isRef 是 ref 对象的身份标识。后文中 isRef 正在通过这个表示来辨别 ref 对象。\n * getter 和 setter 属于 es6 的语法。在 value 的 getter 中调用了 track 函数，这个函数对 target 也就是 toRaw (this) 进行了依赖收集，也就是任何应用到当前的 ref 值的地方都会被记录。在 value 的 setter 中先是比较新值和旧值是否有变化，只有变化的值才会引起响应式更新，trigger 函数正在对当前 target 所收集的依赖进行执行。track 和 trigger 实际上是使用了订阅发布的设计模式，我们将会在 effect 部分详细分析。\n * 响应式我们已经有 reactive 了，为什么还要有 ref？ 从 convert 的代码中可以看出，ref 的传值如果是 object 时实际上是间接使用了 reactive 来保持 deep reactivity 的，然后才被包装成了 ref 对象。Proxy Api 是只用于 object 中的，这一点从 MDN 的解释 'The Proxy object enables you to create a proxy for another object, which can intercept and redefine fundamental operations for that object.' 可以看出。因此针对普通值类型的响应式，我们还是需要由 ref 来实现的。而且对于普通值类型的响应式而言，并不存在 object property 的劫持，仍然是一种很高效的响应式方法。\n\n参考资料：\n\n * MDN: Object.defineProperty\n * MDN: Proxy\n\n\n# shallowRef\n\n官网释义\n\nCreates a ref that tracks its own .value mutation but doesn't make its value reactive.\n\n创建一个跟踪自身 .value 变化的 ref，但不会使其值也变成响应式的。\n\nexport function shallowRef(value?: unknown) {\n  return createRef(value, true)\n}\n\n\n1\n2\n3\n\n\n可以看到，shallowRef 同样是调用 shallowRef，只不过 _shallow 传入了 true。与 ref 不同点就在于：在针对 object 的 setter 时，并不在是使用 reactive 了，而是直接使用_rawValue。有此可见，如果传入了 Object，则只是 object 顶层响应式的，也就是 ref.value 是响应式的，这是的 isReactive (ref.value) 应该是 false 。\n\n\n# isRef\n\n官网释义\n\nChecks if a value is a ref object.\n\n检查值是否为一个 ref 对象。\n\nexport function isRef(r: any): r is Ref {\n  return Boolean(r && r.__v_isRef === true)\n}\n\n\n1\n2\n3\n\n\n根据 __v_isRef 标志判断是否是 ref 对象。\n\n\n# toRef\n\n官网释义\n\nCan be used to create a ref for a property on a source reactive object. The ref can then be passed around, retaining the reactive connection to its source property.\n\n可以用来为源响应式对象上的某个 property 新创建一个 ref。然后，ref 可以被传递，它会保持对其源 property 的响应式连接。\n\nexport function toRef<T extends object, K extends keyof T>(\n  object: T,\n  key: K\n): ToRef<T[K]> {\n  return isRef(object[key])\n    ? object[key]\n    : (new ObjectRefImpl(object, key) as any)\n}\nclass ObjectRefImpl<T extends object, K extends keyof T> {\n  public readonly __v_isRef = true\n\n  constructor(private readonly _object: T, private readonly _key: K) {}\n\n  get value() {\n    return this._object[this._key]\n  }\n\n  set value(newVal) {\n    this._object[this._key] = newVal\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n内部仍然是 ObjectRefImpl 实现。\n\n\n# toRefs\n\n官网释义\n\nConverts a reactive object to a plain object where each property of the resulting object is a ref pointing to the corresponding property of the original object.\n\n将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 ref。\n\nexport function toRefs<T extends object>(object: T): ToRefs<T> {\n  const ret: any = isArray(object) ? new Array(object.length) : {}\n  for (const key in object) {\n    ret[key] = toRef(object, key)\n  }\n  return ret\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * toRefs 支持 array 和 object。\n\n\n# unref\n\n官网释义\n\nReturns the inner value if the argument is a ref, otherwise return the argument itself. This is a sugar function for val = isRef(val) ? val.value : val.\n\n如果参数是一个 ref，则返回内部值，否则返回参数本身。这是 val = isRef (val) ? val.value : val 的语法糖函数。\n\nexport function unref<T>(ref: T | Ref<T>): T {\n  return isRef(ref) ? (ref.value as any) : ref\n}\n\n\n1\n2\n3\n\n\n\n# customRef\n\n官网释义\n\nCreates a customized ref with explicit control over its dependency tracking and updates triggering. It expects a factory function, which receives track and trigger functions as arguments and should return an object with get and set.\n\n创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。它需要一个工厂函数，该函数接收 track 和 trigger 函数作为参数，并且应该返回一个带有 get 和 set 的对象。\n\nexport function customRef<T>(factory: CustomRefFactory<T>): Ref<T> {\n  return new CustomRefImpl(factory) as any\n}\nclass CustomRefImpl<T> {\n  private readonly _get: ReturnType<CustomRefFactory<T>>['get']\n  private readonly _set: ReturnType<CustomRefFactory<T>>['set']\n\n  public readonly __v_isRef = true\n\n  constructor(factory: CustomRefFactory<T>) {\n    // 将 track 和 trigger 传入默认的参数包装成函数传递给工厂函数。\n    // 执行工厂函数获取 getter 和 setter。\n    const { get, set } = factory(\n      () => track(this, TrackOpTypes.GET, 'value'),\n      () => trigger(this, TriggerOpTypes.SET, 'value')\n    )\n    this._get = get\n    this._set = set\n  }\n\n  get value() {\n    return this._get()\n  }\n\n  set value(newVal) {\n    this._set(newVal)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n从 CustomRefImpl 可以看出：\n\n * ref 响应式的核心就是对 value 的 getter 和 setter 的拦截，在 getter 最重要的两步就是 track 和赋值，在 setter 中最重要的就是 trigger 和设置值。track 和 trigger 就是 vue 响应式的核心。\n * customRef 可以通过对 getter 和 setter 的自定义来实现响应式的不同的效果。可以对 ref 的响应式做定制。\n\n\n# triggerRef\n\n官网释义\n\nExecute any effects tied to a shallowRef manually.\n\n手动执行与 shallowRef 关联的任何副作用。\n\nexport function triggerRef(ref: Ref) {\n  trigger(toRaw(ref), TriggerOpTypes.SET, 'value', __DEV__ ? ref.value : void 0)\n}\n\n\n1\n2\n3\n\n\ntriggerRef 就是对 ref 对象上收集的依赖进行手动触发和执行。\n\n\n# 文章小结\n\n本文是对 vue3 响应式原理部分 Ref Api 进行源码剖析。更深的理解需要参照 reactive 和 effect 部分。",normalizedContent:"# 目录\n\n\n\n * 目录\n * ref\n * shallowref\n * isref\n * toref\n * torefs\n * unref\n * customref\n * triggerref\n * 文章小结\n\n\n\n\n# ref\n\n官网释义\n\ntakes an inner value and returns a reactive and mutable ref object. the ref object has a single property .value that points to the inner value.\n\n接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象具有指向内部值的单个 property .value。\n\n * ref 接受一个 unknown 类型的值，内部调用了 createref 函数。\n * createref 内部对于本身已经是 ref 的传值返回其本身，返回了一个 refimpl 对象实例。有此可见一个 ref 兑现个，实际上是一个 refimpl 的对象实例。同时我们注意到，ref 传入 refimpl 中 shadow 的值是 false。也就是 ref 创建的响应式是 deep reactivity 的。\n\nexport function ref(value?: unknown) {\n  return createref(value)\n}\nfunction createref(rawvalue: unknown, shallow = false) {\n  if (isref(rawvalue)) {\n    return rawvalue\n  }\n  return new refimpl(rawvalue, shallow)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n接着我们来看下核心 class refimpl:\n\nclass refimpl<t> {\n  private _value: t\n\n  public readonly __v_isref = true\n\n  // 如果 shadow 或者是不是对象 则 _rawvalue，是对象就调 reactive。\n  // 这里给 _value 赋初始值\n  constructor(private _rawvalue: t, public readonly _shallow: boolean) {\n    // 初始化设置值\n    this._value = _shallow ? _rawvalue : convert(_rawvalue)\n  }\n  \n  get value() {\n    // 初始化依赖收集，这里的 target 是 row target\n    track(toraw(this), trackoptypes.get, 'value')\n    return this._value\n  }\n\n  set value(newval) {\n    // 检查值是否有变化，只有有变化时才出发 setter\n    // this._rawvalue 是上一次 set 时传的 rowvalue\n    if (haschanged(toraw(newval), this._rawvalue)) {\n      this._rawvalue = newval\n      this._value = this._shallow ? newval : convert(newval)\n      // 触发（消费）依赖集合，注意这里传入了 newval\n      trigger(toraw(this), triggeroptypes.set, 'value', newval)\n    }\n  }\n}\n// 如果是传入对象就简介调用 reactive\nconst convert = <t extends unknown>(val: t): t =>\n  isobject(val) ? reactive(val) : val\n// compare whether a value has changed, accounting for nan.\n// 这里是考虑到 nan 的情况，因为 nan === nan 是 false，但是 null === null 是 true。\nexport const haschanged = (value: any, oldvalue: any): boolean =>\n  value !== oldvalue && (value === value || oldvalue === oldvalue)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n * 在这段代码中，实现了 ref 的响应式，我们知道 vue 的响应式都是基于对响应式 target 的值的 get 和 set 的拦截来实现的，简单的说就是 在 get 时对 target 进行依赖收集，在 set 时触发依赖回调集合来实现响应式的。在 vue2 中的 object.defineproperty ()，以及 vue3 中的 proxy 都是这样的原理。\n * _value 维护了 ref 中响应式的值，__v_isref 是 ref 对象的身份标识。后文中 isref 正在通过这个表示来辨别 ref 对象。\n * getter 和 setter 属于 es6 的语法。在 value 的 getter 中调用了 track 函数，这个函数对 target 也就是 toraw (this) 进行了依赖收集，也就是任何应用到当前的 ref 值的地方都会被记录。在 value 的 setter 中先是比较新值和旧值是否有变化，只有变化的值才会引起响应式更新，trigger 函数正在对当前 target 所收集的依赖进行执行。track 和 trigger 实际上是使用了订阅发布的设计模式，我们将会在 effect 部分详细分析。\n * 响应式我们已经有 reactive 了，为什么还要有 ref？ 从 convert 的代码中可以看出，ref 的传值如果是 object 时实际上是间接使用了 reactive 来保持 deep reactivity 的，然后才被包装成了 ref 对象。proxy api 是只用于 object 中的，这一点从 mdn 的解释 'the proxy object enables you to create a proxy for another object, which can intercept and redefine fundamental operations for that object.' 可以看出。因此针对普通值类型的响应式，我们还是需要由 ref 来实现的。而且对于普通值类型的响应式而言，并不存在 object property 的劫持，仍然是一种很高效的响应式方法。\n\n参考资料：\n\n * mdn: object.defineproperty\n * mdn: proxy\n\n\n# shallowref\n\n官网释义\n\ncreates a ref that tracks its own .value mutation but doesn't make its value reactive.\n\n创建一个跟踪自身 .value 变化的 ref，但不会使其值也变成响应式的。\n\nexport function shallowref(value?: unknown) {\n  return createref(value, true)\n}\n\n\n1\n2\n3\n\n\n可以看到，shallowref 同样是调用 shallowref，只不过 _shallow 传入了 true。与 ref 不同点就在于：在针对 object 的 setter 时，并不在是使用 reactive 了，而是直接使用_rawvalue。有此可见，如果传入了 object，则只是 object 顶层响应式的，也就是 ref.value 是响应式的，这是的 isreactive (ref.value) 应该是 false 。\n\n\n# isref\n\n官网释义\n\nchecks if a value is a ref object.\n\n检查值是否为一个 ref 对象。\n\nexport function isref(r: any): r is ref {\n  return boolean(r && r.__v_isref === true)\n}\n\n\n1\n2\n3\n\n\n根据 __v_isref 标志判断是否是 ref 对象。\n\n\n# toref\n\n官网释义\n\ncan be used to create a ref for a property on a source reactive object. the ref can then be passed around, retaining the reactive connection to its source property.\n\n可以用来为源响应式对象上的某个 property 新创建一个 ref。然后，ref 可以被传递，它会保持对其源 property 的响应式连接。\n\nexport function toref<t extends object, k extends keyof t>(\n  object: t,\n  key: k\n): toref<t[k]> {\n  return isref(object[key])\n    ? object[key]\n    : (new objectrefimpl(object, key) as any)\n}\nclass objectrefimpl<t extends object, k extends keyof t> {\n  public readonly __v_isref = true\n\n  constructor(private readonly _object: t, private readonly _key: k) {}\n\n  get value() {\n    return this._object[this._key]\n  }\n\n  set value(newval) {\n    this._object[this._key] = newval\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n内部仍然是 objectrefimpl 实现。\n\n\n# torefs\n\n官网释义\n\nconverts a reactive object to a plain object where each property of the resulting object is a ref pointing to the corresponding property of the original object.\n\n将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 ref。\n\nexport function torefs<t extends object>(object: t): torefs<t> {\n  const ret: any = isarray(object) ? new array(object.length) : {}\n  for (const key in object) {\n    ret[key] = toref(object, key)\n  }\n  return ret\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * torefs 支持 array 和 object。\n\n\n# unref\n\n官网释义\n\nreturns the inner value if the argument is a ref, otherwise return the argument itself. this is a sugar function for val = isref(val) ? val.value : val.\n\n如果参数是一个 ref，则返回内部值，否则返回参数本身。这是 val = isref (val) ? val.value : val 的语法糖函数。\n\nexport function unref<t>(ref: t | ref<t>): t {\n  return isref(ref) ? (ref.value as any) : ref\n}\n\n\n1\n2\n3\n\n\n\n# customref\n\n官网释义\n\ncreates a customized ref with explicit control over its dependency tracking and updates triggering. it expects a factory function, which receives track and trigger functions as arguments and should return an object with get and set.\n\n创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。它需要一个工厂函数，该函数接收 track 和 trigger 函数作为参数，并且应该返回一个带有 get 和 set 的对象。\n\nexport function customref<t>(factory: customreffactory<t>): ref<t> {\n  return new customrefimpl(factory) as any\n}\nclass customrefimpl<t> {\n  private readonly _get: returntype<customreffactory<t>>['get']\n  private readonly _set: returntype<customreffactory<t>>['set']\n\n  public readonly __v_isref = true\n\n  constructor(factory: customreffactory<t>) {\n    // 将 track 和 trigger 传入默认的参数包装成函数传递给工厂函数。\n    // 执行工厂函数获取 getter 和 setter。\n    const { get, set } = factory(\n      () => track(this, trackoptypes.get, 'value'),\n      () => trigger(this, triggeroptypes.set, 'value')\n    )\n    this._get = get\n    this._set = set\n  }\n\n  get value() {\n    return this._get()\n  }\n\n  set value(newval) {\n    this._set(newval)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n从 customrefimpl 可以看出：\n\n * ref 响应式的核心就是对 value 的 getter 和 setter 的拦截，在 getter 最重要的两步就是 track 和赋值，在 setter 中最重要的就是 trigger 和设置值。track 和 trigger 就是 vue 响应式的核心。\n * customref 可以通过对 getter 和 setter 的自定义来实现响应式的不同的效果。可以对 ref 的响应式做定制。\n\n\n# triggerref\n\n官网释义\n\nexecute any effects tied to a shallowref manually.\n\n手动执行与 shallowref 关联的任何副作用。\n\nexport function triggerref(ref: ref) {\n  trigger(toraw(ref), triggeroptypes.set, 'value', __dev__ ? ref.value : void 0)\n}\n\n\n1\n2\n3\n\n\ntriggerref 就是对 ref 对象上收集的依赖进行手动触发和执行。\n\n\n# 文章小结\n\n本文是对 vue3 响应式原理部分 ref api 进行源码剖析。更深的理解需要参照 reactive 和 effect 部分。",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"Reactive",frontmatter:{title:"Reactive",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/basic/reactive/",categories:["vue3","reactivity"],tags:[null]},regularPath:"/20.vue3/20.reactivity/20.reactive.html",relativePath:"20.vue3/20.reactivity/20.reactive.md",key:"v-4d69bd7d",path:"/vue3/basic/reactive/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"Proxy",slug:"proxy",normalizedTitle:"proxy",charIndex:17},{level:2,title:"Object.defineProperty",slug:"object-defineproperty",normalizedTitle:"object.defineproperty",charIndex:26},{level:2,title:"createReactiveObject",slug:"createreactiveobject",normalizedTitle:"createreactiveobject",charIndex:51},{level:2,title:"reactive",slug:"reactive",normalizedTitle:"reactive",charIndex:75},{level:2,title:"readonly",slug:"readonly",normalizedTitle:"readonly",charIndex:87},{level:2,title:"shallowReactive",slug:"shallowreactive",normalizedTitle:"shallowreactive",charIndex:99},{level:2,title:"shallowReadonly",slug:"shallowreadonly",normalizedTitle:"shallowreadonly",charIndex:118},{level:2,title:"isReadonly",slug:"isreadonly",normalizedTitle:"isreadonly",charIndex:137},{level:2,title:"isReactive",slug:"isreactive",normalizedTitle:"isreactive",charIndex:151},{level:2,title:"isProxy",slug:"isproxy",normalizedTitle:"isproxy",charIndex:165},{level:2,title:"markRaw",slug:"markraw",normalizedTitle:"markraw",charIndex:176},{level:2,title:"toRaw",slug:"toraw",normalizedTitle:"toraw",charIndex:187},{level:2,title:"Q&A",slug:"q-a",normalizedTitle:"q&amp;a",charIndex:null},{level:2,title:"文章小结",slug:"文章小结",normalizedTitle:"文章小结",charIndex:203}],readingTime:{text:"7 min read",minutes:6.67,time:400200,words:1334},headersStr:"目录 Proxy Object.defineProperty createReactiveObject reactive readonly shallowReactive shallowReadonly isReadonly isReactive isProxy markRaw toRaw Q&A 文章小结",content:"# 目录\n\n\n\n * 目录\n * Proxy\n * Object.defineProperty\n * createReactiveObject\n * reactive\n * readonly\n * shallowReactive\n * shallowReadonly\n * isReadonly\n * isReactive\n * isProxy\n * markRaw\n * toRaw\n * Q&A\n * 文章小结\n\n\n\n\n# Proxy\n\nProxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。\n\nconst p = new Proxy(target, handler)\n\n\n1\n\n * target: 要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。\n * handler: 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。\n\n在 vue2.0 中使用 Object.defineProperty() 来劫持、监听对象属性，在 vue 3 中则采用了 Proxy 来劫持、监听对象属性，相比于 Object.defineProperty()，Proxy Api 的好处是：\n\n * 可以监听到对象属性的增加和删除行为。\n * 可以监听数组索引值或者长度的变化。\n * 对 Map、Set、WeakMap 和 WeakSet 的支持。(Proxy 可以代理所有的对象)\n\nProxy Api 不兼容 ie 浏览器，这也意味着 vue3 是面向现代主流浏览器的，不支持 ie 浏览器，如果需要兼容 ie 浏览器，需要使用 vue2。\n\n详见：MDN: Proxy\n\n\n# Object.defineProperty\n\nObject.defineProperty () 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。\n\nObject.defineProperty(obj, prop, descriptor)\n\n\n1\n\n * obj：要定义属性的对象。\n * prop：要定义或修改的属性的名称或 Symbol 。\n * descriptor：要定义或修改的属性描述符。\n\nDESCRIPTOR     描述                                                             类型        默认值\nconfigurable   当且仅当该属性的 configurable 键值为 true                                 boolean   false\n               时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。\nenumerable     当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。               boolean   false\nvalue          该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。                      \\         undefined\nwritable       当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符        boolean   false\n               (en-US) 改变。\nget            属性的 getter 函数，如果没有 getter，则为                                   \\         undefined\n               undefined。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的\n               this 并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。\nset            属性的 setter 函数，如果没有 setter，则为                                   \\         undefined\n               undefined。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this\n               对象。\n\n详见：MDN: Object.defineProperty()\n\n\n# createReactiveObject\n\n先来看一个最为重要的函数，这是实现 reactive/shallowReactive/readonly/shallowReadonly 这四个 api 的核心。\n\nexport const enum ReactiveFlags {\n  SKIP = '__v_skip',\n  IS_REACTIVE = '__v_isReactive',\n  IS_READONLY = '__v_isReadonly',\n  RAW = '__v_raw'\n}\n\nexport interface Target {\n  [ReactiveFlags.SKIP]?: boolean // 表示当前当前监听的对象是否可以跳过（不监听）\n  [ReactiveFlags.IS_REACTIVE]?: boolean // 是否是 reactive 类型值\n  [ReactiveFlags.IS_READONLY]?: boolean // 是否是 readonly 类型值\n  [ReactiveFlags.RAW]?: any // 表示原始的值。\n}\n\nfunction createReactiveObject(\n  target: Target, // reactive target\n  isReadonly: boolean, // 是否只读\n  baseHandlers: ProxyHandler<any>, // 基本的 handlers，object/array\n  collectionHandlers: ProxyHandler<any>, // COLLECTION 类别的 handlers，map/set/weakMap/weakSet\n  proxyMap: WeakMap<Target, any> // 保存 Map(t, p) 集合\n) {\n  // reactive 只作用于 object\n  if (!isObject(target)) {\n    if (__DEV__) {\n      console.warn(`value cannot be made reactive: ${String(target)}`)\n    }\n    return target\n  }\n  // target is already a Proxy, return it.\n  // exception: calling readonly() on a reactive object\n  // 已经是一个 Proxy 对象，返回其本身\n  // 如果原始值已经存在，但是又不是 readonly 值和 reactive 值。\n  if (\n    target[ReactiveFlags.RAW] &&\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\n  ) {\n    return target\n  }\n  // target already has corresponding Proxy\n  // target 对应的 Proxy 对象已经存在于 proxyMap 中，返回这个 existingProxy。\n  const existingProxy = proxyMap.get(target)\n  if (existingProxy) {\n    return existingProxy\n  }\n  // only a whitelist of value types can be observed.\n  // getTargetType 获取 target 的分类：INVALID、COMMON、COLLECTION\n  // 不支持的类型返回其本身。\n  const targetType = getTargetType(target)\n  if (targetType === TargetType.INVALID) {\n    return target\n  }\n  // 根据 target 创建一个 Proxy 对象。\n  // COLLECTION 使用 collectionHandlers，否则使用 baseHandlers\n  const proxy = new Proxy(\n    target,\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\n  )\n  // 将 proxy 对象加入到 proxyMap 中，结构: Map<target, proxy>。\n  proxyMap.set(target, proxy)\n  // 返回的是 proxy 对象，也就是说 target 的属性和行为将会被拦截，即是响应式。\n  return proxy\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n分析如下：\n\n * 接收 5 个参数，target: 响应式的目标对象，也就是我们传入了需要响应式的值，isReadonly：是否只读，baseHandlers：基本的 handlers，用于 object/array，collectionHandlers：COLLECTION 类别的 handlers，适用于 map/set/weakMap/weakSet，proxyMap 保存 Map (target, proxy) 映射的 Map。\n * 考虑到的特殊情况：不是 object，已经是一个 Proxy 对象，target 对应的 Proxy 对象已经存在于 proxyMap 中，不支持的类型。\n * createReactiveObject 函数结构如下：\n\n由此可见，handlers 和 proxyMap 将是很重要的部分。也是实现响应式 api 的核心。\n\n\n# reactive\n\n官网释义\n\nReturns a reactive copy of the object.\n\nThe reactive conversion is \"deep\"—it affects all nested properties. In the ES2015 Proxy based implementation, the returned proxy is not equal to the original object. It is recommended to work exclusively with the reactive proxy and avoid relying on the original object.\n\n返回对象的响应式副本。\n\n响应式转换是 “深层的”：会影响对象内部所有嵌套的属性。基于 ES2015 的 Proxy 实现，返回的代理对象不等于原始对象。建议仅使用代理对象而避免依赖原始对象。\n\n源码如下：\n\nexport function reactive(target: object) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  // readonly 值不可变，返回其本身\n  if (target && (target as Target)[ReactiveFlags.IS_READONLY]) {\n    return target\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  )\n}\n\nexport const mutableHandlers: ProxyHandler<object> = {\n  get,\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n}\n\nexport const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {\n  get: /*#__PURE__*/ createInstrumentationGetter(false, false)\n}\n\nexport const reactiveMap = new WeakMap<Target, any>()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nhandles 细节部分在 handler 文章中具体分析。\n\n\n# readonly\n\n官网释义\n\nTakes an object (reactive or plain) or a ref and returns a readonly proxy to the original. A readonly proxy is deep: any nested property accessed will be readonly as well.\n\n接受一个对象 (响应式或纯对象) 或 ref 并返回原始对象的只读代理。只读代理是深层的：任何被访问的嵌套 property 也是只读的。\n\nexport function readonly<T extends object>(\n  target: T\n): DeepReadonly<UnwrapNestedRefs<T>> {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  )\n}\n\nexport const readonlyHandlers: ProxyHandler<object> = {\n  get: readonlyGet,\n  set(target, key) {\n    return true\n  },\n  deleteProperty(target, key) {\n    return true\n  }\n}\n\nexport const readonlyCollectionHandlers: ProxyHandler<CollectionTypes> = {\n  get: /*#__PURE__*/ createInstrumentationGetter(true, false)\n}\n\nexport const readonlyMap = new WeakMap<Target, any>()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * readonly 的对象的属性值是不可被 set 和 delete，均返回 true。\n\n\n# shallowReactive\n\n官网释义\n\nCreates a reactive proxy that tracks reactivity of its own properties but does not perform deep reactive conversion of nested objects (exposes raw values).\n\n创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (暴露原始值)。\n\nexport function shallowReactive<T extends object>(target: T): T {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  )\n}\n\nexport const shallowReactiveHandlers = /*#__PURE__*/ extend(\n  {},\n  mutableHandlers,\n  {\n    get: shallowGet,\n    set: shallowSet\n  }\n)\n\nexport const shallowCollectionHandlers: ProxyHandler<CollectionTypes> = {\n  get: /*#__PURE__*/ createInstrumentationGetter(false, true)\n}\n\nexport const shallowReactiveMap = new WeakMap<Target, any>()\n\nexport const extend = Object.assign\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# shallowReadonly\n\n官网释义\n\nCreates a proxy that makes its own properties readonly, but does not perform deep readonly conversion of nested objects (exposes raw values).\n\n创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换 (暴露原始值)。\n\nexport function shallowReadonly<T extends object>(\n  target: T\n): Readonly<{ [K in keyof T]: UnwrapNestedRefs<T[K]> }> {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  )\n}\n\nexport const shallowReadonlyHandlers = /*#__PURE__*/ extend(\n  {},\n  readonlyHandlers,\n  {\n    get: shallowReadonlyGet\n  }\n)\n\nexport const shallowReadonlyCollectionHandlers: ProxyHandler<\n  CollectionTypes\n> = {\n  get: /*#__PURE__*/ createInstrumentationGetter(true, true)\n}\n\nexport const shallowReadonlyMap = new WeakMap<Target, any>()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# isReadonly\n\n官网释义\n\nChecks if an object is a readonly proxy created by readonly.\n\n检查对象是否是由 readonly 创建的只读代理。\n\nexport function isReadonly(value: unknown): boolean {\n  return !!(value && (value as Target)[ReactiveFlags.IS_READONLY])\n}\n\n\n1\n2\n3\n\n\nisReadonly 是通过检查 target 的 __v_isReadonly 标记实现的。\n\n\n# isReactive\n\n官网释义\n\nChecks if an object is a reactive proxy created by reactive.\n\n检查对象是否是由 reactive 创建的响应式代理。\n\nexport function isReactive(value: unknown): boolean {\n  if (isReadonly(value)) {\n    return isReactive((value as Target)[ReactiveFlags.RAW])\n  }\n  return !!(value && (value as Target)[ReactiveFlags.IS_REACTIVE])\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果 value 只读，检查原始值是否是 reactive 类型，否则检查 __v_isReactive 标记。\n\n\n# isProxy\n\n官网释义\n\nChecks if an object is a proxy created by reactive or readonly.\n\n检查对象是否是由 reactive 或 readonly 创建的 proxy。\n\nexport function isProxy(value: unknown): boolean {\n  return isReactive(value) || isReadonly(value)\n}\n\n\n1\n2\n3\n\n\n检查是否是 reactive 类型或者 readonly 类型值。\n\n\n# markRaw\n\n官网释义\n\nMarks an object so that it will never be converted to a proxy. Returns the object itself.\n\n标记一个对象，使其永远不会转换为 proxy。返回对象本身。\n\nexport function markRaw<T extends object>(value: T): T {\n  // markRaw 的对象标记 '__v_skip' 为 true ，在执行副作用时跳过\n  def(value, ReactiveFlags.SKIP, true)\n  return value\n}\n\nexport const def = (obj: object, key: string | symbol, value: any) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    value\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nmarkRaw 是根据 __v_skip 标记实现的，在消费 effect 的时候，有此标记的 target 会跳过消费 effect 的过程，因此 markRaw 的对象就不在具有响应式。\n\n\n# toRaw\n\n官网释义\n\nReturns the raw, original object of a reactive or readonly proxy. This is an escape hatch that can be used to temporarily read without incurring proxy access/tracking overhead or write without triggering changes. It is not recommended to hold a persistent reference to the original object. Use with caution.\n\n返回 reactive 或 readonly 代理的原始对象。这是一个 “逃生舱”，可用于临时读取数据而无需承担代理访问 / 跟踪的开销，也可用于写入数据而避免触发更改。不建议保留对原始对象的持久引用。请谨慎使用。\n\nexport function toRaw<T>(observed: T): T {\n  return (\n    (observed && toRaw((observed as Target)[ReactiveFlags.RAW])) || observed\n  )\n}\n\n\n1\n2\n3\n4\n5\n\n * 如果不是 proxy 对象就原样返回，否则就递归找到 raw object。需要注意的是这个针对响应式数据的一种 “逃生舱” 机制。\n * markRaw 和 toRaw 经常被用作一种优化的手段：在不需要通知视图时，减少数据变化引起的视图更新的花销；在数据不会变化的情况下，可以跳过 Proxy，提高渲染性能。\n\n\n# Q&A\n\n 1. createReactiveObject 创建了哪几种响应式的类型？\n\n * reactive：完全响应式的，即 deep reactivity。\n * readonly：完全只读的，即 deep readonly。\n * shallowReactive：浅层的响应式，即 shallow reactivity。\n * shallowReactive：浅层的只读，即 shallow readonly。\n\n 2. createReactiveObject 能够处理哪些类型的数据？\n\n从源码中对 target 的分类：\n\nfunction targetTypeMap(rawType: string) {\n  switch (rawType) {\n    case 'Object':\n    case 'Array':\n      return TargetType.COMMON\n    case 'Map':\n    case 'Set':\n    case 'WeakMap':\n    case 'WeakSet':\n      return TargetType.COLLECTION\n    default:\n      return TargetType.INVALID\n  }\n}\n\n// 获取 value 的类型\nfunction getTargetType(value: Target) {\n  return value[ReactiveFlags.SKIP] || !Object.isExtensible(value)\n    ? TargetType.INVALID\n    : targetTypeMap(toRawType(value))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n可以处理的数据类型包括如下两类：\n\n * COMMON：Object、Array。\n * COLLECTION：Map、Set、WeakMap、WeakSet。\n\n另外，需要注意的是，如果对象有 configurable: false 与 writable: false 的属性，那该对象就无法被 proxy 代理。\n\n\n# 文章小结\n\n这篇文章时对 reactivity 模块中 reactive 的源码分析，分析了四种 reactive object 的创建过程。各种 reactive object 都是由 Proxy 创建，创建是提供了不同的 handlers 和 proxyMap，proxyMap 就是对创建的 proxy 对象进行的缓存，handlers 是 Proxy 机制的核心，是劫持、控制对象属性的重要部分，这部分我们在 Handler 中详细分析。",normalizedContent:"# 目录\n\n\n\n * 目录\n * proxy\n * object.defineproperty\n * createreactiveobject\n * reactive\n * readonly\n * shallowreactive\n * shallowreadonly\n * isreadonly\n * isreactive\n * isproxy\n * markraw\n * toraw\n * q&a\n * 文章小结\n\n\n\n\n# proxy\n\nproxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。\n\nconst p = new proxy(target, handler)\n\n\n1\n\n * target: 要使用 proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。\n * handler: 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。\n\n在 vue2.0 中使用 object.defineproperty() 来劫持、监听对象属性，在 vue 3 中则采用了 proxy 来劫持、监听对象属性，相比于 object.defineproperty()，proxy api 的好处是：\n\n * 可以监听到对象属性的增加和删除行为。\n * 可以监听数组索引值或者长度的变化。\n * 对 map、set、weakmap 和 weakset 的支持。(proxy 可以代理所有的对象)\n\nproxy api 不兼容 ie 浏览器，这也意味着 vue3 是面向现代主流浏览器的，不支持 ie 浏览器，如果需要兼容 ie 浏览器，需要使用 vue2。\n\n详见：mdn: proxy\n\n\n# object.defineproperty\n\nobject.defineproperty () 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。\n\nobject.defineproperty(obj, prop, descriptor)\n\n\n1\n\n * obj：要定义属性的对象。\n * prop：要定义或修改的属性的名称或 symbol 。\n * descriptor：要定义或修改的属性描述符。\n\ndescriptor     描述                                                             类型        默认值\nconfigurable   当且仅当该属性的 configurable 键值为 true                                 boolean   false\n               时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。\nenumerable     当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。               boolean   false\nvalue          该属性对应的值。可以是任何有效的 javascript 值（数值，对象，函数等）。                      \\         undefined\nwritable       当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符        boolean   false\n               (en-us) 改变。\nget            属性的 getter 函数，如果没有 getter，则为                                   \\         undefined\n               undefined。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的\n               this 并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。\nset            属性的 setter 函数，如果没有 setter，则为                                   \\         undefined\n               undefined。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this\n               对象。\n\n详见：mdn: object.defineproperty()\n\n\n# createreactiveobject\n\n先来看一个最为重要的函数，这是实现 reactive/shallowreactive/readonly/shallowreadonly 这四个 api 的核心。\n\nexport const enum reactiveflags {\n  skip = '__v_skip',\n  is_reactive = '__v_isreactive',\n  is_readonly = '__v_isreadonly',\n  raw = '__v_raw'\n}\n\nexport interface target {\n  [reactiveflags.skip]?: boolean // 表示当前当前监听的对象是否可以跳过（不监听）\n  [reactiveflags.is_reactive]?: boolean // 是否是 reactive 类型值\n  [reactiveflags.is_readonly]?: boolean // 是否是 readonly 类型值\n  [reactiveflags.raw]?: any // 表示原始的值。\n}\n\nfunction createreactiveobject(\n  target: target, // reactive target\n  isreadonly: boolean, // 是否只读\n  basehandlers: proxyhandler<any>, // 基本的 handlers，object/array\n  collectionhandlers: proxyhandler<any>, // collection 类别的 handlers，map/set/weakmap/weakset\n  proxymap: weakmap<target, any> // 保存 map(t, p) 集合\n) {\n  // reactive 只作用于 object\n  if (!isobject(target)) {\n    if (__dev__) {\n      console.warn(`value cannot be made reactive: ${string(target)}`)\n    }\n    return target\n  }\n  // target is already a proxy, return it.\n  // exception: calling readonly() on a reactive object\n  // 已经是一个 proxy 对象，返回其本身\n  // 如果原始值已经存在，但是又不是 readonly 值和 reactive 值。\n  if (\n    target[reactiveflags.raw] &&\n    !(isreadonly && target[reactiveflags.is_reactive])\n  ) {\n    return target\n  }\n  // target already has corresponding proxy\n  // target 对应的 proxy 对象已经存在于 proxymap 中，返回这个 existingproxy。\n  const existingproxy = proxymap.get(target)\n  if (existingproxy) {\n    return existingproxy\n  }\n  // only a whitelist of value types can be observed.\n  // gettargettype 获取 target 的分类：invalid、common、collection\n  // 不支持的类型返回其本身。\n  const targettype = gettargettype(target)\n  if (targettype === targettype.invalid) {\n    return target\n  }\n  // 根据 target 创建一个 proxy 对象。\n  // collection 使用 collectionhandlers，否则使用 basehandlers\n  const proxy = new proxy(\n    target,\n    targettype === targettype.collection ? collectionhandlers : basehandlers\n  )\n  // 将 proxy 对象加入到 proxymap 中，结构: map<target, proxy>。\n  proxymap.set(target, proxy)\n  // 返回的是 proxy 对象，也就是说 target 的属性和行为将会被拦截，即是响应式。\n  return proxy\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n分析如下：\n\n * 接收 5 个参数，target: 响应式的目标对象，也就是我们传入了需要响应式的值，isreadonly：是否只读，basehandlers：基本的 handlers，用于 object/array，collectionhandlers：collection 类别的 handlers，适用于 map/set/weakmap/weakset，proxymap 保存 map (target, proxy) 映射的 map。\n * 考虑到的特殊情况：不是 object，已经是一个 proxy 对象，target 对应的 proxy 对象已经存在于 proxymap 中，不支持的类型。\n * createreactiveobject 函数结构如下：\n\n由此可见，handlers 和 proxymap 将是很重要的部分。也是实现响应式 api 的核心。\n\n\n# reactive\n\n官网释义\n\nreturns a reactive copy of the object.\n\nthe reactive conversion is \"deep\"—it affects all nested properties. in the es2015 proxy based implementation, the returned proxy is not equal to the original object. it is recommended to work exclusively with the reactive proxy and avoid relying on the original object.\n\n返回对象的响应式副本。\n\n响应式转换是 “深层的”：会影响对象内部所有嵌套的属性。基于 es2015 的 proxy 实现，返回的代理对象不等于原始对象。建议仅使用代理对象而避免依赖原始对象。\n\n源码如下：\n\nexport function reactive(target: object) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  // readonly 值不可变，返回其本身\n  if (target && (target as target)[reactiveflags.is_readonly]) {\n    return target\n  }\n  return createreactiveobject(\n    target,\n    false,\n    mutablehandlers,\n    mutablecollectionhandlers,\n    reactivemap\n  )\n}\n\nexport const mutablehandlers: proxyhandler<object> = {\n  get,\n  set,\n  deleteproperty,\n  has,\n  ownkeys\n}\n\nexport const mutablecollectionhandlers: proxyhandler<collectiontypes> = {\n  get: /*#__pure__*/ createinstrumentationgetter(false, false)\n}\n\nexport const reactivemap = new weakmap<target, any>()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nhandles 细节部分在 handler 文章中具体分析。\n\n\n# readonly\n\n官网释义\n\ntakes an object (reactive or plain) or a ref and returns a readonly proxy to the original. a readonly proxy is deep: any nested property accessed will be readonly as well.\n\n接受一个对象 (响应式或纯对象) 或 ref 并返回原始对象的只读代理。只读代理是深层的：任何被访问的嵌套 property 也是只读的。\n\nexport function readonly<t extends object>(\n  target: t\n): deepreadonly<unwrapnestedrefs<t>> {\n  return createreactiveobject(\n    target,\n    true,\n    readonlyhandlers,\n    readonlycollectionhandlers,\n    readonlymap\n  )\n}\n\nexport const readonlyhandlers: proxyhandler<object> = {\n  get: readonlyget,\n  set(target, key) {\n    return true\n  },\n  deleteproperty(target, key) {\n    return true\n  }\n}\n\nexport const readonlycollectionhandlers: proxyhandler<collectiontypes> = {\n  get: /*#__pure__*/ createinstrumentationgetter(true, false)\n}\n\nexport const readonlymap = new weakmap<target, any>()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * readonly 的对象的属性值是不可被 set 和 delete，均返回 true。\n\n\n# shallowreactive\n\n官网释义\n\ncreates a reactive proxy that tracks reactivity of its own properties but does not perform deep reactive conversion of nested objects (exposes raw values).\n\n创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (暴露原始值)。\n\nexport function shallowreactive<t extends object>(target: t): t {\n  return createreactiveobject(\n    target,\n    false,\n    shallowreactivehandlers,\n    shallowcollectionhandlers,\n    shallowreactivemap\n  )\n}\n\nexport const shallowreactivehandlers = /*#__pure__*/ extend(\n  {},\n  mutablehandlers,\n  {\n    get: shallowget,\n    set: shallowset\n  }\n)\n\nexport const shallowcollectionhandlers: proxyhandler<collectiontypes> = {\n  get: /*#__pure__*/ createinstrumentationgetter(false, true)\n}\n\nexport const shallowreactivemap = new weakmap<target, any>()\n\nexport const extend = object.assign\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# shallowreadonly\n\n官网释义\n\ncreates a proxy that makes its own properties readonly, but does not perform deep readonly conversion of nested objects (exposes raw values).\n\n创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换 (暴露原始值)。\n\nexport function shallowreadonly<t extends object>(\n  target: t\n): readonly<{ [k in keyof t]: unwrapnestedrefs<t[k]> }> {\n  return createreactiveobject(\n    target,\n    true,\n    shallowreadonlyhandlers,\n    shallowreadonlycollectionhandlers,\n    shallowreadonlymap\n  )\n}\n\nexport const shallowreadonlyhandlers = /*#__pure__*/ extend(\n  {},\n  readonlyhandlers,\n  {\n    get: shallowreadonlyget\n  }\n)\n\nexport const shallowreadonlycollectionhandlers: proxyhandler<\n  collectiontypes\n> = {\n  get: /*#__pure__*/ createinstrumentationgetter(true, true)\n}\n\nexport const shallowreadonlymap = new weakmap<target, any>()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# isreadonly\n\n官网释义\n\nchecks if an object is a readonly proxy created by readonly.\n\n检查对象是否是由 readonly 创建的只读代理。\n\nexport function isreadonly(value: unknown): boolean {\n  return !!(value && (value as target)[reactiveflags.is_readonly])\n}\n\n\n1\n2\n3\n\n\nisreadonly 是通过检查 target 的 __v_isreadonly 标记实现的。\n\n\n# isreactive\n\n官网释义\n\nchecks if an object is a reactive proxy created by reactive.\n\n检查对象是否是由 reactive 创建的响应式代理。\n\nexport function isreactive(value: unknown): boolean {\n  if (isreadonly(value)) {\n    return isreactive((value as target)[reactiveflags.raw])\n  }\n  return !!(value && (value as target)[reactiveflags.is_reactive])\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果 value 只读，检查原始值是否是 reactive 类型，否则检查 __v_isreactive 标记。\n\n\n# isproxy\n\n官网释义\n\nchecks if an object is a proxy created by reactive or readonly.\n\n检查对象是否是由 reactive 或 readonly 创建的 proxy。\n\nexport function isproxy(value: unknown): boolean {\n  return isreactive(value) || isreadonly(value)\n}\n\n\n1\n2\n3\n\n\n检查是否是 reactive 类型或者 readonly 类型值。\n\n\n# markraw\n\n官网释义\n\nmarks an object so that it will never be converted to a proxy. returns the object itself.\n\n标记一个对象，使其永远不会转换为 proxy。返回对象本身。\n\nexport function markraw<t extends object>(value: t): t {\n  // markraw 的对象标记 '__v_skip' 为 true ，在执行副作用时跳过\n  def(value, reactiveflags.skip, true)\n  return value\n}\n\nexport const def = (obj: object, key: string | symbol, value: any) => {\n  object.defineproperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    value\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nmarkraw 是根据 __v_skip 标记实现的，在消费 effect 的时候，有此标记的 target 会跳过消费 effect 的过程，因此 markraw 的对象就不在具有响应式。\n\n\n# toraw\n\n官网释义\n\nreturns the raw, original object of a reactive or readonly proxy. this is an escape hatch that can be used to temporarily read without incurring proxy access/tracking overhead or write without triggering changes. it is not recommended to hold a persistent reference to the original object. use with caution.\n\n返回 reactive 或 readonly 代理的原始对象。这是一个 “逃生舱”，可用于临时读取数据而无需承担代理访问 / 跟踪的开销，也可用于写入数据而避免触发更改。不建议保留对原始对象的持久引用。请谨慎使用。\n\nexport function toraw<t>(observed: t): t {\n  return (\n    (observed && toraw((observed as target)[reactiveflags.raw])) || observed\n  )\n}\n\n\n1\n2\n3\n4\n5\n\n * 如果不是 proxy 对象就原样返回，否则就递归找到 raw object。需要注意的是这个针对响应式数据的一种 “逃生舱” 机制。\n * markraw 和 toraw 经常被用作一种优化的手段：在不需要通知视图时，减少数据变化引起的视图更新的花销；在数据不会变化的情况下，可以跳过 proxy，提高渲染性能。\n\n\n# q&a\n\n 1. createreactiveobject 创建了哪几种响应式的类型？\n\n * reactive：完全响应式的，即 deep reactivity。\n * readonly：完全只读的，即 deep readonly。\n * shallowreactive：浅层的响应式，即 shallow reactivity。\n * shallowreactive：浅层的只读，即 shallow readonly。\n\n 2. createreactiveobject 能够处理哪些类型的数据？\n\n从源码中对 target 的分类：\n\nfunction targettypemap(rawtype: string) {\n  switch (rawtype) {\n    case 'object':\n    case 'array':\n      return targettype.common\n    case 'map':\n    case 'set':\n    case 'weakmap':\n    case 'weakset':\n      return targettype.collection\n    default:\n      return targettype.invalid\n  }\n}\n\n// 获取 value 的类型\nfunction gettargettype(value: target) {\n  return value[reactiveflags.skip] || !object.isextensible(value)\n    ? targettype.invalid\n    : targettypemap(torawtype(value))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n可以处理的数据类型包括如下两类：\n\n * common：object、array。\n * collection：map、set、weakmap、weakset。\n\n另外，需要注意的是，如果对象有 configurable: false 与 writable: false 的属性，那该对象就无法被 proxy 代理。\n\n\n# 文章小结\n\n这篇文章时对 reactivity 模块中 reactive 的源码分析，分析了四种 reactive object 的创建过程。各种 reactive object 都是由 proxy 创建，创建是提供了不同的 handlers 和 proxymap，proxymap 就是对创建的 proxy 对象进行的缓存，handlers 是 proxy 机制的核心，是劫持、控制对象属性的重要部分，这部分我们在 handler 中详细分析。",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"Handler",frontmatter:{title:"Handler",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/basic/handler/",categories:["vue3","reactivity"],tags:[null]},regularPath:"/20.vue3/20.reactivity/30.handler.html",relativePath:"20.vue3/20.reactivity/30.handler.md",key:"v-eea5a8ce",path:"/vue3/basic/handler/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"baseHandlers",slug:"basehandlers",normalizedTitle:"basehandlers",charIndex:17},{level:3,title:"get",slug:"get",normalizedTitle:"get",charIndex:35},{level:4,title:"arrayInstrumentations",slug:"arrayinstrumentations",normalizedTitle:"arrayinstrumentations",charIndex:1871},{level:3,title:"set",slug:"set",normalizedTitle:"set",charIndex:44},{level:3,title:"deleteProperty",slug:"deleteproperty",normalizedTitle:"deleteproperty",charIndex:53},{level:3,title:"has",slug:"has",normalizedTitle:"has",charIndex:73},{level:3,title:"ownKeys",slug:"ownkeys",normalizedTitle:"ownkeys",charIndex:82},{level:3,title:"shallowGet",slug:"shallowget",normalizedTitle:"shallowget",charIndex:95},{level:3,title:"shallowSet",slug:"shallowset",normalizedTitle:"shallowset",charIndex:111},{level:3,title:"readonlyGet",slug:"readonlyget",normalizedTitle:"readonlyget",charIndex:127},{level:3,title:"shallowReadonlyGet",slug:"shallowreadonlyget",normalizedTitle:"shallowreadonlyget",charIndex:144},{level:2,title:"collectionHandlers",slug:"collectionhandlers",normalizedTitle:"collectionhandlers",charIndex:166},{level:3,title:"createInstrumentationGetter",slug:"createinstrumentationgetter",normalizedTitle:"createinstrumentationgetter",charIndex:190},{level:3,title:"createInstrumentations",slug:"createinstrumentations",normalizedTitle:"createinstrumentations",charIndex:223},{level:3,title:"get",slug:"get-2",normalizedTitle:"get",charIndex:35},{level:3,title:"size",slug:"size",normalizedTitle:"size",charIndex:260},{level:3,title:"has",slug:"has-2",normalizedTitle:"has",charIndex:73},{level:3,title:"add",slug:"add",normalizedTitle:"add",charIndex:279},{level:3,title:"set",slug:"set-2",normalizedTitle:"set",charIndex:44},{level:3,title:"delete",slug:"delete",normalizedTitle:"delete",charIndex:53},{level:3,title:"clear",slug:"clear",normalizedTitle:"clear",charIndex:309},{level:3,title:"forEach",slug:"foreach",normalizedTitle:"foreach",charIndex:320},{level:2,title:"Q&A",slug:"q-a",normalizedTitle:"q&amp;a",charIndex:null},{level:3,title:"Proxy Handlers 类别与权限的关系？",slug:"proxy-handlers-类别与权限的关系",normalizedTitle:"proxy handlers 类别与权限的关系？",charIndex:340},{level:3,title:"纯函数与 Tree Shaking",slug:"纯函数与-tree-shaking",normalizedTitle:"纯函数与 tree shaking",charIndex:370},{level:3,title:"Proxy对数组的代理",slug:"proxy对数组的代理",normalizedTitle:"proxy 对数组的代理",charIndex:18454},{level:3,title:"Proxy 对 Map、Set 等集合对象的代理",slug:"proxy-对-map、set-等集合对象的代理",normalizedTitle:"proxy 对 map、set 等集合对象的代理",charIndex:410},{level:2,title:"文章小结",slug:"文章小结",normalizedTitle:"文章小结",charIndex:438},{level:2,title:"参考链接",slug:"参考链接",normalizedTitle:"参考链接",charIndex:446}],readingTime:{text:"12 min read",minutes:11.565,time:693900,words:2313},headersStr:"目录 baseHandlers get arrayInstrumentations set deleteProperty has ownKeys shallowGet shallowSet readonlyGet shallowReadonlyGet collectionHandlers createInstrumentationGetter createInstrumentations get size has add set delete clear forEach Q&A Proxy Handlers 类别与权限的关系？ 纯函数与 Tree Shaking Proxy对数组的代理 Proxy 对 Map、Set 等集合对象的代理 文章小结 参考链接",content:"# 目录\n\n\n\n * 目录\n * baseHandlers\n   * get\n   * set\n   * deleteProperty\n   * has\n   * ownKeys\n   * shallowGet\n   * shallowSet\n   * readonlyGet\n   * shallowReadonlyGet\n * collectionHandlers\n   * createInstrumentationGetter\n   * createInstrumentations\n   * get\n   * size\n   * has\n   * add\n   * set\n   * delete\n   * clear\n   * forEach\n * Q&A\n   * Proxy Handlers 类别与权限的关系？\n   * 纯函数与 Tree Shaking\n   * Proxy对数组的代理\n   * Proxy 对 Map、Set 等集合对象的代理\n * 文章小结\n * 参考链接\n\n\n\n> 在 Reactive 文章中，我们知道四种 reactive object 使用了不同的 handler，这篇文章我们从 baseHandlers 和 collectionHandlers 两个类别去分析 handler 的详细原理。结合 Reactive 文章，就可以明晰 creative object 的创建过程了。\n\n\n# baseHandlers\n\nbaseHandlers 源码见文件 reactivity/baseHandlers.ts。baseHandlers 的作用是对 array、object 这些普通类型的响应式数据进行劫持。\n\n\n# get\n\n这个 handler 用于获取响应式数据的值。先看代码：\n\nconst get = /*#__PURE__*/ createGetter()\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target: Target, key: string | symbol, receiver: object) {\n    // __v_isReactive 和 __v_isReactive、__v_raw 这几个标记是特殊的属性，如果获取这两个属性的值，就直接返回判断结果\n    // 使用到这个 get 方法的一定是响应式的对象，那么智能是 reactive 或者 readonly。\n    // 一下是获取 target 的内置标记属性的值\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly\n    } else if (\n      key === ReactiveFlags.RAW &&\n      receiver ===\n        (isReadonly\n          ? shallow\n            ? shallowReadonlyMap\n            : readonlyMap\n          : shallow\n            ? shallowReactiveMap\n            : reactiveMap\n        )\n          // 如果获取 __v_raw 的值，且传入的 receiver ProxyMap 是正确的，则返回 target\n          // 注意：这里的 target 是 raw object。\n          // 由 receiver === proxyMap.get(target) 可知，receiver 是 proxy object，target 是 raw object。\n          .get(target)\n    ) {\n      return target\n    }\n\n    const targetIsArray = isArray(target)\n    // 如果不是 readonly，target 是数组且 key 在 arrayInstrumentations 对象中有记录\n    // 这里是对 target 数组的一些方法进行改装，这里获取的属性是函数的一些方法\n    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\n      return Reflect.get(arrayInstrumentations, key, receiver)\n    }\n    // 获取到 target[key],这里同样适用于数组，因为数组的特殊属性在上面已经考虑\n    const res = Reflect.get(target, key, receiver)\n    // 如果 key 是内置的 Symbol 属性或者 key 是不许追踪响应性的，就直接返回\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res\n    }\n    // Reactive target 则对target.key 进行依赖追踪\n    // 注意：这里和创建 ref 时的追踪呼应\n    if (!isReadonly) {\n      track(target, TrackOpTypes.GET, key)\n    }\n    // 如果是 shallow 的，直接返回就可以了，因为顶层属性已经进行了依赖追踪\n    if (shallow) {\n      return res\n    }\n    // 如果属性值是 ref 类型，，则需要解包装（unwrapping）\n    if (isRef(res)) {\n      // ref unwrapping - does not apply for Array + integer key.\n      // target 是数字且 key 是 string int 如 '1', 这是不需要解包装\n      const shouldUnwrap = !targetIsArray || !isIntegerKey(key)\n      return shouldUnwrap ? res.value : res\n    }\n    // typeof [] === \"object\"\n    // 数组和对象都会走到这里\n    if (isObject(res)) {\n      // Convert returned value into a proxy as well. we do the isObject check\n      // here to avoid invalid value warning. Also need to lazy access readonly\n      // and reactive here to avoid circular dependency.\n      // 数组和对象需要递归 proxy，这就实现了 deep proxy\n      return isReadonly ? readonly(res) : reactive(res)\n    }\n    // 其他的类型，如基本值类型会走到这里\n    return res\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n * /*#__PURE__*/ 将 createGetter 标记为纯函数，有利于在打包时进行 Tree Shaking，减小打包体积。详见：纯函数与 Tree Shaking\n * createGetter 返回一个 getter 函数。setter 的处理逻辑见下图。\n\n * 对内置的 proxy 属性进行处理：这些属性其实是在创建时传入的，比较特殊的返回 __v_raw 属性的值，获取这个属性需要传入与该 proxy object 相对应的 proxyMap，返回 target 是因为 target 本身就是 raw，注意这里传入 target 是 handlers.get () 默认的传参。\n * 这里比较有意思的是对响应式数组内部属性或方法的一些重写，我们可以看到，如果获取的是数组的下标的值，就会走和 object 一致的 track 程序，如果获取的是数组的一些方法属性就会单独的 track，换句话说也就是如果调用了响应式数组的方法就会被 track，为什么这样呢？难道是 Proxy Api 无法对数组的这些方法进行劫持吗？从 Proxy 对数组的监听 中我们知道，Proxy API 对于数组的方法也是可以劫持的。显然这里不使用与 object keys 一致的 track 方法，可以说是一种 hack 方法，这部分的分析我们在下文详述 arrayInstrumentations 。\n * 这里使用 Reflect.get 来获取对象的属性主要是因为 receiver，作为 Reflect.get 的第三个参数，receiver 将 this 进行了传递。同时反射的方式有利于函数式编程。参考：stackoverflow: JavaScript: Difference between Reflect.get() and obj['foo']\n * 如果获取的值是一个 ref 对象就会解包装，只有获取数组下标值是除外的。官网对此做出了解释：Ref unwrapping only happens when nested inside a reactive Object. There is no unwrapping performed when the ref is accessed from an Array or a native collection type like Map。参见：vue3: ref-unwrapping\n\n核心理解\n\n最重要的是下面的代码（摘录的片段）：\n\n\nif (!isReadonly) {\n  track(target, TrackOpTypes.GET, key)\n}\n\nif (isObject(res)) {\n  // Convert returned value into a proxy as well. we do the isObject check\n  // here to avoid invalid value warning. Also need to lazy access readonly\n  // and reactive here to avoid circular dependency.\n  // 数组和对象需要递归 proxy，这就实现了 deep proxy\n  return isReadonly ? readonly(res) : reactive(res)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n可以看到：\n\n * 除了 readonly 的不再具有响应式的数据，都是需要 track 的。也是就说响应式数据在 get handler 中都会被追踪和手机依赖，因为这个数据响应式的基础。那么我们可能会有这样的疑问，readonly 的数据既然不具有响应式，为什么还要单独的来控制，只要不给他响应性的能力不就可以了吗？需要注意的是 readonly !== none reactivity，readonly 的数据是只读的，不具有响应式只是一方面，最重要的还是要保证数据的只读性。一个数据只有先是非响应式的，然后才能是只读的，使用场景不同。\n * isObject 是判断了 object 和 array，需要注意的是，数组也会走这里的逻辑。根据数据是 readonly 还是 reactive，来进一步对数据做 deep proxy，才是响应式数据能够 deep reactivity 的原因。本质上这里是一种递归。\n\n前置知识 - handler.get()\n\nhandler.get () 方法用于拦截对象的读取属性操作。\n\nvar p = new Proxy(target, {\n  get: function(target, property, receiver) {\n  }\n});\n\n\n1\n2\n3\n4\n\n\n以下是传递给 get 方法的参数，this 上下文绑定在 handler 对象上.\n\n * target：目标对象。\n * property：被获取的属性名。\n * receiver：Proxy 对象或者继承 Proxy 的对象\n\n详见：MDN: handler.get()\n\n前置知识 - Reflect 和 Reflect.get()\n\nReflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 proxy handlers (en-US) 的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。Reflect 的所有属性和方法都是静态的（就像 Math 对象）。Reflect 对象提供的静态方法与 proxy handler methods (en-US) 的命名相同.Reflect 不支持 ie 浏览器。Reflect 让我们对对象的操作可以用函数来处理。\n\nReflect.get () 方法与从对象 (target [propertyKey]) 中读取属性类似，但它是通过一个函数执行来操作的。\n\nReflect.get(target, propertyKey[, receiver])\n\n\n1\n\n * target：需要取值的目标对象\n * propertyKey：需要获取的值的键值\n * receiver：与 Proxy 中的 receiver 项对应，如果 target 对象中指定了 getter，receiver 则为 getter 调用时的 this 值。\n\n参考：\n\n * MDN: Reflect\n * Reflect.get()\n * JS 的 Reflect 学习和应用\n * 一起來了解 Javascript 中的 Proxy 與 Reflect\n\n# arrayInstrumentations\n\narrayInstrumentations 是通过纯函数 createArrayInstrumentations 生成的：\n\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations()\n// 对数组的方法进行改装(hack)，以注入一些响应式的逻辑。\nfunction createArrayInstrumentations() {\n  const instrumentations: Record<string, Function> = {}\n  // instrument identity-sensitive Array methods to account for possible reactive\n  // values\n  // 针对查找性的方法进行 hack\n  ;(['includes', 'indexOf', 'lastIndexOf'] as const).forEach(key => {\n    // 从数组原型上获取到原方法\n    const method = Array.prototype[key] as any\n    // this 是指向 receiver 的，针对数组 receiver 要么传的是数组本身，要么不传，但是 receiver 的默认值就是 target\n    // 因此这里的 this 是指向 target 的，也就是数组本身\n    instrumentations[key] = function(this: unknown[], ...args: unknown[]) {\n      // 获取数组的 row value，receiver 是 proxy object\n      const arr = toRaw(this)\n      // 对数组的每一项进行 track\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, TrackOpTypes.GET, i + '')\n      }\n      // we run the method using the original args first (which may be reactive)\n      // 默认用户传的参数是 row vlaue。调用原函数。\n      const res = method.apply(arr, args)\n      if (res === -1 || res === false) {\n        // if that didn't work, run it again using raw values.\n        // 如果没找到，可能用户传的是 proxy value。这里自动帮用户转成 raw value\n        return method.apply(arr, args.map(toRaw))\n      } else {\n        return res\n      }\n    }\n  })\n  // instrument length-altering mutation methods to avoid length being tracked\n  // which leads to infinite loops in some cases (#2137)\n  // 针对改变数组长度的方法进行 hack\n  // 避免在某些情况下 track 会造成死循环的情况\n  ;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach(key => {\n    const method = Array.prototype[key] as any\n    instrumentations[key] = function(this: unknown[], ...args: unknown[]) {\n      // 在调用原方法时先关闭 track，调用完毕后再恢复上一次的 track 状态，避免造成死循环。\n      // 注意：这里 this 并没有转成 raw object。这里关闭了 track，但是 trigger 仍然可以触发。\n      pauseTracking()\n      const res = method.apply(this, args)\n      resetTracking()\n      return res\n    }\n  })\n  return instrumentations\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n * 这里针对数组的方法进行了 hack，主要有两类，第一类是 'includes', 'indexOf', 'lastIndexOf' 这些 identity-sensitive Array methods，跟查找相关的身份敏感的方法，这些方法在调用时需要先对数组的每一项进行 track。 第二类是 'push', 'pop', 'shift', 'unshift', 'splice' 这些 length-altering mutation methods，会改变数组长度的方法，为了避免死循环，这里在调用原方法之前先暂停 tracK，在调用完毕之后在恢复上一次的 track 状态。造成死循环的原因请参照：Proxy 对数组的监听。\n * 看完这段代码，我们最大的疑惑可能就是：为什么第一类方法需要提前对数组的每一项进行 track？ 第 2 类方法明明改变了数组却不用 trigger？第一类方法在调用的时候使用的是 raw object，并不会触发 track，所以在调用之前需要提交 track 每一项，第二类方法在调用的时候使用的是 proxy object，本身会触发 trigger，为了不引起死循环，才屏蔽了 track。\n\n\n# set\n\n这个 handler 用于增加或者更新响应式数据的值。先看代码：\n\nconst set = /*#__PURE__*/ createSetter()\nfunction createSetter(shallow = false) {\n  return function set(\n    target: object, // raw target object\n    key: string | symbol, // target property\n    value: unknown, // new value for property\n    receiver: object // proxy target object\n  ): boolean {\n    // 取出旧值\n    let oldValue = (target as any)[key]\n    if (!shallow) {\n      // value 需要转成 raw value\n      value = toRaw(value)\n      oldValue = toRaw(oldValue)\n      // 如果 target 不是数组，原值是 ref 对象现在传的不是 ref 对象，则仍然保持 ref\n      // 注意：这里 return 了，并没有触发 trigger\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value\n        return true\n      }\n    } else {\n      // in shallow mode, objects are set as-is regardless of reactive or not\n    }\n    // key 值是否在 target 中，如果是 array 的 int key 判断 key值是否合法\n    // 注意：这里的 key 值为负值，如 '-100'，情况已经在 isIntegerKey 排除了\n    const hadKey =\n      isArray(target) && isIntegerKey(key)\n        ? Number(key) < target.length\n        : hasOwn(target, key)\n    // 设置新值\n    const result = Reflect.set(target, key, value, receiver)\n    // don't trigger if target is something up in the prototype chain of original\n    // 操作原型链上的数据，不引起 trigger\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        // 增加新的属性\n        trigger(target, TriggerOpTypes.ADD, key, value)\n      } else if (hasChanged(value, oldValue)) {\n        // 修改原属性\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\n      }\n    }\n    return result\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n * 这里有一个奇怪的地方，在非 shallow 情况下，如果 一个不是数字的 target 旧值是 ref 对象新值却不是 ref 对象，这里直接修改了 ref.value 就 return 了，并没有触发后面的 trigger 啊，那是不是就不会响应了。其实并不是，修改 ref 对象本身就会触发 trigger 的，详见 ref 篇，所以这里仍然是保持了响应式。\n * target === toRaw(receiver) 说明只有在 receiver 刚好是 target 的 proxy 时才触发 trigger，这个判断看起来很多余其实不然，需要注意的是如果在 target 的原型链上执行 set 操作，并不会触发 trigger。\n * 这里通过 hadKey 来判断是 ADD 操作还是 SET，不同的操作类型所触发的 effects 集合也不尽相同。track 和 trigger 部分将在 effect 篇中详述。\n\n核心理解\n\nget () 引起 track ()，set () 引起 trigger ()，这与 ref 中 getter 中 track，setter 中 trigger 一致。get 和 set 可以对应理解为对数据的读和写操作，在读取数据中通过 track 收集依赖回调，在写数据时通过 trigger 对收集的依赖进行消费，对依赖于这个数据的部分进行更新，这就是 vue 响应式原理的核心。\n\n\n# deleteProperty\n\n这个 handler 用于删除响应式数据的值。\n\nfunction deleteProperty(target: object, key: string | symbol): boolean {\n  const hadKey = hasOwn(target, key)\n  const oldValue = (target as any)[key]\n  const result = Reflect.deleteProperty(target, key)\n  // key 值存在且删除成功时 trigger，类型为 DELETE\n  if (result && hadKey) {\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\n  }\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# has\n\n这个 handler 用于获取响应式数据的值。\n\nfunction has(target: object, key: string | symbol): boolean {\n  const result = Reflect.has(target, key)\n  // 如果 key 不是 Sumbol，或者不在 builtInSymbols 中，就 track\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\n    track(target, TrackOpTypes.HAS, key)\n  }\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nhas 属于读操作，在这里出发了 track。\n\n前置知识\n\nhandler.has () 的触发的时机： The handler.has () method is a trap for the in operator.\n\n参考：MDN: handler.has()\n\n\n# ownKeys\n\n这个 handler 用于遍历响应式数据的值（不包括值为 Symbol 项）。\n\nfunction ownKeys(target: object): (string | symbol)[] {\n  // 触发 track，类型为 ITERATE，key 参数不用重视，因为在 prod 用不到\n  track(target, TrackOpTypes.ITERATE, isArray(target) ? 'length' : ITERATE_KEY)\n  return Reflect.ownKeys(target)\n}\n\n\n1\n2\n3\n4\n5\n\n\n前置知识\n\nhandler.ownKeys () 的触发的时机：ownKeys 在 Object.keys() 执行时触发。\n\n参考：MDN: handler.ownKeys()\n\n\n# shallowGet\n\n用于 hallowReactive。\n\nconst shallowGet = /*#__PURE__*/ createGetter(false, true)\n\n\n1\n\n\n参照上文，直接在 track 之后返回，不用 deep reactivity。\n\n\n# shallowSet\n\n用于 shallowReactive。\n\nconst shallowSet = /*#__PURE__*/ createSetter(true)\n\n\n1\n\n\n相比于 set 变化不大。\n\n\n# readonlyGet\n\n用于 readonly。\n\nconst readonlyGet = /*#__PURE__*/ createGetter(true)\n\n\n1\n\n\n跳过 track 并执行了 deep readonly。\n\n\n# shallowReadonlyGet\n\n用于 shallowReadonly。\n\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true)\n\n\n1\n\n\n跳过了 track 并且直接返回了。\n\n\n# collectionHandlers\n\ncollectionHandlers 源码见文件 reactivity/collectionHandlers.ts。collectionHandlers 的作用是对 Map、Set、WeakSet、WeakMap 这些集合类型的响应式数据进行劫持。\n\n\n# createInstrumentationGetter\n\n用于 reactive、readonly、shallowReactive 和 shallowReadonly 四种响应式 API（所有）。\n\nfunction createInstrumentationGetter(isReadonly: boolean, shallow: boolean) {\n  // 根据 isReadonly 和 shallow 选择不同 instrumentations。\n  const instrumentations = shallow\n    ? isReadonly\n      ? shallowReadonlyInstrumentations\n      : shallowInstrumentations\n    : isReadonly\n      ? readonlyInstrumentations\n      : mutableInstrumentations\n\n  return (\n    target: CollectionTypes,\n    key: string | symbol,\n    receiver: CollectionTypes\n  ) => {\n    // buildin 的属性\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly\n    } else if (key === ReactiveFlags.RAW) {\n      return target\n    }\n\n    // 如果获取内置方法属性就从 instrumentations 中获取，否则从 target 获取，这是普通的取值操作\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target\n        ? instrumentations\n        : target,\n      key,\n      receiver\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n这段代码机器简洁，核心代码就在 return 语句中，如果 key 值在 instrumentations 中就从 instrumentations 取，否则就从 target 中取。而且我们已经注意到非常疑惑的一点就是：对于 CollectionTypes，似乎只配置了 get handler，这是非常奇怪的，Proxy 对这些集合对象的拦截肯定是没有问题的，那这到底是为什么呢？我们先来运行一些测试代码：\n\nconst m = new Map([[\"name\", 'any']]);\nconst p = new Proxy(m, {\n  get(target, key, receiver) {\n    const v = Reflect.get(...arguments);\n    console.info('==> get', key);\n    return typeof v === \"function\" ? v.bind(target) : v;\n  },\n  set(target, key, receiver) {\n    const v = Reflect.set(...arguments);\n    console.info('==> set', key);\n    return typeof v === \"function\" ? v.bind(target) : v;\n  },\n})\n// 以下代码在 console 中逐句运行\np.get(\"name\");\n// >> ==> get get\np.set('name', 'some')\n// >> ==> get set\np.delete(\"name\")\n// >> ==> get delete\np.clear()\n// >> ==> get clear\np.entries()\n// >> ==> get entries\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n现在我们知道原因了： Proxy Api 对于集合对象只会触发 get handler，其他都不会触发 。也就是说，我们只需要拦截 get 然后根据 key 做不同的处理即可。从上面的代码中可以看到，根据 isReadonly 和 shallow 的值选择了不同的 instrumentations，这个 instrumentations 中就包含了对于不同 key 值的处理。\n\n\n# createInstrumentations\n\n这个一个工厂函数，这个函数创建 isReadOnly 和 shallow 不同场景下的 handlers。\n\nfunction createInstrumentations() {\n  // reactive\n  const mutableInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key)\n    },\n    get size() {\n      return size((this as unknown) as IterableCollections)\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  }\n  // shallowReactive\n  const shallowInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key, false, true)\n    },\n    get size() {\n      return size((this as unknown) as IterableCollections)\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  }\n  // readOnly\n  const readonlyInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key, true)\n    },\n    get size() {\n      return size((this as unknown) as IterableCollections, true)\n    },\n    has(this: MapTypes, key: unknown) {\n      return has.call(this, key, true)\n    },\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\n    set: createReadonlyMethod(TriggerOpTypes.SET),\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\n    forEach: createForEach(true, false)\n  }\n  // shallowReadOnly\n  const shallowReadonlyInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key, true, true)\n    },\n    get size() {\n      return size((this as unknown) as IterableCollections, true)\n    },\n    has(this: MapTypes, key: unknown) {\n      return has.call(this, key, true)\n    },\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\n    set: createReadonlyMethod(TriggerOpTypes.SET),\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\n    forEach: createForEach(true, true)\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n我们来看一下核心的几个函数是如何处理的：\n\n\n# get\n\n\n# size\n\n\n# has\n\n\n# add\n\n\n# set\n\n\n# delete\n\n\n# clear\n\n\n# forEach\n\n\n# Q&A\n\n\n# Proxy Handlers 类别与权限的关系？\n\n权限      HANDLER\nread    get | has | ownKeys\nwrite   set | deleteProperty\n\n\n# 纯函数与 Tree Shaking\n\n什么是纯函数？\n\n在程序设计中，若一个函数符合以下要求，则它可能被认为是纯函数：\n\n * 此函数在相同的输入值时，需产生相同的输出。函数的输出和输入值以外的其他隐藏信息或状态无关，也和由 I/O 设备产生的外部输出无关。\n * 该函数不能有语义上可观察的函数副作用，诸如 “触发事件”，使输出设备输出，或更改输出值以外物件的内容等。\n\n什么是 Tree Shaking？\n\nTree Shaking：用于描述移除 JavaScript 上下文中的未引用代码 (dead-code)\n\n为什么纯函数比较有利于 Tree Shaking？\n\n/*#__PURE__*/ 标记表明被标记的代码是静态的，标记在函数前则表示被标记的函数是纯函数，纯函数在得到相同的输入后得到的输出是可预见的，打包器在遇到静态的代码时，就可以判断当前的代码是否有引用，没有引用的代码咋可以被安全的删除。而纯函数在得到确切的输入时，打包器就可以直接打包可预见的执行结果而将纯函数删除。这就是纯函数对于 Tree Shaking 的作用。之所以要认为的标记是因为打包器没有判断对目标函数做纯函数的判断，因为从表现上来看，村函数当然是被引用过了。\n\n参考资料：\n\n * Wiki: Pure function\n * 【译】精通 JavaScript： 什么是纯函数（Pure Function）？\n * Webpack: Tree Shaking\n\n\n# Proxy 对数组的代理\n\n下面我们来测试下如下的代码：\n\nconst arr = [1,2,3];\nconst proxy = new Proxy(arr, {\n  get: function (target, key, receiver) {\n      console.log('get的key为 ===> ' + key);\n      return Reflect.get(target, key, receiver);\n  },\n  set(target, key, value, receiver){\n      console.log('set的key为 ===> ' + key, value);\n      return Reflect.set(target, key, value, receiver);\n  }\n})\n// 注意：以下代码为逐行在 console 中执行。\nproxy[0]\n//>> get的key为 ===> 0\nproxy[3] = 12\n//>> set的key为 ===> 3 12\nproxy.includes(1)\n// >> get的key为 ===> includes\n// >> get的key为 ===> length\n// >> get的key为 ===> 0\nproxy.indexOf(2)\n// >> get的key为 ===> indexOf\n// >> get的key为 ===> length\n// >> get的key为 ===> 0\n// >> get的key为 ===> 1\n\nproxy.pop()\n// >> get的key为 ===> pop\n// >> get的key为 ===> length\n// >> get的key为 ===> 3\n// >> set的key为 ===> length 3\nproxy.push(4)\n// >> get的key为 ===> push\n// >> get的key为 ===> length\n// >> set的key为 ===> 3 4\n// >> set的key为 ===> length 4\nproxy.slice(0,1)\n//  >> get的key为 ===> slice\n//  >> get的key为 ===> length\n//  >> get的key为 ===> constructor\n//  >> get的key为 ===> 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n由如上的代码测试，我们可以看出：\n\n * Proxy 对于数组的属性和行为也具有拦截的作用，也就是说 Proxy API 是适用于数组的。\n * identity-sensitive Array methods （第一类）这类的数组方法，会触发多次 get ()，但是不会触发 set (); length-altering mutation methods （第二类）这类的数组方法可能会触发多次的 get () 和 set ()。\n * 由于触发 get () 就会触发 track ()，触发 set () 就会触发 trigger ()，所以第二类方法会连续触发多次的 track () 和 trigger ()，会造成死循环。\n * 如果我们把 receiver 打印出来的话，就会发现它其实是 target 的 proxy 对象，这也是 Proxy 和 Reflect 一起使用的好处。\n\n\n# Proxy 对 Map、Set 等集合对象的代理\n\n需要注意的是，集合元素是通过 get ()、add () 等方法操作，因此需要注意 this 的指向问题。\n\n执行如下代码：\n\nconst m = new Map([[\"name\", 'any']]);\nconst p = new Proxy(m, {\n  get(target, key, receiver) {\n    const v = Reflect.get(...arguments);\n    console.log({key, v}, this);\n    return v;\n  }\n})\np.get(\"name\");\n// >> {key: \"get\", v: ƒ}key: \"get\"v: ƒ ()arguments: (...)caller: (...)length: 1name: \"get\"[[Prototype]]: ƒ ()[[Scopes]]: Scopes[0][[Prototype]]: Object {get: ƒ}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这回报一个错误： Uncaught TypeError: Method Map.prototype.get called on incompatible receiver #<Map> 。这是因为此时的 this 指向了 get ()，v 的值是一个函数。而我们需要使 v 中 this 指向 target，因为需要从 target 中取值。改成下面的代码：\n\nconst m = new Map([[\"name\", 'any']]);\nconst p = new Proxy(m, {\n  get(target, key, receiver) {\n    const v = Reflect.get(...arguments);\n    console.log({key, v}, this);\n    return typeof v === \"function\" ? v.bind(target) : v;\n  }\n})\np.get(\"name\");\n// >> \"any\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这样就可以顺利的代理 Map 等集合对象了。\n\n\n# 文章小结\n\n\n# 参考链接\n\n * MDN: Proxy() constructor",normalizedContent:"# 目录\n\n\n\n * 目录\n * basehandlers\n   * get\n   * set\n   * deleteproperty\n   * has\n   * ownkeys\n   * shallowget\n   * shallowset\n   * readonlyget\n   * shallowreadonlyget\n * collectionhandlers\n   * createinstrumentationgetter\n   * createinstrumentations\n   * get\n   * size\n   * has\n   * add\n   * set\n   * delete\n   * clear\n   * foreach\n * q&a\n   * proxy handlers 类别与权限的关系？\n   * 纯函数与 tree shaking\n   * proxy对数组的代理\n   * proxy 对 map、set 等集合对象的代理\n * 文章小结\n * 参考链接\n\n\n\n> 在 reactive 文章中，我们知道四种 reactive object 使用了不同的 handler，这篇文章我们从 basehandlers 和 collectionhandlers 两个类别去分析 handler 的详细原理。结合 reactive 文章，就可以明晰 creative object 的创建过程了。\n\n\n# basehandlers\n\nbasehandlers 源码见文件 reactivity/basehandlers.ts。basehandlers 的作用是对 array、object 这些普通类型的响应式数据进行劫持。\n\n\n# get\n\n这个 handler 用于获取响应式数据的值。先看代码：\n\nconst get = /*#__pure__*/ creategetter()\nfunction creategetter(isreadonly = false, shallow = false) {\n  return function get(target: target, key: string | symbol, receiver: object) {\n    // __v_isreactive 和 __v_isreactive、__v_raw 这几个标记是特殊的属性，如果获取这两个属性的值，就直接返回判断结果\n    // 使用到这个 get 方法的一定是响应式的对象，那么智能是 reactive 或者 readonly。\n    // 一下是获取 target 的内置标记属性的值\n    if (key === reactiveflags.is_reactive) {\n      return !isreadonly\n    } else if (key === reactiveflags.is_readonly) {\n      return isreadonly\n    } else if (\n      key === reactiveflags.raw &&\n      receiver ===\n        (isreadonly\n          ? shallow\n            ? shallowreadonlymap\n            : readonlymap\n          : shallow\n            ? shallowreactivemap\n            : reactivemap\n        )\n          // 如果获取 __v_raw 的值，且传入的 receiver proxymap 是正确的，则返回 target\n          // 注意：这里的 target 是 raw object。\n          // 由 receiver === proxymap.get(target) 可知，receiver 是 proxy object，target 是 raw object。\n          .get(target)\n    ) {\n      return target\n    }\n\n    const targetisarray = isarray(target)\n    // 如果不是 readonly，target 是数组且 key 在 arrayinstrumentations 对象中有记录\n    // 这里是对 target 数组的一些方法进行改装，这里获取的属性是函数的一些方法\n    if (!isreadonly && targetisarray && hasown(arrayinstrumentations, key)) {\n      return reflect.get(arrayinstrumentations, key, receiver)\n    }\n    // 获取到 target[key],这里同样适用于数组，因为数组的特殊属性在上面已经考虑\n    const res = reflect.get(target, key, receiver)\n    // 如果 key 是内置的 symbol 属性或者 key 是不许追踪响应性的，就直接返回\n    if (issymbol(key) ? builtinsymbols.has(key) : isnontrackablekeys(key)) {\n      return res\n    }\n    // reactive target 则对target.key 进行依赖追踪\n    // 注意：这里和创建 ref 时的追踪呼应\n    if (!isreadonly) {\n      track(target, trackoptypes.get, key)\n    }\n    // 如果是 shallow 的，直接返回就可以了，因为顶层属性已经进行了依赖追踪\n    if (shallow) {\n      return res\n    }\n    // 如果属性值是 ref 类型，，则需要解包装（unwrapping）\n    if (isref(res)) {\n      // ref unwrapping - does not apply for array + integer key.\n      // target 是数字且 key 是 string int 如 '1', 这是不需要解包装\n      const shouldunwrap = !targetisarray || !isintegerkey(key)\n      return shouldunwrap ? res.value : res\n    }\n    // typeof [] === \"object\"\n    // 数组和对象都会走到这里\n    if (isobject(res)) {\n      // convert returned value into a proxy as well. we do the isobject check\n      // here to avoid invalid value warning. also need to lazy access readonly\n      // and reactive here to avoid circular dependency.\n      // 数组和对象需要递归 proxy，这就实现了 deep proxy\n      return isreadonly ? readonly(res) : reactive(res)\n    }\n    // 其他的类型，如基本值类型会走到这里\n    return res\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n * /*#__pure__*/ 将 creategetter 标记为纯函数，有利于在打包时进行 tree shaking，减小打包体积。详见：纯函数与 tree shaking\n * creategetter 返回一个 getter 函数。setter 的处理逻辑见下图。\n\n * 对内置的 proxy 属性进行处理：这些属性其实是在创建时传入的，比较特殊的返回 __v_raw 属性的值，获取这个属性需要传入与该 proxy object 相对应的 proxymap，返回 target 是因为 target 本身就是 raw，注意这里传入 target 是 handlers.get () 默认的传参。\n * 这里比较有意思的是对响应式数组内部属性或方法的一些重写，我们可以看到，如果获取的是数组的下标的值，就会走和 object 一致的 track 程序，如果获取的是数组的一些方法属性就会单独的 track，换句话说也就是如果调用了响应式数组的方法就会被 track，为什么这样呢？难道是 proxy api 无法对数组的这些方法进行劫持吗？从 proxy 对数组的监听 中我们知道，proxy api 对于数组的方法也是可以劫持的。显然这里不使用与 object keys 一致的 track 方法，可以说是一种 hack 方法，这部分的分析我们在下文详述 arrayinstrumentations 。\n * 这里使用 reflect.get 来获取对象的属性主要是因为 receiver，作为 reflect.get 的第三个参数，receiver 将 this 进行了传递。同时反射的方式有利于函数式编程。参考：stackoverflow: javascript: difference between reflect.get() and obj['foo']\n * 如果获取的值是一个 ref 对象就会解包装，只有获取数组下标值是除外的。官网对此做出了解释：ref unwrapping only happens when nested inside a reactive object. there is no unwrapping performed when the ref is accessed from an array or a native collection type like map。参见：vue3: ref-unwrapping\n\n核心理解\n\n最重要的是下面的代码（摘录的片段）：\n\n\nif (!isreadonly) {\n  track(target, trackoptypes.get, key)\n}\n\nif (isobject(res)) {\n  // convert returned value into a proxy as well. we do the isobject check\n  // here to avoid invalid value warning. also need to lazy access readonly\n  // and reactive here to avoid circular dependency.\n  // 数组和对象需要递归 proxy，这就实现了 deep proxy\n  return isreadonly ? readonly(res) : reactive(res)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n可以看到：\n\n * 除了 readonly 的不再具有响应式的数据，都是需要 track 的。也是就说响应式数据在 get handler 中都会被追踪和手机依赖，因为这个数据响应式的基础。那么我们可能会有这样的疑问，readonly 的数据既然不具有响应式，为什么还要单独的来控制，只要不给他响应性的能力不就可以了吗？需要注意的是 readonly !== none reactivity，readonly 的数据是只读的，不具有响应式只是一方面，最重要的还是要保证数据的只读性。一个数据只有先是非响应式的，然后才能是只读的，使用场景不同。\n * isobject 是判断了 object 和 array，需要注意的是，数组也会走这里的逻辑。根据数据是 readonly 还是 reactive，来进一步对数据做 deep proxy，才是响应式数据能够 deep reactivity 的原因。本质上这里是一种递归。\n\n前置知识 - handler.get()\n\nhandler.get () 方法用于拦截对象的读取属性操作。\n\nvar p = new proxy(target, {\n  get: function(target, property, receiver) {\n  }\n});\n\n\n1\n2\n3\n4\n\n\n以下是传递给 get 方法的参数，this 上下文绑定在 handler 对象上.\n\n * target：目标对象。\n * property：被获取的属性名。\n * receiver：proxy 对象或者继承 proxy 的对象\n\n详见：mdn: handler.get()\n\n前置知识 - reflect 和 reflect.get()\n\nreflect 是一个内置的对象，它提供拦截 javascript 操作的方法。这些方法与 proxy handlers (en-us) 的方法相同。reflect 不是一个函数对象，因此它是不可构造的。reflect 的所有属性和方法都是静态的（就像 math 对象）。reflect 对象提供的静态方法与 proxy handler methods (en-us) 的命名相同.reflect 不支持 ie 浏览器。reflect 让我们对对象的操作可以用函数来处理。\n\nreflect.get () 方法与从对象 (target [propertykey]) 中读取属性类似，但它是通过一个函数执行来操作的。\n\nreflect.get(target, propertykey[, receiver])\n\n\n1\n\n * target：需要取值的目标对象\n * propertykey：需要获取的值的键值\n * receiver：与 proxy 中的 receiver 项对应，如果 target 对象中指定了 getter，receiver 则为 getter 调用时的 this 值。\n\n参考：\n\n * mdn: reflect\n * reflect.get()\n * js 的 reflect 学习和应用\n * 一起來了解 javascript 中的 proxy 與 reflect\n\n# arrayinstrumentations\n\narrayinstrumentations 是通过纯函数 createarrayinstrumentations 生成的：\n\nconst arrayinstrumentations = /*#__pure__*/ createarrayinstrumentations()\n// 对数组的方法进行改装(hack)，以注入一些响应式的逻辑。\nfunction createarrayinstrumentations() {\n  const instrumentations: record<string, function> = {}\n  // instrument identity-sensitive array methods to account for possible reactive\n  // values\n  // 针对查找性的方法进行 hack\n  ;(['includes', 'indexof', 'lastindexof'] as const).foreach(key => {\n    // 从数组原型上获取到原方法\n    const method = array.prototype[key] as any\n    // this 是指向 receiver 的，针对数组 receiver 要么传的是数组本身，要么不传，但是 receiver 的默认值就是 target\n    // 因此这里的 this 是指向 target 的，也就是数组本身\n    instrumentations[key] = function(this: unknown[], ...args: unknown[]) {\n      // 获取数组的 row value，receiver 是 proxy object\n      const arr = toraw(this)\n      // 对数组的每一项进行 track\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, trackoptypes.get, i + '')\n      }\n      // we run the method using the original args first (which may be reactive)\n      // 默认用户传的参数是 row vlaue。调用原函数。\n      const res = method.apply(arr, args)\n      if (res === -1 || res === false) {\n        // if that didn't work, run it again using raw values.\n        // 如果没找到，可能用户传的是 proxy value。这里自动帮用户转成 raw value\n        return method.apply(arr, args.map(toraw))\n      } else {\n        return res\n      }\n    }\n  })\n  // instrument length-altering mutation methods to avoid length being tracked\n  // which leads to infinite loops in some cases (#2137)\n  // 针对改变数组长度的方法进行 hack\n  // 避免在某些情况下 track 会造成死循环的情况\n  ;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).foreach(key => {\n    const method = array.prototype[key] as any\n    instrumentations[key] = function(this: unknown[], ...args: unknown[]) {\n      // 在调用原方法时先关闭 track，调用完毕后再恢复上一次的 track 状态，避免造成死循环。\n      // 注意：这里 this 并没有转成 raw object。这里关闭了 track，但是 trigger 仍然可以触发。\n      pausetracking()\n      const res = method.apply(this, args)\n      resettracking()\n      return res\n    }\n  })\n  return instrumentations\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n * 这里针对数组的方法进行了 hack，主要有两类，第一类是 'includes', 'indexof', 'lastindexof' 这些 identity-sensitive array methods，跟查找相关的身份敏感的方法，这些方法在调用时需要先对数组的每一项进行 track。 第二类是 'push', 'pop', 'shift', 'unshift', 'splice' 这些 length-altering mutation methods，会改变数组长度的方法，为了避免死循环，这里在调用原方法之前先暂停 track，在调用完毕之后在恢复上一次的 track 状态。造成死循环的原因请参照：proxy 对数组的监听。\n * 看完这段代码，我们最大的疑惑可能就是：为什么第一类方法需要提前对数组的每一项进行 track？ 第 2 类方法明明改变了数组却不用 trigger？第一类方法在调用的时候使用的是 raw object，并不会触发 track，所以在调用之前需要提交 track 每一项，第二类方法在调用的时候使用的是 proxy object，本身会触发 trigger，为了不引起死循环，才屏蔽了 track。\n\n\n# set\n\n这个 handler 用于增加或者更新响应式数据的值。先看代码：\n\nconst set = /*#__pure__*/ createsetter()\nfunction createsetter(shallow = false) {\n  return function set(\n    target: object, // raw target object\n    key: string | symbol, // target property\n    value: unknown, // new value for property\n    receiver: object // proxy target object\n  ): boolean {\n    // 取出旧值\n    let oldvalue = (target as any)[key]\n    if (!shallow) {\n      // value 需要转成 raw value\n      value = toraw(value)\n      oldvalue = toraw(oldvalue)\n      // 如果 target 不是数组，原值是 ref 对象现在传的不是 ref 对象，则仍然保持 ref\n      // 注意：这里 return 了，并没有触发 trigger\n      if (!isarray(target) && isref(oldvalue) && !isref(value)) {\n        oldvalue.value = value\n        return true\n      }\n    } else {\n      // in shallow mode, objects are set as-is regardless of reactive or not\n    }\n    // key 值是否在 target 中，如果是 array 的 int key 判断 key值是否合法\n    // 注意：这里的 key 值为负值，如 '-100'，情况已经在 isintegerkey 排除了\n    const hadkey =\n      isarray(target) && isintegerkey(key)\n        ? number(key) < target.length\n        : hasown(target, key)\n    // 设置新值\n    const result = reflect.set(target, key, value, receiver)\n    // don't trigger if target is something up in the prototype chain of original\n    // 操作原型链上的数据，不引起 trigger\n    if (target === toraw(receiver)) {\n      if (!hadkey) {\n        // 增加新的属性\n        trigger(target, triggeroptypes.add, key, value)\n      } else if (haschanged(value, oldvalue)) {\n        // 修改原属性\n        trigger(target, triggeroptypes.set, key, value, oldvalue)\n      }\n    }\n    return result\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n * 这里有一个奇怪的地方，在非 shallow 情况下，如果 一个不是数字的 target 旧值是 ref 对象新值却不是 ref 对象，这里直接修改了 ref.value 就 return 了，并没有触发后面的 trigger 啊，那是不是就不会响应了。其实并不是，修改 ref 对象本身就会触发 trigger 的，详见 ref 篇，所以这里仍然是保持了响应式。\n * target === toraw(receiver) 说明只有在 receiver 刚好是 target 的 proxy 时才触发 trigger，这个判断看起来很多余其实不然，需要注意的是如果在 target 的原型链上执行 set 操作，并不会触发 trigger。\n * 这里通过 hadkey 来判断是 add 操作还是 set，不同的操作类型所触发的 effects 集合也不尽相同。track 和 trigger 部分将在 effect 篇中详述。\n\n核心理解\n\nget () 引起 track ()，set () 引起 trigger ()，这与 ref 中 getter 中 track，setter 中 trigger 一致。get 和 set 可以对应理解为对数据的读和写操作，在读取数据中通过 track 收集依赖回调，在写数据时通过 trigger 对收集的依赖进行消费，对依赖于这个数据的部分进行更新，这就是 vue 响应式原理的核心。\n\n\n# deleteproperty\n\n这个 handler 用于删除响应式数据的值。\n\nfunction deleteproperty(target: object, key: string | symbol): boolean {\n  const hadkey = hasown(target, key)\n  const oldvalue = (target as any)[key]\n  const result = reflect.deleteproperty(target, key)\n  // key 值存在且删除成功时 trigger，类型为 delete\n  if (result && hadkey) {\n    trigger(target, triggeroptypes.delete, key, undefined, oldvalue)\n  }\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# has\n\n这个 handler 用于获取响应式数据的值。\n\nfunction has(target: object, key: string | symbol): boolean {\n  const result = reflect.has(target, key)\n  // 如果 key 不是 sumbol，或者不在 builtinsymbols 中，就 track\n  if (!issymbol(key) || !builtinsymbols.has(key)) {\n    track(target, trackoptypes.has, key)\n  }\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nhas 属于读操作，在这里出发了 track。\n\n前置知识\n\nhandler.has () 的触发的时机： the handler.has () method is a trap for the in operator.\n\n参考：mdn: handler.has()\n\n\n# ownkeys\n\n这个 handler 用于遍历响应式数据的值（不包括值为 symbol 项）。\n\nfunction ownkeys(target: object): (string | symbol)[] {\n  // 触发 track，类型为 iterate，key 参数不用重视，因为在 prod 用不到\n  track(target, trackoptypes.iterate, isarray(target) ? 'length' : iterate_key)\n  return reflect.ownkeys(target)\n}\n\n\n1\n2\n3\n4\n5\n\n\n前置知识\n\nhandler.ownkeys () 的触发的时机：ownkeys 在 object.keys() 执行时触发。\n\n参考：mdn: handler.ownkeys()\n\n\n# shallowget\n\n用于 hallowreactive。\n\nconst shallowget = /*#__pure__*/ creategetter(false, true)\n\n\n1\n\n\n参照上文，直接在 track 之后返回，不用 deep reactivity。\n\n\n# shallowset\n\n用于 shallowreactive。\n\nconst shallowset = /*#__pure__*/ createsetter(true)\n\n\n1\n\n\n相比于 set 变化不大。\n\n\n# readonlyget\n\n用于 readonly。\n\nconst readonlyget = /*#__pure__*/ creategetter(true)\n\n\n1\n\n\n跳过 track 并执行了 deep readonly。\n\n\n# shallowreadonlyget\n\n用于 shallowreadonly。\n\nconst shallowreadonlyget = /*#__pure__*/ creategetter(true, true)\n\n\n1\n\n\n跳过了 track 并且直接返回了。\n\n\n# collectionhandlers\n\ncollectionhandlers 源码见文件 reactivity/collectionhandlers.ts。collectionhandlers 的作用是对 map、set、weakset、weakmap 这些集合类型的响应式数据进行劫持。\n\n\n# createinstrumentationgetter\n\n用于 reactive、readonly、shallowreactive 和 shallowreadonly 四种响应式 api（所有）。\n\nfunction createinstrumentationgetter(isreadonly: boolean, shallow: boolean) {\n  // 根据 isreadonly 和 shallow 选择不同 instrumentations。\n  const instrumentations = shallow\n    ? isreadonly\n      ? shallowreadonlyinstrumentations\n      : shallowinstrumentations\n    : isreadonly\n      ? readonlyinstrumentations\n      : mutableinstrumentations\n\n  return (\n    target: collectiontypes,\n    key: string | symbol,\n    receiver: collectiontypes\n  ) => {\n    // buildin 的属性\n    if (key === reactiveflags.is_reactive) {\n      return !isreadonly\n    } else if (key === reactiveflags.is_readonly) {\n      return isreadonly\n    } else if (key === reactiveflags.raw) {\n      return target\n    }\n\n    // 如果获取内置方法属性就从 instrumentations 中获取，否则从 target 获取，这是普通的取值操作\n    return reflect.get(\n      hasown(instrumentations, key) && key in target\n        ? instrumentations\n        : target,\n      key,\n      receiver\n    )\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n这段代码机器简洁，核心代码就在 return 语句中，如果 key 值在 instrumentations 中就从 instrumentations 取，否则就从 target 中取。而且我们已经注意到非常疑惑的一点就是：对于 collectiontypes，似乎只配置了 get handler，这是非常奇怪的，proxy 对这些集合对象的拦截肯定是没有问题的，那这到底是为什么呢？我们先来运行一些测试代码：\n\nconst m = new map([[\"name\", 'any']]);\nconst p = new proxy(m, {\n  get(target, key, receiver) {\n    const v = reflect.get(...arguments);\n    console.info('==> get', key);\n    return typeof v === \"function\" ? v.bind(target) : v;\n  },\n  set(target, key, receiver) {\n    const v = reflect.set(...arguments);\n    console.info('==> set', key);\n    return typeof v === \"function\" ? v.bind(target) : v;\n  },\n})\n// 以下代码在 console 中逐句运行\np.get(\"name\");\n// >> ==> get get\np.set('name', 'some')\n// >> ==> get set\np.delete(\"name\")\n// >> ==> get delete\np.clear()\n// >> ==> get clear\np.entries()\n// >> ==> get entries\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n现在我们知道原因了： proxy api 对于集合对象只会触发 get handler，其他都不会触发 。也就是说，我们只需要拦截 get 然后根据 key 做不同的处理即可。从上面的代码中可以看到，根据 isreadonly 和 shallow 的值选择了不同的 instrumentations，这个 instrumentations 中就包含了对于不同 key 值的处理。\n\n\n# createinstrumentations\n\n这个一个工厂函数，这个函数创建 isreadonly 和 shallow 不同场景下的 handlers。\n\nfunction createinstrumentations() {\n  // reactive\n  const mutableinstrumentations: record<string, function> = {\n    get(this: maptypes, key: unknown) {\n      return get(this, key)\n    },\n    get size() {\n      return size((this as unknown) as iterablecollections)\n    },\n    has,\n    add,\n    set,\n    delete: deleteentry,\n    clear,\n    foreach: createforeach(false, false)\n  }\n  // shallowreactive\n  const shallowinstrumentations: record<string, function> = {\n    get(this: maptypes, key: unknown) {\n      return get(this, key, false, true)\n    },\n    get size() {\n      return size((this as unknown) as iterablecollections)\n    },\n    has,\n    add,\n    set,\n    delete: deleteentry,\n    clear,\n    foreach: createforeach(false, true)\n  }\n  // readonly\n  const readonlyinstrumentations: record<string, function> = {\n    get(this: maptypes, key: unknown) {\n      return get(this, key, true)\n    },\n    get size() {\n      return size((this as unknown) as iterablecollections, true)\n    },\n    has(this: maptypes, key: unknown) {\n      return has.call(this, key, true)\n    },\n    add: createreadonlymethod(triggeroptypes.add),\n    set: createreadonlymethod(triggeroptypes.set),\n    delete: createreadonlymethod(triggeroptypes.delete),\n    clear: createreadonlymethod(triggeroptypes.clear),\n    foreach: createforeach(true, false)\n  }\n  // shallowreadonly\n  const shallowreadonlyinstrumentations: record<string, function> = {\n    get(this: maptypes, key: unknown) {\n      return get(this, key, true, true)\n    },\n    get size() {\n      return size((this as unknown) as iterablecollections, true)\n    },\n    has(this: maptypes, key: unknown) {\n      return has.call(this, key, true)\n    },\n    add: createreadonlymethod(triggeroptypes.add),\n    set: createreadonlymethod(triggeroptypes.set),\n    delete: createreadonlymethod(triggeroptypes.delete),\n    clear: createreadonlymethod(triggeroptypes.clear),\n    foreach: createforeach(true, true)\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n我们来看一下核心的几个函数是如何处理的：\n\n\n# get\n\n\n# size\n\n\n# has\n\n\n# add\n\n\n# set\n\n\n# delete\n\n\n# clear\n\n\n# foreach\n\n\n# q&a\n\n\n# proxy handlers 类别与权限的关系？\n\n权限      handler\nread    get | has | ownkeys\nwrite   set | deleteproperty\n\n\n# 纯函数与 tree shaking\n\n什么是纯函数？\n\n在程序设计中，若一个函数符合以下要求，则它可能被认为是纯函数：\n\n * 此函数在相同的输入值时，需产生相同的输出。函数的输出和输入值以外的其他隐藏信息或状态无关，也和由 i/o 设备产生的外部输出无关。\n * 该函数不能有语义上可观察的函数副作用，诸如 “触发事件”，使输出设备输出，或更改输出值以外物件的内容等。\n\n什么是 tree shaking？\n\ntree shaking：用于描述移除 javascript 上下文中的未引用代码 (dead-code)\n\n为什么纯函数比较有利于 tree shaking？\n\n/*#__pure__*/ 标记表明被标记的代码是静态的，标记在函数前则表示被标记的函数是纯函数，纯函数在得到相同的输入后得到的输出是可预见的，打包器在遇到静态的代码时，就可以判断当前的代码是否有引用，没有引用的代码咋可以被安全的删除。而纯函数在得到确切的输入时，打包器就可以直接打包可预见的执行结果而将纯函数删除。这就是纯函数对于 tree shaking 的作用。之所以要认为的标记是因为打包器没有判断对目标函数做纯函数的判断，因为从表现上来看，村函数当然是被引用过了。\n\n参考资料：\n\n * wiki: pure function\n * 【译】精通 javascript： 什么是纯函数（pure function）？\n * webpack: tree shaking\n\n\n# proxy 对数组的代理\n\n下面我们来测试下如下的代码：\n\nconst arr = [1,2,3];\nconst proxy = new proxy(arr, {\n  get: function (target, key, receiver) {\n      console.log('get的key为 ===> ' + key);\n      return reflect.get(target, key, receiver);\n  },\n  set(target, key, value, receiver){\n      console.log('set的key为 ===> ' + key, value);\n      return reflect.set(target, key, value, receiver);\n  }\n})\n// 注意：以下代码为逐行在 console 中执行。\nproxy[0]\n//>> get的key为 ===> 0\nproxy[3] = 12\n//>> set的key为 ===> 3 12\nproxy.includes(1)\n// >> get的key为 ===> includes\n// >> get的key为 ===> length\n// >> get的key为 ===> 0\nproxy.indexof(2)\n// >> get的key为 ===> indexof\n// >> get的key为 ===> length\n// >> get的key为 ===> 0\n// >> get的key为 ===> 1\n\nproxy.pop()\n// >> get的key为 ===> pop\n// >> get的key为 ===> length\n// >> get的key为 ===> 3\n// >> set的key为 ===> length 3\nproxy.push(4)\n// >> get的key为 ===> push\n// >> get的key为 ===> length\n// >> set的key为 ===> 3 4\n// >> set的key为 ===> length 4\nproxy.slice(0,1)\n//  >> get的key为 ===> slice\n//  >> get的key为 ===> length\n//  >> get的key为 ===> constructor\n//  >> get的key为 ===> 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n由如上的代码测试，我们可以看出：\n\n * proxy 对于数组的属性和行为也具有拦截的作用，也就是说 proxy api 是适用于数组的。\n * identity-sensitive array methods （第一类）这类的数组方法，会触发多次 get ()，但是不会触发 set (); length-altering mutation methods （第二类）这类的数组方法可能会触发多次的 get () 和 set ()。\n * 由于触发 get () 就会触发 track ()，触发 set () 就会触发 trigger ()，所以第二类方法会连续触发多次的 track () 和 trigger ()，会造成死循环。\n * 如果我们把 receiver 打印出来的话，就会发现它其实是 target 的 proxy 对象，这也是 proxy 和 reflect 一起使用的好处。\n\n\n# proxy 对 map、set 等集合对象的代理\n\n需要注意的是，集合元素是通过 get ()、add () 等方法操作，因此需要注意 this 的指向问题。\n\n执行如下代码：\n\nconst m = new map([[\"name\", 'any']]);\nconst p = new proxy(m, {\n  get(target, key, receiver) {\n    const v = reflect.get(...arguments);\n    console.log({key, v}, this);\n    return v;\n  }\n})\np.get(\"name\");\n// >> {key: \"get\", v: ƒ}key: \"get\"v: ƒ ()arguments: (...)caller: (...)length: 1name: \"get\"[[prototype]]: ƒ ()[[scopes]]: scopes[0][[prototype]]: object {get: ƒ}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这回报一个错误： uncaught typeerror: method map.prototype.get called on incompatible receiver #<map> 。这是因为此时的 this 指向了 get ()，v 的值是一个函数。而我们需要使 v 中 this 指向 target，因为需要从 target 中取值。改成下面的代码：\n\nconst m = new map([[\"name\", 'any']]);\nconst p = new proxy(m, {\n  get(target, key, receiver) {\n    const v = reflect.get(...arguments);\n    console.log({key, v}, this);\n    return typeof v === \"function\" ? v.bind(target) : v;\n  }\n})\np.get(\"name\");\n// >> \"any\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这样就可以顺利的代理 map 等集合对象了。\n\n\n# 文章小结\n\n\n# 参考链接\n\n * mdn: proxy() constructor",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"Effect",frontmatter:{title:"Effect",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/basic/effect/",categories:["vue3","reactivity"],tags:[null]},regularPath:"/20.vue3/20.reactivity/40.effect.html",relativePath:"20.vue3/20.reactivity/40.effect.md",key:"v-7c3809bd",path:"/vue3/basic/effect/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"effects",slug:"effects",normalizedTitle:"effects",charIndex:17},{level:2,title:"track",slug:"track",normalizedTitle:"track",charIndex:28},{level:2,title:"trigger",slug:"trigger",normalizedTitle:"trigger",charIndex:37},{level:2,title:"track 的暂停与恢复",slug:"track-的暂停与恢复",normalizedTitle:"track 的暂停与恢复",charIndex:48},{level:2,title:"一些问题",slug:"一些问题",normalizedTitle:"一些问题",charIndex:64},{level:3,title:"effect 流程",slug:"effect-流程",normalizedTitle:"effect 流程",charIndex:74},{level:2,title:"文章小结",slug:"文章小结",normalizedTitle:"文章小结",charIndex:87}],readingTime:{text:"9 min read",minutes:8.28,time:496799.99999999994,words:1656},headersStr:"目录 effects track trigger track 的暂停与恢复 一些问题 effect 流程 文章小结",content:"# 目录\n\n\n\n * 目录\n * effects\n * track\n * trigger\n * track 的暂停与恢复\n * 一些问题\n   * effect 流程\n * 文章小结\n\n\n\n\n# effects\n\n通过 effect 函数创建 effect，可以将 fn (回调) 包装成一个 effect 对象。\n\nexport function effect<T = any>(\n  fn: () => T, // 创建 effect 的回调函数\n  options: ReactiveEffectOptions = EMPTY_OBJ // 创建 effect 的配置项\n): ReactiveEffect<T> {\n  if (isEffect(fn)) {\n    // 如果已经是一个 effect 对象，则以 raw fn 重新创建 effect\n    fn = fn.raw\n  }\n  // 用回调函数和配置项创建 effect\n  const effect = createReactiveEffect(fn, options)\n  // 除 lazy effect 之外都应该立即执行一遍\n  // 为什么在创建完 effect 要执行一遍？初始化响应式的代码逻辑\n  if (!options.lazy) {\n    effect()\n  }\n  return effect\n}\nexport function isEffect(fn: any): fn is ReactiveEffect {\n  // 通过 _isEffect 属性来判断是否是 effect 对象\n  return fn && fn._isEffect === true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这个函数的核心是调用 createReactiveEffect 工厂函数创建 effect。\n\n先来看看什么是 effect：\n\nexport interface ReactiveEffect<T = any> {\n  (): T\n  _isEffect: true // 是否是 effect 对象的标志，isEffect 判断的根据\n  id: number // effect id\n  active: boolean // 是否处于激活状态，没有被 stop 的 effect 都属于激活状态\n  raw: () => T // 原本的回调，就是被包装的回调函数\n  deps: Array<Dep> // 当前 effect 所属于的依赖数组，结构为 Array<Set>，每个 Set 代表 Map<key, effect>\n  options: ReactiveEffectOptions // 当前 effect 的配置项\n  allowRecurse: boolean // 是否允许递归\n}\nexport interface ReactiveEffectOptions {\n  lazy?: boolean // 是否懒响应，懒响应的 effect 创建时不执行\n  scheduler?: (job: ReactiveEffect) => void // effect 的调度器，如果有调度器，在执行 effect 时会交由调度器处理\n  onTrack?: (event: DebuggerEvent) => void // 用于 dev 环境，跟踪 track 过程，track 执行时触发\n  onTrigger?: (event: DebuggerEvent) => void // 用于 dev 环境，跟踪 trigger 过程，run effect 时触发\n  onStop?: () => void // stop effect 时触发\n  allowRecurse?: boolean // 交给调度器时是否允许递归触发\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n重点来看下 createReactiveEffect 函数：\n\n// 当前真该执行的 effect 的栈\nconst effectStack: ReactiveEffect[] = []\nfunction createReactiveEffect<T = any>(\n  fn: () => T,\n  options: ReactiveEffectOptions\n): ReactiveEffect<T> {\n  // 根据 fn 创建一个 effect，effect 本质上是一个 function，是可以执行的\n  const effect = function reactiveEffect(): unknown {\n    // 注意：此函数在 effect 执行时调用，effect的属性是有值的\n    // 如果当前 effect 已经被 stop 了，就执行他\n    // 如果是 scheduled effect，即时 stop 了也执行，但是不开启 track\n    // effect 就是指当前的 effect 函数\n    if (!effect.active) {\n      return fn()\n    }\n    // 如果 effect 执行栈里不包含当前的 effect，即当前的 effect 并没有正在执行\n    if (!effectStack.includes(effect)) {\n      // 先清空依赖集合中的当前的 effect，因为此 effect 即将被消费。\n      // 这表明 effect 消费以后就被删除了，新的 effect 会被加入\n      cleanup(effect)\n      try {\n        // 开启依赖追踪\n        enableTracking()\n        // 将 effect 推进执行栈\n        effectStack.push(effect)\n        // 将当前 effect 设置为正在执行的 effect\n        activeEffect = effect\n        // 执行回调并返回，后面的代码不在执行\n        return fn()\n      } finally {\n        // 如果 fn 执行报错就从执行栈中弹出 effect\n        // 执行错误的 effect 将会被舍弃\n        effectStack.pop()\n        // 重置 track 的状态\n        resetTracking()\n        // activeEffect 回退指向栈顶的 effect\n        activeEffect = effectStack[effectStack.length - 1]\n      }\n    }\n  } as ReactiveEffect\n  effect.id = uid++\n  // 是否允许递归\n  effect.allowRecurse = !!options.allowRecurse\n  effect._isEffect = true\n  // effect 默认是激活的\n  effect.active = true\n  effect.raw = fn\n  effect.deps = []\n  effect.options = options\n  return effect\n}\n\nfunction cleanup(effect: ReactiveEffect) {\n  // 取出当前 effect 所属的依赖数组\n  const { deps } = effect\n  if (deps.length) {\n    // 循环对应每个 key 值的依赖集合\n    for (let i = 0; i < deps.length; i++) {\n      // 从各个集合中将此 effect 清除掉\n      deps[i].delete(effect)\n    }\n    // 依赖数组清空：注意这只是 effect.deps，不影响整个依赖关系\n    deps.length = 0\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n这里有几个问题比较值得注意：\n\n 1. 这里！effect.active 的 effect 为什么要执行？\n\nstop 函数可以将 effect.active 关闭，并且触发 onStop 钩子函数。\n\nexport function stop(effect: ReactiveEffect) {\n  if (effect.active) {\n    cleanup(effect)\n    if (effect.options.onStop) {\n      effect.options.onStop()\n    }\n    effect.active = false\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n需要注意的是，这里将 effect 已经清理过了，也就是说 stop 之后，在 trigger effect 时，应该就不存在已经关闭的 effect 了。\n\n 2. effectStack 有什么作用？\n\neffectStack 中缓存正在执行的 effect，以保证同一个 effect 不会被重复的消费。\n\n\n# track\n\ntrack 的主要作用是针对 target 进行依赖收集，track 是响应式的基础。\n\n// （副作用）依赖收集\nexport function track(target: object, type: TrackOpTypes, key: unknown) {\n  // 这里的 type 在 prod 没有作用\n  // shouldTrack  可以关闭依赖追踪，activeEffect === undefined 表示还没有创建过 effect\n  if (!shouldTrack || activeEffect === undefined) {\n    return\n  }\n  // 取出当前 target 的依赖集合，结构：Map<target, Map<key, Set>>，\n  // targetMap → depsMap → dep → activeEffect\n  let depsMap = targetMap.get(target)\n  // 依赖集合不存在就将之初始化\n  if (!depsMap) {\n    targetMap.set(target, (depsMap = new Map()))\n  }\n  let dep = depsMap.get(key)\n  if (!dep) {\n    depsMap.set(key, (dep = new Set()))\n  }\n  // 将当前的 effect 进行收集，并且 activeEffect.deps 数组记录自身所属于的依赖集合（dep）\n  // activeEffect 表示当前正在执行的 effect\n  if (!dep.has(activeEffect)) {\n    dep.add(activeEffect)\n    activeEffect.deps.push(dep)\n    if (__DEV__ && activeEffect.options.onTrack) {\n      activeEffect.options.onTrack({\n        effect: activeEffect,\n        target,\n        type,\n        key\n      })\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n * 退出 track 的条件是：track 是 enable 的，且已经创建过 effect。\n * depsMap 依赖收集的结构是： Map<target, Map<key, Set>> ，map-map-set 结构。\n\n\n# trigger\n\ntrigger 的主要作用是消费 target 上需要消费的 effect (副作用)，trigger 是响应式的核心。\n\nexport function trigger(\n  target: object,\n  type: TriggerOpTypes,\n  key?: unknown,\n  newValue?: unknown,\n  oldValue?: unknown,\n  oldTarget?: Map<unknown, unknown> | Set<unknown>\n) {\n  // 取出 target 上的依赖集合，结构：Map<target, Map<key, Set>>，\n  const depsMap = targetMap.get(target)\n  // 没有依赖则不必消费依赖了\n  if (!depsMap) {\n    // never been tracked\n    return\n  }\n  // 待消费的依赖集合\n  const effects = new Set<ReactiveEffect>()\n  // add 函数将 key set 中的 effect 推进 effects 数组。\n  const add = (effectsToAdd: Set<ReactiveEffect> | undefined) => {\n    if (effectsToAdd) {\n      effectsToAdd.forEach(effect => {\n        // 如果 effect 不是栈顶的 effect 且允许递归\n        if (effect !== activeEffect || effect.allowRecurse) {\n          // 将依赖添加到待消费的依赖集合\n          effects.add(effect)\n        }\n      })\n    }\n  }\n\n  // 如果是 CLEAR 类型\n  if (type === TriggerOpTypes.CLEAR) {\n    // collection being cleared\n    // trigger all effects for target\n    // Map 在 forEach 中获取的是 values，此处传入的是 Set\n    // 触发 target 上所有的 effect\n    depsMap.forEach(add)\n  } else if (key === 'length' && isArray(target)) {\n    // 如果 target 是一个数组\n    // 数组依赖的消费\n    depsMap.forEach((dep, key) => {\n      // key >= newValue 表示 大于 newValue 的 key set 将会被消费\n      if (key === 'length' || key >= (newValue as number)) {\n        // 只有满足上述条件的 set 才可以被消费\n        add(dep)\n      }\n    })\n  } else {\n    // schedule runs for SET | ADD | DELETE\n    // void 0 returns undefined and can not be overwritten while undefined can be overwritten.\n    //  see https://stackoverflow.com/questions/7452341/what-does-void-0-mean\n    // 如果 key ！=== undefined，则消费 key 所对应的 Set。\n    // 消费某个单独的 key set\n    if (key !== void 0) {\n      add(depsMap.get(key))\n    }\n\n    // also run for iteration key on ADD | DELETE | Map.SET\n    // iteration key 需要消费的 effect\n    switch (type) {\n      // 增加属性\n      case TriggerOpTypes.ADD:\n        if (!isArray(target)) {\n          // 根据 target 类型不同，选择需要消费的 effect 集合\n          add(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            add(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        } else if (isIntegerKey(key)) {\n          // new index added to array -> length changes\n          // 数组增加值改变 length\n          add(depsMap.get('length'))\n        }\n        break\n      // 删除属性\n      case TriggerOpTypes.DELETE:\n        if (!isArray(target)) {\n          add(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            add(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        }\n        // TODO 为什么不处理数组的 length\n        break\n      // 修改属性\n      case TriggerOpTypes.SET:\n        if (isMap(target)) {\n          add(depsMap.get(ITERATE_KEY))\n        }\n        break\n    }\n  }\n\n  // 执行 effect，指定了 scheduler 的交给 scheduler 处理。\n  const run = (effect: ReactiveEffect) => {\n    if (__DEV__ && effect.options.onTrigger) {\n      effect.options.onTrigger({\n        effect,\n        target,\n        key,\n        type,\n        newValue,\n        oldValue,\n        oldTarget\n      })\n    }\n    if (effect.options.scheduler) {\n      effect.options.scheduler(effect)\n    } else {\n      effect()\n    }\n  }\n  // 执行待消费的所有的依赖\n  effects.forEach(run)\n}\n\nexport const enum TriggerOpTypes {\n  SET = 'set',\n  ADD = 'add',\n  DELETE = 'delete',\n  CLEAR = 'clear'\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n\n * trigger 的类型包括：SET、ADD、DELETE、CLEAR。\n * 需要注意的是： effect 消费完之后就被删除，新的 effect 将会被生产，因为响应式的要求就是在每一次响应中 trigger effects 。effect 在 effect () 函数本身中被 cleanUp。\n\n\n# track 的暂停与恢复\n\n下面我们来看看管理 track 暂停与恢复的机制：\n\nlet shouldTrack = true\n// 保存上一次的 shouldTrack 状态\nconst trackStack: boolean[] = []\n\nexport function pauseTracking() {\n  trackStack.push(shouldTrack)\n  shouldTrack = false\n}\n\nexport function enableTracking() {\n  trackStack.push(shouldTrack)\n  shouldTrack = true\n}\n\nexport function resetTracking() {\n  const last = trackStack.pop()\n  shouldTrack = last === undefined ? true : last\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * shouldTrack 是当前的 track 的开关。\n * trackStack 是 track 状态的栈，用于快速恢复上一次 track 的状态，便于在执行错误等情况下进行恢复。\n\n\n# 一些问题\n\n\n# effect 流程\n\n在 track 中我们注意到将 activeEffect 加入依赖集合，activeEffect 表示正在被执行的 effect，可是 trigger 不是应该在 track 之后吗？如果说 effect 是在初始化创建时给 activeEffect 赋值的，那么 activeEffect 怎么能保证就是当前需要被加入的 effect 呢？\n\n为了弄清楚这个问题，我们来做个测试：\n\nit('should observe basic properties', () => {\n  let dummy\n  let temp\n  const counter = reactive({ num: 0 })\n  console.log('==>', 1)\n  effect(() => (dummy = counter.num))\n  console.log('==>', 2)\n  effect(() => (temp = counter.num * 2))\n  console.log('==>', 3)\n\n  expect(dummy).toBe(0)\n  console.log('==>', 4)\n  expect(counter.num).toBe(0)\n  console.log('==>', 5)\n  counter.num = 7\n  console.log('==>', 6)\n  expect(dummy).toBe(7)\n  console.log('==>', 7)\n  expect(temp).toBe(14)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n执行上述 jest 代码段，结果如下：\n\n// 创建 reactive 对象，target 被 proxy\n==> createReactiveObject { target: { num: 0 } }\n\n==> 1\n// 创建 target 的 effect 对象\n==> createReactiveEffect [Arguments] { '0': [Function], '1': {} }\n// 创建完之后需要初始化，执行 effect，触发 get handler\n==> get { target: { num: 0 }, key: 'num' }\n// get 时触发 track 手机依赖，结构 Map<{ num: 0 }, Map<num, Set<effect>>>，将 effect 对象放在 Set 中\n// 注意：因为初始化时一定会触发 get 进行触发 track，所以此时 activeEffect 一定是正需要收集的 effect\n==> track [Arguments] { '0': { num: 0 }, '1': 'get', '2': 'num' } { activeEffect:\n   { [Function: reactiveEffect]\n     id: 0,\n     allowRecurse: false,\n     _isEffect: true,\n     active: true,\n     raw: [Function],\n     deps: [],\n     options: {} } }\n\n==> 2\n// 创建一个新的 effect\n==> createReactiveEffect [Arguments] { '0': [Function], '1': {} }\n// 初始化时触发 get\n==> get { target: { num: 0 }, key: 'num' }\n// get handler 中追踪依赖，activeEffect 仍然可以保持正确\n==> track [Arguments] { '0': { num: 0 }, '1': 'get', '2': 'num' } { activeEffect:\n   { [Function: reactiveEffect]\n     id: 1,\n     allowRecurse: false,\n     _isEffect: true,\n     active: true,\n     raw: [Function],\n     deps: [],\n     options: {} } }\n\n==> 3\n// 非响应式的数据不会响应\n==> 4\n// 获取响应式数据触发 get handler\n==> get { target: { num: 0 }, key: 'num' }\n// 追踪依赖，此时没有正在创建的 effect\n==> track [Arguments] { '0': { num: 0 }, '1': 'get', '2': 'num' } { activeEffect: undefined }\n\n==> 5\n// 设置响应式数据触发 set handler\n==> set { target: { num: 0 }, key: 'num' }\n// 传入的 value 需要 toRaw，触发 get handler，key 为 __v_raw，builtin 属性不需要 track\n==> get { target: { num: 7 }, key: '__v_raw' }\n// set handler 触发 trigger，key 为 number，newValue 为 7\n// depsMap.get(target).get(key) 找到 effect，并执行\n==> trigger [Arguments] { '0': { num: 7 }, '1': 'set', '2': 'num', '3': 7, '4': 0 }\n// 计算响应值触发 get handler，计算dummy\n==> get { target: { num: 7 }, key: 'num' }\n// 追踪依赖\n// 重新计算响应值时重新追踪了依赖，所以 effect 在消费之后才可以 cleanup\n==> track [Arguments] { '0': { num: 7 }, '1': 'get', '2': 'num' } { activeEffect:\n   { [Function: reactiveEffect]\n     id: 0,\n     allowRecurse: false,\n     _isEffect: true,\n     active: true,\n     raw: [Function],\n     deps: [],\n     options: {} } }\n// 计算响应值触发 get handler，计算 temp\n==> get { target: { num: 7 }, key: 'num' }\n// 追踪依赖\n==> track [Arguments] { '0': { num: 7 }, '1': 'get', '2': 'num' } { activeEffect:\n   { [Function: reactiveEffect]\n     id: 1,\n     allowRecurse: false,\n     _isEffect: true,\n     active: true,\n     raw: [Function],\n     deps: [],\n     options: {} } }\n\n==> 6\n// 非响应式数据不响应\n\n==> 7\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n\n\n通过上面的测试代码，我们应该对 effect 生产、追踪和消费的过程以及响应式的原理比较清晰了。需要注意的有一下几点：\n\n * effect 被生产之后需要被初始化，也就是 effect 被执行一次（lazy effect 除外），因此在初始化计算响应式值的过程中会触发 get handler，进而会对创建的 effect 进行追踪（track）。这也就是 activeEffect 能保持是需要被 track 的 effect 的原因。由此也可说明， activeEffect 实际指的是 正在被创建的 effect 。\n * effect 被消费之后之所以可以被 cleanup，原因是因为在 effect 被消费时执行 effect，会重新计算响应值，在这个过程中会重新触发 get handler，进而对 effect 进行 track，重新收集依赖。\n\n\n# 文章小结\n\n这篇文章分析了 effect 的生产、追踪和消费的原理，以及 track 的暂停与恢复等细节问题。我们已经介绍了 ref、reactive 等响应式 api，而本篇所讲的 effect 就是响应式 api 响应式功能的核心。总体来说，effect 的核心就是 track 和 trigger，也就是 依赖追踪 和 依赖触发 。依赖追踪就是对追踪目标 target 上的一系列的 key 所产生的依赖关系（相应回调）进行收集，依赖触发就是在数据（target）发生变化时，触发追踪目标上的所有的需要做更新的依赖进行执行和更新。",normalizedContent:"# 目录\n\n\n\n * 目录\n * effects\n * track\n * trigger\n * track 的暂停与恢复\n * 一些问题\n   * effect 流程\n * 文章小结\n\n\n\n\n# effects\n\n通过 effect 函数创建 effect，可以将 fn (回调) 包装成一个 effect 对象。\n\nexport function effect<t = any>(\n  fn: () => t, // 创建 effect 的回调函数\n  options: reactiveeffectoptions = empty_obj // 创建 effect 的配置项\n): reactiveeffect<t> {\n  if (iseffect(fn)) {\n    // 如果已经是一个 effect 对象，则以 raw fn 重新创建 effect\n    fn = fn.raw\n  }\n  // 用回调函数和配置项创建 effect\n  const effect = createreactiveeffect(fn, options)\n  // 除 lazy effect 之外都应该立即执行一遍\n  // 为什么在创建完 effect 要执行一遍？初始化响应式的代码逻辑\n  if (!options.lazy) {\n    effect()\n  }\n  return effect\n}\nexport function iseffect(fn: any): fn is reactiveeffect {\n  // 通过 _iseffect 属性来判断是否是 effect 对象\n  return fn && fn._iseffect === true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这个函数的核心是调用 createreactiveeffect 工厂函数创建 effect。\n\n先来看看什么是 effect：\n\nexport interface reactiveeffect<t = any> {\n  (): t\n  _iseffect: true // 是否是 effect 对象的标志，iseffect 判断的根据\n  id: number // effect id\n  active: boolean // 是否处于激活状态，没有被 stop 的 effect 都属于激活状态\n  raw: () => t // 原本的回调，就是被包装的回调函数\n  deps: array<dep> // 当前 effect 所属于的依赖数组，结构为 array<set>，每个 set 代表 map<key, effect>\n  options: reactiveeffectoptions // 当前 effect 的配置项\n  allowrecurse: boolean // 是否允许递归\n}\nexport interface reactiveeffectoptions {\n  lazy?: boolean // 是否懒响应，懒响应的 effect 创建时不执行\n  scheduler?: (job: reactiveeffect) => void // effect 的调度器，如果有调度器，在执行 effect 时会交由调度器处理\n  ontrack?: (event: debuggerevent) => void // 用于 dev 环境，跟踪 track 过程，track 执行时触发\n  ontrigger?: (event: debuggerevent) => void // 用于 dev 环境，跟踪 trigger 过程，run effect 时触发\n  onstop?: () => void // stop effect 时触发\n  allowrecurse?: boolean // 交给调度器时是否允许递归触发\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n重点来看下 createreactiveeffect 函数：\n\n// 当前真该执行的 effect 的栈\nconst effectstack: reactiveeffect[] = []\nfunction createreactiveeffect<t = any>(\n  fn: () => t,\n  options: reactiveeffectoptions\n): reactiveeffect<t> {\n  // 根据 fn 创建一个 effect，effect 本质上是一个 function，是可以执行的\n  const effect = function reactiveeffect(): unknown {\n    // 注意：此函数在 effect 执行时调用，effect的属性是有值的\n    // 如果当前 effect 已经被 stop 了，就执行他\n    // 如果是 scheduled effect，即时 stop 了也执行，但是不开启 track\n    // effect 就是指当前的 effect 函数\n    if (!effect.active) {\n      return fn()\n    }\n    // 如果 effect 执行栈里不包含当前的 effect，即当前的 effect 并没有正在执行\n    if (!effectstack.includes(effect)) {\n      // 先清空依赖集合中的当前的 effect，因为此 effect 即将被消费。\n      // 这表明 effect 消费以后就被删除了，新的 effect 会被加入\n      cleanup(effect)\n      try {\n        // 开启依赖追踪\n        enabletracking()\n        // 将 effect 推进执行栈\n        effectstack.push(effect)\n        // 将当前 effect 设置为正在执行的 effect\n        activeeffect = effect\n        // 执行回调并返回，后面的代码不在执行\n        return fn()\n      } finally {\n        // 如果 fn 执行报错就从执行栈中弹出 effect\n        // 执行错误的 effect 将会被舍弃\n        effectstack.pop()\n        // 重置 track 的状态\n        resettracking()\n        // activeeffect 回退指向栈顶的 effect\n        activeeffect = effectstack[effectstack.length - 1]\n      }\n    }\n  } as reactiveeffect\n  effect.id = uid++\n  // 是否允许递归\n  effect.allowrecurse = !!options.allowrecurse\n  effect._iseffect = true\n  // effect 默认是激活的\n  effect.active = true\n  effect.raw = fn\n  effect.deps = []\n  effect.options = options\n  return effect\n}\n\nfunction cleanup(effect: reactiveeffect) {\n  // 取出当前 effect 所属的依赖数组\n  const { deps } = effect\n  if (deps.length) {\n    // 循环对应每个 key 值的依赖集合\n    for (let i = 0; i < deps.length; i++) {\n      // 从各个集合中将此 effect 清除掉\n      deps[i].delete(effect)\n    }\n    // 依赖数组清空：注意这只是 effect.deps，不影响整个依赖关系\n    deps.length = 0\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n这里有几个问题比较值得注意：\n\n 1. 这里！effect.active 的 effect 为什么要执行？\n\nstop 函数可以将 effect.active 关闭，并且触发 onstop 钩子函数。\n\nexport function stop(effect: reactiveeffect) {\n  if (effect.active) {\n    cleanup(effect)\n    if (effect.options.onstop) {\n      effect.options.onstop()\n    }\n    effect.active = false\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n需要注意的是，这里将 effect 已经清理过了，也就是说 stop 之后，在 trigger effect 时，应该就不存在已经关闭的 effect 了。\n\n 2. effectstack 有什么作用？\n\neffectstack 中缓存正在执行的 effect，以保证同一个 effect 不会被重复的消费。\n\n\n# track\n\ntrack 的主要作用是针对 target 进行依赖收集，track 是响应式的基础。\n\n// （副作用）依赖收集\nexport function track(target: object, type: trackoptypes, key: unknown) {\n  // 这里的 type 在 prod 没有作用\n  // shouldtrack  可以关闭依赖追踪，activeeffect === undefined 表示还没有创建过 effect\n  if (!shouldtrack || activeeffect === undefined) {\n    return\n  }\n  // 取出当前 target 的依赖集合，结构：map<target, map<key, set>>，\n  // targetmap → depsmap → dep → activeeffect\n  let depsmap = targetmap.get(target)\n  // 依赖集合不存在就将之初始化\n  if (!depsmap) {\n    targetmap.set(target, (depsmap = new map()))\n  }\n  let dep = depsmap.get(key)\n  if (!dep) {\n    depsmap.set(key, (dep = new set()))\n  }\n  // 将当前的 effect 进行收集，并且 activeeffect.deps 数组记录自身所属于的依赖集合（dep）\n  // activeeffect 表示当前正在执行的 effect\n  if (!dep.has(activeeffect)) {\n    dep.add(activeeffect)\n    activeeffect.deps.push(dep)\n    if (__dev__ && activeeffect.options.ontrack) {\n      activeeffect.options.ontrack({\n        effect: activeeffect,\n        target,\n        type,\n        key\n      })\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n * 退出 track 的条件是：track 是 enable 的，且已经创建过 effect。\n * depsmap 依赖收集的结构是： map<target, map<key, set>> ，map-map-set 结构。\n\n\n# trigger\n\ntrigger 的主要作用是消费 target 上需要消费的 effect (副作用)，trigger 是响应式的核心。\n\nexport function trigger(\n  target: object,\n  type: triggeroptypes,\n  key?: unknown,\n  newvalue?: unknown,\n  oldvalue?: unknown,\n  oldtarget?: map<unknown, unknown> | set<unknown>\n) {\n  // 取出 target 上的依赖集合，结构：map<target, map<key, set>>，\n  const depsmap = targetmap.get(target)\n  // 没有依赖则不必消费依赖了\n  if (!depsmap) {\n    // never been tracked\n    return\n  }\n  // 待消费的依赖集合\n  const effects = new set<reactiveeffect>()\n  // add 函数将 key set 中的 effect 推进 effects 数组。\n  const add = (effectstoadd: set<reactiveeffect> | undefined) => {\n    if (effectstoadd) {\n      effectstoadd.foreach(effect => {\n        // 如果 effect 不是栈顶的 effect 且允许递归\n        if (effect !== activeeffect || effect.allowrecurse) {\n          // 将依赖添加到待消费的依赖集合\n          effects.add(effect)\n        }\n      })\n    }\n  }\n\n  // 如果是 clear 类型\n  if (type === triggeroptypes.clear) {\n    // collection being cleared\n    // trigger all effects for target\n    // map 在 foreach 中获取的是 values，此处传入的是 set\n    // 触发 target 上所有的 effect\n    depsmap.foreach(add)\n  } else if (key === 'length' && isarray(target)) {\n    // 如果 target 是一个数组\n    // 数组依赖的消费\n    depsmap.foreach((dep, key) => {\n      // key >= newvalue 表示 大于 newvalue 的 key set 将会被消费\n      if (key === 'length' || key >= (newvalue as number)) {\n        // 只有满足上述条件的 set 才可以被消费\n        add(dep)\n      }\n    })\n  } else {\n    // schedule runs for set | add | delete\n    // void 0 returns undefined and can not be overwritten while undefined can be overwritten.\n    //  see https://stackoverflow.com/questions/7452341/what-does-void-0-mean\n    // 如果 key ！=== undefined，则消费 key 所对应的 set。\n    // 消费某个单独的 key set\n    if (key !== void 0) {\n      add(depsmap.get(key))\n    }\n\n    // also run for iteration key on add | delete | map.set\n    // iteration key 需要消费的 effect\n    switch (type) {\n      // 增加属性\n      case triggeroptypes.add:\n        if (!isarray(target)) {\n          // 根据 target 类型不同，选择需要消费的 effect 集合\n          add(depsmap.get(iterate_key))\n          if (ismap(target)) {\n            add(depsmap.get(map_key_iterate_key))\n          }\n        } else if (isintegerkey(key)) {\n          // new index added to array -> length changes\n          // 数组增加值改变 length\n          add(depsmap.get('length'))\n        }\n        break\n      // 删除属性\n      case triggeroptypes.delete:\n        if (!isarray(target)) {\n          add(depsmap.get(iterate_key))\n          if (ismap(target)) {\n            add(depsmap.get(map_key_iterate_key))\n          }\n        }\n        // todo 为什么不处理数组的 length\n        break\n      // 修改属性\n      case triggeroptypes.set:\n        if (ismap(target)) {\n          add(depsmap.get(iterate_key))\n        }\n        break\n    }\n  }\n\n  // 执行 effect，指定了 scheduler 的交给 scheduler 处理。\n  const run = (effect: reactiveeffect) => {\n    if (__dev__ && effect.options.ontrigger) {\n      effect.options.ontrigger({\n        effect,\n        target,\n        key,\n        type,\n        newvalue,\n        oldvalue,\n        oldtarget\n      })\n    }\n    if (effect.options.scheduler) {\n      effect.options.scheduler(effect)\n    } else {\n      effect()\n    }\n  }\n  // 执行待消费的所有的依赖\n  effects.foreach(run)\n}\n\nexport const enum triggeroptypes {\n  set = 'set',\n  add = 'add',\n  delete = 'delete',\n  clear = 'clear'\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n\n * trigger 的类型包括：set、add、delete、clear。\n * 需要注意的是： effect 消费完之后就被删除，新的 effect 将会被生产，因为响应式的要求就是在每一次响应中 trigger effects 。effect 在 effect () 函数本身中被 cleanup。\n\n\n# track 的暂停与恢复\n\n下面我们来看看管理 track 暂停与恢复的机制：\n\nlet shouldtrack = true\n// 保存上一次的 shouldtrack 状态\nconst trackstack: boolean[] = []\n\nexport function pausetracking() {\n  trackstack.push(shouldtrack)\n  shouldtrack = false\n}\n\nexport function enabletracking() {\n  trackstack.push(shouldtrack)\n  shouldtrack = true\n}\n\nexport function resettracking() {\n  const last = trackstack.pop()\n  shouldtrack = last === undefined ? true : last\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * shouldtrack 是当前的 track 的开关。\n * trackstack 是 track 状态的栈，用于快速恢复上一次 track 的状态，便于在执行错误等情况下进行恢复。\n\n\n# 一些问题\n\n\n# effect 流程\n\n在 track 中我们注意到将 activeeffect 加入依赖集合，activeeffect 表示正在被执行的 effect，可是 trigger 不是应该在 track 之后吗？如果说 effect 是在初始化创建时给 activeeffect 赋值的，那么 activeeffect 怎么能保证就是当前需要被加入的 effect 呢？\n\n为了弄清楚这个问题，我们来做个测试：\n\nit('should observe basic properties', () => {\n  let dummy\n  let temp\n  const counter = reactive({ num: 0 })\n  console.log('==>', 1)\n  effect(() => (dummy = counter.num))\n  console.log('==>', 2)\n  effect(() => (temp = counter.num * 2))\n  console.log('==>', 3)\n\n  expect(dummy).tobe(0)\n  console.log('==>', 4)\n  expect(counter.num).tobe(0)\n  console.log('==>', 5)\n  counter.num = 7\n  console.log('==>', 6)\n  expect(dummy).tobe(7)\n  console.log('==>', 7)\n  expect(temp).tobe(14)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n执行上述 jest 代码段，结果如下：\n\n// 创建 reactive 对象，target 被 proxy\n==> createreactiveobject { target: { num: 0 } }\n\n==> 1\n// 创建 target 的 effect 对象\n==> createreactiveeffect [arguments] { '0': [function], '1': {} }\n// 创建完之后需要初始化，执行 effect，触发 get handler\n==> get { target: { num: 0 }, key: 'num' }\n// get 时触发 track 手机依赖，结构 map<{ num: 0 }, map<num, set<effect>>>，将 effect 对象放在 set 中\n// 注意：因为初始化时一定会触发 get 进行触发 track，所以此时 activeeffect 一定是正需要收集的 effect\n==> track [arguments] { '0': { num: 0 }, '1': 'get', '2': 'num' } { activeeffect:\n   { [function: reactiveeffect]\n     id: 0,\n     allowrecurse: false,\n     _iseffect: true,\n     active: true,\n     raw: [function],\n     deps: [],\n     options: {} } }\n\n==> 2\n// 创建一个新的 effect\n==> createreactiveeffect [arguments] { '0': [function], '1': {} }\n// 初始化时触发 get\n==> get { target: { num: 0 }, key: 'num' }\n// get handler 中追踪依赖，activeeffect 仍然可以保持正确\n==> track [arguments] { '0': { num: 0 }, '1': 'get', '2': 'num' } { activeeffect:\n   { [function: reactiveeffect]\n     id: 1,\n     allowrecurse: false,\n     _iseffect: true,\n     active: true,\n     raw: [function],\n     deps: [],\n     options: {} } }\n\n==> 3\n// 非响应式的数据不会响应\n==> 4\n// 获取响应式数据触发 get handler\n==> get { target: { num: 0 }, key: 'num' }\n// 追踪依赖，此时没有正在创建的 effect\n==> track [arguments] { '0': { num: 0 }, '1': 'get', '2': 'num' } { activeeffect: undefined }\n\n==> 5\n// 设置响应式数据触发 set handler\n==> set { target: { num: 0 }, key: 'num' }\n// 传入的 value 需要 toraw，触发 get handler，key 为 __v_raw，builtin 属性不需要 track\n==> get { target: { num: 7 }, key: '__v_raw' }\n// set handler 触发 trigger，key 为 number，newvalue 为 7\n// depsmap.get(target).get(key) 找到 effect，并执行\n==> trigger [arguments] { '0': { num: 7 }, '1': 'set', '2': 'num', '3': 7, '4': 0 }\n// 计算响应值触发 get handler，计算dummy\n==> get { target: { num: 7 }, key: 'num' }\n// 追踪依赖\n// 重新计算响应值时重新追踪了依赖，所以 effect 在消费之后才可以 cleanup\n==> track [arguments] { '0': { num: 7 }, '1': 'get', '2': 'num' } { activeeffect:\n   { [function: reactiveeffect]\n     id: 0,\n     allowrecurse: false,\n     _iseffect: true,\n     active: true,\n     raw: [function],\n     deps: [],\n     options: {} } }\n// 计算响应值触发 get handler，计算 temp\n==> get { target: { num: 7 }, key: 'num' }\n// 追踪依赖\n==> track [arguments] { '0': { num: 7 }, '1': 'get', '2': 'num' } { activeeffect:\n   { [function: reactiveeffect]\n     id: 1,\n     allowrecurse: false,\n     _iseffect: true,\n     active: true,\n     raw: [function],\n     deps: [],\n     options: {} } }\n\n==> 6\n// 非响应式数据不响应\n\n==> 7\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n\n\n通过上面的测试代码，我们应该对 effect 生产、追踪和消费的过程以及响应式的原理比较清晰了。需要注意的有一下几点：\n\n * effect 被生产之后需要被初始化，也就是 effect 被执行一次（lazy effect 除外），因此在初始化计算响应式值的过程中会触发 get handler，进而会对创建的 effect 进行追踪（track）。这也就是 activeeffect 能保持是需要被 track 的 effect 的原因。由此也可说明， activeeffect 实际指的是 正在被创建的 effect 。\n * effect 被消费之后之所以可以被 cleanup，原因是因为在 effect 被消费时执行 effect，会重新计算响应值，在这个过程中会重新触发 get handler，进而对 effect 进行 track，重新收集依赖。\n\n\n# 文章小结\n\n这篇文章分析了 effect 的生产、追踪和消费的原理，以及 track 的暂停与恢复等细节问题。我们已经介绍了 ref、reactive 等响应式 api，而本篇所讲的 effect 就是响应式 api 响应式功能的核心。总体来说，effect 的核心就是 track 和 trigger，也就是 依赖追踪 和 依赖触发 。依赖追踪就是对追踪目标 target 上的一系列的 key 所产生的依赖关系（相应回调）进行收集，依赖触发就是在数据（target）发生变化时，触发追踪目标上的所有的需要做更新的依赖进行执行和更新。",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"Computed",frontmatter:{title:"Computed",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/basic/computed/",categories:["vue3","reactivity"],tags:[null]},regularPath:"/20.vue3/20.reactivity/50.computed.html",relativePath:"20.vue3/20.reactivity/50.computed.md",key:"v-47f301c6",path:"/vue3/basic/computed/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"computed",slug:"computed",normalizedTitle:"computed",charIndex:17},{level:2,title:"ComputedRefImpl",slug:"computedrefimpl",normalizedTitle:"computedrefimpl",charIndex:29},{level:2,title:"文章小结",slug:"文章小结",normalizedTitle:"文章小结",charIndex:48}],readingTime:{text:"5 min read",minutes:4.185,time:251099.99999999997,words:837},headersStr:"目录 computed ComputedRefImpl 文章小结",content:"# 目录\n\n\n\n * 目录\n * computed\n * ComputedRefImpl\n * 文章小结\n\n\n\n\n# computed\n\n官网释义\n\nTakes a getter function and returns an immutable (不可改变的，不可写的) reactive ref object for the returned value from the getter.Alternatively, it can take an object with get and set functions to create a writable ref object. 使用 getter 函数，并为从 getter 返回的值返回一个不变的响应式 ref 对象。或者，它可以使用具有 get 和 set 函数的对象来创建可写的 ref 对象。\n\n// 函数重载\nexport function computed<T>(getter: ComputedGetter<T>): ComputedRef<T>\nexport function computed<T>(\n  options: WritableComputedOptions<T>\n): WritableComputedRef<T>\nexport function computed<T>(\n  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>\n) {\n  let getter: ComputedGetter<T>\n  let setter: ComputedSetter<T>\n  // 解析 getter 和 setter\n  if (isFunction(getterOrOptions)) {\n    // 只读\n    getter = getterOrOptions\n    setter = __DEV__\n      ? () => {\n          console.warn('Write operation failed: computed value is readonly')\n        }\n      : NOOP\n  } else {\n    // 可读可写\n    getter = getterOrOptions.get\n    setter = getterOrOptions.set\n  }\n\n  return new ComputedRefImpl(\n    getter,\n    setter,\n    isFunction(getterOrOptions) || !getterOrOptions.set\n  ) as any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\ncomputed 主要由 ComputedRefImpl 实现功能，可以传入 getter 和 setter，用于创建 ref 对象。\n\n\n# ComputedRefImpl\n\n创建 computedRef 对象。\n\nclass ComputedRefImpl<T> {\n  private _value!: T\n  private _dirty = true // 初始就调度一次\n\n  public readonly effect: ReactiveEffect<T>\n\n  public readonly __v_isRef = true;\n  public readonly [ReactiveFlags.IS_READONLY]: boolean\n\n  constructor(\n    getter: ComputedGetter<T>,\n    private readonly _setter: ComputedSetter<T>,\n    isReadonly: boolean\n  ) {\n    // 创建 lazy effect\n    this.effect = effect(getter, {\n      // 跳过初始化的执行\n      lazy: true, // 自定义调度器，在执行 effect 时由交给自定义的调度器处理（调度）\n      // _dirty 表示是否调度过\n      // 注意：这里并不是说 effect 只会执行一次，而是发起了一次调度\n      scheduler: () => {\n        if (!this._dirty) {\n          this._dirty = true\n          trigger(toRaw(this), TriggerOpTypes.SET, 'value')\n        }\n      }\n    })\n\n    this[ReactiveFlags.IS_READONLY] = isReadonly\n  }\n\n  get value() {\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n    // 如果当前对象被 proxy，需要将它解包装\n    const self = toRaw(this)\n    // 如果已经被调度，就执行 effect，并且响应执行后的结果，然后关闭调度\n    if (self._dirty) {\n      self._value = this.effect()\n      self._dirty = false\n    }\n    // 追踪依赖\n    track(self, TrackOpTypes.GET, 'value')\n    return self._value\n  }\n\n  set value(newValue: T) {\n    // 直接调用 _setter\n    this._setter(newValue)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n与 ref 不同的有以下几点：\n\n * 创建是 effect 是 lazy effect，也就是在初始化时并不会执行一次。\n\n执行如下的测试代码，看一下 computed 的过程：\n\nit('should return updated value', () => {\n  const value = reactive<{ foo?: number }>({})\n  console.log('==> 1')\n  const cValue = computed(() => value.foo)\n  let temp\n  console.log('==> 2')\n  effect(() => (temp = cValue.value))\n  console.log('==> 3')\n  expect(cValue.value).toBe(undefined)\n  console.log('==> 4')\n  value.foo = 1\n  console.log('==> 5')\n  expect(cValue.value).toBe(1)\n  console.log('==> 6')\n  expect(temp).toBe(1)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n// 创建 reactive 对象，响应式目标被代理\n==> createReactiveObject { target: {} }\n\n==> 1\n// 实例化 ComputedRefImpl 对象，在构造器中生成 effect。调用 effect()。\n==> createReactiveEffect [Arguments] {\n  '0': [Function],\n  '1': { lazy: true, scheduler: [Function: scheduler] } }\n\n==> 2\n\n==> createReactiveEffect [Arguments] { '0': [Function], '1': {} }\n\n==> ComputedRefImpl get { _dirty: true }\n\n==> get { target: {}, key: 'foo' }\n\n==> track [Arguments] { '0': {}, '1': 'get', '2': 'foo' } { activeEffect:\n   { [Function: reactiveEffect]\n     id: 0,\n     allowRecurse: false,\n     _isEffect: true,\n     active: true,\n     raw: [Function],\n     deps: [],\n     options: { lazy: true, scheduler: [Function: scheduler] } } }\n\n==> track [Arguments] {\n  '0':\n   ComputedRefImpl {\n     _setter: [Function],\n     _dirty: false,\n     __v_isRef: true,\n     effect:\n      { [Function: reactiveEffect]\n        id: 0,\n        allowRecurse: false,\n        _isEffect: true,\n        active: true,\n        raw: [Function],\n        deps: [Array],\n        options: [Object] },\n     __v_isReadonly: true,\n     _value: undefined },\n  '1': 'get',\n  '2': 'value' } { activeEffect:\n   { [Function: reactiveEffect]\n     id: 1,\n     allowRecurse: false,\n     _isEffect: true,\n     active: true,\n     raw: [Function],\n     deps: [],\n     options: {} } }\n\n==> 3\n\n==> ComputedRefImpl get { _dirty: false }\n\n==> track [Arguments] {\n  '0':\n   ComputedRefImpl {\n     _setter: [Function],\n     _dirty: false,\n     __v_isRef: true,\n     effect:\n      { [Function: reactiveEffect]\n        id: 0,\n        allowRecurse: false,\n        _isEffect: true,\n        active: true,\n        raw: [Function],\n        deps: [Array],\n        options: [Object] },\n     __v_isReadonly: true,\n     _value: undefined },\n  '1': 'get',\n  '2': 'value' } { activeEffect: undefined }\n\n==> 4\n\n==> set { target: {}, key: 'foo' }\n\n==> get { target: { foo: 1 }, key: '__v_raw' }\n\n==> trigger [Arguments] { '0': { foo: 1 }, '1': 'add', '2': 'foo', '3': 1 }\n\n==> ComputedRefImpl effect scheduler { _dirty: false }\n\n==> trigger [Arguments] {\n  '0':\n   ComputedRefImpl {\n     _setter: [Function],\n     _dirty: true,\n     __v_isRef: true,\n     effect:\n      { [Function: reactiveEffect]\n        id: 0,\n        allowRecurse: false,\n        _isEffect: true,\n        active: true,\n        raw: [Function],\n        deps: [Array],\n        options: [Object] },\n     __v_isReadonly: true,\n     _value: undefined },\n  '1': 'set',\n  '2': 'value' }\n\n==> ComputedRefImpl get { _dirty: true }\n\n==> get { target: { foo: 1 }, key: 'foo' }\n\n==> track [Arguments] { '0': { foo: 1 }, '1': 'get', '2': 'foo' } { activeEffect:\n   { [Function: reactiveEffect]\n     id: 0,\n     allowRecurse: false,\n     _isEffect: true,\n     active: true,\n     raw: [Function],\n     deps: [],\n     options: { lazy: true, scheduler: [Function: scheduler] } } }\n\n==> track [Arguments] {\n  '0':\n   ComputedRefImpl {\n     _setter: [Function],\n     _dirty: false,\n     __v_isRef: true,\n     effect:\n      { [Function: reactiveEffect]\n        id: 0,\n        allowRecurse: false,\n        _isEffect: true,\n        active: true,\n        raw: [Function],\n        deps: [Array],\n        options: [Object] },\n     __v_isReadonly: true,\n     _value: 1 },\n  '1': 'get',\n  '2': 'value' } { activeEffect:\n   { [Function: reactiveEffect]\n     id: 1,\n     allowRecurse: false,\n     _isEffect: true,\n     active: true,\n     raw: [Function],\n     deps: [],\n     options: {} } }\n\n==> 5\n\n==> ComputedRefImpl get { _dirty: false }\n\n==> track [Arguments] {\n  '0':\n   ComputedRefImpl {\n     _setter: [Function],\n     _dirty: false,\n     __v_isRef: true,\n     effect:\n      { [Function: reactiveEffect]\n        id: 0,\n        allowRecurse: false,\n        _isEffect: true,\n        active: true,\n        raw: [Function],\n        deps: [Array],\n        options: [Object] },\n     __v_isReadonly: true,\n     _value: 1 },\n  '1': 'get',\n  '2': 'value' } { activeEffect: undefined }\n\n==> 6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n\n\n\n# 文章小结",normalizedContent:"# 目录\n\n\n\n * 目录\n * computed\n * computedrefimpl\n * 文章小结\n\n\n\n\n# computed\n\n官网释义\n\ntakes a getter function and returns an immutable (不可改变的，不可写的) reactive ref object for the returned value from the getter.alternatively, it can take an object with get and set functions to create a writable ref object. 使用 getter 函数，并为从 getter 返回的值返回一个不变的响应式 ref 对象。或者，它可以使用具有 get 和 set 函数的对象来创建可写的 ref 对象。\n\n// 函数重载\nexport function computed<t>(getter: computedgetter<t>): computedref<t>\nexport function computed<t>(\n  options: writablecomputedoptions<t>\n): writablecomputedref<t>\nexport function computed<t>(\n  getteroroptions: computedgetter<t> | writablecomputedoptions<t>\n) {\n  let getter: computedgetter<t>\n  let setter: computedsetter<t>\n  // 解析 getter 和 setter\n  if (isfunction(getteroroptions)) {\n    // 只读\n    getter = getteroroptions\n    setter = __dev__\n      ? () => {\n          console.warn('write operation failed: computed value is readonly')\n        }\n      : noop\n  } else {\n    // 可读可写\n    getter = getteroroptions.get\n    setter = getteroroptions.set\n  }\n\n  return new computedrefimpl(\n    getter,\n    setter,\n    isfunction(getteroroptions) || !getteroroptions.set\n  ) as any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\ncomputed 主要由 computedrefimpl 实现功能，可以传入 getter 和 setter，用于创建 ref 对象。\n\n\n# computedrefimpl\n\n创建 computedref 对象。\n\nclass computedrefimpl<t> {\n  private _value!: t\n  private _dirty = true // 初始就调度一次\n\n  public readonly effect: reactiveeffect<t>\n\n  public readonly __v_isref = true;\n  public readonly [reactiveflags.is_readonly]: boolean\n\n  constructor(\n    getter: computedgetter<t>,\n    private readonly _setter: computedsetter<t>,\n    isreadonly: boolean\n  ) {\n    // 创建 lazy effect\n    this.effect = effect(getter, {\n      // 跳过初始化的执行\n      lazy: true, // 自定义调度器，在执行 effect 时由交给自定义的调度器处理（调度）\n      // _dirty 表示是否调度过\n      // 注意：这里并不是说 effect 只会执行一次，而是发起了一次调度\n      scheduler: () => {\n        if (!this._dirty) {\n          this._dirty = true\n          trigger(toraw(this), triggeroptypes.set, 'value')\n        }\n      }\n    })\n\n    this[reactiveflags.is_readonly] = isreadonly\n  }\n\n  get value() {\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n    // 如果当前对象被 proxy，需要将它解包装\n    const self = toraw(this)\n    // 如果已经被调度，就执行 effect，并且响应执行后的结果，然后关闭调度\n    if (self._dirty) {\n      self._value = this.effect()\n      self._dirty = false\n    }\n    // 追踪依赖\n    track(self, trackoptypes.get, 'value')\n    return self._value\n  }\n\n  set value(newvalue: t) {\n    // 直接调用 _setter\n    this._setter(newvalue)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n与 ref 不同的有以下几点：\n\n * 创建是 effect 是 lazy effect，也就是在初始化时并不会执行一次。\n\n执行如下的测试代码，看一下 computed 的过程：\n\nit('should return updated value', () => {\n  const value = reactive<{ foo?: number }>({})\n  console.log('==> 1')\n  const cvalue = computed(() => value.foo)\n  let temp\n  console.log('==> 2')\n  effect(() => (temp = cvalue.value))\n  console.log('==> 3')\n  expect(cvalue.value).tobe(undefined)\n  console.log('==> 4')\n  value.foo = 1\n  console.log('==> 5')\n  expect(cvalue.value).tobe(1)\n  console.log('==> 6')\n  expect(temp).tobe(1)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n// 创建 reactive 对象，响应式目标被代理\n==> createreactiveobject { target: {} }\n\n==> 1\n// 实例化 computedrefimpl 对象，在构造器中生成 effect。调用 effect()。\n==> createreactiveeffect [arguments] {\n  '0': [function],\n  '1': { lazy: true, scheduler: [function: scheduler] } }\n\n==> 2\n\n==> createreactiveeffect [arguments] { '0': [function], '1': {} }\n\n==> computedrefimpl get { _dirty: true }\n\n==> get { target: {}, key: 'foo' }\n\n==> track [arguments] { '0': {}, '1': 'get', '2': 'foo' } { activeeffect:\n   { [function: reactiveeffect]\n     id: 0,\n     allowrecurse: false,\n     _iseffect: true,\n     active: true,\n     raw: [function],\n     deps: [],\n     options: { lazy: true, scheduler: [function: scheduler] } } }\n\n==> track [arguments] {\n  '0':\n   computedrefimpl {\n     _setter: [function],\n     _dirty: false,\n     __v_isref: true,\n     effect:\n      { [function: reactiveeffect]\n        id: 0,\n        allowrecurse: false,\n        _iseffect: true,\n        active: true,\n        raw: [function],\n        deps: [array],\n        options: [object] },\n     __v_isreadonly: true,\n     _value: undefined },\n  '1': 'get',\n  '2': 'value' } { activeeffect:\n   { [function: reactiveeffect]\n     id: 1,\n     allowrecurse: false,\n     _iseffect: true,\n     active: true,\n     raw: [function],\n     deps: [],\n     options: {} } }\n\n==> 3\n\n==> computedrefimpl get { _dirty: false }\n\n==> track [arguments] {\n  '0':\n   computedrefimpl {\n     _setter: [function],\n     _dirty: false,\n     __v_isref: true,\n     effect:\n      { [function: reactiveeffect]\n        id: 0,\n        allowrecurse: false,\n        _iseffect: true,\n        active: true,\n        raw: [function],\n        deps: [array],\n        options: [object] },\n     __v_isreadonly: true,\n     _value: undefined },\n  '1': 'get',\n  '2': 'value' } { activeeffect: undefined }\n\n==> 4\n\n==> set { target: {}, key: 'foo' }\n\n==> get { target: { foo: 1 }, key: '__v_raw' }\n\n==> trigger [arguments] { '0': { foo: 1 }, '1': 'add', '2': 'foo', '3': 1 }\n\n==> computedrefimpl effect scheduler { _dirty: false }\n\n==> trigger [arguments] {\n  '0':\n   computedrefimpl {\n     _setter: [function],\n     _dirty: true,\n     __v_isref: true,\n     effect:\n      { [function: reactiveeffect]\n        id: 0,\n        allowrecurse: false,\n        _iseffect: true,\n        active: true,\n        raw: [function],\n        deps: [array],\n        options: [object] },\n     __v_isreadonly: true,\n     _value: undefined },\n  '1': 'set',\n  '2': 'value' }\n\n==> computedrefimpl get { _dirty: true }\n\n==> get { target: { foo: 1 }, key: 'foo' }\n\n==> track [arguments] { '0': { foo: 1 }, '1': 'get', '2': 'foo' } { activeeffect:\n   { [function: reactiveeffect]\n     id: 0,\n     allowrecurse: false,\n     _iseffect: true,\n     active: true,\n     raw: [function],\n     deps: [],\n     options: { lazy: true, scheduler: [function: scheduler] } } }\n\n==> track [arguments] {\n  '0':\n   computedrefimpl {\n     _setter: [function],\n     _dirty: false,\n     __v_isref: true,\n     effect:\n      { [function: reactiveeffect]\n        id: 0,\n        allowrecurse: false,\n        _iseffect: true,\n        active: true,\n        raw: [function],\n        deps: [array],\n        options: [object] },\n     __v_isreadonly: true,\n     _value: 1 },\n  '1': 'get',\n  '2': 'value' } { activeeffect:\n   { [function: reactiveeffect]\n     id: 1,\n     allowrecurse: false,\n     _iseffect: true,\n     active: true,\n     raw: [function],\n     deps: [],\n     options: {} } }\n\n==> 5\n\n==> computedrefimpl get { _dirty: false }\n\n==> track [arguments] {\n  '0':\n   computedrefimpl {\n     _setter: [function],\n     _dirty: false,\n     __v_isref: true,\n     effect:\n      { [function: reactiveeffect]\n        id: 0,\n        allowrecurse: false,\n        _iseffect: true,\n        active: true,\n        raw: [function],\n        deps: [array],\n        options: [object] },\n     __v_isreadonly: true,\n     _value: 1 },\n  '1': 'get',\n  '2': 'value' } { activeeffect: undefined }\n\n==> 6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n\n\n\n# 文章小结",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/runtime-core/index/",categories:["vue3","runtime-core"],tags:[null]},regularPath:"/20.vue3/30.runtime-core/0.index.html",relativePath:"20.vue3/30.runtime-core/0.index.md",key:"v-7844a83d",path:"/vue3/runtime-core/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-14T22:02:21.000Z",permalink:"/vue3/runtime-dom/index/",categories:["vue3","runtime-dom"],tags:[null]},regularPath:"/20.vue3/40.runtime-dom/0.index.html",relativePath:"20.vue3/40.runtime-dom/0.index.md",key:"v-847c1376",path:"/vue3/runtime-dom/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"apiCreateApp",frontmatter:{title:"apiCreateApp",date:"2022-07-13T17:59:59.000Z",permalink:"/vue3/runtime-dom/apiCreateApp/",categories:["vue3","runtime-dom"],tags:[null]},regularPath:"/20.vue3/40.runtime-dom/10.apiCreateApp.html",relativePath:"20.vue3/40.runtime-dom/10.apiCreateApp.md",key:"v-36768879",path:"/vue3/runtime-dom/apiCreateApp/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"createApp",slug:"createapp",normalizedTitle:"createapp",charIndex:17},{level:2,title:"createRenderer",slug:"createrenderer",normalizedTitle:"createrenderer",charIndex:30},{level:2,title:"createAppAPI",slug:"createappapi",normalizedTitle:"createappapi",charIndex:48},{level:2,title:"createAppContext",slug:"createappcontext",normalizedTitle:"createappcontext",charIndex:64}],readingTime:{text:"3 min read",minutes:2.645,time:158700,words:529},headersStr:"目录 createApp createRenderer createAppAPI createAppContext",content:"# 目录\n\n\n\n * 目录\n * createApp\n * createRenderer\n * createAppAPI\n * createAppContext\n\n\n\n\n# createApp\n\n// packages/runtime-dom/src/index.ts\n// see https://vuejs.org/api/application.html#createapp\nconst createApp = ((...args) => {\n  const app = ensureRenderer().createApp(...args)\n  // ......\n  const { mount } = app\n  app.mount = (containerOrSelector: Element | ShadowRoot | string): any => {\n    const container = normalizeContainer(containerOrSelector)\n    if (!container) return\n    // ......\n    // clear content before mounting\n    container.innerHTML = ''\n    const proxy = mount(container, false, container instanceof SVGElement)\n    // ......\n    return proxy\n  }\n  return app\n}) as CreateAppFunction<Element>\n\n// lazy create the renderer - this makes core renderer logic tree-shakable\n// in case the user only imports reactivity utilities from Vue.\nlet renderer: Renderer<Element | ShadowRoot> | HydrationRenderer\n\nfunction ensureRenderer() {\n  return (\n    renderer ||\n    (renderer = createRenderer<Node, Element | ShadowRoot>(rendererOptions))\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# createRenderer\n\nexport function createRenderer<\n  HostNode = RendererNode,\n  HostElement = RendererElement\n>(options: RendererOptions<HostNode, HostElement>) {\n  return baseCreateRenderer<HostNode, HostElement>(options)\n}\n\nfunction baseCreateRenderer(options: RendererOptions) {\n  // ......\n   const render: RootRenderFunction = (vnode, container, isSVG) => {\n    // ......\n    patch(container._vnode || null, vnode, container, null, null, null, isSVG)\n    // ......\n    container._vnode = vnode\n  }\n  return {\n    render,\n    hydrate,\n    createApp: createAppAPI(render, hydrate)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# createAppAPI\n\n// packages/runtime-core/src/apiCreateApp.ts\nexport function createAppAPI<HostElement>(\n  render: RootRenderFunction,\n  hydrate?: RootHydrateFunction\n): CreateAppFunction<HostElement> {\n  return function createApp(rootComponent, rootProps = null) {\n    // ......\n\n    const context = createAppContext()\n    const installedPlugins = new Set()\n\n    let isMounted = false\n\n    const app: App = (context.app = {\n      _uid: uid++,\n      _component: rootComponent as ConcreteComponent,\n      _props: rootProps,\n      _container: null,\n      _context: context,\n      _instance: null,\n\n      version,\n\n      get config() {\n        return context.config\n      },\n      // ......\n\n      use(plugin: Plugin, ...options: any[]) {\n        if (installedPlugins.has(plugin)) {\n          __DEV__ && warn(`Plugin has already been applied to target app.`)\n        } else if (plugin && isFunction(plugin.install)) {\n          installedPlugins.add(plugin)\n          plugin.install(app, ...options)\n        } else if (isFunction(plugin)) {\n          installedPlugins.add(plugin)\n          plugin(app, ...options)\n        } \n        // ......\n        return app\n      },\n\n      mixin(mixin: ComponentOptions) {\n        if (__FEATURE_OPTIONS_API__) {\n          if (!context.mixins.includes(mixin)) {\n            context.mixins.push(mixin)\n          }\n          // ......\n        } \n        // ......\n        return app\n      },\n\n      component(name: string, component?: Component): any {\n        if (!component) {\n          return context.components[name]\n        }\n        // ......\n        context.components[name] = component\n        return app\n      },\n\n      directive(name: string, directive?: Directive) {\n        if (!directive) {\n          return context.directives[name] as any\n        }\n        // ......\n        context.directives[name] = directive\n        return app\n      },\n\n      mount(\n        rootContainer: HostElement,\n        isHydrate?: boolean,\n        isSVG?: boolean\n      ): any {\n        if (!isMounted) {\n          // ......\n          const vnode = createVNode(\n            rootComponent as ConcreteComponent,\n            rootProps\n          )\n          // store app context on the root VNode.\n          // this will be set on the root instance on initial mount.\n          vnode.appContext = context\n          // ......\n\n          if (isHydrate && hydrate) {\n            hydrate(vnode as VNode<Node, Element>, rootContainer as any)\n          } else {\n            render(vnode, rootContainer, isSVG)\n          }\n          isMounted = true\n          app._container = rootContainer\n          // ......\n          return getExposeProxy(vnode.component!) || vnode.component!.proxy\n        } \n        // ......\n      },\n\n      unmount() {\n        if (isMounted) {\n          (null, app._container)\n          // ..render....\n          delete app._container.__vue_app__\n        } \n        // .......\n      },\n\n      provide(key, value) {\n        // ......\n        context.provides[key as string | symbol] = value\n        return app\n      }\n    })\n    // ......\n    return app\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n\n\n\n# createAppContext\n\n// see https://vuejs.org/api/application.html#app-config\nfunction createAppContext(): AppContext {\n  return {\n    app: null as any,\n    config: {\n      isNativeTag: NO,\n      performance: false,\n      globalProperties: {},\n      optionMergeStrategies: {},\n      errorHandler: undefined,\n      warnHandler: undefined,\n      compilerOptions: {}\n    },\n    mixins: [],\n    components: {},\n    directives: {},\n    provides: Object.create(null),\n    optionsCache: new WeakMap(),\n    propsCache: new WeakMap(),\n    emitsCache: new WeakMap()\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",normalizedContent:"# 目录\n\n\n\n * 目录\n * createapp\n * createrenderer\n * createappapi\n * createappcontext\n\n\n\n\n# createapp\n\n// packages/runtime-dom/src/index.ts\n// see https://vuejs.org/api/application.html#createapp\nconst createapp = ((...args) => {\n  const app = ensurerenderer().createapp(...args)\n  // ......\n  const { mount } = app\n  app.mount = (containerorselector: element | shadowroot | string): any => {\n    const container = normalizecontainer(containerorselector)\n    if (!container) return\n    // ......\n    // clear content before mounting\n    container.innerhtml = ''\n    const proxy = mount(container, false, container instanceof svgelement)\n    // ......\n    return proxy\n  }\n  return app\n}) as createappfunction<element>\n\n// lazy create the renderer - this makes core renderer logic tree-shakable\n// in case the user only imports reactivity utilities from vue.\nlet renderer: renderer<element | shadowroot> | hydrationrenderer\n\nfunction ensurerenderer() {\n  return (\n    renderer ||\n    (renderer = createrenderer<node, element | shadowroot>(rendereroptions))\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# createrenderer\n\nexport function createrenderer<\n  hostnode = renderernode,\n  hostelement = rendererelement\n>(options: rendereroptions<hostnode, hostelement>) {\n  return basecreaterenderer<hostnode, hostelement>(options)\n}\n\nfunction basecreaterenderer(options: rendereroptions) {\n  // ......\n   const render: rootrenderfunction = (vnode, container, issvg) => {\n    // ......\n    patch(container._vnode || null, vnode, container, null, null, null, issvg)\n    // ......\n    container._vnode = vnode\n  }\n  return {\n    render,\n    hydrate,\n    createapp: createappapi(render, hydrate)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# createappapi\n\n// packages/runtime-core/src/apicreateapp.ts\nexport function createappapi<hostelement>(\n  render: rootrenderfunction,\n  hydrate?: roothydratefunction\n): createappfunction<hostelement> {\n  return function createapp(rootcomponent, rootprops = null) {\n    // ......\n\n    const context = createappcontext()\n    const installedplugins = new set()\n\n    let ismounted = false\n\n    const app: app = (context.app = {\n      _uid: uid++,\n      _component: rootcomponent as concretecomponent,\n      _props: rootprops,\n      _container: null,\n      _context: context,\n      _instance: null,\n\n      version,\n\n      get config() {\n        return context.config\n      },\n      // ......\n\n      use(plugin: plugin, ...options: any[]) {\n        if (installedplugins.has(plugin)) {\n          __dev__ && warn(`plugin has already been applied to target app.`)\n        } else if (plugin && isfunction(plugin.install)) {\n          installedplugins.add(plugin)\n          plugin.install(app, ...options)\n        } else if (isfunction(plugin)) {\n          installedplugins.add(plugin)\n          plugin(app, ...options)\n        } \n        // ......\n        return app\n      },\n\n      mixin(mixin: componentoptions) {\n        if (__feature_options_api__) {\n          if (!context.mixins.includes(mixin)) {\n            context.mixins.push(mixin)\n          }\n          // ......\n        } \n        // ......\n        return app\n      },\n\n      component(name: string, component?: component): any {\n        if (!component) {\n          return context.components[name]\n        }\n        // ......\n        context.components[name] = component\n        return app\n      },\n\n      directive(name: string, directive?: directive) {\n        if (!directive) {\n          return context.directives[name] as any\n        }\n        // ......\n        context.directives[name] = directive\n        return app\n      },\n\n      mount(\n        rootcontainer: hostelement,\n        ishydrate?: boolean,\n        issvg?: boolean\n      ): any {\n        if (!ismounted) {\n          // ......\n          const vnode = createvnode(\n            rootcomponent as concretecomponent,\n            rootprops\n          )\n          // store app context on the root vnode.\n          // this will be set on the root instance on initial mount.\n          vnode.appcontext = context\n          // ......\n\n          if (ishydrate && hydrate) {\n            hydrate(vnode as vnode<node, element>, rootcontainer as any)\n          } else {\n            render(vnode, rootcontainer, issvg)\n          }\n          ismounted = true\n          app._container = rootcontainer\n          // ......\n          return getexposeproxy(vnode.component!) || vnode.component!.proxy\n        } \n        // ......\n      },\n\n      unmount() {\n        if (ismounted) {\n          (null, app._container)\n          // ..render....\n          delete app._container.__vue_app__\n        } \n        // .......\n      },\n\n      provide(key, value) {\n        // ......\n        context.provides[key as string | symbol] = value\n        return app\n      }\n    })\n    // ......\n    return app\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n\n\n\n# createappcontext\n\n// see https://vuejs.org/api/application.html#app-config\nfunction createappcontext(): appcontext {\n  return {\n    app: null as any,\n    config: {\n      isnativetag: no,\n      performance: false,\n      globalproperties: {},\n      optionmergestrategies: {},\n      errorhandler: undefined,\n      warnhandler: undefined,\n      compileroptions: {}\n    },\n    mixins: [],\n    components: {},\n    directives: {},\n    provides: object.create(null),\n    optionscache: new weakmap(),\n    propscache: new weakmap(),\n    emitscache: new weakmap()\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",charsets:{cjk:!0},lastUpdated:"2022/07/13, 18:52:25",lastUpdatedTimestamp:1657709545e3},{title:"apiDefineComponent",frontmatter:{title:"apiDefineComponent",date:"2022-07-13T18:57:20.000Z",permalink:"/vue3/runtime-dom/apiDefineComponent/",categories:["vue3","runtime-dom"],tags:[null]},regularPath:"/20.vue3/40.runtime-dom/20.apiDefineComponent.html",relativePath:"20.vue3/40.runtime-dom/20.apiDefineComponent.md",key:"v-af98cc06",path:"/vue3/runtime-dom/apiDefineComponent/",headers:[{level:2,title:"defineComponent",slug:"definecomponent",normalizedTitle:"definecomponent",charIndex:2},{level:2,title:"defineAsyncComponent",slug:"defineasynccomponent",normalizedTitle:"defineasynccomponent",charIndex:290}],readingTime:{text:"3 min read",minutes:2.235,time:134100,words:447},headersStr:"defineComponent defineAsyncComponent",content:"# defineComponent\n\n// packages/runtime-core/src/apiDefineComponent.ts\n// see https://vuejs.org/api/general.html#definecomponent\nfunction defineComponent(options: unknown) {\n  return isFunction(options) ? { setup: options, name: options.name } : options\n}\n\n\n1\n2\n3\n4\n5\n\n\nSFC 的本质是 object。\n\n\n# defineAsyncComponent\n\n// see https://vuejs.org/api/general.html#defineasynccomponent\nexport function defineAsyncComponent<\n  T extends Component = { new (): ComponentPublicInstance }\n>(source: AsyncComponentLoader<T> | AsyncComponentOptions<T>): T {\n  if (isFunction(source)) {\n    source = { loader: source }\n  }\n\n  const {\n    loader,\n    loadingComponent,\n    errorComponent,\n    delay = 200,\n    timeout, // undefined = never times out\n    suspensible = true,\n    onError: userOnError\n  } = source\n\n  let pendingRequest: Promise<ConcreteComponent> | null = null\n  let resolvedComp: ConcreteComponent | undefined\n\n  // ......\n  const load = (): Promise<ConcreteComponent> => {\n    let thisRequest: Promise<ConcreteComponent>\n    return (\n      pendingRequest ||\n      (thisRequest = pendingRequest =\n        loader()\n          .catch(err => {\n            // ......\n          })\n          .then((comp: any) => {\n            // ......\n            // interop module default\n            if (\n              comp &&\n              (comp.__esModule || comp[Symbol.toStringTag] === 'Module')\n            ) {\n              comp = comp.default\n            }\n            //  ......\n            resolvedComp = comp\n            return comp\n          }))\n    )\n  }\n\n  return defineComponent({\n    name: 'AsyncComponentWrapper',\n\n    __asyncLoader: load,\n\n    get __asyncResolved() {\n      return resolvedComp\n    },\n\n    setup() {\n      const instance = currentInstance!\n\n      // already resolved\n      if (resolvedComp) {\n        return () => createInnerComp(resolvedComp!, instance)\n      }\n\n      const onError = (err: Error) => {\n        pendingRequest = null\n        handleError(\n          err,\n          instance,\n          ErrorCodes.ASYNC_COMPONENT_LOADER,\n          !errorComponent /* do not throw in dev if user provided error component */\n        )\n      }\n\n      // suspense-controlled or SSR.\n      if (\n        (__FEATURE_SUSPENSE__ && suspensible && instance.suspense) ||\n        (__SSR__ && isInSSRComponentSetup)\n      ) {\n        return load()\n          .then(comp => {\n            return () => createInnerComp(comp, instance)\n          })\n          .catch(err => {\n            onError(err)\n            return () =>\n              errorComponent\n                ? createVNode(errorComponent as ConcreteComponent, {\n                    error: err\n                  })\n                : null\n          })\n      }\n\n      const loaded = ref(false)\n      const error = ref()\n      const delayed = ref(!!delay)\n\n      if (delay) {\n        setTimeout(() => {\n          delayed.value = false\n        }, delay)\n      }\n\n      if (timeout != null) {\n        setTimeout(() => {\n          if (!loaded.value && !error.value) {\n            const err = new Error(\n              `Async component timed out after ${timeout}ms.`\n            )\n            onError(err)\n            error.value = err\n          }\n        }, timeout)\n      }\n\n      load()\n        .then(() => {\n          loaded.value = true\n          if (instance.parent && isKeepAlive(instance.parent.vnode)) {\n            // parent is keep-alive, force update so the loaded component's\n            // name is taken into account\n            queueJob(instance.parent.update)\n          }\n        })\n        .catch(err => {\n          onError(err)\n          error.value = err\n        })\n\n      return () => {\n        if (loaded.value && resolvedComp) {\n          return createInnerComp(resolvedComp, instance)\n        } else if (error.value && errorComponent) {\n          return createVNode(errorComponent as ConcreteComponent, {\n            error: error.value\n          })\n        } else if (loadingComponent && !delayed.value) {\n          return createVNode(loadingComponent as ConcreteComponent)\n        }\n      }\n    }\n  }) as T\n}\n\nfunction createInnerComp(\n  comp: ConcreteComponent,\n  {\n    vnode: { ref, props, children, shapeFlag },\n    parent\n  }: ComponentInternalInstance\n) {\n  const vnode = createVNode(comp, props, children)\n  // ensure inner component inherits the async wrapper's ref owner\n  vnode.ref = ref\n  return vnode\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n",normalizedContent:"# definecomponent\n\n// packages/runtime-core/src/apidefinecomponent.ts\n// see https://vuejs.org/api/general.html#definecomponent\nfunction definecomponent(options: unknown) {\n  return isfunction(options) ? { setup: options, name: options.name } : options\n}\n\n\n1\n2\n3\n4\n5\n\n\nsfc 的本质是 object。\n\n\n# defineasynccomponent\n\n// see https://vuejs.org/api/general.html#defineasynccomponent\nexport function defineasynccomponent<\n  t extends component = { new (): componentpublicinstance }\n>(source: asynccomponentloader<t> | asynccomponentoptions<t>): t {\n  if (isfunction(source)) {\n    source = { loader: source }\n  }\n\n  const {\n    loader,\n    loadingcomponent,\n    errorcomponent,\n    delay = 200,\n    timeout, // undefined = never times out\n    suspensible = true,\n    onerror: useronerror\n  } = source\n\n  let pendingrequest: promise<concretecomponent> | null = null\n  let resolvedcomp: concretecomponent | undefined\n\n  // ......\n  const load = (): promise<concretecomponent> => {\n    let thisrequest: promise<concretecomponent>\n    return (\n      pendingrequest ||\n      (thisrequest = pendingrequest =\n        loader()\n          .catch(err => {\n            // ......\n          })\n          .then((comp: any) => {\n            // ......\n            // interop module default\n            if (\n              comp &&\n              (comp.__esmodule || comp[symbol.tostringtag] === 'module')\n            ) {\n              comp = comp.default\n            }\n            //  ......\n            resolvedcomp = comp\n            return comp\n          }))\n    )\n  }\n\n  return definecomponent({\n    name: 'asynccomponentwrapper',\n\n    __asyncloader: load,\n\n    get __asyncresolved() {\n      return resolvedcomp\n    },\n\n    setup() {\n      const instance = currentinstance!\n\n      // already resolved\n      if (resolvedcomp) {\n        return () => createinnercomp(resolvedcomp!, instance)\n      }\n\n      const onerror = (err: error) => {\n        pendingrequest = null\n        handleerror(\n          err,\n          instance,\n          errorcodes.async_component_loader,\n          !errorcomponent /* do not throw in dev if user provided error component */\n        )\n      }\n\n      // suspense-controlled or ssr.\n      if (\n        (__feature_suspense__ && suspensible && instance.suspense) ||\n        (__ssr__ && isinssrcomponentsetup)\n      ) {\n        return load()\n          .then(comp => {\n            return () => createinnercomp(comp, instance)\n          })\n          .catch(err => {\n            onerror(err)\n            return () =>\n              errorcomponent\n                ? createvnode(errorcomponent as concretecomponent, {\n                    error: err\n                  })\n                : null\n          })\n      }\n\n      const loaded = ref(false)\n      const error = ref()\n      const delayed = ref(!!delay)\n\n      if (delay) {\n        settimeout(() => {\n          delayed.value = false\n        }, delay)\n      }\n\n      if (timeout != null) {\n        settimeout(() => {\n          if (!loaded.value && !error.value) {\n            const err = new error(\n              `async component timed out after ${timeout}ms.`\n            )\n            onerror(err)\n            error.value = err\n          }\n        }, timeout)\n      }\n\n      load()\n        .then(() => {\n          loaded.value = true\n          if (instance.parent && iskeepalive(instance.parent.vnode)) {\n            // parent is keep-alive, force update so the loaded component's\n            // name is taken into account\n            queuejob(instance.parent.update)\n          }\n        })\n        .catch(err => {\n          onerror(err)\n          error.value = err\n        })\n\n      return () => {\n        if (loaded.value && resolvedcomp) {\n          return createinnercomp(resolvedcomp, instance)\n        } else if (error.value && errorcomponent) {\n          return createvnode(errorcomponent as concretecomponent, {\n            error: error.value\n          })\n        } else if (loadingcomponent && !delayed.value) {\n          return createvnode(loadingcomponent as concretecomponent)\n        }\n      }\n    }\n  }) as t\n}\n\nfunction createinnercomp(\n  comp: concretecomponent,\n  {\n    vnode: { ref, props, children, shapeflag },\n    parent\n  }: componentinternalinstance\n) {\n  const vnode = createvnode(comp, props, children)\n  // ensure inner component inherits the async wrapper's ref owner\n  vnode.ref = ref\n  return vnode\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n",charsets:{cjk:!0},lastUpdated:"2022/07/18, 21:05:56",lastUpdatedTimestamp:1658149556e3},{title:"scheduler",frontmatter:{title:"scheduler",date:"2022-07-13T19:00:32.000Z",permalink:"/pages/286896/",categories:["vue3","runtime-dom"],tags:[null]},regularPath:"/20.vue3/40.runtime-dom/90.scheduler.html",relativePath:"20.vue3/40.runtime-dom/90.scheduler.md",key:"v-7b4d74fd",path:"/pages/286896/",headers:[{level:2,title:"nextTick",slug:"nexttick",normalizedTitle:"nexttick",charIndex:2}],readingTime:{text:"1 min read",minutes:.27,time:16200.000000000004,words:54},headersStr:"nextTick",content:"# nextTick\n\n// packages/runtime-core/src/scheduler.ts\n// see https://vuejs.org/api/general.html#nexttick\nconst resolvedPromise = /*#__PURE__*/ Promise.resolve() as Promise<any>\nlet currentFlushPromise: Promise<void> | null = null\n\nfunction nextTick<T = void>(\n  this: T,\n  fn?: (this: T) => void\n): Promise<void> {\n  const p = currentFlushPromise || resolvedPromise\n  return fn ? p.then(this ? fn.bind(this) : fn) : p\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",normalizedContent:"# nexttick\n\n// packages/runtime-core/src/scheduler.ts\n// see https://vuejs.org/api/general.html#nexttick\nconst resolvedpromise = /*#__pure__*/ promise.resolve() as promise<any>\nlet currentflushpromise: promise<void> | null = null\n\nfunction nexttick<t = void>(\n  this: t,\n  fn?: (this: t) => void\n): promise<void> {\n  const p = currentflushpromise || resolvedpromise\n  return fn ? p.then(this ? fn.bind(this) : fn) : p\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n",charsets:{cjk:!0},lastUpdated:"2022/07/18, 21:05:56",lastUpdatedTimestamp:1658149556e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-14T23:36:48.000Z",permalink:"/web/index/",categories:null,tags:[null]},regularPath:"/30.web/0.index.html",relativePath:"30.web/0.index.md",key:"v-50e647d9",path:"/web/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"Plan 计划",frontmatter:{title:"Plan 计划",date:"2022-04-16T13:46:07.000Z",permalink:"/web/plan/",categories:null,tags:[null]},regularPath:"/30.web/1.plan.html",relativePath:"30.web/1.plan.md",key:"v-26e7ba7d",path:"/web/plan/",headers:[{level:2,title:"Plan",slug:"plan",normalizedTitle:"plan",charIndex:2},{level:2,title:"Current 近期计划",slug:"current-近期计划",normalizedTitle:"current 近期计划",charIndex:43}],readingTime:{text:"1 min read",minutes:.09,time:5399.999999999999,words:18},headersStr:"Plan Current 近期计划",content:"# Plan\n\n * Qiankun 源码\n * Single-spa 源码\n\n\n# Current 近期计划\n\n * Webpack 源码",normalizedContent:"# plan\n\n * qiankun 源码\n * single-spa 源码\n\n\n# current 近期计划\n\n * webpack 源码",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"开始阅读",frontmatter:{title:"开始阅读",date:"2022-04-14T22:02:21.000Z",permalink:"/vite/index/",categories:["vite"],tags:[null]},regularPath:"/30.web/10.vite%E6%BA%90%E7%A0%81/0.index.html",relativePath:"30.web/10.vite源码/0.index.md",key:"v-566737cd",path:"/vite/index/",headers:[{level:2,title:"了解 vite",slug:"了解-vite",normalizedTitle:"了解 vite",charIndex:2},{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:1180},{level:2,title:"参考链接",slug:"参考链接",normalizedTitle:"参考链接",charIndex:1415},{level:2,title:"TODO 计划",slug:"todo-计划",normalizedTitle:"todo 计划",charIndex:1455},{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:1467}],readingTime:{text:"1 min read",minutes:.89,time:53400,words:178},headersStr:"了解 vite 说明 参考链接 TODO 计划 目录",content:"# 了解 vite\n\n要了解 vite，当然要从官网开始。vite 定位为下一代前端开发与构建工具，这体现在 vite 具有的如下特点：\n\n * 💡 极速的服务启动：使用原生 ESM 文件，无需打包！\n\n在 webpack 中，资源被打包成 chunk 以驱动程序运行，这其中产品的成本包括: 1. 资源打包的成本。2. 未加载的资源被打包的成本，因此即时是 dev server 中使用了热更新的优化，仍然无法彻底解决庞大的项目打包的速度问题。vite 则另辟蹊径，使用原生的 ESM 来作为 dev server 的资源分发，利用了现在浏览器对 ESM 的原生支持，同时借助浏览器发起的资源请求按需加载资源，可以说是完美的解决了传统的打包器的弊端。vite 解决资源打包成本问题是因为它根本就不打包，解决冗余资源加载成本问题是因为浏览器原生的按需请求。当然，只有现代浏览器才原生支持 ESM 会成为 vite 的弊端吗？其实不然，因为利用 ESM 打包是在 development 环境下才会使用的，毕竟有哪个开发者会使用陈旧的浏览器进行开发呢？实际上在 production 环境会使用类 rollup 的原理进行资源打包，既满足了轻量级的条件，同时也借用了 rollup 的开发生态。\n\n * ⚡️ 轻量快速的热重载：无论应用程序大小如何，都始终极快的模块热重载（HMR）\n\n所谓 HMR，就是 hot module reload，是指在更新代码后快速的重载应用。\n\n * 🛠️ 丰富的功能：对 TypeScript、JSX、CSS 等支持开箱即用。\n\nTypeScript 支持不必多言，vite 本身就是 TypeScript 写的。vite 作为一款通用的打包器，除了支持丝滑的 vue3 之外，还支持其他的框架和技术栈。相比于 webpack 这样的老牌打包器，vite 最大的优势就是优秀的开发体验，对于大型项目而言，打包速度依然不减。生产中常配合 vite 和 webpack 使用，vite 用于 development 环境，而将 webpack 用于生产环境的打包，这很大程度上是因为 webpack 成熟的生态和灵活的配置。\n\n * 📦 优化的构建：可选 “多页应用” 或 “库” 模式的预配置 Rollup 构建\n\n * 🔩 通用的插件：在开发和构建之间共享 Rollup-superset 插件接口。\n\nvite 在插件设计上兼容了 rollup 的插件生态，同时支持 vite 独有的插件。\n\n * 🔑 完全类型化的 API：灵活的 API 和完整 TypeScript 类型。\n\n上面是官网中支持的 vite 特点，在之后的源码解读中将逐渐体现这些方面。想要了解 vite 更多可以移步：vite: 指引\n\n\n# 说明\n\n事项          描述\nvite 版本     \nIDE         VSCode\n笔记源码 Repo   https://github.com/jonsam-ng/fe-source-reading\n笔记地址        https://source.jonsam.site\n阅读重点        解析依赖、解析源码、dev server、HMR、对 SFC 和 JSX 的支持\n阅读方式        运行源码、源码标注、笔记分析总结\n\n\n# 参考链接\n\n * vitejs/vite\n * Vite 官方中文文档\n\n\n# TODO 计划\n\n\n# 目录",normalizedContent:"# 了解 vite\n\n要了解 vite，当然要从官网开始。vite 定位为下一代前端开发与构建工具，这体现在 vite 具有的如下特点：\n\n * 💡 极速的服务启动：使用原生 esm 文件，无需打包！\n\n在 webpack 中，资源被打包成 chunk 以驱动程序运行，这其中产品的成本包括: 1. 资源打包的成本。2. 未加载的资源被打包的成本，因此即时是 dev server 中使用了热更新的优化，仍然无法彻底解决庞大的项目打包的速度问题。vite 则另辟蹊径，使用原生的 esm 来作为 dev server 的资源分发，利用了现在浏览器对 esm 的原生支持，同时借助浏览器发起的资源请求按需加载资源，可以说是完美的解决了传统的打包器的弊端。vite 解决资源打包成本问题是因为它根本就不打包，解决冗余资源加载成本问题是因为浏览器原生的按需请求。当然，只有现代浏览器才原生支持 esm 会成为 vite 的弊端吗？其实不然，因为利用 esm 打包是在 development 环境下才会使用的，毕竟有哪个开发者会使用陈旧的浏览器进行开发呢？实际上在 production 环境会使用类 rollup 的原理进行资源打包，既满足了轻量级的条件，同时也借用了 rollup 的开发生态。\n\n * ⚡️ 轻量快速的热重载：无论应用程序大小如何，都始终极快的模块热重载（hmr）\n\n所谓 hmr，就是 hot module reload，是指在更新代码后快速的重载应用。\n\n * 🛠️ 丰富的功能：对 typescript、jsx、css 等支持开箱即用。\n\ntypescript 支持不必多言，vite 本身就是 typescript 写的。vite 作为一款通用的打包器，除了支持丝滑的 vue3 之外，还支持其他的框架和技术栈。相比于 webpack 这样的老牌打包器，vite 最大的优势就是优秀的开发体验，对于大型项目而言，打包速度依然不减。生产中常配合 vite 和 webpack 使用，vite 用于 development 环境，而将 webpack 用于生产环境的打包，这很大程度上是因为 webpack 成熟的生态和灵活的配置。\n\n * 📦 优化的构建：可选 “多页应用” 或 “库” 模式的预配置 rollup 构建\n\n * 🔩 通用的插件：在开发和构建之间共享 rollup-superset 插件接口。\n\nvite 在插件设计上兼容了 rollup 的插件生态，同时支持 vite 独有的插件。\n\n * 🔑 完全类型化的 api：灵活的 api 和完整 typescript 类型。\n\n上面是官网中支持的 vite 特点，在之后的源码解读中将逐渐体现这些方面。想要了解 vite 更多可以移步：vite: 指引\n\n\n# 说明\n\n事项          描述\nvite 版本     \nide         vscode\n笔记源码 repo   https://github.com/jonsam-ng/fe-source-reading\n笔记地址        https://source.jonsam.site\n阅读重点        解析依赖、解析源码、dev server、hmr、对 sfc 和 jsx 的支持\n阅读方式        运行源码、源码标注、笔记分析总结\n\n\n# 参考链接\n\n * vitejs/vite\n * vite 官方中文文档\n\n\n# todo 计划\n\n\n# 目录",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"本章概要",frontmatter:{title:"本章概要",date:"2022-04-14T22:02:21.000Z",permalink:"/vite/basic/index/",categories:["vite","basic"],tags:[null]},regularPath:"/30.web/10.vite%E6%BA%90%E7%A0%81/10.%E5%9F%BA%E7%A1%80/0.index.html",relativePath:"30.web/10.vite源码/10.基础/0.index.md",key:"v-6e8687a2",path:"/vite/basic/index/",readingTime:{text:"1 min read",minutes:.545,time:32700.000000000004,words:109},headersStr:null,content:"在 packages 目录中，我们可以在看到 vite 主要分为下面几个模块：\n\n * create-app: vite cli 工具。\n * create-vite: vite template，支持包括 lit、preact、react、svelte、vanilla、vue 及其 ts 版本。\n * vite-playground: vite playground 演示工具。\n * plugin-legacy: 支持非现代浏览器使用 vite 的插件。\n * plugin-react: 支持 react 项目使用 vite 的插件。\n * plugin-vue: 支持 vue 项目（SFC）使用 vite 的插件。\n * plugin-vue-jsx: 支持 vue 项目使用 jsx 的插件。\n * vite: vite 源码。\n\nvite 的生态主要包括 vite 核心、插件系统、脚手架、模板工具等。在之后的章节中，将重点解析如下几个模块：\n\n * vite: 学习 vite dev server、打包原理、插件系统、依赖解析等。\n * plugin-vue: 学习 vite 是如何支持 vue 项目使用 vite 的，主要学习 vite 对 SFC 的解析。\n * plugin-react: 学习 vite 是如何支持 react 项目使用 vite 的，主要学习 vite 对 JSX 的解析。\n * create-app: 学习 vite 脚手架的工作原理。\n * create-vite: 学习如何配合脚手架工具搭建和管理项目模板。\n * plugin-legacy: 学习 vite 是如何是 legacy 浏览器支持 vite 的。\n * 项目结构：学习 monorepo 项目的搭建和管理。",normalizedContent:"在 packages 目录中，我们可以在看到 vite 主要分为下面几个模块：\n\n * create-app: vite cli 工具。\n * create-vite: vite template，支持包括 lit、preact、react、svelte、vanilla、vue 及其 ts 版本。\n * vite-playground: vite playground 演示工具。\n * plugin-legacy: 支持非现代浏览器使用 vite 的插件。\n * plugin-react: 支持 react 项目使用 vite 的插件。\n * plugin-vue: 支持 vue 项目（sfc）使用 vite 的插件。\n * plugin-vue-jsx: 支持 vue 项目使用 jsx 的插件。\n * vite: vite 源码。\n\nvite 的生态主要包括 vite 核心、插件系统、脚手架、模板工具等。在之后的章节中，将重点解析如下几个模块：\n\n * vite: 学习 vite dev server、打包原理、插件系统、依赖解析等。\n * plugin-vue: 学习 vite 是如何支持 vue 项目使用 vite 的，主要学习 vite 对 sfc 的解析。\n * plugin-react: 学习 vite 是如何支持 react 项目使用 vite 的，主要学习 vite 对 jsx 的解析。\n * create-app: 学习 vite 脚手架的工作原理。\n * create-vite: 学习如何配合脚手架工具搭建和管理项目模板。\n * plugin-legacy: 学习 vite 是如何是 legacy 浏览器支持 vite 的。\n * 项目结构：学习 monorepo 项目的搭建和管理。",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"本章概要",frontmatter:{title:"本章概要",date:"2022-04-14T22:02:21.000Z",permalink:"/vite/core/index/",categories:["vite","vite"],tags:[null]},regularPath:"/30.web/10.vite%E6%BA%90%E7%A0%81/20.vite/0.index.html",relativePath:"30.web/10.vite源码/20.vite/0.index.md",key:"v-7373c0fa",path:"/vite/core/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"cli：vite 的启起点",frontmatter:{title:"cli：vite 的启起点",date:"2022-04-14T22:02:21.000Z",permalink:"/vite/core/cli/",categories:["vite","vite"],tags:[null]},regularPath:"/30.web/10.vite%E6%BA%90%E7%A0%81/20.vite/10.cli.html",relativePath:"30.web/10.vite源码/20.vite/10.cli.md",key:"v-55a8d0bf",path:"/vite/core/cli/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"start",slug:"start",normalizedTitle:"start",charIndex:17},{level:2,title:"cli",slug:"cli",normalizedTitle:"cli",charIndex:26},{level:2,title:"相关工具库",slug:"相关工具库",normalizedTitle:"相关工具库",charIndex:33}],readingTime:{text:"3 min read",minutes:2.66,time:159600.00000000003,words:532},headersStr:"目录 start cli 相关工具库",content:"# 目录\n\n\n\n * 目录\n * start\n * cli\n * 相关工具库\n\n\n\n\n# start\n\n我们知道在使用 vite 时是将 vite 作为 npm 命令能使用以启动我们的项目的，因为 vite 实质上应该是 bin（二进制） 工程项目。因此在 vite 目录下的 package.json 文件中可以找到 bin 的入口为 bin/vite.js 。因此我们先来看下 vite.js 这个启动文件。\n\n在 vite.js 文件中主要对 cli 中 debug、profile 等特殊的参数进行处理，挂载到 process.env 或者 global 上，进而调用 start 函数。\n\nfunction start() {\n  require('../dist/node/cli')\n}\n\n\n1\n2\n3\n\n\n此处调用的是打包后的文件，由 src/node/cli.ts 打包生成，这里才真正进入 cli 的处理环节。\n\n\n# cli\n\n 1. 编写 cli.option\n\n// cli.option(name, description, config?)\ncli.option('-c, --config <file>', `[string] use specified config file`)\n\n\n1\n2\n\n * 定义参数的简写，全写，参数值占位和参数说明。\n * 支持链式调用。\n\n 2. 注册的 command 命令\n\n * vite serve (dev) 命令：启动 dev server。\n\naction 部分的处理：\n\nasync (root: string, options: ServerOptions & GlobalCLIOptions) => {\n    // output structure is preserved even after bundling so require()\n    // is ok here\n    const {\n        createServer\n    } = await import('./server')\n    try {\n        // 创建 dev server\n        const server = await createServer({\n            root,\n            base: options.base,\n            mode: options.mode,\n            configFile: options.config,\n            logLevel: options.logLevel,\n            clearScreen: options.clearScreen,\n            server: cleanOptions(options)\n        })\n        // 检测是否可使用 http server\n        if (!server.httpServer) {\n            throw new Error('HTTP server not available')\n        }\n        // 开始 dev server 监听进程\n        await server.listen()\n        //  获取到 info logger\n        const info = server.config.logger.info\n\n        info(\n            chalk.cyan(`\\n  vite v${require('vite/package.json').version}`) +\n            chalk.green(` dev server running at:\\n`), {\n                clear: !server.config.logger.hasWarned\n            }\n        )\n        // 打印 server url\n        server.printUrls()\n        // 打印启动时间统计\n        // @ts-ignore\n        if (global.__vite_start_time) {\n            // @ts-ignore\n            const startupDuration = performance.now() - global.__vite_start_time\n            info(`\\n  ${chalk.cyan(`ready in ${Math.ceil(startupDuration)}ms.`)}\\n`)\n        }\n    } catch (e) {\n        createLogger(options.logLevel).error(\n            chalk.red(`error when starting dev server:\\n${e.stack}`), {\n                error: e\n            }\n        )\n        // 退出程序\n        process.exit(1)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n这个命令的主要作用就是：开始 dev server、打印 server 信息和错误处理。\n\n * vite build 命令：项目打包\n\naction 部分的处理：\n\nasync (root: string, options: BuildOptions & GlobalCLIOptions) => {\n    const {\n        build\n    } = await import('./build')\n    const buildOptions: BuildOptions = cleanOptions(options)\n    // build project\n    try {\n        await build({\n            root,\n            base: options.base,\n            mode: options.mode,\n            configFile: options.config,\n            logLevel: options.logLevel,\n            clearScreen: options.clearScreen,\n            build: buildOptions\n        })\n    } catch (e) {\n        createLogger(options.logLevel).error(\n            chalk.red(`error during build:\\n${e.stack}`), {\n                error: e\n            }\n        )\n        process.exit(1)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n这里调用了异步方法 build 来打包项目。这个命令的主要作用是：项目打包。\n\n * vite optimize: 依赖优化\n\naction 部分的处理：\n\nasync (root: string, options: {\n    force ? : boolean\n} & GlobalCLIOptions) => {\n    const {\n        optimizeDeps\n    } = await import('./optimizer')\n    try {\n        // 处理 config\n        const config = await resolveConfig({\n                root,\n                base: options.base,\n                configFile: options.config,\n                logLevel: options.logLevel\n            },\n            'build',\n            'development'\n        )\n        // 优化依赖项\n        await optimizeDeps(config, options.force, true)\n    } catch (e) {\n        createLogger(options.logLevel).error(\n            chalk.red(`error when optimizing deps:\\n${e.stack}`), {\n                error: e\n            }\n        )\n        process.exit(1)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nvite 会对项目的依赖关系进行缓存，此命名可重建依赖缓存。\n\n * vite preview: production 模式的预览\n\naction 部分的处理：\n\nasync (\n    root: string,\n    options: {\n        host ? : string | boolean\n        port ? : number\n        https ? : boolean\n        open ? : boolean | string\n        strictPort ? : boolean\n    } & GlobalCLIOptions\n) => {\n    // 模拟 server 以 buildDir 为静态目录 serve 资源\n    try {\n        const server = await preview({\n            root,\n            base: options.base,\n            configFile: options.config,\n            logLevel: options.logLevel,\n            preview: {\n                port: options.port,\n                strictPort: options.strictPort,\n                host: options.host,\n                https: options.https,\n                open: options.open\n            }\n        })\n        server.printUrls()\n    } catch (e) {\n        createLogger(options.logLevel).error(\n            chalk.red(`error when starting preview server:\\n${e.stack}`), {\n                error: e\n            }\n        )\n        process.exit(1)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n这部分模拟真实的服务器对打包的资源提供服务，预览 dist 在真实 server 环境下的表现。\n\n 3. cli.help(): Display help message when -h or --help appears.\n 4. cli.version(): Display version number when -v or --version appears.\n 5. cli.parse(): Parse CLI args.\n\n\n# 相关工具库\n\n * cacjs/cac:Simple yet powerful framework for building command-line apps.\n * chalk/chalk: Terminal string styling done right.",normalizedContent:"# 目录\n\n\n\n * 目录\n * start\n * cli\n * 相关工具库\n\n\n\n\n# start\n\n我们知道在使用 vite 时是将 vite 作为 npm 命令能使用以启动我们的项目的，因为 vite 实质上应该是 bin（二进制） 工程项目。因此在 vite 目录下的 package.json 文件中可以找到 bin 的入口为 bin/vite.js 。因此我们先来看下 vite.js 这个启动文件。\n\n在 vite.js 文件中主要对 cli 中 debug、profile 等特殊的参数进行处理，挂载到 process.env 或者 global 上，进而调用 start 函数。\n\nfunction start() {\n  require('../dist/node/cli')\n}\n\n\n1\n2\n3\n\n\n此处调用的是打包后的文件，由 src/node/cli.ts 打包生成，这里才真正进入 cli 的处理环节。\n\n\n# cli\n\n 1. 编写 cli.option\n\n// cli.option(name, description, config?)\ncli.option('-c, --config <file>', `[string] use specified config file`)\n\n\n1\n2\n\n * 定义参数的简写，全写，参数值占位和参数说明。\n * 支持链式调用。\n\n 2. 注册的 command 命令\n\n * vite serve (dev) 命令：启动 dev server。\n\naction 部分的处理：\n\nasync (root: string, options: serveroptions & globalclioptions) => {\n    // output structure is preserved even after bundling so require()\n    // is ok here\n    const {\n        createserver\n    } = await import('./server')\n    try {\n        // 创建 dev server\n        const server = await createserver({\n            root,\n            base: options.base,\n            mode: options.mode,\n            configfile: options.config,\n            loglevel: options.loglevel,\n            clearscreen: options.clearscreen,\n            server: cleanoptions(options)\n        })\n        // 检测是否可使用 http server\n        if (!server.httpserver) {\n            throw new error('http server not available')\n        }\n        // 开始 dev server 监听进程\n        await server.listen()\n        //  获取到 info logger\n        const info = server.config.logger.info\n\n        info(\n            chalk.cyan(`\\n  vite v${require('vite/package.json').version}`) +\n            chalk.green(` dev server running at:\\n`), {\n                clear: !server.config.logger.haswarned\n            }\n        )\n        // 打印 server url\n        server.printurls()\n        // 打印启动时间统计\n        // @ts-ignore\n        if (global.__vite_start_time) {\n            // @ts-ignore\n            const startupduration = performance.now() - global.__vite_start_time\n            info(`\\n  ${chalk.cyan(`ready in ${math.ceil(startupduration)}ms.`)}\\n`)\n        }\n    } catch (e) {\n        createlogger(options.loglevel).error(\n            chalk.red(`error when starting dev server:\\n${e.stack}`), {\n                error: e\n            }\n        )\n        // 退出程序\n        process.exit(1)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n这个命令的主要作用就是：开始 dev server、打印 server 信息和错误处理。\n\n * vite build 命令：项目打包\n\naction 部分的处理：\n\nasync (root: string, options: buildoptions & globalclioptions) => {\n    const {\n        build\n    } = await import('./build')\n    const buildoptions: buildoptions = cleanoptions(options)\n    // build project\n    try {\n        await build({\n            root,\n            base: options.base,\n            mode: options.mode,\n            configfile: options.config,\n            loglevel: options.loglevel,\n            clearscreen: options.clearscreen,\n            build: buildoptions\n        })\n    } catch (e) {\n        createlogger(options.loglevel).error(\n            chalk.red(`error during build:\\n${e.stack}`), {\n                error: e\n            }\n        )\n        process.exit(1)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n这里调用了异步方法 build 来打包项目。这个命令的主要作用是：项目打包。\n\n * vite optimize: 依赖优化\n\naction 部分的处理：\n\nasync (root: string, options: {\n    force ? : boolean\n} & globalclioptions) => {\n    const {\n        optimizedeps\n    } = await import('./optimizer')\n    try {\n        // 处理 config\n        const config = await resolveconfig({\n                root,\n                base: options.base,\n                configfile: options.config,\n                loglevel: options.loglevel\n            },\n            'build',\n            'development'\n        )\n        // 优化依赖项\n        await optimizedeps(config, options.force, true)\n    } catch (e) {\n        createlogger(options.loglevel).error(\n            chalk.red(`error when optimizing deps:\\n${e.stack}`), {\n                error: e\n            }\n        )\n        process.exit(1)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nvite 会对项目的依赖关系进行缓存，此命名可重建依赖缓存。\n\n * vite preview: production 模式的预览\n\naction 部分的处理：\n\nasync (\n    root: string,\n    options: {\n        host ? : string | boolean\n        port ? : number\n        https ? : boolean\n        open ? : boolean | string\n        strictport ? : boolean\n    } & globalclioptions\n) => {\n    // 模拟 server 以 builddir 为静态目录 serve 资源\n    try {\n        const server = await preview({\n            root,\n            base: options.base,\n            configfile: options.config,\n            loglevel: options.loglevel,\n            preview: {\n                port: options.port,\n                strictport: options.strictport,\n                host: options.host,\n                https: options.https,\n                open: options.open\n            }\n        })\n        server.printurls()\n    } catch (e) {\n        createlogger(options.loglevel).error(\n            chalk.red(`error when starting preview server:\\n${e.stack}`), {\n                error: e\n            }\n        )\n        process.exit(1)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n这部分模拟真实的服务器对打包的资源提供服务，预览 dist 在真实 server 环境下的表现。\n\n 3. cli.help(): display help message when -h or --help appears.\n 4. cli.version(): display version number when -v or --version appears.\n 5. cli.parse(): parse cli args.\n\n\n# 相关工具库\n\n * cacjs/cac:simple yet powerful framework for building command-line apps.\n * chalk/chalk: terminal string styling done right.",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"server： dev server 的创建",frontmatter:{title:"server： dev server 的创建",date:"2022-04-14T22:02:21.000Z",permalink:"/vite/core/server/",categories:["vite","vite"],tags:[null]},regularPath:"/30.web/10.vite%E6%BA%90%E7%A0%81/20.vite/20.server.html",relativePath:"30.web/10.vite源码/20.vite/20.server.md",key:"v-18766245",path:"/vite/core/server/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"createServer",slug:"createserver",normalizedTitle:"createserver",charIndex:17}],readingTime:{text:"1 min read",minutes:.095,time:5700,words:19},headersStr:"目录 createServer",content:"# 目录\n\n\n\n * 目录\n * createServer\n\n\n\n\n# createServer\n\n源码路径：packages/vite/src/node/server/index.ts\n\n从 cli 中，我们已经知道 vite dev 命令主要是 createServer 来处理的。那么 dev server 具体的创建过程是怎么样的呢？",normalizedContent:"# 目录\n\n\n\n * 目录\n * createserver\n\n\n\n\n# createserver\n\n源码路径：packages/vite/src/node/server/index.ts\n\n从 cli 中，我们已经知道 vite dev 命令主要是 createserver 来处理的。那么 dev server 具体的创建过程是怎么样的呢？",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-25T10:24:16.000Z",permalink:"/express/index/",categories:["express"],tags:[null]},regularPath:"/30.web/160.express/0.index.html",relativePath:"30.web/160.express/0.index.md",key:"v-53f20ec6",path:"/express/index/",headers:[{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2}],excerpt:"",readingTime:{text:"1 min read",minutes:.065,time:3900.0000000000005,words:13},headersStr:"参考",content:"# 参考\n\n * Node.js API 文档\n * Node.js v18.0.0 Documentation",normalizedContent:"# 参考\n\n * node.js api 文档\n * node.js v18.0.0 documentation",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-26T11:33:53.000Z",permalink:"/acorn/index/",categories:["acorn源码"],tags:[null]},regularPath:"/30.web/170.acorn%E6%BA%90%E7%A0%81/0.index.html",relativePath:"30.web/170.acorn源码/0.index.md",key:"v-4bc33869",path:"/acorn/index/",headers:[{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2}],readingTime:{text:"1 min read",minutes:.05,time:3e3,words:10},headersStr:"参考",content:"# 参考\n\n * estree/estree: The ESTree Spec\n * AST explorer",normalizedContent:"# 参考\n\n * estree/estree: the estree spec\n * ast explorer",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"开始阅读",frontmatter:{title:"开始阅读",date:"2022-04-29T10:32:57.000Z",permalink:"/immutable/index/",categories:["web","immutable.js源码"],tags:[null]},regularPath:"/30.web/180.immutable.js%E6%BA%90%E7%A0%81/0.index.html",relativePath:"30.web/180.immutable.js源码/0.index.md",key:"v-687541db",path:"/immutable/index/",headers:[{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2}],readingTime:{text:"1 min read",minutes:.095,time:5700,words:19},headersStr:"参考",content:"# 参考\n\n * Immutable.js 及在 React 中的应用\n * Immutable.js\n * immutable-js/immutable-js: Immutable persistent data collections for Javascript which increase efficiency and simplicity.",normalizedContent:"# 参考\n\n * immutable.js 及在 react 中的应用\n * immutable.js\n * immutable-js/immutable-js: immutable persistent data collections for javascript which increase efficiency and simplicity.",charsets:{cjk:!0},lastUpdated:"2022/05/01, 10:17:14",lastUpdatedTimestamp:1651371434e3},{title:"开始阅读",frontmatter:{title:"开始阅读",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/index/",categories:["typescript-utility"],tags:[null]},regularPath:"/30.web/4.typescript-utility/0.index.html",relativePath:"30.web/4.typescript-utility/0.index.md",key:"v-6414adc6",path:"/ts/index/",readingTime:{text:"0 min read",minutes:0,time:0,words:0},headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"本章概要",frontmatter:{title:"本章概要",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/basic/index/",categories:["typescript-utility","basic"],tags:[null]},regularPath:"/30.web/4.typescript-utility/10.%E5%9F%BA%E7%A1%80/0.index.html",relativePath:"30.web/4.typescript-utility/10.基础/0.index.md",key:"v-2985970b",path:"/ts/basic/index/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:17},{level:2,title:"链接",slug:"链接",normalizedTitle:"链接",charIndex:23}],readingTime:{text:"1 min read",minutes:.095,time:5700,words:19},headersStr:"目录 说明 链接",content:"# 目录\n\n\n\n * 目录\n * 说明\n * 链接\n\n\n\n\n# 说明\n\nTypescript 基础主要关注 typescript 官网文档中的基础知识，这是学习后面的 typescript utility 的基础。\n\n\n# 链接\n\n * Typescript 官方文档",normalizedContent:"# 目录\n\n\n\n * 目录\n * 说明\n * 链接\n\n\n\n\n# 说明\n\ntypescript 基础主要关注 typescript 官网文档中的基础知识，这是学习后面的 typescript utility 的基础。\n\n\n# 链接\n\n * typescript 官方文档",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"basic-types 基础类型",frontmatter:{title:"basic-types 基础类型",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/basic/basic-types/",categories:["typescript-utility","basic"],tags:[null]},regularPath:"/30.web/4.typescript-utility/10.%E5%9F%BA%E7%A1%80/10.basic-types.html",relativePath:"30.web/4.typescript-utility/10.基础/10.basic-types.md",key:"v-aef55d32",path:"/ts/basic/basic-types/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"The Basics",slug:"the-basics",normalizedTitle:"the basics",charIndex:17},{level:2,title:"Everyday Types 日常类型",slug:"everyday-types-日常类型",normalizedTitle:"everyday types 日常类型",charIndex:31},{level:2,title:"Narrowing 缩小范围",slug:"narrowing-缩小范围",normalizedTitle:"narrowing 缩小范围",charIndex:54},{level:2,title:"More on Functions",slug:"more-on-functions",normalizedTitle:"more on functions",charIndex:72},{level:2,title:"Object Types 对象类型",slug:"object-types-对象类型",normalizedTitle:"object types 对象类型",charIndex:93},{level:2,title:"modules 模块",slug:"modules-模块",normalizedTitle:"modules 模块",charIndex:114},{level:3,title:"Non-modules 非模块",slug:"non-modules-非模块",normalizedTitle:"non-modules 非模块",charIndex:130},{level:3,title:"CommonJS and ES Modules interop 和 ES 模块互操作",slug:"commonjs-and-es-modules-interop-和-es-模块互操作",normalizedTitle:"commonjs and es modules interop 和 es 模块互操作",charIndex:151}],readingTime:{text:"13 min read",minutes:12.14,time:728400.0000000001,words:2428},headersStr:"目录 The Basics Everyday Types 日常类型 Narrowing 缩小范围 More on Functions Object Types 对象类型 modules 模块 Non-modules 非模块 CommonJS and ES Modules interop 和 ES 模块互操作",content:'# 目录\n\n\n\n * 目录\n * The Basics\n * Everyday Types 日常类型\n * Narrowing 缩小范围\n * More on Functions\n * Object Types 对象类型\n * modules 模块\n   * Non-modules 非模块\n   * CommonJS and ES Modules interop 和 ES 模块互操作\n\n\n\n\n# The Basics\n\n * Static type-checking 静态类型检查\n\nStatic types systems describe the shapes and behaviors of what our values will be when we run our programs. A type-checker like TypeScript uses that information and tells us when things might be going off the rails. 静态类型系统描述了当我们运行程序时我们的值的形状和行为。类似于打字稿的类型检查器使用这些信息，并告诉我们什么时候可能会出问题。\n\n * Non-exception Failures 无异常错误\n\nA static type system has to make the call over what code should be flagged as an error in its system, even if it’s “valid” JavaScript that won’t immediately throw an error. 静态类型系统必须调用系统中应该标记为错误的代码，即使它是 “有效的” JavaScript，不会立即抛出错误。\n\n * Types for Tooling 类型工具\n\nThe type-checker has information to check things like whether we’re accessing the right properties on variables and other properties. Once it has that information, it can also start suggesting which properties you might want to use. 类型检查器有信息来检查我们是否正在访问变量和其他属性的正确属性。一旦它有了这些信息，它还可以开始建议您可能想要使用哪些属性。\n\n * tsc, the TypeScript compiler 编译器\n\n * Explicit Types 显式类型\n\n * Erased Types 被擦除的类型\n\nType annotations aren’t part of JavaScript (or ECMAScript to be pedantic), so there really aren’t any browsers or other runtimes that can just run TypeScript unmodified. That’s why TypeScript needs a compiler in the first place - it needs some way to strip out or transform any TypeScript-specific code so that you can run it. 类型注释不是 JavaScript 的一部分 (或者说 ECMAScript 是迂腐的) ，所以真的没有任何浏览器或者其他运行时可以不经修改就运行打字稿。这就是为什么打字稿首先需要一个编译器 —— 它需要某种方法去掉或转换任何特定于打字稿的代码，以便您可以运行它。\n\n * Downleveling 下调水平\n\nTypeScript has the ability to rewrite code from newer versions of ECMAScript to older ones such as ECMAScript 3 or ECMAScript 5 (a.k.a. ES3 and ES5). This process of moving from a newer or “higher” version of ECMAScript down to an older or “lower” one is sometimes called downleveling. 打字稿能够将新版本的 ECMAScript 代码重写到旧版本，如 ECMAScript 3 或 ECMAScript 5 (又名 es3 和 ES5)。从一个更新的或者 “更高” 的 ECMAScript 版本下降到一个更旧的或者 “更低” 的过程有时被称为下调。\n\nBy default TypeScript targets ES3, an extremely old version of ECMAScript. We could have chosen something a little bit more recent by using the target option. Running with --target es2015 changes TypeScript to target ECMAScript 2015, meaning code should be able to run wherever ECMAScript 2015 is supported. 默认情况下，打字稿的目标是 ES3，一个非常老的 ECMAScript 版本。通过使用 target 选项，我们可以选择一些更新的内容。使用 -- target es2015 将打字稿更改为针对 ECMAScript 2015，这意味着代码应该能够在支持 ECMAScript 2015 的任何地方运行。\n\nWhile the default target is ES3, the great majority of current browsers support ES2015. Most developers can therefore safely specify ES2015 or above as a target, unless compatibility with certain ancient browsers is important. 虽然默认的目标是 ES3，但是大多数当前的浏览器都支持 ES2015。因此，大多数开发人员可以安全地将 es2015 或以上指定为目标，除非与某些古老浏览器的兼容性很重要。\n\n * Strictness 严格\n\nIn contrast, a lot of users prefer to have TypeScript validate as much as it can straight away, and that’s why the language provides strictness settings as well. These strictness settings turn static type-checking from a switch (either your code is checked or not) into something closer to a dial. The further you turn this dial up, the more TypeScript will check for you. This can require a little extra work, but generally speaking it pays for itself in the long run, and enables more thorough checks and more accurate tooling. When possible, a new codebase should always turn these strictness checks on. 相比之下，很多用户更喜欢让 TypeScript 尽可能直接地进行验证，这就是为什么该语言也提供了严格的设置。这些严格的设置将静态类型检查从开关 (无论您的代码是否被检查) 转变为更接近于刻度盘的设置。你拨号拨得越远，越多的打字稿会为你检查。这可能需要一些额外的工作，但一般来说，从长远来看，这样做是值得的，并且可以进行更彻底的检查和更精确的工具。如果可能的话，一个新的代码库应该总是启用这些严格的检查。\n\nThe strict flag in the CLI, or "strict": true in a tsconfig.json toggles them all on simultaneously, but we can opt out of them individually. The two biggest ones you should know about are noImplicitAny and strictNullChecks. CLI 中的严格标志，或者说 “strict”: 在 tsconfig.json 中为 true，可以同时开启所有选项，但是我们可以单独选择退出。你应该知道的两个最重要的检查是 noImplicitAny 和 strictnullcheck。\n\n\n# Everyday Types 日常类型\n\n * The primitives: string,number, and boolean\n * Arrays 数组\n * any\n * Functions\n * Anonymous Functions 匿名函数\n * Object Types 对象类型\n * Optional Properties 可选属性\n * Union Types 合并类型\n * Type Aliases 类型别名\n * Interfaces 接口\n * Type Assertions 类型断言\n\nTypeScript only allows type assertions which convert to a more specific or less specific version of a type. 打字稿只允许类型断言转换为更具体或更不具体的类型版本。\n\nSometimes this rule can be too conservative and will disallow more complex coercions that might be valid. If this happens, you can use two assertions, first to any (or unknown, which we’ll introduce later), then to the desired type. 有时这个规则可能过于保守，不允许更复杂的有效强制。如果出现这种情况，您可以使用两个断言，首先是针对 any (或者我们将在后面介绍的 unknown) ，然后是所需的类型。\n\n * Literal Types 文字类型\n * Literal Inference 字面推理\n\nThe as const suffix acts like const but for the type system, ensuring that all properties are assigned the literal type instead of a more general version like string or number. As const 后缀的作用类似于 const，但是对于类型系统，确保所有属性都被分配为文本类型，而不是字符串或数字之类的更一般的版本。\n\n * null and undefined\n * Enums\n * Less Common Primitives technique 不太常见的原语：bigint、symbol\n\n\n# Narrowing 缩小范围\n\n * typeof type guards\n\n"string"、"number"、"bigint"、"boolean"、"symbol"、"undefined"、"object"、"function"\n\n * Truthiness narrowing\n * Equality narrowing\n * The in operator narrowing\n * instanceof narrowing\n * Assignments 工作分配\n * Control flow analysis 控制流分析\n * Using type predicates 使用类型谓词\n\nA predicate takes the form parameterName is Type, where parameterName must be the name of a parameter from the current function signature. 谓词接受表单 parameterName is Type，其中 parameterName 必须是来自当前函数签名的参数的名称。\n\nclasses can use this is Type to narrow their type. 此外，类可以使用 this is Type 来缩小它们的类型。\n\n * Discriminated unions 消除联合类型\n\n * The never type\n\nWhen narrowing, you can reduce the options of a union to a point where you have removed all possibilities and have nothing left. In those cases, TypeScript will use a never type to represent a state which shouldn’t exist. 当缩小范围时，您可以将联合的选项减少到删除了所有的可能性并且没有剩余的选项。在这些情况下，TypeScript 将使用一个 never 类型来表示一个不应该存在的状态。\n\n * Exhaustiveness checking 彻底检查\n\nThe never type is assignable to every type; however, no type is assignable to never (except never itself). This means you can use narrowing and rely on never turning up to do exhaustive checking in a switch statement. Never 类型可以分配给每个类型；但是，没有任何类型可以分配给 never (除了它本身)。这意味着您可以在 switch 语句中使用收缩，并依赖于永远不会进行详尽的检查。\n\n\n# More on Functions\n\n * Function Type Expressions 函数类型表达式\n * Call Signatures 调用签名\n\nIn JavaScript, functions can have properties in addition to being callable. However, the function type expression syntax doesn’t allow for declaring properties. If we want to describe something callable with properties, we can write a call signature in an object type. 在 JavaScript 中，函数除了可调用之外，还可以具有属性。但是，函数类型表达式语法不允许声明属性。如果我们想用属性来描述可调用的东西，我们可以用对象类型来写一个调用签名.\n\ntype DescribableFunction = {\n  description: string;\n  (someArg: number): boolean;\n};\nfunction doSomething(fn: DescribableFunction) {\n  console.log(fn.description + " returned " + fn(6));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * Construct Signatures 构造签名\n\nJavaScript functions can also be invoked with the new operator. TypeScript refers to these as constructors because they usually create a new object. You can write a construct signature by adding the new keyword in front of a call signature: 函数也可以用新的操作符来调用。引用这些作为构造函数，因为它们通常会创建一个新对象。你可以通过在调用签名前面添加 new 关键字来写一个构造签名:\n\ntype SomeConstructor = {\n  new (s: string): SomeObject;\n};\nfunction fn(ctor: SomeConstructor) {\n  return new ctor("hello");\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nSome objects, like JavaScript’s Date object, can be called with or without new. You can combine call and construct signatures in the same type arbitrarily: 有些对象，比如 JavaScript 的 Date 对象，可以使用或不使用 new 来调用。您可以任意组合调用和构造同一类型的签名:\n\ninterface CallOrConstruct {\n  new (s: string): Date;\n  (n?: number): number;\n}\n\n\n1\n2\n3\n4\n\n * Generic Functions 泛型函数\n\nIn TypeScript, generics are used when we want to describe a correspondence between two values. 在 TypeScript 中，泛型用于描述两个值之间的对应关系。\n\n * Inference 推断\n * Constraints 约束\n\nSometimes we want to relate two values, but can only operate on a certain subset of values. In this case, we can use a constraint to limit the kinds of types that a type parameter can accept. 有时候我们想要关联两个值，但是只能对值的某个子集进行操作。在这种情况下，我们可以使用约束来限制类型参数可以接受的类型种类。\n\nfunction longest<Type extends { length: number }>(a: Type, b: Type) {\n  if (a.length >= b.length) {\n    return a;\n  } else {\n    return b;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n * Working with Constrained Values 使用约束值\n\n * Specifying Type Arguments 指定类型参数\n\n * Guidelines for Writing Good Generic Functions 编写良好通用函数的指南\n\nPush Type Parameters Down 下推类型参数\n\nRule: When possible, use the type parameter itself rather than constraining it 规则：如果可能的话，使用类型参数本身而不是约束它\n\nUse Fewer Type Parameters 使用更少的类型参数\n\nRule: Always use as few type parameters as possible 规则：总是使用尽可能少的类型参数\n\nType Parameters Should Appear Twice 类型参数应该出现两次\n\nRule: If a type parameter only appears in one location, strongly reconsider if you actually need it 规则：如果一个类型参数只出现在一个位置，请强烈重新考虑是否实际需要它\n\n * Optional Parameters 可选参数\n\n * Function Overloads 函数重载\n\nIn TypeScript, we can specify a function that can be called in different ways by writing overload signatures. To do this, write some number of function signatures (usually two or more), followed by the body of the function: 在打字稿中，我们可以通过写重载签名来指定一个可以以不同方式调用的函数。要做到这一点，写一些函数签名 (通常是两个或更多) ，后面跟着函数体:\n\nfunction makeDate(timestamp: number): Date;\nfunction makeDate(m: number, d: number, y: number): Date;\nfunction makeDate(mOrTimestamp: number, d?: number, y?: number): Date {\n  if (d !== undefined && y !== undefined) {\n    return new Date(y, mOrTimestamp, d);\n  } else {\n    return new Date(mOrTimestamp);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * Writing Good Overloads 写好重载\n\nAlways prefer parameters with union types instead of overloads when possible 如果可能的话，总是倾向于使用联合类型的参数，而不是重载\n\n * Other Types to Know About 其他需要了解的类型\n\nvoid：\n\nIn JavaScript, a function that doesn’t return any value will implicitly return the value undefined. However, void and undefined are not the same thing in TypeScript. 在 JavaScript 中，不返回任何值的函数将隐式返回未定义的值。然而，void 和 undefined 在打字稿中并不是一回事。\n\nobject：\n\nThe special type object refers to any value that isn’t a primitive (string, number, bigint, boolean, symbol, null, or undefined). This is different from the empty object type { }, and also different from the global type Object. It’s very likely you will never use Object. 特殊类型对象引用任何不是基元的值 (string、 number、 bigint、 boolean、 symbol、 null 或 undefined)。这不同于空对象类型 {} ，也不同于全局类型 Object。很有可能你永远不会使用 Object。\n\nobject is not Object. Always use object! 对象不是对象。始终使用对象！\n\nunknown：\n\nThe unknown type represents any value. This is similar to the any type, but is safer because it’s not legal to do anything with an unknown value. 未知类型表示任何值。这类似于任何类型，但是更安全，因为任何未知值都是不合法的。\n\nnever：\n\nThe never type represents values which are never observed. In a return type, this means that the function throws an exception or terminates execution of the program. Never 类型表示从未观察到的值。在返回类型中，这意味着函数抛出异常或终止程序的执行。\n\nnever also appears when TypeScript determines there’s nothing left in a union. 当打字稿确定工会中没有剩余的内容时，也不会出现。\n\nFunction：\n\nThe global type Function describes properties like bind, call, apply, and others present on all function values in JavaScript. It also has the special property that values of type Function can always be called; these calls return any. 全局类型 Function 描述了类似 bind、 call、 apply 等属性，这些属性出现在 JavaScript 中的所有函数值上。它还有一个特殊属性，即 Function 类型的值总是可以被调用；这些调用返回任何。\n\nThis is an untyped function call and is generally best avoided because of the unsafe any return type. 这是一个非类型化的函数调用，通常最好避免这种情况，因为任何返回类型都是不安全的。\n\nIf you need to accept an arbitrary function but don’t intend to call it, the type () => void is generally safer. 如果您需要接受一个任意函数，但不打算调用它，那么 type () => void 通常更安全。\n\n * Rest Parameters and Arguments\n\n * Parameter Destructuring 参数析构\n\nAssignability of Functions 函数的可转让性\n\nReturn type void:\n\nContextual typing with a return type of void does not force functions to not return something. Another way to say this is a contextual function type with a void return type (type vf = () => void), when implemented, can return any other value, but it will be ignored. 返回类型为 void 的上下文类型不会强制函数不返回某些内容。另一种方法是使用 void 返回类型 (type vf = () = > void) 的上下文函数类型，实现后可以返回任何其他值，但是它将被忽略。\n\nAnd when the return value of one of these functions is assigned to another variable, it will retain the type of void. 当其中一个函数的返回值被赋给另一个变量时，它将保留 void 类型。\n\nThere is one other special case to be aware of, when a literal function definition has a void return type, that function must not return anything. 还有另外一个需要注意的特殊情况，当文本函数定义具有 void 返回类型时，该函数不能返回任何内容。\n\n\n# Object Types 对象类型\n\n * Property Modifiers 属性修饰符\n\n * Optional Properties 可选属性\n\nNote that there is currently no way to place type annotations within destructuring patterns. This is because the following syntax already means something different in JavaScript. 请注意，目前没有将类型注释放置在析构化模式中的方法。这是因为下面的语法在 JavaScript 中已经有了不同的含义。\n\n * readonly Properties\n\nProperties can also be marked as readonly for TypeScript. While it won’t change any behavior at runtime, a property marked as readonly can’t be written to during type-checking. 属性也可以标记为 TypeScript 的只读属性。虽然它不会在运行时改变任何行为，但是在类型检查期间不能写入标记为 readonly 的属性。\n\nUsing the readonly modifier doesn’t necessarily imply that a value is totally immutable - or in other words, that its internal contents can’t be changed. It just means the property itself can’t be re-written to. 使用 readonly 修饰符并不一定意味着一个值是完全不可变的，或者换句话说，它的内部内容不能被更改。这只是意味着财产本身不能被重写。\n\n * Index Signatures 索引签名\n\nAn index signature property type must be either ‘string’ or ‘number’. 索引签名属性类型必须是 “string” 或 “ number”。\n\nWhile string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type. This is because a string index declares that obj.property is also available as obj["property"] . 虽然字符串索引签名是描述 “字典” 模式的一种强大方式，但是它们也要求所有属性都匹配它们的返回类型。这是因为字符串索引声明 obj.property 也可以作为 obj [“ property”] 使用。\n\nyou can make index signatures readonly in order to prevent assignment to their indices. 您可以使索引签名只读，以防止分配给他们的索引。\n\ninterface ReadonlyStringArray {\n  readonly [index: number]: string;\n}\n\n\n1\n2\n3\n\n\n * Extending Types 扩展类型\n\n * Intersection Types 交叉类型\n\n * Interfaces vs. Intersections\n\nWe just looked at two ways to combine types which are similar, but are actually subtly different. With interfaces, we could use an extends clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias. The principle difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why you’d pick one over the other between an interface and a type alias of an intersection type. 我们刚刚研究了两种组合类型的方法，这两种类型相似，但实际上略有不同。对于接口，我们可以使用 extends 子句从其他类型进行扩展，而且我们可以对交叉点进行类似的操作，并使用类型别名命名结果。两者之间的主要区别在于如何处理冲突，这种区别通常是在接口和交集类型的类型别名之间选择一个而不是另一个的主要原因之一。\n\n * Generic Object Types 泛型对象类型\n\n * The Array Type\n\n * The ReadonlyArray Type\n\nThe ReadonlyArray is a special type that describes arrays that shouldn’t be changed. ReadonlyArray 是一种特殊类型，用于描述不应该更改的数组。\n\nMuch like the readonly modifier for properties, it’s mainly a tool we can use for intent. When we see a function that returns ReadonlyArrays, it tells us we’re not meant to change the contents at all, and when we see a function that consumes ReadonlyArrays, it tells us that we can pass any array into that function without worrying that it will change its contents. 很像属性的 readonly 修饰符，它主要是一个我们可以使用的工具意图。当我们看到一个函数返回 ReadonlyArrays 时，它告诉我们，我们根本不打算改变内容，当我们看到一个函数使用 ReadonlyArrays 时，它告诉我们，我们可以将任何数组传递到该函数，而不用担心它会改变其内容。\n\nJust as TypeScript provides a shorthand syntax for Array<Type> with Type[], it also provides a shorthand syntax for ReadonlyArray<Type> with readonly Type[]. 正如 TypeScript 为 Array <Type> 提供了一种简化语法，使用 Type [] ，它也为 ReadonlyArray < Type > 提供了一种简化语法，使用 readonly Type []。\n\n * Tuple Types 元组类型\n\nA tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions. Tuple 类型是另一种 Array 类型，它确切地知道它包含多少个元素，以及它在特定位置包含哪些类型。\n\nAnother thing you may be interested in is that tuples can have optional properties by writing out a question mark (? after an element’s type). Optional tuple elements can only come at the end, and also affect the type of length. 您可能感兴趣的另一件事是，通过写出一个问号 (？在元素的类型之后)。可选的 tuple 元素只能出现在结尾，并且还会影响长度的类型。\n\nTuples can also have rest elements, which have to be an array/tuple type. 元组还可以有 rest 元素，这些元素必须是数组 / 元组类型。\n\ntype Either2dOr3d = [number, number, number?];\ntype StringNumberBooleans = [string, number, ...boolean[]];\ntype StringBooleansNumber = [string, ...boolean[], number];\ntype BooleansStringNumber = [...boolean[], string, number];\n\n\n1\n2\n3\n4\n\n\nA tuple with a rest element has no set “length” - it only has a set of well-known elements in different positions. 带有 rest 元素的 tuple 没有设置 “长度”—— 它只有一组位于不同位置的已知元素。\n\n * readonly Tuple Types 元组类型\n\n\n# modules 模块\n\n\n# Non-modules 非模块\n\nThe JavaScript specification declares that any JavaScript files without an export or top-level await should be considered a script and not a module. JavaScript 规范声明，任何没有导出或顶级等待的 JavaScript 文件都应该被视为脚本，而不是模块。\n\n\n# CommonJS and ES Modules interop 和 ES 模块互操作\n\nThere is a mis-match in features between CommonJS and ES Modules regarding the distinction between a default import and a module namespace object import. TypeScript has a compiler flag to reduce the friction between the two different sets of constraints with esModuleInterop.\n\n关于默认导入和模块名称空间对象导入之间的区别，CommonJS 和 ES Modules 之间的特性不匹配。TypeScript 有一个编译器标志，以减少 esModuleInterop 中两组不同约束之间的摩擦。',normalizedContent:'# 目录\n\n\n\n * 目录\n * the basics\n * everyday types 日常类型\n * narrowing 缩小范围\n * more on functions\n * object types 对象类型\n * modules 模块\n   * non-modules 非模块\n   * commonjs and es modules interop 和 es 模块互操作\n\n\n\n\n# the basics\n\n * static type-checking 静态类型检查\n\nstatic types systems describe the shapes and behaviors of what our values will be when we run our programs. a type-checker like typescript uses that information and tells us when things might be going off the rails. 静态类型系统描述了当我们运行程序时我们的值的形状和行为。类似于打字稿的类型检查器使用这些信息，并告诉我们什么时候可能会出问题。\n\n * non-exception failures 无异常错误\n\na static type system has to make the call over what code should be flagged as an error in its system, even if it’s “valid” javascript that won’t immediately throw an error. 静态类型系统必须调用系统中应该标记为错误的代码，即使它是 “有效的” javascript，不会立即抛出错误。\n\n * types for tooling 类型工具\n\nthe type-checker has information to check things like whether we’re accessing the right properties on variables and other properties. once it has that information, it can also start suggesting which properties you might want to use. 类型检查器有信息来检查我们是否正在访问变量和其他属性的正确属性。一旦它有了这些信息，它还可以开始建议您可能想要使用哪些属性。\n\n * tsc, the typescript compiler 编译器\n\n * explicit types 显式类型\n\n * erased types 被擦除的类型\n\ntype annotations aren’t part of javascript (or ecmascript to be pedantic), so there really aren’t any browsers or other runtimes that can just run typescript unmodified. that’s why typescript needs a compiler in the first place - it needs some way to strip out or transform any typescript-specific code so that you can run it. 类型注释不是 javascript 的一部分 (或者说 ecmascript 是迂腐的) ，所以真的没有任何浏览器或者其他运行时可以不经修改就运行打字稿。这就是为什么打字稿首先需要一个编译器 —— 它需要某种方法去掉或转换任何特定于打字稿的代码，以便您可以运行它。\n\n * downleveling 下调水平\n\ntypescript has the ability to rewrite code from newer versions of ecmascript to older ones such as ecmascript 3 or ecmascript 5 (a.k.a. es3 and es5). this process of moving from a newer or “higher” version of ecmascript down to an older or “lower” one is sometimes called downleveling. 打字稿能够将新版本的 ecmascript 代码重写到旧版本，如 ecmascript 3 或 ecmascript 5 (又名 es3 和 es5)。从一个更新的或者 “更高” 的 ecmascript 版本下降到一个更旧的或者 “更低” 的过程有时被称为下调。\n\nby default typescript targets es3, an extremely old version of ecmascript. we could have chosen something a little bit more recent by using the target option. running with --target es2015 changes typescript to target ecmascript 2015, meaning code should be able to run wherever ecmascript 2015 is supported. 默认情况下，打字稿的目标是 es3，一个非常老的 ecmascript 版本。通过使用 target 选项，我们可以选择一些更新的内容。使用 -- target es2015 将打字稿更改为针对 ecmascript 2015，这意味着代码应该能够在支持 ecmascript 2015 的任何地方运行。\n\nwhile the default target is es3, the great majority of current browsers support es2015. most developers can therefore safely specify es2015 or above as a target, unless compatibility with certain ancient browsers is important. 虽然默认的目标是 es3，但是大多数当前的浏览器都支持 es2015。因此，大多数开发人员可以安全地将 es2015 或以上指定为目标，除非与某些古老浏览器的兼容性很重要。\n\n * strictness 严格\n\nin contrast, a lot of users prefer to have typescript validate as much as it can straight away, and that’s why the language provides strictness settings as well. these strictness settings turn static type-checking from a switch (either your code is checked or not) into something closer to a dial. the further you turn this dial up, the more typescript will check for you. this can require a little extra work, but generally speaking it pays for itself in the long run, and enables more thorough checks and more accurate tooling. when possible, a new codebase should always turn these strictness checks on. 相比之下，很多用户更喜欢让 typescript 尽可能直接地进行验证，这就是为什么该语言也提供了严格的设置。这些严格的设置将静态类型检查从开关 (无论您的代码是否被检查) 转变为更接近于刻度盘的设置。你拨号拨得越远，越多的打字稿会为你检查。这可能需要一些额外的工作，但一般来说，从长远来看，这样做是值得的，并且可以进行更彻底的检查和更精确的工具。如果可能的话，一个新的代码库应该总是启用这些严格的检查。\n\nthe strict flag in the cli, or "strict": true in a tsconfig.json toggles them all on simultaneously, but we can opt out of them individually. the two biggest ones you should know about are noimplicitany and strictnullchecks. cli 中的严格标志，或者说 “strict”: 在 tsconfig.json 中为 true，可以同时开启所有选项，但是我们可以单独选择退出。你应该知道的两个最重要的检查是 noimplicitany 和 strictnullcheck。\n\n\n# everyday types 日常类型\n\n * the primitives: string,number, and boolean\n * arrays 数组\n * any\n * functions\n * anonymous functions 匿名函数\n * object types 对象类型\n * optional properties 可选属性\n * union types 合并类型\n * type aliases 类型别名\n * interfaces 接口\n * type assertions 类型断言\n\ntypescript only allows type assertions which convert to a more specific or less specific version of a type. 打字稿只允许类型断言转换为更具体或更不具体的类型版本。\n\nsometimes this rule can be too conservative and will disallow more complex coercions that might be valid. if this happens, you can use two assertions, first to any (or unknown, which we’ll introduce later), then to the desired type. 有时这个规则可能过于保守，不允许更复杂的有效强制。如果出现这种情况，您可以使用两个断言，首先是针对 any (或者我们将在后面介绍的 unknown) ，然后是所需的类型。\n\n * literal types 文字类型\n * literal inference 字面推理\n\nthe as const suffix acts like const but for the type system, ensuring that all properties are assigned the literal type instead of a more general version like string or number. as const 后缀的作用类似于 const，但是对于类型系统，确保所有属性都被分配为文本类型，而不是字符串或数字之类的更一般的版本。\n\n * null and undefined\n * enums\n * less common primitives technique 不太常见的原语：bigint、symbol\n\n\n# narrowing 缩小范围\n\n * typeof type guards\n\n"string"、"number"、"bigint"、"boolean"、"symbol"、"undefined"、"object"、"function"\n\n * truthiness narrowing\n * equality narrowing\n * the in operator narrowing\n * instanceof narrowing\n * assignments 工作分配\n * control flow analysis 控制流分析\n * using type predicates 使用类型谓词\n\na predicate takes the form parametername is type, where parametername must be the name of a parameter from the current function signature. 谓词接受表单 parametername is type，其中 parametername 必须是来自当前函数签名的参数的名称。\n\nclasses can use this is type to narrow their type. 此外，类可以使用 this is type 来缩小它们的类型。\n\n * discriminated unions 消除联合类型\n\n * the never type\n\nwhen narrowing, you can reduce the options of a union to a point where you have removed all possibilities and have nothing left. in those cases, typescript will use a never type to represent a state which shouldn’t exist. 当缩小范围时，您可以将联合的选项减少到删除了所有的可能性并且没有剩余的选项。在这些情况下，typescript 将使用一个 never 类型来表示一个不应该存在的状态。\n\n * exhaustiveness checking 彻底检查\n\nthe never type is assignable to every type; however, no type is assignable to never (except never itself). this means you can use narrowing and rely on never turning up to do exhaustive checking in a switch statement. never 类型可以分配给每个类型；但是，没有任何类型可以分配给 never (除了它本身)。这意味着您可以在 switch 语句中使用收缩，并依赖于永远不会进行详尽的检查。\n\n\n# more on functions\n\n * function type expressions 函数类型表达式\n * call signatures 调用签名\n\nin javascript, functions can have properties in addition to being callable. however, the function type expression syntax doesn’t allow for declaring properties. if we want to describe something callable with properties, we can write a call signature in an object type. 在 javascript 中，函数除了可调用之外，还可以具有属性。但是，函数类型表达式语法不允许声明属性。如果我们想用属性来描述可调用的东西，我们可以用对象类型来写一个调用签名.\n\ntype describablefunction = {\n  description: string;\n  (somearg: number): boolean;\n};\nfunction dosomething(fn: describablefunction) {\n  console.log(fn.description + " returned " + fn(6));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * construct signatures 构造签名\n\njavascript functions can also be invoked with the new operator. typescript refers to these as constructors because they usually create a new object. you can write a construct signature by adding the new keyword in front of a call signature: 函数也可以用新的操作符来调用。引用这些作为构造函数，因为它们通常会创建一个新对象。你可以通过在调用签名前面添加 new 关键字来写一个构造签名:\n\ntype someconstructor = {\n  new (s: string): someobject;\n};\nfunction fn(ctor: someconstructor) {\n  return new ctor("hello");\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nsome objects, like javascript’s date object, can be called with or without new. you can combine call and construct signatures in the same type arbitrarily: 有些对象，比如 javascript 的 date 对象，可以使用或不使用 new 来调用。您可以任意组合调用和构造同一类型的签名:\n\ninterface callorconstruct {\n  new (s: string): date;\n  (n?: number): number;\n}\n\n\n1\n2\n3\n4\n\n * generic functions 泛型函数\n\nin typescript, generics are used when we want to describe a correspondence between two values. 在 typescript 中，泛型用于描述两个值之间的对应关系。\n\n * inference 推断\n * constraints 约束\n\nsometimes we want to relate two values, but can only operate on a certain subset of values. in this case, we can use a constraint to limit the kinds of types that a type parameter can accept. 有时候我们想要关联两个值，但是只能对值的某个子集进行操作。在这种情况下，我们可以使用约束来限制类型参数可以接受的类型种类。\n\nfunction longest<type extends { length: number }>(a: type, b: type) {\n  if (a.length >= b.length) {\n    return a;\n  } else {\n    return b;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n * working with constrained values 使用约束值\n\n * specifying type arguments 指定类型参数\n\n * guidelines for writing good generic functions 编写良好通用函数的指南\n\npush type parameters down 下推类型参数\n\nrule: when possible, use the type parameter itself rather than constraining it 规则：如果可能的话，使用类型参数本身而不是约束它\n\nuse fewer type parameters 使用更少的类型参数\n\nrule: always use as few type parameters as possible 规则：总是使用尽可能少的类型参数\n\ntype parameters should appear twice 类型参数应该出现两次\n\nrule: if a type parameter only appears in one location, strongly reconsider if you actually need it 规则：如果一个类型参数只出现在一个位置，请强烈重新考虑是否实际需要它\n\n * optional parameters 可选参数\n\n * function overloads 函数重载\n\nin typescript, we can specify a function that can be called in different ways by writing overload signatures. to do this, write some number of function signatures (usually two or more), followed by the body of the function: 在打字稿中，我们可以通过写重载签名来指定一个可以以不同方式调用的函数。要做到这一点，写一些函数签名 (通常是两个或更多) ，后面跟着函数体:\n\nfunction makedate(timestamp: number): date;\nfunction makedate(m: number, d: number, y: number): date;\nfunction makedate(mortimestamp: number, d?: number, y?: number): date {\n  if (d !== undefined && y !== undefined) {\n    return new date(y, mortimestamp, d);\n  } else {\n    return new date(mortimestamp);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * writing good overloads 写好重载\n\nalways prefer parameters with union types instead of overloads when possible 如果可能的话，总是倾向于使用联合类型的参数，而不是重载\n\n * other types to know about 其他需要了解的类型\n\nvoid：\n\nin javascript, a function that doesn’t return any value will implicitly return the value undefined. however, void and undefined are not the same thing in typescript. 在 javascript 中，不返回任何值的函数将隐式返回未定义的值。然而，void 和 undefined 在打字稿中并不是一回事。\n\nobject：\n\nthe special type object refers to any value that isn’t a primitive (string, number, bigint, boolean, symbol, null, or undefined). this is different from the empty object type { }, and also different from the global type object. it’s very likely you will never use object. 特殊类型对象引用任何不是基元的值 (string、 number、 bigint、 boolean、 symbol、 null 或 undefined)。这不同于空对象类型 {} ，也不同于全局类型 object。很有可能你永远不会使用 object。\n\nobject is not object. always use object! 对象不是对象。始终使用对象！\n\nunknown：\n\nthe unknown type represents any value. this is similar to the any type, but is safer because it’s not legal to do anything with an unknown value. 未知类型表示任何值。这类似于任何类型，但是更安全，因为任何未知值都是不合法的。\n\nnever：\n\nthe never type represents values which are never observed. in a return type, this means that the function throws an exception or terminates execution of the program. never 类型表示从未观察到的值。在返回类型中，这意味着函数抛出异常或终止程序的执行。\n\nnever also appears when typescript determines there’s nothing left in a union. 当打字稿确定工会中没有剩余的内容时，也不会出现。\n\nfunction：\n\nthe global type function describes properties like bind, call, apply, and others present on all function values in javascript. it also has the special property that values of type function can always be called; these calls return any. 全局类型 function 描述了类似 bind、 call、 apply 等属性，这些属性出现在 javascript 中的所有函数值上。它还有一个特殊属性，即 function 类型的值总是可以被调用；这些调用返回任何。\n\nthis is an untyped function call and is generally best avoided because of the unsafe any return type. 这是一个非类型化的函数调用，通常最好避免这种情况，因为任何返回类型都是不安全的。\n\nif you need to accept an arbitrary function but don’t intend to call it, the type () => void is generally safer. 如果您需要接受一个任意函数，但不打算调用它，那么 type () => void 通常更安全。\n\n * rest parameters and arguments\n\n * parameter destructuring 参数析构\n\nassignability of functions 函数的可转让性\n\nreturn type void:\n\ncontextual typing with a return type of void does not force functions to not return something. another way to say this is a contextual function type with a void return type (type vf = () => void), when implemented, can return any other value, but it will be ignored. 返回类型为 void 的上下文类型不会强制函数不返回某些内容。另一种方法是使用 void 返回类型 (type vf = () = > void) 的上下文函数类型，实现后可以返回任何其他值，但是它将被忽略。\n\nand when the return value of one of these functions is assigned to another variable, it will retain the type of void. 当其中一个函数的返回值被赋给另一个变量时，它将保留 void 类型。\n\nthere is one other special case to be aware of, when a literal function definition has a void return type, that function must not return anything. 还有另外一个需要注意的特殊情况，当文本函数定义具有 void 返回类型时，该函数不能返回任何内容。\n\n\n# object types 对象类型\n\n * property modifiers 属性修饰符\n\n * optional properties 可选属性\n\nnote that there is currently no way to place type annotations within destructuring patterns. this is because the following syntax already means something different in javascript. 请注意，目前没有将类型注释放置在析构化模式中的方法。这是因为下面的语法在 javascript 中已经有了不同的含义。\n\n * readonly properties\n\nproperties can also be marked as readonly for typescript. while it won’t change any behavior at runtime, a property marked as readonly can’t be written to during type-checking. 属性也可以标记为 typescript 的只读属性。虽然它不会在运行时改变任何行为，但是在类型检查期间不能写入标记为 readonly 的属性。\n\nusing the readonly modifier doesn’t necessarily imply that a value is totally immutable - or in other words, that its internal contents can’t be changed. it just means the property itself can’t be re-written to. 使用 readonly 修饰符并不一定意味着一个值是完全不可变的，或者换句话说，它的内部内容不能被更改。这只是意味着财产本身不能被重写。\n\n * index signatures 索引签名\n\nan index signature property type must be either ‘string’ or ‘number’. 索引签名属性类型必须是 “string” 或 “ number”。\n\nwhile string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type. this is because a string index declares that obj.property is also available as obj["property"] . 虽然字符串索引签名是描述 “字典” 模式的一种强大方式，但是它们也要求所有属性都匹配它们的返回类型。这是因为字符串索引声明 obj.property 也可以作为 obj [“ property”] 使用。\n\nyou can make index signatures readonly in order to prevent assignment to their indices. 您可以使索引签名只读，以防止分配给他们的索引。\n\ninterface readonlystringarray {\n  readonly [index: number]: string;\n}\n\n\n1\n2\n3\n\n\n * extending types 扩展类型\n\n * intersection types 交叉类型\n\n * interfaces vs. intersections\n\nwe just looked at two ways to combine types which are similar, but are actually subtly different. with interfaces, we could use an extends clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias. the principle difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why you’d pick one over the other between an interface and a type alias of an intersection type. 我们刚刚研究了两种组合类型的方法，这两种类型相似，但实际上略有不同。对于接口，我们可以使用 extends 子句从其他类型进行扩展，而且我们可以对交叉点进行类似的操作，并使用类型别名命名结果。两者之间的主要区别在于如何处理冲突，这种区别通常是在接口和交集类型的类型别名之间选择一个而不是另一个的主要原因之一。\n\n * generic object types 泛型对象类型\n\n * the array type\n\n * the readonlyarray type\n\nthe readonlyarray is a special type that describes arrays that shouldn’t be changed. readonlyarray 是一种特殊类型，用于描述不应该更改的数组。\n\nmuch like the readonly modifier for properties, it’s mainly a tool we can use for intent. when we see a function that returns readonlyarrays, it tells us we’re not meant to change the contents at all, and when we see a function that consumes readonlyarrays, it tells us that we can pass any array into that function without worrying that it will change its contents. 很像属性的 readonly 修饰符，它主要是一个我们可以使用的工具意图。当我们看到一个函数返回 readonlyarrays 时，它告诉我们，我们根本不打算改变内容，当我们看到一个函数使用 readonlyarrays 时，它告诉我们，我们可以将任何数组传递到该函数，而不用担心它会改变其内容。\n\njust as typescript provides a shorthand syntax for array<type> with type[], it also provides a shorthand syntax for readonlyarray<type> with readonly type[]. 正如 typescript 为 array <type> 提供了一种简化语法，使用 type [] ，它也为 readonlyarray < type > 提供了一种简化语法，使用 readonly type []。\n\n * tuple types 元组类型\n\na tuple type is another sort of array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions. tuple 类型是另一种 array 类型，它确切地知道它包含多少个元素，以及它在特定位置包含哪些类型。\n\nanother thing you may be interested in is that tuples can have optional properties by writing out a question mark (? after an element’s type). optional tuple elements can only come at the end, and also affect the type of length. 您可能感兴趣的另一件事是，通过写出一个问号 (？在元素的类型之后)。可选的 tuple 元素只能出现在结尾，并且还会影响长度的类型。\n\ntuples can also have rest elements, which have to be an array/tuple type. 元组还可以有 rest 元素，这些元素必须是数组 / 元组类型。\n\ntype either2dor3d = [number, number, number?];\ntype stringnumberbooleans = [string, number, ...boolean[]];\ntype stringbooleansnumber = [string, ...boolean[], number];\ntype booleansstringnumber = [...boolean[], string, number];\n\n\n1\n2\n3\n4\n\n\na tuple with a rest element has no set “length” - it only has a set of well-known elements in different positions. 带有 rest 元素的 tuple 没有设置 “长度”—— 它只有一组位于不同位置的已知元素。\n\n * readonly tuple types 元组类型\n\n\n# modules 模块\n\n\n# non-modules 非模块\n\nthe javascript specification declares that any javascript files without an export or top-level await should be considered a script and not a module. javascript 规范声明，任何没有导出或顶级等待的 javascript 文件都应该被视为脚本，而不是模块。\n\n\n# commonjs and es modules interop 和 es 模块互操作\n\nthere is a mis-match in features between commonjs and es modules regarding the distinction between a default import and a module namespace object import. typescript has a compiler flag to reduce the friction between the two different sets of constraints with esmoduleinterop.\n\n关于默认导入和模块名称空间对象导入之间的区别，commonjs 和 es modules 之间的特性不匹配。typescript 有一个编译器标志，以减少 esmoduleinterop 中两组不同约束之间的摩擦。',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"type-manipulation 类型操作",frontmatter:{title:"type-manipulation 类型操作",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/basic/type-manipulation/",categories:["typescript-utility","basic"],tags:[null]},regularPath:"/30.web/4.typescript-utility/10.%E5%9F%BA%E7%A1%80/20.type-manipulation.html",relativePath:"30.web/4.typescript-utility/10.基础/20.type-manipulation.md",key:"v-25439586",path:"/ts/basic/type-manipulation/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"Generics 泛型",slug:"generics-泛型",normalizedTitle:"generics 泛型",charIndex:17},{level:2,title:"Keyof Type Operator 类型操作运算符",slug:"keyof-type-operator-类型操作运算符",normalizedTitle:"keyof type operator 类型操作运算符",charIndex:32},{level:2,title:"Typeof Type Operator",slug:"typeof-type-operator",normalizedTitle:"typeof type operator",charIndex:63},{level:2,title:"Indexed Access Types",slug:"indexed-access-types",normalizedTitle:"indexed access types",charIndex:87},{level:2,title:"Conditional Types 条件类型",slug:"conditional-types-条件类型",normalizedTitle:"conditional types 条件类型",charIndex:111},{level:2,title:"Mapped Types 映射类型",slug:"mapped-types-映射类型",normalizedTitle:"mapped types 映射类型",charIndex:137},{level:2,title:"Template Literal Types 模板文字类型",slug:"template-literal-types-模板文字类型",normalizedTitle:"template literal types 模板文字类型",charIndex:158}],readingTime:{text:"5 min read",minutes:4.84,time:290400,words:968},headersStr:"目录 Generics 泛型 Keyof Type Operator 类型操作运算符 Typeof Type Operator Indexed Access Types Conditional Types 条件类型 Mapped Types 映射类型 Template Literal Types 模板文字类型",content:'# 目录\n\n\n\n * 目录\n * Generics 泛型\n * Keyof Type Operator 类型操作运算符\n * Typeof Type Operator\n * Indexed Access Types\n * Conditional Types 条件类型\n * Mapped Types 映射类型\n * Template Literal Types 模板文字类型\n\n\n\n\n# Generics 泛型\n\n * Generic Types：泛型类型\n\nWe can also write the generic type as a call signature of an object literal type: 我们也可以将泛型类型写作为对象文本类型的调用签名:\n\nfunction identity<Type>(arg: Type): Type {\n  return arg;\n}\n \nlet myIdentity: { <Type>(arg: Type): Type } = identity;\n\n\n1\n2\n3\n4\n5\n\n * Generic Classes: 泛型类\n\nA class has two sides to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class’s type parameter. 类的类型有两个方面：静态方面和实例方面。泛型类只是泛型的实例端而不是静态端，因此在处理类时，静态成员不能使用类的类型参数。\n\n * Generic Constraints: 泛型约束\n\n * Using Type Parameters in Generic Constraints：在泛型约束中使用类型参数\n\n * Using Class Types in Generics：在泛型中使用类类型\n\n\n# Keyof Type Operator 类型操作运算符\n\nIf the type has a string or number index signature, keyof will return those types instead: 如果类型有字符串或数字索引签名，keyof 将返回这些类型:\n\ntype Arrayish = { [n: number]: unknown };\ntype A = keyof Arrayish;\n \ntype Mapish = { [k: string]: boolean };\ntype M = keyof Mapish;\n\n\n1\n2\n3\n4\n5\n\n\n\n# Typeof Type Operator\n\nit’s only legal to use typeof on identifiers (i.e. variable names) or their properties. 使用 typeof on 标识符 (即变量名) 或其属性是合法的\n\n\n# Indexed Access Types\n\nThe indexing type is itself a type, so we can use unions, keyof, or other types entirely: 索引类型本身是一种类型，因此我们可以使用联合、键或其他类型:\n\ntype I1 = Person["age" | "name"];\ntype I2 = Person[keyof Person];\n\n\n1\n2\n\n\nAnother example of indexing with an arbitrary type is using number to get the type of an array’s elements. We can combine this with typeof to conveniently capture the element type of an array literal: 使用任意类型进行索引的另一个示例是使用 number 来获取数组元素的类型。我们可以把它和 typeof 结合起来，方便地捕获数组文字的元素类型:\n\nconst MyArray = [\n  { name: "Alice", age: 15 },\n  { name: "Bob", age: 23 },\n  { name: "Eve", age: 38 },\n];\ntype Age = typeof MyArray[number]["age"];\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# Conditional Types 条件类型\n\ntype NameOrId<T extends number | string> = T extends number\n  ? IdLabel\n  : NameLabel;\n\n\n1\n2\n3\n\n * Conditional Type Constraints 条件类型约束\n\ntype MessageOf<T extends { message: unknown }> = T["message"];\ntype Flatten<T> = T extends any[] ? T[number] : T;\n\n\n1\n2\n\n * Inferring Within Conditional Types 在条件类型中推断\n\ntype Flatten<Type> = Type extends Array<infer Item> ? Item : Type;\n\ntype GetReturnType<Type> = Type extends (...args: never[]) => infer Return\n  ? Return\n  : never;\n\n\n1\n2\n3\n4\n5\n\n * Distributive Conditional Types: 分配条件类型\n\nWhen conditional types act on a generic type, they become distributive when given a union type. 当条件类型作用于泛型类型时，它们在给定联合类型时成为分配类型。\n\ntype ToArray<Type> = Type extends any ? Type[] : never;\n \ntype StrArrOrNumArr = ToArray<string | number>; // type StrArrOrNumArr = string[] | number[]\n\n\n1\n2\n3\n\n\nTypically, distributivity is the desired behavior. To avoid that behavior, you can surround each side of the extends keyword with square brackets. 通常，分布性是期望的行为。为了避免这种行为，可以用方括号将 extends 关键字的每一边包围起来。\n\ntype ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;\n \n// \'StrArrOrNumArr\' is no longer a union.\ntype StrArrOrNumArr = ToArrayNonDist<string | number>; //type StrArrOrNumArr = (string | number)[]\n\n\n1\n2\n3\n4\n\n\n\n# Mapped Types 映射类型\n\nMapped types build on the syntax for index signatures, which are used to declare the types of properties which have not been declared ahead of time: 映射类型建立在索引签名的语法之上，索引签名用于声明未提前声明的属性类型:\n\ntype OnlyBoolsAndHorses = {\n  [key: string]: boolean | Horse;\n};\n\ntype OptionsFlags<Type> = {\n  [Property in keyof Type]: boolean;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * Mapping Modifiers: 映射修饰符\n\nThere are two additional modifiers which can be applied during mapping: readonly and ? which affect mutability and optionality respectively. 在映射过程中可以使用两个额外的修饰符: readonly 和？，它们分别影响可变性和可选性。\n\nYou can remove or add these modifiers by prefixing with - or +. If you don’t add a prefix, then + is assumed. 您可以通过使用 - 或 + 作为前缀来删除或添加这些修饰符。如果您没有添加前缀，则假定为 + 。\n\ntype CreateMutable<Type> = {\n  -readonly [Property in keyof Type]: Type[Property];\n};\ntype Concrete<Type> = {\n  [Property in keyof Type]-?: Type[Property];\n};\n\n\n1\n2\n3\n4\n5\n6\n\n * Key Remapping via as\n\nIn TypeScript 4.1 and onwards, you can re-map keys in mapped types with an as clause in a mapped type: 在 TypeScript 4.1 及以后的版本中，您可以使用映射类型中的 as 子句重新映射映射类型的键:\n\ntype Getters<Type> = {\n    [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property]\n};\n \ninterface Person {\n    name: string;\n    age: number;\n    location: string;\n}\n// type LazyPerson = {\n//     getName: () => string;\n//     getAge: () => number;\n//     getLocation: () => string;\n// }\ntype LazyPerson = Getters<Person>;\n\ntype RemoveKindField<Type> = {\n    [Property in keyof Type as Exclude<Property, "kind">]: Type[Property]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nYou can map over arbitrary unions, not just unions of string | number | symbol, but unions of any type: 你可以映射任意的联合，不仅仅是字符串 | 数字 | 符号的联合，而是任意类型的联合:\n\ntype EventConfig<Events extends { kind: string }> = {\n    [E in Events as E["kind"]]: (event: E) => void;\n}\n \ntype SquareEvent = { kind: "square", x: number, y: number };\ntype CircleEvent = { kind: "circle", radius: number };\n// type Config = {\n//     square: (event: SquareEvent) => void;\n//     circle: (event: CircleEvent) => void;\n// }\ntype Config = EventConfig<SquareEvent | CircleEvent>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Template Literal Types 模板文字类型\n\n * String Unions in Types 类型字符串联合\n\ntype PropEventSource<Type> = {\n    on(eventName: `${string & keyof Type}Changed`, callback: (newValue: any) => void): void;\n};\n \n/// Create a "watched object" with an \'on\' method\n/// so that you can watch for changes to properties.\ndeclare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * Inference with Template Literals: 使用模板文字进行推理\n\ntype PropEventSource<Type> = {\n    on<Key extends string & keyof Type>\n        (eventName: `${Key}Changed`, callback: (newValue: Type[Key]) => void ): void;\n};\n\n\n1\n2\n3\n4\n\n * Intrinsic String Manipulation Types: 内部字符串操作类型\n\nTo help with string manipulation, TypeScript includes a set of types which can be used in string manipulation. These types come built-in to the compiler for performance and can’t be found in the .d.ts files included with TypeScript.\n\n为了帮助进行字符串操作，TypeScript 包含了一组可用于字符串操作的类型。这些类型是编译器内置的，用于提高性能，在。打字稿中包含的 d.ts 文件。\n\nUppercase<StringType> : Converts each character in the string to the uppercase version. 将字符串中的每个字符转换为大写版本。\n\nLowercase<StringType> : Converts each character in the string to the lowercase equivalent. 将字符串中的每个字符转换为等效的小写形式。\n\nCapitalize<StringType> : Converts the first character in the string to an uppercase equivalent. 将字符串中的第一个字符转换为等效的大写字母。\n\nUncapitalize<StringType> : Converts the first character in the string to a lowercase equivalent. 将字符串中的第一个字符转换为等效的小写形式。',normalizedContent:'# 目录\n\n\n\n * 目录\n * generics 泛型\n * keyof type operator 类型操作运算符\n * typeof type operator\n * indexed access types\n * conditional types 条件类型\n * mapped types 映射类型\n * template literal types 模板文字类型\n\n\n\n\n# generics 泛型\n\n * generic types：泛型类型\n\nwe can also write the generic type as a call signature of an object literal type: 我们也可以将泛型类型写作为对象文本类型的调用签名:\n\nfunction identity<type>(arg: type): type {\n  return arg;\n}\n \nlet myidentity: { <type>(arg: type): type } = identity;\n\n\n1\n2\n3\n4\n5\n\n * generic classes: 泛型类\n\na class has two sides to its type: the static side and the instance side. generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class’s type parameter. 类的类型有两个方面：静态方面和实例方面。泛型类只是泛型的实例端而不是静态端，因此在处理类时，静态成员不能使用类的类型参数。\n\n * generic constraints: 泛型约束\n\n * using type parameters in generic constraints：在泛型约束中使用类型参数\n\n * using class types in generics：在泛型中使用类类型\n\n\n# keyof type operator 类型操作运算符\n\nif the type has a string or number index signature, keyof will return those types instead: 如果类型有字符串或数字索引签名，keyof 将返回这些类型:\n\ntype arrayish = { [n: number]: unknown };\ntype a = keyof arrayish;\n \ntype mapish = { [k: string]: boolean };\ntype m = keyof mapish;\n\n\n1\n2\n3\n4\n5\n\n\n\n# typeof type operator\n\nit’s only legal to use typeof on identifiers (i.e. variable names) or their properties. 使用 typeof on 标识符 (即变量名) 或其属性是合法的\n\n\n# indexed access types\n\nthe indexing type is itself a type, so we can use unions, keyof, or other types entirely: 索引类型本身是一种类型，因此我们可以使用联合、键或其他类型:\n\ntype i1 = person["age" | "name"];\ntype i2 = person[keyof person];\n\n\n1\n2\n\n\nanother example of indexing with an arbitrary type is using number to get the type of an array’s elements. we can combine this with typeof to conveniently capture the element type of an array literal: 使用任意类型进行索引的另一个示例是使用 number 来获取数组元素的类型。我们可以把它和 typeof 结合起来，方便地捕获数组文字的元素类型:\n\nconst myarray = [\n  { name: "alice", age: 15 },\n  { name: "bob", age: 23 },\n  { name: "eve", age: 38 },\n];\ntype age = typeof myarray[number]["age"];\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# conditional types 条件类型\n\ntype nameorid<t extends number | string> = t extends number\n  ? idlabel\n  : namelabel;\n\n\n1\n2\n3\n\n * conditional type constraints 条件类型约束\n\ntype messageof<t extends { message: unknown }> = t["message"];\ntype flatten<t> = t extends any[] ? t[number] : t;\n\n\n1\n2\n\n * inferring within conditional types 在条件类型中推断\n\ntype flatten<type> = type extends array<infer item> ? item : type;\n\ntype getreturntype<type> = type extends (...args: never[]) => infer return\n  ? return\n  : never;\n\n\n1\n2\n3\n4\n5\n\n * distributive conditional types: 分配条件类型\n\nwhen conditional types act on a generic type, they become distributive when given a union type. 当条件类型作用于泛型类型时，它们在给定联合类型时成为分配类型。\n\ntype toarray<type> = type extends any ? type[] : never;\n \ntype strarrornumarr = toarray<string | number>; // type strarrornumarr = string[] | number[]\n\n\n1\n2\n3\n\n\ntypically, distributivity is the desired behavior. to avoid that behavior, you can surround each side of the extends keyword with square brackets. 通常，分布性是期望的行为。为了避免这种行为，可以用方括号将 extends 关键字的每一边包围起来。\n\ntype toarraynondist<type> = [type] extends [any] ? type[] : never;\n \n// \'strarrornumarr\' is no longer a union.\ntype strarrornumarr = toarraynondist<string | number>; //type strarrornumarr = (string | number)[]\n\n\n1\n2\n3\n4\n\n\n\n# mapped types 映射类型\n\nmapped types build on the syntax for index signatures, which are used to declare the types of properties which have not been declared ahead of time: 映射类型建立在索引签名的语法之上，索引签名用于声明未提前声明的属性类型:\n\ntype onlyboolsandhorses = {\n  [key: string]: boolean | horse;\n};\n\ntype optionsflags<type> = {\n  [property in keyof type]: boolean;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * mapping modifiers: 映射修饰符\n\nthere are two additional modifiers which can be applied during mapping: readonly and ? which affect mutability and optionality respectively. 在映射过程中可以使用两个额外的修饰符: readonly 和？，它们分别影响可变性和可选性。\n\nyou can remove or add these modifiers by prefixing with - or +. if you don’t add a prefix, then + is assumed. 您可以通过使用 - 或 + 作为前缀来删除或添加这些修饰符。如果您没有添加前缀，则假定为 + 。\n\ntype createmutable<type> = {\n  -readonly [property in keyof type]: type[property];\n};\ntype concrete<type> = {\n  [property in keyof type]-?: type[property];\n};\n\n\n1\n2\n3\n4\n5\n6\n\n * key remapping via as\n\nin typescript 4.1 and onwards, you can re-map keys in mapped types with an as clause in a mapped type: 在 typescript 4.1 及以后的版本中，您可以使用映射类型中的 as 子句重新映射映射类型的键:\n\ntype getters<type> = {\n    [property in keyof type as `get${capitalize<string & property>}`]: () => type[property]\n};\n \ninterface person {\n    name: string;\n    age: number;\n    location: string;\n}\n// type lazyperson = {\n//     getname: () => string;\n//     getage: () => number;\n//     getlocation: () => string;\n// }\ntype lazyperson = getters<person>;\n\ntype removekindfield<type> = {\n    [property in keyof type as exclude<property, "kind">]: type[property]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nyou can map over arbitrary unions, not just unions of string | number | symbol, but unions of any type: 你可以映射任意的联合，不仅仅是字符串 | 数字 | 符号的联合，而是任意类型的联合:\n\ntype eventconfig<events extends { kind: string }> = {\n    [e in events as e["kind"]]: (event: e) => void;\n}\n \ntype squareevent = { kind: "square", x: number, y: number };\ntype circleevent = { kind: "circle", radius: number };\n// type config = {\n//     square: (event: squareevent) => void;\n//     circle: (event: circleevent) => void;\n// }\ntype config = eventconfig<squareevent | circleevent>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# template literal types 模板文字类型\n\n * string unions in types 类型字符串联合\n\ntype propeventsource<type> = {\n    on(eventname: `${string & keyof type}changed`, callback: (newvalue: any) => void): void;\n};\n \n/// create a "watched object" with an \'on\' method\n/// so that you can watch for changes to properties.\ndeclare function makewatchedobject<type>(obj: type): type & propeventsource<type>;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * inference with template literals: 使用模板文字进行推理\n\ntype propeventsource<type> = {\n    on<key extends string & keyof type>\n        (eventname: `${key}changed`, callback: (newvalue: type[key]) => void ): void;\n};\n\n\n1\n2\n3\n4\n\n * intrinsic string manipulation types: 内部字符串操作类型\n\nto help with string manipulation, typescript includes a set of types which can be used in string manipulation. these types come built-in to the compiler for performance and can’t be found in the .d.ts files included with typescript.\n\n为了帮助进行字符串操作，typescript 包含了一组可用于字符串操作的类型。这些类型是编译器内置的，用于提高性能，在。打字稿中包含的 d.ts 文件。\n\nuppercase<stringtype> : converts each character in the string to the uppercase version. 将字符串中的每个字符转换为大写版本。\n\nlowercase<stringtype> : converts each character in the string to the lowercase equivalent. 将字符串中的每个字符转换为等效的小写形式。\n\ncapitalize<stringtype> : converts the first character in the string to an uppercase equivalent. 将字符串中的第一个字符转换为等效的大写字母。\n\nuncapitalize<stringtype> : converts the first character in the string to a lowercase equivalent. 将字符串中的第一个字符转换为等效的小写形式。',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"classes 类类型",frontmatter:{title:"classes 类类型",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/basic/classes/",categories:["typescript-utility","basic"],tags:[null]},regularPath:"/30.web/4.typescript-utility/10.%E5%9F%BA%E7%A1%80/30.classes.html",relativePath:"30.web/4.typescript-utility/10.基础/30.classes.md",key:"v-27eebe53",path:"/ts/basic/classes/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"Class Members 类成员",slug:"class-members-类成员",normalizedTitle:"class members 类成员",charIndex:17},{level:3,title:"--strictPropertyInitialization",slug:"strictpropertyinitialization",normalizedTitle:"--strictpropertyinitialization",charIndex:40},{level:2,title:"readonly",slug:"readonly",normalizedTitle:"readonly",charIndex:74},{level:2,title:"Constructors 构造器",slug:"constructors-构造器",normalizedTitle:"constructors 构造器",charIndex:86},{level:2,title:"Super Calls 父级构造器调用",slug:"super-calls-父级构造器调用",normalizedTitle:"super calls 父级构造器调用",charIndex:106},{level:2,title:"Methods 方法",slug:"methods-方法",normalizedTitle:"methods 方法",charIndex:129},{level:2,title:"Getters / Setters",slug:"getters-setters",normalizedTitle:"getters / setters",charIndex:143},{level:2,title:"Index Signatures 索引签名",slug:"index-signatures-索引签名",normalizedTitle:"index signatures 索引签名",charIndex:164},{level:2,title:"Class Heritage 类继承",slug:"class-heritage-类继承",normalizedTitle:"class heritage 类继承",charIndex:189},{level:2,title:"Member Visibility 会员能见度",slug:"member-visibility-会员能见度",normalizedTitle:"member visibility 会员能见度",charIndex:211},{level:2,title:"Static Members 固定成员",slug:"static-members-固定成员",normalizedTitle:"static members 固定成员",charIndex:238},{level:2,title:"Special Static Names 特殊静态名称",slug:"special-static-names-特殊静态名称",normalizedTitle:"special static names 特殊静态名称",charIndex:261},{level:2,title:"Why No Static Classes? 为什么没有静态类？",slug:"why-no-static-classes-为什么没有静态类",normalizedTitle:"why no static classes? 为什么没有静态类？",charIndex:292},{level:2,title:"static Blocks in Classes 类中的块",slug:"static-blocks-in-classes-类中的块",normalizedTitle:"static blocks in classes 类中的块",charIndex:328},{level:2,title:"Generic Classes 通用类",slug:"generic-classes-通用类",normalizedTitle:"generic classes 通用类",charIndex:361},{level:2,title:"Type Parameters in Static Members 静态成员中的类型参数",slug:"type-parameters-in-static-members-静态成员中的类型参数",normalizedTitle:"type parameters in static members 静态成员中的类型参数",charIndex:384},{level:2,title:"this at Runtime in Classes在运行时在类中",slug:"this-at-runtime-in-classes在运行时在类中",normalizedTitle:"this at runtime in classes 在运行时在类中",charIndex:9053},{level:2,title:"Arrow Functions 箭头函数",slug:"arrow-functions-箭头函数",normalizedTitle:"arrow functions 箭头函数",charIndex:469},{level:2,title:"this parameters 参数",slug:"this-parameters-参数",normalizedTitle:"this parameters 参数",charIndex:493},{level:2,title:"this Types 类类型",slug:"this-types-类类型",normalizedTitle:"this types 类类型",charIndex:515},{level:2,title:"this-based type guards 基于类型的保护",slug:"this-based-type-guards-基于类型的保护",normalizedTitle:"this-based type guards 基于类型的保护",charIndex:533},{level:2,title:"Parameter Properties 参数属性",slug:"parameter-properties-参数属性",normalizedTitle:"parameter properties 参数属性",charIndex:567},{level:2,title:"Class Expressions 类别表达式",slug:"class-expressions-类别表达式",normalizedTitle:"class expressions 类别表达式",charIndex:596},{level:2,title:"abstract Classes and Members 班级及成员",slug:"abstract-classes-and-members-班级及成员",normalizedTitle:"abstract classes and members 班级及成员",charIndex:623},{level:2,title:"Abstract Construct Signatures 抽象构造签名",slug:"abstract-construct-signatures-抽象构造签名",normalizedTitle:"abstract construct signatures 抽象构造签名",charIndex:661},{level:2,title:"Relationships Between Classes 阶级之间的关系",slug:"relationships-between-classes-阶级之间的关系",normalizedTitle:"relationships between classes 阶级之间的关系",charIndex:701}],readingTime:{text:"10 min read",minutes:9.535,time:572100,words:1907},headersStr:"目录 Class Members 类成员 --strictPropertyInitialization readonly Constructors 构造器 Super Calls 父级构造器调用 Methods 方法 Getters / Setters Index Signatures 索引签名 Class Heritage 类继承 Member Visibility 会员能见度 Static Members 固定成员 Special Static Names 特殊静态名称 Why No Static Classes? 为什么没有静态类？ static Blocks in Classes 类中的块 Generic Classes 通用类 Type Parameters in Static Members 静态成员中的类型参数 this at Runtime in Classes在运行时在类中 Arrow Functions 箭头函数 this parameters 参数 this Types 类类型 this-based type guards 基于类型的保护 Parameter Properties 参数属性 Class Expressions 类别表达式 abstract Classes and Members 班级及成员 Abstract Construct Signatures 抽象构造签名 Relationships Between Classes 阶级之间的关系",content:'# 目录\n\n\n\n * 目录\n * Class Members 类成员\n   * --strictPropertyInitialization\n * readonly\n * Constructors 构造器\n * Super Calls 父级构造器调用\n * Methods 方法\n * Getters / Setters\n * Index Signatures 索引签名\n * Class Heritage 类继承\n * Member Visibility 会员能见度\n * Static Members 固定成员\n * Special Static Names 特殊静态名称\n * Why No Static Classes? 为什么没有静态类？\n * static Blocks in Classes 类中的块\n * Generic Classes 通用类\n * Type Parameters in Static Members 静态成员中的类型参数\n * this at Runtime in Classes在运行时在类中\n * Arrow Functions 箭头函数\n * this parameters 参数\n * this Types 类类型\n * this-based type guards 基于类型的保护\n * Parameter Properties 参数属性\n * Class Expressions 类别表达式\n * abstract Classes and Members 班级及成员\n * Abstract Construct Signatures 抽象构造签名\n * Relationships Between Classes 阶级之间的关系\n\n\n\n\n# Class Members 类成员\n\n\n# --strictPropertyInitialization\n\nThe strictPropertyInitialization setting controls whether class fields need to be initialized in the constructor. strictPropertyInitialization 设置控制是否需要在构造函数中初始化类字段。\n\nIf you intend to definitely initialize a field through means other than the constructor (for example, maybe an external library is filling in part of your class for you), you can use the definite assignment assertion operator, !: 如果您打算通过构造函数以外的方法 (例如，可能有一个外部库为您填充了类的一部分) 确切地初始化字段，那么您可以使用确定的赋值断言运算符，！\n\n\n# readonly\n\nFields may be prefixed with the readonly modifier. This prevents assignments to the field outside of the constructor. 字段可以用 readonly 修饰符作为前缀。这样可以防止赋值到构造函数之外的字段。\n\n\n# Constructors 构造器\n\nClass constructors are very similar to functions. You can add parameters with type annotations, default values, and overloads. 类构造函数与函数非常相似。你可以添加带有类型注释、默认值和重载的参数。\n\nThere are just a few differences between class constructor signatures and function signatures: 类构造函数签名和函数签名只有一些区别:\n\n * Constructors can’t have type parameters - these belong on the outer class declaration. 构造函数不能有类型参数 —— 它们属于外部类声明。\n * onstructors can’t have return type annotations - the class instance type is always what’s returned 构造函数不能有返回类型注释 —— 返回的总是类实例类型。\n\n\n# Super Calls 父级构造器调用\n\n\n# Methods 方法\n\n\n# Getters / Setters\n\nTypeScript has some special inference rules for accessors: 对访问器有一些特殊的推理规则:\n\n * If get exists but no set, the property is automatically readonly. 如果 get 存在但没有设置，则属性自动为只读\n * If the type of the setter parameter is not specified, it is inferred from the return type of the getter. 如果没有指定 setter 参数的类型，则从 getter 的返回类型推断出来\n * Getters and setters must have the same Member Visibility. Getters 和 setter 必须具有相同的成员 Visibility\n\n\n# Index Signatures 索引签名\n\nclass MyClass {\n  [s: string]: boolean | ((s: string) => boolean);\n \n  check(s: string) {\n    return this[s] as boolean;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Class Heritage 类继承\n\n * implements： Classes may also implement multiple interfaces, e.g. class C implements A, B {}.\n * extends：A derived class has all the properties and methods of its base class, and also define additional members. 派生类具有其基类的所有属性和方法，并定义其他成员。\n * Overriding Methods 覆盖方法：A derived class can also override a base class field or property. You can use the super. syntax to access base class methods. 派生类还可以重写基类字段或属性。你可以使用管理员。语法来访问基类方法。\n * Initialization Order 初始化顺序\n * Inheriting Built-in Types 继承内置类型\n\nIn ES2015, constructors which return an object implicitly substitute the value of this for any callers of super(...). It is necessary for generated constructor code to capture any potential return value of super(...) and replace it with this. 在 es2015 中，返回对象的构造函数隐式地用这个值替换任何 super (...) 调用方。生成的构造函数代码必须捕获 super (...) 的任何潜在返回值，并将其替换为这个值。\n\nAs a result, subclassing Error, Array, and others may no longer work as expected. This is due to the fact that constructor functions for Error, Array, and the like use ECMAScript 6’s new.target to adjust the prototype chain; however, there is no way to ensure a value for new.target when invoking a constructor in ECMAScript 5. Other downlevel compilers generally have the same limitation by default. 因此，子类化 Error、 Array 和其他元素可能无法正常工作。这是因为 Error，Array 和类似的构造函数使用 ECMAScript 6 的 new.target 来调整原型链；然而，当调用 ECMAScript 5 中的构造函数时，无法确保 new.target 的值。默认情况下，其他底层编译器通常具有相同的限制。\n\nAs a recommendation, you can manually adjust the prototype immediately after any super(...) calls. 作为建议，您可以在任何 super (...) 调用之后立即手动调整原型。\n\nclass MsgError extends Error {\n  constructor(m: string) {\n    super(m);\n \n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, MsgError.prototype);\n  }\n \n  sayHello() {\n    return "hello " + this.message;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nHowever, any subclass of MsgError will have to manually set the prototype as well. For runtimes that don’t support Object.setPrototypeOf, you may instead be able to use proto. 但是，MsgError 的任何子类都必须手动设置原型。对于不支持 Object.setPrototypeOf 的运行时，您可以使用 _ proto _。\n\nUnfortunately, these workarounds will not work on Internet Explorer 10 and prior. One can manually copy methods from the prototype onto the instance itself (i.e. MsgError.prototype onto this), but the prototype chain itself cannot be fixed. 不幸的是，这些变通方法不会在 Internet Explorer 10 和之前起作用。人们可以手动地将方法从原型复制到实例本身 (例如，MsgError.prototype 复制到实例本身) ，但是原型链本身不能修复。\n\n\n# Member Visibility 会员能见度\n\n * public: A public member can be accessed anywhere. public 成员可以在任何地方访问。\n * protected： protected members are only visible to subclasses of the class they’re declared in. 受保护成员只对它们在其中声明的类的子类可见。\n * exposure of 曝光 protected members 成员：Derived classes need to follow their base class contracts, but may choose to expose a subtype of base class with more capabilities. This includes making protected members public。派生类需要遵循其基类契约，但可以选择公开具有更多功能的基类的子类型。这包括使受保护成员公开。\n * private：private is like protected, but doesn’t allow access to the member even from subclasses.Private 类似于 protected，但是不允许访问成员，即使是来自子类。\n * Cross-instance 交叉实例 private access 访问：\n\nDifferent OOP languages disagree about whether different instances of the same class may access each others’ private members. While languages like Java, C#, C++, Swift, and PHP allow this, Ruby does not. 不同的 OOP 语言对同一类的不同实例是否可以访问彼此的私有成员存在分歧。尽管 Java、 c # 、 c + + 、 Swift 和 PHP 等语言允许这样做，但 Ruby 不允许。TypeScript does allow cross-instance private access.TypeScript 允许跨实例的私有访问\n\nprivate and protected are only enforced during type checking.private 和 protected 只在类型检查期间强制执行。\n\nprivate also allows access using bracket notation during type checking. This makes private-declared fields potentially easier to access for things like unit tests, with the drawback that these fields are soft private and don’t strictly enforce privacy. Private 还允许在类型检查期间使用括号表示法访问。这使得私有声明的字段可能更容易访问像单元测试这样的东西，但缺点是这些字段是软私有的，并不严格执行隐私。\n\nUnlike TypeScripts’s private, JavaScript’s private fields (#) remain private after compilation and do not provide the previously mentioned escape hatches like bracket notation access, making them hard private. 与 TypeScripts 的私有字段不同，JavaScript 的私有字段 (#) 在编译后仍然是私有的，并且不提供前面提到的逃逸字段，比如括号记号访问，这使得它们很难私有化。\n\nWhen compiling to ES2021 or less, TypeScript will use WeakMaps in place of #. 当编译成 es2021 或更少时，打字稿将使用 WeakMaps 来代替 # 。\n\nIf you need to protect values in your class from malicious actors, you should use mechanisms that offer hard runtime privacy, such as closures, WeakMaps, or private fields. Note that these added privacy checks during runtime could affect performance. 如果需要保护类中的值不受恶意操作者的攻击，应该使用提供硬运行时隐私的机制，如闭包、 WeakMaps 或私有字段。请注意，运行时期间这些添加的隐私检查可能会影响性能。\n\n\n# Static Members 固定成员\n\nClasses may have static members. These members aren’t associated with a particular instance of the class. They can be accessed through the class constructor object itself。类可以有静态成员。这些成员不与类的特定实例关联。它们可以通过类构造函数对象本身访问。\n\nStatic members can also use the same public, protected, and private visibility modifiers。 静态成员还可以使用相同的 public、 protected 和 private 可见性修饰符。\n\nStatic members are also inherited。 静态成员也可以继承。\n\n\n# Special Static Names 特殊静态名称\n\nIt’s generally not safe/possible to overwrite properties from the Function prototype. Because classes are themselves functions that can be invoked with new, certain static names can’t be used. Function properties like name, length, and call aren’t valid to define as static members。 从函数原型中覆盖属性通常是不安全的 / 不可能的。因为类本身是可以用新名称调用的函数，所以某些静态名称不能使用。函数属性，如名称、长度和调用，无法定义为静态成员。\n\n\n# Why No Static Classes? 为什么没有静态类？\n\nwe don’t need a “static class” syntax in TypeScript because a regular object (or even top-level function) will do the job just as well. 我们不需要打字稿中的 “静态类” 语法，因为一个常规对象 (甚至是顶级函数) 也可以很好地完成这项工作。\n\n\n# static Blocks in Classes 类中的块\n\nStatic blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. This means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our class’s internals. 静态块允许您编写具有自己作用域的语句序列，该语句序列可以访问包含类中的私有字段。这意味着我们可以使用编写语句的所有功能来编写初始化代码，不泄露变量，并且可以完全访问类的内部。\n\n\n# Generic Classes 通用类\n\nClasses can use generic constraints and defaults the same way as interfaces. 类可以像使用接口一样使用泛型约束和默认值。\n\n\n# Type Parameters in Static Members 静态成员中的类型参数\n\nThe static members of a generic class can never refer to the class’s type parameters. 泛型类的静态成员永远不能引用类的类型参数。\n\n\n# this at Runtime in Classes 在运行时在类中\n\nLong story short, by default, the value of this inside a function depends on how the function was called. In this example, because the function was called through the obj reference, its value of this was obj rather than the class instance. 长话短说，默认情况下，这个函数在函数内部的值取决于函数的调用方式。在这个例子中，因为函数是通过 obj 引用调用的，所以它的值是 obj 而不是类实例。\n\n\n# Arrow Functions 箭头函数\n\nIf you have a function that will often be called in a way that loses its this context, it can make sense to use an arrow function property instead of a method definition: 如果你有一个函数被调用的方式会失去它的上下文，那么使用箭头函数属性来代替方法定义是有意义的:\n\nclass MyClass {\n  name = "MyClass";\n  getName = () => {\n    return this.name;\n  };\n}\nconst c = new MyClass();\nconst g = c.getName;\n// Prints "MyClass" instead of crashing\nconsole.log(g());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nThis has some trade-offs: 这有一些取舍:\n\n * The this value is guaranteed to be correct at runtime, even for code not checked with TypeScript 这个值在运行时保证是正确的，即使对于没有用打字稿检查的代码也是如此\n\n * This will use more memory, because each class instance will have its own copy of each function defined this way 这将使用更多的内存，因为每个类实例都有以这种方式定义的每个函数的自己的副本\n\n * You can’t use super.getName in a derived class, because there’s no entry in the prototype chain to fetch the base class method from 不能在派生类中使用 super.getName，因为原型链中没有从中提取基类方法的条目\n\n\n# this parameters 参数\n\nIn a method or function definition, an initial parameter named this has special meaning in TypeScript. These parameters are erased during compilation 在方法或函数定义中，名为 this 的初始参数在打字稿中具有特殊意义。这些参数在编译过程中被删除\n\nTypeScript checks that calling a function with a this parameter is done so with a correct context. Instead of using an arrow function, we can add a this parameter to method definitions to statically enforce that the method is called correctly. 打字稿检查使用 this 参数调用函数是否使用了正确的上下文。与使用箭头函数不同，我们可以在方法定义中添加 this 参数来静态地强制方法被正确调用。\n\nThis method makes the opposite trade-offs of the arrow function approach: 这个方法使得箭头函数的取舍相反:\n\n * JavaScript callers might still use the class method incorrectly without realizing it JavaScript 调用方可能仍然不正确地使用类方法而没有实现它\n\n * Only one function per class definition gets allocated, rather than one per class instance 每个类定义只分配一个函数，而不是每个类实例分配一个函数\n\n * Base method definitions can still be called via super. 仍然可以通过 super 调用基方法定义\n\n\n# this Types 类类型\n\nIn classes, a special type called this refers dynamically to the type of the current class. 在类中，一个名为 this 的特殊类型动态地引用当前类的类型。\n\n\n# this-based type guards 基于类型的保护\n\nYou can use this is Type in the return position for methods in classes and interfaces. When mixed with a type narrowing (e.g. if statements) the type of the target object would be narrowed to the specified Type. 您可以在类和接口中的方法的返回位置中使用这个是 Type。当与类型收缩 (例如 if 语句) 混合时，目标对象的类型将收缩到指定的 Type。\n\nA common use-case for a this-based type guard is to allow for lazy validation of a particular field. 此类型保护的一个常见用例是允许对特定字段进行延迟验证。\n\nclass Box<T> {\n  value?: T;\n \n  hasValue(): this is { value: T } {\n    return this.value !== undefined;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Parameter Properties 参数属性\n\nTypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value. These are called parameter properties and are created by prefixing a constructor argument with one of the visibility modifiers public, private, protected, or readonly. The resulting field gets those modifier(s): 打字稿提供了特殊的语法，可以将构造函数参数转换为具有相同名称和值的类属性。这些属性称为参数属性，通过在构造函数参数前加上一个可见性修饰符 public、 private、 protected 或 readonly 来创建。结果字段得到这些修饰符:\n\nclass Params {\n  constructor(\n    public readonly x: number,\n    protected y: number,\n    private z: number\n  ) {\n    // No body necessary\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# Class Expressions 类别表达式\n\nClass expressions are very similar to class declarations. The only real difference is that class expressions don’t need a name, though we can refer to them via whatever identifier they ended up bound to: 类表达式与类声明非常相似。唯一的区别是类表达式不需要名称，尽管我们可以通过它们最终绑定到的任何标识符引用它们.\n\nconst someClass = class<Type> {\n  content: Type;\n  constructor(value: Type) {\n    this.content = value;\n  }\n};\n \nconst m = new someClass("Hello, world");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# abstract Classes and Members 班级及成员\n\nClasses, methods, and fields in TypeScript may be abstract. 打字稿中的类、方法和字段可能是抽象的。\n\nAn abstract method or abstract field is one that hasn’t had an implementation provided. These members must exist inside an abstract class, which cannot be directly instantiated. 抽象方法或抽象字段是没有提供实现的方法。这些成员必须存在于抽象类中，而抽象类不能直接实例化。\n\nThe role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members. When a class doesn’t have any abstract members, it is said to be concrete. 抽象类的作用是作为实现所有抽象成员的子类的基类。当一个类没有任何抽象成员时，它被称为具体的。\n\n\n# Abstract Construct Signatures 抽象构造签名\n\nfunction greet(ctor: new () => Base) {\n  const instance = new ctor();\n  instance.printName();\n}\n\n\n1\n2\n3\n4\n\n\n\n# Relationships Between Classes 阶级之间的关系\n\nIn most cases, classes in TypeScript are compared structurally, the same as other types. 在大多数情况下，TypeScript 中的类在结构上进行比较，与其他类型相同。\n\nclass Point1 {\n  x = 0;\n  y = 0;\n}\n \nclass Point2 {\n  x = 0;\n  y = 0;\n}\n \n// OK\nconst p: Point1 = new Point2();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nSimilarly, subtype relationships between classes exist even if there’s no explicit inheritance: 类似地，即使没有明确的继承，类之间也存在子类型关系:\n\nclass Person {\n  name: string;\n  age: number;\n}\n \nclass Employee {\n  name: string;\n  age: number;\n  salary: number;\n}\n \n// OK\nconst p: Person = new Employee();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nEmpty classes have no members. In a structural type system, a type with no members is generally a supertype of anything else. So if you write an empty class (don’t!), anything can be used in place of it. 空类没有成员。在结构类型系统中，没有成员的类型通常是其他任何类型的超类型。因此，如果您编写了一个空类 (不要！) 任何东西都可以代替它.',normalizedContent:'# 目录\n\n\n\n * 目录\n * class members 类成员\n   * --strictpropertyinitialization\n * readonly\n * constructors 构造器\n * super calls 父级构造器调用\n * methods 方法\n * getters / setters\n * index signatures 索引签名\n * class heritage 类继承\n * member visibility 会员能见度\n * static members 固定成员\n * special static names 特殊静态名称\n * why no static classes? 为什么没有静态类？\n * static blocks in classes 类中的块\n * generic classes 通用类\n * type parameters in static members 静态成员中的类型参数\n * this at runtime in classes在运行时在类中\n * arrow functions 箭头函数\n * this parameters 参数\n * this types 类类型\n * this-based type guards 基于类型的保护\n * parameter properties 参数属性\n * class expressions 类别表达式\n * abstract classes and members 班级及成员\n * abstract construct signatures 抽象构造签名\n * relationships between classes 阶级之间的关系\n\n\n\n\n# class members 类成员\n\n\n# --strictpropertyinitialization\n\nthe strictpropertyinitialization setting controls whether class fields need to be initialized in the constructor. strictpropertyinitialization 设置控制是否需要在构造函数中初始化类字段。\n\nif you intend to definitely initialize a field through means other than the constructor (for example, maybe an external library is filling in part of your class for you), you can use the definite assignment assertion operator, !: 如果您打算通过构造函数以外的方法 (例如，可能有一个外部库为您填充了类的一部分) 确切地初始化字段，那么您可以使用确定的赋值断言运算符，！\n\n\n# readonly\n\nfields may be prefixed with the readonly modifier. this prevents assignments to the field outside of the constructor. 字段可以用 readonly 修饰符作为前缀。这样可以防止赋值到构造函数之外的字段。\n\n\n# constructors 构造器\n\nclass constructors are very similar to functions. you can add parameters with type annotations, default values, and overloads. 类构造函数与函数非常相似。你可以添加带有类型注释、默认值和重载的参数。\n\nthere are just a few differences between class constructor signatures and function signatures: 类构造函数签名和函数签名只有一些区别:\n\n * constructors can’t have type parameters - these belong on the outer class declaration. 构造函数不能有类型参数 —— 它们属于外部类声明。\n * onstructors can’t have return type annotations - the class instance type is always what’s returned 构造函数不能有返回类型注释 —— 返回的总是类实例类型。\n\n\n# super calls 父级构造器调用\n\n\n# methods 方法\n\n\n# getters / setters\n\ntypescript has some special inference rules for accessors: 对访问器有一些特殊的推理规则:\n\n * if get exists but no set, the property is automatically readonly. 如果 get 存在但没有设置，则属性自动为只读\n * if the type of the setter parameter is not specified, it is inferred from the return type of the getter. 如果没有指定 setter 参数的类型，则从 getter 的返回类型推断出来\n * getters and setters must have the same member visibility. getters 和 setter 必须具有相同的成员 visibility\n\n\n# index signatures 索引签名\n\nclass myclass {\n  [s: string]: boolean | ((s: string) => boolean);\n \n  check(s: string) {\n    return this[s] as boolean;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# class heritage 类继承\n\n * implements： classes may also implement multiple interfaces, e.g. class c implements a, b {}.\n * extends：a derived class has all the properties and methods of its base class, and also define additional members. 派生类具有其基类的所有属性和方法，并定义其他成员。\n * overriding methods 覆盖方法：a derived class can also override a base class field or property. you can use the super. syntax to access base class methods. 派生类还可以重写基类字段或属性。你可以使用管理员。语法来访问基类方法。\n * initialization order 初始化顺序\n * inheriting built-in types 继承内置类型\n\nin es2015, constructors which return an object implicitly substitute the value of this for any callers of super(...). it is necessary for generated constructor code to capture any potential return value of super(...) and replace it with this. 在 es2015 中，返回对象的构造函数隐式地用这个值替换任何 super (...) 调用方。生成的构造函数代码必须捕获 super (...) 的任何潜在返回值，并将其替换为这个值。\n\nas a result, subclassing error, array, and others may no longer work as expected. this is due to the fact that constructor functions for error, array, and the like use ecmascript 6’s new.target to adjust the prototype chain; however, there is no way to ensure a value for new.target when invoking a constructor in ecmascript 5. other downlevel compilers generally have the same limitation by default. 因此，子类化 error、 array 和其他元素可能无法正常工作。这是因为 error，array 和类似的构造函数使用 ecmascript 6 的 new.target 来调整原型链；然而，当调用 ecmascript 5 中的构造函数时，无法确保 new.target 的值。默认情况下，其他底层编译器通常具有相同的限制。\n\nas a recommendation, you can manually adjust the prototype immediately after any super(...) calls. 作为建议，您可以在任何 super (...) 调用之后立即手动调整原型。\n\nclass msgerror extends error {\n  constructor(m: string) {\n    super(m);\n \n    // set the prototype explicitly.\n    object.setprototypeof(this, msgerror.prototype);\n  }\n \n  sayhello() {\n    return "hello " + this.message;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nhowever, any subclass of msgerror will have to manually set the prototype as well. for runtimes that don’t support object.setprototypeof, you may instead be able to use proto. 但是，msgerror 的任何子类都必须手动设置原型。对于不支持 object.setprototypeof 的运行时，您可以使用 _ proto _。\n\nunfortunately, these workarounds will not work on internet explorer 10 and prior. one can manually copy methods from the prototype onto the instance itself (i.e. msgerror.prototype onto this), but the prototype chain itself cannot be fixed. 不幸的是，这些变通方法不会在 internet explorer 10 和之前起作用。人们可以手动地将方法从原型复制到实例本身 (例如，msgerror.prototype 复制到实例本身) ，但是原型链本身不能修复。\n\n\n# member visibility 会员能见度\n\n * public: a public member can be accessed anywhere. public 成员可以在任何地方访问。\n * protected： protected members are only visible to subclasses of the class they’re declared in. 受保护成员只对它们在其中声明的类的子类可见。\n * exposure of 曝光 protected members 成员：derived classes need to follow their base class contracts, but may choose to expose a subtype of base class with more capabilities. this includes making protected members public。派生类需要遵循其基类契约，但可以选择公开具有更多功能的基类的子类型。这包括使受保护成员公开。\n * private：private is like protected, but doesn’t allow access to the member even from subclasses.private 类似于 protected，但是不允许访问成员，即使是来自子类。\n * cross-instance 交叉实例 private access 访问：\n\ndifferent oop languages disagree about whether different instances of the same class may access each others’ private members. while languages like java, c#, c++, swift, and php allow this, ruby does not. 不同的 oop 语言对同一类的不同实例是否可以访问彼此的私有成员存在分歧。尽管 java、 c # 、 c + + 、 swift 和 php 等语言允许这样做，但 ruby 不允许。typescript does allow cross-instance private access.typescript 允许跨实例的私有访问\n\nprivate and protected are only enforced during type checking.private 和 protected 只在类型检查期间强制执行。\n\nprivate also allows access using bracket notation during type checking. this makes private-declared fields potentially easier to access for things like unit tests, with the drawback that these fields are soft private and don’t strictly enforce privacy. private 还允许在类型检查期间使用括号表示法访问。这使得私有声明的字段可能更容易访问像单元测试这样的东西，但缺点是这些字段是软私有的，并不严格执行隐私。\n\nunlike typescripts’s private, javascript’s private fields (#) remain private after compilation and do not provide the previously mentioned escape hatches like bracket notation access, making them hard private. 与 typescripts 的私有字段不同，javascript 的私有字段 (#) 在编译后仍然是私有的，并且不提供前面提到的逃逸字段，比如括号记号访问，这使得它们很难私有化。\n\nwhen compiling to es2021 or less, typescript will use weakmaps in place of #. 当编译成 es2021 或更少时，打字稿将使用 weakmaps 来代替 # 。\n\nif you need to protect values in your class from malicious actors, you should use mechanisms that offer hard runtime privacy, such as closures, weakmaps, or private fields. note that these added privacy checks during runtime could affect performance. 如果需要保护类中的值不受恶意操作者的攻击，应该使用提供硬运行时隐私的机制，如闭包、 weakmaps 或私有字段。请注意，运行时期间这些添加的隐私检查可能会影响性能。\n\n\n# static members 固定成员\n\nclasses may have static members. these members aren’t associated with a particular instance of the class. they can be accessed through the class constructor object itself。类可以有静态成员。这些成员不与类的特定实例关联。它们可以通过类构造函数对象本身访问。\n\nstatic members can also use the same public, protected, and private visibility modifiers。 静态成员还可以使用相同的 public、 protected 和 private 可见性修饰符。\n\nstatic members are also inherited。 静态成员也可以继承。\n\n\n# special static names 特殊静态名称\n\nit’s generally not safe/possible to overwrite properties from the function prototype. because classes are themselves functions that can be invoked with new, certain static names can’t be used. function properties like name, length, and call aren’t valid to define as static members。 从函数原型中覆盖属性通常是不安全的 / 不可能的。因为类本身是可以用新名称调用的函数，所以某些静态名称不能使用。函数属性，如名称、长度和调用，无法定义为静态成员。\n\n\n# why no static classes? 为什么没有静态类？\n\nwe don’t need a “static class” syntax in typescript because a regular object (or even top-level function) will do the job just as well. 我们不需要打字稿中的 “静态类” 语法，因为一个常规对象 (甚至是顶级函数) 也可以很好地完成这项工作。\n\n\n# static blocks in classes 类中的块\n\nstatic blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. this means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our class’s internals. 静态块允许您编写具有自己作用域的语句序列，该语句序列可以访问包含类中的私有字段。这意味着我们可以使用编写语句的所有功能来编写初始化代码，不泄露变量，并且可以完全访问类的内部。\n\n\n# generic classes 通用类\n\nclasses can use generic constraints and defaults the same way as interfaces. 类可以像使用接口一样使用泛型约束和默认值。\n\n\n# type parameters in static members 静态成员中的类型参数\n\nthe static members of a generic class can never refer to the class’s type parameters. 泛型类的静态成员永远不能引用类的类型参数。\n\n\n# this at runtime in classes 在运行时在类中\n\nlong story short, by default, the value of this inside a function depends on how the function was called. in this example, because the function was called through the obj reference, its value of this was obj rather than the class instance. 长话短说，默认情况下，这个函数在函数内部的值取决于函数的调用方式。在这个例子中，因为函数是通过 obj 引用调用的，所以它的值是 obj 而不是类实例。\n\n\n# arrow functions 箭头函数\n\nif you have a function that will often be called in a way that loses its this context, it can make sense to use an arrow function property instead of a method definition: 如果你有一个函数被调用的方式会失去它的上下文，那么使用箭头函数属性来代替方法定义是有意义的:\n\nclass myclass {\n  name = "myclass";\n  getname = () => {\n    return this.name;\n  };\n}\nconst c = new myclass();\nconst g = c.getname;\n// prints "myclass" instead of crashing\nconsole.log(g());\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nthis has some trade-offs: 这有一些取舍:\n\n * the this value is guaranteed to be correct at runtime, even for code not checked with typescript 这个值在运行时保证是正确的，即使对于没有用打字稿检查的代码也是如此\n\n * this will use more memory, because each class instance will have its own copy of each function defined this way 这将使用更多的内存，因为每个类实例都有以这种方式定义的每个函数的自己的副本\n\n * you can’t use super.getname in a derived class, because there’s no entry in the prototype chain to fetch the base class method from 不能在派生类中使用 super.getname，因为原型链中没有从中提取基类方法的条目\n\n\n# this parameters 参数\n\nin a method or function definition, an initial parameter named this has special meaning in typescript. these parameters are erased during compilation 在方法或函数定义中，名为 this 的初始参数在打字稿中具有特殊意义。这些参数在编译过程中被删除\n\ntypescript checks that calling a function with a this parameter is done so with a correct context. instead of using an arrow function, we can add a this parameter to method definitions to statically enforce that the method is called correctly. 打字稿检查使用 this 参数调用函数是否使用了正确的上下文。与使用箭头函数不同，我们可以在方法定义中添加 this 参数来静态地强制方法被正确调用。\n\nthis method makes the opposite trade-offs of the arrow function approach: 这个方法使得箭头函数的取舍相反:\n\n * javascript callers might still use the class method incorrectly without realizing it javascript 调用方可能仍然不正确地使用类方法而没有实现它\n\n * only one function per class definition gets allocated, rather than one per class instance 每个类定义只分配一个函数，而不是每个类实例分配一个函数\n\n * base method definitions can still be called via super. 仍然可以通过 super 调用基方法定义\n\n\n# this types 类类型\n\nin classes, a special type called this refers dynamically to the type of the current class. 在类中，一个名为 this 的特殊类型动态地引用当前类的类型。\n\n\n# this-based type guards 基于类型的保护\n\nyou can use this is type in the return position for methods in classes and interfaces. when mixed with a type narrowing (e.g. if statements) the type of the target object would be narrowed to the specified type. 您可以在类和接口中的方法的返回位置中使用这个是 type。当与类型收缩 (例如 if 语句) 混合时，目标对象的类型将收缩到指定的 type。\n\na common use-case for a this-based type guard is to allow for lazy validation of a particular field. 此类型保护的一个常见用例是允许对特定字段进行延迟验证。\n\nclass box<t> {\n  value?: t;\n \n  hasvalue(): this is { value: t } {\n    return this.value !== undefined;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# parameter properties 参数属性\n\ntypescript offers special syntax for turning a constructor parameter into a class property with the same name and value. these are called parameter properties and are created by prefixing a constructor argument with one of the visibility modifiers public, private, protected, or readonly. the resulting field gets those modifier(s): 打字稿提供了特殊的语法，可以将构造函数参数转换为具有相同名称和值的类属性。这些属性称为参数属性，通过在构造函数参数前加上一个可见性修饰符 public、 private、 protected 或 readonly 来创建。结果字段得到这些修饰符:\n\nclass params {\n  constructor(\n    public readonly x: number,\n    protected y: number,\n    private z: number\n  ) {\n    // no body necessary\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# class expressions 类别表达式\n\nclass expressions are very similar to class declarations. the only real difference is that class expressions don’t need a name, though we can refer to them via whatever identifier they ended up bound to: 类表达式与类声明非常相似。唯一的区别是类表达式不需要名称，尽管我们可以通过它们最终绑定到的任何标识符引用它们.\n\nconst someclass = class<type> {\n  content: type;\n  constructor(value: type) {\n    this.content = value;\n  }\n};\n \nconst m = new someclass("hello, world");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# abstract classes and members 班级及成员\n\nclasses, methods, and fields in typescript may be abstract. 打字稿中的类、方法和字段可能是抽象的。\n\nan abstract method or abstract field is one that hasn’t had an implementation provided. these members must exist inside an abstract class, which cannot be directly instantiated. 抽象方法或抽象字段是没有提供实现的方法。这些成员必须存在于抽象类中，而抽象类不能直接实例化。\n\nthe role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members. when a class doesn’t have any abstract members, it is said to be concrete. 抽象类的作用是作为实现所有抽象成员的子类的基类。当一个类没有任何抽象成员时，它被称为具体的。\n\n\n# abstract construct signatures 抽象构造签名\n\nfunction greet(ctor: new () => base) {\n  const instance = new ctor();\n  instance.printname();\n}\n\n\n1\n2\n3\n4\n\n\n\n# relationships between classes 阶级之间的关系\n\nin most cases, classes in typescript are compared structurally, the same as other types. 在大多数情况下，typescript 中的类在结构上进行比较，与其他类型相同。\n\nclass point1 {\n  x = 0;\n  y = 0;\n}\n \nclass point2 {\n  x = 0;\n  y = 0;\n}\n \n// ok\nconst p: point1 = new point2();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nsimilarly, subtype relationships between classes exist even if there’s no explicit inheritance: 类似地，即使没有明确的继承，类之间也存在子类型关系:\n\nclass person {\n  name: string;\n  age: number;\n}\n \nclass employee {\n  name: string;\n  age: number;\n  salary: number;\n}\n \n// ok\nconst p: person = new employee();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nempty classes have no members. in a structural type system, a type with no members is generally a supertype of anything else. so if you write an empty class (don’t!), anything can be used in place of it. 空类没有成员。在结构类型系统中，没有成员的类型通常是其他任何类型的超类型。因此，如果您编写了一个空类 (不要！) 任何东西都可以代替它.',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"reference 其他",frontmatter:{title:"reference 其他",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/basic/reference/",categories:["typescript-utility","basic"],tags:[null]},regularPath:"/30.web/4.typescript-utility/10.%E5%9F%BA%E7%A1%80/40.reference.html",relativePath:"30.web/4.typescript-utility/10.基础/40.reference.md",key:"v-2080504b",path:"/ts/basic/reference/",headers:[{level:2,title:"Utility Types 实用类型",slug:"utility-types-实用类型",normalizedTitle:"utility types 实用类型",charIndex:2}],readingTime:{text:"3 min read",minutes:2.41,time:144600.00000000003,words:482},headersStr:"Utility Types 实用类型",content:"# Utility Types 实用类型\n\n * Partial<Type>\n\nConstructs a type with all properties of Type set to optional. This utility will return a type that represents all subsets of a given type. 构造具有 Type 的所有属性设置为可选的类型。此实用程序将返回表示给定类型的所有子集的类型。\n\n * Required<Type>\n\nConstructs a type consisting of all properties of Type set to required. The opposite of Partial. 构造一个包含 Type 设置为 required 的所有属性的类型。与 Partial 相反。\n\n * Readonly<Type>\n\nConstructs a type with all properties of Type set to readonly, meaning the properties of the constructed type cannot be reassigned. 构造具有 Type 的所有属性设置为只读的类型，这意味着不能重新分配构造类型的属性。\n\n * Record<Keys, Type>\n\nConstructs an object type whose property keys are Keys and whose property values are Type. This utility can be used to map the properties of a type to another type. 构造属性键为 Keys、属性值为 Type 的对象类型。此实用工具可用于将一个类型的属性映射到另一个类型。\n\n * Pick<Type, Keys>\n\nConstructs a type by picking the set of properties Keys (string literal or union of string literals) from Type. 通过从 Type 中选择一组属性 Keys (字符串文本或字符串文本的并集) 来构造类型。\n\n * Omit<Type, Keys>\n\nConstructs a type by picking all properties from Type and then removing Keys (string literal or union of string literals). 通过从 Type 中选取所有属性，然后移除 Keys (字符串文字或字符串文字的并集) 来构造类型。\n\n * Exclude<Type, ExcludedUnion>\n\nConstructs a type by excluding from Type all union members that are assignable to ExcludedUnion. 通过从类型中排除可分配给 ExcludedUnion 的所有联合成员来构造类型。\n\n * Extract<Type, Union>\n\nConstructs a type by extracting from Type all union members that are assignable to Union. 通过从 Type 中提取可分配给 Union 的所有联合成员来构造类型。\n\n * NonNullable<Type>\n\nConstructs a type by excluding null and undefined from Type. 通过从 Type 中排除 null 和 undefined 来构造类型。\n\n * Parameters<Type>\n\nConstructs a tuple type from the types used in the parameters of a function type Type. 从函数类型类型的参数中使用的类型构造元组类型。\n\n * ConstructorParameters<Type>\n\nConstructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the type never if Type is not a function). 从构造函数类型的类型构造元组或数组类型。它生成具有所有参数类型的元组类型 (如果 Type 不是函数，则生成 never 类型)。\n\n * ReturnType<Type>\n\nConstructs a type consisting of the return type of function Type. 构造一个类型，包含函数 Type 的返回类型。\n\n * InstanceType<Type>\n\nConstructs a type consisting of the instance type of a constructor function in Type. 构造由 Type 中构造函数的实例类型组成的类型。\n\n * ThisParameterType<Type>\n\nExtracts the type of the this parameter for a function type, or unknown if the function type has no this parameter. 提取函数类型的此参数的类型，如果函数类型没有此参数，则未知。\n\n * OmitThisParameter<Type>\n\nRemoves the this parameter from Type. If Type has no explicitly declared this parameter, the result is simply Type. Otherwise, a new function type with no this parameter is created from Type. Generics are erased and only the last overload signature is propagated into the new function type. 从 Type 中移除此参数。如果 Type 没有显式声明此参数，则结果只是 Type。否则，将从 Type 创建没有此参数的新函数类型。泛型被擦除，只有最后一个重载签名被传播到新的函数类型中。\n\nfunction toHex(this: Number) {\n  return this.toString(16);\n}\n \nconst fiveToHex: OmitThisParameter<typeof toHex> = toHex.bind(5);\n \nconsole.log(fiveToHex());\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * ThisType<Type>\n\nThis utility does not return a transformed type. Instead, it serves as a marker for a contextual this type. Note that the noImplicitThis flag must be enabled to use this utility. 此实用程序不返回转换后的类型。相反，它可以作为这种类型上下文的标记。请注意，必须启用 noImplicitThis 标志才能使用此实用程序。\n\n * Intrinsic String Manipulation Types\n\n 1. Uppercase<StringType>\n 2. Lowercase<StringType>\n 3. Capitalize<StringType>\n 4. Uncapitalize<StringType>",normalizedContent:"# utility types 实用类型\n\n * partial<type>\n\nconstructs a type with all properties of type set to optional. this utility will return a type that represents all subsets of a given type. 构造具有 type 的所有属性设置为可选的类型。此实用程序将返回表示给定类型的所有子集的类型。\n\n * required<type>\n\nconstructs a type consisting of all properties of type set to required. the opposite of partial. 构造一个包含 type 设置为 required 的所有属性的类型。与 partial 相反。\n\n * readonly<type>\n\nconstructs a type with all properties of type set to readonly, meaning the properties of the constructed type cannot be reassigned. 构造具有 type 的所有属性设置为只读的类型，这意味着不能重新分配构造类型的属性。\n\n * record<keys, type>\n\nconstructs an object type whose property keys are keys and whose property values are type. this utility can be used to map the properties of a type to another type. 构造属性键为 keys、属性值为 type 的对象类型。此实用工具可用于将一个类型的属性映射到另一个类型。\n\n * pick<type, keys>\n\nconstructs a type by picking the set of properties keys (string literal or union of string literals) from type. 通过从 type 中选择一组属性 keys (字符串文本或字符串文本的并集) 来构造类型。\n\n * omit<type, keys>\n\nconstructs a type by picking all properties from type and then removing keys (string literal or union of string literals). 通过从 type 中选取所有属性，然后移除 keys (字符串文字或字符串文字的并集) 来构造类型。\n\n * exclude<type, excludedunion>\n\nconstructs a type by excluding from type all union members that are assignable to excludedunion. 通过从类型中排除可分配给 excludedunion 的所有联合成员来构造类型。\n\n * extract<type, union>\n\nconstructs a type by extracting from type all union members that are assignable to union. 通过从 type 中提取可分配给 union 的所有联合成员来构造类型。\n\n * nonnullable<type>\n\nconstructs a type by excluding null and undefined from type. 通过从 type 中排除 null 和 undefined 来构造类型。\n\n * parameters<type>\n\nconstructs a tuple type from the types used in the parameters of a function type type. 从函数类型类型的参数中使用的类型构造元组类型。\n\n * constructorparameters<type>\n\nconstructs a tuple or array type from the types of a constructor function type. it produces a tuple type with all the parameter types (or the type never if type is not a function). 从构造函数类型的类型构造元组或数组类型。它生成具有所有参数类型的元组类型 (如果 type 不是函数，则生成 never 类型)。\n\n * returntype<type>\n\nconstructs a type consisting of the return type of function type. 构造一个类型，包含函数 type 的返回类型。\n\n * instancetype<type>\n\nconstructs a type consisting of the instance type of a constructor function in type. 构造由 type 中构造函数的实例类型组成的类型。\n\n * thisparametertype<type>\n\nextracts the type of the this parameter for a function type, or unknown if the function type has no this parameter. 提取函数类型的此参数的类型，如果函数类型没有此参数，则未知。\n\n * omitthisparameter<type>\n\nremoves the this parameter from type. if type has no explicitly declared this parameter, the result is simply type. otherwise, a new function type with no this parameter is created from type. generics are erased and only the last overload signature is propagated into the new function type. 从 type 中移除此参数。如果 type 没有显式声明此参数，则结果只是 type。否则，将从 type 创建没有此参数的新函数类型。泛型被擦除，只有最后一个重载签名被传播到新的函数类型中。\n\nfunction tohex(this: number) {\n  return this.tostring(16);\n}\n \nconst fivetohex: omitthisparameter<typeof tohex> = tohex.bind(5);\n \nconsole.log(fivetohex());\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * thistype<type>\n\nthis utility does not return a transformed type. instead, it serves as a marker for a contextual this type. note that the noimplicitthis flag must be enabled to use this utility. 此实用程序不返回转换后的类型。相反，它可以作为这种类型上下文的标记。请注意，必须启用 noimplicitthis 标志才能使用此实用程序。\n\n * intrinsic string manipulation types\n\n 1. uppercase<stringtype>\n 2. lowercase<stringtype>\n 3. capitalize<stringtype>\n 4. uncapitalize<stringtype>",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"type-zoo",frontmatter:{title:"type-zoo",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/basic/type-zoo/",categories:["typescript-utility","basic"],tags:[null]},regularPath:"/30.web/4.typescript-utility/10.%E5%9F%BA%E7%A1%80/50.type-zoo.html",relativePath:"30.web/4.typescript-utility/10.基础/50.type-zoo.md",key:"v-057781cb",path:"/ts/basic/type-zoo/",readingTime:{text:"5 min read",minutes:4.19,time:251400.00000000003,words:838},headersStr:null,content:"/**\n * Extract from `T` those types that are assignable to `U`, where `U` must exist in `T`.\n *\n * Similar to `Extract` but requires the extraction list to be composed of valid members of `T`.\n *\n * @see https://github.com/pelotom/type-zoo/issues/37\n */\nexport type ExtractStrict<T, U extends T> = T extends U ? T : never;\n\n/**\n * Exclude from `T` those types that are assignable to `U`, where `U` must exist in `T`.\n *\n * Similar to `Exclude` but requires the exclusion list to be composed of valid members of `T`.\n *\n * @see https://github.com/pelotom/type-zoo/issues/37\n */\nexport type ExcludeStrict<T, U extends T> = T extends U ? never : T;\n\n/**\n * Drop keys `K` from `T` if they are present.\n *\n * @see https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-377567046\n */\nexport type Omit<T, K extends keyof any> = T extends any ? Pick<T, Exclude<keyof T, K>> : never;\n\n/**\n * Drop keys `K` from `T`, where `K` must exist in `T`.\n *\n * @see https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-377567046\n */\nexport type OmitStrict<T, K extends keyof T> = T extends any ? Pick<T, Exclude<keyof T, K>> : never;\n\n/**\n * Like `T & U`, but where there are overlapping properties using the\n * type from U only.\n *\n * @see Old: https://github.com/pelotom/type-zoo/issues/2\n * @see Old: https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458\n * @see New: https://github.com/pelotom/type-zoo/pull/14#discussion_r183527882\n */\nexport type Overwrite<T, U> = Omit<T, keyof T & keyof U> & U;\n\n/**\n * Use to prevent a usage of type `T` from being inferred in other generics.\n *\n * Example:\n * declare function assertEqual<T>(actual: T, expected: NoInfer<T>): boolean;\n *\n * Type `T` will now only be inferred based on the type of the `actual` param, and\n * the `expected` param is required to be assignable to the type of `actual`.\n * This allows you to give one particular usage of type `T` full control over how the\n * compiler infers type `T`.\n *\n * @see https://github.com/Microsoft/TypeScript/issues/14829#issuecomment-322267089\n */\nexport type NoInfer<T> = T & { [K in keyof T]: T[K] };\n\n/**\n * Forgets contextual knowledge of partiality of keys.\n */\nexport type Purify<T extends string> = { [P in T]: T }[T];\n\n/**\n * Get the public interface of a type. This is useful for working with classes that have private members.\n *\n * export class Foo {\n *   private priv: string;\n *\n *   bar(): number {\n *     // ...\n *   }\n * }\n *\n * export type IFoo = Public<Foo>;\n *\n * // Can mock or fake\n * const fakeFoo: IFoo = {\n *   bar(): { return 1;}\n * }\n */\nexport type Public<T> = { [P in keyof T]: T[P] };\n\n/**\n * Selects the type of the 0th parameter in a function-type\n */\nexport type Param0<Func> = Func extends (a: infer T, ...args: any[]) => any ? T : never;\n/**\n * Selects the type of the 1st parameter in a function-type\n */\nexport type Param1<Func> = Func extends (a: any, b: infer T, ...args: any[]) => any ? T : never;\n/**\n * Selects the type of the 2nd parameter in a function-type\n */\nexport type Param2<Func> = Func extends (a: any, b: any, c: infer T, ...args: any[]) => any\n  ? T\n  : never;\n/**\n * Selects the type of the 3rd parameter in a function-type\n */\nexport type Param3<Func> = Func extends (a: any, b: any, c: any, d: infer T, ...args: any[]) => any\n  ? T\n  : never;\n/**\n * Selects the types of all the parameters in a function-type.\n * Warnings:\n *  - This is probably less performant if you're only looking up a single param! {@see Param0-Param# }\n *  - This omits rest parameters (...args:any[])\n */\nexport type ParamTypes<F extends Function> = F extends () => any // tslint:disable-line\n  ? {}\n  : F extends (p0: infer P0) => any\n    ? [P0]\n    : F extends (p0: infer P0, p1: infer P1) => any\n      ? [P0, P1]\n      : F extends (p0: infer P0, p1: infer P1, p2: infer P2) => any\n        ? [P0, P1, P2]\n        : F extends (p0: infer P0, p1: infer P1, p2: infer P2, p3: infer P3) => any\n          ? [P0, P1, P2, P3] // ... -- extend this at your own risk, this could be bad for compilation performance!\n          : never;\n\n/**\n * Picks 2 levels deep into a nested object!\n *\n * @see https://gist.github.com/staltz/368866ea6b8a167fbdac58cddf79c1bf\n */\nexport type Pick2<T, K1 extends keyof T, K2 extends keyof T[K1]> = {\n  [P1 in K1]: { [P2 in K2]: (T[K1])[P2] }\n};\n\n/**\n * Picks 3 levels deep into a nested object!\n *\n * @see https://gist.github.com/staltz/368866ea6b8a167fbdac58cddf79c1bf\n */\nexport type Pick3<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]> = {\n  [P1 in K1]: { [P2 in K2]: { [P3 in K3]: ((T[K1])[K2])[P3] } }\n};\n\n/**\n * Picks 4 levels deep into a nested object!\n */\nexport type Pick4<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3]\n> = { [P1 in K1]: { [P2 in K2]: { [P3 in K3]: { [P4 in K4]: (((T[K1])[K2])[K3])[P4] } } } };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n",normalizedContent:"/**\n * extract from `t` those types that are assignable to `u`, where `u` must exist in `t`.\n *\n * similar to `extract` but requires the extraction list to be composed of valid members of `t`.\n *\n * @see https://github.com/pelotom/type-zoo/issues/37\n */\nexport type extractstrict<t, u extends t> = t extends u ? t : never;\n\n/**\n * exclude from `t` those types that are assignable to `u`, where `u` must exist in `t`.\n *\n * similar to `exclude` but requires the exclusion list to be composed of valid members of `t`.\n *\n * @see https://github.com/pelotom/type-zoo/issues/37\n */\nexport type excludestrict<t, u extends t> = t extends u ? never : t;\n\n/**\n * drop keys `k` from `t` if they are present.\n *\n * @see https://github.com/microsoft/typescript/issues/12215#issuecomment-377567046\n */\nexport type omit<t, k extends keyof any> = t extends any ? pick<t, exclude<keyof t, k>> : never;\n\n/**\n * drop keys `k` from `t`, where `k` must exist in `t`.\n *\n * @see https://github.com/microsoft/typescript/issues/12215#issuecomment-377567046\n */\nexport type omitstrict<t, k extends keyof t> = t extends any ? pick<t, exclude<keyof t, k>> : never;\n\n/**\n * like `t & u`, but where there are overlapping properties using the\n * type from u only.\n *\n * @see old: https://github.com/pelotom/type-zoo/issues/2\n * @see old: https://github.com/microsoft/typescript/issues/12215#issuecomment-307871458\n * @see new: https://github.com/pelotom/type-zoo/pull/14#discussion_r183527882\n */\nexport type overwrite<t, u> = omit<t, keyof t & keyof u> & u;\n\n/**\n * use to prevent a usage of type `t` from being inferred in other generics.\n *\n * example:\n * declare function assertequal<t>(actual: t, expected: noinfer<t>): boolean;\n *\n * type `t` will now only be inferred based on the type of the `actual` param, and\n * the `expected` param is required to be assignable to the type of `actual`.\n * this allows you to give one particular usage of type `t` full control over how the\n * compiler infers type `t`.\n *\n * @see https://github.com/microsoft/typescript/issues/14829#issuecomment-322267089\n */\nexport type noinfer<t> = t & { [k in keyof t]: t[k] };\n\n/**\n * forgets contextual knowledge of partiality of keys.\n */\nexport type purify<t extends string> = { [p in t]: t }[t];\n\n/**\n * get the public interface of a type. this is useful for working with classes that have private members.\n *\n * export class foo {\n *   private priv: string;\n *\n *   bar(): number {\n *     // ...\n *   }\n * }\n *\n * export type ifoo = public<foo>;\n *\n * // can mock or fake\n * const fakefoo: ifoo = {\n *   bar(): { return 1;}\n * }\n */\nexport type public<t> = { [p in keyof t]: t[p] };\n\n/**\n * selects the type of the 0th parameter in a function-type\n */\nexport type param0<func> = func extends (a: infer t, ...args: any[]) => any ? t : never;\n/**\n * selects the type of the 1st parameter in a function-type\n */\nexport type param1<func> = func extends (a: any, b: infer t, ...args: any[]) => any ? t : never;\n/**\n * selects the type of the 2nd parameter in a function-type\n */\nexport type param2<func> = func extends (a: any, b: any, c: infer t, ...args: any[]) => any\n  ? t\n  : never;\n/**\n * selects the type of the 3rd parameter in a function-type\n */\nexport type param3<func> = func extends (a: any, b: any, c: any, d: infer t, ...args: any[]) => any\n  ? t\n  : never;\n/**\n * selects the types of all the parameters in a function-type.\n * warnings:\n *  - this is probably less performant if you're only looking up a single param! {@see param0-param# }\n *  - this omits rest parameters (...args:any[])\n */\nexport type paramtypes<f extends function> = f extends () => any // tslint:disable-line\n  ? {}\n  : f extends (p0: infer p0) => any\n    ? [p0]\n    : f extends (p0: infer p0, p1: infer p1) => any\n      ? [p0, p1]\n      : f extends (p0: infer p0, p1: infer p1, p2: infer p2) => any\n        ? [p0, p1, p2]\n        : f extends (p0: infer p0, p1: infer p1, p2: infer p2, p3: infer p3) => any\n          ? [p0, p1, p2, p3] // ... -- extend this at your own risk, this could be bad for compilation performance!\n          : never;\n\n/**\n * picks 2 levels deep into a nested object!\n *\n * @see https://gist.github.com/staltz/368866ea6b8a167fbdac58cddf79c1bf\n */\nexport type pick2<t, k1 extends keyof t, k2 extends keyof t[k1]> = {\n  [p1 in k1]: { [p2 in k2]: (t[k1])[p2] }\n};\n\n/**\n * picks 3 levels deep into a nested object!\n *\n * @see https://gist.github.com/staltz/368866ea6b8a167fbdac58cddf79c1bf\n */\nexport type pick3<t, k1 extends keyof t, k2 extends keyof t[k1], k3 extends keyof t[k1][k2]> = {\n  [p1 in k1]: { [p2 in k2]: { [p3 in k3]: ((t[k1])[k2])[p3] } }\n};\n\n/**\n * picks 4 levels deep into a nested object!\n */\nexport type pick4<\n  t,\n  k1 extends keyof t,\n  k2 extends keyof t[k1],\n  k3 extends keyof t[k1][k2],\n  k4 extends keyof t[k1][k2][k3]\n> = { [p1 in k1]: { [p2 in k2]: { [p3 in k3]: { [p4 in k4]: (((t[k1])[k2])[k3])[p4] } } } };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"本章概要",frontmatter:{title:"本章概要",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/utility/index/",categories:["typescript-utility","utility-types"],tags:[null]},regularPath:"/30.web/4.typescript-utility/20.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7/0.index.html",relativePath:"30.web/4.typescript-utility/20.类型工具/0.index.md",key:"v-2af34dca",path:"/ts/utility/index/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2}],readingTime:{text:"1 min read",minutes:.025,time:1500,words:5},headersStr:"目录",content:"# 目录\n\n\n\n * 目录\n\n",normalizedContent:"# 目录\n\n\n\n * 目录\n\n",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"Basic Utility Types",frontmatter:{title:"Basic Utility Types",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/utility/basic/",categories:["typescript-utility","utility-types"],tags:[null]},regularPath:"/30.web/4.typescript-utility/20.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7/10.basic.html",relativePath:"30.web/4.typescript-utility/20.类型工具/10.basic.md",key:"v-f790ca6e",path:"/ts/utility/basic/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"$Keys",slug:"keys",normalizedTitle:"$keys",charIndex:17},{level:2,title:"$Values",slug:"values",normalizedTitle:"$values",charIndex:26},{level:2,title:"$ReadOnly",slug:"readonly",normalizedTitle:"$readonly",charIndex:37},{level:2,title:"$Diff",slug:"diff",normalizedTitle:"$diff",charIndex:50},{level:2,title:"$PropertyType",slug:"propertytype",normalizedTitle:"$propertytype",charIndex:59},{level:2,title:"$ElementType",slug:"elementtype",normalizedTitle:"$elementtype",charIndex:76},{level:2,title:"$Call",slug:"call",normalizedTitle:"$call",charIndex:92},{level:2,title:"$Shape",slug:"shape",normalizedTitle:"$shape",charIndex:101},{level:2,title:"$NonMaybeType",slug:"nonmaybetype",normalizedTitle:"$nonmaybetype",charIndex:111},{level:2,title:"Class",slug:"class",normalizedTitle:"class",charIndex:128}],readingTime:{text:"5 min read",minutes:4.32,time:259200.00000000006,words:864},headersStr:"目录 $Keys $Values $ReadOnly $Diff $PropertyType $ElementType $Call $Shape $NonMaybeType Class",content:"# 目录\n\n\n\n * 目录\n * $Keys\n * $Values\n * $ReadOnly\n * $Diff\n * $PropertyType\n * $ElementType\n * $Call\n * $Shape\n * $NonMaybeType\n * Class\n\n\n\n以下方法兼容 Flow 类型。\n\n\n# $Keys\n\n获取 object 的 keys。\n\n/**\n * $Keys\n * @desc Get the union type of all the keys in an object type `T`\n * @see https://flow.org/en/docs/types/utilities/#toc-keys\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *\n *   // Expect: \"name\" | \"age\" | \"visible\"\n *   type PropsKeys = $Keys<Props>;\n */\nexport type $Keys<T extends object> = keyof T;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# $Values\n\n获取 object 的 values types。\n\n/**\n * $Values\n * @desc Get the union type of all the values in an object type `T`\n * @see https://flow.org/en/docs/types/utilities/#toc-values\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *\n *   // Expect: string | number | boolean\n *   type PropsValues = $Values<Props>;\n */\nexport type $Values<T extends object> = T[keyof T];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# $ReadOnly\n\n获取 deep readonly object type。\n\n/**\n * $ReadOnly\n * @desc Get the read-only version of a given object type `T` (it works on nested data structure)\n * @see https://flow.org/en/docs/types/utilities/#toc-readonly\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *\n *   // Expect: Readonly<{ name: string; age: number; visible: boolean; }>\n *   type ReadOnlyProps = $ReadOnly<Props>;\n */\nexport type $ReadOnly<T extends object> = DeepReadonly<T>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * DeepReadonly：object deep readonly type.\n\n\n# $Diff\n\n获取两个 object 的类型差集。\n\n/**\n * $Diff\n * @desc Get the set difference of a given object types `T` and `U` (`T \\ U`)\n * @see https://flow.org/en/docs/types/utilities/#toc-diff\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *   type DefaultProps = { age: number };\n *\n *   // Expect: { name: string; visible: boolean; }\n *   type RequiredProps = Diff<Props, DefaultProps>;\n */\nexport type $Diff<T extends U, U extends object> = Pick<\n  T,\n  SetComplement<keyof T, keyof U>\n>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * SetComplement：从集合中过滤掉另一个集成中的类型。\n\n\n# $PropertyType\n\n获取 object 中某个 key 对应的 type。\n\n/**\n * $PropertyType\n * @desc Get the type of property of an object at a given key `K`\n * @see https://flow.org/en/docs/types/utilities/#toc-propertytype\n * @example\n *   // Expect: string;\n *   type Props = { name: string; age: number; visible: boolean };\n *   type NameType = $PropertyType<Props, 'name'>;\n *\n *   // Expect: boolean\n *   type Tuple = [boolean, number];\n *   type A = $PropertyType<Tuple, '0'>;\n *   // Expect: number\n *   type B = $PropertyType<Tuple, '1'>;\n */\nexport type $PropertyType<T extends object, K extends keyof T> = T[K];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# $ElementType\n\n给定 index 的类型，获取 object、array、tuple 指定下标的类型。\n\n/**\n * $ElementType\n * @desc Get the type of elements inside of array, tuple or object of type `T`, that matches the given index type `K`\n * @see https://flow.org/en/docs/types/utilities/#toc-elementtype\n * @example\n *   // Expect: string;\n *   type Props = { name: string; age: number; visible: boolean };\n *   type NameType = $ElementType<Props, 'name'>;\n *\n *   // Expect: boolean\n *   type Tuple = [boolean, number];\n *   type A = $ElementType<Tuple, '0'>;\n *   // Expect: number\n *   type B = $ElementType<Tuple, '1'>;\n *\n *   // Expect: boolean\n *   type Arr = boolean[];\n *   type ItemsType = $ElementType<Arr, number>;\n *\n *   // Expect: number\n *   type Obj = { [key: string]: number };\n *   type ValuesType = $ElementType<Obj, string>;\n */\nexport type $ElementType<\n  T extends { [P in K & any]: any },\n  K extends keyof T | number\n> = T[K];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# $Call\n\n获取函数的返回值类型。\n\n/**\n * $Call\n * @desc Get the return type from a given typeof expression\n * @see https://flow.org/en/docs/types/utilities/#toc-call\n * @example\n *   // Common use-case\n *   const add = (amount: number) => ({ type: 'ADD' as 'ADD', payload: amount });\n *   type AddAction = $Call<typeof returnOfIncrement>; // { type: 'ADD'; payload: number }\n *\n *   // Examples migrated from Flow docs\n *   type ExtractPropType<T extends { prop: any }> = (arg: T) => T['prop'];\n *   type Obj = { prop: number };\n *   type PropType = $Call<ExtractPropType<Obj>>; // number\n *\n *   type ExtractReturnType<T extends () => any> = (arg: T) => ReturnType<T>;\n *   type Fn = () => number;\n *   type FnReturnType = $Call<ExtractReturnType<Fn>>; // number\n */\nexport type $Call<Fn extends (...args: any[]) => any> = Fn extends (\n  arg: any\n) => infer RT\n  ? RT\n  : never;\n\ntype ReturnType<T> = T extends (...args: any[]) => infer P ? P : any;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * infer: 表示在 extends 条件语句中待推断的类型变量。\n\n\n# $Shape\n\n使 object 的所有 property 类型为可选。\n\n/**\n * $Shape\n * @desc Copies the shape of the type supplied, but marks every field optional.\n * @see https://flow.org/en/docs/types/utilities/#toc-shape\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *\n *   // Expect: Partial<Props>\n *   type PartialProps = $Shape<Props>;\n */\nexport type $Shape<T extends object> = Partial<T>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# $NonMaybeType\n\n去除 null 、undefined 类型。\n\n/**\n * $NonMaybeType\n * @desc Excludes null and undefined from T\n * @see https://flow.org/en/docs/types/utilities/#toc-nonmaybe\n * @example\n *   type MaybeName = string | null;\n *\n *   // Expect: string\n *   type Name = $NonMaybeType<MaybeName>;\n */\nexport type $NonMaybeType<T> = NonNullable<T>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Class\n\n获取 class 的类型。\n\n/**\n * Class\n * @desc Represents constructor of type T\n * @see https://flow.org/en/docs/types/utilities/#toc-class\n * @example\n *   class Store {}\n *   function makeStore(storeClass: Class<Store>): Store {\n *     return new storeClass();\n *   }\n */\nexport type Class<T> = new (...args: any[]) => T;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",normalizedContent:"# 目录\n\n\n\n * 目录\n * $keys\n * $values\n * $readonly\n * $diff\n * $propertytype\n * $elementtype\n * $call\n * $shape\n * $nonmaybetype\n * class\n\n\n\n以下方法兼容 flow 类型。\n\n\n# $keys\n\n获取 object 的 keys。\n\n/**\n * $keys\n * @desc get the union type of all the keys in an object type `t`\n * @see https://flow.org/en/docs/types/utilities/#toc-keys\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *\n *   // expect: \"name\" | \"age\" | \"visible\"\n *   type propskeys = $keys<props>;\n */\nexport type $keys<t extends object> = keyof t;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# $values\n\n获取 object 的 values types。\n\n/**\n * $values\n * @desc get the union type of all the values in an object type `t`\n * @see https://flow.org/en/docs/types/utilities/#toc-values\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *\n *   // expect: string | number | boolean\n *   type propsvalues = $values<props>;\n */\nexport type $values<t extends object> = t[keyof t];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# $readonly\n\n获取 deep readonly object type。\n\n/**\n * $readonly\n * @desc get the read-only version of a given object type `t` (it works on nested data structure)\n * @see https://flow.org/en/docs/types/utilities/#toc-readonly\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *\n *   // expect: readonly<{ name: string; age: number; visible: boolean; }>\n *   type readonlyprops = $readonly<props>;\n */\nexport type $readonly<t extends object> = deepreadonly<t>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n * deepreadonly：object deep readonly type.\n\n\n# $diff\n\n获取两个 object 的类型差集。\n\n/**\n * $diff\n * @desc get the set difference of a given object types `t` and `u` (`t \\ u`)\n * @see https://flow.org/en/docs/types/utilities/#toc-diff\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *   type defaultprops = { age: number };\n *\n *   // expect: { name: string; visible: boolean; }\n *   type requiredprops = diff<props, defaultprops>;\n */\nexport type $diff<t extends u, u extends object> = pick<\n  t,\n  setcomplement<keyof t, keyof u>\n>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * setcomplement：从集合中过滤掉另一个集成中的类型。\n\n\n# $propertytype\n\n获取 object 中某个 key 对应的 type。\n\n/**\n * $propertytype\n * @desc get the type of property of an object at a given key `k`\n * @see https://flow.org/en/docs/types/utilities/#toc-propertytype\n * @example\n *   // expect: string;\n *   type props = { name: string; age: number; visible: boolean };\n *   type nametype = $propertytype<props, 'name'>;\n *\n *   // expect: boolean\n *   type tuple = [boolean, number];\n *   type a = $propertytype<tuple, '0'>;\n *   // expect: number\n *   type b = $propertytype<tuple, '1'>;\n */\nexport type $propertytype<t extends object, k extends keyof t> = t[k];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# $elementtype\n\n给定 index 的类型，获取 object、array、tuple 指定下标的类型。\n\n/**\n * $elementtype\n * @desc get the type of elements inside of array, tuple or object of type `t`, that matches the given index type `k`\n * @see https://flow.org/en/docs/types/utilities/#toc-elementtype\n * @example\n *   // expect: string;\n *   type props = { name: string; age: number; visible: boolean };\n *   type nametype = $elementtype<props, 'name'>;\n *\n *   // expect: boolean\n *   type tuple = [boolean, number];\n *   type a = $elementtype<tuple, '0'>;\n *   // expect: number\n *   type b = $elementtype<tuple, '1'>;\n *\n *   // expect: boolean\n *   type arr = boolean[];\n *   type itemstype = $elementtype<arr, number>;\n *\n *   // expect: number\n *   type obj = { [key: string]: number };\n *   type valuestype = $elementtype<obj, string>;\n */\nexport type $elementtype<\n  t extends { [p in k & any]: any },\n  k extends keyof t | number\n> = t[k];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# $call\n\n获取函数的返回值类型。\n\n/**\n * $call\n * @desc get the return type from a given typeof expression\n * @see https://flow.org/en/docs/types/utilities/#toc-call\n * @example\n *   // common use-case\n *   const add = (amount: number) => ({ type: 'add' as 'add', payload: amount });\n *   type addaction = $call<typeof returnofincrement>; // { type: 'add'; payload: number }\n *\n *   // examples migrated from flow docs\n *   type extractproptype<t extends { prop: any }> = (arg: t) => t['prop'];\n *   type obj = { prop: number };\n *   type proptype = $call<extractproptype<obj>>; // number\n *\n *   type extractreturntype<t extends () => any> = (arg: t) => returntype<t>;\n *   type fn = () => number;\n *   type fnreturntype = $call<extractreturntype<fn>>; // number\n */\nexport type $call<fn extends (...args: any[]) => any> = fn extends (\n  arg: any\n) => infer rt\n  ? rt\n  : never;\n\ntype returntype<t> = t extends (...args: any[]) => infer p ? p : any;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n * infer: 表示在 extends 条件语句中待推断的类型变量。\n\n\n# $shape\n\n使 object 的所有 property 类型为可选。\n\n/**\n * $shape\n * @desc copies the shape of the type supplied, but marks every field optional.\n * @see https://flow.org/en/docs/types/utilities/#toc-shape\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *\n *   // expect: partial<props>\n *   type partialprops = $shape<props>;\n */\nexport type $shape<t extends object> = partial<t>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# $nonmaybetype\n\n去除 null 、undefined 类型。\n\n/**\n * $nonmaybetype\n * @desc excludes null and undefined from t\n * @see https://flow.org/en/docs/types/utilities/#toc-nonmaybe\n * @example\n *   type maybename = string | null;\n *\n *   // expect: string\n *   type name = $nonmaybetype<maybename>;\n */\nexport type $nonmaybetype<t> = nonnullable<t>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# class\n\n获取 class 的类型。\n\n/**\n * class\n * @desc represents constructor of type t\n * @see https://flow.org/en/docs/types/utilities/#toc-class\n * @example\n *   class store {}\n *   function makestore(storeclass: class<store>): store {\n *     return new storeclass();\n *   }\n */\nexport type class<t> = new (...args: any[]) => t;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"Mapped Types",frontmatter:{title:"Mapped Types",date:"2022-04-14T22:02:21.000Z",permalink:"/ts/utility/mapped/",categories:["typescript-utility","utility-types"],tags:[null]},regularPath:"/30.web/4.typescript-utility/20.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7/20.mapped-types.html",relativePath:"30.web/4.typescript-utility/20.类型工具/20.mapped-types.md",key:"v-1061317b",path:"/ts/utility/mapped/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2}],readingTime:{text:"15 min read",minutes:14.3,time:858e3,words:2860},headersStr:"目录",content:"# 目录\n\n\n\n * 目录\n\n\n\n/**\n * SetIntersection (same as Extract)\n * @desc Set intersection of given union types `A` and `B`\n * @example\n *   // Expect: \"2\" | \"3\"\n *   SetIntersection<'1' | '2' | '3', '2' | '3' | '4'>;\n *\n *   // Expect: () => void\n *   SetIntersection<string | number | (() => void), Function>;\n */\nexport type SetIntersection<A, B> = A extends B ? A : never;\n\n/**\n * SetDifference (same as Exclude)\n * @desc Set difference of given union types `A` and `B`\n * @example\n *   // Expect: \"1\"\n *   SetDifference<'1' | '2' | '3', '2' | '3' | '4'>;\n *\n *   // Expect: string | number\n *   SetDifference<string | number | (() => void), Function>;\n */\nexport type SetDifference<A, B> = A extends B ? never : A;\n\n/**\n * SetComplement\n * @desc Set complement of given union types `A` and (it's subset) `A1`\n * @example\n *   // Expect: \"1\"\n *   SetComplement<'1' | '2' | '3', '2' | '3'>;\n */\nexport type SetComplement<A, A1 extends A> = SetDifference<A, A1>;\n\n/**\n * SymmetricDifference\n * @desc Set difference of union and intersection of given union types `A` and `B`\n * @example\n *   // Expect: \"1\" | \"4\"\n *   SymmetricDifference<'1' | '2' | '3', '2' | '3' | '4'>;\n */\nexport type SymmetricDifference<A, B> = SetDifference<A | B, A & B>;\n\n/**\n * NonUndefined\n * @desc Exclude undefined from set `A`\n * @example\n *   // Expect: \"string | null\"\n *   SymmetricDifference<string | null | undefined>;\n */\nexport type NonUndefined<A> = A extends undefined ? never : A;\n\n/**\n * NonNullable\n * @desc Exclude undefined and null from set `A`\n * @example\n *   // Expect: \"string\"\n *   SymmetricDifference<string | null | undefined>;\n */\n// type NonNullable - built-in\n\n/**\n * FunctionKeys\n * @desc Get union type of keys that are functions in object type `T`\n * @example\n *  type MixedProps = {name: string; setName: (name: string) => void; someKeys?: string; someFn?: (...args: any) => any;};\n *\n *   // Expect: \"setName | someFn\"\n *   type Keys = FunctionKeys<MixedProps>;\n */\nexport type FunctionKeys<T extends object> = {\n  [K in keyof T]-?: NonUndefined<T[K]> extends Function ? K : never;\n}[keyof T];\n\n/**\n * NonFunctionKeys\n * @desc Get union type of keys that are non-functions in object type `T`\n * @example\n *   type MixedProps = {name: string; setName: (name: string) => void; someKeys?: string; someFn?: (...args: any) => any;};\n *\n *   // Expect: \"name | someKey\"\n *   type Keys = NonFunctionKeys<MixedProps>;\n */\nexport type NonFunctionKeys<T extends object> = {\n  [K in keyof T]-?: NonUndefined<T[K]> extends Function ? never : K;\n}[keyof T];\n\n/**\n * MutableKeys\n * @desc Get union type of keys that are mutable in object type `T`\n * Credit: Matt McCutchen\n * https://stackoverflow.com/questions/52443276/how-to-exclude-getter-only-properties-from-type-in-typescript\n * @example\n *   type Props = { readonly foo: string; bar: number };\n *\n *   // Expect: \"bar\"\n *   type Keys = MutableKeys<Props>;\n */\nexport type MutableKeys<T extends object> = {\n  [P in keyof T]-?: IfEquals<\n    { [Q in P]: T[P] },\n    { -readonly [Q in P]: T[P] },\n    P\n  >;\n}[keyof T];\nexport type WritableKeys<T extends object> = MutableKeys<T>;\n\n/**\n * ReadonlyKeys\n * @desc Get union type of keys that are readonly in object type `T`\n * Credit: Matt McCutchen\n * https://stackoverflow.com/questions/52443276/how-to-exclude-getter-only-properties-from-type-in-typescript\n * @example\n *   type Props = { readonly foo: string; bar: number };\n *\n *   // Expect: \"foo\"\n *   type Keys = ReadonlyKeys<Props>;\n */\nexport type ReadonlyKeys<T extends object> = {\n  [P in keyof T]-?: IfEquals<\n    { [Q in P]: T[P] },\n    { -readonly [Q in P]: T[P] },\n    never,\n    P\n  >;\n}[keyof T];\n\ntype IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <\n  T\n>() => T extends Y ? 1 : 2\n  ? A\n  : B;\n\n/**\n * RequiredKeys\n * @desc Get union type of keys that are required in object type `T`\n * @see https://stackoverflow.com/questions/52984808/is-there-a-way-to-get-all-required-properties-of-a-typescript-object\n * @example\n *   type Props = { req: number; reqUndef: number | undefined; opt?: string; optUndef?: number | undefined; };\n *\n *   // Expect: \"req\" | \"reqUndef\"\n *   type Keys = RequiredKeys<Props>;\n */\nexport type RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K;\n}[keyof T];\n\n/**\n * OptionalKeys\n * @desc Get union type of keys that are optional in object type `T`\n * @see https://stackoverflow.com/questions/52984808/is-there-a-way-to-get-all-required-properties-of-a-typescript-object\n * @example\n *   type Props = { req: number; reqUndef: number | undefined; opt?: string; optUndef?: number | undefined; };\n *\n *   // Expect: \"opt\" | \"optUndef\"\n *   type Keys = OptionalKeys<Props>;\n */\nexport type OptionalKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? K : never;\n}[keyof T];\n\n/**\n * Pick (complements Omit)\n * @desc From `T` pick a set of properties by key `K`\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *\n *   // Expect: { age: number; }\n *   type Props = Pick<Props, 'age'>;\n */\nnamespace Pick {}\n\n/**\n * PickByValue\n * @desc From `T` pick a set of properties by value matching `ValueType`.\n * Credit: [Piotr Lewandowski](https://medium.com/dailyjs/typescript-create-a-condition-based-subset-types-9d902cea5b8c)\n * @example\n *   type Props = { req: number; reqUndef: number | undefined; opt?: string; };\n *\n *   // Expect: { req: number }\n *   type Props = PickByValue<Props, number>;\n *   // Expect: { req: number; reqUndef: number | undefined; }\n *   type Props = PickByValue<Props, number | undefined>;\n */\nexport type PickByValue<T, ValueType> = Pick<\n  T,\n  { [Key in keyof T]-?: T[Key] extends ValueType ? Key : never }[keyof T]\n>;\n\n/**\n * PickByValueExact\n * @desc From `T` pick a set of properties by value matching exact `ValueType`.\n * @example\n *   type Props = { req: number; reqUndef: number | undefined; opt?: string; };\n *\n *   // Expect: { req: number }\n *   type Props = PickByValueExact<Props, number>;\n *   // Expect: { reqUndef: number | undefined; }\n *   type Props = PickByValueExact<Props, number | undefined>;\n */\nexport type PickByValueExact<T, ValueType> = Pick<\n  T,\n  {\n    [Key in keyof T]-?: [ValueType] extends [T[Key]]\n      ? [T[Key]] extends [ValueType]\n        ? Key\n        : never\n      : never;\n  }[keyof T]\n>;\n\n/**\n * Omit (complements Pick)\n * @desc From `T` remove a set of properties by key `K`\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *\n *   // Expect: { name: string; visible: boolean; }\n *   type Props = Omit<Props, 'age'>;\n */\nexport type Omit<T, K extends keyof any> = Pick<T, SetDifference<keyof T, K>>;\n\n/**\n * OmitByValue\n * @desc From `T` remove a set of properties by value matching `ValueType`.\n * Credit: [Piotr Lewandowski](https://medium.com/dailyjs/typescript-create-a-condition-based-subset-types-9d902cea5b8c)\n * @example\n *   type Props = { req: number; reqUndef: number | undefined; opt?: string; };\n *\n *   // Expect: { reqUndef: number | undefined; opt?: string; }\n *   type Props = OmitByValue<Props, number>;\n *   // Expect: { opt?: string; }\n *   type Props = OmitByValue<Props, number | undefined>;\n */\nexport type OmitByValue<T, ValueType> = Pick<\n  T,\n  { [Key in keyof T]-?: T[Key] extends ValueType ? never : Key }[keyof T]\n>;\n\n/**\n * OmitByValueExact\n * @desc From `T` remove a set of properties by value matching exact `ValueType`.\n * @example\n *   type Props = { req: number; reqUndef: number | undefined; opt?: string; };\n *\n *   // Expect: { reqUndef: number | undefined; opt?: string; }\n *   type Props = OmitByValueExact<Props, number>;\n *   // Expect: { req: number; opt?: string }\n *   type Props = OmitByValueExact<Props, number | undefined>;\n */\nexport type OmitByValueExact<T, ValueType> = Pick<\n  T,\n  {\n    [Key in keyof T]-?: [ValueType] extends [T[Key]]\n      ? [T[Key]] extends [ValueType]\n        ? never\n        : Key\n      : Key;\n  }[keyof T]\n>;\n\n/**\n * Intersection\n * @desc From `T` pick properties that exist in `U`\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *   type DefaultProps = { age: number };\n *\n *   // Expect: { age: number; }\n *   type DuplicateProps = Intersection<Props, DefaultProps>;\n */\nexport type Intersection<T extends object, U extends object> = Pick<\n  T,\n  Extract<keyof T, keyof U> & Extract<keyof U, keyof T>\n>;\n\n/**\n * Diff\n * @desc From `T` remove properties that exist in `U`\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *   type DefaultProps = { age: number };\n *\n *   // Expect: { name: string; visible: boolean; }\n *   type DiffProps = Diff<Props, DefaultProps>;\n */\nexport type Diff<T extends object, U extends object> = Pick<\n  T,\n  SetDifference<keyof T, keyof U>\n>;\n\n/**\n * Subtract\n * @desc From `T` remove properties that exist in `T1` (`T1` has a subset of the properties of `T`)\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *   type DefaultProps = { age: number };\n *\n *   // Expect: { name: string; visible: boolean; }\n *   type RestProps = Subtract<Props, DefaultProps>;\n */\nexport type Subtract<T extends T1, T1 extends object> = Pick<\n  T,\n  SetComplement<keyof T, keyof T1>\n>;\n\n/**\n * Overwrite\n * @desc From `U` overwrite properties to `T`\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *   type NewProps = { age: string; other: string };\n *\n *   // Expect: { name: string; age: string; visible: boolean; }\n *   type ReplacedProps = Overwrite<Props, NewProps>;\n */\nexport type Overwrite<\n  T extends object,\n  U extends object,\n  I = Diff<T, U> & Intersection<U, T>\n> = Pick<I, keyof I>;\n\n/**\n * Assign\n * @desc From `U` assign properties to `T` (just like object assign)\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *   type NewProps = { age: string; other: string };\n *\n *   // Expect: { name: string; age: number; visible: boolean; other: string; }\n *   type ExtendedProps = Assign<Props, NewProps>;\n */\nexport type Assign<\n  T extends object,\n  U extends object,\n  I = Diff<T, U> & Intersection<U, T> & Diff<U, T>\n> = Pick<I, keyof I>;\n\n/**\n * Exact\n * @desc Create branded object type for exact type matching\n */\nexport type Exact<A extends object> = A & { __brand: keyof A };\n\n/**\n * Unionize\n * @desc Disjoin object to form union of objects, each with single property\n * @example\n *   type Props = { name: string; age: number; visible: boolean };\n *\n *   // Expect: { name: string; } | { age: number; } | { visible: boolean; }\n *   type UnionizedType = Unionize<Props>;\n */\nexport type Unionize<T extends object> = {\n  [P in keyof T]: { [Q in P]: T[P] };\n}[keyof T];\n\n/**\n * PromiseType\n * @desc Obtain Promise resolve type\n * @example\n *   // Expect: string;\n *   type Response = PromiseType<Promise<string>>;\n */\nexport type PromiseType<T extends Promise<any>> = T extends Promise<infer U>\n  ? U\n  : never;\n\n// TODO: inline _DeepReadonlyArray with infer in DeepReadonly, same for all other deep types\n/**\n * DeepReadonly\n * @desc Readonly that works for deeply nested structure\n * @example\n *   // Expect: {\n *   //   readonly first: {\n *   //     readonly second: {\n *   //       readonly name: string;\n *   //     };\n *   //   };\n *   // }\n *   type NestedProps = {\n *     first: {\n *       second: {\n *         name: string;\n *       };\n *     };\n *   };\n *   type ReadonlyNestedProps = DeepReadonly<NestedProps>;\n */\nexport type DeepReadonly<T> = T extends ((...args: any[]) => any) | Primitive\n  ? T\n  : T extends _DeepReadonlyArray<infer U>\n  ? _DeepReadonlyArray<U>\n  : T extends _DeepReadonlyObject<infer V>\n  ? _DeepReadonlyObject<V>\n  : T;\n/** @private */\n// tslint:disable-next-line:class-name\nexport interface _DeepReadonlyArray<T> extends ReadonlyArray<DeepReadonly<T>> {}\n/** @private */\nexport type _DeepReadonlyObject<T> = {\n  readonly [P in keyof T]: DeepReadonly<T[P]>;\n};\n\n/**\n * DeepRequired\n * @desc Required that works for deeply nested structure\n * @example\n *   // Expect: {\n *   //   first: {\n *   //     second: {\n *   //       name: string;\n *   //     };\n *   //   };\n *   // }\n *   type NestedProps = {\n *     first?: {\n *       second?: {\n *         name?: string;\n *       };\n *     };\n *   };\n *   type RequiredNestedProps = DeepRequired<NestedProps>;\n */\nexport type DeepRequired<T> = T extends (...args: any[]) => any\n  ? T\n  : T extends any[]\n  ? _DeepRequiredArray<T[number]>\n  : T extends object\n  ? _DeepRequiredObject<T>\n  : T;\n/** @private */\n// tslint:disable-next-line:class-name\nexport interface _DeepRequiredArray<T>\n  extends Array<DeepRequired<NonUndefined<T>>> {}\n/** @private */\nexport type _DeepRequiredObject<T> = {\n  [P in keyof T]-?: DeepRequired<NonUndefined<T[P]>>;\n};\n\n/**\n * DeepNonNullable\n * @desc NonNullable that works for deeply nested structure\n * @example\n *   // Expect: {\n *   //   first: {\n *   //     second: {\n *   //       name: string;\n *   //     };\n *   //   };\n *   // }\n *   type NestedProps = {\n *     first?: null | {\n *       second?: null | {\n *         name?: string | null |\n *         undefined;\n *       };\n *     };\n *   };\n *   type RequiredNestedProps = DeepNonNullable<NestedProps>;\n */\nexport type DeepNonNullable<T> = T extends (...args: any[]) => any\n  ? T\n  : T extends any[]\n  ? _DeepNonNullableArray<T[number]>\n  : T extends object\n  ? _DeepNonNullableObject<T>\n  : T;\n/** @private */\n// tslint:disable-next-line:class-name\nexport interface _DeepNonNullableArray<T>\n  extends Array<DeepNonNullable<NonNullable<T>>> {}\n/** @private */\nexport type _DeepNonNullableObject<T> = {\n  [P in keyof T]-?: DeepNonNullable<NonNullable<T[P]>>;\n};\n\n/**\n * DeepPartial\n * @desc Partial that works for deeply nested structure\n * @example\n *   // Expect: {\n *   //   first?: {\n *   //     second?: {\n *   //       name?: string;\n *   //     };\n *   //   };\n *   // }\n *   type NestedProps = {\n *     first: {\n *       second: {\n *         name: string;\n *       };\n *     };\n *   };\n *   type PartialNestedProps = DeepPartial<NestedProps>;\n */\nexport type DeepPartial<T> = T extends Function\n  ? T\n  : T extends Array<infer U>\n  ? _DeepPartialArray<U>\n  : T extends object\n  ? _DeepPartialObject<T>\n  : T | undefined;\n/** @private */\n// tslint:disable-next-line:class-name\nexport interface _DeepPartialArray<T> extends Array<DeepPartial<T>> {}\n/** @private */\nexport type _DeepPartialObject<T> = { [P in keyof T]?: DeepPartial<T[P]> };\n\n/**\n * Brand\n * @desc Define nominal type of U based on type of T. Similar to Opaque types in Flow.\n * @example\n *   type USD = Brand<number, \"USD\">\n *   type EUR = Brand<number, \"EUR\">\n *\n *   const tax = 5 as USD;\n *   const usd = 10 as USD;\n *   const eur = 10 as EUR;\n *\n *   function gross(net: USD): USD {\n *     return (net + tax) as USD;\n *   }\n *\n *   // Expect: No compile error\n *   gross(usd);\n *   // Expect: Compile error (Type '\"EUR\"' is not assignable to type '\"USD\"'.)\n *   gross(eur);\n */\nexport type Brand<T, U> = T & { __brand: U };\n\n/**\n * Optional\n * @desc From `T` make a set of properties by key `K` become optional\n * @example\n *    type Props = {\n *      name: string;\n *      age: number;\n *      visible: boolean;\n *    };\n *\n *    // Expect: { name?: string; age?: number; visible?: boolean; }\n *    type Props = Optional<Props>;\n *\n *    // Expect: { name: string; age?: number; visible?: boolean; }\n *    type Props = Optional<Props, 'age' | 'visible'>;\n */\nexport type Optional<T extends object, K extends keyof T = keyof T> = Omit<\n  T,\n  K\n> &\n  Partial<Pick<T, K>>;\n\n/**\n * ValuesType\n * @desc Get the union type of all the values in an object, array or array-like type `T`\n * @example\n *    type Props = { name: string; age: number; visible: boolean };\n *    // Expect: string | number | boolean\n *    type PropsValues = ValuesType<Props>;\n *\n *    type NumberArray = number[];\n *    // Expect: number\n *    type NumberItems = ValuesType<NumberArray>;\n *\n *    type ReadonlySymbolArray = readonly symbol[];\n *    // Expect: symbol\n *    type SymbolItems = ValuesType<ReadonlySymbolArray>;\n *\n *    type NumberTuple = [1, 2];\n *    // Expect: 1 | 2\n *    type NumberUnion = ValuesType<NumberTuple>;\n *\n *    type ReadonlyNumberTuple = readonly [1, 2];\n *    // Expect: 1 | 2\n *    type AnotherNumberUnion = ValuesType<NumberTuple>;\n *\n *    type BinaryArray = Uint8Array;\n *    // Expect: number\n *    type BinaryItems = ValuesType<BinaryArray>;\n */\nexport type ValuesType<\n  T extends ReadonlyArray<any> | ArrayLike<any> | Record<any, any>\n> = T extends ReadonlyArray<any>\n  ? T[number]\n  : T extends ArrayLike<any>\n  ? T[number]\n  : T extends object\n  ? T[keyof T]\n  : never;\n\n/**\n * Required\n * @desc From `T` make a set of properties by key `K` become required\n * @example\n *    type Props = {\n *      name?: string;\n *      age?: number;\n *      visible?: boolean;\n *    };\n *\n *    // Expect: { name: string; age: number; visible: boolean; }\n *    type Props = Required<Props>;\n *\n *    // Expect: { name?: string; age: number; visible: boolean; }\n *    type Props = Required<Props, 'age' | 'visible'>;\n */\nexport type AugmentedRequired<\n  T extends object,\n  K extends keyof T = keyof T\n> = Omit<T, K> & Required<Pick<T, K>>;\n\n/**\n * UnionToIntersection\n * @desc Get intersection type given union type `U`\n * Credit: jcalz\n * @see https://stackoverflow.com/a/50375286/7381355\n * @example\n *   // Expect: { name: string } & { age: number } & { visible: boolean }\n *   UnionToIntersection<{ name: string } | { age: number } | { visible: boolean }>\n */\nexport type UnionToIntersection<U> = (U extends any\n? (k: U) => void\n: never) extends (k: infer I) => void\n  ? I\n  : never;\n\n/**\n * Mutable\n * @desc From `T` make all properties become mutable\n * @example\n *    type Props = {\n *      readonly name: string;\n *      readonly age: number;\n *      readonly visible: boolean;\n *    };\n *\n *    // Expect: { name: string; age: number; visible: boolean; }\n *    Mutable<Props>;\n */\nexport type Mutable<T> = { -readonly [P in keyof T]: T[P] };\nexport type Writable<T> = Mutable<T>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n",normalizedContent:"# 目录\n\n\n\n * 目录\n\n\n\n/**\n * setintersection (same as extract)\n * @desc set intersection of given union types `a` and `b`\n * @example\n *   // expect: \"2\" | \"3\"\n *   setintersection<'1' | '2' | '3', '2' | '3' | '4'>;\n *\n *   // expect: () => void\n *   setintersection<string | number | (() => void), function>;\n */\nexport type setintersection<a, b> = a extends b ? a : never;\n\n/**\n * setdifference (same as exclude)\n * @desc set difference of given union types `a` and `b`\n * @example\n *   // expect: \"1\"\n *   setdifference<'1' | '2' | '3', '2' | '3' | '4'>;\n *\n *   // expect: string | number\n *   setdifference<string | number | (() => void), function>;\n */\nexport type setdifference<a, b> = a extends b ? never : a;\n\n/**\n * setcomplement\n * @desc set complement of given union types `a` and (it's subset) `a1`\n * @example\n *   // expect: \"1\"\n *   setcomplement<'1' | '2' | '3', '2' | '3'>;\n */\nexport type setcomplement<a, a1 extends a> = setdifference<a, a1>;\n\n/**\n * symmetricdifference\n * @desc set difference of union and intersection of given union types `a` and `b`\n * @example\n *   // expect: \"1\" | \"4\"\n *   symmetricdifference<'1' | '2' | '3', '2' | '3' | '4'>;\n */\nexport type symmetricdifference<a, b> = setdifference<a | b, a & b>;\n\n/**\n * nonundefined\n * @desc exclude undefined from set `a`\n * @example\n *   // expect: \"string | null\"\n *   symmetricdifference<string | null | undefined>;\n */\nexport type nonundefined<a> = a extends undefined ? never : a;\n\n/**\n * nonnullable\n * @desc exclude undefined and null from set `a`\n * @example\n *   // expect: \"string\"\n *   symmetricdifference<string | null | undefined>;\n */\n// type nonnullable - built-in\n\n/**\n * functionkeys\n * @desc get union type of keys that are functions in object type `t`\n * @example\n *  type mixedprops = {name: string; setname: (name: string) => void; somekeys?: string; somefn?: (...args: any) => any;};\n *\n *   // expect: \"setname | somefn\"\n *   type keys = functionkeys<mixedprops>;\n */\nexport type functionkeys<t extends object> = {\n  [k in keyof t]-?: nonundefined<t[k]> extends function ? k : never;\n}[keyof t];\n\n/**\n * nonfunctionkeys\n * @desc get union type of keys that are non-functions in object type `t`\n * @example\n *   type mixedprops = {name: string; setname: (name: string) => void; somekeys?: string; somefn?: (...args: any) => any;};\n *\n *   // expect: \"name | somekey\"\n *   type keys = nonfunctionkeys<mixedprops>;\n */\nexport type nonfunctionkeys<t extends object> = {\n  [k in keyof t]-?: nonundefined<t[k]> extends function ? never : k;\n}[keyof t];\n\n/**\n * mutablekeys\n * @desc get union type of keys that are mutable in object type `t`\n * credit: matt mccutchen\n * https://stackoverflow.com/questions/52443276/how-to-exclude-getter-only-properties-from-type-in-typescript\n * @example\n *   type props = { readonly foo: string; bar: number };\n *\n *   // expect: \"bar\"\n *   type keys = mutablekeys<props>;\n */\nexport type mutablekeys<t extends object> = {\n  [p in keyof t]-?: ifequals<\n    { [q in p]: t[p] },\n    { -readonly [q in p]: t[p] },\n    p\n  >;\n}[keyof t];\nexport type writablekeys<t extends object> = mutablekeys<t>;\n\n/**\n * readonlykeys\n * @desc get union type of keys that are readonly in object type `t`\n * credit: matt mccutchen\n * https://stackoverflow.com/questions/52443276/how-to-exclude-getter-only-properties-from-type-in-typescript\n * @example\n *   type props = { readonly foo: string; bar: number };\n *\n *   // expect: \"foo\"\n *   type keys = readonlykeys<props>;\n */\nexport type readonlykeys<t extends object> = {\n  [p in keyof t]-?: ifequals<\n    { [q in p]: t[p] },\n    { -readonly [q in p]: t[p] },\n    never,\n    p\n  >;\n}[keyof t];\n\ntype ifequals<x, y, a = x, b = never> = (<t>() => t extends x ? 1 : 2) extends <\n  t\n>() => t extends y ? 1 : 2\n  ? a\n  : b;\n\n/**\n * requiredkeys\n * @desc get union type of keys that are required in object type `t`\n * @see https://stackoverflow.com/questions/52984808/is-there-a-way-to-get-all-required-properties-of-a-typescript-object\n * @example\n *   type props = { req: number; requndef: number | undefined; opt?: string; optundef?: number | undefined; };\n *\n *   // expect: \"req\" | \"requndef\"\n *   type keys = requiredkeys<props>;\n */\nexport type requiredkeys<t> = {\n  [k in keyof t]-?: {} extends pick<t, k> ? never : k;\n}[keyof t];\n\n/**\n * optionalkeys\n * @desc get union type of keys that are optional in object type `t`\n * @see https://stackoverflow.com/questions/52984808/is-there-a-way-to-get-all-required-properties-of-a-typescript-object\n * @example\n *   type props = { req: number; requndef: number | undefined; opt?: string; optundef?: number | undefined; };\n *\n *   // expect: \"opt\" | \"optundef\"\n *   type keys = optionalkeys<props>;\n */\nexport type optionalkeys<t> = {\n  [k in keyof t]-?: {} extends pick<t, k> ? k : never;\n}[keyof t];\n\n/**\n * pick (complements omit)\n * @desc from `t` pick a set of properties by key `k`\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *\n *   // expect: { age: number; }\n *   type props = pick<props, 'age'>;\n */\nnamespace pick {}\n\n/**\n * pickbyvalue\n * @desc from `t` pick a set of properties by value matching `valuetype`.\n * credit: [piotr lewandowski](https://medium.com/dailyjs/typescript-create-a-condition-based-subset-types-9d902cea5b8c)\n * @example\n *   type props = { req: number; requndef: number | undefined; opt?: string; };\n *\n *   // expect: { req: number }\n *   type props = pickbyvalue<props, number>;\n *   // expect: { req: number; requndef: number | undefined; }\n *   type props = pickbyvalue<props, number | undefined>;\n */\nexport type pickbyvalue<t, valuetype> = pick<\n  t,\n  { [key in keyof t]-?: t[key] extends valuetype ? key : never }[keyof t]\n>;\n\n/**\n * pickbyvalueexact\n * @desc from `t` pick a set of properties by value matching exact `valuetype`.\n * @example\n *   type props = { req: number; requndef: number | undefined; opt?: string; };\n *\n *   // expect: { req: number }\n *   type props = pickbyvalueexact<props, number>;\n *   // expect: { requndef: number | undefined; }\n *   type props = pickbyvalueexact<props, number | undefined>;\n */\nexport type pickbyvalueexact<t, valuetype> = pick<\n  t,\n  {\n    [key in keyof t]-?: [valuetype] extends [t[key]]\n      ? [t[key]] extends [valuetype]\n        ? key\n        : never\n      : never;\n  }[keyof t]\n>;\n\n/**\n * omit (complements pick)\n * @desc from `t` remove a set of properties by key `k`\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *\n *   // expect: { name: string; visible: boolean; }\n *   type props = omit<props, 'age'>;\n */\nexport type omit<t, k extends keyof any> = pick<t, setdifference<keyof t, k>>;\n\n/**\n * omitbyvalue\n * @desc from `t` remove a set of properties by value matching `valuetype`.\n * credit: [piotr lewandowski](https://medium.com/dailyjs/typescript-create-a-condition-based-subset-types-9d902cea5b8c)\n * @example\n *   type props = { req: number; requndef: number | undefined; opt?: string; };\n *\n *   // expect: { requndef: number | undefined; opt?: string; }\n *   type props = omitbyvalue<props, number>;\n *   // expect: { opt?: string; }\n *   type props = omitbyvalue<props, number | undefined>;\n */\nexport type omitbyvalue<t, valuetype> = pick<\n  t,\n  { [key in keyof t]-?: t[key] extends valuetype ? never : key }[keyof t]\n>;\n\n/**\n * omitbyvalueexact\n * @desc from `t` remove a set of properties by value matching exact `valuetype`.\n * @example\n *   type props = { req: number; requndef: number | undefined; opt?: string; };\n *\n *   // expect: { requndef: number | undefined; opt?: string; }\n *   type props = omitbyvalueexact<props, number>;\n *   // expect: { req: number; opt?: string }\n *   type props = omitbyvalueexact<props, number | undefined>;\n */\nexport type omitbyvalueexact<t, valuetype> = pick<\n  t,\n  {\n    [key in keyof t]-?: [valuetype] extends [t[key]]\n      ? [t[key]] extends [valuetype]\n        ? never\n        : key\n      : key;\n  }[keyof t]\n>;\n\n/**\n * intersection\n * @desc from `t` pick properties that exist in `u`\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *   type defaultprops = { age: number };\n *\n *   // expect: { age: number; }\n *   type duplicateprops = intersection<props, defaultprops>;\n */\nexport type intersection<t extends object, u extends object> = pick<\n  t,\n  extract<keyof t, keyof u> & extract<keyof u, keyof t>\n>;\n\n/**\n * diff\n * @desc from `t` remove properties that exist in `u`\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *   type defaultprops = { age: number };\n *\n *   // expect: { name: string; visible: boolean; }\n *   type diffprops = diff<props, defaultprops>;\n */\nexport type diff<t extends object, u extends object> = pick<\n  t,\n  setdifference<keyof t, keyof u>\n>;\n\n/**\n * subtract\n * @desc from `t` remove properties that exist in `t1` (`t1` has a subset of the properties of `t`)\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *   type defaultprops = { age: number };\n *\n *   // expect: { name: string; visible: boolean; }\n *   type restprops = subtract<props, defaultprops>;\n */\nexport type subtract<t extends t1, t1 extends object> = pick<\n  t,\n  setcomplement<keyof t, keyof t1>\n>;\n\n/**\n * overwrite\n * @desc from `u` overwrite properties to `t`\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *   type newprops = { age: string; other: string };\n *\n *   // expect: { name: string; age: string; visible: boolean; }\n *   type replacedprops = overwrite<props, newprops>;\n */\nexport type overwrite<\n  t extends object,\n  u extends object,\n  i = diff<t, u> & intersection<u, t>\n> = pick<i, keyof i>;\n\n/**\n * assign\n * @desc from `u` assign properties to `t` (just like object assign)\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *   type newprops = { age: string; other: string };\n *\n *   // expect: { name: string; age: number; visible: boolean; other: string; }\n *   type extendedprops = assign<props, newprops>;\n */\nexport type assign<\n  t extends object,\n  u extends object,\n  i = diff<t, u> & intersection<u, t> & diff<u, t>\n> = pick<i, keyof i>;\n\n/**\n * exact\n * @desc create branded object type for exact type matching\n */\nexport type exact<a extends object> = a & { __brand: keyof a };\n\n/**\n * unionize\n * @desc disjoin object to form union of objects, each with single property\n * @example\n *   type props = { name: string; age: number; visible: boolean };\n *\n *   // expect: { name: string; } | { age: number; } | { visible: boolean; }\n *   type unionizedtype = unionize<props>;\n */\nexport type unionize<t extends object> = {\n  [p in keyof t]: { [q in p]: t[p] };\n}[keyof t];\n\n/**\n * promisetype\n * @desc obtain promise resolve type\n * @example\n *   // expect: string;\n *   type response = promisetype<promise<string>>;\n */\nexport type promisetype<t extends promise<any>> = t extends promise<infer u>\n  ? u\n  : never;\n\n// todo: inline _deepreadonlyarray with infer in deepreadonly, same for all other deep types\n/**\n * deepreadonly\n * @desc readonly that works for deeply nested structure\n * @example\n *   // expect: {\n *   //   readonly first: {\n *   //     readonly second: {\n *   //       readonly name: string;\n *   //     };\n *   //   };\n *   // }\n *   type nestedprops = {\n *     first: {\n *       second: {\n *         name: string;\n *       };\n *     };\n *   };\n *   type readonlynestedprops = deepreadonly<nestedprops>;\n */\nexport type deepreadonly<t> = t extends ((...args: any[]) => any) | primitive\n  ? t\n  : t extends _deepreadonlyarray<infer u>\n  ? _deepreadonlyarray<u>\n  : t extends _deepreadonlyobject<infer v>\n  ? _deepreadonlyobject<v>\n  : t;\n/** @private */\n// tslint:disable-next-line:class-name\nexport interface _deepreadonlyarray<t> extends readonlyarray<deepreadonly<t>> {}\n/** @private */\nexport type _deepreadonlyobject<t> = {\n  readonly [p in keyof t]: deepreadonly<t[p]>;\n};\n\n/**\n * deeprequired\n * @desc required that works for deeply nested structure\n * @example\n *   // expect: {\n *   //   first: {\n *   //     second: {\n *   //       name: string;\n *   //     };\n *   //   };\n *   // }\n *   type nestedprops = {\n *     first?: {\n *       second?: {\n *         name?: string;\n *       };\n *     };\n *   };\n *   type requirednestedprops = deeprequired<nestedprops>;\n */\nexport type deeprequired<t> = t extends (...args: any[]) => any\n  ? t\n  : t extends any[]\n  ? _deeprequiredarray<t[number]>\n  : t extends object\n  ? _deeprequiredobject<t>\n  : t;\n/** @private */\n// tslint:disable-next-line:class-name\nexport interface _deeprequiredarray<t>\n  extends array<deeprequired<nonundefined<t>>> {}\n/** @private */\nexport type _deeprequiredobject<t> = {\n  [p in keyof t]-?: deeprequired<nonundefined<t[p]>>;\n};\n\n/**\n * deepnonnullable\n * @desc nonnullable that works for deeply nested structure\n * @example\n *   // expect: {\n *   //   first: {\n *   //     second: {\n *   //       name: string;\n *   //     };\n *   //   };\n *   // }\n *   type nestedprops = {\n *     first?: null | {\n *       second?: null | {\n *         name?: string | null |\n *         undefined;\n *       };\n *     };\n *   };\n *   type requirednestedprops = deepnonnullable<nestedprops>;\n */\nexport type deepnonnullable<t> = t extends (...args: any[]) => any\n  ? t\n  : t extends any[]\n  ? _deepnonnullablearray<t[number]>\n  : t extends object\n  ? _deepnonnullableobject<t>\n  : t;\n/** @private */\n// tslint:disable-next-line:class-name\nexport interface _deepnonnullablearray<t>\n  extends array<deepnonnullable<nonnullable<t>>> {}\n/** @private */\nexport type _deepnonnullableobject<t> = {\n  [p in keyof t]-?: deepnonnullable<nonnullable<t[p]>>;\n};\n\n/**\n * deeppartial\n * @desc partial that works for deeply nested structure\n * @example\n *   // expect: {\n *   //   first?: {\n *   //     second?: {\n *   //       name?: string;\n *   //     };\n *   //   };\n *   // }\n *   type nestedprops = {\n *     first: {\n *       second: {\n *         name: string;\n *       };\n *     };\n *   };\n *   type partialnestedprops = deeppartial<nestedprops>;\n */\nexport type deeppartial<t> = t extends function\n  ? t\n  : t extends array<infer u>\n  ? _deeppartialarray<u>\n  : t extends object\n  ? _deeppartialobject<t>\n  : t | undefined;\n/** @private */\n// tslint:disable-next-line:class-name\nexport interface _deeppartialarray<t> extends array<deeppartial<t>> {}\n/** @private */\nexport type _deeppartialobject<t> = { [p in keyof t]?: deeppartial<t[p]> };\n\n/**\n * brand\n * @desc define nominal type of u based on type of t. similar to opaque types in flow.\n * @example\n *   type usd = brand<number, \"usd\">\n *   type eur = brand<number, \"eur\">\n *\n *   const tax = 5 as usd;\n *   const usd = 10 as usd;\n *   const eur = 10 as eur;\n *\n *   function gross(net: usd): usd {\n *     return (net + tax) as usd;\n *   }\n *\n *   // expect: no compile error\n *   gross(usd);\n *   // expect: compile error (type '\"eur\"' is not assignable to type '\"usd\"'.)\n *   gross(eur);\n */\nexport type brand<t, u> = t & { __brand: u };\n\n/**\n * optional\n * @desc from `t` make a set of properties by key `k` become optional\n * @example\n *    type props = {\n *      name: string;\n *      age: number;\n *      visible: boolean;\n *    };\n *\n *    // expect: { name?: string; age?: number; visible?: boolean; }\n *    type props = optional<props>;\n *\n *    // expect: { name: string; age?: number; visible?: boolean; }\n *    type props = optional<props, 'age' | 'visible'>;\n */\nexport type optional<t extends object, k extends keyof t = keyof t> = omit<\n  t,\n  k\n> &\n  partial<pick<t, k>>;\n\n/**\n * valuestype\n * @desc get the union type of all the values in an object, array or array-like type `t`\n * @example\n *    type props = { name: string; age: number; visible: boolean };\n *    // expect: string | number | boolean\n *    type propsvalues = valuestype<props>;\n *\n *    type numberarray = number[];\n *    // expect: number\n *    type numberitems = valuestype<numberarray>;\n *\n *    type readonlysymbolarray = readonly symbol[];\n *    // expect: symbol\n *    type symbolitems = valuestype<readonlysymbolarray>;\n *\n *    type numbertuple = [1, 2];\n *    // expect: 1 | 2\n *    type numberunion = valuestype<numbertuple>;\n *\n *    type readonlynumbertuple = readonly [1, 2];\n *    // expect: 1 | 2\n *    type anothernumberunion = valuestype<numbertuple>;\n *\n *    type binaryarray = uint8array;\n *    // expect: number\n *    type binaryitems = valuestype<binaryarray>;\n */\nexport type valuestype<\n  t extends readonlyarray<any> | arraylike<any> | record<any, any>\n> = t extends readonlyarray<any>\n  ? t[number]\n  : t extends arraylike<any>\n  ? t[number]\n  : t extends object\n  ? t[keyof t]\n  : never;\n\n/**\n * required\n * @desc from `t` make a set of properties by key `k` become required\n * @example\n *    type props = {\n *      name?: string;\n *      age?: number;\n *      visible?: boolean;\n *    };\n *\n *    // expect: { name: string; age: number; visible: boolean; }\n *    type props = required<props>;\n *\n *    // expect: { name?: string; age: number; visible: boolean; }\n *    type props = required<props, 'age' | 'visible'>;\n */\nexport type augmentedrequired<\n  t extends object,\n  k extends keyof t = keyof t\n> = omit<t, k> & required<pick<t, k>>;\n\n/**\n * uniontointersection\n * @desc get intersection type given union type `u`\n * credit: jcalz\n * @see https://stackoverflow.com/a/50375286/7381355\n * @example\n *   // expect: { name: string } & { age: number } & { visible: boolean }\n *   uniontointersection<{ name: string } | { age: number } | { visible: boolean }>\n */\nexport type uniontointersection<u> = (u extends any\n? (k: u) => void\n: never) extends (k: infer i) => void\n  ? i\n  : never;\n\n/**\n * mutable\n * @desc from `t` make all properties become mutable\n * @example\n *    type props = {\n *      readonly name: string;\n *      readonly age: number;\n *      readonly visible: boolean;\n *    };\n *\n *    // expect: { name: string; age: number; visible: boolean; }\n *    mutable<props>;\n */\nexport type mutable<t> = { -readonly [p in keyof t]: t[p] };\nexport type writable<t> = mutable<t>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"开始阅读",frontmatter:{title:"开始阅读",date:"2022-04-14T22:02:21.000Z",permalink:"/single-spa/index/",categories:["single-spa"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/0.index.html",relativePath:"30.web/5.single-spa源码/0.index.md",key:"v-1ba4b31b",path:"/single-spa/index/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"内容",slug:"内容",normalizedTitle:"内容",charIndex:234},{level:2,title:"声明",slug:"声明",normalizedTitle:"声明",charIndex:634},{level:2,title:"前提",slug:"前提",normalizedTitle:"前提",charIndex:849},{level:2,title:"微前端",slug:"微前端",normalizedTitle:"微前端",charIndex:50},{level:3,title:"微前端类型",slug:"微前端类型",normalizedTitle:"微前端类型",charIndex:938},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1167}],readingTime:{text:"1 min read",minutes:.705,time:42300,words:141},headersStr:"介绍 内容 声明 前提 微前端 微前端类型 参考",content:"# 介绍\n\nSingle-spa 是一个将多个单页面应用聚合为一个整体应用的 JavaScript 微前端框架。 使用 single-spa 进行前端架构设计可以带来很多好处，例如:\n\n * 在同一页面上使用多个前端框架 而不用刷新页面 (React, AngularJS, Angular, Ember, 你正在使用的框架)。\n * 独立部署每一个单页面应用。\n * 新功能使用新框架，旧的单页应用不用重写可以共存。\n * 改善初始加载时间，延迟加载代码。\n\n\n# 内容\n\nsingle-spa 在微应用的层面做了如下的事情：\n\n * 微应用管理\n * 微应用生命周期管理\n * 路由管理\n\n我们知道只有这些功能对于构建微前端应用时远远不够的，因为还有很多核心问题没有解决。因此，qiankun 在 single-spa 的基础上做了如下的事情：\n\n * 封装、简化后的应用管理和应用生命周期（门面模式）。\n * JavaScript 沙箱：代理沙箱和快照沙箱。\n * 微应用的加载方案，模板解析、应用加载、应用钩子，支持各种 JavaScript 框架和 vanillaJS、JQuery 等。\n * CSS 沙箱方案。\n * 功能加强，如 prefetch 应用预加载、globalState 微应用、主应用（基座应用）通信方案。\n\nsingle-spa 具有很灵活的使用场景，基于 single-spa 可以封装出适合企业的各种轻量级的微前端的框架。\n\n\n# 声明\n\n在文章中可能遇到的简写：\n\n概念           简写      描述\nsingle-spa   s-spa   single-spa 框架\n微应用          应用      框架所管理的微前端子应用\n父应用、基座应用     /       加载微应用的基座应用\n\n提示\n\n您可以自由选择 qiankun源码 和 single-spa源码 的阅读顺序，这取决于您希望自顶向下还是自底向上了解微应用。\n\n\n# 前提\n\n建议您先阅读一下内容：\n\n * single-spa | 概念等微前端概念、s-spa 的设计理念等内容。\n\n\n# 微前端\n\n微前端是指存在于浏览器中的微服务。\n\n\n# 微前端类型\n\n在 single-spa 中，有以下三种微前端类型：\n\n 1. single-spa applications: 为一组特定路由渲染组件的微前端。\n\n 2. single-spa parcels: 不受路由控制，渲染组件的微前端。\n\n 3. utility modules: 非渲染组件，用于暴露共享 javascript 逻辑的微前端。\n\n一个 web 应用可能包含一种或多种类型的微前端。差异可见深入对比，我们推荐微前端类型选择。\n\n\n# 参考\n\nGetting Started with single-spa | single-spa",normalizedContent:"# 介绍\n\nsingle-spa 是一个将多个单页面应用聚合为一个整体应用的 javascript 微前端框架。 使用 single-spa 进行前端架构设计可以带来很多好处，例如:\n\n * 在同一页面上使用多个前端框架 而不用刷新页面 (react, angularjs, angular, ember, 你正在使用的框架)。\n * 独立部署每一个单页面应用。\n * 新功能使用新框架，旧的单页应用不用重写可以共存。\n * 改善初始加载时间，延迟加载代码。\n\n\n# 内容\n\nsingle-spa 在微应用的层面做了如下的事情：\n\n * 微应用管理\n * 微应用生命周期管理\n * 路由管理\n\n我们知道只有这些功能对于构建微前端应用时远远不够的，因为还有很多核心问题没有解决。因此，qiankun 在 single-spa 的基础上做了如下的事情：\n\n * 封装、简化后的应用管理和应用生命周期（门面模式）。\n * javascript 沙箱：代理沙箱和快照沙箱。\n * 微应用的加载方案，模板解析、应用加载、应用钩子，支持各种 javascript 框架和 vanillajs、jquery 等。\n * css 沙箱方案。\n * 功能加强，如 prefetch 应用预加载、globalstate 微应用、主应用（基座应用）通信方案。\n\nsingle-spa 具有很灵活的使用场景，基于 single-spa 可以封装出适合企业的各种轻量级的微前端的框架。\n\n\n# 声明\n\n在文章中可能遇到的简写：\n\n概念           简写      描述\nsingle-spa   s-spa   single-spa 框架\n微应用          应用      框架所管理的微前端子应用\n父应用、基座应用     /       加载微应用的基座应用\n\n提示\n\n您可以自由选择 qiankun源码 和 single-spa源码 的阅读顺序，这取决于您希望自顶向下还是自底向上了解微应用。\n\n\n# 前提\n\n建议您先阅读一下内容：\n\n * single-spa | 概念等微前端概念、s-spa 的设计理念等内容。\n\n\n# 微前端\n\n微前端是指存在于浏览器中的微服务。\n\n\n# 微前端类型\n\n在 single-spa 中，有以下三种微前端类型：\n\n 1. single-spa applications: 为一组特定路由渲染组件的微前端。\n\n 2. single-spa parcels: 不受路由控制，渲染组件的微前端。\n\n 3. utility modules: 非渲染组件，用于暴露共享 javascript 逻辑的微前端。\n\n一个 web 应用可能包含一种或多种类型的微前端。差异可见深入对比，我们推荐微前端类型选择。\n\n\n# 参考\n\ngetting started with single-spa | single-spa",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"本章概要",frontmatter:{title:"本章概要",date:"2022-04-14T22:02:21.000Z",permalink:"/single-spa/app/index/",categories:["single-spa","app"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/10.app%E4%B8%8E%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/0.index.html",relativePath:"30.web/5.single-spa源码/10.app与应用管理/0.index.md",key:"v-6b7f390c",path:"/single-spa/app/index/",readingTime:{text:"0 min read",minutes:0,time:0,words:0},headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"Apps",frontmatter:{title:"Apps",date:"2022-04-14T22:02:21.000Z",permalink:"/single-spa/app/apps/",categories:["single-spa","app"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/10.app%E4%B8%8E%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/10.apps.html",relativePath:"30.web/5.single-spa源码/10.app与应用管理/10.apps.md",key:"v-3bded94c",path:"/single-spa/app/apps/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:125},{level:2,title:"registerApplication",slug:"registerapplication",normalizedTitle:"registerapplication",charIndex:140},{level:2,title:"unregisterApplication",slug:"unregisterapplication",normalizedTitle:"unregisterapplication",charIndex:163},{level:2,title:"unloadApplication",slug:"unloadapplication",normalizedTitle:"unloadapplication",charIndex:188},{level:2,title:"immediatelyUnloadApp",slug:"immediatelyunloadapp",normalizedTitle:"immediatelyunloadapp",charIndex:209},{level:2,title:"getAppNames",slug:"getappnames",normalizedTitle:"getappnames",charIndex:233},{level:2,title:"getMountedApps",slug:"getmountedapps",normalizedTitle:"getmountedapps",charIndex:248},{level:2,title:"getAppStatus",slug:"getappstatus",normalizedTitle:"getappstatus",charIndex:266},{level:2,title:"checkActivityFunctions",slug:"checkactivityfunctions",normalizedTitle:"checkactivityfunctions",charIndex:282},{level:2,title:"pathToActiveWhen",slug:"pathtoactivewhen",normalizedTitle:"pathtoactivewhen",charIndex:308},{level:2,title:"toDynamicPathValidatorRegex",slug:"todynamicpathvalidatorregex",normalizedTitle:"todynamicpathvalidatorregex",charIndex:328},{level:2,title:"getAppChanges",slug:"getappchanges",normalizedTitle:"getappchanges",charIndex:359},{level:2,title:"globalTimeoutConfig",slug:"globaltimeoutconfig",normalizedTitle:"globaltimeoutconfig",charIndex:376},{level:2,title:"start",slug:"start",normalizedTitle:"start",charIndex:399}],excerpt:'<Badges :content="[]" />\n<TimeToRead />\n<p>本节讲解 single-spa 的顶层 API（应用层 API），从整体了解 s-spa 中应用管理的部分的原理，包括应用 register、unregister、unload 等，初步了解 s-spa 中应用的生命周期脉络，方便后文深入。</p>\n',readingTime:{text:"8 min read",minutes:7.155,time:429300,words:1431},headersStr:"目录 registerApplication unregisterApplication unloadApplication immediatelyUnloadApp getAppNames getMountedApps getAppStatus checkActivityFunctions pathToActiveWhen toDynamicPathValidatorRegex getAppChanges globalTimeoutConfig start",content:'本节讲解 single-spa 的顶层 API（应用层 API），从整体了解 s-spa 中应用管理的部分的原理，包括应用 register、unregister、unload 等，初步了解 s-spa 中应用的生命周期脉络，方便后文深入。\n\n\n# 目录\n\n\n\n * 目录\n * registerApplication\n * unregisterApplication\n * unloadApplication\n * immediatelyUnloadApp\n * getAppNames\n * getMountedApps\n * getAppStatus\n * checkActivityFunctions\n * pathToActiveWhen\n * toDynamicPathValidatorRegex\n * getAppChanges\n * globalTimeoutConfig\n * start\n\n\n\n以下代码位置： src/applications/apps.js\n\n\n# registerApplication\n\nregisterApplication 注册微应用。\n\n// src/applications/apps.js\nconst apps = [];\nexport const isInBrowser = typeof window !== "undefined";\nexport function registerApplication(\n  appNameOrConfig,\n  appOrLoadApp,\n  activeWhen,\n  customProps\n) {\n  // 参数消毒\n  const registration = sanitizeArguments(\n    appNameOrConfig,\n    appOrLoadApp,\n    activeWhen,\n    customProps\n  );\n  // 检查重复注册\n  if (getAppNames().indexOf(registration.name) !== -1)\n    throw Error(\n      formatErrorMessage(\n        21,\n        __DEV__ &&\n          `There is already an app registered with name ${registration.name}`,\n        registration.name\n      )\n    );\n  // 加入微应用列表，并合并默认配置\n  apps.push(\n    assign(\n      {\n        loadErrorTime: null,\n        status: NOT_LOADED,\n        parcels: {},\n        devtools: {\n          overlays: {\n            options: {},\n            selectors: [],\n          },\n        },\n      },\n      registration\n    )\n  );\n\n  if (isInBrowser) {\n    // 代理 jq 的路由\n    ensureJQuerySupport();\n    // 调整路由监听，初始化或者应用配置变化\n    reroute();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n 1. 参数消毒\n\nsanitizeArguments 这样的思想在设计复杂的门面 API 时可以参考，既可以过滤掉非法的参数，也可以对参数的传参行为进行加强。\n\n 2. map 与 mapper\n\nexport function getAppNames() {\n  return apps.map(toName);\n}\nexport function toName(app) {\n  return app.name;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n将 map、forEach 等传入回调函数的方法与回调本身分离开来，赋予 mapper 以一定的逻辑功能点，能够提供复用代码的目的。\n\n 3. formatErrorMessage\n\nexport function formatErrorMessage(code, msg, ...args) {\n  return `single-spa minified message #${code}: ${\n    msg ? msg + " " : ""\n  }See https://single-spa.js.org/error/?code=${code}${\n    args.length ? `&arg=${args.join("&arg=")}` : ""\n  }`;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n错误信息日志在很多框架中都有设计，可以参考各种写法，有些可能需要与官方文档向关联。但是这种把 code 耦合在逻辑代码中的做法有点不妥。\n\n\n# unregisterApplication\n\nunregisterApplication 删除微应用。\n\nexport function unregisterApplication(appName) {\n  // 未找到卸载微应用\n  if (apps.filter((app) => toName(app) === appName).length === 0) {\n    // ......\n  }\n\n  return unloadApplication(appName).then(() => {\n    // 卸载应用并且将应用从箣竹列表中删除\n    const appIndex = apps.map(toName).indexOf(appName);\n    apps.splice(appIndex, 1);\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# unloadApplication\n\nunloadApplication unload 微应用。\n\nexport function unloadApplication(appName, opts = { waitForUnmount: false }) {\n  // ......\n\n  const appUnloadInfo = getAppUnloadInfo(toName(app));\n  // 在 unload 之前需要等待应用 unmount（即等应用 unmount 之后才能 unload）\n  if (opts && opts.waitForUnmount) {\n    // We need to wait for unmount before unloading the app\n    if (appUnloadInfo) {\n      // Someone else is already waiting for this, too\n      // 应用已经正在 unload，返回这个 promise\n      return appUnloadInfo.promise;\n    } else {\n      // We\'re the first ones wanting the app to be resolved.\n      // 将应用加入到 unload 队列，并且返回这个 promise，promise 将在应用 unload 时 resolve\n      const promise = new Promise((resolve, reject) => {\n        addAppToUnload(app, () => promise, resolve, reject);\n      });\n      return promise;\n    }\n  } else {\n    /* We should unmount the app, unload it, and remount it immediately.*/\n    let resultPromise;\n    // 不必等待 unmount，直接将之 unload \n    if (appUnloadInfo) {\n      // Someone else is already waiting for this app to unload\n      resultPromise = appUnloadInfo.promise;\n      // 立即  unload 应用，因为之前已经等待式 unload，现在又立即 unload，所以将之前的 promise.resolve 传入\n      immediatelyUnloadApp(app, appUnloadInfo.resolve, appUnloadInfo.reject);\n    } else {\n      // We\'re the first ones wanting the app to be resolved.\n      // 创建 promise，在 promise 中将应用加入到 unload 列表，并立即 unload 应用\n      resultPromise = new Promise((resolve, reject) => {\n        addAppToUnload(app, () => resultPromise, resolve, reject);\n        immediatelyUnloadApp(app, resolve, reject);\n      });\n    }\n    // 返回 unload promise\n    return resultPromise;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n * 这里提出了 unmount 和 unload 的概念。之后会详细了解两者的区别。\n * 分成了四种情况，是否在 unload 之前等待 unmount、是否已经存在于 unload 列表中。可见 unload 本身应该是异步的，因此才返回一个 promise，并承诺应用 unload 时在 promise 中会 resolve。这其中 unmount 的过程是个很重要的因素，因为 unmount 的阻塞才需要区分是否去等待 unmount 的过程，才需要用 unload 的队列来管理这样一个异步的任务队列。可见这里的设计很巧妙。\n * 等待 unmount 会等待一个怎样的过程，这个过程如何借宿并且自动触发 unload，我们下文知晓。\n\n\n# immediatelyUnloadApp\n\n立即 unload 应用。\n\n在 unloadApplication 中的 waitForUnmount 为 false 时，立即 unload 应用，不用等待 unmount。\n\nfunction immediatelyUnloadApp(app, resolve, reject) {\n  toUnmountPromise(app)\n    .then(toUnloadPromise)\n    .then(() => {\n      resolve();\n      setTimeout(() => {\n        // reroute, but the unload promise is done、\n        // 宏任务：应用 unload 之后重新调整路由监听\n        reroute();\n      });\n    })\n    .catch(reject);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 按照 unload 的顺序，应该先 unmount，再 unload，两者都是异步的操作，因此采用 promise。 toUnmountPromise unmount 应用，并返回 promise； toUnloadPromise unload 应用并返回 promise。unload 之后先 resolve 整个 unload 任务，再在宏任务里调整路由监听。代码虽少，封装性很强，设计的很巧妙。全程使用 promise 替代 async/await，提升代码运行效率，同时将整个异步的任务处理的很巧妙。\n * toUnloadPromise 和 toUnmountPromise 后文详述。\n\n\n# getAppNames\n\n获取所有应用名称。\n\nexport function getAppNames() {\n  return apps.map(toName);\n}\n\n\n1\n2\n3\n\n\n\n# getMountedApps\n\ngetMountedApps 获取已经 mount 的应用。\n\nexport function isActive(app) {\n  return app.status === MOUNTED;\n}\nexport function getMountedApps() {\n  return apps.filter(isActive).map(toName);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# getAppStatus\n\n获取应用的状态。\n\nexport function getAppStatus(appName) {\n  const app = find(apps, (app) => toName(app) === appName);\n  return app ? app.status : null;\n}\n\n\n1\n2\n3\n4\n\n\n\n# checkActivityFunctions\n\n获取当前匹配到路由的应用名称。\n\nexport function checkActivityFunctions(location = window.location) {\n  return apps.filter((app) => app.activeWhen(location)).map(toName);\n}\n\n\n1\n2\n3\n\n\n\n# pathToActiveWhen\n\n将 path（正则或者 string） 转换成 activity function（ActiveWhen）。\n\nActiveWhen 支持 ActivityFunction，也支持直接传入 path，如果直接传入 path，需要内部转换为 Activity Function。\n\nexport function pathToActiveWhen(path, exactMatch) {\n  // 将 path 转换为正则\n  const regex = toDynamicPathValidatorRegex(path, exactMatch);\n  // 返回 Activity function\n  return (location) => {\n    // compatible with IE10\n    let origin = location.origin;\n    if (!origin) {\n      origin = `${location.protocol}//${location.host}`;\n    }\n    // 链接去除 origin、search string\n    const route = location.href\n      .replace(origin, "")\n      .replace(location.search, "")\n      .split("?")[0];\n    return regex.test(route);\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n下面我们来看下，如何将 path 转换为路由匹配正则表达式。\n\n\n# toDynamicPathValidatorRegex\n\nfunction toDynamicPathValidatorRegex(path, exactMatch) {\n  let lastIndex = 0,\n    inDynamic = false,\n    regexStr = "^";\n  // 无论是正则还是string 路径，都应该以 / 开头\n  if (path[0] !== "/") {\n    path = "/" + path;\n  }\n  // 解析 path\n  for (let charIndex = 0; charIndex < path.length; charIndex++) {\n    const char = path[charIndex];\n    const startOfDynamic = !inDynamic && char === ":";\n    const endOfDynamic = inDynamic && char === "/";\n    if (startOfDynamic || endOfDynamic) {\n      appendToRegex(charIndex);\n    }\n  }\n\n  appendToRegex(path.length);\n  return new RegExp(regexStr, "i");\n\n  function appendToRegex(index) {\n    const anyCharMaybeTrailingSlashRegex = "[^/]+/?";\n    const commonStringSubPath = escapeStrRegex(path.slice(lastIndex, index));\n\n    regexStr += inDynamic\n      ? anyCharMaybeTrailingSlashRegex\n      : commonStringSubPath;\n    // path 解析完毕，根据 exactMatch 补全正则\n    if (index === path.length) {\n      if (inDynamic) {\n        if (exactMatch) {\n          // Ensure exact match paths that end in a dynamic portion don\'t match\n          // urls with characters after a slash after the dynamic portion.\n          regexStr += "$";\n        }\n      } else {\n        // For exact matches, expect no more characters. Otherwise, allow\n        // any characters.\n        const suffix = exactMatch ? "" : ".*";\n\n        regexStr =\n          // use charAt instead as we could not use es6 method endsWith\n          regexStr.charAt(regexStr.length - 1) === "/"\n            ? `${regexStr}${suffix}$`\n            : `${regexStr}(/${suffix})?(#.*)?$`;\n      }\n    }\n\n    inDynamic = !inDynamic;\n    lastIndex = index;\n  }\n  // escape 正则中的特殊符号\n  function escapeStrRegex(str) {\n    // borrowed from https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js\n    return str.replace(/[|\\\\{}()[\\]^$+*?.]/g, "\\\\$&");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n这段代码将 string 或者正则的 path 转换成正则表达式，同时支持精确匹配和开头匹配。\n\n\n# getAppChanges\n\ngetAppChanges 根据路由的变化和应用的状态，对应用执行相应的变化。当路由改变后，getAppChanges 将重新评估应用的行为，将之区分为 appsToUnload , appsToUnmount , appsToLoad , appsToMount 四类。\n\nexport function getAppChanges() {\n  const appsToUnload = [],\n    appsToUnmount = [],\n    appsToLoad = [],\n    appsToMount = [];\n\n  // We re-attempt to download applications in LOAD_ERROR after a timeout of 200 milliseconds\n  const currentTime = new Date().getTime();\n  // 遍历应用执行相应的变化\n  apps.forEach((app) => {\n    // 判断应用是否应该被路由匹配上，即 active。\n    const appShouldBeActive =\n      app.status !== SKIP_BECAUSE_BROKEN && shouldBeActive(app);\n\n    switch (app.status) {\n      case LOAD_ERROR:\n        // 如果应用 load 失败，但应该被路由匹配，且失败超时 200 ms，则尝试重新排队 load 应用\n        if (appShouldBeActive && currentTime - app.loadErrorTime >= 200) {\n          appsToLoad.push(app);\n        }\n        break;\n      case NOT_LOADED:\n      case LOADING_SOURCE_CODE:\n        // 如果应用没有 load 或者正在 load 源码，而应用被匹配上了，则排队 load 应用\n        if (appShouldBeActive) {\n          appsToLoad.push(app);\n        }\n        break;\n      case NOT_BOOTSTRAPPED:\n      case NOT_MOUNTED:\n        // 如果应用还没有 bootstrap 或者 mount，应用未被路由匹配，且应用正在排队 unload，则排队 unload 应用\n        if (!appShouldBeActive && getAppUnloadInfo(toName(app))) {\n          appsToUnload.push(app);\n        } else if (appShouldBeActive) {\n          // 如果应用还没有 bootstrap 或者 mount，但是应用被匹配上，则排列 mount 应用\n          appsToMount.push(app);\n        }\n        break;\n      case MOUNTED:\n        // 如果应用已经 mount，没有被路由匹配，则排列 unmount 应用。\n        if (!appShouldBeActive) {\n          appsToUnmount.push(app);\n        }\n        break;\n      // all other statuses are ignored\n    }\n  });\n\n  return { appsToUnload, appsToUnmount, appsToLoad, appsToMount };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n这个函数是针对路由变化执行的，此函数在 reroute 中执行。总结起来就是，路由变化时应用的行为应该发生相应的变化，很像是状态模式的思想。路由捕获到匹配时：load 错误超时的应用重试、未 load 完成的尽快 load；路由失去匹配时，已经 unmount 的应用尽快 unload、尚未 unmount 的应用 尽快 unmount。\n\n这里体现出应用生命周期状态的一些细节：\n\n// registered\nexport const NOT_LOADED = "NOT_LOADED";\n// load\nexport const LOADING_SOURCE_CODE = "LOADING_SOURCE_CODE";\nexport const NOT_BOOTSTRAPPED = "NOT_BOOTSTRAPPED";\n// bootstrap\nexport const BOOTSTRAPPING = "BOOTSTRAPPING";\nexport const NOT_MOUNTED = "NOT_MOUNTED";\n// mount\nexport const MOUNTING = "MOUNTING";\nexport const MOUNTED = "MOUNTED";\n// update\nexport const UPDATING = "UPDATING";\n// unmount\nexport const UNMOUNTING = "UNMOUNTING";\n// unload\nexport const UNLOADING = "UNLOADING";\n// error\nexport const LOAD_ERROR = "LOAD_ERROR";\nexport const SKIP_BECAUSE_BROKEN = "SKIP_BECAUSE_BROKEN";\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n这样上面的状态的变化就一目了然了。\n\n\n# globalTimeoutConfig\n\nglobalTimeoutConfig 对应用生命周期的超时时间做管理。\n\n// src/applications/timeouts.js\nconst globalTimeoutConfig = {\n  bootstrap: {\n    millis: 4000, // 超时时间\n    dieOnTimeout: false, // 是否在 timeout 时放弃重试\n    warningMillis: defaultWarningMillis, // 多长时间未成功就 warning\n  },\n  mount: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis,\n  },\n  unmount: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis,\n  },\n  unload: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis,\n  },\n  update: {\n    millis: 3000,\n    dieOnTimeout: false,\n    warningMillis: defaultWarningMillis,\n  },\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n除此之外，sspa 支持用户修改 timeout 的配置，如：\n\nexport function setBootstrapMaxTime(time, dieOnTimeout, warningMillis) {\n  // 参数校验\n  if (typeof time !== "number" || time <= 0) {\n    // ......\n  }\n\n  globalTimeoutConfig.bootstrap = {\n    millis: time,\n    dieOnTimeout,\n    warningMillis: warningMillis || defaultWarningMillis,\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n将 timeout 分度分离出来，并且提供 timeout 的配置并在应用的生命周期中进行注入，这种写法值得借鉴。将生命周期中的模块与生命周期本身分别开来，以注入的方式进行功能加强，这很类似于装饰器模式的思想。\n\n\n# start\n\n参数               描述\nurlRerouteOnly   A boolean that defaults to false. If set to true, calls to\n                 history.pushState () and history.replaceState () will not\n                 trigger a single-spa reroute unless the client side route\n                 was changed. Setting this to true can be better for\n                 performance in some situations. 设置为 true， history.pushState\n                 和 history.replaceState 将不会触发 reroute。用于性能考量。\n\n// src/start.js\nlet started = false;\nexport function start(opts) {\n  started = true;\n  if (opts && opts.urlRerouteOnly) {\n    // 设置 urlRerouteOnly\n    setUrlRerouteOnly(opts.urlRerouteOnly);\n  }\n  if (isInBrowser) {\n    // 调整路由监听\n    reroute();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n为什么需要 start 函数？\n\nMust be called by your single spa config. Before start is called, applications will be loaded, but will never be bootstrapped, mounted or unmounted. The reason for start is to give you control over the performance of your single page application. 【参考 Applications API | single-spa】',normalizedContent:'本节讲解 single-spa 的顶层 api（应用层 api），从整体了解 s-spa 中应用管理的部分的原理，包括应用 register、unregister、unload 等，初步了解 s-spa 中应用的生命周期脉络，方便后文深入。\n\n\n# 目录\n\n\n\n * 目录\n * registerapplication\n * unregisterapplication\n * unloadapplication\n * immediatelyunloadapp\n * getappnames\n * getmountedapps\n * getappstatus\n * checkactivityfunctions\n * pathtoactivewhen\n * todynamicpathvalidatorregex\n * getappchanges\n * globaltimeoutconfig\n * start\n\n\n\n以下代码位置： src/applications/apps.js\n\n\n# registerapplication\n\nregisterapplication 注册微应用。\n\n// src/applications/apps.js\nconst apps = [];\nexport const isinbrowser = typeof window !== "undefined";\nexport function registerapplication(\n  appnameorconfig,\n  apporloadapp,\n  activewhen,\n  customprops\n) {\n  // 参数消毒\n  const registration = sanitizearguments(\n    appnameorconfig,\n    apporloadapp,\n    activewhen,\n    customprops\n  );\n  // 检查重复注册\n  if (getappnames().indexof(registration.name) !== -1)\n    throw error(\n      formaterrormessage(\n        21,\n        __dev__ &&\n          `there is already an app registered with name ${registration.name}`,\n        registration.name\n      )\n    );\n  // 加入微应用列表，并合并默认配置\n  apps.push(\n    assign(\n      {\n        loaderrortime: null,\n        status: not_loaded,\n        parcels: {},\n        devtools: {\n          overlays: {\n            options: {},\n            selectors: [],\n          },\n        },\n      },\n      registration\n    )\n  );\n\n  if (isinbrowser) {\n    // 代理 jq 的路由\n    ensurejquerysupport();\n    // 调整路由监听，初始化或者应用配置变化\n    reroute();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n 1. 参数消毒\n\nsanitizearguments 这样的思想在设计复杂的门面 api 时可以参考，既可以过滤掉非法的参数，也可以对参数的传参行为进行加强。\n\n 2. map 与 mapper\n\nexport function getappnames() {\n  return apps.map(toname);\n}\nexport function toname(app) {\n  return app.name;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n将 map、foreach 等传入回调函数的方法与回调本身分离开来，赋予 mapper 以一定的逻辑功能点，能够提供复用代码的目的。\n\n 3. formaterrormessage\n\nexport function formaterrormessage(code, msg, ...args) {\n  return `single-spa minified message #${code}: ${\n    msg ? msg + " " : ""\n  }see https://single-spa.js.org/error/?code=${code}${\n    args.length ? `&arg=${args.join("&arg=")}` : ""\n  }`;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n错误信息日志在很多框架中都有设计，可以参考各种写法，有些可能需要与官方文档向关联。但是这种把 code 耦合在逻辑代码中的做法有点不妥。\n\n\n# unregisterapplication\n\nunregisterapplication 删除微应用。\n\nexport function unregisterapplication(appname) {\n  // 未找到卸载微应用\n  if (apps.filter((app) => toname(app) === appname).length === 0) {\n    // ......\n  }\n\n  return unloadapplication(appname).then(() => {\n    // 卸载应用并且将应用从箣竹列表中删除\n    const appindex = apps.map(toname).indexof(appname);\n    apps.splice(appindex, 1);\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# unloadapplication\n\nunloadapplication unload 微应用。\n\nexport function unloadapplication(appname, opts = { waitforunmount: false }) {\n  // ......\n\n  const appunloadinfo = getappunloadinfo(toname(app));\n  // 在 unload 之前需要等待应用 unmount（即等应用 unmount 之后才能 unload）\n  if (opts && opts.waitforunmount) {\n    // we need to wait for unmount before unloading the app\n    if (appunloadinfo) {\n      // someone else is already waiting for this, too\n      // 应用已经正在 unload，返回这个 promise\n      return appunloadinfo.promise;\n    } else {\n      // we\'re the first ones wanting the app to be resolved.\n      // 将应用加入到 unload 队列，并且返回这个 promise，promise 将在应用 unload 时 resolve\n      const promise = new promise((resolve, reject) => {\n        addapptounload(app, () => promise, resolve, reject);\n      });\n      return promise;\n    }\n  } else {\n    /* we should unmount the app, unload it, and remount it immediately.*/\n    let resultpromise;\n    // 不必等待 unmount，直接将之 unload \n    if (appunloadinfo) {\n      // someone else is already waiting for this app to unload\n      resultpromise = appunloadinfo.promise;\n      // 立即  unload 应用，因为之前已经等待式 unload，现在又立即 unload，所以将之前的 promise.resolve 传入\n      immediatelyunloadapp(app, appunloadinfo.resolve, appunloadinfo.reject);\n    } else {\n      // we\'re the first ones wanting the app to be resolved.\n      // 创建 promise，在 promise 中将应用加入到 unload 列表，并立即 unload 应用\n      resultpromise = new promise((resolve, reject) => {\n        addapptounload(app, () => resultpromise, resolve, reject);\n        immediatelyunloadapp(app, resolve, reject);\n      });\n    }\n    // 返回 unload promise\n    return resultpromise;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n * 这里提出了 unmount 和 unload 的概念。之后会详细了解两者的区别。\n * 分成了四种情况，是否在 unload 之前等待 unmount、是否已经存在于 unload 列表中。可见 unload 本身应该是异步的，因此才返回一个 promise，并承诺应用 unload 时在 promise 中会 resolve。这其中 unmount 的过程是个很重要的因素，因为 unmount 的阻塞才需要区分是否去等待 unmount 的过程，才需要用 unload 的队列来管理这样一个异步的任务队列。可见这里的设计很巧妙。\n * 等待 unmount 会等待一个怎样的过程，这个过程如何借宿并且自动触发 unload，我们下文知晓。\n\n\n# immediatelyunloadapp\n\n立即 unload 应用。\n\n在 unloadapplication 中的 waitforunmount 为 false 时，立即 unload 应用，不用等待 unmount。\n\nfunction immediatelyunloadapp(app, resolve, reject) {\n  tounmountpromise(app)\n    .then(tounloadpromise)\n    .then(() => {\n      resolve();\n      settimeout(() => {\n        // reroute, but the unload promise is done、\n        // 宏任务：应用 unload 之后重新调整路由监听\n        reroute();\n      });\n    })\n    .catch(reject);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 按照 unload 的顺序，应该先 unmount，再 unload，两者都是异步的操作，因此采用 promise。 tounmountpromise unmount 应用，并返回 promise； tounloadpromise unload 应用并返回 promise。unload 之后先 resolve 整个 unload 任务，再在宏任务里调整路由监听。代码虽少，封装性很强，设计的很巧妙。全程使用 promise 替代 async/await，提升代码运行效率，同时将整个异步的任务处理的很巧妙。\n * tounloadpromise 和 tounmountpromise 后文详述。\n\n\n# getappnames\n\n获取所有应用名称。\n\nexport function getappnames() {\n  return apps.map(toname);\n}\n\n\n1\n2\n3\n\n\n\n# getmountedapps\n\ngetmountedapps 获取已经 mount 的应用。\n\nexport function isactive(app) {\n  return app.status === mounted;\n}\nexport function getmountedapps() {\n  return apps.filter(isactive).map(toname);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# getappstatus\n\n获取应用的状态。\n\nexport function getappstatus(appname) {\n  const app = find(apps, (app) => toname(app) === appname);\n  return app ? app.status : null;\n}\n\n\n1\n2\n3\n4\n\n\n\n# checkactivityfunctions\n\n获取当前匹配到路由的应用名称。\n\nexport function checkactivityfunctions(location = window.location) {\n  return apps.filter((app) => app.activewhen(location)).map(toname);\n}\n\n\n1\n2\n3\n\n\n\n# pathtoactivewhen\n\n将 path（正则或者 string） 转换成 activity function（activewhen）。\n\nactivewhen 支持 activityfunction，也支持直接传入 path，如果直接传入 path，需要内部转换为 activity function。\n\nexport function pathtoactivewhen(path, exactmatch) {\n  // 将 path 转换为正则\n  const regex = todynamicpathvalidatorregex(path, exactmatch);\n  // 返回 activity function\n  return (location) => {\n    // compatible with ie10\n    let origin = location.origin;\n    if (!origin) {\n      origin = `${location.protocol}//${location.host}`;\n    }\n    // 链接去除 origin、search string\n    const route = location.href\n      .replace(origin, "")\n      .replace(location.search, "")\n      .split("?")[0];\n    return regex.test(route);\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n下面我们来看下，如何将 path 转换为路由匹配正则表达式。\n\n\n# todynamicpathvalidatorregex\n\nfunction todynamicpathvalidatorregex(path, exactmatch) {\n  let lastindex = 0,\n    indynamic = false,\n    regexstr = "^";\n  // 无论是正则还是string 路径，都应该以 / 开头\n  if (path[0] !== "/") {\n    path = "/" + path;\n  }\n  // 解析 path\n  for (let charindex = 0; charindex < path.length; charindex++) {\n    const char = path[charindex];\n    const startofdynamic = !indynamic && char === ":";\n    const endofdynamic = indynamic && char === "/";\n    if (startofdynamic || endofdynamic) {\n      appendtoregex(charindex);\n    }\n  }\n\n  appendtoregex(path.length);\n  return new regexp(regexstr, "i");\n\n  function appendtoregex(index) {\n    const anycharmaybetrailingslashregex = "[^/]+/?";\n    const commonstringsubpath = escapestrregex(path.slice(lastindex, index));\n\n    regexstr += indynamic\n      ? anycharmaybetrailingslashregex\n      : commonstringsubpath;\n    // path 解析完毕，根据 exactmatch 补全正则\n    if (index === path.length) {\n      if (indynamic) {\n        if (exactmatch) {\n          // ensure exact match paths that end in a dynamic portion don\'t match\n          // urls with characters after a slash after the dynamic portion.\n          regexstr += "$";\n        }\n      } else {\n        // for exact matches, expect no more characters. otherwise, allow\n        // any characters.\n        const suffix = exactmatch ? "" : ".*";\n\n        regexstr =\n          // use charat instead as we could not use es6 method endswith\n          regexstr.charat(regexstr.length - 1) === "/"\n            ? `${regexstr}${suffix}$`\n            : `${regexstr}(/${suffix})?(#.*)?$`;\n      }\n    }\n\n    indynamic = !indynamic;\n    lastindex = index;\n  }\n  // escape 正则中的特殊符号\n  function escapestrregex(str) {\n    // borrowed from https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js\n    return str.replace(/[|\\\\{}()[\\]^$+*?.]/g, "\\\\$&");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n这段代码将 string 或者正则的 path 转换成正则表达式，同时支持精确匹配和开头匹配。\n\n\n# getappchanges\n\ngetappchanges 根据路由的变化和应用的状态，对应用执行相应的变化。当路由改变后，getappchanges 将重新评估应用的行为，将之区分为 appstounload , appstounmount , appstoload , appstomount 四类。\n\nexport function getappchanges() {\n  const appstounload = [],\n    appstounmount = [],\n    appstoload = [],\n    appstomount = [];\n\n  // we re-attempt to download applications in load_error after a timeout of 200 milliseconds\n  const currenttime = new date().gettime();\n  // 遍历应用执行相应的变化\n  apps.foreach((app) => {\n    // 判断应用是否应该被路由匹配上，即 active。\n    const appshouldbeactive =\n      app.status !== skip_because_broken && shouldbeactive(app);\n\n    switch (app.status) {\n      case load_error:\n        // 如果应用 load 失败，但应该被路由匹配，且失败超时 200 ms，则尝试重新排队 load 应用\n        if (appshouldbeactive && currenttime - app.loaderrortime >= 200) {\n          appstoload.push(app);\n        }\n        break;\n      case not_loaded:\n      case loading_source_code:\n        // 如果应用没有 load 或者正在 load 源码，而应用被匹配上了，则排队 load 应用\n        if (appshouldbeactive) {\n          appstoload.push(app);\n        }\n        break;\n      case not_bootstrapped:\n      case not_mounted:\n        // 如果应用还没有 bootstrap 或者 mount，应用未被路由匹配，且应用正在排队 unload，则排队 unload 应用\n        if (!appshouldbeactive && getappunloadinfo(toname(app))) {\n          appstounload.push(app);\n        } else if (appshouldbeactive) {\n          // 如果应用还没有 bootstrap 或者 mount，但是应用被匹配上，则排列 mount 应用\n          appstomount.push(app);\n        }\n        break;\n      case mounted:\n        // 如果应用已经 mount，没有被路由匹配，则排列 unmount 应用。\n        if (!appshouldbeactive) {\n          appstounmount.push(app);\n        }\n        break;\n      // all other statuses are ignored\n    }\n  });\n\n  return { appstounload, appstounmount, appstoload, appstomount };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n这个函数是针对路由变化执行的，此函数在 reroute 中执行。总结起来就是，路由变化时应用的行为应该发生相应的变化，很像是状态模式的思想。路由捕获到匹配时：load 错误超时的应用重试、未 load 完成的尽快 load；路由失去匹配时，已经 unmount 的应用尽快 unload、尚未 unmount 的应用 尽快 unmount。\n\n这里体现出应用生命周期状态的一些细节：\n\n// registered\nexport const not_loaded = "not_loaded";\n// load\nexport const loading_source_code = "loading_source_code";\nexport const not_bootstrapped = "not_bootstrapped";\n// bootstrap\nexport const bootstrapping = "bootstrapping";\nexport const not_mounted = "not_mounted";\n// mount\nexport const mounting = "mounting";\nexport const mounted = "mounted";\n// update\nexport const updating = "updating";\n// unmount\nexport const unmounting = "unmounting";\n// unload\nexport const unloading = "unloading";\n// error\nexport const load_error = "load_error";\nexport const skip_because_broken = "skip_because_broken";\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n这样上面的状态的变化就一目了然了。\n\n\n# globaltimeoutconfig\n\nglobaltimeoutconfig 对应用生命周期的超时时间做管理。\n\n// src/applications/timeouts.js\nconst globaltimeoutconfig = {\n  bootstrap: {\n    millis: 4000, // 超时时间\n    dieontimeout: false, // 是否在 timeout 时放弃重试\n    warningmillis: defaultwarningmillis, // 多长时间未成功就 warning\n  },\n  mount: {\n    millis: 3000,\n    dieontimeout: false,\n    warningmillis: defaultwarningmillis,\n  },\n  unmount: {\n    millis: 3000,\n    dieontimeout: false,\n    warningmillis: defaultwarningmillis,\n  },\n  unload: {\n    millis: 3000,\n    dieontimeout: false,\n    warningmillis: defaultwarningmillis,\n  },\n  update: {\n    millis: 3000,\n    dieontimeout: false,\n    warningmillis: defaultwarningmillis,\n  },\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n除此之外，sspa 支持用户修改 timeout 的配置，如：\n\nexport function setbootstrapmaxtime(time, dieontimeout, warningmillis) {\n  // 参数校验\n  if (typeof time !== "number" || time <= 0) {\n    // ......\n  }\n\n  globaltimeoutconfig.bootstrap = {\n    millis: time,\n    dieontimeout,\n    warningmillis: warningmillis || defaultwarningmillis,\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n将 timeout 分度分离出来，并且提供 timeout 的配置并在应用的生命周期中进行注入，这种写法值得借鉴。将生命周期中的模块与生命周期本身分别开来，以注入的方式进行功能加强，这很类似于装饰器模式的思想。\n\n\n# start\n\n参数               描述\nurlrerouteonly   a boolean that defaults to false. if set to true, calls to\n                 history.pushstate () and history.replacestate () will not\n                 trigger a single-spa reroute unless the client side route\n                 was changed. setting this to true can be better for\n                 performance in some situations. 设置为 true， history.pushstate\n                 和 history.replacestate 将不会触发 reroute。用于性能考量。\n\n// src/start.js\nlet started = false;\nexport function start(opts) {\n  started = true;\n  if (opts && opts.urlrerouteonly) {\n    // 设置 urlrerouteonly\n    seturlrerouteonly(opts.urlrerouteonly);\n  }\n  if (isinbrowser) {\n    // 调整路由监听\n    reroute();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n为什么需要 start 函数？\n\nmust be called by your single spa config. before start is called, applications will be loaded, but will never be bootstrapped, mounted or unmounted. the reason for start is to give you control over the performance of your single page application. 【参考 applications api | single-spa】',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"本章概要",frontmatter:{title:"本章概要",date:"2022-04-14T22:02:21.000Z",permalink:"/single-spa/lifecycle/index/",categories:["single-spa"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/20.lifecycles%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/0.index.html",relativePath:"30.web/5.single-spa源码/20.lifecycles与生命周期管理/0.index.md",key:"v-0b29f556",path:"/single-spa/lifecycle/index/",headers:[{level:2,title:"内容",slug:"内容",normalizedTitle:"内容",charIndex:118},{level:3,title:"生命周期与微应用的行为",slug:"生命周期与微应用的行为",normalizedTitle:"生命周期与微应用的行为",charIndex:245},{level:2,title:"目标",slug:"目标",normalizedTitle:"目标",charIndex:496},{level:2,title:"Q&A",slug:"q-a",normalizedTitle:"q&amp;a",charIndex:null}],excerpt:"<p>在上一章中讲解了 single-spa 中主应用的 API，主要是一些提供给用户、devtool 等的顶层 API。最重要的 API 包括  <code>registerApplication</code> 、  <code>unregisterApplication</code>  等。这些内容实际上就是应用管理。</p>\n<p>同时我们已经接触到微应用的生命周期，如 load、bootstrap、mount、update、unmount、unload 等。这一章中，我们来详细探讨 single-spa 中的微应用生命周期管理。</p>\n",readingTime:{text:"1 min read",minutes:.205,time:12299.999999999998,words:41},headersStr:"内容 生命周期与微应用的行为 目标 Q&A",content:"在上一章中讲解了 single-spa 中主应用的 API，主要是一些提供给用户、devtool 等的顶层 API。最重要的 API 包括 registerApplication 、 unregisterApplication 等。这些内容实际上就是应用管理。\n\n同时我们已经接触到微应用的生命周期，如 load、bootstrap、mount、update、unmount、unload 等。这一章中，我们来详细探讨 single-spa 中的微应用生命周期管理。\n\n\n# 内容\n\n\n# 生命周期与微应用的行为\n\ns-spa 管理了微应用及其生命周期，这对于实现微前端的结构至关重要但不是全部，因为 s-spa 具有很强的可定制能力和灵活性，在生命周期中有很多微应用的行为和状态是可以由外界去维护的。qianKun 正是运用了这一点。\n\n让微前端应用具有更多开箱即用的特性这正是 qianKun 所正在做的，在 qiqnKun 中，基于这样的生命周期的设计，它实现了更多如 JavaScript 沙箱、css 沙箱、模板解析、prefech、微应用内部的 hooks 等扩展功能。\n\n\n# 目标\n\n\n# Q&A",normalizedContent:"在上一章中讲解了 single-spa 中主应用的 api，主要是一些提供给用户、devtool 等的顶层 api。最重要的 api 包括 registerapplication 、 unregisterapplication 等。这些内容实际上就是应用管理。\n\n同时我们已经接触到微应用的生命周期，如 load、bootstrap、mount、update、unmount、unload 等。这一章中，我们来详细探讨 single-spa 中的微应用生命周期管理。\n\n\n# 内容\n\n\n# 生命周期与微应用的行为\n\ns-spa 管理了微应用及其生命周期，这对于实现微前端的结构至关重要但不是全部，因为 s-spa 具有很强的可定制能力和灵活性，在生命周期中有很多微应用的行为和状态是可以由外界去维护的。qiankun 正是运用了这一点。\n\n让微前端应用具有更多开箱即用的特性这正是 qiankun 所正在做的，在 qiqnkun 中，基于这样的生命周期的设计，它实现了更多如 javascript 沙箱、css 沙箱、模板解析、prefech、微应用内部的 hooks 等扩展功能。\n\n\n# 目标\n\n\n# q&a",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"生命周期：load 和 unload",frontmatter:{title:"生命周期：load 和 unload",date:"2022-04-15T13:41:48.000Z",permalink:"/single-spa/lifecycle/load/",categories:["single-spa","lifecycles生命周期"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/20.lifecycles%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/10.load.html",relativePath:"30.web/5.single-spa源码/20.lifecycles与生命周期管理/10.load.md",key:"v-70bd8ed4",path:"/single-spa/lifecycle/load/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:180},{level:2,title:"app 是什么？",slug:"app-是什么",normalizedTitle:"app 是什么？",charIndex:195},{level:2,title:"toLoadPromise",slug:"toloadpromise",normalizedTitle:"toloadpromise",charIndex:207},{level:2,title:"smellsLikeAPromise",slug:"smellslikeapromise",normalizedTitle:"smellslikeapromise",charIndex:224},{level:2,title:"flattenFnArray",slug:"flattenfnarray",normalizedTitle:"flattenfnarray",charIndex:246},{level:2,title:"toUnloadPromise",slug:"tounloadpromise",normalizedTitle:"tounloadpromise",charIndex:264}],excerpt:"<TimeToRead />\n<p>本节讲解 single-spa 中的生命周期 load 和 unload 函数的原理。在 single-spa 中 load 是在 bootstrap、mount 阶段之前，注册应用后的阶段。此阶段的主要工作是加载并检验 load 配置、校验配置和钩子函数、规整钩子函数等。unload 是在 unmount 之后 unregister 之前的阶段。</p>\n",readingTime:{text:"6 min read",minutes:5.39,time:323400,words:1078},headersStr:"目录 app 是什么？ toLoadPromise smellsLikeAPromise flattenFnArray toUnloadPromise",content:'本节讲解 single-spa 中的生命周期 load 和 unload 函数的原理。在 single-spa 中 load 是在 bootstrap、mount 阶段之前，注册应用后的阶段。此阶段的主要工作是加载并检验 load 配置、校验配置和钩子函数、规整钩子函数等。unload 是在 unmount 之后 unregister 之前的阶段。\n\n\n# 目录\n\n\n\n * 目录\n * app 是什么？\n * toLoadPromise\n * smellsLikeAPromise\n * flattenFnArray\n * toUnloadPromise\n\n\n\n\n# app 是什么？\n\n因为上一章中是从宏观上管理微应用，我们只需要知道微应用是一个 object 接口。在这一章中，因为我们要详细探讨微应用的生命周期，这必然要涉及到对微应用中某些属性的操作，因此在探讨 toLoadPromise 之前，先来看下 app 是什么？因为 s-spa 不是 typescript 编写的，我们在文档和代码中还原 app 的原状。以内部命名为准。\n\n参数              描述\nname            App name that single-spa will register and reference this\n                application with, and will be labelled with in dev tools.\nloadApp         Application object or a function that returns the resolved\n                application (Promise or not)\nactiveWhen      Can be a path prefix which will match every URL starting\n                with this path, an activity function (as described in the\n                simple arguments) or an array containing both of them.\ncustomProps     Will be passed to the application during each lifecycle\n                method.\nloadErrorTime   微应用 load 错误的时间点\nloadPromise     微应用 load 的 promise\nstatus          微应用的状态\nparcels         \ndevtools        devtools 的配置\n\n提示\n\n加粗的参数未用户会配置的参数，其余为内部使用参数。\n\n\n# toLoadPromise\n\n这个函数的结构很复杂，先来探讨下其结构:\n\nfunction toLoadPromise(app) {\n  // P0\n  return Promise.resolve().then(() => {\n    // ......\n    // P1\n    return (app.loadPromise = Promise.resolve().then(() => {\n      // ......\n      // P2\n      return app;\n    })).catch(err => {\n      // ......\n      // P3\n      return app;\n    } )\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nPromise 的类型定义参考：qiankun: loadApp 加载微应用\n\n * P0：返回 Promise.resolve().then 的 return，即 Promise<app> 。\n * P1：P1 的返回就是 P0 的返回。\n * P2/P3：P2/P3 的返回就是 Promise<app> 。\n\nMDN：Promise.resolve()\n\nThis function flattens nested layers of promise-like objects (e.g. a promise that resolves to a promise that resolves to something) into a single layer.\n\nPromise.resolve() 会将 Promise 进行 flat，但是这里使用嵌套的 Promise.resolve 来返回 Promise<app> ，目的是为了是让 toLoadPromise，即返回 Promise<app> 这个操作成为 Promise，希望它能够在微任务里执行，提升执行效率。关于 Promise 模拟微任务可参见：30 分钟看懂 React 框架原理。\n\n结合此函数在 reroute 和 performAppChanges 里调用，执行的频率较高，这么做也就可以理解了。\n\n下面来具体看下源码：\n\nexport function toLoadPromise(app) {\n  // load app 返回 loadPromise，Promise.resolve() 会将嵌套的 promise 摊平\n  return Promise.resolve().then(() => {\n    // 如果 loadPromise 已经存在，直接返回，不用再生成 loadPromise，执行 load 过程\n    if (app.loadPromise) {\n      return app.loadPromise;\n    }\n    // app.status 必须是 NOT_LOADED 或者 LOAD_ERROR\n    if (app.status !== NOT_LOADED && app.status !== LOAD_ERROR) {\n      return app;\n    }\n    // 状态修改为 LOADING_SOURCE_CODE，这是因为这 LOADING_SOURCE_CODE 阶段主要目前的加载应用配置对象\n    // 配置中包含应用生命周期钩子（加载源码并不是 load 阶段，这部分由外界完成，\n    // 如 qiankun 就自定义的加载源代码这块以实现 prefecth 等增强功能） \n    app.status = LOADING_SOURCE_CODE;\n\n    let appOpts, isUserErr;\n    // 将 loadPromise 保存在 app 上以\n    return (app.loadPromise = Promise.resolve()\n      .then(() => {\n        // load app promise，规整传递给 loadApp 的参数\n        const loadPromise = app.loadApp(getProps(app));\n        // 判断是否是 promise，如果不是 promise 就会报错\n        // 参见 registerMicroApps 中 app 使用  async 返回对象\n        if (!smellsLikeAPromise(loadPromise)) {\n          isUserErr = true;\n          // throw Error() ......\n        }\n        return loadPromise.then((val) => {\n          app.loadErrorTime = null;\n\n          appOpts = val;\n\n          let validationErrMessage, validationErrCode;\n          // loadPromise 必须返回 object\n          if (typeof appOpts !== "object") {\n            validationErrCode = 34;\n          }\n          // 有 bootstrap 钩子，但是钩子不合法\n          if (\n            // ES Modules don\'t have the Object prototype\n            Object.prototype.hasOwnProperty.call(appOpts, "bootstrap") &&\n            !validLifecycleFn(appOpts.bootstrap)\n          ) {\n            validationErrCode = 35;\n          }\n          // mount 钩子必须有，但是钩子不合法\n          if (!validLifecycleFn(appOpts.mount)) {\n            validationErrCode = 36;\n          }\n          // unmount 钩子必须有，但是钩子不合法\n          if (!validLifecycleFn(appOpts.unmount)) {\n            validationErrCode = 37;\n          }\n          // 判断 app 是 parcel 还是 application，根据 appOpts.unmountThisParcel 判断\n          const type = objectType(appOpts);\n\n          if (validationErrCode) {\n            // ......\n            handleAppError(validationErrMessage, app, SKIP_BECAUSE_BROKEN);\n            return app;\n          }\n\n          // 状态由 LOADING_SOURCE_CODE 更新为 NOT_BOOTSTRAPPED\n          app.status = NOT_BOOTSTRAPPED;\n          // 规整 bootstrap 钩子，将钩子转成 钩子数组，并且返回 promise reduce pipeline\n          // 以下类比，注意这里只是返回 promise reduce pipeline，并没有执行\n          app.bootstrap = flattenFnArray(appOpts, "bootstrap");\n          app.mount = flattenFnArray(appOpts, "mount");\n          app.unmount = flattenFnArray(appOpts, "unmount");\n          app.unload = flattenFnArray(appOpts, "unload");\n          // 规整 timeouts 的配置，并且跟默认配置合并\n          app.timeouts = ensureValidAppTimeouts(appOpts.timeouts);\n          // load 过程完毕，删除 app.loadPromise， 这个 app.loadPromise 相当于一个互斥锁\n          delete app.loadPromise;\n\n          return app;\n        });\n      })\n      .catch((err) => {\n        delete app.loadPromise;\n\n        let newStatus;\n        // 出错，如果是用户配置问题，将状态置为 SKIP_BECAUSE_BROKEN，否则将状态置为 LOAD_ERROR\n        if (isUserErr) {\n          newStatus = SKIP_BECAUSE_BROKEN;\n        } else {\n          newStatus = LOAD_ERROR;\n          app.loadErrorTime = new Date().getTime();\n        }\n        // 初始应用错误\n        handleAppError(err, app, newStatus);\n\n        return app;\n      }));\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n\n\n先从整体上总结这个函数的作用：\n\n * 函数返回 loadPromise 即， Promise<app> ，在注册应用之后，mount 应用之前，此函数将 load 应用。\n * load 应用主要做如下工作：调用 app.loadApp 加载并检验 load 配置、校验配置和钩子函数、规整钩子函数（转成数组、将钩子数组包装成 reduce pipeline）、错误处理。\n * 此过程中状态为 LOADING_SOURCE_CODE （校验 app.loadPromise 和 app.status 之后） 和 NOT_BOOTSTRAPPED （配置和钩子函数检验完毕之后）。\n\n参考：\n\n * Applications API | single-spa | registerApplication\n * Promise.resolve() - JavaScript | MDN\n\n\n# smellsLikeAPromise\n\n判断是否是 Promise。\n\nexport function smellsLikeAPromise(promise) {\n  return (\n    promise &&\n    typeof promise.then === "function" &&\n    typeof promise.catch === "function"\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n为什么不用 p instanceof Promise 呢？我们注意到很多源码中（Vue3 等）都使用上述的方式判断 promise，而非使用 instanceof 判断。这是因为 instanceof 仅可判断由 ES6 实现的 Promise，而对于很多自己实现的 Promise，包括 polyfill 中实现的 Promise，这种方法可能就没法很好判断。而上述的判断是基于 ES 的实现规范的判断方法，这种判断方法更为普遍。\n\n\n# flattenFnArray\n\nexport function flattenFnArray(appOrParcel, lifecycle) {\n  let fns = appOrParcel[lifecycle] || [];\n  fns = Array.isArray(fns) ? fns : [fns];\n  if (fns.length === 0) {\n    fns = [() => Promise.resolve()];\n  }\n\n  const type = objectType(appOrParcel);\n  const name = toName(appOrParcel);\n\n  return function (props) {\n    // promise reduce pipeline\n    // 执行钩子数组中所有的钩子，并且将最后 promise 返回\n    return fns.reduce((resultPromise, fn, index) => {\n      return resultPromise.then(() => {\n        const thisPromise = fn(props);\n        return smellsLikeAPromise(thisPromise)\n          ? thisPromise\n          : Promise.reject(/** ...... **/)\n      });\n    }, Promise.resolve());\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n数组中的钩子函数将依次在微任务里执行，知道返回最后一个钩子执行的 promise。\n\n关于 reduce pipeline，在中也 qiankun: loadApp 加载微应用运用了这个技巧。\n\n\n# toUnloadPromise\n\ntoUnloadPromise 函数卸载微应用。\n\nexport function toUnloadPromise(app) {\n  return Promise.resolve().then(() => {\n    const unloadInfo = appsToUnload[toName(app)];\n    // 如果已经 unload 没有排队，直接返回，因为 unloadApplication 没有被调用\n    if (!unloadInfo) {\n      /* No one has called unloadApplication for this app,\n       */\n      return app;\n    }\n    // 如果状态已经是 NOT_LOADED，直接 finishUnloadingApp\n    if (app.status === NOT_LOADED) {\n      /* This app is already unloaded. We just need to clean up\n       * anything that still thinks we need to unload the app.\n       */\n      finishUnloadingApp(app, unloadInfo);\n      return app;\n    }\n    // 可能是 unloadApplication 和 reroute 同时想要 unload 应用\n    // 等待已经 unload 执行完毕\n    if (app.status === UNLOADING) {\n      /* Both unloadApplication and reroute want to unload this app.\n       * It only needs to be done once, though.\n       */\n      return unloadInfo.promise.then(() => app);\n    }\n    // 如果应用状态不是 NOT_MOUNTED 或者 LOAD_ERROR，没有办法 unload，直接返回\n    // 需要先 unmount 到 NOT_MOUNTED 状态才能 unload \n    if (app.status !== NOT_MOUNTED && app.status !== LOAD_ERROR) {\n      /* The app cannot be unloaded until it is unmounted.\n       */\n      return app;\n    }\n\n    const unloadPromise =\n      app.status === LOAD_ERROR\n        ? Promise.resolve()\n        : reasonableTime(app, "unload");\n\n    app.status = UNLOADING;\n    // 如果不是 LOAD_ERROR 状态就执行 unload 的钩子\n    return unloadPromise\n      .then(() => {\n        // 执行成功后 finishUnloadingApp\n        finishUnloadingApp(app, unloadInfo);\n        return app;\n      })\n      .catch((err) => {\n        errorUnloadingApp(app, unloadInfo, err);\n        return app;\n      });\n  });\n}\n\nfunction finishUnloadingApp(app, unloadInfo) {\n  // 从 unload 队列中删除\n  delete appsToUnload[toName(app)];\n  // 删除生命周期\n  // Unloaded apps don\'t have lifecycles\n  delete app.bootstrap;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n  // 更新状态为 NOT_LOADED\n  app.status = NOT_LOADED;\n  //  resolve unloadInfo promise，完成整个 unload 过程\n  /* resolve the promise of whoever called unloadApplication.\n   * This should be done after all other cleanup/bookkeeping\n   */\n  unloadInfo.resolve();\n}\n\nfunction errorUnloadingApp(app, unloadInfo, err) {\n  delete appsToUnload[toName(app)];\n\n  // Unloaded apps don\'t have lifecycles\n  delete app.bootstrap;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n\n  handleAppError(err, app, SKIP_BECAUSE_BROKEN);\n  // 将错误 reject 给外部\n  unloadInfo.reject(err);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n\n\n使用队列的方式来 unload 应用是因为 unloadApplication 和 reroute 可能会同时想要 unload 应用。\n\n这个函数的核心作用是:\n\n * 调用 unload 钩子，将应用 unload。\n * 删除应用的生命周期，并且将队列中 unload 任务的 promise 进行 resolve 或者 reject。',normalizedContent:'本节讲解 single-spa 中的生命周期 load 和 unload 函数的原理。在 single-spa 中 load 是在 bootstrap、mount 阶段之前，注册应用后的阶段。此阶段的主要工作是加载并检验 load 配置、校验配置和钩子函数、规整钩子函数等。unload 是在 unmount 之后 unregister 之前的阶段。\n\n\n# 目录\n\n\n\n * 目录\n * app 是什么？\n * toloadpromise\n * smellslikeapromise\n * flattenfnarray\n * tounloadpromise\n\n\n\n\n# app 是什么？\n\n因为上一章中是从宏观上管理微应用，我们只需要知道微应用是一个 object 接口。在这一章中，因为我们要详细探讨微应用的生命周期，这必然要涉及到对微应用中某些属性的操作，因此在探讨 toloadpromise 之前，先来看下 app 是什么？因为 s-spa 不是 typescript 编写的，我们在文档和代码中还原 app 的原状。以内部命名为准。\n\n参数              描述\nname            app name that single-spa will register and reference this\n                application with, and will be labelled with in dev tools.\nloadapp         application object or a function that returns the resolved\n                application (promise or not)\nactivewhen      can be a path prefix which will match every url starting\n                with this path, an activity function (as described in the\n                simple arguments) or an array containing both of them.\ncustomprops     will be passed to the application during each lifecycle\n                method.\nloaderrortime   微应用 load 错误的时间点\nloadpromise     微应用 load 的 promise\nstatus          微应用的状态\nparcels         \ndevtools        devtools 的配置\n\n提示\n\n加粗的参数未用户会配置的参数，其余为内部使用参数。\n\n\n# toloadpromise\n\n这个函数的结构很复杂，先来探讨下其结构:\n\nfunction toloadpromise(app) {\n  // p0\n  return promise.resolve().then(() => {\n    // ......\n    // p1\n    return (app.loadpromise = promise.resolve().then(() => {\n      // ......\n      // p2\n      return app;\n    })).catch(err => {\n      // ......\n      // p3\n      return app;\n    } )\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\npromise 的类型定义参考：qiankun: loadapp 加载微应用\n\n * p0：返回 promise.resolve().then 的 return，即 promise<app> 。\n * p1：p1 的返回就是 p0 的返回。\n * p2/p3：p2/p3 的返回就是 promise<app> 。\n\nmdn：promise.resolve()\n\nthis function flattens nested layers of promise-like objects (e.g. a promise that resolves to a promise that resolves to something) into a single layer.\n\npromise.resolve() 会将 promise 进行 flat，但是这里使用嵌套的 promise.resolve 来返回 promise<app> ，目的是为了是让 toloadpromise，即返回 promise<app> 这个操作成为 promise，希望它能够在微任务里执行，提升执行效率。关于 promise 模拟微任务可参见：30 分钟看懂 react 框架原理。\n\n结合此函数在 reroute 和 performappchanges 里调用，执行的频率较高，这么做也就可以理解了。\n\n下面来具体看下源码：\n\nexport function toloadpromise(app) {\n  // load app 返回 loadpromise，promise.resolve() 会将嵌套的 promise 摊平\n  return promise.resolve().then(() => {\n    // 如果 loadpromise 已经存在，直接返回，不用再生成 loadpromise，执行 load 过程\n    if (app.loadpromise) {\n      return app.loadpromise;\n    }\n    // app.status 必须是 not_loaded 或者 load_error\n    if (app.status !== not_loaded && app.status !== load_error) {\n      return app;\n    }\n    // 状态修改为 loading_source_code，这是因为这 loading_source_code 阶段主要目前的加载应用配置对象\n    // 配置中包含应用生命周期钩子（加载源码并不是 load 阶段，这部分由外界完成，\n    // 如 qiankun 就自定义的加载源代码这块以实现 prefecth 等增强功能） \n    app.status = loading_source_code;\n\n    let appopts, isusererr;\n    // 将 loadpromise 保存在 app 上以\n    return (app.loadpromise = promise.resolve()\n      .then(() => {\n        // load app promise，规整传递给 loadapp 的参数\n        const loadpromise = app.loadapp(getprops(app));\n        // 判断是否是 promise，如果不是 promise 就会报错\n        // 参见 registermicroapps 中 app 使用  async 返回对象\n        if (!smellslikeapromise(loadpromise)) {\n          isusererr = true;\n          // throw error() ......\n        }\n        return loadpromise.then((val) => {\n          app.loaderrortime = null;\n\n          appopts = val;\n\n          let validationerrmessage, validationerrcode;\n          // loadpromise 必须返回 object\n          if (typeof appopts !== "object") {\n            validationerrcode = 34;\n          }\n          // 有 bootstrap 钩子，但是钩子不合法\n          if (\n            // es modules don\'t have the object prototype\n            object.prototype.hasownproperty.call(appopts, "bootstrap") &&\n            !validlifecyclefn(appopts.bootstrap)\n          ) {\n            validationerrcode = 35;\n          }\n          // mount 钩子必须有，但是钩子不合法\n          if (!validlifecyclefn(appopts.mount)) {\n            validationerrcode = 36;\n          }\n          // unmount 钩子必须有，但是钩子不合法\n          if (!validlifecyclefn(appopts.unmount)) {\n            validationerrcode = 37;\n          }\n          // 判断 app 是 parcel 还是 application，根据 appopts.unmountthisparcel 判断\n          const type = objecttype(appopts);\n\n          if (validationerrcode) {\n            // ......\n            handleapperror(validationerrmessage, app, skip_because_broken);\n            return app;\n          }\n\n          // 状态由 loading_source_code 更新为 not_bootstrapped\n          app.status = not_bootstrapped;\n          // 规整 bootstrap 钩子，将钩子转成 钩子数组，并且返回 promise reduce pipeline\n          // 以下类比，注意这里只是返回 promise reduce pipeline，并没有执行\n          app.bootstrap = flattenfnarray(appopts, "bootstrap");\n          app.mount = flattenfnarray(appopts, "mount");\n          app.unmount = flattenfnarray(appopts, "unmount");\n          app.unload = flattenfnarray(appopts, "unload");\n          // 规整 timeouts 的配置，并且跟默认配置合并\n          app.timeouts = ensurevalidapptimeouts(appopts.timeouts);\n          // load 过程完毕，删除 app.loadpromise， 这个 app.loadpromise 相当于一个互斥锁\n          delete app.loadpromise;\n\n          return app;\n        });\n      })\n      .catch((err) => {\n        delete app.loadpromise;\n\n        let newstatus;\n        // 出错，如果是用户配置问题，将状态置为 skip_because_broken，否则将状态置为 load_error\n        if (isusererr) {\n          newstatus = skip_because_broken;\n        } else {\n          newstatus = load_error;\n          app.loaderrortime = new date().gettime();\n        }\n        // 初始应用错误\n        handleapperror(err, app, newstatus);\n\n        return app;\n      }));\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n\n\n先从整体上总结这个函数的作用：\n\n * 函数返回 loadpromise 即， promise<app> ，在注册应用之后，mount 应用之前，此函数将 load 应用。\n * load 应用主要做如下工作：调用 app.loadapp 加载并检验 load 配置、校验配置和钩子函数、规整钩子函数（转成数组、将钩子数组包装成 reduce pipeline）、错误处理。\n * 此过程中状态为 loading_source_code （校验 app.loadpromise 和 app.status 之后） 和 not_bootstrapped （配置和钩子函数检验完毕之后）。\n\n参考：\n\n * applications api | single-spa | registerapplication\n * promise.resolve() - javascript | mdn\n\n\n# smellslikeapromise\n\n判断是否是 promise。\n\nexport function smellslikeapromise(promise) {\n  return (\n    promise &&\n    typeof promise.then === "function" &&\n    typeof promise.catch === "function"\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n为什么不用 p instanceof promise 呢？我们注意到很多源码中（vue3 等）都使用上述的方式判断 promise，而非使用 instanceof 判断。这是因为 instanceof 仅可判断由 es6 实现的 promise，而对于很多自己实现的 promise，包括 polyfill 中实现的 promise，这种方法可能就没法很好判断。而上述的判断是基于 es 的实现规范的判断方法，这种判断方法更为普遍。\n\n\n# flattenfnarray\n\nexport function flattenfnarray(apporparcel, lifecycle) {\n  let fns = apporparcel[lifecycle] || [];\n  fns = array.isarray(fns) ? fns : [fns];\n  if (fns.length === 0) {\n    fns = [() => promise.resolve()];\n  }\n\n  const type = objecttype(apporparcel);\n  const name = toname(apporparcel);\n\n  return function (props) {\n    // promise reduce pipeline\n    // 执行钩子数组中所有的钩子，并且将最后 promise 返回\n    return fns.reduce((resultpromise, fn, index) => {\n      return resultpromise.then(() => {\n        const thispromise = fn(props);\n        return smellslikeapromise(thispromise)\n          ? thispromise\n          : promise.reject(/** ...... **/)\n      });\n    }, promise.resolve());\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n数组中的钩子函数将依次在微任务里执行，知道返回最后一个钩子执行的 promise。\n\n关于 reduce pipeline，在中也 qiankun: loadapp 加载微应用运用了这个技巧。\n\n\n# tounloadpromise\n\ntounloadpromise 函数卸载微应用。\n\nexport function tounloadpromise(app) {\n  return promise.resolve().then(() => {\n    const unloadinfo = appstounload[toname(app)];\n    // 如果已经 unload 没有排队，直接返回，因为 unloadapplication 没有被调用\n    if (!unloadinfo) {\n      /* no one has called unloadapplication for this app,\n       */\n      return app;\n    }\n    // 如果状态已经是 not_loaded，直接 finishunloadingapp\n    if (app.status === not_loaded) {\n      /* this app is already unloaded. we just need to clean up\n       * anything that still thinks we need to unload the app.\n       */\n      finishunloadingapp(app, unloadinfo);\n      return app;\n    }\n    // 可能是 unloadapplication 和 reroute 同时想要 unload 应用\n    // 等待已经 unload 执行完毕\n    if (app.status === unloading) {\n      /* both unloadapplication and reroute want to unload this app.\n       * it only needs to be done once, though.\n       */\n      return unloadinfo.promise.then(() => app);\n    }\n    // 如果应用状态不是 not_mounted 或者 load_error，没有办法 unload，直接返回\n    // 需要先 unmount 到 not_mounted 状态才能 unload \n    if (app.status !== not_mounted && app.status !== load_error) {\n      /* the app cannot be unloaded until it is unmounted.\n       */\n      return app;\n    }\n\n    const unloadpromise =\n      app.status === load_error\n        ? promise.resolve()\n        : reasonabletime(app, "unload");\n\n    app.status = unloading;\n    // 如果不是 load_error 状态就执行 unload 的钩子\n    return unloadpromise\n      .then(() => {\n        // 执行成功后 finishunloadingapp\n        finishunloadingapp(app, unloadinfo);\n        return app;\n      })\n      .catch((err) => {\n        errorunloadingapp(app, unloadinfo, err);\n        return app;\n      });\n  });\n}\n\nfunction finishunloadingapp(app, unloadinfo) {\n  // 从 unload 队列中删除\n  delete appstounload[toname(app)];\n  // 删除生命周期\n  // unloaded apps don\'t have lifecycles\n  delete app.bootstrap;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n  // 更新状态为 not_loaded\n  app.status = not_loaded;\n  //  resolve unloadinfo promise，完成整个 unload 过程\n  /* resolve the promise of whoever called unloadapplication.\n   * this should be done after all other cleanup/bookkeeping\n   */\n  unloadinfo.resolve();\n}\n\nfunction errorunloadingapp(app, unloadinfo, err) {\n  delete appstounload[toname(app)];\n\n  // unloaded apps don\'t have lifecycles\n  delete app.bootstrap;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n\n  handleapperror(err, app, skip_because_broken);\n  // 将错误 reject 给外部\n  unloadinfo.reject(err);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n\n\n使用队列的方式来 unload 应用是因为 unloadapplication 和 reroute 可能会同时想要 unload 应用。\n\n这个函数的核心作用是:\n\n * 调用 unload 钩子，将应用 unload。\n * 删除应用的生命周期，并且将队列中 unload 任务的 promise 进行 resolve 或者 reject。',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"生命周期：bootstrap",frontmatter:{title:"生命周期：bootstrap",date:"2022-04-18T14:20:39.000Z",permalink:"/single-spa/lifecycle/bootstrap/",categories:["single-spa源码","lifecycles生命周期"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/20.lifecycles%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/20.bootstrap.html",relativePath:"30.web/5.single-spa源码/20.lifecycles与生命周期管理/20.bootstrap.md",key:"v-5cc090d4",path:"/single-spa/lifecycle/bootstrap/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:167},{level:2,title:"toBootstrapPromise",slug:"tobootstrappromise",normalizedTitle:"tobootstrappromise",charIndex:182},{level:2,title:"reasonableTime",slug:"reasonabletime",normalizedTitle:"reasonabletime",charIndex:204}],excerpt:"<TimeToRead />\n<p>本节讲解 single-spa 中生命周期 bootstrap 函数的原理。在 single-spa 中 bootstrap 是在 load 阶段之后、mount 阶段之前的阶段。bootstrap 阶段的主要任务就是执行 bootstrap 生命周期钩子，bootstrap 钩子可以理解为  <code>beforeMount</code>  钩子。</p>\n",readingTime:{text:"2 min read",minutes:1.66,time:99600,words:332},headersStr:"目录 toBootstrapPromise reasonableTime",content:"本节讲解 single-spa 中生命周期 bootstrap 函数的原理。在 single-spa 中 bootstrap 是在 load 阶段之后、mount 阶段之前的阶段。bootstrap 阶段的主要任务就是执行 bootstrap 生命周期钩子，bootstrap 钩子可以理解为 beforeMount 钩子。\n\n\n# 目录\n\n\n\n * 目录\n * toBootstrapPromise\n * reasonableTime\n\n\n\n\n# toBootstrapPromise\n\n代码如下。\n\nexport function toBootstrapPromise(appOrParcel, hardFail) {\n  return Promise.resolve().then(() => {\n    if (appOrParcel.status !== NOT_BOOTSTRAPPED) {\n      return appOrParcel;\n    }\n    // 将状态修改为 BOOTSTRAPPING\n    appOrParcel.status = BOOTSTRAPPING;\n    // 如果没有 bootstrap 钩子，则使用默认的钩子\n    if (!appOrParcel.bootstrap) {\n      // Default implementation of bootstrap\n      return Promise.resolve().then(successfulBootstrap);\n    }\n    // 调用声明周期函数并且应用 timeout 超时时间配置\n    return reasonableTime(appOrParcel, \"bootstrap\")\n      .then(successfulBootstrap)\n      .catch((err) => {\n        if (hardFail) {\n          throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n        } else {\n          handleAppError(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n          return appOrParcel;\n        }\n      });\n  });\n\n  function successfulBootstrap() {\n    appOrParcel.status = NOT_MOUNTED;\n    return appOrParcel;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\ntoBootstrapPromise 的主要工作总结如下：\n\n * 执行 bootstrap 生命周期钩子。\n * 初始化时将 app.status 更新为 BOOTSTRAPPING，执行钩子任务出现错误时将状态更新为 SKIP_BECAUSE_BROKEN，钩子任务执行成功后将转台更新为 NOT_MOUNTED。\n\n\n# reasonableTime\n\n按照 timeout 超时时间的配置执行生命周期钩子，并且返回执行结果 promise。\n\napp.timeouts 是在 load 阶段初始化的。\n\nexport function reasonableTime(appOrParcel, lifecycle) {\n  // 获取 timeouts 配置\n  const timeoutConfig = appOrParcel.timeouts[lifecycle];\n  const warningPeriod = timeoutConfig.warningMillis;\n  // 应用的类型\n  const type = objectType(appOrParcel);\n\n  return new Promise((resolve, reject) => {\n    let finished = false;\n    let errored = false;\n    // 调用钩子函数（在 load 阶段已经转换为 reduce pipeline）\n    // 传入相关属性，因为这里是异步的不影响后面在 setTimeout 中\n    // 使用 warningPeriod 和 timeoutConfig.millis\n    appOrParcel[lifecycle](getProps(appOrParcel))\n      .then((val) => {\n        // 将管道执行的结果 resolve\n        finished = true;\n        resolve(val);\n      })\n      .catch((val) => {\n        finished = true;\n        reject(val);\n      });\n    // 在 warningPeriod 之后判断是否需要 warning\n    setTimeout(() => maybeTimingOut(1), warningPeriod);\n    // 在 timeoutConfig.millis 之后绝对是否需要终止\n    setTimeout(() => maybeTimingOut(true), timeoutConfig.millis);\n\n    const errMsg = formatErrorMessage(\n      // ......\n    );\n\n    function maybeTimingOut(shouldError) {\n      // 没有 finished 才需要 warning 和 stop\n      if (!finished) {\n        if (shouldError === true) {\n          errored = true;\n          // 如果配置 dieOnTimeout，则超时 reject 即可\n          if (timeoutConfig.dieOnTimeout) {\n            reject(Error(errMsg));\n          } else {\n            // 即时超时也要等待应用生命周期执行完毕\n            console.error(errMsg);\n            //don't resolve or reject, we're waiting this one out\n          }\n        } else if (!errored) {\n          // shouldError 是数字表示 waning 重试次数\n          const numWarnings = shouldError;\n          // 重试时间\n          const numMillis = numWarnings * warningPeriod;\n          console.warn(errMsg);\n          // 重试 waning，直到 finished\n          if (numMillis + warningPeriod < timeoutConfig.millis) {\n            setTimeout(() => maybeTimingOut(numWarnings + 1), warningPeriod);\n          }\n        }\n      }\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n这里比较巧妙的是报错和报警的处理和任务队列的处理。\n\n生命周期的钩子数组处理为任务数组（回调数组），以 promise 的方式在微任务中逐个执行，执行所有的任务都完成。这对于简单的任务队列是可以参考的，而反观 React 中调度器中的任务队列，实际上是实现了更为复杂的功能包括基于优先级的回调、任务的中断与恢复、任务的时间切片等。\n\n这样的简单任务队列在 promise 的支持下也实现了任务的切片执行，这使得计算量较大的任务可以单独在一个微任务中执行，这提高了任务执行的效率，同时整个任务的执行过程也变得异步。\n\nmaybeTimingOut 可以对任务队列的超时状况进行报警，方便开发者进行性能调优和错误监控。",normalizedContent:"本节讲解 single-spa 中生命周期 bootstrap 函数的原理。在 single-spa 中 bootstrap 是在 load 阶段之后、mount 阶段之前的阶段。bootstrap 阶段的主要任务就是执行 bootstrap 生命周期钩子，bootstrap 钩子可以理解为 beforemount 钩子。\n\n\n# 目录\n\n\n\n * 目录\n * tobootstrappromise\n * reasonabletime\n\n\n\n\n# tobootstrappromise\n\n代码如下。\n\nexport function tobootstrappromise(apporparcel, hardfail) {\n  return promise.resolve().then(() => {\n    if (apporparcel.status !== not_bootstrapped) {\n      return apporparcel;\n    }\n    // 将状态修改为 bootstrapping\n    apporparcel.status = bootstrapping;\n    // 如果没有 bootstrap 钩子，则使用默认的钩子\n    if (!apporparcel.bootstrap) {\n      // default implementation of bootstrap\n      return promise.resolve().then(successfulbootstrap);\n    }\n    // 调用声明周期函数并且应用 timeout 超时时间配置\n    return reasonabletime(apporparcel, \"bootstrap\")\n      .then(successfulbootstrap)\n      .catch((err) => {\n        if (hardfail) {\n          throw transformerr(err, apporparcel, skip_because_broken);\n        } else {\n          handleapperror(err, apporparcel, skip_because_broken);\n          return apporparcel;\n        }\n      });\n  });\n\n  function successfulbootstrap() {\n    apporparcel.status = not_mounted;\n    return apporparcel;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\ntobootstrappromise 的主要工作总结如下：\n\n * 执行 bootstrap 生命周期钩子。\n * 初始化时将 app.status 更新为 bootstrapping，执行钩子任务出现错误时将状态更新为 skip_because_broken，钩子任务执行成功后将转台更新为 not_mounted。\n\n\n# reasonabletime\n\n按照 timeout 超时时间的配置执行生命周期钩子，并且返回执行结果 promise。\n\napp.timeouts 是在 load 阶段初始化的。\n\nexport function reasonabletime(apporparcel, lifecycle) {\n  // 获取 timeouts 配置\n  const timeoutconfig = apporparcel.timeouts[lifecycle];\n  const warningperiod = timeoutconfig.warningmillis;\n  // 应用的类型\n  const type = objecttype(apporparcel);\n\n  return new promise((resolve, reject) => {\n    let finished = false;\n    let errored = false;\n    // 调用钩子函数（在 load 阶段已经转换为 reduce pipeline）\n    // 传入相关属性，因为这里是异步的不影响后面在 settimeout 中\n    // 使用 warningperiod 和 timeoutconfig.millis\n    apporparcel[lifecycle](getprops(apporparcel))\n      .then((val) => {\n        // 将管道执行的结果 resolve\n        finished = true;\n        resolve(val);\n      })\n      .catch((val) => {\n        finished = true;\n        reject(val);\n      });\n    // 在 warningperiod 之后判断是否需要 warning\n    settimeout(() => maybetimingout(1), warningperiod);\n    // 在 timeoutconfig.millis 之后绝对是否需要终止\n    settimeout(() => maybetimingout(true), timeoutconfig.millis);\n\n    const errmsg = formaterrormessage(\n      // ......\n    );\n\n    function maybetimingout(shoulderror) {\n      // 没有 finished 才需要 warning 和 stop\n      if (!finished) {\n        if (shoulderror === true) {\n          errored = true;\n          // 如果配置 dieontimeout，则超时 reject 即可\n          if (timeoutconfig.dieontimeout) {\n            reject(error(errmsg));\n          } else {\n            // 即时超时也要等待应用生命周期执行完毕\n            console.error(errmsg);\n            //don't resolve or reject, we're waiting this one out\n          }\n        } else if (!errored) {\n          // shoulderror 是数字表示 waning 重试次数\n          const numwarnings = shoulderror;\n          // 重试时间\n          const nummillis = numwarnings * warningperiod;\n          console.warn(errmsg);\n          // 重试 waning，直到 finished\n          if (nummillis + warningperiod < timeoutconfig.millis) {\n            settimeout(() => maybetimingout(numwarnings + 1), warningperiod);\n          }\n        }\n      }\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n这里比较巧妙的是报错和报警的处理和任务队列的处理。\n\n生命周期的钩子数组处理为任务数组（回调数组），以 promise 的方式在微任务中逐个执行，执行所有的任务都完成。这对于简单的任务队列是可以参考的，而反观 react 中调度器中的任务队列，实际上是实现了更为复杂的功能包括基于优先级的回调、任务的中断与恢复、任务的时间切片等。\n\n这样的简单任务队列在 promise 的支持下也实现了任务的切片执行，这使得计算量较大的任务可以单独在一个微任务中执行，这提高了任务执行的效率，同时整个任务的执行过程也变得异步。\n\nmaybetimingout 可以对任务队列的超时状况进行报警，方便开发者进行性能调优和错误监控。",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"生命周期：mount 和 unmount",frontmatter:{title:"生命周期：mount 和 unmount",date:"2022-04-18T15:22:01.000Z",permalink:"/single-spa/lifecycle/mount/",categories:["single-spa源码","lifecycles生命周期"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/20.lifecycles%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/30.mount.html",relativePath:"30.web/5.single-spa源码/20.lifecycles与生命周期管理/30.mount.md",key:"v-4dfd12d8",path:"/single-spa/lifecycle/mount/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:172},{level:2,title:"toMountPromise",slug:"tomountpromise",normalizedTitle:"tomountpromise",charIndex:187},{level:2,title:"toUnmountPromise",slug:"tounmountpromise",normalizedTitle:"tounmountpromise",charIndex:205}],excerpt:"<TimeToRead />\n<p>本节讲解 single-spa 生命周期中 mount 和 unmount 函数的原理。在 single-spa 中 mount 阶段是在 update 阶段之前，bootstrap 阶段之后的阶段。mount 阶段的主要任务是执行 mount 阶段的钩子。unmount 则需要 unmount app 和 app.parcels。</p>\n",readingTime:{text:"3 min read",minutes:2.53,time:151799.99999999997,words:506},headersStr:"目录 toMountPromise toUnmountPromise",content:'本节讲解 single-spa 生命周期中 mount 和 unmount 函数的原理。在 single-spa 中 mount 阶段是在 update 阶段之前，bootstrap 阶段之后的阶段。mount 阶段的主要任务是执行 mount 阶段的钩子。unmount 则需要 unmount app 和 app.parcels。\n\n\n# 目录\n\n\n\n * 目录\n * toMountPromise\n * toUnmountPromise\n\n\n\n\n# toMountPromise\n\ntoMountPromise 函数 mount 微应用。\n\nexport function toMountPromise(appOrParcel, hardFail) {\n  return Promise.resolve().then(() => {\n    // 状态必须为 NOT_MOUNTED\n    if (appOrParcel.status !== NOT_MOUNTED) {\n      return appOrParcel;\n    }\n    // 首次执行 mount 操作，dispatch before-first-mount 事件\n    if (!beforeFirstMountFired) {\n      window.dispatchEvent(new CustomEvent("single-spa:before-first-mount"));\n      beforeFirstMountFired = true;\n    }\n\n    return reasonableTime(appOrParcel, "mount")\n      .then(() => {\n        // mount 成功，将状态更新为 MOUNTED\n        appOrParcel.status = MOUNTED;\n        // 首次执行 mount 操作执行成功，dispatch first-mount 事件\n        if (!firstMountFired) {\n          window.dispatchEvent(new CustomEvent("single-spa:first-mount"));\n          firstMountFired = true;\n        }\n\n        return appOrParcel;\n      })\n      .catch((err) => {\n        // If we fail to mount the appOrParcel, we should attempt to unmount it before putting in SKIP_BECAUSE_BROKEN\n        // We temporarily put the appOrParcel into MOUNTED status so that toUnmountPromise actually attempts to unmount it\n        // instead of just doing a no-op.\n        // 如果 mount 过程发生错误，则执行 unmount\n        // 先将状态更新为 MOUNTED，以便 toUnmountPromise 能够执行 unmount。\n        appOrParcel.status = MOUNTED;\n        return toUnmountPromise(appOrParcel, true).then(\n          setSkipBecauseBroken,\n          setSkipBecauseBroken\n        );\n\n        function setSkipBecauseBroken() {\n          if (!hardFail) {\n            handleAppError(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n            return appOrParcel;\n          } else {\n            throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n          }\n        }\n      });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n此函数核心作用是：\n\n * 执行应用上 mount 阶段的钩子。执行成功后将状态更新为 MOUNTED。\n * 如果 mount 失败，尝试 unmount 应用。\n * dispatch before-first-mount 和 first-mount 事件。这些自定义事件，在源码内部并没有使用，是暴露给外部使用的。\n\n关于这一点可以参考下面这个测试用例：\n\ndescribe(`single-spa:first-mount events`, () => {\n  it(`fires first-mount exactly once when the first app is mounted`, () => {\n    singleSpa.registerApplication("firstMount", dummyApp, () => {\n      return window.location.hash.indexOf("#/firstMount") === 0;\n    });\n    singleSpa.start();\n    let numFirstMounts = 0,\n      numBeforeFirstMounts = 0;\n\n    window.addEventListener("single-spa:first-mount", () => {\n      numBeforeFirstMounts++;\n    });\n\n    window.addEventListener("single-spa:first-mount", () => {\n      numFirstMounts++;\n    });\n\n    window.location.hash = `#/firstMount`;\n\n    return singleSpa\n      .triggerAppChange()\n      .then(() => {\n        // Unmount\n        window.location.hash = `#/`;\n        return singleSpa.triggerAppChange();\n      })\n      .then(() => {\n        // Remount (shouldn\'t trigger an event)\n        window.location.hash = `#/firstMount`;\n        return singleSpa.triggerAppChange();\n      })\n      .then(() => {\n        expect(numBeforeFirstMounts).toBe(1);\n        expect(numFirstMounts).toBe(1);\n      });\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# toUnmountPromise\n\ntoUnmountPromise 函数 unmount 微应用。\n\nexport function toUnmountPromise(appOrParcel, hardFail) {\n  return Promise.resolve().then(() => {\n    // app.status 必须是 MOUNTED\n    if (appOrParcel.status !== MOUNTED) {\n      return appOrParcel;\n    }\n    // 将 app.status 状态更新为 UNMOUNTING\n    appOrParcel.status = UNMOUNTING;\n    // 卸载应用下的子 parcel，子 parcel 依附于微应用，当微应用 unmount 时，子 parcel 均被 unmount \n    const unmountChildrenParcels = Object.keys(\n      appOrParcel.parcels\n    ).map((parcelId) => appOrParcel.parcels[parcelId].unmountThisParcel());\n\n    let parcelError;\n\n    return Promise.all(unmountChildrenParcels)\n      .then(unmountAppOrParcel, (parcelError) => {\n        // There is a parcel unmount error\n        return unmountAppOrParcel().then(() => {\n          // Unmounting the app/parcel succeeded, but unmounting its children parcels did not\n          const parentError = Error(parcelError.message);\n          if (hardFail) {\n            throw transformErr(parentError, appOrParcel, SKIP_BECAUSE_BROKEN);\n          } else {\n            handleAppError(parentError, appOrParcel, SKIP_BECAUSE_BROKEN);\n          }\n        });\n      })\n      .then(() => appOrParcel);\n    // 将 app unmount \n    function unmountAppOrParcel() {\n      // We always try to unmount the appOrParcel, even if the children parcels failed to unmount.\n      return reasonableTime(appOrParcel, "unmount")\n        .then(() => {\n          // The appOrParcel needs to stay in a broken status if its children parcels fail to unmount\n          if (!parcelError) {\n            // 如果 app 和 app.parcels 均成功 unmount，更新其状态为 NOT_MOUNTED\n            appOrParcel.status = NOT_MOUNTED;\n          }\n        })\n        .catch((err) => {\n          if (hardFail) {\n            throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n          } else {\n            handleAppError(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n          }\n        });\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n * unmount 过程中状态为 UNMOUNTING，成功后状态为 NOT_MOUNTED，失败后状态为 SKIP_BECAUSE_BROKEN。\n * unmount application 应用时，其下的 parcel 应用也会被 umount。',normalizedContent:'本节讲解 single-spa 生命周期中 mount 和 unmount 函数的原理。在 single-spa 中 mount 阶段是在 update 阶段之前，bootstrap 阶段之后的阶段。mount 阶段的主要任务是执行 mount 阶段的钩子。unmount 则需要 unmount app 和 app.parcels。\n\n\n# 目录\n\n\n\n * 目录\n * tomountpromise\n * tounmountpromise\n\n\n\n\n# tomountpromise\n\ntomountpromise 函数 mount 微应用。\n\nexport function tomountpromise(apporparcel, hardfail) {\n  return promise.resolve().then(() => {\n    // 状态必须为 not_mounted\n    if (apporparcel.status !== not_mounted) {\n      return apporparcel;\n    }\n    // 首次执行 mount 操作，dispatch before-first-mount 事件\n    if (!beforefirstmountfired) {\n      window.dispatchevent(new customevent("single-spa:before-first-mount"));\n      beforefirstmountfired = true;\n    }\n\n    return reasonabletime(apporparcel, "mount")\n      .then(() => {\n        // mount 成功，将状态更新为 mounted\n        apporparcel.status = mounted;\n        // 首次执行 mount 操作执行成功，dispatch first-mount 事件\n        if (!firstmountfired) {\n          window.dispatchevent(new customevent("single-spa:first-mount"));\n          firstmountfired = true;\n        }\n\n        return apporparcel;\n      })\n      .catch((err) => {\n        // if we fail to mount the apporparcel, we should attempt to unmount it before putting in skip_because_broken\n        // we temporarily put the apporparcel into mounted status so that tounmountpromise actually attempts to unmount it\n        // instead of just doing a no-op.\n        // 如果 mount 过程发生错误，则执行 unmount\n        // 先将状态更新为 mounted，以便 tounmountpromise 能够执行 unmount。\n        apporparcel.status = mounted;\n        return tounmountpromise(apporparcel, true).then(\n          setskipbecausebroken,\n          setskipbecausebroken\n        );\n\n        function setskipbecausebroken() {\n          if (!hardfail) {\n            handleapperror(err, apporparcel, skip_because_broken);\n            return apporparcel;\n          } else {\n            throw transformerr(err, apporparcel, skip_because_broken);\n          }\n        }\n      });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n此函数核心作用是：\n\n * 执行应用上 mount 阶段的钩子。执行成功后将状态更新为 mounted。\n * 如果 mount 失败，尝试 unmount 应用。\n * dispatch before-first-mount 和 first-mount 事件。这些自定义事件，在源码内部并没有使用，是暴露给外部使用的。\n\n关于这一点可以参考下面这个测试用例：\n\ndescribe(`single-spa:first-mount events`, () => {\n  it(`fires first-mount exactly once when the first app is mounted`, () => {\n    singlespa.registerapplication("firstmount", dummyapp, () => {\n      return window.location.hash.indexof("#/firstmount") === 0;\n    });\n    singlespa.start();\n    let numfirstmounts = 0,\n      numbeforefirstmounts = 0;\n\n    window.addeventlistener("single-spa:first-mount", () => {\n      numbeforefirstmounts++;\n    });\n\n    window.addeventlistener("single-spa:first-mount", () => {\n      numfirstmounts++;\n    });\n\n    window.location.hash = `#/firstmount`;\n\n    return singlespa\n      .triggerappchange()\n      .then(() => {\n        // unmount\n        window.location.hash = `#/`;\n        return singlespa.triggerappchange();\n      })\n      .then(() => {\n        // remount (shouldn\'t trigger an event)\n        window.location.hash = `#/firstmount`;\n        return singlespa.triggerappchange();\n      })\n      .then(() => {\n        expect(numbeforefirstmounts).tobe(1);\n        expect(numfirstmounts).tobe(1);\n      });\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# tounmountpromise\n\ntounmountpromise 函数 unmount 微应用。\n\nexport function tounmountpromise(apporparcel, hardfail) {\n  return promise.resolve().then(() => {\n    // app.status 必须是 mounted\n    if (apporparcel.status !== mounted) {\n      return apporparcel;\n    }\n    // 将 app.status 状态更新为 unmounting\n    apporparcel.status = unmounting;\n    // 卸载应用下的子 parcel，子 parcel 依附于微应用，当微应用 unmount 时，子 parcel 均被 unmount \n    const unmountchildrenparcels = object.keys(\n      apporparcel.parcels\n    ).map((parcelid) => apporparcel.parcels[parcelid].unmountthisparcel());\n\n    let parcelerror;\n\n    return promise.all(unmountchildrenparcels)\n      .then(unmountapporparcel, (parcelerror) => {\n        // there is a parcel unmount error\n        return unmountapporparcel().then(() => {\n          // unmounting the app/parcel succeeded, but unmounting its children parcels did not\n          const parenterror = error(parcelerror.message);\n          if (hardfail) {\n            throw transformerr(parenterror, apporparcel, skip_because_broken);\n          } else {\n            handleapperror(parenterror, apporparcel, skip_because_broken);\n          }\n        });\n      })\n      .then(() => apporparcel);\n    // 将 app unmount \n    function unmountapporparcel() {\n      // we always try to unmount the apporparcel, even if the children parcels failed to unmount.\n      return reasonabletime(apporparcel, "unmount")\n        .then(() => {\n          // the apporparcel needs to stay in a broken status if its children parcels fail to unmount\n          if (!parcelerror) {\n            // 如果 app 和 app.parcels 均成功 unmount，更新其状态为 not_mounted\n            apporparcel.status = not_mounted;\n          }\n        })\n        .catch((err) => {\n          if (hardfail) {\n            throw transformerr(err, apporparcel, skip_because_broken);\n          } else {\n            handleapperror(err, apporparcel, skip_because_broken);\n          }\n        });\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n * unmount 过程中状态为 unmounting，成功后状态为 not_mounted，失败后状态为 skip_because_broken。\n * unmount application 应用时，其下的 parcel 应用也会被 umount。',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"生命周期：update",frontmatter:{title:"生命周期：update",date:"2022-04-18T16:06:26.000Z",permalink:"/single-spa/lifecycle/update/",categories:["single-spa源码","lifecycles生命周期"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/20.lifecycles%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/40.update.html",relativePath:"30.web/5.single-spa源码/20.lifecycles与生命周期管理/40.update.md",key:"v-3336f808",path:"/single-spa/lifecycle/update/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:84},{level:2,title:"toUpdatePromise",slug:"toupdatepromise",normalizedTitle:"toupdatepromise",charIndex:99}],excerpt:"<TimeToRead />\n<p>本节讲解 single-spa 生命周期中 update 函数的原理。在 single-spa 中 update 是在 mount 之后，应用需要更新时执行。</p>\n",readingTime:{text:"1 min read",minutes:.395,time:23700.000000000004,words:79},headersStr:"目录 toUpdatePromise",content:'本节讲解 single-spa 生命周期中 update 函数的原理。在 single-spa 中 update 是在 mount 之后，应用需要更新时执行。\n\n\n# 目录\n\n\n\n * 目录\n * toUpdatePromise\n\n\n\n\n# toUpdatePromise\n\nexport function toUpdatePromise(parcel) {\n  return Promise.resolve().then(() => {\n    if (parcel.status !== MOUNTED) {\n      throw Error(\n        // ......\n      );\n    }\n\n    parcel.status = UPDATING;\n\n    return reasonableTime(parcel, "update")\n      .then(() => {\n        // 更新的钩子执行完毕将状态重置为 MOUNTED\n        parcel.status = MOUNTED;\n        return parcel;\n      })\n      .catch((err) => {\n        throw transformErr(err, parcel, SKIP_BECAUSE_BROKEN);\n      });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 更新过程中状态设置为 UPDATING，更新完毕状态重置为 MOUNTED。\n * update 钩子主要用于 parcel 应用。',normalizedContent:'本节讲解 single-spa 生命周期中 update 函数的原理。在 single-spa 中 update 是在 mount 之后，应用需要更新时执行。\n\n\n# 目录\n\n\n\n * 目录\n * toupdatepromise\n\n\n\n\n# toupdatepromise\n\nexport function toupdatepromise(parcel) {\n  return promise.resolve().then(() => {\n    if (parcel.status !== mounted) {\n      throw error(\n        // ......\n      );\n    }\n\n    parcel.status = updating;\n\n    return reasonabletime(parcel, "update")\n      .then(() => {\n        // 更新的钩子执行完毕将状态重置为 mounted\n        parcel.status = mounted;\n        return parcel;\n      })\n      .catch((err) => {\n        throw transformerr(err, parcel, skip_because_broken);\n      });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n * 更新过程中状态设置为 updating，更新完毕状态重置为 mounted。\n * update 钩子主要用于 parcel 应用。',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"本章概要",frontmatter:{title:"本章概要",date:"2022-04-18T17:06:55.000Z",permalink:"/single-spa/nav/index/",categories:["single-spa源码","navigation路由管理"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/30.navigation%E4%B8%8E%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86/0.index.html",relativePath:"30.web/5.single-spa源码/30.navigation与路由管理/0.index.md",key:"v-3bd3e459",path:"/single-spa/nav/index/",excerpt:"<p>在上一章  <code>lifecycles生命周期管理</code>  的内容中，我们探讨到了 single-spa 的微应用生命周期的管理，包括 bootstrap 初始化应用、mount 和 unmount、load 和 unload、update 更新应用。在这些生命周期中，最重要的就是要执行外界传入的应用的生命周期钩子去完成微应用的行为变化，同时在 s-spa 内部去管理应用和应用的生命周期。</p>\n<p>在这一章中，我们将探讨 single-spa 路由管理的原因，这也是微前端中极其重要的一环。从导出看，源码导出了  <code>navigateToUrl</code>  和  <code>triggerAppChange</code>  两个路由相关的 API。本章将以此如突破口进行探讨。</p>\n",readingTime:{text:"1 min read",minutes:.125,time:7500,words:25},headersStr:null,content:"在上一章 lifecycles生命周期管理 的内容中，我们探讨到了 single-spa 的微应用生命周期的管理，包括 bootstrap 初始化应用、mount 和 unmount、load 和 unload、update 更新应用。在这些生命周期中，最重要的就是要执行外界传入的应用的生命周期钩子去完成微应用的行为变化，同时在 s-spa 内部去管理应用和应用的生命周期。\n\n在这一章中，我们将探讨 single-spa 路由管理的原因，这也是微前端中极其重要的一环。从导出看，源码导出了 navigateToUrl 和 triggerAppChange 两个路由相关的 API。本章将以此如突破口进行探讨。",normalizedContent:"在上一章 lifecycles生命周期管理 的内容中，我们探讨到了 single-spa 的微应用生命周期的管理，包括 bootstrap 初始化应用、mount 和 unmount、load 和 unload、update 更新应用。在这些生命周期中，最重要的就是要执行外界传入的应用的生命周期钩子去完成微应用的行为变化，同时在 s-spa 内部去管理应用和应用的生命周期。\n\n在这一章中，我们将探讨 single-spa 路由管理的原因，这也是微前端中极其重要的一环。从导出看，源码导出了 navigatetourl 和 triggerappchange 两个路由相关的 api。本章将以此如突破口进行探讨。",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"navigation-events 路由监听",frontmatter:{title:"navigation-events 路由监听",date:"2022-04-18T17:28:37.000Z",permalink:"/single-spa/nav/events/",categories:["single-spa源码","navigation与路由管理"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/30.navigation%E4%B8%8E%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86/10.navigation-events.html",relativePath:"30.web/5.single-spa源码/30.navigation与路由管理/10.navigation-events.md",key:"v-3bb59422",path:"/single-spa/nav/events/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:164},{level:2,title:"路由监听",slug:"路由监听",normalizedTitle:"路由监听",charIndex:95},{level:2,title:"urlReroute",slug:"urlreroute",normalizedTitle:"urlreroute",charIndex:187},{level:2,title:"patchedUpdateState",slug:"patchedupdatestate",normalizedTitle:"patchedupdatestate",charIndex:201},{level:2,title:"navigateToUrl",slug:"navigatetourl",normalizedTitle:"navigatetourl",charIndex:223},{level:2,title:"createPopStateEvent",slug:"createpopstateevent",normalizedTitle:"createpopstateevent",charIndex:240}],excerpt:"<p>本节探讨 single 中路由管理部分路由的监听与代理的内容。我们知道，微应用需要根据一定的规则匹配到相应的路由，并根据路由去挂载和卸载微应用。从整体上来看，s-spa 需要完成这几件事情：路由监听、路由匹配、应用状态更新（mount 或者 unmount）。作为 s-spa 中独立的一部分，这部分具有一定的复杂度。</p>\n",readingTime:{text:"5 min read",minutes:4.105,time:246300,words:821},headersStr:"目录 路由监听 urlReroute patchedUpdateState navigateToUrl createPopStateEvent",content:'本节探讨 single 中路由管理部分路由的监听与代理的内容。我们知道，微应用需要根据一定的规则匹配到相应的路由，并根据路由去挂载和卸载微应用。从整体上来看，s-spa 需要完成这几件事情：路由监听、路由匹配、应用状态更新（mount 或者 unmount）。作为 s-spa 中独立的一部分，这部分具有一定的复杂度。\n\n\n# 目录\n\n\n\n * 目录\n * 路由监听\n * urlReroute\n * patchedUpdateState\n * navigateToUrl\n * createPopStateEvent\n\n\n\n从路由监听的角度来看我们不得不考虑以下的诸多问题：\n\n * hash 路由和 history 路由\n * url 路由变化和直接操作 history 导致 url 变化\n\n\n# 路由监听\n\n框架初始化时执行，监听 window 上 hashchange 和 popstate 事件，分别在 url hash 变化和 popstate 时触发；代码 history.pushState 和 history.replaceState，在两者执行时比较 url 是否变化。如果 url 变化将执行 reroute，调整应用匹配和应用状态更新。\n\nif (isInBrowser) {\n  // 监听 hashchange 和 popstate 事件\n  // 这里不一定是原生的 addEventListener ，因为允许被代理\n  // We will trigger an app change for any routing events.\n  window.addEventListener("hashchange", urlReroute);\n  window.addEventListener("popstate", urlReroute);\n\n  // Monkeypatch addEventListener so that we can ensure correct timing\n  const originalAddEventListener = window.addEventListener;\n  const originalRemoveEventListener = window.removeEventListener;\n  // 代理 addEventListener 和 removeEventListener\n  window.addEventListener = function (eventName, fn) {\n    // 注意，以下代码在 addEventListener 时执行一次，在 listener 被回调时不会再执行\n    if (typeof fn === "function") {\n      // 如果是需要监听的路由事件，且未在 capturedEventListeners[eventName] 上注册\n      if (\n        routingEventsListeningTo.indexOf(eventName) >= 0 &&\n        !find(capturedEventListeners[eventName], (listener) => listener === fn)\n      ) {\n        // 将 listener 注册到 capturedEventListeners\n        capturedEventListeners[eventName].push(fn);\n        // 注意：收集到 listeners 之后就返回了，由 s-spa 接管了 listeners 的调用\n        return;\n      }\n    }\n\n    return originalAddEventListener.apply(this, arguments);\n  };\n\n  window.removeEventListener = function (eventName, listenerFn) {\n    if (typeof listenerFn === "function") {\n      // 如果在 capturedEventListeners 中注册过此 listener，则将之删除\n      if (routingEventsListeningTo.indexOf(eventName) >= 0) {\n        capturedEventListeners[eventName] = capturedEventListeners[\n          eventName\n        ].filter((fn) => fn !== listenerFn);\n        return;\n      }\n    }\n\n    return originalRemoveEventListener.apply(this, arguments);\n  };\n  // 代理 history.pushState 和 history.replaceState\n  // patchedUpdateState 需要比较 url 是否变化\n  window.history.pushState = patchedUpdateState(\n    window.history.pushState,\n    "pushState"\n  );\n  window.history.replaceState = patchedUpdateState(\n    window.history.replaceState,\n    "replaceState"\n  );\n  // 如果此代码被执行了两次则出现异常\n  if (window.singleSpaNavigate) {\n    console.warn(\n      formatErrorMessage(\n        41,\n        __DEV__ &&\n          "single-spa has been loaded twice on the page. This can result in unexpected behavior."\n      )\n    );\n  } else {\n    /* For convenience in `onclick` attributes, we expose a global function for navigating to\n     * whatever an <a> tag\'s href is.\n     */\n    // 便于调用 navigateToUrl 进行导航\n    window.singleSpaNavigate = navigateToUrl;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n这个函数的主要作用如下：\n\n * 路由监听：hashchange、popstate、history.pushState 和 history.replaceState。\n * 代理 window.addEventListener 和 window.removeEventListener 手机 hashchange 和 popstate 的 listener。\n * 将 singleSpaNavigate 挂载到 window.singleSpaNavigate。\n\n\n# urlReroute\n\n由 hashchange 和 popstate 引起的 url 变化，执行 reroute。\n\nfunction urlReroute() {\n  // url 已知变化，直接 reroute\n  reroute([], arguments);\n}\n\n\n1\n2\n3\n4\n\n\n\n# patchedUpdateState\n\n由 history.pushState 和 history.replaceState 引起的 state 变化，先比较 url 是否变化，在执行 reroute。\n\nfunction patchedUpdateState(updateState, methodName) {\n  // 从 history.pushState 和 replace.replaceState，需比对 url 是否变化\n  return function () {\n    const urlBefore = window.location.href;\n    // 调用原生函数\n    const result = updateState.apply(this, arguments);\n    const urlAfter = window.location.href;\n    // 只有不是 urlRerouteOnly，且 url 发生变化\n    if (!urlRerouteOnly || urlBefore !== urlAfter) {\n      if (isStarted()) {\n        // fire an artificial popstate event once single-spa is started,\n        // so that single-spa applications know about routing that\n        // occurs in a different application\n        // 通过事件系统仿造一个 popsState 事件，以触发 reroute，并且能够使所有微应用监听到变化\n        window.dispatchEvent(\n          createPopStateEvent(window.history.state, methodName)\n        );\n      } else {\n        // do not fire an artificial popstate event before single-spa is started,\n        // since no single-spa applications need to know about routing events\n        // outside of their own router.\n        // s-spa 还未 start，不需要以事件的形式进行通知，直接执行 reroute\n        // 注意：即使还没有 start，仍然需要 reroute，因为 reroute 会针对 start 情况做处理\n        reroute([]);\n      }\n    }\n\n    return result;\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n注意\n\n如果框架已经 start，则需要以事件的方式引发 reroute，因为需要通知微应用路由的变化。这里使用 createPopStateEvent 仿造 popState 事件。\n\n\n# navigateToUrl\n\n> Use this utility function to easily perform url navigation between registered applications without needing to deal with event.preventDefault(), pushState, triggerAppChange(), etc.\n\n/**\n * see https://single-spa.js.org/docs/api/#navigatetourl\n * 不使用任何框架导航到目标 url，同时触发应用的更新 triggerAppChange\n */\nexport function navigateToUrl(obj) {\n  let url;\n  // obj 为 url\n  if (typeof obj === "string") {\n    url = obj;\n  } else if (this && this.href) {\n    // obj 为 a 标签\n    url = this.href;\n  } else if (\n    // object 为 ClickEvent\n    obj &&\n    obj.currentTarget &&\n    obj.currentTarget.href &&\n    obj.preventDefault\n  ) {\n    url = obj.currentTarget.href;\n    obj.preventDefault();\n  } else {\n    throw Error(\n      // ......\n    );\n  }\n  // 将 currentUrl 和 url 分别生成 a 标签\n  const current = parseUri(window.location.href);\n  const destination = parseUri(url);\n \n  if (url.indexOf("#") === 0) {\n    // url 是 hash \n    window.location.hash = destination.hash;\n  } else if (current.host !== destination.host && destination.host) {\n    if (process.env.BABEL_ENV === "test") {\n      return { wouldHaveReloadedThePage: true };\n    } else {\n      // 改变了 host\n      window.location.href = url;\n    }\n  } else if (\n    destination.pathname === current.pathname &&\n    destination.search === current.search\n  ) {\n    // pathname 和 search 没有变\n    window.location.hash = destination.hash;\n  } else {\n    // different path, host, or query params\n    window.history.pushState(null, null, url);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\nnavigateToUrl 方法不依赖于其他框架的路由组件，提供导航的功能，同时帮助我们触发 reroute。\n\n\n# createPopStateEvent\n\ncreatePopStateEvent 创建一个 popState 事件。在 history.pushState 和 history.replaceState 被调用且 url 发生变化时，主动发出一个 popState 事件，以使微应用可以监听到此事件而得知路由发生了变化。\n\nfunction createPopStateEvent(state, originalMethodName) {\n  // https://github.com/single-spa/single-spa/issues/224 and https://github.com/single-spa/single-spa-angular/issues/49\n  // We need a popstate event even though the browser doesn\'t do one by default when you call replaceState, so that\n  // all the applications can reroute. We explicitly identify this extraneous event by setting singleSpa=true and\n  // singleSpaTrigger=<pushState|replaceState> on the event instance.\n  let evt;\n  try {\n    // IE 浏览器不支持 PopStateEvent()， see https://caniuse.com/mdn-api_popstateevent_popstateevent\n    evt = new PopStateEvent("popstate", { state });\n  } catch (err) {\n    // IE 11 compatibility https://github.com/single-spa/single-spa/issues/299\n    // https://docs.microsoft.com/en-us/openspecs/ie_standards/ms-html5e/bd560f47-b349-4d2c-baa8-f1560fb489dd\n    evt = document.createEvent("PopStateEvent");\n    // nitializes the properties of a PopStateEvent object.Available only in IE10, IE11, and EdgeHTML Mode (All Versions).\n    evt.initPopStateEvent("popstate", false, false, state);\n  }\n  // 区分其他 popState 事件\n  evt.singleSpa = true;\n  evt.singleSpaTrigger = originalMethodName;\n  return evt;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在外界的应用中，同样可以通过监听 hashchange 和 popState 事件以得知 url 发生了变化，而不用额外封装 history.pushState 和 history.replaceState 。\n\n参考：\n\n * Events | single-spa',normalizedContent:'本节探讨 single 中路由管理部分路由的监听与代理的内容。我们知道，微应用需要根据一定的规则匹配到相应的路由，并根据路由去挂载和卸载微应用。从整体上来看，s-spa 需要完成这几件事情：路由监听、路由匹配、应用状态更新（mount 或者 unmount）。作为 s-spa 中独立的一部分，这部分具有一定的复杂度。\n\n\n# 目录\n\n\n\n * 目录\n * 路由监听\n * urlreroute\n * patchedupdatestate\n * navigatetourl\n * createpopstateevent\n\n\n\n从路由监听的角度来看我们不得不考虑以下的诸多问题：\n\n * hash 路由和 history 路由\n * url 路由变化和直接操作 history 导致 url 变化\n\n\n# 路由监听\n\n框架初始化时执行，监听 window 上 hashchange 和 popstate 事件，分别在 url hash 变化和 popstate 时触发；代码 history.pushstate 和 history.replacestate，在两者执行时比较 url 是否变化。如果 url 变化将执行 reroute，调整应用匹配和应用状态更新。\n\nif (isinbrowser) {\n  // 监听 hashchange 和 popstate 事件\n  // 这里不一定是原生的 addeventlistener ，因为允许被代理\n  // we will trigger an app change for any routing events.\n  window.addeventlistener("hashchange", urlreroute);\n  window.addeventlistener("popstate", urlreroute);\n\n  // monkeypatch addeventlistener so that we can ensure correct timing\n  const originaladdeventlistener = window.addeventlistener;\n  const originalremoveeventlistener = window.removeeventlistener;\n  // 代理 addeventlistener 和 removeeventlistener\n  window.addeventlistener = function (eventname, fn) {\n    // 注意，以下代码在 addeventlistener 时执行一次，在 listener 被回调时不会再执行\n    if (typeof fn === "function") {\n      // 如果是需要监听的路由事件，且未在 capturedeventlisteners[eventname] 上注册\n      if (\n        routingeventslisteningto.indexof(eventname) >= 0 &&\n        !find(capturedeventlisteners[eventname], (listener) => listener === fn)\n      ) {\n        // 将 listener 注册到 capturedeventlisteners\n        capturedeventlisteners[eventname].push(fn);\n        // 注意：收集到 listeners 之后就返回了，由 s-spa 接管了 listeners 的调用\n        return;\n      }\n    }\n\n    return originaladdeventlistener.apply(this, arguments);\n  };\n\n  window.removeeventlistener = function (eventname, listenerfn) {\n    if (typeof listenerfn === "function") {\n      // 如果在 capturedeventlisteners 中注册过此 listener，则将之删除\n      if (routingeventslisteningto.indexof(eventname) >= 0) {\n        capturedeventlisteners[eventname] = capturedeventlisteners[\n          eventname\n        ].filter((fn) => fn !== listenerfn);\n        return;\n      }\n    }\n\n    return originalremoveeventlistener.apply(this, arguments);\n  };\n  // 代理 history.pushstate 和 history.replacestate\n  // patchedupdatestate 需要比较 url 是否变化\n  window.history.pushstate = patchedupdatestate(\n    window.history.pushstate,\n    "pushstate"\n  );\n  window.history.replacestate = patchedupdatestate(\n    window.history.replacestate,\n    "replacestate"\n  );\n  // 如果此代码被执行了两次则出现异常\n  if (window.singlespanavigate) {\n    console.warn(\n      formaterrormessage(\n        41,\n        __dev__ &&\n          "single-spa has been loaded twice on the page. this can result in unexpected behavior."\n      )\n    );\n  } else {\n    /* for convenience in `onclick` attributes, we expose a global function for navigating to\n     * whatever an <a> tag\'s href is.\n     */\n    // 便于调用 navigatetourl 进行导航\n    window.singlespanavigate = navigatetourl;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n这个函数的主要作用如下：\n\n * 路由监听：hashchange、popstate、history.pushstate 和 history.replacestate。\n * 代理 window.addeventlistener 和 window.removeeventlistener 手机 hashchange 和 popstate 的 listener。\n * 将 singlespanavigate 挂载到 window.singlespanavigate。\n\n\n# urlreroute\n\n由 hashchange 和 popstate 引起的 url 变化，执行 reroute。\n\nfunction urlreroute() {\n  // url 已知变化，直接 reroute\n  reroute([], arguments);\n}\n\n\n1\n2\n3\n4\n\n\n\n# patchedupdatestate\n\n由 history.pushstate 和 history.replacestate 引起的 state 变化，先比较 url 是否变化，在执行 reroute。\n\nfunction patchedupdatestate(updatestate, methodname) {\n  // 从 history.pushstate 和 replace.replacestate，需比对 url 是否变化\n  return function () {\n    const urlbefore = window.location.href;\n    // 调用原生函数\n    const result = updatestate.apply(this, arguments);\n    const urlafter = window.location.href;\n    // 只有不是 urlrerouteonly，且 url 发生变化\n    if (!urlrerouteonly || urlbefore !== urlafter) {\n      if (isstarted()) {\n        // fire an artificial popstate event once single-spa is started,\n        // so that single-spa applications know about routing that\n        // occurs in a different application\n        // 通过事件系统仿造一个 popsstate 事件，以触发 reroute，并且能够使所有微应用监听到变化\n        window.dispatchevent(\n          createpopstateevent(window.history.state, methodname)\n        );\n      } else {\n        // do not fire an artificial popstate event before single-spa is started,\n        // since no single-spa applications need to know about routing events\n        // outside of their own router.\n        // s-spa 还未 start，不需要以事件的形式进行通知，直接执行 reroute\n        // 注意：即使还没有 start，仍然需要 reroute，因为 reroute 会针对 start 情况做处理\n        reroute([]);\n      }\n    }\n\n    return result;\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n注意\n\n如果框架已经 start，则需要以事件的方式引发 reroute，因为需要通知微应用路由的变化。这里使用 createpopstateevent 仿造 popstate 事件。\n\n\n# navigatetourl\n\n> use this utility function to easily perform url navigation between registered applications without needing to deal with event.preventdefault(), pushstate, triggerappchange(), etc.\n\n/**\n * see https://single-spa.js.org/docs/api/#navigatetourl\n * 不使用任何框架导航到目标 url，同时触发应用的更新 triggerappchange\n */\nexport function navigatetourl(obj) {\n  let url;\n  // obj 为 url\n  if (typeof obj === "string") {\n    url = obj;\n  } else if (this && this.href) {\n    // obj 为 a 标签\n    url = this.href;\n  } else if (\n    // object 为 clickevent\n    obj &&\n    obj.currenttarget &&\n    obj.currenttarget.href &&\n    obj.preventdefault\n  ) {\n    url = obj.currenttarget.href;\n    obj.preventdefault();\n  } else {\n    throw error(\n      // ......\n    );\n  }\n  // 将 currenturl 和 url 分别生成 a 标签\n  const current = parseuri(window.location.href);\n  const destination = parseuri(url);\n \n  if (url.indexof("#") === 0) {\n    // url 是 hash \n    window.location.hash = destination.hash;\n  } else if (current.host !== destination.host && destination.host) {\n    if (process.env.babel_env === "test") {\n      return { wouldhavereloadedthepage: true };\n    } else {\n      // 改变了 host\n      window.location.href = url;\n    }\n  } else if (\n    destination.pathname === current.pathname &&\n    destination.search === current.search\n  ) {\n    // pathname 和 search 没有变\n    window.location.hash = destination.hash;\n  } else {\n    // different path, host, or query params\n    window.history.pushstate(null, null, url);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\nnavigatetourl 方法不依赖于其他框架的路由组件，提供导航的功能，同时帮助我们触发 reroute。\n\n\n# createpopstateevent\n\ncreatepopstateevent 创建一个 popstate 事件。在 history.pushstate 和 history.replacestate 被调用且 url 发生变化时，主动发出一个 popstate 事件，以使微应用可以监听到此事件而得知路由发生了变化。\n\nfunction createpopstateevent(state, originalmethodname) {\n  // https://github.com/single-spa/single-spa/issues/224 and https://github.com/single-spa/single-spa-angular/issues/49\n  // we need a popstate event even though the browser doesn\'t do one by default when you call replacestate, so that\n  // all the applications can reroute. we explicitly identify this extraneous event by setting singlespa=true and\n  // singlespatrigger=<pushstate|replacestate> on the event instance.\n  let evt;\n  try {\n    // ie 浏览器不支持 popstateevent()， see https://caniuse.com/mdn-api_popstateevent_popstateevent\n    evt = new popstateevent("popstate", { state });\n  } catch (err) {\n    // ie 11 compatibility https://github.com/single-spa/single-spa/issues/299\n    // https://docs.microsoft.com/en-us/openspecs/ie_standards/ms-html5e/bd560f47-b349-4d2c-baa8-f1560fb489dd\n    evt = document.createevent("popstateevent");\n    // nitializes the properties of a popstateevent object.available only in ie10, ie11, and edgehtml mode (all versions).\n    evt.initpopstateevent("popstate", false, false, state);\n  }\n  // 区分其他 popstate 事件\n  evt.singlespa = true;\n  evt.singlespatrigger = originalmethodname;\n  return evt;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在外界的应用中，同样可以通过监听 hashchange 和 popstate 事件以得知 url 发生了变化，而不用额外封装 history.pushstate 和 history.replacestate 。\n\n参考：\n\n * events | single-spa',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"reroute 根据路由更新应用状态",frontmatter:{title:"reroute 根据路由更新应用状态",date:"2022-04-18T17:25:22.000Z",permalink:"/single-spa/nav/reroute/",categories:["single-spa源码","navigation与路由管理"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/30.navigation%E4%B8%8E%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86/20.reroute.html",relativePath:"30.web/5.single-spa源码/30.navigation与路由管理/20.reroute.md",key:"v-44bace4f",path:"/single-spa/nav/reroute/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:375},{level:2,title:"学习目标",slug:"学习目标",normalizedTitle:"学习目标",charIndex:390},{level:2,title:"reroute",slug:"reroute",normalizedTitle:"reroute",charIndex:103},{level:3,title:"为什么收集 hashchange 和 popstate 的 listeners?",slug:"为什么收集-hashchange-和-popstate-的-listeners",normalizedTitle:"为什么收集 hashchange 和 popstate 的 listeners?",charIndex:411},{level:3,title:"为什么 cancelNavigation 能够取消导航？",slug:"为什么-cancelnavigation-能够取消导航",normalizedTitle:"为什么 cancelnavigation 能够取消导航？",charIndex:457},{level:3,title:"函数互斥锁与任务队列",slug:"函数互斥锁与任务队列",normalizedTitle:"函数互斥锁与任务队列",charIndex:491},{level:3,title:"事件的触发顺序及含义",slug:"事件的触发顺序及含义",normalizedTitle:"事件的触发顺序及含义",charIndex:507},{level:2,title:"tryToBootstrapAndMount",slug:"trytobootstrapandmount",normalizedTitle:"trytobootstrapandmount",charIndex:521},{level:2,title:"callCapturedEventListeners",slug:"callcapturedeventlisteners",normalizedTitle:"callcapturedeventlisteners",charIndex:547},{level:2,title:"triggerAppChange",slug:"triggerappchange",normalizedTitle:"triggerappchange",charIndex:577}],excerpt:"<TimeToRead />\n<p>在上一节中，我们已经了解到 s-spa 会监听到各种 url 变化的事件（注： <code>history.pushState</code>  和  <code>history.replaceState</code>  是通过代理（劫持）来实现监听的），并且调用 reroute 以根据路由状态的变化来更新应用的状态。从整体上说，reroute 模块是路由管理和应用生命周期管理的桥梁。</p>\n<p>在 s-spa 的概念中，applications 指的是  <code>为一组特定路由而渲染的微前端组件</code> 。也就是说 applications 的生命周期是受到路由控制的。当前还有一种  <code>不受路由控制，独立渲染的微前端组件</code>  的组件成为 parcel。这属于是 s-spa 中一个很独特和进阶的概念，将在下一章节中探讨。</p>\n<p>在本节的内容中，我们将探讨 reroute 的原理，了解 reroute 是如何更新应用的生命状态。</p>\n",readingTime:{text:"9 min read",minutes:8.485,time:509099.99999999994,words:1697},headersStr:"目录 学习目标 reroute 为什么收集 hashchange 和 popstate 的 listeners? 为什么 cancelNavigation 能够取消导航？ 函数互斥锁与任务队列 事件的触发顺序及含义 tryToBootstrapAndMount callCapturedEventListeners triggerAppChange",content:'在上一节中，我们已经了解到 s-spa 会监听到各种 url 变化的事件（注： history.pushState 和 history.replaceState 是通过代理（劫持）来实现监听的），并且调用 reroute 以根据路由状态的变化来更新应用的状态。从整体上说，reroute 模块是路由管理和应用生命周期管理的桥梁。\n\n在 s-spa 的概念中，applications 指的是 为一组特定路由而渲染的微前端组件 。也就是说 applications 的生命周期是受到路由控制的。当前还有一种 不受路由控制，独立渲染的微前端组件 的组件成为 parcel。这属于是 s-spa 中一个很独特和进阶的概念，将在下一章节中探讨。\n\n在本节的内容中，我们将探讨 reroute 的原理，了解 reroute 是如何更新应用的生命状态。\n\n\n# 目录\n\n\n\n * 目录\n * 学习目标\n * reroute\n   * 为什么收集 hashchange 和 popstate 的 listeners?\n   * 为什么 cancelNavigation 能够取消导航？\n   * 函数互斥锁与任务队列\n   * 事件的触发顺序及含义\n * tryToBootstrapAndMount\n * callCapturedEventListeners\n * triggerAppChange\n\n\n\n\n# 学习目标\n\n * 学习 reroute 根据路由变化更新应用的生命状态的原理。\n * 了解应用的生命周期是如何与路由监听和路由变化联动的。\n\n\n# reroute\n\n在 single-spa 中写的最精彩的代码就是应用生命周期的代码和路由管理的代码，尤其是 reroute 的代码。建议精读 reroute 的代码，体会其中使用的编程技巧。在这段代码里，使用了非阻塞式编程（出神入化的 Promise 的使用）、非阻塞式错误处理、函数互斥锁与任务队列、事件消息钩子等。\n\n// 是否正在处理 reroute，互斥锁\nlet appChangeUnderway = false,\n  // 等待 reroute 的任务队列\n  peopleWaitingOnAppChange = [],\n  // 上一次 url\n  currentUrl = isInBrowser && window.location.href;\n\n// pendingPromises：需要 resolve 的 pending 的 reroute 任务，eventArguments：调用 listener 时的传参\nexport function reroute(pendingPromises = [], eventArguments) {\n  if (appChangeUnderway) {\n    // 如果 reroute 正在处理中，将 reroute 任务入队列\n    return new Promise((resolve, reject) => {\n      // 注意：这里的对象中有 reject, reject 是一个“伪造的” promise，不是真正的 promise。\n      // promise 一般是通过 then 和 catch 判断的。\n      peopleWaitingOnAppChange.push({\n        resolve,\n        reject,\n        eventArguments,\n      });\n    });\n  }\n  // 根据新的路由状态计算生命状态需要改变的应用\n  // 需要 unload、unmount、load、mount 的应用，reroute 只处理这几个状态\n  const {\n    appsToUnload,\n    appsToUnmount,\n    appsToLoad,\n    appsToMount,\n  } = getAppChanges();\n  // 需要更新的应用\n  let appsThatChanged,\n    // 导航是否被取消\n    navigationIsCanceled = false,\n    // 更新 oldUrl 和 newUrl\n    oldUrl = currentUrl,\n    newUrl = (currentUrl = window.location.href);\n\n  if (isStarted()) {\n    // s-spa 已经启动，开启互斥锁，阻止 reroute 重复进入\n    appChangeUnderway = true;\n    // 四种类型都需要更新\n    appsThatChanged = appsToUnload.concat(\n      appsToLoad,\n      appsToUnmount,\n      appsToMount\n    );\n    // 更新应用\n    return performAppChanges();\n  } else {\n    //  s-spa 未启动，只更新需要 load 的应用以提前加载应用\n    appsThatChanged = appsToLoad;\n    // 加载应用，返回 mount 成功的应用，[]\n    return loadApps();\n  }\n\n  function cancelNavigation() {\n    navigationIsCanceled = true;\n  }\n\n  function loadApps() {\n    return Promise.resolve().then(() => {\n      // load appsToLoad 中的应用，loadPromises 是 Promise[]\n      const loadPromises = appsToLoad.map(toLoadPromise);\n\n      return (\n        Promise.all(loadPromises)\n          // 应用都 load 成功后调用 listeners\n          .then(callAllEventListeners)\n          // there are no mounted apps, before start() is called, so we always return []\n          // 由于未 start 时没有已经 mount 的应用，因此返回 []\n          .then(() => [])\n          .catch((err) => {\n            // 发生错误仍然要调用 listeners\n            callAllEventListeners();\n            throw err;\n          })\n      );\n    });\n  }\n\n  function performAppChanges() {\n    return Promise.resolve().then(() => {\n      // https://github.com/single-spa/single-spa/issues/545\n      window.dispatchEvent(\n        new CustomEvent(\n          appsThatChanged.length === 0\n            ? "single-spa:before-no-app-change"\n            : "single-spa:before-app-change",\n          getCustomEventDetail(true)\n        )\n      );\n      // 监听此事件，并且执行 cancelNavigation 可以取消导航\n      // see https://single-spa.js.org/docs/api/#canceling-navigation\n      window.dispatchEvent(\n        new CustomEvent(\n          "single-spa:before-routing-event",\n          getCustomEventDetail(true, { cancelNavigation })\n        )\n      );\n      // 如果取消了导航，返回 oldUrl，触发事件 before-mount-routing-event\n      // see https://single-spa.js.org/docs/api#canceling-navigation\n      if (navigationIsCanceled) {\n        window.dispatchEvent(\n          new CustomEvent(\n            "single-spa:before-mount-routing-event",\n            getCustomEventDetail(true)\n          )\n        );\n        finishUpAndReturn();\n        navigateToUrl(oldUrl);\n        return;\n      }\n      // unload apps promises\n      const unloadPromises = appsToUnload.map(toUnloadPromise);\n      // appsToUnmount 中的应用，要先 unmount，再 unload\n      const unmountUnloadPromises = appsToUnmount\n        .map(toUnmountPromise)\n        .map((unmountPromise) => unmountPromise.then(toUnloadPromise));\n      // 需要 unload 完成的 promises，此时并没有真正 unload\n      const allUnmountPromises = unmountUnloadPromises.concat(unloadPromises);\n      // 等待 unload 完成的 promises\n      const unmountAllPromise = Promise.all(allUnmountPromises);\n\n      unmountAllPromise.then(() => {\n        // unload 完成后，触发 before-mount-routing-event 事件\n        window.dispatchEvent(\n          new CustomEvent(\n            "single-spa:before-mount-routing-event",\n            getCustomEventDetail(true)\n          )\n        );\n      });\n\n      /* We load and bootstrap apps while other apps are unmounting, but we\n       * wait to mount the app until all apps are finishing unmounting\n       */\n      // 在上述应用 unmounting 的过程中先尝试将 appsToLoad 中的应用进行 bootstrap 和 load\n      // 在上述应用 unmounting 完成后再将 appsToLoad 和 appsToMount 中的应用进行 mount\n      const loadThenMountPromises = appsToLoad.map((app) => {\n        return toLoadPromise(app).then((app) =>\n          tryToBootstrapAndMount(app, unmountAllPromise)\n        );\n      });\n\n      /* These are the apps that are already bootstrapped and just need\n       * to be mounted. They each wait for all unmounting apps to finish up\n       * before they mount.\n       */\n      // 过滤掉已经在 appsToLoad 处理过的的应用，在调用 tryToBootstrapAndMount\n      // 注意：应用mount 顺序：load => bootstrap => mount\n      const mountPromises = appsToMount\n        .filter((appToMount) => appsToLoad.indexOf(appToMount) < 0)\n        .map((appToMount) => {\n          return tryToBootstrapAndMount(appToMount, unmountAllPromise);\n        });\n\n      return unmountAllPromise\n        .catch((err) => {\n          // 不管 unmount 成功还是失败都要调用 listeners\n          callAllEventListeners();\n          throw err;\n        })\n        .then(() => {\n          /* Now that the apps that needed to be unmounted are unmounted, their DOM navigation\n           * events (like hashchange or popstate) should have been cleaned up. So it\'s safe\n           * to let the remaining captured event listeners to handle about the DOM event.\n           */\n          // 需要被 unmount 的应用都已经 unmount\n          callAllEventListeners();\n          // 将 loadThenMountPromises 和 mountPromises 合并起来，分别对应 appsToLoad 和 appsToMount\n          return Promise.all(loadThenMountPromises.concat(mountPromises))\n            .catch((err) => {\n              // 将 pending 的 reroute 任务都 reject\n              pendingPromises.forEach((promise) => promise.reject(err));\n              throw err;\n            })\n            // 等待 finish 并返回最终 mount 的应用\n            .then(finishUpAndReturn);\n        });\n    });\n  }\n\n  function finishUpAndReturn() {\n    // 获取已经 mount 的应用\n    const returnValue = getMountedApps();\n    // 将 pending 的 reroute 任务都 resolve\n    pendingPromises.forEach((promise) => promise.resolve(returnValue));\n    // dispatch app-change 或者 no-app-change 事件\n    try {\n      const appChangeEventName =\n        appsThatChanged.length === 0\n          ? "single-spa:no-app-change"\n          : "single-spa:app-change";\n      window.dispatchEvent(\n        new CustomEvent(appChangeEventName, getCustomEventDetail())\n      );\n      // dispatch routing-event 事件\n      window.dispatchEvent(\n        new CustomEvent("single-spa:routing-event", getCustomEventDetail())\n      );\n    } catch (err) {\n      /* We use a setTimeout because if someone else\'s event handler throws an error, single-spa\n       * needs to carry on. If a listener to the event throws an error, it\'s their own fault, not\n       * single-spa\'s.\n       */\n      // 非阻塞式抛出异常\n      setTimeout(() => {\n        throw err;\n      });\n    }\n\n    /* Setting this allows for subsequent calls to reroute() to actually perform\n     * a reroute instead of just getting queued behind the current reroute call.\n     * We want to do this after the mounting/unmounting is done but before we\n     * resolve the promise for the `reroute` function.\n     */\n    // 关闭互斥锁，将会在 mount/unmount 执行完毕，reroute 还没有 resolve 之前关闭\n    appChangeUnderway = false;\n    // 处理 reroute 任务队列中的任务\n    if (peopleWaitingOnAppChange.length > 0) {\n      /* While we were rerouting, someone else triggered another reroute that got queued.\n       * So we need reroute again.\n       */\n      // Array<{resolve: any; reject: any; eventArguments: any[]}>\n      const nextPendingPromises = peopleWaitingOnAppChange;\n      // 清空任务队列\n      peopleWaitingOnAppChange = [];\n      // 再次执行 reroute，处理队列中的执行任务，因为每个任务都期待一个 promise 的结果\n      // 因此只需要执行一次，resolve 全部的结果的任务即可\n      reroute(nextPendingPromises);\n    }\n\n    return returnValue;\n  }\n\n  /* We need to call all event listeners that have been delayed because they were\n   * waiting on single-spa. This includes haschange and popstate events for both\n   * the current run of performAppChanges(), but also all of the queued event listeners.\n   * We want to call the listeners in the same order as if they had not been delayed by\n   * single-spa, which means queued ones first and then the most recent one.\n   */\n  // 调用路由监听中收集的 listeners \n  function callAllEventListeners() {\n    // 虽然任务执行可以节流，调用 listener 是伴随 reroute 调用的，不可节流\n    pendingPromises.forEach((pendingPromise) => {\n      // 队列中的任务：调用捕获的 listener 并传参\n      callCapturedEventListeners(pendingPromise.eventArguments);\n    });\n    // 当前的任务：调用捕获的 listener 并传参\n    callCapturedEventListeners(eventArguments);\n  }\n\n  // 包装一个 customEvent 事件对象的参数信息\n  // CustomEvent 使用了 https://github.com/webmodules/custom-event/blob/master/index.js\n  function getCustomEventDetail(isBeforeChanges = false, extraProperties) {\n    const newAppStatuses = {};\n    const appsByNewStatus = {\n      // for apps that were mounted\n      [MOUNTED]: [],\n      // for apps that were unmounted\n      [NOT_MOUNTED]: [],\n      // apps that were forcibly unloaded\n      [NOT_LOADED]: [],\n      // apps that attempted to do something but are broken now\n      [SKIP_BECAUSE_BROKEN]: [],\n    };\n    // 应用声明状态还未更新，需要根据四种分类进行状态预测\n    if (isBeforeChanges) {\n      appsToLoad.concat(appsToMount).forEach((app, index) => {\n        addApp(app, MOUNTED);\n      });\n      appsToUnload.forEach((app) => {\n        addApp(app, NOT_LOADED);\n      });\n      appsToUnmount.forEach((app) => {\n        addApp(app, NOT_MOUNTED);\n      });\n    } else {\n      // 应用生命状态已经更新完毕，可以根据 appsThatChanged 真实情况计算\n      appsThatChanged.forEach((app) => {\n        addApp(app);\n      });\n    }\n\n    const result = {\n      detail: {\n        newAppStatuses,\n        appsByNewStatus,\n        totalAppChanges: appsThatChanged.length,\n        originalEvent: eventArguments?.[0],\n        oldUrl,\n        newUrl,\n        navigationIsCanceled,\n      },\n    };\n    // 添加额外的属性\n    if (extraProperties) {\n      assign(result.detail, extraProperties);\n    }\n\n    return result;\n\n    function addApp(app, status) {\n      const appName = toName(app);\n      status = status || getAppStatus(appName);\n      // 将 app 状态信息加到 newAppStatuses\n      newAppStatuses[appName] = status;\n      const statusArr = (appsByNewStatus[status] =\n        appsByNewStatus[status] || []);\n      // 将 app 加入到 statusArr 相应的数组\n      statusArr.push(appName);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n\n\n\n# 为什么收集 hashchange 和 popstate 的 listeners?\n\n对于 hashchange 和 popstate 的 listeners，可能其中会有一些 DOM 的操作，开发者可能以为 url 变化了应用就变化了，使用了更新后的应用的 DOM 情况。因此需要将此 listener 进行劫持，在应用变化（load、mount）之后，再调用 listeners。\n\n\n# 为什么 cancelNavigation 能够取消导航？\n\nMDN: dispatchEvent\n\nThe dispatchEvent() method of the EventTarget sends an Event to the object, (synchronously) invoking the affected EventListeners in the appropriate order.\n\n我们可能会疑惑的是，为什么 before-routing-event 这个事件被 dispatch 之后，如果其中一个 listener 执行了 cancelNavigation ，紧随其后的 navigationIsCanceled 一定是 false。在我们的印象里，dispatchEvent 似乎是异常的，其实不然。\n\ndispatchEvent 其实是同步的，因为从其返回值大致可知。\n\n> false if event is cancelable, and at least one of the event handlers which received event called Event.preventDefault(). Otherwise true.\n\ndispatchEvent 本质上是利用了观察订阅模式，一般来说像是 emitter 会将 listener 的消息处理为同步的， dispatchEvent 也是如此。\n\n参考：\n\n * EventTarget.dispatchEvent() - Web APIs | MDN\n * javascript - Is dispatchEvent a sync or an async function - Stack Overflow\n\n\n# 函数互斥锁与任务队列\n\n// 函数互斥锁\nlet appChangeUnderway = false,\n // 函数执行任务队列\n  peopleWaitingOnAppChange = [];\n\n// pendingPromises 为 pending 任务的 promise\nfunction reroute(pendingPromises = []) {\n  if (appChangeUnderway) {\n    // 互斥锁关闭，将执行任务存入任务队列\n    return new Promise((resolve, reject) => {\n      peopleWaitingOnAppChange.push({\n        resolve,\n        reject,\n        eventArguments,\n      });\n    });\n  }\n  // ......\n  // 进入函数主体：关闭互斥锁\n  appChangeUnderway = true;\n  // ......\n \n  // 执行当前任务：等待当前任务的 promise\n  // ......\n  // 如果当前任务执行失败：将 pending 的任务 reject\n  pendingPromises.forEach((promise) => promise.reject(err));\n  // 准备函数返回值\n  let returnValue;\n  // 如果当前任务执行成功：将 pending 的任务 resolve，并 resolve 当前任务的返回值 returnValue\n  pendingPromises.forEach((promise) => promise.resolve(returnValue));\n  // 关闭互斥锁\n  appChangeUnderway = false;\n  // 处理任务队列中的任务\n  if (peopleWaitingOnAppChange.length > 0) {\n    const nextPendingPromises = peopleWaitingOnAppChange;\n    // 清空任务队列\n    peopleWaitingOnAppChange = [];\n    // 重新调用自身，将 pending 任务的 promise 传入\n    reroute(nextPendingPromises);\n  }\n\n  return returnValue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n这种方式十分巧妙，可应用于处理如下场景的函数：\n\n * 函数需要互斥执行。\n * 函数中包含大量的计算任务或者异步任务。\n * 函数业务本身需要节流（一系列的调用结果可以复用最后一次的调用结果）。\n\n这种应用场景很广泛，比如说：\n\n * 作图应用中渲染参考线系统时需要大量的计算任务。\n\n\n# 事件的触发顺序及含义\n\n部分生命周期需要参考应用生命周期章节。\n\nEVENT ORDER   EVENT NAME                                          CONDITION FOR FIRING                                  备注\n1             single-spa:before-app-change or                     Will any applications change status?                  在 reroute 之前是否将会有应用发生状态变化？\n              single-spa:before-no-app-change\n2             single-spa:before-routing-event                     —                                                     可以通过 cancelNavigation 取消导航\n3             single-spa:before-mount-routing-event               —                                                     在 unmount（inactive 应用） 之后 mount（active 应用） 之前触发\n4             single-spa:before-first-mount                       Is this the first time any application is mounting?   首次有应用被 mount 之前触发\n5             single-spa:first-mount                              Is this the first time any application was mounted?   首次有应用被 mount 之后触发\n6             single-spa:app-change or single-spa:no-app-change   Did any applications change status?                   在 reroute 之后是否有应用已经发生了状态变化？\n7             single-spa:routing-event                            —                                                     在 reroute 成功执行后触发\n\n参考：\n\n * Applications API | single-spa\n\n\n# tryToBootstrapAndMount\n\ntryToBootstrapAndMount 异步 bootstrap 应用，并且在 inactive 应用 unmounting 之后 mount active 应用。\n\n/**\n * Let\'s imagine that some kind of delay occurred during application loading.\n * The user without waiting for the application to load switched to another route,\n * this means that we shouldn\'t bootstrap and mount that application, thus we check\n * twice if that application should be active before bootstrapping and mounting.\n * https://github.com/single-spa/single-spa/issues/524\n */\nfunction tryToBootstrapAndMount(app, unmountAllPromise) {\n  // 如果应用确实被路由匹配上\n  if (shouldBeActive(app)) {\n    // 先 bootstrap 应用，注意这时可能并非所有应用都 unmount 完毕\n    return toBootstrapPromise(app).then((app) =>\n      // 等待所有应用 unmount 完毕再次判断是应用是否匹配路由，如果匹配在 mount 应用\n      // 再次判断是否匹配路由是因为在等待其他需要 unmount 应用 unmount 的过程中，路由还可能会变化\n      unmountAllPromise.then(() =>\n        shouldBeActive(app) ? toMountPromise(app) : app\n      )\n    );\n  } else {\n    return unmountAllPromise.then(() => app);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# callCapturedEventListeners\n\ncallCapturedEventListeners 调用 reroute 执行成功之前收集的 hashchange 和 popstate 的 liseners。\n\nexport function callCapturedEventListeners(eventArguments) {\n  if (eventArguments) {\n    const eventType = eventArguments[0].type;\n    // 事件类型是否是需要监听的类型\n    if (routingEventsListeningTo.indexOf(eventType) >= 0) {\n      // 调用收集的该事件类型的所有的 listener\n      capturedEventListeners[eventType].forEach((listener) => {\n        // 调用外界的 listener 错误时不能将程序中断\n        try {\n          // The error thrown by application event listener should not break single-spa down.\n          // Just like https://github.com/single-spa/single-spa/blob/85f5042dff960e40936f3a5069d56fc9477fac04/src/navigation/reroute.js#L140-L146 did\n          listener.apply(this, eventArguments);\n        } catch (e) {\n          setTimeout(() => {\n            throw e;\n          });\n        }\n      });\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# triggerAppChange\n\nexport function triggerAppChange() {\n  // Call reroute with no arguments, intentionally\n  return reroute();\n}\n\n\n1\n2\n3\n4\n\n\ns-spa 为外界提供此方法，以便开发者在内部未能正确监听到路由变化时手动更新（或者强制更新）应用的生命状态。',normalizedContent:'在上一节中，我们已经了解到 s-spa 会监听到各种 url 变化的事件（注： history.pushstate 和 history.replacestate 是通过代理（劫持）来实现监听的），并且调用 reroute 以根据路由状态的变化来更新应用的状态。从整体上说，reroute 模块是路由管理和应用生命周期管理的桥梁。\n\n在 s-spa 的概念中，applications 指的是 为一组特定路由而渲染的微前端组件 。也就是说 applications 的生命周期是受到路由控制的。当前还有一种 不受路由控制，独立渲染的微前端组件 的组件成为 parcel。这属于是 s-spa 中一个很独特和进阶的概念，将在下一章节中探讨。\n\n在本节的内容中，我们将探讨 reroute 的原理，了解 reroute 是如何更新应用的生命状态。\n\n\n# 目录\n\n\n\n * 目录\n * 学习目标\n * reroute\n   * 为什么收集 hashchange 和 popstate 的 listeners?\n   * 为什么 cancelnavigation 能够取消导航？\n   * 函数互斥锁与任务队列\n   * 事件的触发顺序及含义\n * trytobootstrapandmount\n * callcapturedeventlisteners\n * triggerappchange\n\n\n\n\n# 学习目标\n\n * 学习 reroute 根据路由变化更新应用的生命状态的原理。\n * 了解应用的生命周期是如何与路由监听和路由变化联动的。\n\n\n# reroute\n\n在 single-spa 中写的最精彩的代码就是应用生命周期的代码和路由管理的代码，尤其是 reroute 的代码。建议精读 reroute 的代码，体会其中使用的编程技巧。在这段代码里，使用了非阻塞式编程（出神入化的 promise 的使用）、非阻塞式错误处理、函数互斥锁与任务队列、事件消息钩子等。\n\n// 是否正在处理 reroute，互斥锁\nlet appchangeunderway = false,\n  // 等待 reroute 的任务队列\n  peoplewaitingonappchange = [],\n  // 上一次 url\n  currenturl = isinbrowser && window.location.href;\n\n// pendingpromises：需要 resolve 的 pending 的 reroute 任务，eventarguments：调用 listener 时的传参\nexport function reroute(pendingpromises = [], eventarguments) {\n  if (appchangeunderway) {\n    // 如果 reroute 正在处理中，将 reroute 任务入队列\n    return new promise((resolve, reject) => {\n      // 注意：这里的对象中有 reject, reject 是一个“伪造的” promise，不是真正的 promise。\n      // promise 一般是通过 then 和 catch 判断的。\n      peoplewaitingonappchange.push({\n        resolve,\n        reject,\n        eventarguments,\n      });\n    });\n  }\n  // 根据新的路由状态计算生命状态需要改变的应用\n  // 需要 unload、unmount、load、mount 的应用，reroute 只处理这几个状态\n  const {\n    appstounload,\n    appstounmount,\n    appstoload,\n    appstomount,\n  } = getappchanges();\n  // 需要更新的应用\n  let appsthatchanged,\n    // 导航是否被取消\n    navigationiscanceled = false,\n    // 更新 oldurl 和 newurl\n    oldurl = currenturl,\n    newurl = (currenturl = window.location.href);\n\n  if (isstarted()) {\n    // s-spa 已经启动，开启互斥锁，阻止 reroute 重复进入\n    appchangeunderway = true;\n    // 四种类型都需要更新\n    appsthatchanged = appstounload.concat(\n      appstoload,\n      appstounmount,\n      appstomount\n    );\n    // 更新应用\n    return performappchanges();\n  } else {\n    //  s-spa 未启动，只更新需要 load 的应用以提前加载应用\n    appsthatchanged = appstoload;\n    // 加载应用，返回 mount 成功的应用，[]\n    return loadapps();\n  }\n\n  function cancelnavigation() {\n    navigationiscanceled = true;\n  }\n\n  function loadapps() {\n    return promise.resolve().then(() => {\n      // load appstoload 中的应用，loadpromises 是 promise[]\n      const loadpromises = appstoload.map(toloadpromise);\n\n      return (\n        promise.all(loadpromises)\n          // 应用都 load 成功后调用 listeners\n          .then(callalleventlisteners)\n          // there are no mounted apps, before start() is called, so we always return []\n          // 由于未 start 时没有已经 mount 的应用，因此返回 []\n          .then(() => [])\n          .catch((err) => {\n            // 发生错误仍然要调用 listeners\n            callalleventlisteners();\n            throw err;\n          })\n      );\n    });\n  }\n\n  function performappchanges() {\n    return promise.resolve().then(() => {\n      // https://github.com/single-spa/single-spa/issues/545\n      window.dispatchevent(\n        new customevent(\n          appsthatchanged.length === 0\n            ? "single-spa:before-no-app-change"\n            : "single-spa:before-app-change",\n          getcustomeventdetail(true)\n        )\n      );\n      // 监听此事件，并且执行 cancelnavigation 可以取消导航\n      // see https://single-spa.js.org/docs/api/#canceling-navigation\n      window.dispatchevent(\n        new customevent(\n          "single-spa:before-routing-event",\n          getcustomeventdetail(true, { cancelnavigation })\n        )\n      );\n      // 如果取消了导航，返回 oldurl，触发事件 before-mount-routing-event\n      // see https://single-spa.js.org/docs/api#canceling-navigation\n      if (navigationiscanceled) {\n        window.dispatchevent(\n          new customevent(\n            "single-spa:before-mount-routing-event",\n            getcustomeventdetail(true)\n          )\n        );\n        finishupandreturn();\n        navigatetourl(oldurl);\n        return;\n      }\n      // unload apps promises\n      const unloadpromises = appstounload.map(tounloadpromise);\n      // appstounmount 中的应用，要先 unmount，再 unload\n      const unmountunloadpromises = appstounmount\n        .map(tounmountpromise)\n        .map((unmountpromise) => unmountpromise.then(tounloadpromise));\n      // 需要 unload 完成的 promises，此时并没有真正 unload\n      const allunmountpromises = unmountunloadpromises.concat(unloadpromises);\n      // 等待 unload 完成的 promises\n      const unmountallpromise = promise.all(allunmountpromises);\n\n      unmountallpromise.then(() => {\n        // unload 完成后，触发 before-mount-routing-event 事件\n        window.dispatchevent(\n          new customevent(\n            "single-spa:before-mount-routing-event",\n            getcustomeventdetail(true)\n          )\n        );\n      });\n\n      /* we load and bootstrap apps while other apps are unmounting, but we\n       * wait to mount the app until all apps are finishing unmounting\n       */\n      // 在上述应用 unmounting 的过程中先尝试将 appstoload 中的应用进行 bootstrap 和 load\n      // 在上述应用 unmounting 完成后再将 appstoload 和 appstomount 中的应用进行 mount\n      const loadthenmountpromises = appstoload.map((app) => {\n        return toloadpromise(app).then((app) =>\n          trytobootstrapandmount(app, unmountallpromise)\n        );\n      });\n\n      /* these are the apps that are already bootstrapped and just need\n       * to be mounted. they each wait for all unmounting apps to finish up\n       * before they mount.\n       */\n      // 过滤掉已经在 appstoload 处理过的的应用，在调用 trytobootstrapandmount\n      // 注意：应用mount 顺序：load => bootstrap => mount\n      const mountpromises = appstomount\n        .filter((apptomount) => appstoload.indexof(apptomount) < 0)\n        .map((apptomount) => {\n          return trytobootstrapandmount(apptomount, unmountallpromise);\n        });\n\n      return unmountallpromise\n        .catch((err) => {\n          // 不管 unmount 成功还是失败都要调用 listeners\n          callalleventlisteners();\n          throw err;\n        })\n        .then(() => {\n          /* now that the apps that needed to be unmounted are unmounted, their dom navigation\n           * events (like hashchange or popstate) should have been cleaned up. so it\'s safe\n           * to let the remaining captured event listeners to handle about the dom event.\n           */\n          // 需要被 unmount 的应用都已经 unmount\n          callalleventlisteners();\n          // 将 loadthenmountpromises 和 mountpromises 合并起来，分别对应 appstoload 和 appstomount\n          return promise.all(loadthenmountpromises.concat(mountpromises))\n            .catch((err) => {\n              // 将 pending 的 reroute 任务都 reject\n              pendingpromises.foreach((promise) => promise.reject(err));\n              throw err;\n            })\n            // 等待 finish 并返回最终 mount 的应用\n            .then(finishupandreturn);\n        });\n    });\n  }\n\n  function finishupandreturn() {\n    // 获取已经 mount 的应用\n    const returnvalue = getmountedapps();\n    // 将 pending 的 reroute 任务都 resolve\n    pendingpromises.foreach((promise) => promise.resolve(returnvalue));\n    // dispatch app-change 或者 no-app-change 事件\n    try {\n      const appchangeeventname =\n        appsthatchanged.length === 0\n          ? "single-spa:no-app-change"\n          : "single-spa:app-change";\n      window.dispatchevent(\n        new customevent(appchangeeventname, getcustomeventdetail())\n      );\n      // dispatch routing-event 事件\n      window.dispatchevent(\n        new customevent("single-spa:routing-event", getcustomeventdetail())\n      );\n    } catch (err) {\n      /* we use a settimeout because if someone else\'s event handler throws an error, single-spa\n       * needs to carry on. if a listener to the event throws an error, it\'s their own fault, not\n       * single-spa\'s.\n       */\n      // 非阻塞式抛出异常\n      settimeout(() => {\n        throw err;\n      });\n    }\n\n    /* setting this allows for subsequent calls to reroute() to actually perform\n     * a reroute instead of just getting queued behind the current reroute call.\n     * we want to do this after the mounting/unmounting is done but before we\n     * resolve the promise for the `reroute` function.\n     */\n    // 关闭互斥锁，将会在 mount/unmount 执行完毕，reroute 还没有 resolve 之前关闭\n    appchangeunderway = false;\n    // 处理 reroute 任务队列中的任务\n    if (peoplewaitingonappchange.length > 0) {\n      /* while we were rerouting, someone else triggered another reroute that got queued.\n       * so we need reroute again.\n       */\n      // array<{resolve: any; reject: any; eventarguments: any[]}>\n      const nextpendingpromises = peoplewaitingonappchange;\n      // 清空任务队列\n      peoplewaitingonappchange = [];\n      // 再次执行 reroute，处理队列中的执行任务，因为每个任务都期待一个 promise 的结果\n      // 因此只需要执行一次，resolve 全部的结果的任务即可\n      reroute(nextpendingpromises);\n    }\n\n    return returnvalue;\n  }\n\n  /* we need to call all event listeners that have been delayed because they were\n   * waiting on single-spa. this includes haschange and popstate events for both\n   * the current run of performappchanges(), but also all of the queued event listeners.\n   * we want to call the listeners in the same order as if they had not been delayed by\n   * single-spa, which means queued ones first and then the most recent one.\n   */\n  // 调用路由监听中收集的 listeners \n  function callalleventlisteners() {\n    // 虽然任务执行可以节流，调用 listener 是伴随 reroute 调用的，不可节流\n    pendingpromises.foreach((pendingpromise) => {\n      // 队列中的任务：调用捕获的 listener 并传参\n      callcapturedeventlisteners(pendingpromise.eventarguments);\n    });\n    // 当前的任务：调用捕获的 listener 并传参\n    callcapturedeventlisteners(eventarguments);\n  }\n\n  // 包装一个 customevent 事件对象的参数信息\n  // customevent 使用了 https://github.com/webmodules/custom-event/blob/master/index.js\n  function getcustomeventdetail(isbeforechanges = false, extraproperties) {\n    const newappstatuses = {};\n    const appsbynewstatus = {\n      // for apps that were mounted\n      [mounted]: [],\n      // for apps that were unmounted\n      [not_mounted]: [],\n      // apps that were forcibly unloaded\n      [not_loaded]: [],\n      // apps that attempted to do something but are broken now\n      [skip_because_broken]: [],\n    };\n    // 应用声明状态还未更新，需要根据四种分类进行状态预测\n    if (isbeforechanges) {\n      appstoload.concat(appstomount).foreach((app, index) => {\n        addapp(app, mounted);\n      });\n      appstounload.foreach((app) => {\n        addapp(app, not_loaded);\n      });\n      appstounmount.foreach((app) => {\n        addapp(app, not_mounted);\n      });\n    } else {\n      // 应用生命状态已经更新完毕，可以根据 appsthatchanged 真实情况计算\n      appsthatchanged.foreach((app) => {\n        addapp(app);\n      });\n    }\n\n    const result = {\n      detail: {\n        newappstatuses,\n        appsbynewstatus,\n        totalappchanges: appsthatchanged.length,\n        originalevent: eventarguments?.[0],\n        oldurl,\n        newurl,\n        navigationiscanceled,\n      },\n    };\n    // 添加额外的属性\n    if (extraproperties) {\n      assign(result.detail, extraproperties);\n    }\n\n    return result;\n\n    function addapp(app, status) {\n      const appname = toname(app);\n      status = status || getappstatus(appname);\n      // 将 app 状态信息加到 newappstatuses\n      newappstatuses[appname] = status;\n      const statusarr = (appsbynewstatus[status] =\n        appsbynewstatus[status] || []);\n      // 将 app 加入到 statusarr 相应的数组\n      statusarr.push(appname);\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n\n\n\n# 为什么收集 hashchange 和 popstate 的 listeners?\n\n对于 hashchange 和 popstate 的 listeners，可能其中会有一些 dom 的操作，开发者可能以为 url 变化了应用就变化了，使用了更新后的应用的 dom 情况。因此需要将此 listener 进行劫持，在应用变化（load、mount）之后，再调用 listeners。\n\n\n# 为什么 cancelnavigation 能够取消导航？\n\nmdn: dispatchevent\n\nthe dispatchevent() method of the eventtarget sends an event to the object, (synchronously) invoking the affected eventlisteners in the appropriate order.\n\n我们可能会疑惑的是，为什么 before-routing-event 这个事件被 dispatch 之后，如果其中一个 listener 执行了 cancelnavigation ，紧随其后的 navigationiscanceled 一定是 false。在我们的印象里，dispatchevent 似乎是异常的，其实不然。\n\ndispatchevent 其实是同步的，因为从其返回值大致可知。\n\n> false if event is cancelable, and at least one of the event handlers which received event called event.preventdefault(). otherwise true.\n\ndispatchevent 本质上是利用了观察订阅模式，一般来说像是 emitter 会将 listener 的消息处理为同步的， dispatchevent 也是如此。\n\n参考：\n\n * eventtarget.dispatchevent() - web apis | mdn\n * javascript - is dispatchevent a sync or an async function - stack overflow\n\n\n# 函数互斥锁与任务队列\n\n// 函数互斥锁\nlet appchangeunderway = false,\n // 函数执行任务队列\n  peoplewaitingonappchange = [];\n\n// pendingpromises 为 pending 任务的 promise\nfunction reroute(pendingpromises = []) {\n  if (appchangeunderway) {\n    // 互斥锁关闭，将执行任务存入任务队列\n    return new promise((resolve, reject) => {\n      peoplewaitingonappchange.push({\n        resolve,\n        reject,\n        eventarguments,\n      });\n    });\n  }\n  // ......\n  // 进入函数主体：关闭互斥锁\n  appchangeunderway = true;\n  // ......\n \n  // 执行当前任务：等待当前任务的 promise\n  // ......\n  // 如果当前任务执行失败：将 pending 的任务 reject\n  pendingpromises.foreach((promise) => promise.reject(err));\n  // 准备函数返回值\n  let returnvalue;\n  // 如果当前任务执行成功：将 pending 的任务 resolve，并 resolve 当前任务的返回值 returnvalue\n  pendingpromises.foreach((promise) => promise.resolve(returnvalue));\n  // 关闭互斥锁\n  appchangeunderway = false;\n  // 处理任务队列中的任务\n  if (peoplewaitingonappchange.length > 0) {\n    const nextpendingpromises = peoplewaitingonappchange;\n    // 清空任务队列\n    peoplewaitingonappchange = [];\n    // 重新调用自身，将 pending 任务的 promise 传入\n    reroute(nextpendingpromises);\n  }\n\n  return returnvalue;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n这种方式十分巧妙，可应用于处理如下场景的函数：\n\n * 函数需要互斥执行。\n * 函数中包含大量的计算任务或者异步任务。\n * 函数业务本身需要节流（一系列的调用结果可以复用最后一次的调用结果）。\n\n这种应用场景很广泛，比如说：\n\n * 作图应用中渲染参考线系统时需要大量的计算任务。\n\n\n# 事件的触发顺序及含义\n\n部分生命周期需要参考应用生命周期章节。\n\nevent order   event name                                          condition for firing                                  备注\n1             single-spa:before-app-change or                     will any applications change status?                  在 reroute 之前是否将会有应用发生状态变化？\n              single-spa:before-no-app-change\n2             single-spa:before-routing-event                     —                                                     可以通过 cancelnavigation 取消导航\n3             single-spa:before-mount-routing-event               —                                                     在 unmount（inactive 应用） 之后 mount（active 应用） 之前触发\n4             single-spa:before-first-mount                       is this the first time any application is mounting?   首次有应用被 mount 之前触发\n5             single-spa:first-mount                              is this the first time any application was mounted?   首次有应用被 mount 之后触发\n6             single-spa:app-change or single-spa:no-app-change   did any applications change status?                   在 reroute 之后是否有应用已经发生了状态变化？\n7             single-spa:routing-event                            —                                                     在 reroute 成功执行后触发\n\n参考：\n\n * applications api | single-spa\n\n\n# trytobootstrapandmount\n\ntrytobootstrapandmount 异步 bootstrap 应用，并且在 inactive 应用 unmounting 之后 mount active 应用。\n\n/**\n * let\'s imagine that some kind of delay occurred during application loading.\n * the user without waiting for the application to load switched to another route,\n * this means that we shouldn\'t bootstrap and mount that application, thus we check\n * twice if that application should be active before bootstrapping and mounting.\n * https://github.com/single-spa/single-spa/issues/524\n */\nfunction trytobootstrapandmount(app, unmountallpromise) {\n  // 如果应用确实被路由匹配上\n  if (shouldbeactive(app)) {\n    // 先 bootstrap 应用，注意这时可能并非所有应用都 unmount 完毕\n    return tobootstrappromise(app).then((app) =>\n      // 等待所有应用 unmount 完毕再次判断是应用是否匹配路由，如果匹配在 mount 应用\n      // 再次判断是否匹配路由是因为在等待其他需要 unmount 应用 unmount 的过程中，路由还可能会变化\n      unmountallpromise.then(() =>\n        shouldbeactive(app) ? tomountpromise(app) : app\n      )\n    );\n  } else {\n    return unmountallpromise.then(() => app);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# callcapturedeventlisteners\n\ncallcapturedeventlisteners 调用 reroute 执行成功之前收集的 hashchange 和 popstate 的 liseners。\n\nexport function callcapturedeventlisteners(eventarguments) {\n  if (eventarguments) {\n    const eventtype = eventarguments[0].type;\n    // 事件类型是否是需要监听的类型\n    if (routingeventslisteningto.indexof(eventtype) >= 0) {\n      // 调用收集的该事件类型的所有的 listener\n      capturedeventlisteners[eventtype].foreach((listener) => {\n        // 调用外界的 listener 错误时不能将程序中断\n        try {\n          // the error thrown by application event listener should not break single-spa down.\n          // just like https://github.com/single-spa/single-spa/blob/85f5042dff960e40936f3a5069d56fc9477fac04/src/navigation/reroute.js#l140-l146 did\n          listener.apply(this, eventarguments);\n        } catch (e) {\n          settimeout(() => {\n            throw e;\n          });\n        }\n      });\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# triggerappchange\n\nexport function triggerappchange() {\n  // call reroute with no arguments, intentionally\n  return reroute();\n}\n\n\n1\n2\n3\n4\n\n\ns-spa 为外界提供此方法，以便开发者在内部未能正确监听到路由变化时手动更新（或者强制更新）应用的生命状态。',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"本章概要",frontmatter:{title:"本章概要",date:"2022-04-18T20:18:20.000Z",permalink:"/single-spa/nav/parcel/",categories:["single-spa源码","parcel组件"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/40.parcel%E7%BB%84%E4%BB%B6/0.index.html",relativePath:"30.web/5.single-spa源码/40.parcel组件/0.index.md",key:"v-73517018",path:"/single-spa/nav/parcel/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:133}],readingTime:{text:"1 min read",minutes:.07,time:4200,words:14},headersStr:"目录",content:"一个 single-spa 的 parcel，指的是一个与框架无关的组件，由一系列功能构成，可以被手动挂载，而无需关心由哪种框架实现。注册 Parcels 和注册应用的 api 一致，不同之处在于 parcel 组件需要手动挂载，而不是通过路由匹配被激活。\n\n\n# 目录\n\n\n\n * 目录\n\n\n\n参考：\n\n * Parcels 概览",normalizedContent:"一个 single-spa 的 parcel，指的是一个与框架无关的组件，由一系列功能构成，可以被手动挂载，而无需关心由哪种框架实现。注册 parcels 和注册应用的 api 一致，不同之处在于 parcel 组件需要手动挂载，而不是通过路由匹配被激活。\n\n\n# 目录\n\n\n\n * 目录\n\n\n\n参考：\n\n * parcels 概览",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"本章概要",frontmatter:{title:"本章概要",date:"2022-04-19T17:32:50.000Z",permalink:"/single-spa/other/index/",categories:["single-spa源码","其他"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/50.%E5%85%B6%E4%BB%96/0.index.html",relativePath:"30.web/5.single-spa源码/50.其他/0.index.md",key:"v-db70af54",path:"/single-spa/other/index/",excerpt:"<p>本章将探讨在 single-spa 源码中出现的或者相关的值得学习和借鉴的内容。</p>\n",readingTime:{text:"1 min read",minutes:.03,time:1799.9999999999998,words:6},headersStr:null,content:"本章将探讨在 single-spa 源码中出现的或者相关的值得学习和借鉴的内容。",normalizedContent:"本章将探讨在 single-spa 源码中出现的或者相关的值得学习和借鉴的内容。",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"customEvent",frontmatter:{title:"customEvent",date:"2022-04-19T17:35:52.000Z",permalink:"/single-spa/other/customEvent/",categories:["more","single-spa源码","其他"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/50.%E5%85%B6%E4%BB%96/10.customEvent.html",relativePath:"30.web/5.single-spa源码/50.其他/10.customEvent.md",key:"v-e148fee0",path:"/single-spa/other/customEvent/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"EventTarget",slug:"eventtarget",normalizedTitle:"eventtarget",charIndex:17},{level:3,title:"谁继承了 EventTarget?",slug:"谁继承了-eventtarget",normalizedTitle:"谁继承了 eventtarget?",charIndex:34},{level:3,title:"Methods",slug:"methods",normalizedTitle:"methods",charIndex:57},{level:2,title:"CustomEvent",slug:"customevent",normalizedTitle:"customevent",charIndex:68}],excerpt:"<TimeToRead />\n",readingTime:{text:"2 min read",minutes:1.72,time:103200,words:344},headersStr:"目录 EventTarget 谁继承了 EventTarget? Methods CustomEvent",content:"# 目录\n\n\n\n * 目录\n * EventTarget\n   * 谁继承了 EventTarget?\n   * Methods\n * CustomEvent\n\n\n\n在很多的框架中，关于提供到框架外部的钩子的处理方法简单的有以下几种：\n\n 1. 直接在代码中注入回调、让框架类继承自 emitter 通过 emitter 处理消息 (OOP)\n 2. 在框架中导出 emitter 通过 emitter 处理消息\n 3. 使用原生的 EventTarget API 处理消息。\n 4. （以及在 webpack 源码中会介绍另外一种钩子机制，此处不再赘述。）\n\n在 single-spa 中使用了 EventTarget API 来处理钩子消息，以便开发者能够在应用的生命周期的关键时刻注入钩子的业务逻辑，使框架本身更加灵活可扩展。\n\n在本节的内容中，将详细介绍 EventTarget API。\n\n\n# EventTarget\n\n> The EventTarget interface is implemented by objects that can receive events and may have listeners for them. In other words, any target of events implements the three methods associated with this interface.\n\n\n# 谁继承了 EventTarget?\n\nElement , and its children, as well as Document and Window , are the most common event targets, but other objects can be event targets, too. For example XMLHttpRequest , AudioNode , and AudioContext are also event targets.\n\n\n# Methods\n\n * EventTarget.addEventListener(): Registers an event handler of a specific event type on the EventTarget.\n * EventTarget.removeEventListener():Removes an event listener from the EventTarget.\n * EventTarget.dispatchEvent():Dispatches an event to this EventTarget.\n\n参考：\n\n * EventTarget - Web APIs | MDN\n\n\n# CustomEvent\n\n使用如下方法兼容 CustomEvent\n\n * modern browser：global.CustomEvent\n * ie9+：document.createEvent、document.initCustomEvent\n * ie8-：document.createEventObject\n\n// https://github.com/webmodules/custom-event/blob/master/index.js\n// global 适用于 nodejs\nvar NativeCustomEvent = global.CustomEvent;\n\n// 是否使用原生 CustomEvent\nfunction useNative () {\n  try {\n    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });\n    return  'cat' === p.type && 'bar' === p.detail.foo;\n  } catch (e) {\n  }\n  return false;\n}\n\n/**\n * Cross-browser `CustomEvent` constructor.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent\n *\n * @public\n */\n\nmodule.exports = useNative() ? NativeCustomEvent :\n\n// IE >= 9\n'undefined' !== typeof document && 'function' === typeof document.createEvent ? function CustomEvent (type, params) {\n  // 支持 ie9 以上，在 document 上创建事件并且初始化\n  // ie9+ 支持 createEvent 和 initCustomEvent\n  var e = document.createEvent('CustomEvent');\n  if (params) {\n    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);\n  } else {\n    e.initCustomEvent(type, false, false, void 0);\n  }\n  return e;\n} :\n\n// IE <= 8\nfunction CustomEvent (type, params) {\n  // ie 8- 支持 createEventObject\n  var e = document.createEventObject();\n  e.type = type;\n  if (params) {\n    e.bubbles = Boolean(params.bubbles);\n    e.cancelable = Boolean(params.cancelable);\n    e.detail = params.detail;\n  } else {\n    e.bubbles = false;\n    e.cancelable = false;\n    e.detail = void 0;\n  }\n  return e;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n参考：\n\n * CustomEvent() - Web APIs | MDN",normalizedContent:"# 目录\n\n\n\n * 目录\n * eventtarget\n   * 谁继承了 eventtarget?\n   * methods\n * customevent\n\n\n\n在很多的框架中，关于提供到框架外部的钩子的处理方法简单的有以下几种：\n\n 1. 直接在代码中注入回调、让框架类继承自 emitter 通过 emitter 处理消息 (oop)\n 2. 在框架中导出 emitter 通过 emitter 处理消息\n 3. 使用原生的 eventtarget api 处理消息。\n 4. （以及在 webpack 源码中会介绍另外一种钩子机制，此处不再赘述。）\n\n在 single-spa 中使用了 eventtarget api 来处理钩子消息，以便开发者能够在应用的生命周期的关键时刻注入钩子的业务逻辑，使框架本身更加灵活可扩展。\n\n在本节的内容中，将详细介绍 eventtarget api。\n\n\n# eventtarget\n\n> the eventtarget interface is implemented by objects that can receive events and may have listeners for them. in other words, any target of events implements the three methods associated with this interface.\n\n\n# 谁继承了 eventtarget?\n\nelement , and its children, as well as document and window , are the most common event targets, but other objects can be event targets, too. for example xmlhttprequest , audionode , and audiocontext are also event targets.\n\n\n# methods\n\n * eventtarget.addeventlistener(): registers an event handler of a specific event type on the eventtarget.\n * eventtarget.removeeventlistener():removes an event listener from the eventtarget.\n * eventtarget.dispatchevent():dispatches an event to this eventtarget.\n\n参考：\n\n * eventtarget - web apis | mdn\n\n\n# customevent\n\n使用如下方法兼容 customevent\n\n * modern browser：global.customevent\n * ie9+：document.createevent、document.initcustomevent\n * ie8-：document.createeventobject\n\n// https://github.com/webmodules/custom-event/blob/master/index.js\n// global 适用于 nodejs\nvar nativecustomevent = global.customevent;\n\n// 是否使用原生 customevent\nfunction usenative () {\n  try {\n    var p = new nativecustomevent('cat', { detail: { foo: 'bar' } });\n    return  'cat' === p.type && 'bar' === p.detail.foo;\n  } catch (e) {\n  }\n  return false;\n}\n\n/**\n * cross-browser `customevent` constructor.\n *\n * https://developer.mozilla.org/en-us/docs/web/api/customevent.customevent\n *\n * @public\n */\n\nmodule.exports = usenative() ? nativecustomevent :\n\n// ie >= 9\n'undefined' !== typeof document && 'function' === typeof document.createevent ? function customevent (type, params) {\n  // 支持 ie9 以上，在 document 上创建事件并且初始化\n  // ie9+ 支持 createevent 和 initcustomevent\n  var e = document.createevent('customevent');\n  if (params) {\n    e.initcustomevent(type, params.bubbles, params.cancelable, params.detail);\n  } else {\n    e.initcustomevent(type, false, false, void 0);\n  }\n  return e;\n} :\n\n// ie <= 8\nfunction customevent (type, params) {\n  // ie 8- 支持 createeventobject\n  var e = document.createeventobject();\n  e.type = type;\n  if (params) {\n    e.bubbles = boolean(params.bubbles);\n    e.cancelable = boolean(params.cancelable);\n    e.detail = params.detail;\n  } else {\n    e.bubbles = false;\n    e.cancelable = false;\n    e.detail = void 0;\n  }\n  return e;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n参考：\n\n * customevent() - web apis | mdn",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"错误处理",frontmatter:{title:"错误处理",date:"2022-04-19T18:09:17.000Z",permalink:"/single-spa/other/error/",categories:["single-spa源码","其他"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/50.%E5%85%B6%E4%BB%96/20.error.html",relativePath:"30.web/5.single-spa源码/50.其他/20.error.md",key:"v-6644dbd4",path:"/single-spa/other/error/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"本章概要",frontmatter:{title:"本章概要",date:"2022-04-18T20:28:19.000Z",permalink:"/single-spa/spa-react/index/",categories:["single-spa源码","single-spa-react"],tags:[null]},regularPath:"/30.web/5.single-spa%E6%BA%90%E7%A0%81/60.single-spa-react/0.index.html",relativePath:"30.web/5.single-spa源码/60.single-spa-react/0.index.md",key:"v-1bd41a5b",path:"/single-spa/spa-react/index/",headers:[{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2}],readingTime:{text:"1 min read",minutes:.05,time:3e3,words:10},headersStr:"参考",content:"# 参考\n\n * single-spa/single-spa-react: a single-spa plugin for react applications",normalizedContent:"# 参考\n\n * single-spa/single-spa-react: a single-spa plugin for react applications",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"JQuery 源码分析",frontmatter:{title:"JQuery 源码分析",date:"2022-04-14T22:02:20.000Z",permalink:"/jquery/jq-book/",categories:["jquery"],tags:[null]},regularPath:"/30.web/50.jquery%E6%BA%90%E7%A0%81/10.jq-book.html",relativePath:"30.web/50.jquery源码/10.jq-book.md",key:"v-82122182",path:"/jquery/jq-book/",readingTime:{text:"1 min read",minutes:.02,time:1200,words:4},headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/25, 18:09:57",lastUpdatedTimestamp:1656151797e3},{title:"开始阅读",frontmatter:{title:"开始阅读",date:"2022-04-14T22:02:20.000Z",permalink:"/jquery/index/",categories:["jquery"],tags:[null]},regularPath:"/30.web/50.jquery%E6%BA%90%E7%A0%81/0.index.html",relativePath:"30.web/50.jquery源码/0.index.md",key:"v-1401de91",path:"/jquery/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"JQuery 源码注释",frontmatter:{title:"JQuery 源码注释",date:"2022-04-14T22:02:20.000Z",permalink:"/jquery/jq-source/",categories:["jquery"],tags:[null]},regularPath:"/30.web/50.jquery%E6%BA%90%E7%A0%81/20.jq-source.html",relativePath:"30.web/50.jquery源码/20.jq-source.md",key:"v-1ff4e09f",path:"/jquery/jq-source/",readingTime:{text:"1 min read",minutes:.02,time:1200,words:4},headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"jQuery 源码问题扩展",frontmatter:{title:"jQuery 源码问题扩展",date:"2022-04-14T22:02:20.000Z",permalink:"/jquery/extend/",categories:["jquery"],tags:[null]},regularPath:"/30.web/50.jquery%E6%BA%90%E7%A0%81/30.extend.html",relativePath:"30.web/50.jquery源码/30.extend.md",key:"v-f54ae5ba",path:"/jquery/extend/",headers:[{level:2,title:"IE和Opera会用name代替ID返回元素的问题",slug:"ie和opera会用name代替id返回元素的问题",normalizedTitle:"ie 和 opera 会用 name 代替 id 返回元素的问题",charIndex:2}],readingTime:{text:"2 min read",minutes:1.475,time:88500,words:295},headersStr:"IE和Opera会用name代替ID返回元素的问题",content:"# IE 和 Opera 会用 name 代替 ID 返回元素的问题\n\nIE works correctly on elements that CAN'T have a name attribute. It works incorrectly, however, on elements that can.\n\nAs I researched this, I found a function in JavaScript I've never used before:\n\n> HTMLCollection.namedItem( String name )\n> \n> This function seeks for any element within the collection whose id attribute value matches the name specified in the call. If it doesn't find one, it searches for any element whose name attribute matches the name specified in the call. The function returns the first element object it finds that meets the criteria, or null if it can't find one.\n\nMy first thought was, Microsoft has their document.getElementById calling their namedItem() function. But then I stepped back and realized through my experiment that IE seems to be matching against both name and id at the same time to match the value.\n\nAs you'll notice below, I have two elements for each part of the experiment. The first has the name attribute filled with the id value \"my[Element]\" I'm wanting to look for. I fill the second element's id attribute with the same value. IE, parsing from the top of the document down, finds the element with the name=\"my[Element]\" first and automatically takes it... it doesn't even wait to see if it can find one with an id that matches first.\n\nI can only assume this was done for optimizing this \"convenience feature\", but makes for some serious puzzlement and aggravation in troubleshooting why the element a developer can't get to who happens to name/id things in a way similar to what happens in my experiment. Whatever reason, they did it, it's wrong. Please be careful in how you name/id things\n\njQuery 通过 $().find(selector) 通过查找子节点来解决这个问题的。\n\n参考：\n\n * Internet Explorer (IE) JavaScript document.getElementById whackedness demo",normalizedContent:"# ie 和 opera 会用 name 代替 id 返回元素的问题\n\nie works correctly on elements that can't have a name attribute. it works incorrectly, however, on elements that can.\n\nas i researched this, i found a function in javascript i've never used before:\n\n> htmlcollection.nameditem( string name )\n> \n> this function seeks for any element within the collection whose id attribute value matches the name specified in the call. if it doesn't find one, it searches for any element whose name attribute matches the name specified in the call. the function returns the first element object it finds that meets the criteria, or null if it can't find one.\n\nmy first thought was, microsoft has their document.getelementbyid calling their nameditem() function. but then i stepped back and realized through my experiment that ie seems to be matching against both name and id at the same time to match the value.\n\nas you'll notice below, i have two elements for each part of the experiment. the first has the name attribute filled with the id value \"my[element]\" i'm wanting to look for. i fill the second element's id attribute with the same value. ie, parsing from the top of the document down, finds the element with the name=\"my[element]\" first and automatically takes it... it doesn't even wait to see if it can find one with an id that matches first.\n\ni can only assume this was done for optimizing this \"convenience feature\", but makes for some serious puzzlement and aggravation in troubleshooting why the element a developer can't get to who happens to name/id things in a way similar to what happens in my experiment. whatever reason, they did it, it's wrong. please be careful in how you name/id things\n\njquery 通过 $().find(selector) 通过查找子节点来解决这个问题的。\n\n参考：\n\n * internet explorer (ie) javascript document.getelementbyid whackedness demo",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"开始阅读",frontmatter:{title:"开始阅读",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/index/",categories:["qiankun"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/0.index.html",relativePath:"30.web/6.qiankun源码/0.index.md",key:"v-52bd35e5",path:"/qiankun/index/",headers:[{level:2,title:"开始上手",slug:"开始上手",normalizedTitle:"开始上手",charIndex:2},{level:2,title:"前提",slug:"前提",normalizedTitle:"前提",charIndex:11},{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:54}],readingTime:{text:"1 min read",minutes:.325,time:19500,words:65},headersStr:"开始上手 前提 介绍",content:"# 开始上手\n\n\n# 前提\n\n参数           描述\nqiankun 版本   2.7.0\n\n\n# 介绍\n\nqiankun 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。\n\n要求：\n\n * 技术栈无关：不限制接入应用的技术栈，应用之间没有隐性依赖\n * 接入简单： 最好就像 iframe 一样简单尽可能避免旧应用改造\n\n“技术栈无关” 是微前端的核心价值。\n\n> 微前端的前提还是得有主体应用，然后才有微组件或微应用，解决的是可控体系下前端协同开发问题。 这里开发问题有两部分：一部分是空间分离带来的协作，另一部分是时间延续带来的升级维护。空间分离带来的协作，需要微前端方案能够提供独立开发、独立部署的特性，来处理协作问题。而时间带来的延续其实是需要我们做到技术栈无关，做到随着时间的推移，当我们技术栈陈旧的时候，还是能够正常的接入我们的框架应用。\n\n微前端框架面临的两大共性问题:\n\n * 应用的加载与切换。包括路由的处理、应用加载的处理和应用入口的选择。\n * 应用的隔离与通信。这是应用已经加载之后面临的问题，它们包括 JS 的隔离（也就是副作用的隔离）、样式的隔离、也包括父子应用和子子应用之间的通信问题。\n\n提示\n\n本文的源码解析将包括 single-spa 的源码，先分开解析各自的原理，然后串讲起来。\n\n参考：single-spa\n\n参考\n\n * 微前端连载 6/7：微前端框架 - qiankun 大法好\n * github: qiankun repo",normalizedContent:"# 开始上手\n\n\n# 前提\n\n参数           描述\nqiankun 版本   2.7.0\n\n\n# 介绍\n\nqiankun 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。\n\n要求：\n\n * 技术栈无关：不限制接入应用的技术栈，应用之间没有隐性依赖\n * 接入简单： 最好就像 iframe 一样简单尽可能避免旧应用改造\n\n“技术栈无关” 是微前端的核心价值。\n\n> 微前端的前提还是得有主体应用，然后才有微组件或微应用，解决的是可控体系下前端协同开发问题。 这里开发问题有两部分：一部分是空间分离带来的协作，另一部分是时间延续带来的升级维护。空间分离带来的协作，需要微前端方案能够提供独立开发、独立部署的特性，来处理协作问题。而时间带来的延续其实是需要我们做到技术栈无关，做到随着时间的推移，当我们技术栈陈旧的时候，还是能够正常的接入我们的框架应用。\n\n微前端框架面临的两大共性问题:\n\n * 应用的加载与切换。包括路由的处理、应用加载的处理和应用入口的选择。\n * 应用的隔离与通信。这是应用已经加载之后面临的问题，它们包括 js 的隔离（也就是副作用的隔离）、样式的隔离、也包括父子应用和子子应用之间的通信问题。\n\n提示\n\n本文的源码解析将包括 single-spa 的源码，先分开解析各自的原理，然后串讲起来。\n\n参考：single-spa\n\n参考\n\n * 微前端连载 6/7：微前端框架 - qiankun 大法好\n * github: qiankun repo",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"本章概要",frontmatter:{title:"本章概要",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/core/index/",categories:["qiankun","core"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/10.core/0.index.html",relativePath:"30.web/6.qiankun源码/10.core/0.index.md",key:"v-7c668ae7",path:"/qiankun/core/index/",readingTime:{text:"1 min read",minutes:.535,time:32100,words:107},headersStr:null,content:"先看下整体的目录结构：\n\n.\n├── addons\n│   ├── engineFlag.ts\n│   ├── index.ts\n│   └── runtimePublicPath.ts\n├── apis.ts\n├── effects.ts\n├── error.ts\n├── errorHandler.ts\n├── globalState.ts\n├── index.ts\n├── interfaces.ts\n├── loader.ts\n├── prefetch.ts\n├── sandbox\n│   ├── common.ts\n│   ├── index.ts\n│   ├── legacy\n│   │   └── sandbox.ts\n│   ├── patchers\n│   │   ├── css.ts\n│   │   ├── dynamicAppend\n│   │   │   ├── common.ts\n│   │   │   ├── forLooseSandbox.ts\n│   │   │   ├── forStrictSandbox.ts\n│   │   │   └── index.ts\n│   │   ├── historyListener.ts\n│   │   ├── index.ts\n│   │   ├── interval.ts\n│   │   └── windowListener.ts\n│   ├── proxySandbox.ts\n│   └── snapshotSandbox.ts\n├── utils.ts\n└── version.ts\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n大致可以分成核心 api、沙箱和插件几个部分。",normalizedContent:"先看下整体的目录结构：\n\n.\n├── addons\n│   ├── engineflag.ts\n│   ├── index.ts\n│   └── runtimepublicpath.ts\n├── apis.ts\n├── effects.ts\n├── error.ts\n├── errorhandler.ts\n├── globalstate.ts\n├── index.ts\n├── interfaces.ts\n├── loader.ts\n├── prefetch.ts\n├── sandbox\n│   ├── common.ts\n│   ├── index.ts\n│   ├── legacy\n│   │   └── sandbox.ts\n│   ├── patchers\n│   │   ├── css.ts\n│   │   ├── dynamicappend\n│   │   │   ├── common.ts\n│   │   │   ├── forloosesandbox.ts\n│   │   │   ├── forstrictsandbox.ts\n│   │   │   └── index.ts\n│   │   ├── historylistener.ts\n│   │   ├── index.ts\n│   │   ├── interval.ts\n│   │   └── windowlistener.ts\n│   ├── proxysandbox.ts\n│   └── snapshotsandbox.ts\n├── utils.ts\n└── version.ts\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n大致可以分成核心 api、沙箱和插件几个部分。",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"核心 API",frontmatter:{title:"核心 API",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/core/apis/",categories:["qiankun","core"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/10.core/10.apis.html",relativePath:"30.web/6.qiankun源码/10.core/10.apis.md",key:"v-6e596402",path:"/qiankun/core/apis/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"registerMicroApps",slug:"registermicroapps",normalizedTitle:"registermicroapps",charIndex:17},{level:2,title:"start",slug:"start",normalizedTitle:"start",charIndex:38},{level:2,title:"loadMicroApp",slug:"loadmicroapp",normalizedTitle:"loadmicroapp",charIndex:47},{level:2,title:"一些技巧",slug:"一些技巧",normalizedTitle:"一些技巧",charIndex:63},{level:3,title:"TS 中，如何添加互斥的属性？",slug:"ts-中-如何添加互斥的属性",normalizedTitle:"ts 中，如何添加互斥的属性？",charIndex:73},{level:3,title:"如何计算计算元素在 DOM 文档中的 XPath 路径？",slug:"如何计算计算元素在-dom-文档中的-xpath-路径",normalizedTitle:"如何计算计算元素在 dom 文档中的 xpath 路径？",charIndex:94}],readingTime:{text:"8 min read",minutes:7.22,time:433200,words:1444},headersStr:"目录 registerMicroApps start loadMicroApp 一些技巧 TS 中，如何添加互斥的属性？ 如何计算计算元素在 DOM 文档中的 XPath 路径？",content:"# 目录\n\n\n\n * 目录\n * registerMicroApps\n * start\n * loadMicroApp\n * 一些技巧\n   * TS 中，如何添加互斥的属性？\n   * 如何计算计算元素在 DOM 文档中的 XPath 路径？\n\n\n\n注意\n\n * s-spa：文章中对 single-spa 的简称。\n * 微应用：框架所管理的微服务子应用。\n * 主程序：框架主程序本身。\n * 文件路径：src/apis.ts\n\n\n# registerMicroApps\n\n注册微应用。\n\n// 已经注册的子应用\nlet microApps: Array<RegistrableApp<Record<string, unknown>>> = [];\n\n// 提供数组配置子应用的方法，内部直接调用 S-Spa.registerApplication 注册子应用，加强了部分功能，如 loader\n// https://qiankun.umijs.org/zh/api#registermicroappsapps-lifecycles\nexport function registerMicroApps<T extends ObjectType>(\n  apps: Array<RegistrableApp<T>>,\n  lifeCycles?: FrameworkLifeCycles<T>,\n) {\n  // Each app only needs to be registered once\n  // registeredApp name 具有唯一性，过滤掉重名 registeredApp\n  const unregisteredApps = apps.filter((app) => !microApps.some((registeredApp) => registeredApp.name === app.name));\n\n  microApps = [...microApps, ...unregisteredApps];\n\n  unregisteredApps.forEach((app) => {\n    const { name, activeRule, loader = noop, props, ...appConfig } = app;\n    // 为没有注册的配置注册应用，调用 single-spa\n    registerApplication({\n      name,\n      // app 参数中是 Loading Function or Application\n      // see https://single-spa.js.org/docs/configuration#registering-applications\n      app: async () => {\n        loader(true);\n        // 等待应用启动，即是 frameworkStartedDefer.promise 被 resolve\n        await frameworkStartedDefer.promise;\n        // 挂载子应用，获得子应用的钩子和配置\n        // loadApp 是在应用启动（start 函数）之后执行的，但是再次之前在 s-spa 中已经注册了应用\n        const {\n          mount,\n          ...otherMicroAppConfigs\n        } = // frameworkConfiguration 是 start 中 merge 而成\n          (await loadApp({ name, props, ...appConfig }, frameworkConfiguration, lifeCycles))();\n\n        return {\n          // 在 single-spa 中注册子应用，这是返回给 single-spa 的配置参数\n          // 此处 loader 是包裹在 mount 函数前后的钩子函数\n          mount: [async () => loader(true), ...toArray(mount), async () => loader(false)],\n          ...otherMicroAppConfigs,\n        };\n      },\n      // Activity function\n      activeWhen: activeRule,\n      // Custom props\n      customProps: props,\n    });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n这里 loadApp 等待 start () 执行完毕在执行，可以看下这里是如何处理的？\n\nconst frameworkStartedDefer = new Deferred<void>();\n\nexport class Deferred<T> {\n  promise: Promise<T>;\n\n  resolve!: (value: T | PromiseLike<T>) => void;\n\n  reject!: (reason?: any) => void;\n\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这种方法还是很巧妙的。利用 Promise 来实现程序等待，可以把很多需要 promise.then 的程序代码进行解耦。\n\n\n# start\n\nregisterMicroApps 的注册的微应用还需要进一步触发 start，并且进行一系列的应用配置。注册和开启应用分离，这也是为了提高性能考虑，这也是 single-spa 的逻辑。原因如下：\n\n> The start() api must be called by your single spa config in order for applications to actually be mounted. Before start is called, applications will be loaded, but not bootstrapped/mounted/unmounted. The reason for start is to give you control over performance.\n\n更多详细原因参考：Calling singleSpa.start()\n\n// 全局的框架配置\nexport let frameworkConfiguration: FrameworkConfiguration = {};\n\n// 对 s-spa 的 startSingleSpa 方法进行包装，并且加入 prefetch、singular、sandbox、和 importEntry 的配置\n// see https://qiankun.umijs.org/zh/api#startopts\n// FrameworkConfiguration 包含 qiankun 独有的配置，s-spa的配置和 import-html-entry 的配置\nexport function start(opts: FrameworkConfiguration = {}) {\n  // 合并默认配置\n  // singular：单实例场景，单实例指的是同一时间只会渲染一个微应用\n  // frameworkConfiguration 被保存为全局变量，方便配置共享\n  frameworkConfiguration = { prefetch: true, singular: true, sandbox: true, ...opts };\n  const {\n    prefetch,\n    sandbox,\n    singular,\n    urlRerouteOnly = defaultUrlRerouteOnly,\n    // 导入 html 模板时的配置\n    ...importEntryOpts\n  } = frameworkConfiguration;\n  // 开启预加载\n  if (prefetch) {\n    // 处理不同预加载策略\n    doPrefetchStrategy(microApps, prefetch, importEntryOpts);\n  }\n  // 对旧版本浏览器的配置进行优雅降级\n  frameworkConfiguration = autoDowngradeForLowVersionBrowser(frameworkConfiguration);\n\n  startSingleSpa({ urlRerouteOnly });\n  // 全局标记应用的启动\n  started = true;\n  // 通知已经在 s-spa 中注册的子应用，prefetch 的配置已经更新，可以继续运行\n  frameworkStartedDefer.resolve();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nstart 函数的主要作用是：对 s-spa 的 startSingleSpa 方法进行包装，并且加入 prefetch、singular、sandbox、和 importEntry 的配置。\n\ndoPrefetchStrategy 函数对不同的预加载策略进行处理，后文详述。\n\nautoDowngradeForLowVersionBrowser 针对旧版本浏览器的配置进行优雅降级，我们来看看做了什么？\n\n// 对旧版浏览器进行降级\nconst autoDowngradeForLowVersionBrowser = (configuration: FrameworkConfiguration): FrameworkConfiguration => {\n  const { sandbox, singular } = configuration;\n  if (sandbox) {\n    // 浏览器不支持 window.Proxy，因为 window 不能够被代码，所以切换到快照模式，对 window 做快照处理，loose\n    if (!window.Proxy) {\n      console.warn('[qiankun] Miss window.Proxy, proxySandbox will degenerate into snapshotSandbox');\n      // singular 是否为单实例场景，单实例指的是同一时间只会渲染一个微应用。\n      // 不支持 window.Proxy 的浏览器在运行多实例时可能有问题\n      if (singular === false) {\n        console.warn(\n          '[qiankun] Setting singular as false may cause unexpected behavior while your browser not support window.Proxy',\n        );\n      }\n\n      return { ...configuration, sandbox: typeof sandbox === 'object' ? { ...sandbox, loose: true } : { loose: true } };\n    }\n  }\n\n  return configuration;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这里引出了 window.Proxy，我们先来简单了解一下：\n\n> The Proxy object enables you to create a proxy for another object, which can intercept and redefine fundamental operations for that object. Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。\n\n在 Vue3 源码中这个重要的底层 API，这里不再赘述。\n\n参考：MDN: Proxy\n\n\n# loadMicroApp\n\n除了 start 中自动开启应用并匹配路由挂载微应用，还可以通过 loadMicroApp 手动挂载微应用。这个函数相对来说较为复杂，代码如下：\n\n// 应用实例缓存 Map<appContainerXPathKey, Promise<(container) => parcelConfig>>\nconst appConfigPromiseGetterMap = new Map<string, Promise<ParcelConfigObjectGetter>>();\n// 微应用列表的缓存\nconst containerMicroAppsMap = new Map<string, MicroApp[]>();\n\n// 手动加载一个微应用，通常这种场景下微应用是一个不带路由的可独立运行的业务组件。\n// see https://qiankun.umijs.org/zh/api#loadmicroappapp-configuration\n// 了解微应用的类型，see https://single-spa.js.org/docs/module-types\nexport function loadMicroApp<T extends ObjectType>(\n  app: LoadableApp<T>,\n  configuration?: FrameworkConfiguration & { autoStart?: boolean },\n  lifeCycles?: FrameworkLifeCycles<T>,\n): MicroApp {\n  const { props, name } = app;\n\n  const container = 'container' in app ? app.container : undefined;\n  // Must compute the container xpath at beginning to keep it consist around app running\n  // If we compute it every time, the container dom structure most probably been changed and result in a different xpath value\n  // 计算 container 的 XPath 路径\n  // 必须在加载应用之前计算，因为之后容器的 DOM 结构可能会改变\n  // 使用 name + XPath 作为微应用在缓存的标志，必须保证此标志是不变的！所以只初始化一次\n  const containerXPath = getContainerXPath(container);\n  const appContainerXPathKey = `${name}-${containerXPath}`;\n\n  let microApp: MicroApp;\n  // 重新挂载相同的微应用，需要对容器中其他应用的挂载状态做容错\n  // 在重新挂载微应用之前，要保证所有之前的应用的 unmount 钩子都执行完毕\n  const wrapParcelConfigForRemount = (config: ParcelConfigObject): ParcelConfigObject => {\n    let microAppConfig = config;\n    if (container) {\n      if (containerXPath) {\n        // 获取所在 container 的缓存中的微应用列表\n        const containerMicroApps = containerMicroAppsMap.get(appContainerXPathKey);\n        if (containerMicroApps?.length) {\n          // 在 mount 钩子中添加额外的逻辑\n          const mount = [\n            async () => {\n              // While there are multiple micro apps mounted on the same container, we must wait until the prev instances all had unmounted\n              // Otherwise it will lead some concurrent issues\n              // 当前应用之前的已挂载的微应用\n              const prevLoadMicroApps = containerMicroApps.slice(0, containerMicroApps.indexOf(microApp));\n              // 过滤掉错误的微应用\n              const prevLoadMicroAppsWhichNotBroken = prevLoadMicroApps.filter(\n                (v) => v.getStatus() !== 'LOAD_ERROR' && v.getStatus() !== 'SKIP_BECAUSE_BROKEN',\n              );\n              // 将 prevLoadMicroAppsWhichNotBroken 所有微应用的 unmountPromise 收集起来，并等待所有的 unmountPromise 都已经 resolve，以免之前的应用实例没卸载干净\n              await Promise.all(prevLoadMicroAppsWhichNotBroken.map((v) => v.unmountPromise));\n            },\n            ...toArray(microAppConfig.mount),\n          ];\n\n          microAppConfig = {\n            ...config,\n            mount,\n          };\n        }\n      }\n    }\n\n    return {\n      ...microAppConfig,\n      // empty bootstrap hook which should not run twice while it calling from cached micro app\n      bootstrap: () => Promise.resolve(),\n    };\n  };\n\n  /**\n   * using name + container xpath as the micro app instance id,\n   * it means if you rendering a micro app to a dom which have been rendered before,\n   * the micro app would not load and evaluate its lifecycles again\n   */\n  const memorizedLoadingFn = async (): Promise<ParcelConfigObject> => {\n    // 合并配置项，并且对旧浏览器优雅降级\n    const userConfiguration = autoDowngradeForLowVersionBrowser(\n      configuration ?? { ...frameworkConfiguration, singular: false },\n    );\n    // $$cacheLifecycleByAppName 是内部实验性的，默认为 false\n    const { $$cacheLifecycleByAppName } = userConfiguration;\n\n    if (container) {\n      // using appName as cache for internal experimental scenario\n      if ($$cacheLifecycleByAppName) {\n        const parcelConfigGetterPromise = appConfigPromiseGetterMap.get(name);\n        if (parcelConfigGetterPromise) return wrapParcelConfigForRemount((await parcelConfigGetterPromise)(container));\n      }\n\n      if (containerXPath) {\n        // 检查微应用是否在缓存中，如果在，直接取出应用实例\n        const parcelConfigGetterPromise = appConfigPromiseGetterMap.get(appContainerXPathKey);\n        // 重新挂载微应用之前需要确保不会与之前的微应用产生冲突\n        if (parcelConfigGetterPromise) return wrapParcelConfigForRemount((await parcelConfigGetterPromise)(container));\n      }\n    }\n    // loadApp 是一个 async 函数，parcelConfigObjectGetterPromise 是一个应用实例的 Promise\n    const parcelConfigObjectGetterPromise = loadApp(app, userConfiguration, lifeCycles);\n\n    if (container) {\n      if ($$cacheLifecycleByAppName) {\n        appConfigPromiseGetterMap.set(name, parcelConfigObjectGetterPromise);\n      } else if (containerXPath)\n        // 设置缓存\n        appConfigPromiseGetterMap.set(appContainerXPathKey, parcelConfigObjectGetterPromise);\n    }\n    // (await parcelConfigGetterPromise)(container) 返回 parcelConfig，这是传给 s-spa 的\n    return (await parcelConfigObjectGetterPromise)(container);\n  };\n  // 如果配置了自动启动，注意 loadMicroApp 之前所有的应用都应该注册过\n  // 这种情况通常不用于路由匹配模式\n  if (!started && configuration?.autoStart !== false) {\n    // We need to invoke start method of single-spa as the popstate event should be dispatched while the main app calling pushState/replaceState automatically,\n    // but in single-spa it will check the start status before it dispatch popstate\n    // github 页面链接可以定位到具体的代码行\n    // see https://github.com/single-spa/single-spa/blob/f28b5963be1484583a072c8145ac0b5a28d91235/src/navigation/navigation-events.js#L101\n    // ref https://github.com/umijs/qiankun/pull/1071\n    // 需要调用 startSingleSpa 是因为 single-spa 在代理 popstate 之前需要检查主应用是否 start，但是只需要调用一次即可\n    // 虽然 parcel 微应用不太需要监听路由变化，但是需要监听 popState 以自动卸载应用\n    startSingleSpa({ urlRerouteOnly: frameworkConfiguration.urlRerouteOnly ?? defaultUrlRerouteOnly });\n  }\n  // 手动挂载 parcel 微应用不需要匹配路由挂载，需要手动挂载到容器，这里调用 s-spa.mountRootParcel\n  // see https://single-spa.js.org/docs/parcels-api#mountrootparcel\n  // microApp 为 Parcel object\n  microApp = mountRootParcel(memorizedLoadingFn, { domElement: document.createElement('div'), ...props });\n\n  // 在 mount 时将微应用添加到应用队列，并且在 unmount 时删除微应用\n  if (container) {\n    if (containerXPath) {\n      // Store the microApps which they mounted on the same container\n      // 取出缓存中当前 container 中的微应用列表\n      const microAppsRef = containerMicroAppsMap.get(appContainerXPathKey) || [];\n      // 将当前已经挂载的微应用加入到微应用列表中\n      microAppsRef.push(microApp);\n      containerMicroAppsMap.set(appContainerXPathKey, microAppsRef);\n\n      const cleanup = () => {\n        // 在微任务列表中删除当前应用\n        const index = microAppsRef.indexOf(microApp);\n        microAppsRef.splice(index, 1);\n        // @ts-ignore\n        microApp = null;\n      };\n\n      // gc after unmount\n      // 挂载卸载的钩子函数，在微任务卸载时执行 GC 函数\n      microApp.unmountPromise.then(cleanup).catch(cleanup);\n    }\n  }\n\n  return microApp;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n\n\nloadMicroApp 中最重要的重要是调用 mountRootParcel 来手动挂载微应用，并且在 s-spa 的上层做了一层缓存层。包括对 AppLoading 函数的缓存和微应用的缓存。其次比较重要的是如果程序还没有启动且配置了 autoStart 就调用 startSingleSpa 来启动主程序。\n\n\n# 一些技巧\n\n\n# TS 中，如何添加互斥的属性？\n\nts 添加排他性（互斥）的属性，如 render 和 container 是互斥的。\n\n// just for manual loaded apps, in single-spa it called parcel\nexport type LoadableApp<T extends ObjectType> = AppMetadata & {\n  /* props pass through to app */ props?: T;\n} & (\n    | {\n        // legacy mode, the render function all handled by user\n        render: HTMLContentRender;\n      }\n    | {\n        // where the app mount to, mutual exclusive with the legacy custom render function\n        container: string | HTMLElement;\n      }\n  );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 如何计算计算元素在 DOM 文档中的 XPath 路径？\n\nexport function getContainer(container: string | HTMLElement): HTMLElement | null {\n  return typeof container === 'string' ? document.querySelector(container) : container;\n}\n\nexport function getContainerXPath(container?: string | HTMLElement): string | void {\n  if (container) {\n    // 获取容器 DOM 元素\n    const containerElement = getContainer(container);\n    if (containerElement) {\n      return getXPathForElement(containerElement, document);\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * 计算元素在 DOM 文档中的 XPath 路径\n * copy from https://developer.mozilla.org/zh-CN/docs/Using_XPath\n * @param el\n * @param document\n */\nexport function getXPathForElement(el: Node, document: Document): string | void {\n  // not support that if el not existed in document yet(such as it not append to document before it mounted)\n  // 元素不在 document 中\n  if (!document.body.contains(el)) {\n    return undefined;\n  }\n\n  let xpath = '';\n  let pos;\n  let tmpEle;\n  let element = el;\n\n  while (element !== document.documentElement) {\n    pos = 0;\n    tmpEle = element;\n    while (tmpEle) {\n      if (tmpEle.nodeType === 1 && tmpEle.nodeName === element.nodeName) {\n        // If it is ELEMENT_NODE of the same name\n        pos += 1;\n      }\n      tmpEle = tmpEle.previousSibling;\n    }\n\n    xpath = `*[name()='${element.nodeName}'][${pos}]/${xpath}`;\n\n    element = element.parentNode!;\n  }\n\n  xpath = `/*[name()='${document.documentElement.nodeName}']/${xpath}`;\n  xpath = xpath.replace(/\\/$/, '');\n\n  return xpath;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n",normalizedContent:"# 目录\n\n\n\n * 目录\n * registermicroapps\n * start\n * loadmicroapp\n * 一些技巧\n   * ts 中，如何添加互斥的属性？\n   * 如何计算计算元素在 dom 文档中的 xpath 路径？\n\n\n\n注意\n\n * s-spa：文章中对 single-spa 的简称。\n * 微应用：框架所管理的微服务子应用。\n * 主程序：框架主程序本身。\n * 文件路径：src/apis.ts\n\n\n# registermicroapps\n\n注册微应用。\n\n// 已经注册的子应用\nlet microapps: array<registrableapp<record<string, unknown>>> = [];\n\n// 提供数组配置子应用的方法，内部直接调用 s-spa.registerapplication 注册子应用，加强了部分功能，如 loader\n// https://qiankun.umijs.org/zh/api#registermicroappsapps-lifecycles\nexport function registermicroapps<t extends objecttype>(\n  apps: array<registrableapp<t>>,\n  lifecycles?: frameworklifecycles<t>,\n) {\n  // each app only needs to be registered once\n  // registeredapp name 具有唯一性，过滤掉重名 registeredapp\n  const unregisteredapps = apps.filter((app) => !microapps.some((registeredapp) => registeredapp.name === app.name));\n\n  microapps = [...microapps, ...unregisteredapps];\n\n  unregisteredapps.foreach((app) => {\n    const { name, activerule, loader = noop, props, ...appconfig } = app;\n    // 为没有注册的配置注册应用，调用 single-spa\n    registerapplication({\n      name,\n      // app 参数中是 loading function or application\n      // see https://single-spa.js.org/docs/configuration#registering-applications\n      app: async () => {\n        loader(true);\n        // 等待应用启动，即是 frameworkstarteddefer.promise 被 resolve\n        await frameworkstarteddefer.promise;\n        // 挂载子应用，获得子应用的钩子和配置\n        // loadapp 是在应用启动（start 函数）之后执行的，但是再次之前在 s-spa 中已经注册了应用\n        const {\n          mount,\n          ...othermicroappconfigs\n        } = // frameworkconfiguration 是 start 中 merge 而成\n          (await loadapp({ name, props, ...appconfig }, frameworkconfiguration, lifecycles))();\n\n        return {\n          // 在 single-spa 中注册子应用，这是返回给 single-spa 的配置参数\n          // 此处 loader 是包裹在 mount 函数前后的钩子函数\n          mount: [async () => loader(true), ...toarray(mount), async () => loader(false)],\n          ...othermicroappconfigs,\n        };\n      },\n      // activity function\n      activewhen: activerule,\n      // custom props\n      customprops: props,\n    });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n这里 loadapp 等待 start () 执行完毕在执行，可以看下这里是如何处理的？\n\nconst frameworkstarteddefer = new deferred<void>();\n\nexport class deferred<t> {\n  promise: promise<t>;\n\n  resolve!: (value: t | promiselike<t>) => void;\n\n  reject!: (reason?: any) => void;\n\n  constructor() {\n    this.promise = new promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这种方法还是很巧妙的。利用 promise 来实现程序等待，可以把很多需要 promise.then 的程序代码进行解耦。\n\n\n# start\n\nregistermicroapps 的注册的微应用还需要进一步触发 start，并且进行一系列的应用配置。注册和开启应用分离，这也是为了提高性能考虑，这也是 single-spa 的逻辑。原因如下：\n\n> the start() api must be called by your single spa config in order for applications to actually be mounted. before start is called, applications will be loaded, but not bootstrapped/mounted/unmounted. the reason for start is to give you control over performance.\n\n更多详细原因参考：calling singlespa.start()\n\n// 全局的框架配置\nexport let frameworkconfiguration: frameworkconfiguration = {};\n\n// 对 s-spa 的 startsinglespa 方法进行包装，并且加入 prefetch、singular、sandbox、和 importentry 的配置\n// see https://qiankun.umijs.org/zh/api#startopts\n// frameworkconfiguration 包含 qiankun 独有的配置，s-spa的配置和 import-html-entry 的配置\nexport function start(opts: frameworkconfiguration = {}) {\n  // 合并默认配置\n  // singular：单实例场景，单实例指的是同一时间只会渲染一个微应用\n  // frameworkconfiguration 被保存为全局变量，方便配置共享\n  frameworkconfiguration = { prefetch: true, singular: true, sandbox: true, ...opts };\n  const {\n    prefetch,\n    sandbox,\n    singular,\n    urlrerouteonly = defaulturlrerouteonly,\n    // 导入 html 模板时的配置\n    ...importentryopts\n  } = frameworkconfiguration;\n  // 开启预加载\n  if (prefetch) {\n    // 处理不同预加载策略\n    doprefetchstrategy(microapps, prefetch, importentryopts);\n  }\n  // 对旧版本浏览器的配置进行优雅降级\n  frameworkconfiguration = autodowngradeforlowversionbrowser(frameworkconfiguration);\n\n  startsinglespa({ urlrerouteonly });\n  // 全局标记应用的启动\n  started = true;\n  // 通知已经在 s-spa 中注册的子应用，prefetch 的配置已经更新，可以继续运行\n  frameworkstarteddefer.resolve();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nstart 函数的主要作用是：对 s-spa 的 startsinglespa 方法进行包装，并且加入 prefetch、singular、sandbox、和 importentry 的配置。\n\ndoprefetchstrategy 函数对不同的预加载策略进行处理，后文详述。\n\nautodowngradeforlowversionbrowser 针对旧版本浏览器的配置进行优雅降级，我们来看看做了什么？\n\n// 对旧版浏览器进行降级\nconst autodowngradeforlowversionbrowser = (configuration: frameworkconfiguration): frameworkconfiguration => {\n  const { sandbox, singular } = configuration;\n  if (sandbox) {\n    // 浏览器不支持 window.proxy，因为 window 不能够被代码，所以切换到快照模式，对 window 做快照处理，loose\n    if (!window.proxy) {\n      console.warn('[qiankun] miss window.proxy, proxysandbox will degenerate into snapshotsandbox');\n      // singular 是否为单实例场景，单实例指的是同一时间只会渲染一个微应用。\n      // 不支持 window.proxy 的浏览器在运行多实例时可能有问题\n      if (singular === false) {\n        console.warn(\n          '[qiankun] setting singular as false may cause unexpected behavior while your browser not support window.proxy',\n        );\n      }\n\n      return { ...configuration, sandbox: typeof sandbox === 'object' ? { ...sandbox, loose: true } : { loose: true } };\n    }\n  }\n\n  return configuration;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这里引出了 window.proxy，我们先来简单了解一下：\n\n> the proxy object enables you to create a proxy for another object, which can intercept and redefine fundamental operations for that object. proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。\n\n在 vue3 源码中这个重要的底层 api，这里不再赘述。\n\n参考：mdn: proxy\n\n\n# loadmicroapp\n\n除了 start 中自动开启应用并匹配路由挂载微应用，还可以通过 loadmicroapp 手动挂载微应用。这个函数相对来说较为复杂，代码如下：\n\n// 应用实例缓存 map<appcontainerxpathkey, promise<(container) => parcelconfig>>\nconst appconfigpromisegettermap = new map<string, promise<parcelconfigobjectgetter>>();\n// 微应用列表的缓存\nconst containermicroappsmap = new map<string, microapp[]>();\n\n// 手动加载一个微应用，通常这种场景下微应用是一个不带路由的可独立运行的业务组件。\n// see https://qiankun.umijs.org/zh/api#loadmicroappapp-configuration\n// 了解微应用的类型，see https://single-spa.js.org/docs/module-types\nexport function loadmicroapp<t extends objecttype>(\n  app: loadableapp<t>,\n  configuration?: frameworkconfiguration & { autostart?: boolean },\n  lifecycles?: frameworklifecycles<t>,\n): microapp {\n  const { props, name } = app;\n\n  const container = 'container' in app ? app.container : undefined;\n  // must compute the container xpath at beginning to keep it consist around app running\n  // if we compute it every time, the container dom structure most probably been changed and result in a different xpath value\n  // 计算 container 的 xpath 路径\n  // 必须在加载应用之前计算，因为之后容器的 dom 结构可能会改变\n  // 使用 name + xpath 作为微应用在缓存的标志，必须保证此标志是不变的！所以只初始化一次\n  const containerxpath = getcontainerxpath(container);\n  const appcontainerxpathkey = `${name}-${containerxpath}`;\n\n  let microapp: microapp;\n  // 重新挂载相同的微应用，需要对容器中其他应用的挂载状态做容错\n  // 在重新挂载微应用之前，要保证所有之前的应用的 unmount 钩子都执行完毕\n  const wrapparcelconfigforremount = (config: parcelconfigobject): parcelconfigobject => {\n    let microappconfig = config;\n    if (container) {\n      if (containerxpath) {\n        // 获取所在 container 的缓存中的微应用列表\n        const containermicroapps = containermicroappsmap.get(appcontainerxpathkey);\n        if (containermicroapps?.length) {\n          // 在 mount 钩子中添加额外的逻辑\n          const mount = [\n            async () => {\n              // while there are multiple micro apps mounted on the same container, we must wait until the prev instances all had unmounted\n              // otherwise it will lead some concurrent issues\n              // 当前应用之前的已挂载的微应用\n              const prevloadmicroapps = containermicroapps.slice(0, containermicroapps.indexof(microapp));\n              // 过滤掉错误的微应用\n              const prevloadmicroappswhichnotbroken = prevloadmicroapps.filter(\n                (v) => v.getstatus() !== 'load_error' && v.getstatus() !== 'skip_because_broken',\n              );\n              // 将 prevloadmicroappswhichnotbroken 所有微应用的 unmountpromise 收集起来，并等待所有的 unmountpromise 都已经 resolve，以免之前的应用实例没卸载干净\n              await promise.all(prevloadmicroappswhichnotbroken.map((v) => v.unmountpromise));\n            },\n            ...toarray(microappconfig.mount),\n          ];\n\n          microappconfig = {\n            ...config,\n            mount,\n          };\n        }\n      }\n    }\n\n    return {\n      ...microappconfig,\n      // empty bootstrap hook which should not run twice while it calling from cached micro app\n      bootstrap: () => promise.resolve(),\n    };\n  };\n\n  /**\n   * using name + container xpath as the micro app instance id,\n   * it means if you rendering a micro app to a dom which have been rendered before,\n   * the micro app would not load and evaluate its lifecycles again\n   */\n  const memorizedloadingfn = async (): promise<parcelconfigobject> => {\n    // 合并配置项，并且对旧浏览器优雅降级\n    const userconfiguration = autodowngradeforlowversionbrowser(\n      configuration ?? { ...frameworkconfiguration, singular: false },\n    );\n    // $$cachelifecyclebyappname 是内部实验性的，默认为 false\n    const { $$cachelifecyclebyappname } = userconfiguration;\n\n    if (container) {\n      // using appname as cache for internal experimental scenario\n      if ($$cachelifecyclebyappname) {\n        const parcelconfiggetterpromise = appconfigpromisegettermap.get(name);\n        if (parcelconfiggetterpromise) return wrapparcelconfigforremount((await parcelconfiggetterpromise)(container));\n      }\n\n      if (containerxpath) {\n        // 检查微应用是否在缓存中，如果在，直接取出应用实例\n        const parcelconfiggetterpromise = appconfigpromisegettermap.get(appcontainerxpathkey);\n        // 重新挂载微应用之前需要确保不会与之前的微应用产生冲突\n        if (parcelconfiggetterpromise) return wrapparcelconfigforremount((await parcelconfiggetterpromise)(container));\n      }\n    }\n    // loadapp 是一个 async 函数，parcelconfigobjectgetterpromise 是一个应用实例的 promise\n    const parcelconfigobjectgetterpromise = loadapp(app, userconfiguration, lifecycles);\n\n    if (container) {\n      if ($$cachelifecyclebyappname) {\n        appconfigpromisegettermap.set(name, parcelconfigobjectgetterpromise);\n      } else if (containerxpath)\n        // 设置缓存\n        appconfigpromisegettermap.set(appcontainerxpathkey, parcelconfigobjectgetterpromise);\n    }\n    // (await parcelconfiggetterpromise)(container) 返回 parcelconfig，这是传给 s-spa 的\n    return (await parcelconfigobjectgetterpromise)(container);\n  };\n  // 如果配置了自动启动，注意 loadmicroapp 之前所有的应用都应该注册过\n  // 这种情况通常不用于路由匹配模式\n  if (!started && configuration?.autostart !== false) {\n    // we need to invoke start method of single-spa as the popstate event should be dispatched while the main app calling pushstate/replacestate automatically,\n    // but in single-spa it will check the start status before it dispatch popstate\n    // github 页面链接可以定位到具体的代码行\n    // see https://github.com/single-spa/single-spa/blob/f28b5963be1484583a072c8145ac0b5a28d91235/src/navigation/navigation-events.js#l101\n    // ref https://github.com/umijs/qiankun/pull/1071\n    // 需要调用 startsinglespa 是因为 single-spa 在代理 popstate 之前需要检查主应用是否 start，但是只需要调用一次即可\n    // 虽然 parcel 微应用不太需要监听路由变化，但是需要监听 popstate 以自动卸载应用\n    startsinglespa({ urlrerouteonly: frameworkconfiguration.urlrerouteonly ?? defaulturlrerouteonly });\n  }\n  // 手动挂载 parcel 微应用不需要匹配路由挂载，需要手动挂载到容器，这里调用 s-spa.mountrootparcel\n  // see https://single-spa.js.org/docs/parcels-api#mountrootparcel\n  // microapp 为 parcel object\n  microapp = mountrootparcel(memorizedloadingfn, { domelement: document.createelement('div'), ...props });\n\n  // 在 mount 时将微应用添加到应用队列，并且在 unmount 时删除微应用\n  if (container) {\n    if (containerxpath) {\n      // store the microapps which they mounted on the same container\n      // 取出缓存中当前 container 中的微应用列表\n      const microappsref = containermicroappsmap.get(appcontainerxpathkey) || [];\n      // 将当前已经挂载的微应用加入到微应用列表中\n      microappsref.push(microapp);\n      containermicroappsmap.set(appcontainerxpathkey, microappsref);\n\n      const cleanup = () => {\n        // 在微任务列表中删除当前应用\n        const index = microappsref.indexof(microapp);\n        microappsref.splice(index, 1);\n        // @ts-ignore\n        microapp = null;\n      };\n\n      // gc after unmount\n      // 挂载卸载的钩子函数，在微任务卸载时执行 gc 函数\n      microapp.unmountpromise.then(cleanup).catch(cleanup);\n    }\n  }\n\n  return microapp;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n\n\nloadmicroapp 中最重要的重要是调用 mountrootparcel 来手动挂载微应用，并且在 s-spa 的上层做了一层缓存层。包括对 apploading 函数的缓存和微应用的缓存。其次比较重要的是如果程序还没有启动且配置了 autostart 就调用 startsinglespa 来启动主程序。\n\n\n# 一些技巧\n\n\n# ts 中，如何添加互斥的属性？\n\nts 添加排他性（互斥）的属性，如 render 和 container 是互斥的。\n\n// just for manual loaded apps, in single-spa it called parcel\nexport type loadableapp<t extends objecttype> = appmetadata & {\n  /* props pass through to app */ props?: t;\n} & (\n    | {\n        // legacy mode, the render function all handled by user\n        render: htmlcontentrender;\n      }\n    | {\n        // where the app mount to, mutual exclusive with the legacy custom render function\n        container: string | htmlelement;\n      }\n  );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 如何计算计算元素在 dom 文档中的 xpath 路径？\n\nexport function getcontainer(container: string | htmlelement): htmlelement | null {\n  return typeof container === 'string' ? document.queryselector(container) : container;\n}\n\nexport function getcontainerxpath(container?: string | htmlelement): string | void {\n  if (container) {\n    // 获取容器 dom 元素\n    const containerelement = getcontainer(container);\n    if (containerelement) {\n      return getxpathforelement(containerelement, document);\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * 计算元素在 dom 文档中的 xpath 路径\n * copy from https://developer.mozilla.org/zh-cn/docs/using_xpath\n * @param el\n * @param document\n */\nexport function getxpathforelement(el: node, document: document): string | void {\n  // not support that if el not existed in document yet(such as it not append to document before it mounted)\n  // 元素不在 document 中\n  if (!document.body.contains(el)) {\n    return undefined;\n  }\n\n  let xpath = '';\n  let pos;\n  let tmpele;\n  let element = el;\n\n  while (element !== document.documentelement) {\n    pos = 0;\n    tmpele = element;\n    while (tmpele) {\n      if (tmpele.nodetype === 1 && tmpele.nodename === element.nodename) {\n        // if it is element_node of the same name\n        pos += 1;\n      }\n      tmpele = tmpele.previoussibling;\n    }\n\n    xpath = `*[name()='${element.nodename}'][${pos}]/${xpath}`;\n\n    element = element.parentnode!;\n  }\n\n  xpath = `/*[name()='${document.documentelement.nodename}']/${xpath}`;\n  xpath = xpath.replace(/\\/$/, '');\n\n  return xpath;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"globalState",frontmatter:{title:"globalState",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/core/globalState/",categories:["qiankun","core"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/10.core/50.globalState.html",relativePath:"30.web/6.qiankun源码/10.core/50.globalState.md",key:"v-263cdfff",path:"/qiankun/core/globalState/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"loadApp 加载微应用",frontmatter:{title:"loadApp 加载微应用",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/core/loader/",categories:["qiankun","core"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/10.core/20.loader.html",relativePath:"30.web/6.qiankun源码/10.core/20.loader.md",key:"v-6646936e",path:"/qiankun/core/loader/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"loadApp",slug:"loadapp",normalizedTitle:"loadapp",charIndex:17},{level:3,title:"createElement",slug:"createelement",normalizedTitle:"createelement",charIndex:30},{level:3,title:"execHooksChain",slug:"exechookschain",normalizedTitle:"exechookschain",charIndex:49},{level:3,title:"getRender",slug:"getrender",normalizedTitle:"getrender",charIndex:69},{level:3,title:"getLifecyclesFromExports",slug:"getlifecyclesfromexports",normalizedTitle:"getlifecyclesfromexports",charIndex:84},{level:2,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:112},{level:3,title:"UMD",slug:"umd",normalizedTitle:"umd",charIndex:120},{level:2,title:"一些技巧",slug:"一些技巧",normalizedTitle:"一些技巧",charIndex:127},{level:3,title:"生成唯一 id 的思路",slug:"生成唯一-id-的思路",normalizedTitle:"生成唯一 id 的思路",charIndex:137},{level:2,title:"获取原生的 window",slug:"获取原生的-window",normalizedTitle:"获取原生的 window",charIndex:152}],readingTime:{text:"11 min read",minutes:10.945,time:656700,words:2189},headersStr:"目录 loadApp createElement execHooksChain getRender getLifecyclesFromExports 扩展 UMD 一些技巧 生成唯一 id 的思路 获取原生的 window",content:"# 目录\n\n\n\n * 目录\n * loadApp\n   * createElement\n   * execHooksChain\n   * getRender\n   * getLifecyclesFromExports\n * 扩展\n   * UMD\n * 一些技巧\n   * 生成唯一 id 的思路\n * 获取原生的 window\n\n\n\n\n# loadApp\n\n在 核心 API 中已经分析过，loadApp 这个函数会在 registerMicroApps、loadMicroApp 两个函数中调用。需要注意的是，需要保证 loadApp 在主程序 start 执行之后在执行，从 s-spa 的角度来说也就是 startSingleSpa 之后执行。主程序的 start 并不是一定得在注册微应用之后立即开启，主程序 start 的机会有两个，分别是 start 函数和 loadMicroApp 函数。\n\n// src/loader.ts\n\nexport async function loadApp<T extends ObjectType>(\n  // 微应用配置\n  app: LoadableApp<T>,\n  // 主程序配置\n  configuration: FrameworkConfiguration = {},\n  // 主程序生命周期钩子\n  lifeCycles?: FrameworkLifeCycles<T>,\n): Promise<ParcelConfigObjectGetter> {\n  const { entry, name: appName } = app;\n  // 通过微应用名称找到微应用实例 id\n  const appInstanceId = genAppInstanceIdByName(appName);\n\n  const {\n    singular = false,\n    sandbox = true,\n    excludeAssetFilter,\n    globalContext = window,\n    ...importEntryOpts\n  } = configuration;\n  // 通过 import-html-entry.importEntry 获取到模板，entry 是微应用的地址，importEntryOpts 是获取模板时的配置\n  // get the entry html content and script executor\n  // template： Processed HTML template.\n  // execScripts：(sandbox?: object, strictGlobal?: boolean, execScriptsHooks?: ExecScriptsHooks): Promise<unknown> - the return value is the last property on window or proxy window which set by the entry script.\n  // assetPublicPath：Public path for assets.\n  // see https://github.com/kuitos/import-html-entry#execscriptsentry-scripts-proxy-opts\n  const { template, execScripts, assetPublicPath } = await importEntry(entry, importEntryOpts);\n\n  // as single-spa load and bootstrap new app parallel with other apps unmounting\n  // (see https://github.com/CanopyTax/single-spa/blob/master/src/navigation/reroute.js#L74)\n  // we need wait to load the app until all apps are finishing unmount in singular mode\n  // singular 支持传函数，所以这里判断最终是否开启 singular\n  if (await validateSingularMode(singular, app)) {\n    // singular模式中，由于 s-spa 中加载新应用和卸载其他应用时同时进行的，所以需要等其他应用卸载完毕\n    await (prevAppUnmountedDeferred && prevAppUnmountedDeferred.promise);\n  }\n\n  // 生成即将要插入到容器中的结构，注意这里使用了 Curry Function\n  // see https://jonsam.site/2021/09/01/js-tricks1/  Curry Function\n  const appContent = getDefaultTplWrapper(appInstanceId)(template);\n\n  // 是否配置了 strictStyleIsolation，如果配置为 true，则使用 ShadowDOM\n  // 这种方法有较大的局限性，see https://qiankun.umijs.org/zh/api#startopts sandbox\n  const strictStyleIsolation = typeof sandbox === 'object' && !!sandbox.strictStyleIsolation;\n\n  // 是否使用 experimentalStyleIsolation（基于样式前缀），而非 shadowDOM 的样式沙箱\n  const scopedCSS = isEnableScopedCSS(sandbox);\n  // 创建待插入的DOM节点元素\n  let initialAppWrapperElement: HTMLElement | null = createElement(\n    appContent,\n    strictStyleIsolation,\n    scopedCSS,\n    appInstanceId,\n  );\n\n  const initialContainer = 'container' in app ? app.container : undefined;\n  const legacyRender = 'render' in app ? app.render : undefined;\n  // 获取渲染策略\n  const render = getRender(appInstanceId, appContent, legacyRender);\n\n  // 第一次加载设置应用可见区域 dom 结构\n  // 确保每次应用加载前容器 dom 结构已经设置完毕\n  // 渲染模板文件到容器中，初始化微应用的 DOM 结构\n  render({ element: initialAppWrapperElement, loading: true, container: initialContainer }, 'loading');\n  // 生成获取微应用节点的方法\n  const initialAppWrapperGetter = getAppWrapperGetter(\n    appInstanceId,\n    !!legacyRender,\n    strictStyleIsolation,\n    scopedCSS,\n    () => initialAppWrapperElement,\n  );\n  // 拷贝 globalContext，以免污染 window\n  let global = globalContext;\n  let mountSandbox = () => Promise.resolve();\n  let unmountSandbox = () => Promise.resolve();\n  // 是否使用 loose 模式的沙箱\n  const useLooseSandbox = typeof sandbox === 'object' && !!sandbox.loose;\n  let sandboxContainer;\n  if (sandbox) {\n    // 创建沙箱容器\n    sandboxContainer = createSandboxContainer(\n      appInstanceId,\n      // FIXME should use a strict sandbox logic while remount, see https://github.com/umijs/qiankun/issues/518\n      initialAppWrapperGetter,\n      scopedCSS,\n      useLooseSandbox,\n      // 沙箱资源白名单过滤器\n      excludeAssetFilter,\n      global,\n    );\n    // 获取到沙箱中的全局代理对象，mount 方法和 unmount 方法\n    // 用沙箱的代理对象作为接下来使用的全局对象\n    global = sandboxContainer.instance.proxy as typeof window;\n    mountSandbox = sandboxContainer.mount;\n    unmountSandbox = sandboxContainer.unmount;\n  }\n\n  const { beforeUnmount = [], afterUnmount = [], afterMount = [], beforeMount = [], beforeLoad = [] } =\n    // mergeWith： This method is like _.merge except that it accepts customizer which is invoked to produce the merged values of the destination and source properties. If customizer returns undefined merging is handled by the method instead.\n    // see https://lodash.com/docs/4.17.15#mergeWith\n    // concat： Creates a new array concatenating array with any additional arrays and/or values.\n    // 合并内部插件中使用的生命周期和用户传入的生命周期回调\n    mergeWith({}, getAddOns(global, assetPublicPath), lifeCycles, (v1, v2) => concat(v1 ?? [], v2 ?? []));\n  // 执行所有 beforeLoad 的钩子链，因为当前处于 beforeLoad 阶段\n  await execHooksChain(toArray(beforeLoad), app, global);\n\n  // get the lifecycle hooks from module exports\n  // 执行模板中的 js 文件，执行 js 的沙箱为 global，如果使用 lose 模式的沙箱就不使用严格的 js 沙箱。\n  // scriptExports 为执行 js 之后的结果，微应用中的 js 通常打包为 umd\n  // 如果代码首次执行提供了沙箱，之后代码在运行时中都会在沙箱中运行\n  const scriptExports: any = await execScripts(global, sandbox && !useLooseSandbox);\n  // 从微应用中获取到相关的钩子函数\n  const { bootstrap, mount, unmount, update } = getLifecyclesFromExports(\n    scriptExports,\n    appName,\n    global,\n    // 之所以要使用 沙箱上的latestSetProp，是因为 execScripts 可能会在得到入口脚本的执行过程中将结果设置到 global 上，如果是代理沙箱，这个行为可以被记录下来，存放到 instance?.latestSetProp 上。参考 UMD 模块化。\n    sandboxContainer?.instance?.latestSetProp,\n  );\n  // 工厂方法：创建当前微应用的全局状态依赖管理工具函数，所有微应用的全局依赖存放在 globalState 文件中的 deps 中。\n  // 这里通过 appInstanceId 为当前微应用创建单独的依赖工具是利用工厂模式提升运行效率，同时可以隐藏 appInstanceId，尤其是暴露给外界 global 的id，体现其封装性\n  const { onGlobalStateChange, setGlobalState, offGlobalStateChange }: Record<string, CallableFunction> =\n    getMicroAppStateActions(appInstanceId);\n\n  // FIXME temporary way\n  const syncAppWrapperElement2Sandbox = (element: HTMLElement | null) => (initialAppWrapperElement = element);\n\n  // container 是可选的，有默认值\n  // loadApp 返回 parcelConfigGetter，通过 container 动态创建传递给 s-spa 的配置。\n  // 这里借鉴了 curry function 的思想\n  const parcelConfigGetter: ParcelConfigObjectGetter = (remountContainer = initialContainer) => {\n    let appWrapperElement: HTMLElement | null;\n    let appWrapperGetter: ReturnType<typeof getAppWrapperGetter>;\n\n    // 动态创建 s-spa.mountRootParcel 的配置\n    const parcelConfig: ParcelConfigObject = {\n      name: appInstanceId,\n      // bootstrap, mount, unmount, update 是从微应用中获取到的钩子函数\n      bootstrap,\n      // 注意这里 mount 中各个钩子函数都是同步执行的（async），这是为了保证钩子的执行顺序，同时也是因为 s-spa 无法确保外部的钩子是同步还是异步的，所以统一使用（await）处理。\n      mount: [\n        // 如果是 singular 模式，等待之前的微应用卸载完毕\n        async () => {\n          if ((await validateSingularMode(singular, app)) && prevAppUnmountedDeferred) {\n            return prevAppUnmountedDeferred.promise;\n          }\n\n          return undefined;\n        },\n        // initial wrapper element before app mount/remount\n        // 重新初始化内部的容器节点和容器 getter 方法\n        async () => {\n          appWrapperElement = initialAppWrapperElement;\n          appWrapperGetter = getAppWrapperGetter(\n            appInstanceId,\n            !!legacyRender,\n            strictStyleIsolation,\n            scopedCSS,\n            () => appWrapperElement,\n          );\n        },\n        // 添加 mount hook, 确保每次应用加载前容器 dom 结构已经设置完毕\n        async () => {\n          const useNewContainer = remountContainer !== initialContainer;\n          // 如果容器节点不存在，可能是已经被卸载了，则重新创建容器节点，并且缓存到 initialAppWrapperElement\n          if (useNewContainer || !appWrapperElement) {\n            // element will be destroyed after unmounted, we need to recreate it if it not exist\n            // or we try to remount into a new container\n            appWrapperElement = createElement(appContent, strictStyleIsolation, scopedCSS, appInstanceId);\n            syncAppWrapperElement2Sandbox(appWrapperElement);\n          }\n          // 确保模板中 dom 结构已经渲染完毕，状态为 mounting\n          render({ element: appWrapperElement, loading: true, container: remountContainer }, 'mounting');\n        },\n        // 执行沙箱中的 mount 钩子，初始化沙箱环境\n        mountSandbox,\n        // 执行插件和用户自定义的生命周期钩子 beforeMount\n        // exec the chain after rendering to keep the behavior with beforeLoad\n        async () => execHooksChain(toArray(beforeMount), app, global),\n        // 收集 s-spa 的回调参数和内部的参数，传递给微应用的 mount 钩子，执行微应用的 mount 钩子，注意这里的 setGlobalState 和 onGlobalStateChange 是当前微应用对全局状态监听的副作用\n        async (props) => mount({ ...props, container: appWrapperGetter(), setGlobalState, onGlobalStateChange }),\n        // finish loading after app mounted\n        // 渲染模板 DOM， 状态为 mounted\n        async () => render({ element: appWrapperElement, loading: false, container: remountContainer }, 'mounted'),\n        // 执行插件和用户自定义的生命周期钩子 afterMount\n        async () => execHooksChain(toArray(afterMount), app, global),\n        // initialize the unmount defer after app mounted and resolve the defer after it unmounted\n        async () => {\n          if (await validateSingularMode(singular, app)) {\n            // 应用已经 mount，初始化 prevAppUnmountedDeferred\n            prevAppUnmountedDeferred = new Deferred<void>();\n          }\n        },\n      ],\n      unmount: [\n        // 执行插件和用户自定义的生命周期钩子 beforeUnmount\n        async () => execHooksChain(toArray(beforeUnmount), app, global),\n        // 收集属性调用微应用的钩子 unmount\n        async (props) => unmount({ ...props, container: appWrapperGetter() }),\n        // 卸载沙箱\n        unmountSandbox,\n        // 执行插件和用户自定义的生命周期钩子 afterUnmount\n        async () => execHooksChain(toArray(afterUnmount), app, global),\n        async () => {\n          // 渲染模板，状态为 unmounted\n          render({ element: null, loading: false, container: remountContainer }, 'unmounted');\n          // 卸载全局状态监听effect\n          offGlobalStateChange(appInstanceId);\n          // 重置 appWrapperElement 和 initialAppWrapperElement\n          // for gc\n          appWrapperElement = null;\n          syncAppWrapperElement2Sandbox(appWrapperElement);\n        },\n        async () => {\n          if ((await validateSingularMode(singular, app)) && prevAppUnmountedDeferred) {\n            // unmount 执行完毕，resolve prevAppUnmountedDeferred\n            prevAppUnmountedDeferred.resolve();\n          }\n        },\n      ],\n    };\n    // 如果需要能支持主应用手动 update 微应用，需要微应用 entry 再多导出一个 update 钩子\n    if (typeof update === 'function') {\n      parcelConfig.update = update;\n    }\n\n    return parcelConfig;\n  };\n\n  return parcelConfigGetter;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n\n\n函数的核心作用：\n\n * 获取模板、渲染模板节点，执行模板脚本获取微应用生命周期钩子，并且在 s-spa 的生命周期中调用。\n * 初始化沙箱，并且在微应用 mount 和 unmount 时挂载和卸载沙箱。\n * 维护微应用的生命周期、执行插件在生命周期的回调和用户自定义的生命周期的回调。\n * 收集微应用监听全局状态的 effect。\n\n\n# createElement\n\ncreateElement 创建模板节点。\n\nconst supportShadowDOM = document.head.attachShadow || document.head.createShadowRoot;\n\nfunction createElement(\n  appContent: string,\n  strictStyleIsolation: boolean,\n  scopedCSS: boolean,\n  appInstanceId: string,\n): HTMLElement {\n  const containerElement = document.createElement('div');\n  containerElement.innerHTML = appContent;\n  // appContent always wrapped with a singular div\n  const appElement = containerElement.firstChild as HTMLElement;\n  if (strictStyleIsolation) {\n    if (!supportShadowDOM) {\n      console.warn(\n        '[qiankun]: As current browser not support shadow dom, your strictStyleIsolation configuration will be ignored!',\n      );\n    } else {\n      const { innerHTML } = appElement;\n      appElement.innerHTML = '';\n      let shadow: ShadowRoot;\n      // attachShadow 是 shadowDOM v1 规范\n      if (appElement.attachShadow) {\n        // 使用 shadowDOM\n        shadow = appElement.attachShadow({ mode: 'open' });\n      } else {\n        // createShadowRoot 是 shadowDOM v0 规范，已经废弃\n        // createShadowRoot was proposed in initial spec, which has then been deprecated\n        shadow = (appElement as any).createShadowRoot();\n      }\n      shadow.innerHTML = innerHTML;\n    }\n  }\n\n  if (scopedCSS) {\n    const attr = appElement.getAttribute(css.QiankunCSSRewriteAttr);\n    if (!attr) {\n      appElement.setAttribute(css.QiankunCSSRewriteAttr, appInstanceId);\n    }\n    // 如果采用了 scopedCSS，获取 appElement 上所有的样式并且加上样式前缀\n    const styleNodes = appElement.querySelectorAll('style') || [];\n    forEach(styleNodes, (stylesheetElement: HTMLStyleElement) => {\n      css.process(appElement!, stylesheetElement, appInstanceId);\n    });\n  }\n\n  return appElement;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n * 配置了 strictStyleIsolation，使用 shadowDOM 隔离样式。\n * 配置了 scopedCSS，使用样式前缀隔离样式。\n\n\n# execHooksChain\n\nexecHooksChain 执行钩子集合。\n\nfunction execHooksChain<T extends ObjectType>(\n  hooks: Array<LifeCycleFn<T>>,\n  app: LoadableApp<T>,\n  global = window,\n): Promise<any> {\n  if (hooks.length) {\n    return hooks.reduce((chain, hook) => chain.then(() => hook(app, global)), Promise.resolve());\n  }\n\n  return Promise.resolve();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nexecHooksChain 执行链式的返回 Promise 的钩子函数，这里用的很巧妙，初始化为空的 Promise，在 Promise.then 中执行 hook。 Promise.resolve().then(() => {}) 返回一个 Promise，促使 reduce 继续执行。而且，每个 hook 都在微任务中执行，知道最后一个 hook 执行返回 promise。\n\n/**\n * Represents the completion of an asynchronous operation\n */\ninterface Promise<T> {\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n     /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T | TResult>\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n以上是 Promise 类型定义，then、catch、finally 返回的都是 Promise。\n\n\n# getRender\n\n获取渲染模板 DOM 节点到容器的方法。\n\n\nconst rawAppendChild = HTMLElement.prototype.appendChild;\nconst rawRemoveChild = HTMLElement.prototype.removeChild;\n/**\n * Get the render function\n * If the legacy render function is provide, used as it, otherwise we will insert the app element to target container by qiankun\n * @param appInstanceId\n * @param appContent\n * @param legacyRender\n */\nfunction getRender(appInstanceId: string, appContent: string, legacyRender?: HTMLContentRender) {\n  const render: ElementRender = ({ element, loading, container }, phase) => {\n    if (legacyRender) {\n      return legacyRender({ loading, appContent: element ? appContent : '' });\n    }\n    // 获取外部配置的要挂载的容器\n    const containerElement = getContainer(container!);\n\n    // The container might have be removed after micro app unmounted.\n    // Such as the micro app unmount lifecycle called by a react componentWillUnmount lifecycle, after micro app unmounted, the react component might also be removed\n    if (phase !== 'unmounted') {\n      // 获取不同状态的报错信息\n      const errorMsg = (() => {\n        switch (phase) {\n          case 'loading':\n          case 'mounting':\n            return `Target container with ${container} not existed while ${appInstanceId} ${phase}!`;\n\n          case 'mounted':\n            return `Target container with ${container} not existed after ${appInstanceId} ${phase}!`;\n\n          default:\n            return `Target container with ${container} not existed while ${appInstanceId} rendering!`;\n        }\n      })();\n      assertElementExist(containerElement, errorMsg);\n    }\n\n    if (containerElement && !containerElement.contains(element)) {\n      // 清空容器\n      // clear the container\n      while (containerElement!.firstChild) {\n        rawRemoveChild.call(containerElement, containerElement!.firstChild);\n      }\n      // 插入元素\n      // append the element to container if it exist\n      if (element) {\n        rawAppendChild.call(containerElement, element);\n      }\n    }\n\n    return undefined;\n  };\n\n  return render;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# getLifecyclesFromExports\n\ngetLifecyclesFromExports 函数从微应用 js 的执行结果里尝试获取生命周期函数。\n\n/** 校验子应用导出的 生命周期 对象是否正确 */\nexport function validateExportLifecycle(exports: any) {\n  const { bootstrap, mount, unmount } = exports ?? {};\n  return isFunction(bootstrap) && isFunction(mount) && isFunction(unmount);\n}\n\nfunction getLifecyclesFromExports(\n  scriptExports: LifeCycles<any>,\n  appName: string,\n  global: WindowProxy,\n  globalLatestSetProp?: PropertyKey | null,\n) {\n  if (validateExportLifecycle(scriptExports)) {\n    return scriptExports;\n  }\n\n  // fallback to sandbox latest set property if it had\n  if (globalLatestSetProp) {\n    const lifecycles = (<any>global)[globalLatestSetProp];\n    if (validateExportLifecycle(lifecycles)) {\n      return lifecycles;\n    }\n  }\n\n  // fallback to global variable who named with ${appName} while module exports not found\n  const globalVariableExports = (global as any)[appName];\n\n  if (validateExportLifecycle(globalVariableExports)) {\n    return globalVariableExports;\n  }\n\n  throw new QiankunError(`You need to export lifecycle functions in ${appName} entry`);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n三种尝试分别为 scriptExports、 global[sandboxContainer?.instance?.latestSetProp] 和 global[appName] 。\n\n\n# 扩展\n\n\n# UMD\n\n在 getLifecyclesFromExports 中，我们知道了 qiankun 会从三中情况获取微应用 js 执行结果的 生命周期钩子，这个步骤至关重要，因为 k 框架本身依赖微应用本身的 mount、unmount 钩子挂载和卸载微应用，如 React 中的 ReactDOM.render 和 Vue3 中的 createApp().mount 。在打包工具中，通常将输出 js 格式设置为 UMD 格式。\n\n> UMD (Universal Module Definition), 希望提供一个前后端跨平台的解决方案 (支持 AMD 与 CommonJS 模块方式)。\n\n实现原理:\n\n * 先判断是否支持 Node.js 模块格式（exports 是否存在），存在则使用 Node.js 模块格式。\n * 再判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块。\n * 前两个都不存在，则将模块公开到全局（window 或 global）。\n\n各种具体的实现方式，可以查看 UMD 的 github。我这里举例一个 jQuery 使用的，按照如上方式实现的代码:\n\n// if the module has no dependencies, the above pattern can be simplified to\n(function (root, factory) {\n    // AMD\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n        // CJS\n    } else if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n      // Global\n        // Browser globals (root is window)\n        root.returnExports = factory();\n  }\n}(this, function () {\n\n    // Just return a value to define the module export.\n    // This example returns an object, but the module\n    // can return a function as the exported value.\n    return {};\n}));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n这里使用了 DI（依赖注入模式）的思想。\n\n参考：\n\n * [JavaScript] Javascript 模块化基础\n * 依赖注入模式（Dependency Injection）\n\n\n# 一些技巧\n\n\n# 生成唯一 id 的思路\n\n一般对于需要创建唯一 id 时，通常会生成一个随机数（UUID）或者哈希值，还有一种简单的方法类似于排队的领号，每个人领到的号都不一样。\n\n// 获取原生的 window\nexport const nativeGlobal = new Function('return this')();\n\n// 在 nativeGlobal 上 配置 __app_instance_name_map__, 这里返回 __app_instance_name_map__\n// once: Creates a function that is restricted to invoking func once. Repeat calls to the function return the value of the first call. The func is invoked with the this binding and arguments of the created function.\n// see https://www.lodashjs.com/docs/lodash.once\n// app instance id generator compatible with nested sandbox\n// genAppInstanceIdByName 同时调用多次时，可能会发生资源争夺，利用闭包让函数只执行一次，缓存执行的结果\nconst getGlobalAppInstanceMap = once<() => Record<string, number>>(() => {\n  if (!nativeGlobal.hasOwnProperty('__app_instance_name_map__')) {\n    Object.defineProperty(nativeGlobal, '__app_instance_name_map__', {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: {},\n    });\n  }\n\n  return nativeGlobal.__app_instance_name_map__;\n});\n/**\n * 根据实例名称获取实例 id，内部计数自增\n * Get app instance name with the auto-increment approach\n * @param appName\n */\nexport const genAppInstanceIdByName = (appName: string): string => {\n  // 获取到应用实例缓存 map\n  const globalAppInstanceMap = getGlobalAppInstanceMap();\n  if (!(appName in globalAppInstanceMap)) {\n    nativeGlobal.__app_instance_name_map__[appName] = 0;\n    return appName;\n  }\n\n  globalAppInstanceMap[appName]++;\n  return `${appName}_${globalAppInstanceMap[appName]}`;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 获取原生的 window\n\nconst window = new Function('return this')(); 可以获取原生的 window，这里利用了构造函数创建的 Function 的一些特性。\n\n> 由 Function 构造函数创建的函数不会创建当前环境的闭包，它们总是被创建于全局环境，因此在运行时它们只能访问全局变量和自己的局部变量，不能访问它们被 Function 构造函数创建时所在的作用域的变量。这一点与使用 eval () 执行创建函数的代码不同。\n\n参考：\n\n * MDN: Function 构造函数与函数声明之间的不同",normalizedContent:"# 目录\n\n\n\n * 目录\n * loadapp\n   * createelement\n   * exechookschain\n   * getrender\n   * getlifecyclesfromexports\n * 扩展\n   * umd\n * 一些技巧\n   * 生成唯一 id 的思路\n * 获取原生的 window\n\n\n\n\n# loadapp\n\n在 核心 api 中已经分析过，loadapp 这个函数会在 registermicroapps、loadmicroapp 两个函数中调用。需要注意的是，需要保证 loadapp 在主程序 start 执行之后在执行，从 s-spa 的角度来说也就是 startsinglespa 之后执行。主程序的 start 并不是一定得在注册微应用之后立即开启，主程序 start 的机会有两个，分别是 start 函数和 loadmicroapp 函数。\n\n// src/loader.ts\n\nexport async function loadapp<t extends objecttype>(\n  // 微应用配置\n  app: loadableapp<t>,\n  // 主程序配置\n  configuration: frameworkconfiguration = {},\n  // 主程序生命周期钩子\n  lifecycles?: frameworklifecycles<t>,\n): promise<parcelconfigobjectgetter> {\n  const { entry, name: appname } = app;\n  // 通过微应用名称找到微应用实例 id\n  const appinstanceid = genappinstanceidbyname(appname);\n\n  const {\n    singular = false,\n    sandbox = true,\n    excludeassetfilter,\n    globalcontext = window,\n    ...importentryopts\n  } = configuration;\n  // 通过 import-html-entry.importentry 获取到模板，entry 是微应用的地址，importentryopts 是获取模板时的配置\n  // get the entry html content and script executor\n  // template： processed html template.\n  // execscripts：(sandbox?: object, strictglobal?: boolean, execscriptshooks?: execscriptshooks): promise<unknown> - the return value is the last property on window or proxy window which set by the entry script.\n  // assetpublicpath：public path for assets.\n  // see https://github.com/kuitos/import-html-entry#execscriptsentry-scripts-proxy-opts\n  const { template, execscripts, assetpublicpath } = await importentry(entry, importentryopts);\n\n  // as single-spa load and bootstrap new app parallel with other apps unmounting\n  // (see https://github.com/canopytax/single-spa/blob/master/src/navigation/reroute.js#l74)\n  // we need wait to load the app until all apps are finishing unmount in singular mode\n  // singular 支持传函数，所以这里判断最终是否开启 singular\n  if (await validatesingularmode(singular, app)) {\n    // singular模式中，由于 s-spa 中加载新应用和卸载其他应用时同时进行的，所以需要等其他应用卸载完毕\n    await (prevappunmounteddeferred && prevappunmounteddeferred.promise);\n  }\n\n  // 生成即将要插入到容器中的结构，注意这里使用了 curry function\n  // see https://jonsam.site/2021/09/01/js-tricks1/  curry function\n  const appcontent = getdefaulttplwrapper(appinstanceid)(template);\n\n  // 是否配置了 strictstyleisolation，如果配置为 true，则使用 shadowdom\n  // 这种方法有较大的局限性，see https://qiankun.umijs.org/zh/api#startopts sandbox\n  const strictstyleisolation = typeof sandbox === 'object' && !!sandbox.strictstyleisolation;\n\n  // 是否使用 experimentalstyleisolation（基于样式前缀），而非 shadowdom 的样式沙箱\n  const scopedcss = isenablescopedcss(sandbox);\n  // 创建待插入的dom节点元素\n  let initialappwrapperelement: htmlelement | null = createelement(\n    appcontent,\n    strictstyleisolation,\n    scopedcss,\n    appinstanceid,\n  );\n\n  const initialcontainer = 'container' in app ? app.container : undefined;\n  const legacyrender = 'render' in app ? app.render : undefined;\n  // 获取渲染策略\n  const render = getrender(appinstanceid, appcontent, legacyrender);\n\n  // 第一次加载设置应用可见区域 dom 结构\n  // 确保每次应用加载前容器 dom 结构已经设置完毕\n  // 渲染模板文件到容器中，初始化微应用的 dom 结构\n  render({ element: initialappwrapperelement, loading: true, container: initialcontainer }, 'loading');\n  // 生成获取微应用节点的方法\n  const initialappwrappergetter = getappwrappergetter(\n    appinstanceid,\n    !!legacyrender,\n    strictstyleisolation,\n    scopedcss,\n    () => initialappwrapperelement,\n  );\n  // 拷贝 globalcontext，以免污染 window\n  let global = globalcontext;\n  let mountsandbox = () => promise.resolve();\n  let unmountsandbox = () => promise.resolve();\n  // 是否使用 loose 模式的沙箱\n  const useloosesandbox = typeof sandbox === 'object' && !!sandbox.loose;\n  let sandboxcontainer;\n  if (sandbox) {\n    // 创建沙箱容器\n    sandboxcontainer = createsandboxcontainer(\n      appinstanceid,\n      // fixme should use a strict sandbox logic while remount, see https://github.com/umijs/qiankun/issues/518\n      initialappwrappergetter,\n      scopedcss,\n      useloosesandbox,\n      // 沙箱资源白名单过滤器\n      excludeassetfilter,\n      global,\n    );\n    // 获取到沙箱中的全局代理对象，mount 方法和 unmount 方法\n    // 用沙箱的代理对象作为接下来使用的全局对象\n    global = sandboxcontainer.instance.proxy as typeof window;\n    mountsandbox = sandboxcontainer.mount;\n    unmountsandbox = sandboxcontainer.unmount;\n  }\n\n  const { beforeunmount = [], afterunmount = [], aftermount = [], beforemount = [], beforeload = [] } =\n    // mergewith： this method is like _.merge except that it accepts customizer which is invoked to produce the merged values of the destination and source properties. if customizer returns undefined merging is handled by the method instead.\n    // see https://lodash.com/docs/4.17.15#mergewith\n    // concat： creates a new array concatenating array with any additional arrays and/or values.\n    // 合并内部插件中使用的生命周期和用户传入的生命周期回调\n    mergewith({}, getaddons(global, assetpublicpath), lifecycles, (v1, v2) => concat(v1 ?? [], v2 ?? []));\n  // 执行所有 beforeload 的钩子链，因为当前处于 beforeload 阶段\n  await exechookschain(toarray(beforeload), app, global);\n\n  // get the lifecycle hooks from module exports\n  // 执行模板中的 js 文件，执行 js 的沙箱为 global，如果使用 lose 模式的沙箱就不使用严格的 js 沙箱。\n  // scriptexports 为执行 js 之后的结果，微应用中的 js 通常打包为 umd\n  // 如果代码首次执行提供了沙箱，之后代码在运行时中都会在沙箱中运行\n  const scriptexports: any = await execscripts(global, sandbox && !useloosesandbox);\n  // 从微应用中获取到相关的钩子函数\n  const { bootstrap, mount, unmount, update } = getlifecyclesfromexports(\n    scriptexports,\n    appname,\n    global,\n    // 之所以要使用 沙箱上的latestsetprop，是因为 execscripts 可能会在得到入口脚本的执行过程中将结果设置到 global 上，如果是代理沙箱，这个行为可以被记录下来，存放到 instance?.latestsetprop 上。参考 umd 模块化。\n    sandboxcontainer?.instance?.latestsetprop,\n  );\n  // 工厂方法：创建当前微应用的全局状态依赖管理工具函数，所有微应用的全局依赖存放在 globalstate 文件中的 deps 中。\n  // 这里通过 appinstanceid 为当前微应用创建单独的依赖工具是利用工厂模式提升运行效率，同时可以隐藏 appinstanceid，尤其是暴露给外界 global 的id，体现其封装性\n  const { onglobalstatechange, setglobalstate, offglobalstatechange }: record<string, callablefunction> =\n    getmicroappstateactions(appinstanceid);\n\n  // fixme temporary way\n  const syncappwrapperelement2sandbox = (element: htmlelement | null) => (initialappwrapperelement = element);\n\n  // container 是可选的，有默认值\n  // loadapp 返回 parcelconfiggetter，通过 container 动态创建传递给 s-spa 的配置。\n  // 这里借鉴了 curry function 的思想\n  const parcelconfiggetter: parcelconfigobjectgetter = (remountcontainer = initialcontainer) => {\n    let appwrapperelement: htmlelement | null;\n    let appwrappergetter: returntype<typeof getappwrappergetter>;\n\n    // 动态创建 s-spa.mountrootparcel 的配置\n    const parcelconfig: parcelconfigobject = {\n      name: appinstanceid,\n      // bootstrap, mount, unmount, update 是从微应用中获取到的钩子函数\n      bootstrap,\n      // 注意这里 mount 中各个钩子函数都是同步执行的（async），这是为了保证钩子的执行顺序，同时也是因为 s-spa 无法确保外部的钩子是同步还是异步的，所以统一使用（await）处理。\n      mount: [\n        // 如果是 singular 模式，等待之前的微应用卸载完毕\n        async () => {\n          if ((await validatesingularmode(singular, app)) && prevappunmounteddeferred) {\n            return prevappunmounteddeferred.promise;\n          }\n\n          return undefined;\n        },\n        // initial wrapper element before app mount/remount\n        // 重新初始化内部的容器节点和容器 getter 方法\n        async () => {\n          appwrapperelement = initialappwrapperelement;\n          appwrappergetter = getappwrappergetter(\n            appinstanceid,\n            !!legacyrender,\n            strictstyleisolation,\n            scopedcss,\n            () => appwrapperelement,\n          );\n        },\n        // 添加 mount hook, 确保每次应用加载前容器 dom 结构已经设置完毕\n        async () => {\n          const usenewcontainer = remountcontainer !== initialcontainer;\n          // 如果容器节点不存在，可能是已经被卸载了，则重新创建容器节点，并且缓存到 initialappwrapperelement\n          if (usenewcontainer || !appwrapperelement) {\n            // element will be destroyed after unmounted, we need to recreate it if it not exist\n            // or we try to remount into a new container\n            appwrapperelement = createelement(appcontent, strictstyleisolation, scopedcss, appinstanceid);\n            syncappwrapperelement2sandbox(appwrapperelement);\n          }\n          // 确保模板中 dom 结构已经渲染完毕，状态为 mounting\n          render({ element: appwrapperelement, loading: true, container: remountcontainer }, 'mounting');\n        },\n        // 执行沙箱中的 mount 钩子，初始化沙箱环境\n        mountsandbox,\n        // 执行插件和用户自定义的生命周期钩子 beforemount\n        // exec the chain after rendering to keep the behavior with beforeload\n        async () => exechookschain(toarray(beforemount), app, global),\n        // 收集 s-spa 的回调参数和内部的参数，传递给微应用的 mount 钩子，执行微应用的 mount 钩子，注意这里的 setglobalstate 和 onglobalstatechange 是当前微应用对全局状态监听的副作用\n        async (props) => mount({ ...props, container: appwrappergetter(), setglobalstate, onglobalstatechange }),\n        // finish loading after app mounted\n        // 渲染模板 dom， 状态为 mounted\n        async () => render({ element: appwrapperelement, loading: false, container: remountcontainer }, 'mounted'),\n        // 执行插件和用户自定义的生命周期钩子 aftermount\n        async () => exechookschain(toarray(aftermount), app, global),\n        // initialize the unmount defer after app mounted and resolve the defer after it unmounted\n        async () => {\n          if (await validatesingularmode(singular, app)) {\n            // 应用已经 mount，初始化 prevappunmounteddeferred\n            prevappunmounteddeferred = new deferred<void>();\n          }\n        },\n      ],\n      unmount: [\n        // 执行插件和用户自定义的生命周期钩子 beforeunmount\n        async () => exechookschain(toarray(beforeunmount), app, global),\n        // 收集属性调用微应用的钩子 unmount\n        async (props) => unmount({ ...props, container: appwrappergetter() }),\n        // 卸载沙箱\n        unmountsandbox,\n        // 执行插件和用户自定义的生命周期钩子 afterunmount\n        async () => exechookschain(toarray(afterunmount), app, global),\n        async () => {\n          // 渲染模板，状态为 unmounted\n          render({ element: null, loading: false, container: remountcontainer }, 'unmounted');\n          // 卸载全局状态监听effect\n          offglobalstatechange(appinstanceid);\n          // 重置 appwrapperelement 和 initialappwrapperelement\n          // for gc\n          appwrapperelement = null;\n          syncappwrapperelement2sandbox(appwrapperelement);\n        },\n        async () => {\n          if ((await validatesingularmode(singular, app)) && prevappunmounteddeferred) {\n            // unmount 执行完毕，resolve prevappunmounteddeferred\n            prevappunmounteddeferred.resolve();\n          }\n        },\n      ],\n    };\n    // 如果需要能支持主应用手动 update 微应用，需要微应用 entry 再多导出一个 update 钩子\n    if (typeof update === 'function') {\n      parcelconfig.update = update;\n    }\n\n    return parcelconfig;\n  };\n\n  return parcelconfiggetter;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n\n\n函数的核心作用：\n\n * 获取模板、渲染模板节点，执行模板脚本获取微应用生命周期钩子，并且在 s-spa 的生命周期中调用。\n * 初始化沙箱，并且在微应用 mount 和 unmount 时挂载和卸载沙箱。\n * 维护微应用的生命周期、执行插件在生命周期的回调和用户自定义的生命周期的回调。\n * 收集微应用监听全局状态的 effect。\n\n\n# createelement\n\ncreateelement 创建模板节点。\n\nconst supportshadowdom = document.head.attachshadow || document.head.createshadowroot;\n\nfunction createelement(\n  appcontent: string,\n  strictstyleisolation: boolean,\n  scopedcss: boolean,\n  appinstanceid: string,\n): htmlelement {\n  const containerelement = document.createelement('div');\n  containerelement.innerhtml = appcontent;\n  // appcontent always wrapped with a singular div\n  const appelement = containerelement.firstchild as htmlelement;\n  if (strictstyleisolation) {\n    if (!supportshadowdom) {\n      console.warn(\n        '[qiankun]: as current browser not support shadow dom, your strictstyleisolation configuration will be ignored!',\n      );\n    } else {\n      const { innerhtml } = appelement;\n      appelement.innerhtml = '';\n      let shadow: shadowroot;\n      // attachshadow 是 shadowdom v1 规范\n      if (appelement.attachshadow) {\n        // 使用 shadowdom\n        shadow = appelement.attachshadow({ mode: 'open' });\n      } else {\n        // createshadowroot 是 shadowdom v0 规范，已经废弃\n        // createshadowroot was proposed in initial spec, which has then been deprecated\n        shadow = (appelement as any).createshadowroot();\n      }\n      shadow.innerhtml = innerhtml;\n    }\n  }\n\n  if (scopedcss) {\n    const attr = appelement.getattribute(css.qiankuncssrewriteattr);\n    if (!attr) {\n      appelement.setattribute(css.qiankuncssrewriteattr, appinstanceid);\n    }\n    // 如果采用了 scopedcss，获取 appelement 上所有的样式并且加上样式前缀\n    const stylenodes = appelement.queryselectorall('style') || [];\n    foreach(stylenodes, (stylesheetelement: htmlstyleelement) => {\n      css.process(appelement!, stylesheetelement, appinstanceid);\n    });\n  }\n\n  return appelement;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n * 配置了 strictstyleisolation，使用 shadowdom 隔离样式。\n * 配置了 scopedcss，使用样式前缀隔离样式。\n\n\n# exechookschain\n\nexechookschain 执行钩子集合。\n\nfunction exechookschain<t extends objecttype>(\n  hooks: array<lifecyclefn<t>>,\n  app: loadableapp<t>,\n  global = window,\n): promise<any> {\n  if (hooks.length) {\n    return hooks.reduce((chain, hook) => chain.then(() => hook(app, global)), promise.resolve());\n  }\n\n  return promise.resolve();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nexechookschain 执行链式的返回 promise 的钩子函数，这里用的很巧妙，初始化为空的 promise，在 promise.then 中执行 hook。 promise.resolve().then(() => {}) 返回一个 promise，促使 reduce 继续执行。而且，每个 hook 都在微任务中执行，知道最后一个 hook 执行返回 promise。\n\n/**\n * represents the completion of an asynchronous operation\n */\ninterface promise<t> {\n    /**\n     * attaches callbacks for the resolution and/or rejection of the promise.\n     * @param onfulfilled the callback to execute when the promise is resolved.\n     * @param onrejected the callback to execute when the promise is rejected.\n     * @returns a promise for the completion of which ever callback is executed.\n     */\n    then<tresult1 = t, tresult2 = never>(onfulfilled?: ((value: t) => tresult1 | promiselike<tresult1>) | undefined | null, onrejected?: ((reason: any) => tresult2 | promiselike<tresult2>) | undefined | null): promise<tresult1 | tresult2>;\n\n    /**\n     * attaches a callback for only the rejection of the promise.\n     * @param onrejected the callback to execute when the promise is rejected.\n     * @returns a promise for the completion of the callback.\n     */\n    catch<tresult = never>(onrejected?: ((reason: any) => tresult | promiselike<tresult>) | undefined | null): promise<t | tresult>;\n     /**\n     * attaches a callback that is invoked when the promise is settled (fulfilled or rejected). the\n     * resolved value cannot be modified from the callback.\n     * @param onfinally the callback to execute when the promise is settled (fulfilled or rejected).\n     * @returns a promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): promise<t | tresult>\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n以上是 promise 类型定义，then、catch、finally 返回的都是 promise。\n\n\n# getrender\n\n获取渲染模板 dom 节点到容器的方法。\n\n\nconst rawappendchild = htmlelement.prototype.appendchild;\nconst rawremovechild = htmlelement.prototype.removechild;\n/**\n * get the render function\n * if the legacy render function is provide, used as it, otherwise we will insert the app element to target container by qiankun\n * @param appinstanceid\n * @param appcontent\n * @param legacyrender\n */\nfunction getrender(appinstanceid: string, appcontent: string, legacyrender?: htmlcontentrender) {\n  const render: elementrender = ({ element, loading, container }, phase) => {\n    if (legacyrender) {\n      return legacyrender({ loading, appcontent: element ? appcontent : '' });\n    }\n    // 获取外部配置的要挂载的容器\n    const containerelement = getcontainer(container!);\n\n    // the container might have be removed after micro app unmounted.\n    // such as the micro app unmount lifecycle called by a react componentwillunmount lifecycle, after micro app unmounted, the react component might also be removed\n    if (phase !== 'unmounted') {\n      // 获取不同状态的报错信息\n      const errormsg = (() => {\n        switch (phase) {\n          case 'loading':\n          case 'mounting':\n            return `target container with ${container} not existed while ${appinstanceid} ${phase}!`;\n\n          case 'mounted':\n            return `target container with ${container} not existed after ${appinstanceid} ${phase}!`;\n\n          default:\n            return `target container with ${container} not existed while ${appinstanceid} rendering!`;\n        }\n      })();\n      assertelementexist(containerelement, errormsg);\n    }\n\n    if (containerelement && !containerelement.contains(element)) {\n      // 清空容器\n      // clear the container\n      while (containerelement!.firstchild) {\n        rawremovechild.call(containerelement, containerelement!.firstchild);\n      }\n      // 插入元素\n      // append the element to container if it exist\n      if (element) {\n        rawappendchild.call(containerelement, element);\n      }\n    }\n\n    return undefined;\n  };\n\n  return render;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# getlifecyclesfromexports\n\ngetlifecyclesfromexports 函数从微应用 js 的执行结果里尝试获取生命周期函数。\n\n/** 校验子应用导出的 生命周期 对象是否正确 */\nexport function validateexportlifecycle(exports: any) {\n  const { bootstrap, mount, unmount } = exports ?? {};\n  return isfunction(bootstrap) && isfunction(mount) && isfunction(unmount);\n}\n\nfunction getlifecyclesfromexports(\n  scriptexports: lifecycles<any>,\n  appname: string,\n  global: windowproxy,\n  globallatestsetprop?: propertykey | null,\n) {\n  if (validateexportlifecycle(scriptexports)) {\n    return scriptexports;\n  }\n\n  // fallback to sandbox latest set property if it had\n  if (globallatestsetprop) {\n    const lifecycles = (<any>global)[globallatestsetprop];\n    if (validateexportlifecycle(lifecycles)) {\n      return lifecycles;\n    }\n  }\n\n  // fallback to global variable who named with ${appname} while module exports not found\n  const globalvariableexports = (global as any)[appname];\n\n  if (validateexportlifecycle(globalvariableexports)) {\n    return globalvariableexports;\n  }\n\n  throw new qiankunerror(`you need to export lifecycle functions in ${appname} entry`);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n三种尝试分别为 scriptexports、 global[sandboxcontainer?.instance?.latestsetprop] 和 global[appname] 。\n\n\n# 扩展\n\n\n# umd\n\n在 getlifecyclesfromexports 中，我们知道了 qiankun 会从三中情况获取微应用 js 执行结果的 生命周期钩子，这个步骤至关重要，因为 k 框架本身依赖微应用本身的 mount、unmount 钩子挂载和卸载微应用，如 react 中的 reactdom.render 和 vue3 中的 createapp().mount 。在打包工具中，通常将输出 js 格式设置为 umd 格式。\n\n> umd (universal module definition), 希望提供一个前后端跨平台的解决方案 (支持 amd 与 commonjs 模块方式)。\n\n实现原理:\n\n * 先判断是否支持 node.js 模块格式（exports 是否存在），存在则使用 node.js 模块格式。\n * 再判断是否支持 amd（define 是否存在），存在则使用 amd 方式加载模块。\n * 前两个都不存在，则将模块公开到全局（window 或 global）。\n\n各种具体的实现方式，可以查看 umd 的 github。我这里举例一个 jquery 使用的，按照如上方式实现的代码:\n\n// if the module has no dependencies, the above pattern can be simplified to\n(function (root, factory) {\n    // amd\n    if (typeof define === 'function' && define.amd) {\n        // amd. register as an anonymous module.\n        define([], factory);\n        // cjs\n    } else if (typeof exports === 'object') {\n        // node. does not work with strict commonjs, but\n        // only commonjs-like environments that support module.exports,\n        // like node.\n        module.exports = factory();\n    } else {\n      // global\n        // browser globals (root is window)\n        root.returnexports = factory();\n  }\n}(this, function () {\n\n    // just return a value to define the module export.\n    // this example returns an object, but the module\n    // can return a function as the exported value.\n    return {};\n}));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n这里使用了 di（依赖注入模式）的思想。\n\n参考：\n\n * [javascript] javascript 模块化基础\n * 依赖注入模式（dependency injection）\n\n\n# 一些技巧\n\n\n# 生成唯一 id 的思路\n\n一般对于需要创建唯一 id 时，通常会生成一个随机数（uuid）或者哈希值，还有一种简单的方法类似于排队的领号，每个人领到的号都不一样。\n\n// 获取原生的 window\nexport const nativeglobal = new function('return this')();\n\n// 在 nativeglobal 上 配置 __app_instance_name_map__, 这里返回 __app_instance_name_map__\n// once: creates a function that is restricted to invoking func once. repeat calls to the function return the value of the first call. the func is invoked with the this binding and arguments of the created function.\n// see https://www.lodashjs.com/docs/lodash.once\n// app instance id generator compatible with nested sandbox\n// genappinstanceidbyname 同时调用多次时，可能会发生资源争夺，利用闭包让函数只执行一次，缓存执行的结果\nconst getglobalappinstancemap = once<() => record<string, number>>(() => {\n  if (!nativeglobal.hasownproperty('__app_instance_name_map__')) {\n    object.defineproperty(nativeglobal, '__app_instance_name_map__', {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: {},\n    });\n  }\n\n  return nativeglobal.__app_instance_name_map__;\n});\n/**\n * 根据实例名称获取实例 id，内部计数自增\n * get app instance name with the auto-increment approach\n * @param appname\n */\nexport const genappinstanceidbyname = (appname: string): string => {\n  // 获取到应用实例缓存 map\n  const globalappinstancemap = getglobalappinstancemap();\n  if (!(appname in globalappinstancemap)) {\n    nativeglobal.__app_instance_name_map__[appname] = 0;\n    return appname;\n  }\n\n  globalappinstancemap[appname]++;\n  return `${appname}_${globalappinstancemap[appname]}`;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 获取原生的 window\n\nconst window = new function('return this')(); 可以获取原生的 window，这里利用了构造函数创建的 function 的一些特性。\n\n> 由 function 构造函数创建的函数不会创建当前环境的闭包，它们总是被创建于全局环境，因此在运行时它们只能访问全局变量和自己的局部变量，不能访问它们被 function 构造函数创建时所在的作用域的变量。这一点与使用 eval () 执行创建函数的代码不同。\n\n参考：\n\n * mdn: function 构造函数与函数声明之间的不同",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"addon",frontmatter:{title:"addon",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/core/addon/",categories:["qiankun","core"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/10.core/60.addon.html",relativePath:"30.web/6.qiankun源码/10.core/60.addon.md",key:"v-4956ba5f",path:"/qiankun/core/addon/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"本章概要",frontmatter:{title:"本章概要",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/sandbox/index/",categories:["qiankun","sandbox"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/20.sandbox/0.index.html",relativePath:"30.web/6.qiankun源码/20.sandbox/0.index.md",key:"v-a0fcd902",path:"/qiankun/sandbox/index/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"沙箱",slug:"沙箱",normalizedTitle:"沙箱",charIndex:17},{level:3,title:"CSS 沙箱",slug:"css-沙箱",normalizedTitle:"css 沙箱",charIndex:25},{level:3,title:"JS 沙箱",slug:"js-沙箱",normalizedTitle:"js 沙箱",charIndex:37},{level:2,title:"Shadow DOM",slug:"shadow-dom",normalizedTitle:"shadow dom",charIndex:46},{level:2,title:"WindowProxy",slug:"windowproxy",normalizedTitle:"windowproxy",charIndex:60},{level:2,title:"Object.getOwnPropertyDescriptor()",slug:"object-getownpropertydescriptor",normalizedTitle:"object.getownpropertydescriptor()",charIndex:75},{level:2,title:"Window.top/parent/self/window",slug:"window-top-parent-self-window",normalizedTitle:"window.top/parent/self/window",charIndex:112}],readingTime:{text:"2 min read",minutes:1.37,time:82200,words:274},headersStr:"目录 沙箱 CSS 沙箱 JS 沙箱 Shadow DOM WindowProxy Object.getOwnPropertyDescriptor() Window.top/parent/self/window",content:"# 目录\n\n\n\n * 目录\n * 沙箱\n   * CSS 沙箱\n   * JS 沙箱\n * Shadow DOM\n * WindowProxy\n * Object.getOwnPropertyDescriptor()\n * Window.top/parent/self/window\n\n\n\n\n# 沙箱\n\n在微服务中，主要要解决两个沙箱问题，分别是 CSS 沙箱和 JS 沙箱。对于 JS 沙箱而言，主要也要解决两个问题，一个是沙箱的隔离作用，二是沙箱间、沙箱与基座应用间的通信机制。在沙箱这一部分，我们主要解析 CSS 沙箱的实现原理和 JS 沙箱的实现原理。\n\n\n# CSS 沙箱\n\n实现 CSS 沙箱主要有以下几种方案：\n\n * BEM CSS。给 CSS class 添加约定的类进行区分。\n * Module CSS。模块化的 CSS 能够让 CSS 在一定的 scope 以内生效。\n * CSS In JS。CSS-in-JS 的实现方法上区分大体分为两种：唯一 CSS 选择器和内联样式（Unique Selector VS Inline Styles）。这两种方法都可以达到隔离 CSS 的作用。参考：阮一峰：CSS in JS 简介\n * ShadowDOM\n * namespace：每个业务模块或者团队使用不同的样式前缀。\n * Dynamic StyleSheet：动态的注入或者删除样式表。\n\n\n# JS 沙箱\n\n * 代理沙箱（ProxySandbox）\n * 快照沙箱（SnapshotSandbox）\n\n\n# Shadow DOM\n\n> Method of establishing and maintaining functional boundaries between DOM trees and how these trees interact with each other within a document, thus enabling better functional encapsulation within the DOM & CSS.\n\nWeb components 的一个重要属性是封装 —— 可以将标记结构、样式和行为隐藏起来，并与页面上的其他代码相隔离，保证不同的部分不会混在一起，可使代码更加干净、整洁。其中，Shadow DOM 接口是关键所在，它可以将一个隐藏的、独立的 DOM 附加到一个元素上。\n\n注意\n\nShadow DOM 不支持 IE 浏览器，查看支持情况，但是可以通过 polyfill 获取支持。\n\n参考：\n\n * Using shadow DOM\n * 深入理解 Shadow DOM v1\n\n参考：\n\n * 15 分钟快速理解 qiankun 的 js 沙箱原理及其实现\n\n\n# WindowProxy\n\n> A WindowProxy object is a wrapper for a Window object. A WindowProxy object exists in every browsing context. All operations performed on a WindowProxy object will also be applied to the underlying Window object it currently wraps. Therefore, interacting with a WindowProxy object is almost identical to directly interacting with a Window object. When a browsing context is navigated, the Window object its WindowProxy wraps is changed.\n\n参考：\n\n * WIKI：WindowProxy\n\n\n# Object.getOwnPropertyDescriptor()\n\n> Object.getOwnPropertyDescriptor () 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）。\n\n该方法允许对一个属性的描述进行检索。在 Javascript 中， 属性 由一个字符串类型的 “名字”（name）和一个 “属性描述符”（property descriptor）对象构成。更多关于属性描述符类型以及他们属性的信息可以查看：Object.defineProperty.\n\n * MDN: Object.getOwnPropertyDescriptor()\n\nObject.defineProperty(obj, prop, descriptor)\n\n\n1\n\n\n\n# Window.top/parent/self/window\n\n * Window.top: Returns a reference to the topmost window in the window hierarchy. This property is read only.\n * Window.parent\n * Window.self: Returns an object reference to the window object itself.\n * Window.window: Returns a reference to the current window.\n\n参考：\n\n * MDN：Window",normalizedContent:"# 目录\n\n\n\n * 目录\n * 沙箱\n   * css 沙箱\n   * js 沙箱\n * shadow dom\n * windowproxy\n * object.getownpropertydescriptor()\n * window.top/parent/self/window\n\n\n\n\n# 沙箱\n\n在微服务中，主要要解决两个沙箱问题，分别是 css 沙箱和 js 沙箱。对于 js 沙箱而言，主要也要解决两个问题，一个是沙箱的隔离作用，二是沙箱间、沙箱与基座应用间的通信机制。在沙箱这一部分，我们主要解析 css 沙箱的实现原理和 js 沙箱的实现原理。\n\n\n# css 沙箱\n\n实现 css 沙箱主要有以下几种方案：\n\n * bem css。给 css class 添加约定的类进行区分。\n * module css。模块化的 css 能够让 css 在一定的 scope 以内生效。\n * css in js。css-in-js 的实现方法上区分大体分为两种：唯一 css 选择器和内联样式（unique selector vs inline styles）。这两种方法都可以达到隔离 css 的作用。参考：阮一峰：css in js 简介\n * shadowdom\n * namespace：每个业务模块或者团队使用不同的样式前缀。\n * dynamic stylesheet：动态的注入或者删除样式表。\n\n\n# js 沙箱\n\n * 代理沙箱（proxysandbox）\n * 快照沙箱（snapshotsandbox）\n\n\n# shadow dom\n\n> method of establishing and maintaining functional boundaries between dom trees and how these trees interact with each other within a document, thus enabling better functional encapsulation within the dom & css.\n\nweb components 的一个重要属性是封装 —— 可以将标记结构、样式和行为隐藏起来，并与页面上的其他代码相隔离，保证不同的部分不会混在一起，可使代码更加干净、整洁。其中，shadow dom 接口是关键所在，它可以将一个隐藏的、独立的 dom 附加到一个元素上。\n\n注意\n\nshadow dom 不支持 ie 浏览器，查看支持情况，但是可以通过 polyfill 获取支持。\n\n参考：\n\n * using shadow dom\n * 深入理解 shadow dom v1\n\n参考：\n\n * 15 分钟快速理解 qiankun 的 js 沙箱原理及其实现\n\n\n# windowproxy\n\n> a windowproxy object is a wrapper for a window object. a windowproxy object exists in every browsing context. all operations performed on a windowproxy object will also be applied to the underlying window object it currently wraps. therefore, interacting with a windowproxy object is almost identical to directly interacting with a window object. when a browsing context is navigated, the window object its windowproxy wraps is changed.\n\n参考：\n\n * wiki：windowproxy\n\n\n# object.getownpropertydescriptor()\n\n> object.getownpropertydescriptor () 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）。\n\n该方法允许对一个属性的描述进行检索。在 javascript 中， 属性 由一个字符串类型的 “名字”（name）和一个 “属性描述符”（property descriptor）对象构成。更多关于属性描述符类型以及他们属性的信息可以查看：object.defineproperty.\n\n * mdn: object.getownpropertydescriptor()\n\nobject.defineproperty(obj, prop, descriptor)\n\n\n1\n\n\n\n# window.top/parent/self/window\n\n * window.top: returns a reference to the topmost window in the window hierarchy. this property is read only.\n * window.parent\n * window.self: returns an object reference to the window object itself.\n * window.window: returns a reference to the current window.\n\n参考：\n\n * mdn：window",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"createSandboxContainer 创建沙箱",frontmatter:{title:"createSandboxContainer 创建沙箱",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/sandbox/sandbox/",categories:["qiankun","sandbox"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/20.sandbox/10.sandbox.html",relativePath:"30.web/6.qiankun源码/20.sandbox/10.sandbox.md",key:"v-b7416126",path:"/qiankun/sandbox/sandbox/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"createSandboxContainer",slug:"createsandboxcontainer",normalizedTitle:"createsandboxcontainer",charIndex:17}],readingTime:{text:"3 min read",minutes:2.4,time:144e3,words:480},headersStr:"目录 createSandboxContainer",content:"# 目录\n\n\n\n * 目录\n * createSandboxContainer\n\n\n\n\n# createSandboxContainer\n\ncreateSandboxContainer 函数创建沙箱，并且维护一些 patch 工作。\n\n// src/sandbox/index.ts\n/**\n * 生成应用运行时沙箱\n *\n * 沙箱分两个类型：\n * 1. app 环境沙箱\n *  app 环境沙箱是指应用初始化过之后，应用会在什么样的上下文环境运行。每个应用的环境沙箱只会初始化一次，因为子应用只会触发一次 bootstrap 。\n *  子应用在切换时，实际上切换的是 app 环境沙箱。\n * 2. render 沙箱\n *  子应用在 app mount 开始前生成好的的沙箱。每次子应用切换过后，render 沙箱都会重现初始化。\n *\n * 这么设计的目的是为了保证每个子应用切换回来之后，还能运行在应用 bootstrap 之后的环境下。\n *\n * @param appName\n * @param elementGetter\n * @param scopedCSS\n * @param useLooseSandbox\n * @param excludeAssetFilter\n * @param globalContext\n */\nexport function createSandboxContainer(\n  appName: string,\n  // 获取待挂载元素的方法\n  elementGetter: () => HTMLElement | ShadowRoot,\n  // 是否使用 scopedCSS\n  scopedCSS: boolean,\n  // 是否使用 lose mode sandbox\n  useLooseSandbox?: boolean,\n  // 沙箱资源白名单\n  excludeAssetFilter?: (url: string) => boolean,\n  // global env\n  globalContext?: typeof window,\n) {\n  let sandbox: SandBox;\n  // 创建沙箱实例\n  if (window.Proxy) {\n    // lose mode 使用旧版沙箱，否则使用代理沙箱\n    sandbox = useLooseSandbox ? new LegacySandbox(appName, globalContext) : new ProxySandbox(appName, globalContext);\n  } else {\n    // 不支持 Proxy API 则使用快照沙箱，快照沙箱不支持多应用模式\n    sandbox = new SnapshotSandbox(appName);\n  }\n\n  // some side effect could be be invoked while bootstrapping, such as dynamic stylesheet injection with style-loader, especially during the development phase\n  // bootstrap 阶段的初始化工作，如动态样式表的插入，返回释放（恢复）副作用的数组\n  const bootstrappingFreers = patchAtBootstrapping(appName, elementGetter, sandbox, scopedCSS, excludeAssetFilter);\n  // mounting freers are one-off and should be re-init at every mounting time\n  let mountingFreers: Freer[] = [];\n\n  let sideEffectsRebuilders: Rebuilder[] = [];\n\n  return {\n    // sandbox 实例\n    instance: sandbox,\n\n    /**\n     * 沙箱被 mount\n     * 可能是从 bootstrap 状态进入的 mount\n     * 也可能是从 unmount 之后再次唤醒进入 mount\n     */\n    async mount() {\n      /* ------------------------------------------ 因为有上下文依赖（window），以下代码执行顺序不能变 ------------------------------------------ */\n\n      /* ------------------------------------------ 1. 启动/恢复 沙箱------------------------------------------ */\n      sandbox.active();\n      // 分离出 bootstrapping 阶段和 mounting 阶段的副作用，能用 bootstrappingFreers.length 分离是因为加入 sideEffectsRebuilders 时把 bootstrappingFreers 放到了前面\n      const sideEffectsRebuildersAtBootstrapping = sideEffectsRebuilders.slice(0, bootstrappingFreers.length);\n      const sideEffectsRebuildersAtMounting = sideEffectsRebuilders.slice(bootstrappingFreers.length);\n\n      // must rebuild the side effects which added at bootstrapping firstly to recovery to nature state\n      // 执行 bootstrapping 阶段的副作用\n      if (sideEffectsRebuildersAtBootstrapping.length) {\n        sideEffectsRebuildersAtBootstrapping.forEach((rebuild) => rebuild());\n      }\n\n      /* ------------------------------------------ 2. 开启全局变量补丁 ------------------------------------------*/\n      // render 沙箱启动时开始劫持各类全局监听，尽量不要在应用初始化阶段有 事件监听/定时器 等副作用\n      // mount 阶段的 patch（初始化） 工作，如事件监听等，返回释放（恢复）副作用的数组\n      mountingFreers = patchAtMounting(appName, elementGetter, sandbox, scopedCSS, excludeAssetFilter);\n\n      /* ------------------------------------------ 3. 重置一些初始化时的副作用 ------------------------------------------*/\n      // 存在 rebuilder 则表明有些副作用需要重建\n      // 执行 mounting 阶段的副作用\n      if (sideEffectsRebuildersAtMounting.length) {\n        sideEffectsRebuildersAtMounting.forEach((rebuild) => rebuild());\n      }\n\n      // clean up rebuilders\n      // 所有 mounting 和 bootstrapping 阶段副作用执行完毕，清空 sideEffectsRebuilders\n      sideEffectsRebuilders = [];\n    },\n\n    /**\n     * 恢复 global 状态，使其能回到应用加载之前的状态\n     */\n    async unmount() {\n      // record the rebuilders of window side effects (event listeners or timers)\n      // note that the frees of mounting phase are one-off as it will be re-init at next mounting\n      // 卸载时记录 bootstrapping 和 mounting 阶段的 rebuild 的副作用，以便在重新挂载时恢复到原始状态\n      // 注意：这里执行 rebuild 其实是 bootstrapping 和 mounting 阶段 patch 的 freer(恢复函数)。\n      // 注意：重新 mount 微应用时并不会重新执行 createSandboxContainer，因为创建的 sandbox 已经在闭包之中，但是 sandbox 的 mount 函数会被重新执行。\n      sideEffectsRebuilders = [...bootstrappingFreers, ...mountingFreers].map((free) => free());\n      // 关闭沙箱\n      sandbox.inactive();\n    },\n  };\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n\n这个函数的核心逻辑如下：\n\n * 根据配置情况创建对应类型的沙箱：lose 模式创建 LegacySandbox，否则支持 Proxy API 的创建 ProxySandbox，不支持则创建 SnapshotSandbox。\n * 返回对象中包含沙箱实例，沙箱的挂载函数，沙箱的卸载函数，这实际上是对不同类型的沙箱的封装，在外层维护了 patch 的副作用和副作用的恢复。\n * 将挂载之前的阶段分成了 bootstrapping 和 mounting，这两个阶段中分别执行了一些 patch 工作，这部分之后详述。在 mount 时，将记录的所以的副作用执行，实际上是恢复上一次的 patch 的动作，在本次会重新 patch，并且在 unmount 时将 patch 记录下来。patch 的工作是一次性的。",normalizedContent:"# 目录\n\n\n\n * 目录\n * createsandboxcontainer\n\n\n\n\n# createsandboxcontainer\n\ncreatesandboxcontainer 函数创建沙箱，并且维护一些 patch 工作。\n\n// src/sandbox/index.ts\n/**\n * 生成应用运行时沙箱\n *\n * 沙箱分两个类型：\n * 1. app 环境沙箱\n *  app 环境沙箱是指应用初始化过之后，应用会在什么样的上下文环境运行。每个应用的环境沙箱只会初始化一次，因为子应用只会触发一次 bootstrap 。\n *  子应用在切换时，实际上切换的是 app 环境沙箱。\n * 2. render 沙箱\n *  子应用在 app mount 开始前生成好的的沙箱。每次子应用切换过后，render 沙箱都会重现初始化。\n *\n * 这么设计的目的是为了保证每个子应用切换回来之后，还能运行在应用 bootstrap 之后的环境下。\n *\n * @param appname\n * @param elementgetter\n * @param scopedcss\n * @param useloosesandbox\n * @param excludeassetfilter\n * @param globalcontext\n */\nexport function createsandboxcontainer(\n  appname: string,\n  // 获取待挂载元素的方法\n  elementgetter: () => htmlelement | shadowroot,\n  // 是否使用 scopedcss\n  scopedcss: boolean,\n  // 是否使用 lose mode sandbox\n  useloosesandbox?: boolean,\n  // 沙箱资源白名单\n  excludeassetfilter?: (url: string) => boolean,\n  // global env\n  globalcontext?: typeof window,\n) {\n  let sandbox: sandbox;\n  // 创建沙箱实例\n  if (window.proxy) {\n    // lose mode 使用旧版沙箱，否则使用代理沙箱\n    sandbox = useloosesandbox ? new legacysandbox(appname, globalcontext) : new proxysandbox(appname, globalcontext);\n  } else {\n    // 不支持 proxy api 则使用快照沙箱，快照沙箱不支持多应用模式\n    sandbox = new snapshotsandbox(appname);\n  }\n\n  // some side effect could be be invoked while bootstrapping, such as dynamic stylesheet injection with style-loader, especially during the development phase\n  // bootstrap 阶段的初始化工作，如动态样式表的插入，返回释放（恢复）副作用的数组\n  const bootstrappingfreers = patchatbootstrapping(appname, elementgetter, sandbox, scopedcss, excludeassetfilter);\n  // mounting freers are one-off and should be re-init at every mounting time\n  let mountingfreers: freer[] = [];\n\n  let sideeffectsrebuilders: rebuilder[] = [];\n\n  return {\n    // sandbox 实例\n    instance: sandbox,\n\n    /**\n     * 沙箱被 mount\n     * 可能是从 bootstrap 状态进入的 mount\n     * 也可能是从 unmount 之后再次唤醒进入 mount\n     */\n    async mount() {\n      /* ------------------------------------------ 因为有上下文依赖（window），以下代码执行顺序不能变 ------------------------------------------ */\n\n      /* ------------------------------------------ 1. 启动/恢复 沙箱------------------------------------------ */\n      sandbox.active();\n      // 分离出 bootstrapping 阶段和 mounting 阶段的副作用，能用 bootstrappingfreers.length 分离是因为加入 sideeffectsrebuilders 时把 bootstrappingfreers 放到了前面\n      const sideeffectsrebuildersatbootstrapping = sideeffectsrebuilders.slice(0, bootstrappingfreers.length);\n      const sideeffectsrebuildersatmounting = sideeffectsrebuilders.slice(bootstrappingfreers.length);\n\n      // must rebuild the side effects which added at bootstrapping firstly to recovery to nature state\n      // 执行 bootstrapping 阶段的副作用\n      if (sideeffectsrebuildersatbootstrapping.length) {\n        sideeffectsrebuildersatbootstrapping.foreach((rebuild) => rebuild());\n      }\n\n      /* ------------------------------------------ 2. 开启全局变量补丁 ------------------------------------------*/\n      // render 沙箱启动时开始劫持各类全局监听，尽量不要在应用初始化阶段有 事件监听/定时器 等副作用\n      // mount 阶段的 patch（初始化） 工作，如事件监听等，返回释放（恢复）副作用的数组\n      mountingfreers = patchatmounting(appname, elementgetter, sandbox, scopedcss, excludeassetfilter);\n\n      /* ------------------------------------------ 3. 重置一些初始化时的副作用 ------------------------------------------*/\n      // 存在 rebuilder 则表明有些副作用需要重建\n      // 执行 mounting 阶段的副作用\n      if (sideeffectsrebuildersatmounting.length) {\n        sideeffectsrebuildersatmounting.foreach((rebuild) => rebuild());\n      }\n\n      // clean up rebuilders\n      // 所有 mounting 和 bootstrapping 阶段副作用执行完毕，清空 sideeffectsrebuilders\n      sideeffectsrebuilders = [];\n    },\n\n    /**\n     * 恢复 global 状态，使其能回到应用加载之前的状态\n     */\n    async unmount() {\n      // record the rebuilders of window side effects (event listeners or timers)\n      // note that the frees of mounting phase are one-off as it will be re-init at next mounting\n      // 卸载时记录 bootstrapping 和 mounting 阶段的 rebuild 的副作用，以便在重新挂载时恢复到原始状态\n      // 注意：这里执行 rebuild 其实是 bootstrapping 和 mounting 阶段 patch 的 freer(恢复函数)。\n      // 注意：重新 mount 微应用时并不会重新执行 createsandboxcontainer，因为创建的 sandbox 已经在闭包之中，但是 sandbox 的 mount 函数会被重新执行。\n      sideeffectsrebuilders = [...bootstrappingfreers, ...mountingfreers].map((free) => free());\n      // 关闭沙箱\n      sandbox.inactive();\n    },\n  };\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n\n这个函数的核心逻辑如下：\n\n * 根据配置情况创建对应类型的沙箱：lose 模式创建 legacysandbox，否则支持 proxy api 的创建 proxysandbox，不支持则创建 snapshotsandbox。\n * 返回对象中包含沙箱实例，沙箱的挂载函数，沙箱的卸载函数，这实际上是对不同类型的沙箱的封装，在外层维护了 patch 的副作用和副作用的恢复。\n * 将挂载之前的阶段分成了 bootstrapping 和 mounting，这两个阶段中分别执行了一些 patch 工作，这部分之后详述。在 mount 时，将记录的所以的副作用执行，实际上是恢复上一次的 patch 的动作，在本次会重新 patch，并且在 unmount 时将 patch 记录下来。patch 的工作是一次性的。",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"proxySandbox",frontmatter:{title:"proxySandbox",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/sandbox/proxySandbox/",categories:["qiankun","sandbox"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/20.sandbox/20.proxySandbox.html",relativePath:"30.web/6.qiankun源码/20.sandbox/20.proxySandbox.md",key:"v-353fcddf",path:"/qiankun/sandbox/proxySandbox/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"ProxySandbox",slug:"proxysandbox",normalizedTitle:"proxysandbox",charIndex:17},{level:2,title:"什么是沙箱？",slug:"什么是沙箱",normalizedTitle:"什么是沙箱？",charIndex:33},{level:2,title:"代理沙箱的核心功能是什么？",slug:"代理沙箱的核心功能是什么",normalizedTitle:"代理沙箱的核心功能是什么？",charIndex:43},{level:2,title:"代理沙箱如何隔离 JS？",slug:"代理沙箱如何隔离-js",normalizedTitle:"代理沙箱如何隔离 js？",charIndex:60},{level:2,title:"代理沙箱的优点是什么？",slug:"代理沙箱的优点是什么",normalizedTitle:"代理沙箱的优点是什么？",charIndex:76},{level:2,title:"代理沙箱有哪些局限性？",slug:"代理沙箱有哪些局限性",normalizedTitle:"代理沙箱有哪些局限性？",charIndex:91},{level:2,title:"createFakeWindow",slug:"createfakewindow",normalizedTitle:"createfakewindow",charIndex:106},{level:2,title:"Proxy Handlers",slug:"proxy-handlers",normalizedTitle:"proxy handlers",charIndex:126},{level:2,title:"getTargetValue",slug:"gettargetvalue",normalizedTitle:"gettargetvalue",charIndex:144}],readingTime:{text:"10 min read",minutes:9.3,time:558e3,words:1860},headersStr:"目录 ProxySandbox 什么是沙箱？ 代理沙箱的核心功能是什么？ 代理沙箱如何隔离 JS？ 代理沙箱的优点是什么？ 代理沙箱有哪些局限性？ createFakeWindow Proxy Handlers getTargetValue",content:"# 目录\n\n\n\n * 目录\n * ProxySandbox\n * 什么是沙箱？\n * 代理沙箱的核心功能是什么？\n * 代理沙箱如何隔离 JS？\n * 代理沙箱的优点是什么？\n * 代理沙箱有哪些局限性？\n * createFakeWindow\n * Proxy Handlers\n * getTargetValue\n\n\n\n\n# ProxySandbox\n\n这部分代码很复杂，但是却是 JS 沙箱机制的核心。无论如何，读代码是最重要的，我们先来通读 ProxySandbox 部分的源码。\n\ntype FakeWindow = Window & Record<PropertyKey, any>;\n\n/**\n * fastest(at most time) unique array method\n * @see https://jsperf.com/array-filter-unique/30\n */\nfunction uniq(array: Array<string | symbol>) {\n  return array.filter(function filter(this: PropertyKey[], element) {\n    return element in this ? false : ((this as any)[element] = true);\n  }, Object.create(null));\n}\n\n// zone.js will overwrite Object.defineProperty\nconst rawObjectDefineProperty = Object.defineProperty;\n\n// who could escape the sandbox\n// 可以绕过沙箱，访问真实 globalContext 的变量\nconst variableWhiteList: PropertyKey[] = [\n  // FIXME System.js used a indirect call with eval, which would make it scope escape to global\n  // To make System.js works well, we write it back to global window temporary\n  // see https://github.com/systemjs/systemjs/blob/457f5b7e8af6bd120a279540477552a07d5de086/src/evaluate.js#L106\n  'System',\n\n  // see https://github.com/systemjs/systemjs/blob/457f5b7e8af6bd120a279540477552a07d5de086/src/instantiate.js#L357\n  '__cjsWrapper',\n];\n\n/*\n variables who are impossible to be overwrite need to be escaped from proxy sandbox for performance reasons\n这些值设置为不可修改、不可覆盖，需要绕开 ProxyWindow\n */\nconst unscopables = {\n  undefined: true,\n  Array: true,\n  Object: true,\n  String: true,\n  Boolean: true,\n  Math: true,\n  Number: true,\n  Symbol: true,\n  parseFloat: true,\n  Float32Array: true,\n  isNaN: true,\n  Infinity: true,\n  Reflect: true,\n  Float64Array: true,\n  Function: true,\n  Map: true,\n  NaN: true,\n  Promise: true,\n  Proxy: true,\n  Set: true,\n  parseInt: true,\n  requestAnimationFrame: true,\n};\n\nconst useNativeWindowForBindingsProps = new Map<PropertyKey, boolean>([\n  ['fetch', true],\n  ['mockDomAPIInBlackList', process.env.NODE_ENV === 'test'],\n]);\n\nfunction createFakeWindow(globalContext: Window) {\n  // map always has the fastest performance in has check scenario\n  // see https://jsperf.com/array-indexof-vs-set-has/23\n  // 属性描述符里有 get 的属性，Map 可以提高搜索场景的性能\n  const propertiesWithGetter = new Map<PropertyKey, boolean>();\n  const fakeWindow = {} as FakeWindow;\n\n  /*\n   copy the non-configurable property of global to fakeWindow\n   将 global 中不可配置的属性全部复制到 fakeWindow\n   see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor\n   > A property cannot be reported as non-configurable, if it does not exists as an own property of the target object or if it exists as a configurable own property of the target object.\n  //  除非属性是代理对象的自身属性，否则这个属性必须可配置\n   */\n  Object.getOwnPropertyNames(globalContext)\n    // 获取 global 中不可配置的属性\n    .filter((p) => {\n      const descriptor = Object.getOwnPropertyDescriptor(globalContext, p);\n      return !descriptor?.configurable;\n    })\n    // 下面的属性都有属性描述符且可配置\n    .forEach((p) => {\n      const descriptor = Object.getOwnPropertyDescriptor(globalContext, p);\n      if (descriptor) {\n        // 属性描述符上是否有 get\n        const hasGetter = Object.prototype.hasOwnProperty.call(descriptor, 'get');\n\n        /*\n         make top/self/window property configurable and writable, otherwise it will cause TypeError while get trap return.\n         see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/get\n         > The value reported for a property must be the same as the value of the corresponding target object property if the target object property is a non-writable, non-configurable data property.\n        //  如果要访问的代理对象的属性是不可写以及不可配置的，则返回的值必须与该代理对象属性的值相同。\n        // 引用 Window 的属性如果是不可写不可配置的，需要改成可写可配置的\n         */\n        if (\n          p === 'top' ||\n          p === 'parent' ||\n          p === 'self' ||\n          p === 'window' ||\n          (process.env.NODE_ENV === 'test' && (p === 'mockTop' || p === 'mockSafariTop'))\n        ) {\n          descriptor.configurable = true;\n          /*\n           The descriptor of window.window/window.top/window.self in Safari/FF are accessor descriptors, we need to avoid adding a data descriptor while it was\n           Example:\n            Safari/FF: Object.getOwnPropertyDescriptor(window, 'top') -> {get: function, set: undefined, enumerable: true, configurable: false}\n            Chrome: Object.getOwnPropertyDescriptor(window, 'top') -> {value: Window, writable: false, enumerable: true, configurable: false}\n           */\n          if (!hasGetter) {\n            descriptor.writable = true;\n          }\n        }\n\n        if (hasGetter) propertiesWithGetter.set(p, true);\n\n        // freeze the descriptor to avoid being modified by zone.js\n        // see https://github.com/angular/zone.js/blob/a5fe09b0fac27ac5df1fa746042f96f05ccb6a00/lib/browser/define-property.ts#L71\n        // 在 fakeWindow 定义上定义此属性，并冻结属性描述符\n        rawObjectDefineProperty(fakeWindow, p, Object.freeze(descriptor));\n      }\n    });\n\n  return {\n    fakeWindow,\n    propertiesWithGetter,\n  };\n}\n\n// count 已经同时运行的 ProxySandbox 的数量\nlet activeSandboxCount = 0;\n\n/**\n * 基于 Proxy 实现的沙箱\n */\nexport default class ProxySandbox implements SandBox {\n  /** window 值变更记录 */\n  private updatedValueSet = new Set<PropertyKey>();\n\n  name: string;\n\n  type: SandBoxType;\n\n  proxy: WindowProxy;\n\n  globalContext: typeof window;\n  // running 状态初始化为 true，即实例化成功就默认开始 running，只有 inactive 时才可能会关闭\n  sandboxRunning = true;\n\n  latestSetProp: PropertyKey | null = null;\n\n  // 设置当前正在运行的微应用\n  private registerRunningApp(name: string, proxy: Window) {\n    if (this.sandboxRunning) {\n      const currentRunningApp = getCurrentRunningApp();\n      if (!currentRunningApp || currentRunningApp.name !== name) {\n        setCurrentRunningApp({ name, window: proxy });\n      }\n      // FIXME if you have any other good ideas\n      // remove the mark in next tick, thus we can identify whether it in micro app or not\n      // this approach is just a workaround, it could not cover all complex cases, such as the micro app runs in the same task context with master in some case\n      // TODO 为什么重置？\n      nextTask(() => {\n        setCurrentRunningApp(null);\n      });\n    }\n  }\n\n  active() {\n    // 实例化时不会执行此句，只有重新开启沙箱时才加 1 ，关闭沙箱(inactive)时减 1。\n    if (!this.sandboxRunning) activeSandboxCount++;\n    this.sandboxRunning = true;\n  }\n\n  inactive() {\n    if (process.env.NODE_ENV === 'development') {\n      console.info(`[qiankun:sandbox] ${this.name} modified global properties restore...`, [\n        ...this.updatedValueSet.keys(),\n      ]);\n    }\n    // activeSandboxCount 减 1，如果没有激活的沙箱，删除 proxyWindow 中存在的白名单里的变量\n    if (--activeSandboxCount === 0) {\n      variableWhiteList.forEach((p) => {\n        if (this.proxy.hasOwnProperty(p)) {\n          // @ts-ignore\n          delete this.globalContext[p];\n        }\n      });\n    }\n\n    this.sandboxRunning = false;\n  }\n\n  constructor(name: string, globalContext = window) {\n    this.name = name;\n    this.globalContext = globalContext;\n    // 设置类型为 Proxy\n    this.type = SandBoxType.Proxy;\n    const { updatedValueSet } = this;\n    // 根据 globalContext 创建 FakeWindow\n    const { fakeWindow, propertiesWithGetter } = createFakeWindow(globalContext);\n\n    const descriptorTargetMap = new Map<PropertyKey, SymbolTarget>();\n    const hasOwnProperty = (key: PropertyKey) => fakeWindow.hasOwnProperty(key) || globalContext.hasOwnProperty(key);\n    // 创建 fakeWindow 的代理对象 proxyWindow\n    const proxy = new Proxy(fakeWindow, {\n      // 劫持 setter\n      set: (target: FakeWindow, p: PropertyKey, value: any): boolean => {\n        // 如果沙箱未激活则不劫持，unmount 之后应该不会出现这种情况\n        if (this.sandboxRunning) {\n          // 注册正在运行的微应用，因为会在 nestTick 中重置\n          this.registerRunningApp(name, proxy);\n          // We must kept its description while the property existed in globalContext before\n          // 如果 globalContext 中有这个属性而 target 中没有，需要参照其描述符\n          // 添加新属性需要参照 globalContext 添加\n          if (!target.hasOwnProperty(p) && globalContext.hasOwnProperty(p)) {\n            // 获取 globalContext 上该属性的属性描述符\n            const descriptor = Object.getOwnPropertyDescriptor(globalContext, p);\n            const { writable, configurable, enumerable } = descriptor!;\n            // 只有原属性是可写的才允许修改\n            if (writable) {\n              Object.defineProperty(target, p, {\n                configurable,\n                enumerable,\n                writable,\n                value,\n              });\n            }\n          } else {\n            // @ts-ignore\n            // globalContext 没有此属性或者 target 上已经有了这个属性\n            target[p] = value;\n          }\n          // 如果是白名单中的属性需要同时设置给 globalContext\n          if (variableWhiteList.indexOf(p) !== -1) {\n            // @ts-ignore\n            globalContext[p] = value;\n          }\n          // 将变化的属性收集到 updatedValueSet 集合\n          updatedValueSet.add(p);\n          // 设置最后一次更新的属性\n          this.latestSetProp = p;\n\n          return true;\n        }\n\n        if (process.env.NODE_ENV === 'development') {\n          console.warn(`[qiankun] Set window.${p.toString()} while sandbox destroyed or inactive in ${name}!`);\n        }\n\n        // 在 strict-mode 下，Proxy 的 handler.set 返回 false 会抛出 TypeError，在沙箱卸载的情况下应该忽略错误\n        return true;\n      },\n      // 劫持 getter\n      get: (target: FakeWindow, p: PropertyKey): any => {\n        // 注册正在运行的微应用，因为会在 nestTick 中重置\n        this.registerRunningApp(name, proxy);\n        // see https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/unscopables\n        // Symbol.unscopables 指用于指定对象值，其对象自身和继承的从关联对象的 with 环境绑定中排除的属性名称。\n        if (p === Symbol.unscopables) return unscopables;\n        // avoid who using window.window or window.self to escape the sandbox environment to touch the really window\n        // see https://github.com/eligrey/FileSaver.js/blob/master/src/FileSaver.js#L13\n        // 拦截绕过 proxyWindow 直接获取到 window 的情况\n        if (p === 'window' || p === 'self') {\n          return proxy;\n        }\n\n        // hijack globalWindow accessing with globalThis keyword\n        // 设置 globalThis 为自己\n        if (p === 'globalThis') {\n          return proxy;\n        }\n\n        if (\n          p === 'top' ||\n          p === 'parent' ||\n          (process.env.NODE_ENV === 'test' && (p === 'mockTop' || p === 'mockSafariTop'))\n        ) {\n          // if your master app in an iframe context, allow these props escape the sandbox\n          if (globalContext === globalContext.parent) {\n            return proxy;\n          }\n          // 获取 top 或者 parent 从 globalContext 上取\n          return (globalContext as any)[p];\n        }\n\n        // proxy.hasOwnProperty would invoke getter firstly, then its value represented as globalContext.hasOwnProperty\n        if (p === 'hasOwnProperty') {\n          return hasOwnProperty;\n        }\n\n        if (p === 'document') {\n          return document;\n        }\n\n        if (p === 'eval') {\n          return eval;\n        }\n        // 如果属性描述符里有 get 就在 globalContext 中找，否则在 ProxyWindow 上找，找不到再在 globalContext 找\n        const value = propertiesWithGetter.has(p)\n          ? (globalContext as any)[p]\n          : p in target\n          ? (target as any)[p]\n          : (globalContext as any)[p];\n        /* Some dom api must be bound to native window, otherwise it would cause exception like 'TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation'\n           See this code:\n             const proxy = new Proxy(window, {});\n             const proxyFetch = fetch.bind(proxy);\n             proxyFetch('https://qiankun.com');\n        */\n        //  有些 DOM API 必须要使用原生的 window。\n        const boundTarget = useNativeWindowForBindingsProps.get(p) ? nativeGlobal : globalContext;\n        // 根据 boundTarget scope 和 value 计算最终的值\n        return getTargetValue(boundTarget, value);\n      },\n\n      // trap in operator\n      // see https://github.com/styled-components/styled-components/blob/master/packages/styled-components/src/constants.js#L12\n      has(target: FakeWindow, p: string | number | symbol): boolean {\n        return p in unscopables || p in target || p in globalContext;\n      },\n\n      getOwnPropertyDescriptor(target: FakeWindow, p: string | number | symbol): PropertyDescriptor | undefined {\n        /*\n         as the descriptor of top/self/window/mockTop in raw window are configurable but not in proxy target, we need to get it from target to avoid TypeError\n         see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor\n         > A property cannot be reported as non-configurable, if it does not exists as an own property of the target object or if it exists as a configurable own property of the target object.\n         */\n        if (target.hasOwnProperty(p)) {\n          const descriptor = Object.getOwnPropertyDescriptor(target, p);\n          descriptorTargetMap.set(p, 'target');\n          return descriptor;\n        }\n\n        if (globalContext.hasOwnProperty(p)) {\n          const descriptor = Object.getOwnPropertyDescriptor(globalContext, p);\n          descriptorTargetMap.set(p, 'globalContext');\n          // A property cannot be reported as non-configurable, if it does not exists as an own property of the target object\n          if (descriptor && !descriptor.configurable) {\n            descriptor.configurable = true;\n          }\n          return descriptor;\n        }\n\n        return undefined;\n      },\n\n      // trap to support iterator with sandbox\n      ownKeys(target: FakeWindow): ArrayLike<string | symbol> {\n        // 将 target 和 globalContext 的 keys 合起来并且去重\n        return uniq(Reflect.ownKeys(globalContext).concat(Reflect.ownKeys(target)));\n      },\n      // the defineProperty and getOwnPropertyDescriptor proxy traps are called when either setting or getting a property descriptor of an object.\n      defineProperty(target: Window, p: PropertyKey, attributes: PropertyDescriptor): boolean {\n        const from = descriptorTargetMap.get(p);\n        /*\n         Descriptor must be defined to native window while it comes from native window via Object.getOwnPropertyDescriptor(window, p),\n         otherwise it would cause a TypeError with illegal invocation.\n         */\n        switch (from) {\n          case 'globalContext':\n            // 如果缓存中已知此描述符在 globalContext 中，则在 globalContext 中定义描述符\n            return Reflect.defineProperty(globalContext, p, attributes);\n          default:\n            return Reflect.defineProperty(target, p, attributes);\n        }\n      },\n\n      deleteProperty: (target: FakeWindow, p: string | number | symbol): boolean => {\n        this.registerRunningApp(name, proxy);\n        if (target.hasOwnProperty(p)) {\n          // @ts-ignore\n          delete target[p];\n          // 属性已经被删除，不用再关注其更新，从更新属性集合中删除\n          updatedValueSet.delete(p);\n\n          return true;\n        }\n\n        return true;\n      },\n\n      // makes sure `window instanceof Window` returns truthy in micro app\n      getPrototypeOf() {\n        // 将 ProxyWindow 的原型从 globalContext 中获取，以伪装成 Window\n        return Reflect.getPrototypeOf(globalContext);\n      },\n    });\n\n    this.proxy = proxy;\n    // 注意：这里并非在 active 中计数，而是在实例化时计数\n    activeSandboxCount++;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n\n\n读完了代码，我们可能从整体上对代理沙箱有了一些了解。现在我们从整体到细节重新分析一下这里的内容。\n\n\n# 什么是沙箱？\n\n> 百度百科： Sandboxie (又叫沙箱、沙盘) 即是一个虚拟系统程序，允许你在沙盘环境中运行浏览器或其他程序，因此运行所产生的变化可以随后删除。它创造了一个类似沙盒的独立作业环境，在其内部运行的程序并不能对硬盘产生永久性的影响。 在网络安全中，沙箱指在隔离环境中，用以测试不受信任的文件或应用程序等行为的工具。\n\n关键特性：\n\n * 虚拟、独立的作业环境\n * 隔离外界、变化可控\n * 可控的通信机制\n\nJS 沙箱：\n\n在这里沙箱并且传统意思上、安全意义上的沙箱。JS 沙箱中运行微应用的代码，使内部和外部的代码不会相互影响，产生一些变量冲突、环境污染的问题，沙箱内部的代码的执行权限是可控的，是独立运行的。沙箱之间，沙箱与主应用之间可以通过么某些可控的通讯机制进行通信。通常使用闭包结合 DI 注入依赖模块就可以模拟最简单的 JS 沙箱环境和沙箱通信机制。\n\nSandBox 接口：\n\nexport type SandBox = {\n  /** 沙箱的名字 */\n  name: string;\n  /** 沙箱的类型 */\n  type: SandBoxType;\n  /** 沙箱导出的代理实体 */\n  proxy: WindowProxy;\n  /** 沙箱是否在运行中 */\n  sandboxRunning: boolean;\n  /** latest set property */\n  latestSetProp?: PropertyKey | null;\n  /** 启动沙箱 */\n  active: () => void;\n  /** 关闭沙箱 */\n  inactive: () => void;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 代理沙箱的核心功能是什么？\n\n分析如上的代码，可知：\n\n * inactive、active：控制沙箱是否开启，并且在所以沙箱均关闭时执行某些清理工作。variableWhiteList 中的 set 操作会更改 globalContext，所以将 globalContext 中的这些属性删除。要到所有沙箱都关闭再删除，是因为无法确定到具体是哪个沙箱做的更改，而且这种做法也无损性能。\n * ProxySandbox 的构造器中调用 createFakeWindow 利用 globalContext 创建出 fakeWindow。然后使用 Proxy API 对 fakeWindow 进行代理，创建 ProxyWindow。\n\n综上，可以总结出代理沙箱的核心功能如下：\n\n * createFakeWindow：伪造一个 Window 全局对象。\n * ProxyWindow：使用 ProxyWindow 代理微应用中对 Window 全局对象的各种操作。\n\nProxyWindow 中 Proxy Handlers 都在做什么？\n\n从整体上来看，JS 沙箱的作用就是保证代码执行的隔离性，而 ProxyWindow 已经能够保证这种隔离性，因此 Handler 中并没有像 VUE3 中 Proxy 有那么多的功能性，如收集 effect 或者触发 effect 消费，在 ProxyWindow 中更重要的是保证代码的全局对象的功能正确，规避错误，同时保证代码的安全性。所以可以总结出 Proxy Handlers 主要任务:\n\n * 功能性、兼容性\n * 容错性（规避错误）\n * 安全性（代码安全）\n\n\n# 代理沙箱如何隔离 JS？\n\n从上面核心功能的分析中，我们已经知道了根据 globalContext 创建的代理对象 ProxyWindow 会代理和劫持 js 代码对 globalContext 的各种操作。 结合 loadApp 中如下代码：\n\nglobal = sandboxContainer.instance.proxy as typeof window;\n\n\n1\n\n\n之后这个伪造的 global 参与了 loadApp 中余下的需要访问全局对象的代码，如: getAddOns、execHooksChain、execScripts、getLifecyclesFromExports 等。参加：loadApp 加载微应用。\n\ngetAddOns、execHooksChain 分别对应着微应用在插件中使用的和用户传入的生命周期的全局对象，这保证了在微应用的生命周期中对于全局对象的访问都是受代理的。\n\nexecScripts 则保证微应用模板中运行时的 js 使用的全局对象和受代理的全局对象。\n\nconst scriptExports: any = await execScripts(global, sandbox && !useLooseSandbox);\n\n\n1\n\n\nexecScripts 接受 global 为沙箱，从如下 import-html-entry 的源码中可以看出，微应用的代码是在 window.proxy 的环境下执行的。因此，getLifecyclesFromExports 才会从已经注入的 global 中取微应用的 mount/unmount/update/bootstrap 等生命周期。\n\n> proxy - Window - required, Window or proxy window.\n\n// https://github.com/kuitos/import-html-entry/blob/master/src/index.js#L54\n\nfunction getExecutableScript(scriptSrc, scriptText, proxy, strictGlobal) {\n  const sourceUrl = isInlineCode(scriptSrc)\n    ? \"\"\n    : `//# sourceURL=${scriptSrc}\\n`;\n\n  // 通过这种方式获取全局 window，因为 script 也是在全局作用域下运行的，所以我们通过 window.proxy 绑定时也必须确保绑定到全局 window 上\n  // 否则在嵌套场景下， window.proxy 设置的是内层应用的 window，而代码其实是在全局作用域运行的，会导致闭包里的 window.proxy 取的是最外层的微应用的 proxy\n  const globalWindow = (0, eval)(\"window\");\n  globalWindow.proxy = proxy;\n  // TODO 通过 strictGlobal 方式切换 with 闭包，待 with 方式坑趟平后再合并\n  return strictGlobal\n    ? `;(function(window, self, globalThis){with(window){;${scriptText}\\n${sourceUrl}}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`\n    : `;(function(window, self, globalThis){;${scriptText}\\n${sourceUrl}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 代理沙箱的优点是什么？\n\n代理沙箱有如下的优点：\n\n * 支持多应用实例。\n\n\n# 代理沙箱有哪些局限性？\n\n代理沙箱有如下的局限性：\n\n * 兼容性问题：旧版浏览器不支持 Proxy API。\n\n上面我们从整体上把握了 ProxySandbox 的原理，现在我们来深入了解一些更细节的内容。\n\n\n# createFakeWindow\n\n\n# Proxy Handlers\n\n\n# getTargetValue",normalizedContent:"# 目录\n\n\n\n * 目录\n * proxysandbox\n * 什么是沙箱？\n * 代理沙箱的核心功能是什么？\n * 代理沙箱如何隔离 js？\n * 代理沙箱的优点是什么？\n * 代理沙箱有哪些局限性？\n * createfakewindow\n * proxy handlers\n * gettargetvalue\n\n\n\n\n# proxysandbox\n\n这部分代码很复杂，但是却是 js 沙箱机制的核心。无论如何，读代码是最重要的，我们先来通读 proxysandbox 部分的源码。\n\ntype fakewindow = window & record<propertykey, any>;\n\n/**\n * fastest(at most time) unique array method\n * @see https://jsperf.com/array-filter-unique/30\n */\nfunction uniq(array: array<string | symbol>) {\n  return array.filter(function filter(this: propertykey[], element) {\n    return element in this ? false : ((this as any)[element] = true);\n  }, object.create(null));\n}\n\n// zone.js will overwrite object.defineproperty\nconst rawobjectdefineproperty = object.defineproperty;\n\n// who could escape the sandbox\n// 可以绕过沙箱，访问真实 globalcontext 的变量\nconst variablewhitelist: propertykey[] = [\n  // fixme system.js used a indirect call with eval, which would make it scope escape to global\n  // to make system.js works well, we write it back to global window temporary\n  // see https://github.com/systemjs/systemjs/blob/457f5b7e8af6bd120a279540477552a07d5de086/src/evaluate.js#l106\n  'system',\n\n  // see https://github.com/systemjs/systemjs/blob/457f5b7e8af6bd120a279540477552a07d5de086/src/instantiate.js#l357\n  '__cjswrapper',\n];\n\n/*\n variables who are impossible to be overwrite need to be escaped from proxy sandbox for performance reasons\n这些值设置为不可修改、不可覆盖，需要绕开 proxywindow\n */\nconst unscopables = {\n  undefined: true,\n  array: true,\n  object: true,\n  string: true,\n  boolean: true,\n  math: true,\n  number: true,\n  symbol: true,\n  parsefloat: true,\n  float32array: true,\n  isnan: true,\n  infinity: true,\n  reflect: true,\n  float64array: true,\n  function: true,\n  map: true,\n  nan: true,\n  promise: true,\n  proxy: true,\n  set: true,\n  parseint: true,\n  requestanimationframe: true,\n};\n\nconst usenativewindowforbindingsprops = new map<propertykey, boolean>([\n  ['fetch', true],\n  ['mockdomapiinblacklist', process.env.node_env === 'test'],\n]);\n\nfunction createfakewindow(globalcontext: window) {\n  // map always has the fastest performance in has check scenario\n  // see https://jsperf.com/array-indexof-vs-set-has/23\n  // 属性描述符里有 get 的属性，map 可以提高搜索场景的性能\n  const propertieswithgetter = new map<propertykey, boolean>();\n  const fakewindow = {} as fakewindow;\n\n  /*\n   copy the non-configurable property of global to fakewindow\n   将 global 中不可配置的属性全部复制到 fakewindow\n   see https://developer.mozilla.org/en-us/docs/web/javascript/reference/global_objects/proxy/handler/getownpropertydescriptor\n   > a property cannot be reported as non-configurable, if it does not exists as an own property of the target object or if it exists as a configurable own property of the target object.\n  //  除非属性是代理对象的自身属性，否则这个属性必须可配置\n   */\n  object.getownpropertynames(globalcontext)\n    // 获取 global 中不可配置的属性\n    .filter((p) => {\n      const descriptor = object.getownpropertydescriptor(globalcontext, p);\n      return !descriptor?.configurable;\n    })\n    // 下面的属性都有属性描述符且可配置\n    .foreach((p) => {\n      const descriptor = object.getownpropertydescriptor(globalcontext, p);\n      if (descriptor) {\n        // 属性描述符上是否有 get\n        const hasgetter = object.prototype.hasownproperty.call(descriptor, 'get');\n\n        /*\n         make top/self/window property configurable and writable, otherwise it will cause typeerror while get trap return.\n         see https://developer.mozilla.org/en-us/docs/web/javascript/reference/global_objects/proxy/handler/get\n         > the value reported for a property must be the same as the value of the corresponding target object property if the target object property is a non-writable, non-configurable data property.\n        //  如果要访问的代理对象的属性是不可写以及不可配置的，则返回的值必须与该代理对象属性的值相同。\n        // 引用 window 的属性如果是不可写不可配置的，需要改成可写可配置的\n         */\n        if (\n          p === 'top' ||\n          p === 'parent' ||\n          p === 'self' ||\n          p === 'window' ||\n          (process.env.node_env === 'test' && (p === 'mocktop' || p === 'mocksafaritop'))\n        ) {\n          descriptor.configurable = true;\n          /*\n           the descriptor of window.window/window.top/window.self in safari/ff are accessor descriptors, we need to avoid adding a data descriptor while it was\n           example:\n            safari/ff: object.getownpropertydescriptor(window, 'top') -> {get: function, set: undefined, enumerable: true, configurable: false}\n            chrome: object.getownpropertydescriptor(window, 'top') -> {value: window, writable: false, enumerable: true, configurable: false}\n           */\n          if (!hasgetter) {\n            descriptor.writable = true;\n          }\n        }\n\n        if (hasgetter) propertieswithgetter.set(p, true);\n\n        // freeze the descriptor to avoid being modified by zone.js\n        // see https://github.com/angular/zone.js/blob/a5fe09b0fac27ac5df1fa746042f96f05ccb6a00/lib/browser/define-property.ts#l71\n        // 在 fakewindow 定义上定义此属性，并冻结属性描述符\n        rawobjectdefineproperty(fakewindow, p, object.freeze(descriptor));\n      }\n    });\n\n  return {\n    fakewindow,\n    propertieswithgetter,\n  };\n}\n\n// count 已经同时运行的 proxysandbox 的数量\nlet activesandboxcount = 0;\n\n/**\n * 基于 proxy 实现的沙箱\n */\nexport default class proxysandbox implements sandbox {\n  /** window 值变更记录 */\n  private updatedvalueset = new set<propertykey>();\n\n  name: string;\n\n  type: sandboxtype;\n\n  proxy: windowproxy;\n\n  globalcontext: typeof window;\n  // running 状态初始化为 true，即实例化成功就默认开始 running，只有 inactive 时才可能会关闭\n  sandboxrunning = true;\n\n  latestsetprop: propertykey | null = null;\n\n  // 设置当前正在运行的微应用\n  private registerrunningapp(name: string, proxy: window) {\n    if (this.sandboxrunning) {\n      const currentrunningapp = getcurrentrunningapp();\n      if (!currentrunningapp || currentrunningapp.name !== name) {\n        setcurrentrunningapp({ name, window: proxy });\n      }\n      // fixme if you have any other good ideas\n      // remove the mark in next tick, thus we can identify whether it in micro app or not\n      // this approach is just a workaround, it could not cover all complex cases, such as the micro app runs in the same task context with master in some case\n      // todo 为什么重置？\n      nexttask(() => {\n        setcurrentrunningapp(null);\n      });\n    }\n  }\n\n  active() {\n    // 实例化时不会执行此句，只有重新开启沙箱时才加 1 ，关闭沙箱(inactive)时减 1。\n    if (!this.sandboxrunning) activesandboxcount++;\n    this.sandboxrunning = true;\n  }\n\n  inactive() {\n    if (process.env.node_env === 'development') {\n      console.info(`[qiankun:sandbox] ${this.name} modified global properties restore...`, [\n        ...this.updatedvalueset.keys(),\n      ]);\n    }\n    // activesandboxcount 减 1，如果没有激活的沙箱，删除 proxywindow 中存在的白名单里的变量\n    if (--activesandboxcount === 0) {\n      variablewhitelist.foreach((p) => {\n        if (this.proxy.hasownproperty(p)) {\n          // @ts-ignore\n          delete this.globalcontext[p];\n        }\n      });\n    }\n\n    this.sandboxrunning = false;\n  }\n\n  constructor(name: string, globalcontext = window) {\n    this.name = name;\n    this.globalcontext = globalcontext;\n    // 设置类型为 proxy\n    this.type = sandboxtype.proxy;\n    const { updatedvalueset } = this;\n    // 根据 globalcontext 创建 fakewindow\n    const { fakewindow, propertieswithgetter } = createfakewindow(globalcontext);\n\n    const descriptortargetmap = new map<propertykey, symboltarget>();\n    const hasownproperty = (key: propertykey) => fakewindow.hasownproperty(key) || globalcontext.hasownproperty(key);\n    // 创建 fakewindow 的代理对象 proxywindow\n    const proxy = new proxy(fakewindow, {\n      // 劫持 setter\n      set: (target: fakewindow, p: propertykey, value: any): boolean => {\n        // 如果沙箱未激活则不劫持，unmount 之后应该不会出现这种情况\n        if (this.sandboxrunning) {\n          // 注册正在运行的微应用，因为会在 nesttick 中重置\n          this.registerrunningapp(name, proxy);\n          // we must kept its description while the property existed in globalcontext before\n          // 如果 globalcontext 中有这个属性而 target 中没有，需要参照其描述符\n          // 添加新属性需要参照 globalcontext 添加\n          if (!target.hasownproperty(p) && globalcontext.hasownproperty(p)) {\n            // 获取 globalcontext 上该属性的属性描述符\n            const descriptor = object.getownpropertydescriptor(globalcontext, p);\n            const { writable, configurable, enumerable } = descriptor!;\n            // 只有原属性是可写的才允许修改\n            if (writable) {\n              object.defineproperty(target, p, {\n                configurable,\n                enumerable,\n                writable,\n                value,\n              });\n            }\n          } else {\n            // @ts-ignore\n            // globalcontext 没有此属性或者 target 上已经有了这个属性\n            target[p] = value;\n          }\n          // 如果是白名单中的属性需要同时设置给 globalcontext\n          if (variablewhitelist.indexof(p) !== -1) {\n            // @ts-ignore\n            globalcontext[p] = value;\n          }\n          // 将变化的属性收集到 updatedvalueset 集合\n          updatedvalueset.add(p);\n          // 设置最后一次更新的属性\n          this.latestsetprop = p;\n\n          return true;\n        }\n\n        if (process.env.node_env === 'development') {\n          console.warn(`[qiankun] set window.${p.tostring()} while sandbox destroyed or inactive in ${name}!`);\n        }\n\n        // 在 strict-mode 下，proxy 的 handler.set 返回 false 会抛出 typeerror，在沙箱卸载的情况下应该忽略错误\n        return true;\n      },\n      // 劫持 getter\n      get: (target: fakewindow, p: propertykey): any => {\n        // 注册正在运行的微应用，因为会在 nesttick 中重置\n        this.registerrunningapp(name, proxy);\n        // see https://developer.mozilla.org/zh-cn/docs/web/javascript/reference/global_objects/symbol/unscopables\n        // symbol.unscopables 指用于指定对象值，其对象自身和继承的从关联对象的 with 环境绑定中排除的属性名称。\n        if (p === symbol.unscopables) return unscopables;\n        // avoid who using window.window or window.self to escape the sandbox environment to touch the really window\n        // see https://github.com/eligrey/filesaver.js/blob/master/src/filesaver.js#l13\n        // 拦截绕过 proxywindow 直接获取到 window 的情况\n        if (p === 'window' || p === 'self') {\n          return proxy;\n        }\n\n        // hijack globalwindow accessing with globalthis keyword\n        // 设置 globalthis 为自己\n        if (p === 'globalthis') {\n          return proxy;\n        }\n\n        if (\n          p === 'top' ||\n          p === 'parent' ||\n          (process.env.node_env === 'test' && (p === 'mocktop' || p === 'mocksafaritop'))\n        ) {\n          // if your master app in an iframe context, allow these props escape the sandbox\n          if (globalcontext === globalcontext.parent) {\n            return proxy;\n          }\n          // 获取 top 或者 parent 从 globalcontext 上取\n          return (globalcontext as any)[p];\n        }\n\n        // proxy.hasownproperty would invoke getter firstly, then its value represented as globalcontext.hasownproperty\n        if (p === 'hasownproperty') {\n          return hasownproperty;\n        }\n\n        if (p === 'document') {\n          return document;\n        }\n\n        if (p === 'eval') {\n          return eval;\n        }\n        // 如果属性描述符里有 get 就在 globalcontext 中找，否则在 proxywindow 上找，找不到再在 globalcontext 找\n        const value = propertieswithgetter.has(p)\n          ? (globalcontext as any)[p]\n          : p in target\n          ? (target as any)[p]\n          : (globalcontext as any)[p];\n        /* some dom api must be bound to native window, otherwise it would cause exception like 'typeerror: failed to execute 'fetch' on 'window': illegal invocation'\n           see this code:\n             const proxy = new proxy(window, {});\n             const proxyfetch = fetch.bind(proxy);\n             proxyfetch('https://qiankun.com');\n        */\n        //  有些 dom api 必须要使用原生的 window。\n        const boundtarget = usenativewindowforbindingsprops.get(p) ? nativeglobal : globalcontext;\n        // 根据 boundtarget scope 和 value 计算最终的值\n        return gettargetvalue(boundtarget, value);\n      },\n\n      // trap in operator\n      // see https://github.com/styled-components/styled-components/blob/master/packages/styled-components/src/constants.js#l12\n      has(target: fakewindow, p: string | number | symbol): boolean {\n        return p in unscopables || p in target || p in globalcontext;\n      },\n\n      getownpropertydescriptor(target: fakewindow, p: string | number | symbol): propertydescriptor | undefined {\n        /*\n         as the descriptor of top/self/window/mocktop in raw window are configurable but not in proxy target, we need to get it from target to avoid typeerror\n         see https://developer.mozilla.org/en-us/docs/web/javascript/reference/global_objects/proxy/handler/getownpropertydescriptor\n         > a property cannot be reported as non-configurable, if it does not exists as an own property of the target object or if it exists as a configurable own property of the target object.\n         */\n        if (target.hasownproperty(p)) {\n          const descriptor = object.getownpropertydescriptor(target, p);\n          descriptortargetmap.set(p, 'target');\n          return descriptor;\n        }\n\n        if (globalcontext.hasownproperty(p)) {\n          const descriptor = object.getownpropertydescriptor(globalcontext, p);\n          descriptortargetmap.set(p, 'globalcontext');\n          // a property cannot be reported as non-configurable, if it does not exists as an own property of the target object\n          if (descriptor && !descriptor.configurable) {\n            descriptor.configurable = true;\n          }\n          return descriptor;\n        }\n\n        return undefined;\n      },\n\n      // trap to support iterator with sandbox\n      ownkeys(target: fakewindow): arraylike<string | symbol> {\n        // 将 target 和 globalcontext 的 keys 合起来并且去重\n        return uniq(reflect.ownkeys(globalcontext).concat(reflect.ownkeys(target)));\n      },\n      // the defineproperty and getownpropertydescriptor proxy traps are called when either setting or getting a property descriptor of an object.\n      defineproperty(target: window, p: propertykey, attributes: propertydescriptor): boolean {\n        const from = descriptortargetmap.get(p);\n        /*\n         descriptor must be defined to native window while it comes from native window via object.getownpropertydescriptor(window, p),\n         otherwise it would cause a typeerror with illegal invocation.\n         */\n        switch (from) {\n          case 'globalcontext':\n            // 如果缓存中已知此描述符在 globalcontext 中，则在 globalcontext 中定义描述符\n            return reflect.defineproperty(globalcontext, p, attributes);\n          default:\n            return reflect.defineproperty(target, p, attributes);\n        }\n      },\n\n      deleteproperty: (target: fakewindow, p: string | number | symbol): boolean => {\n        this.registerrunningapp(name, proxy);\n        if (target.hasownproperty(p)) {\n          // @ts-ignore\n          delete target[p];\n          // 属性已经被删除，不用再关注其更新，从更新属性集合中删除\n          updatedvalueset.delete(p);\n\n          return true;\n        }\n\n        return true;\n      },\n\n      // makes sure `window instanceof window` returns truthy in micro app\n      getprototypeof() {\n        // 将 proxywindow 的原型从 globalcontext 中获取，以伪装成 window\n        return reflect.getprototypeof(globalcontext);\n      },\n    });\n\n    this.proxy = proxy;\n    // 注意：这里并非在 active 中计数，而是在实例化时计数\n    activesandboxcount++;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n\n\n读完了代码，我们可能从整体上对代理沙箱有了一些了解。现在我们从整体到细节重新分析一下这里的内容。\n\n\n# 什么是沙箱？\n\n> 百度百科： sandboxie (又叫沙箱、沙盘) 即是一个虚拟系统程序，允许你在沙盘环境中运行浏览器或其他程序，因此运行所产生的变化可以随后删除。它创造了一个类似沙盒的独立作业环境，在其内部运行的程序并不能对硬盘产生永久性的影响。 在网络安全中，沙箱指在隔离环境中，用以测试不受信任的文件或应用程序等行为的工具。\n\n关键特性：\n\n * 虚拟、独立的作业环境\n * 隔离外界、变化可控\n * 可控的通信机制\n\njs 沙箱：\n\n在这里沙箱并且传统意思上、安全意义上的沙箱。js 沙箱中运行微应用的代码，使内部和外部的代码不会相互影响，产生一些变量冲突、环境污染的问题，沙箱内部的代码的执行权限是可控的，是独立运行的。沙箱之间，沙箱与主应用之间可以通过么某些可控的通讯机制进行通信。通常使用闭包结合 di 注入依赖模块就可以模拟最简单的 js 沙箱环境和沙箱通信机制。\n\nsandbox 接口：\n\nexport type sandbox = {\n  /** 沙箱的名字 */\n  name: string;\n  /** 沙箱的类型 */\n  type: sandboxtype;\n  /** 沙箱导出的代理实体 */\n  proxy: windowproxy;\n  /** 沙箱是否在运行中 */\n  sandboxrunning: boolean;\n  /** latest set property */\n  latestsetprop?: propertykey | null;\n  /** 启动沙箱 */\n  active: () => void;\n  /** 关闭沙箱 */\n  inactive: () => void;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 代理沙箱的核心功能是什么？\n\n分析如上的代码，可知：\n\n * inactive、active：控制沙箱是否开启，并且在所以沙箱均关闭时执行某些清理工作。variablewhitelist 中的 set 操作会更改 globalcontext，所以将 globalcontext 中的这些属性删除。要到所有沙箱都关闭再删除，是因为无法确定到具体是哪个沙箱做的更改，而且这种做法也无损性能。\n * proxysandbox 的构造器中调用 createfakewindow 利用 globalcontext 创建出 fakewindow。然后使用 proxy api 对 fakewindow 进行代理，创建 proxywindow。\n\n综上，可以总结出代理沙箱的核心功能如下：\n\n * createfakewindow：伪造一个 window 全局对象。\n * proxywindow：使用 proxywindow 代理微应用中对 window 全局对象的各种操作。\n\nproxywindow 中 proxy handlers 都在做什么？\n\n从整体上来看，js 沙箱的作用就是保证代码执行的隔离性，而 proxywindow 已经能够保证这种隔离性，因此 handler 中并没有像 vue3 中 proxy 有那么多的功能性，如收集 effect 或者触发 effect 消费，在 proxywindow 中更重要的是保证代码的全局对象的功能正确，规避错误，同时保证代码的安全性。所以可以总结出 proxy handlers 主要任务:\n\n * 功能性、兼容性\n * 容错性（规避错误）\n * 安全性（代码安全）\n\n\n# 代理沙箱如何隔离 js？\n\n从上面核心功能的分析中，我们已经知道了根据 globalcontext 创建的代理对象 proxywindow 会代理和劫持 js 代码对 globalcontext 的各种操作。 结合 loadapp 中如下代码：\n\nglobal = sandboxcontainer.instance.proxy as typeof window;\n\n\n1\n\n\n之后这个伪造的 global 参与了 loadapp 中余下的需要访问全局对象的代码，如: getaddons、exechookschain、execscripts、getlifecyclesfromexports 等。参加：loadapp 加载微应用。\n\ngetaddons、exechookschain 分别对应着微应用在插件中使用的和用户传入的生命周期的全局对象，这保证了在微应用的生命周期中对于全局对象的访问都是受代理的。\n\nexecscripts 则保证微应用模板中运行时的 js 使用的全局对象和受代理的全局对象。\n\nconst scriptexports: any = await execscripts(global, sandbox && !useloosesandbox);\n\n\n1\n\n\nexecscripts 接受 global 为沙箱，从如下 import-html-entry 的源码中可以看出，微应用的代码是在 window.proxy 的环境下执行的。因此，getlifecyclesfromexports 才会从已经注入的 global 中取微应用的 mount/unmount/update/bootstrap 等生命周期。\n\n> proxy - window - required, window or proxy window.\n\n// https://github.com/kuitos/import-html-entry/blob/master/src/index.js#l54\n\nfunction getexecutablescript(scriptsrc, scripttext, proxy, strictglobal) {\n  const sourceurl = isinlinecode(scriptsrc)\n    ? \"\"\n    : `//# sourceurl=${scriptsrc}\\n`;\n\n  // 通过这种方式获取全局 window，因为 script 也是在全局作用域下运行的，所以我们通过 window.proxy 绑定时也必须确保绑定到全局 window 上\n  // 否则在嵌套场景下， window.proxy 设置的是内层应用的 window，而代码其实是在全局作用域运行的，会导致闭包里的 window.proxy 取的是最外层的微应用的 proxy\n  const globalwindow = (0, eval)(\"window\");\n  globalwindow.proxy = proxy;\n  // todo 通过 strictglobal 方式切换 with 闭包，待 with 方式坑趟平后再合并\n  return strictglobal\n    ? `;(function(window, self, globalthis){with(window){;${scripttext}\\n${sourceurl}}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`\n    : `;(function(window, self, globalthis){;${scripttext}\\n${sourceurl}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 代理沙箱的优点是什么？\n\n代理沙箱有如下的优点：\n\n * 支持多应用实例。\n\n\n# 代理沙箱有哪些局限性？\n\n代理沙箱有如下的局限性：\n\n * 兼容性问题：旧版浏览器不支持 proxy api。\n\n上面我们从整体上把握了 proxysandbox 的原理，现在我们来深入了解一些更细节的内容。\n\n\n# createfakewindow\n\n\n# proxy handlers\n\n\n# gettargetvalue",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"snapshotSandbox",frontmatter:{title:"snapshotSandbox",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/sandbox/snapshotSandbox/",categories:["qiankun","sandbox"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/20.sandbox/30.snapshotSandbox.html",relativePath:"30.web/6.qiankun源码/20.sandbox/30.snapshotSandbox.md",key:"v-33490a39",path:"/qiankun/sandbox/snapshotSandbox/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"SnapshotSandbox",slug:"snapshotsandbox",normalizedTitle:"snapshotsandbox",charIndex:17},{level:2,title:"快照沙箱的核心功能是什么？",slug:"快照沙箱的核心功能是什么",normalizedTitle:"快照沙箱的核心功能是什么？",charIndex:36},{level:2,title:"快照沙箱如何隔离 JS？",slug:"快照沙箱如何隔离-js",normalizedTitle:"快照沙箱如何隔离 js？",charIndex:53},{level:2,title:"优点",slug:"优点",normalizedTitle:"优点",charIndex:69},{level:2,title:"缺点",slug:"缺点",normalizedTitle:"缺点",charIndex:75}],readingTime:{text:"2 min read",minutes:1.14,time:68399.99999999999,words:228},headersStr:"目录 SnapshotSandbox 快照沙箱的核心功能是什么？ 快照沙箱如何隔离 JS？ 优点 缺点",content:"# 目录\n\n\n\n * 目录\n * SnapshotSandbox\n * 快照沙箱的核心功能是什么？\n * 快照沙箱如何隔离 JS？\n * 优点\n * 缺点\n\n\n\n\n# SnapshotSandbox\n\n快照沙箱较为简单，这种基于快照机制的沙箱有很大的局限性就是不能同时多个沙箱同时打快照，不然就会混乱，因为快照是直接基于 window 的。代码如下：\n\nfunction iter(obj: typeof window, callbackFn: (prop: any) => void) {\n  // eslint-disable-next-line guard-for-in, no-restricted-syntax\n  for (const prop in obj) {\n    // patch for clearInterval for compatible reason, see #1490\n    if (obj.hasOwnProperty(prop) || prop === 'clearInterval') {\n      callbackFn(prop);\n    }\n  }\n}\n\n/**\n * 基于 diff 方式实现的沙箱，用于不支持 Proxy 的低版本浏览器\n */\nexport default class SnapshotSandbox implements SandBox {\n  proxy: WindowProxy;\n\n  name: string;\n\n  type: SandBoxType;\n\n  sandboxRunning = true;\n\n  private windowSnapshot!: Window;\n\n  private modifyPropsMap: Record<any, any> = {};\n\n  constructor(name: string) {\n    this.name = name;\n    // 基于快照的实现，直接使用 window\n    this.proxy = window;\n    this.type = SandBoxType.Snapshot;\n  }\n\n  active() {\n    // 记录当前快照\n    this.windowSnapshot = {} as Window;\n    // 将 window 上的属性克隆到 windowSnapshot\n    iter(window, (prop) => {\n      this.windowSnapshot[prop] = window[prop];\n    });\n\n    // 恢复之前的变更\n    Object.keys(this.modifyPropsMap).forEach((p: any) => {\n      window[p] = this.modifyPropsMap[p];\n    });\n\n    this.sandboxRunning = true;\n  }\n\n  inactive() {\n    // 先清空 modifyPropsMap，理论上在 active 时已经被消费\n    this.modifyPropsMap = {};\n    // 如果 window 上的属性和快照上的属性不一致，说明在沙箱中有修改，在 modifyPropsMap 保存这个宝盖以便在重新启动沙箱时恢复，同时将 window 重置为快照的状态\n    iter(window, (prop) => {\n      if (window[prop] !== this.windowSnapshot[prop]) {\n        // 记录变更，恢复环境\n        this.modifyPropsMap[prop] = window[prop];\n        window[prop] = this.windowSnapshot[prop];\n      }\n    });\n\n    this.sandboxRunning = false;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n\n# 快照沙箱的核心功能是什么？\n\n快照沙箱有两个主要的任务，一是关闭沙箱时将 window 从快照恢复，二是重新开启沙箱时从缓存恢复上次的沙箱状态。\n\n * 关闭沙箱时将 window 从快照恢复\n * 重新开启沙箱时从缓存恢复上次的沙箱状态\n\n\n# 快照沙箱如何隔离 JS？\n\n快照沙箱在关闭时会将 window 与开启沙箱时的快照进行 diff，并且恢复到快照状态下的 window。\n\n\n# 优点\n\n快照沙箱有如下优点：\n\n * 原理简单。\n * 兼容性很好，几乎所有浏览器都支持。\n\n\n# 缺点\n\n快照沙箱有如下缺点：\n\n * 不支持多应用实例。一个页面只能有一个沙箱实例。\n * 在 active 和 inactive 中都需要迭代大量属性，耗费性能。\n * 尽管沙箱关闭时会清理 window，但是在沙箱开启时，主应用和微应用共用一个 window，容易造成 js 混乱。",normalizedContent:"# 目录\n\n\n\n * 目录\n * snapshotsandbox\n * 快照沙箱的核心功能是什么？\n * 快照沙箱如何隔离 js？\n * 优点\n * 缺点\n\n\n\n\n# snapshotsandbox\n\n快照沙箱较为简单，这种基于快照机制的沙箱有很大的局限性就是不能同时多个沙箱同时打快照，不然就会混乱，因为快照是直接基于 window 的。代码如下：\n\nfunction iter(obj: typeof window, callbackfn: (prop: any) => void) {\n  // eslint-disable-next-line guard-for-in, no-restricted-syntax\n  for (const prop in obj) {\n    // patch for clearinterval for compatible reason, see #1490\n    if (obj.hasownproperty(prop) || prop === 'clearinterval') {\n      callbackfn(prop);\n    }\n  }\n}\n\n/**\n * 基于 diff 方式实现的沙箱，用于不支持 proxy 的低版本浏览器\n */\nexport default class snapshotsandbox implements sandbox {\n  proxy: windowproxy;\n\n  name: string;\n\n  type: sandboxtype;\n\n  sandboxrunning = true;\n\n  private windowsnapshot!: window;\n\n  private modifypropsmap: record<any, any> = {};\n\n  constructor(name: string) {\n    this.name = name;\n    // 基于快照的实现，直接使用 window\n    this.proxy = window;\n    this.type = sandboxtype.snapshot;\n  }\n\n  active() {\n    // 记录当前快照\n    this.windowsnapshot = {} as window;\n    // 将 window 上的属性克隆到 windowsnapshot\n    iter(window, (prop) => {\n      this.windowsnapshot[prop] = window[prop];\n    });\n\n    // 恢复之前的变更\n    object.keys(this.modifypropsmap).foreach((p: any) => {\n      window[p] = this.modifypropsmap[p];\n    });\n\n    this.sandboxrunning = true;\n  }\n\n  inactive() {\n    // 先清空 modifypropsmap，理论上在 active 时已经被消费\n    this.modifypropsmap = {};\n    // 如果 window 上的属性和快照上的属性不一致，说明在沙箱中有修改，在 modifypropsmap 保存这个宝盖以便在重新启动沙箱时恢复，同时将 window 重置为快照的状态\n    iter(window, (prop) => {\n      if (window[prop] !== this.windowsnapshot[prop]) {\n        // 记录变更，恢复环境\n        this.modifypropsmap[prop] = window[prop];\n        window[prop] = this.windowsnapshot[prop];\n      }\n    });\n\n    this.sandboxrunning = false;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n\n# 快照沙箱的核心功能是什么？\n\n快照沙箱有两个主要的任务，一是关闭沙箱时将 window 从快照恢复，二是重新开启沙箱时从缓存恢复上次的沙箱状态。\n\n * 关闭沙箱时将 window 从快照恢复\n * 重新开启沙箱时从缓存恢复上次的沙箱状态\n\n\n# 快照沙箱如何隔离 js？\n\n快照沙箱在关闭时会将 window 与开启沙箱时的快照进行 diff，并且恢复到快照状态下的 window。\n\n\n# 优点\n\n快照沙箱有如下优点：\n\n * 原理简单。\n * 兼容性很好，几乎所有浏览器都支持。\n\n\n# 缺点\n\n快照沙箱有如下缺点：\n\n * 不支持多应用实例。一个页面只能有一个沙箱实例。\n * 在 active 和 inactive 中都需要迭代大量属性，耗费性能。\n * 尽管沙箱关闭时会清理 window，但是在沙箱开启时，主应用和微应用共用一个 window，容易造成 js 混乱。",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"import-html-entry 原理",frontmatter:{title:"import-html-entry 原理",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/import-html-entry/",categories:["qiankun"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/999.import-html-entry.html",relativePath:"30.web/6.qiankun源码/999.import-html-entry.md",key:"v-51af4a72",path:"/qiankun/import-html-entry/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:17},{level:2,title:"importEntry",slug:"importentry",normalizedTitle:"importentry",charIndex:23},{level:3,title:"html 外部的 style 和 script 会不会生效？",slug:"html-外部的-style-和-script-会不会生效",normalizedTitle:"html 外部的 style 和 script 会不会生效？",charIndex:40},{level:2,title:"importHTML",slug:"importhtml",normalizedTitle:"importhtml",charIndex:74},{level:2,title:"getEmbedHTML",slug:"getembedhtml",normalizedTitle:"getembedhtml",charIndex:88},{level:2,title:"getExternalScripts",slug:"getexternalscripts",normalizedTitle:"getexternalscripts",charIndex:104},{level:2,title:"getExternalStyleSheets",slug:"getexternalstylesheets",normalizedTitle:"getexternalstylesheets",charIndex:126},{level:2,title:"execScripts",slug:"execscripts",normalizedTitle:"execscripts",charIndex:152},{level:2,title:"processTpl",slug:"processtpl",normalizedTitle:"processtpl",charIndex:167},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:181}],readingTime:{text:"10 min read",minutes:9.225,time:553500,words:1845},headersStr:"目录 介绍 importEntry html 外部的 style 和 script 会不会生效？ importHTML getEmbedHTML getExternalScripts getExternalStyleSheets execScripts processTpl 参考",content:'# 目录\n\n\n\n * 目录\n * 介绍\n * importEntry\n   * html 外部的 style 和 script 会不会生效？\n * importHTML\n * getEmbedHTML\n * getExternalScripts\n * getExternalStyleSheets\n * execScripts\n * processTpl\n * 参考\n\n\n\n\n# 介绍\n\n> Treats the index html as manifest and loads the assets(css,js), get the exports from entry script.\n\n\n# importEntry\n\nexport function defaultGetPublicPath(entry) {\n if (typeof entry === "object") {\n  return "/";\n }\n try {\n  // new URL(\'https://example.org/foo\', \'https://example.org/\') 和 new URL(\'/foo\', \'https://example.org/\') 结果是一样的\n  const { origin, pathname } = new URL(entry, location.href);\n  const paths = pathname.split("/");\n  // 移除最后一个元素\n  paths.pop();\n  return `${origin}${paths.join("/")}/`;\n } catch (e) {\n  console.warn(e);\n  return "";\n }\n}\n\nexport function importEntry(entry, opts = {}) {\n const {\n  fetch = defaultFetch,\n  getTemplate = defaultGetTemplate,\n  postProcessTemplate,\n } = opts;\n const getPublicPath =\n  opts.getPublicPath || opts.getDomain || defaultGetPublicPath;\n\n if (!entry) {\n  throw new SyntaxError("entry should not be empty!");\n }\n\n // html entry\n if (typeof entry === "string") {\n  return importHTML(entry, {\n   fetch,\n   getPublicPath,\n   getTemplate,\n   postProcessTemplate,\n  });\n }\n\n // config entry\n if (Array.isArray(entry.scripts) || Array.isArray(entry.styles)) {\n  const { scripts = [], styles = [], html = "" } = entry;\n  // 为 styles 打占位标记\n  const getHTMLWithStylePlaceholder = (tpl) =>\n   // reduceRight 支持 ie，因为是写在模板的前面，所以用 reduceRight 保证先后顺序\n   // see https://caniuse.com/?search=reduceRight\n   styles.reduceRight(\n    (html, styleSrc) => `${genLinkReplaceSymbol(styleSrc)}${html}`,\n    tpl\n   );\n  // 为 scripts 打占位标记\n  const getHTMLWithScriptPlaceholder = (tpl) =>\n   scripts.reduce(\n    (html, scriptSrc) => `${html}${genScriptReplaceSymbol(scriptSrc)}`,\n    tpl\n   );\n\n  return getEmbedHTML(\n   // 回调给外部定制 template\n   getTemplate(\n    // 给  script 和 styles 打占位标记\n    // 注意，这两种占位都打在 html 的两端\n    getHTMLWithScriptPlaceholder(getHTMLWithStylePlaceholder(html))\n   ),\n   styles,\n   { fetch }\n  ).then((embedHTML) => ({\n   template: embedHTML,\n   assetPublicPath: getPublicPath(entry),\n   getExternalScripts: () => getExternalScripts(scripts, fetch),\n   getExternalStyleSheets: () => getExternalStyleSheets(styles, fetch),\n   execScripts: (proxy, strictGlobal, execScriptsHooks = {}) => {\n    if (!scripts.length) {\n     return Promise.resolve();\n    }\n    return execScripts(scripts[scripts.length - 1], scripts, proxy, {\n     fetch,\n     strictGlobal,\n     beforeExec: execScriptsHooks.beforeExec,\n     afterExec: execScriptsHooks.afterExec,\n    });\n   },\n  }));\n } else {\n  throw new SyntaxError("entry scripts or styles should be array!");\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# html 外部的 style 和 script 会不会生效？\n\n\x3c!-- html 标签外部的样式 --\x3e\n<style>\n  #root {\n    width: 100px;\n    height: 100px;\n    background: red;\n  }\n</style>\n\n<!DOCTYPE html>\n<head>\n  <meta charset="UTF-8">\n</head>\n<body>\n  <div id="root"></div>\n</body>\n</html>\n\n\x3c!-- html 标签外部的脚本 --\x3e\n<script src="./index.js"><\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n将占位标记打在 html 的外部，构成类似上面的代码，这样的代码样式仍然会生效，脚本也会生效。可以参考这个示例：html 标签外部的样式和脚本示例\n\n\n# importHTML\n\n过程跟 importEntry 类似，不在赘述。\n\n// 读取 fetch 的结果为字符串，并且支持自动检测字符编码类型\nexport function readResAsString(response, autoDetectCharset) {\n // 未启用自动检测\n if (!autoDetectCharset) {\n  return response.text();\n }\n\n // 如果没headers，发生在test环境下的mock数据，为兼容原有测试用例\n if (!response.headers) {\n  return response.text();\n }\n\n // 如果没返回content-type，走默认逻辑\n const contentType = response.headers.get("Content-Type");\n if (!contentType) {\n  return response.text();\n }\n\n // 解析content-type内的charset\n // Content-Type: text/html; charset=utf-8\n // Content-Type: multipart/form-data; boundary=something\n // GET请求下不会出现第二种content-type\n let charset = "utf-8";\n const parts = contentType.split(";");\n if (parts.length === 2) {\n  const [, value] = parts[1].split("=");\n  const encoding = value && value.trim();\n  if (encoding) {\n   charset = encoding;\n  }\n }\n\n // 如果还是utf-8，那么走默认，兼容原有逻辑，这段代码删除也应该工作\n if (charset.toUpperCase() === "UTF-8") {\n  return response.text();\n }\n\n // 走流读取，编码可能是gbk，gb2312等，比如sofa 3默认是gbk编码\n return response.blob().then(\n  (file) =>\n   new Promise((resolve, reject) => {\n    const reader = new window.FileReader();\n    reader.onload = () => {\n     resolve(reader.result);\n    };\n    reader.onerror = reject;\n    reader.readAsText(file, charset);\n   })\n );\n}\n\nexport function defaultGetPublicPath(entry) {\n if (typeof entry === "object") {\n  return "/";\n }\n try {\n  // new URL(\'https://example.org/foo\', \'https://example.org/\') 和 new URL(\'/foo\', \'https://example.org/\') 结果是一样的\n  const { origin, pathname } = new URL(entry, location.href);\n  const paths = pathname.split("/");\n  // 移除最后一个元素\n  paths.pop();\n  return `${origin}${paths.join("/")}/`;\n } catch (e) {\n  console.warn(e);\n  return "";\n }\n}\n\nexport default function importHTML(url, opts = {}) {\n let fetch = defaultFetch;\n let autoDecodeResponse = false;\n let getPublicPath = defaultGetPublicPath;\n let getTemplate = defaultGetTemplate;\n const { postProcessTemplate } = opts;\n\n // compatible with the legacy importHTML api\n if (typeof opts === "function") {\n  fetch = opts;\n } else {\n  // fetch option is availble\n  if (opts.fetch) {\n   // fetch is a funciton\n   if (typeof opts.fetch === "function") {\n    fetch = opts.fetch;\n   } else {\n    // configuration\n    fetch = opts.fetch.fn || defaultFetch;\n    autoDecodeResponse = !!opts.fetch.autoDecodeResponse;\n   }\n  }\n  getPublicPath =\n   opts.getPublicPath || opts.getDomain || defaultGetPublicPath;\n  getTemplate = opts.getTemplate || defaultGetTemplate;\n }\n\n return (\n  // 先从缓存中取，缓存中有直接使用缓存的结果，否则请求模板并解析，并将解析结果缓存\n  embedHTMLCache[url] ||\n  (embedHTMLCache[url] = fetch(url)\n   .then((response) => readResAsString(response, autoDecodeResponse))\n   .then((html) => {\n    const assetPublicPath = getPublicPath(url);\n    // 解析模板，获取 template, scripts, entry, styles\n    const { template, scripts, entry, styles } = processTpl(\n     getTemplate(html),\n     assetPublicPath,\n     postProcessTemplate\n    );\n\n    return getEmbedHTML(template, styles, { fetch }).then((embedHTML) => ({\n     template: embedHTML,\n     assetPublicPath,\n     getExternalScripts: () => getExternalScripts(scripts, fetch),\n     getExternalStyleSheets: () => getExternalStyleSheets(styles, fetch),\n     execScripts: (proxy, strictGlobal, execScriptsHooks = {}) => {\n      if (!scripts.length) {\n       return Promise.resolve();\n      }\n      return execScripts(entry, scripts, proxy, {\n       fetch,\n       strictGlobal,\n       beforeExec: execScriptsHooks.beforeExec,\n       afterExec: execScriptsHooks.afterExec,\n      });\n     },\n    }));\n   }))\n );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n\n\n\n# getEmbedHTML\n\n获取优化样式后的模板，将外部样式转换为内部样式以优化性能\n\n/**\n * convert external css link to inline style for performance optimization\n * 获取优化样式后的模板，将外部样式转换为内部样式以优化性能，注意这里不是行内样式\n * ? 为什么可以优化性能？\n * 将 template 中 style 的\n * @param template\n * @param styles\n * @param opts\n * @return embedHTML\n */\nfunction getEmbedHTML(template, styles, opts = {}) {\n const { fetch = defaultFetch } = opts;\n let embedHTML = template;\n\n return getExternalStyleSheets(styles, fetch).then((styleSheets) => {\n  // 获取外部样式并转化为内部样式替换到样式占位标记的位置\n  embedHTML = styles.reduce((html, styleSrc, i) => {\n   html = html.replace(\n    genLinkReplaceSymbol(styleSrc),\n    `<style>/* ${styleSrc} */${styleSheets[i]}</style>`\n   );\n   return html;\n  }, embedHTML);\n  return embedHTML;\n });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# getExternalScripts\n\n获取模板中的脚本内容。\n\n// 是否是内部脚本\nconst isInlineCode = (code) => code.startsWith("<");\n// 获取内部脚本内部的内容\nexport function getInlineCode(match) {\n const start = match.indexOf(">") + 1;\n const end = match.lastIndexOf("<");\n return match.substring(start, end);\n}\n// RIC and shim for browsers setTimeout() without it\nexport const requestIdleCallback =\n window.requestIdleCallback ||\n function requestIdleCallback(cb) {\n  // 模拟 requestIdleCallback 的返回值\n  return setTimeout(() => {\n   cb();\n  }, 1);\n };\n\n// for prefetch\nexport function getExternalScripts(\n scripts,\n fetch = defaultFetch,\n errorCallback = () => {}\n) {\n const fetchScript = (scriptUrl) =>\n  // 使用缓存机制\n  scriptCache[scriptUrl] ||\n  (scriptCache[scriptUrl] = fetch(scriptUrl)\n   .then((response) => {\n    // usually browser treats 4xx and 5xx response of script loading as an error and will fire a script error event\n    // https://stackoverflow.com/questions/5625420/what-http-headers-responses-trigger-the-onerror-handler-on-a-script-tag/5625603\n    // 400 以上通常是请求错误\n    if (response.status >= 400) {\n     errorCallback();\n     throw new Error(\n      `${scriptUrl} load failed with status ${response.status}`\n     );\n    }\n\n    return response.text();\n   })\n   .catch((e) => {\n    errorCallback();\n    throw e;\n   }));\n\n return Promise.all(\n  scripts.map((script) => {\n   if (typeof script === "string") {\n    if (isInlineCode(script)) {\n     // if it is inline script\n     return getInlineCode(script);\n    } else {\n     // 外部脚本发请求获取\n     // external script\n     return fetchScript(script);\n    }\n   } else {\n    // 如果是一个对象，processTpl 解析的结果\n    // use idle time to load async script\n    const { src, async } = script;\n    // 如果是异步的脚本，先返回一个对象 content 在 IDLE 时加载\n    if (async) {\n     return {\n      src,\n      async: true,\n      content: new Promise((resolve, reject) =>\n       // 这里 resolve, reject 这样写是因为可以不传参\n       requestIdleCallback(() => fetchScript(src).then(resolve, reject))\n      ),\n     };\n    }\n    // 同步的发请求获取\n    return fetchScript(src);\n   }\n  })\n );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n# getExternalStyleSheets\n\n获取模板中的样式表内容，和 getExternalScripts 类似不在赘述。\n\n// for prefetch\nexport function getExternalStyleSheets(styles, fetch = defaultFetch) {\n return Promise.all(\n  styles.map((styleLink) => {\n   if (isInlineCode(styleLink)) {\n    // if it is inline style\n    return getInlineCode(styleLink);\n   } else {\n    // external styles\n    return (\n     styleCache[styleLink] ||\n     (styleCache[styleLink] = fetch(styleLink).then((response) =>\n      response.text()\n     ))\n    );\n   }\n  })\n );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# execScripts\n\n执行 js 脚本文件，如果有入口脚本文件 (entry)，将 entry 文件执行的结果返回。\n\n\nconst evalCache = {};\n// 在 window 环境下安全的执行代码，并且加入缓存机制\nexport function evalCode(scriptSrc, code) {\n const key = scriptSrc;\n if (!evalCache[key]) {\n  // 将待执行的代码包装成函数\n  const functionWrappedCode = `window.__TEMP_EVAL_FUNC__ = function(){${code}}`;\n  // 在安全的 window 环境执行上述代码，将包装的函数挂载到 window.__TEMP_EVAL_FUNC__ 上\n  // (0, eval)(\'console.log(this)\') 返回 Window\n  (0, eval)(functionWrappedCode);\n  // 将函数加入到缓存中\n  evalCache[key] = window.__TEMP_EVAL_FUNC__;\n  // 函数已经执行完毕，因为code是自执行函数，删除临时变量\n  delete window.__TEMP_EVAL_FUNC__;\n }\n // 如果命中缓存，从缓存中取出函数并执行\n const evalFunc = evalCache[key];\n evalFunc.call(window);\n}\n\n// 将要执行脚本包装成带对应执行环境的自执行函数\nfunction getExecutableScript(scriptSrc, scriptText, proxy, strictGlobal) {\n  // 注释内容，不影响执行结果\n const sourceUrl = isInlineCode(scriptSrc)\n  ? ""\n  : `//# sourceURL=${scriptSrc}\\n`;\n\n // 通过这种方式获取全局 window，因为 script 也是在全局作用域下运行的，所以我们通过 window.proxy 绑定时也必须确保绑定到全局 window 上\n // 否则在嵌套场景下， window.proxy 设置的是内层应用的 window，而代码其实是在全局作用域运行的，会导致闭包里的 window.proxy 取的是最外层的微应用的 proxy\n const globalWindow = (0, eval)("window");\n globalWindow.proxy = proxy;\n // TODO 通过 strictGlobal 方式切换 with 闭包，待 with 方式坑趟平后再合并\n return strictGlobal\n  ? `;(function(window, self, globalThis){with(window){;${scriptText}\\n${sourceUrl}}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`\n  : `;(function(window, self, globalThis){;${scriptText}\\n${sourceUrl}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`;\n}\n\n/**\n * FIXME to consistent with browser behavior, we should only provide callback way to invoke success and error event\n * @param entry\n * @param scripts\n * @param proxy\n * @param opts\n * @returns {Promise<unknown>}\n */\nexport function execScripts(entry, scripts, proxy = window, opts = {}) {\n const {\n  fetch = defaultFetch,\n  strictGlobal = false,\n  success,\n  error = () => {},\n  beforeExec = () => {},\n  afterExec = () => {},\n } = opts;\n\n return getExternalScripts(scripts, fetch, error).then((scriptsText) => {\n  const geval = (scriptSrc, inlineScript) => {、\n      // 执行 beforeExec 钩子\n   const rawCode = beforeExec(inlineScript, scriptSrc) || inlineScript;\n      // 获取包装后要执行的代码（自执行函数）\n   const code = getExecutableScript(scriptSrc, rawCode, proxy, strictGlobal);\n      // 执行包装后的代码\n   evalCode(scriptSrc, code);\n      // 执行 afterExec 钩子\n   afterExec(inlineScript, scriptSrc);\n  };\n\n  function exec(scriptSrc, inlineScript, resolve) {\n   // 获取到入口脚本\n   if (scriptSrc === entry) {\n    noteGlobalProps(strictGlobal ? proxy : window);\n\n    try {\n     // bind window.proxy to change `this` reference in script\n     geval(scriptSrc, inlineScript);\n     const exports =\n      proxy[getGlobalProp(strictGlobal ? proxy : window)] || {};\n     // resolve 执行入口脚本导出的内容\n     resolve(exports);\n    } catch (e) {\n     // entry error must be thrown to make the promise settled\n     console.error(\n      `[import-html-entry]: error occurs while executing entry script ${scriptSrc}`\n     );\n     throw e;\n    }\n   } else {\n    if (typeof inlineScript === "string") {\n     try {\n      // bind window.proxy to change `this` reference in script\n      // 执行代码\n      geval(scriptSrc, inlineScript);\n     } catch (e) {\n      // consistent with browser behavior, any independent script evaluation error should not block the others\n      throwNonBlockingError(\n       e,\n       `[import-html-entry]: error occurs while executing normal script ${scriptSrc}`\n      );\n     }\n    } else {\n     // external script marked with async\n     // 如果是异步脚本\n     inlineScript.async &&\n      inlineScript?.content\n       .then((downloadedScriptText) =>\n        // 执行 content 中的脚本内容\n        geval(inlineScript.src, downloadedScriptText)\n       )\n       .catch((e) => {\n        throwNonBlockingError(\n         e,\n         `[import-html-entry]: error occurs while executing async script ${inlineScript.src}`\n        );\n       });\n    }\n   }\n  }\n  //  i 表示从下标 i 开始处理\n  function schedule(i, resolvePromise) {\n   if (i < scripts.length) {\n    const scriptSrc = scripts[i];\n    const inlineScript = scriptsText[i];\n    // 执行脚本文件\n    // 因为 entry 只有一个，所以一个 resolvePromise 传入没有问题\n    exec(scriptSrc, inlineScript, resolvePromise);\n    // resolve the promise while the last script executed and entry not provided\n    // 如果没有提供入口脚本，且所有的脚本都执行完了直接 resolve\n    if (!entry && i === scripts.length - 1) {\n     resolvePromise();\n    } else {\n     // 继续执行下一个脚本\n     schedule(i + 1, resolvePromise);\n    }\n   }\n  }\n  // 如果传了 success 就在 success 中处理，否则就在 Promise.then 里处理\n  return new Promise((resolve) => schedule(0, success || resolve));\n });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n\n\n上述代码还有如下的疑点：\n\nnoteGlobalProps 和 getGlobalProp 是什么意思？\n\nconst isIE11 =\n typeof navigator !== "undefined" &&\n navigator.userAgent.indexOf("Trident") !== -1;\n\n// 性能优化考虑\nfunction shouldSkipProperty(global, p) {\n if (!global.hasOwnProperty(p) || (!isNaN(p) && p < global.length))\n  return true;\n\n if (isIE11) {\n  // https://github.com/kuitos/import-html-entry/pull/32，最小化 try 范围\n  try {\n   return (\n    global[p] &&\n    typeof window !== "undefined" &&\n    global[p].parent === window\n   );\n  } catch (err) {\n   return true;\n  }\n } else {\n  return false;\n }\n}\n\n// safari unpredictably lists some new globals first or second in object order\nlet firstGlobalProp, secondGlobalProp, lastGlobalProp;\n\nexport function getGlobalProp(global) {\n let cnt = 0;\n let lastProp;\n let hasIframe = false;\n\n for (let p in global) {\n  if (shouldSkipProperty(global, p)) continue;\n\n  // 遍历 iframe，检查 window 上的属性值是否是 iframe，是则跳过后面的 first 和 second 判断\n  for (let i = 0; i < window.frames.length && !hasIframe; i++) {\n   const frame = window.frames[i];\n   if (frame === global[p]) {\n    hasIframe = true;\n    break;\n   }\n  }\n\n  if (\n   !hasIframe &&\n   ((cnt === 0 && p !== firstGlobalProp) ||\n    (cnt === 1 && p !== secondGlobalProp))\n  )\n   return p;\n  cnt++;\n  lastProp = p;\n }\n\n if (lastProp !== lastGlobalProp) return lastProp;\n}\n\nexport function noteGlobalProps(global) {\n // 获取 global 上最后一个属性\n // alternatively Object.keys(global).pop()\n // but this may be faster (pending benchmarks)\n firstGlobalProp = secondGlobalProp = undefined;\n\n for (let p in global) {\n  if (shouldSkipProperty(global, p)) continue;\n  if (!firstGlobalProp) firstGlobalProp = p;\n  else if (!secondGlobalProp) secondGlobalProp = p;\n  lastGlobalProp = p;\n }\n return lastGlobalProp;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# processTpl\n\n\n# 参考\n\n * Github: import-html-entry',normalizedContent:'# 目录\n\n\n\n * 目录\n * 介绍\n * importentry\n   * html 外部的 style 和 script 会不会生效？\n * importhtml\n * getembedhtml\n * getexternalscripts\n * getexternalstylesheets\n * execscripts\n * processtpl\n * 参考\n\n\n\n\n# 介绍\n\n> treats the index html as manifest and loads the assets(css,js), get the exports from entry script.\n\n\n# importentry\n\nexport function defaultgetpublicpath(entry) {\n if (typeof entry === "object") {\n  return "/";\n }\n try {\n  // new url(\'https://example.org/foo\', \'https://example.org/\') 和 new url(\'/foo\', \'https://example.org/\') 结果是一样的\n  const { origin, pathname } = new url(entry, location.href);\n  const paths = pathname.split("/");\n  // 移除最后一个元素\n  paths.pop();\n  return `${origin}${paths.join("/")}/`;\n } catch (e) {\n  console.warn(e);\n  return "";\n }\n}\n\nexport function importentry(entry, opts = {}) {\n const {\n  fetch = defaultfetch,\n  gettemplate = defaultgettemplate,\n  postprocesstemplate,\n } = opts;\n const getpublicpath =\n  opts.getpublicpath || opts.getdomain || defaultgetpublicpath;\n\n if (!entry) {\n  throw new syntaxerror("entry should not be empty!");\n }\n\n // html entry\n if (typeof entry === "string") {\n  return importhtml(entry, {\n   fetch,\n   getpublicpath,\n   gettemplate,\n   postprocesstemplate,\n  });\n }\n\n // config entry\n if (array.isarray(entry.scripts) || array.isarray(entry.styles)) {\n  const { scripts = [], styles = [], html = "" } = entry;\n  // 为 styles 打占位标记\n  const gethtmlwithstyleplaceholder = (tpl) =>\n   // reduceright 支持 ie，因为是写在模板的前面，所以用 reduceright 保证先后顺序\n   // see https://caniuse.com/?search=reduceright\n   styles.reduceright(\n    (html, stylesrc) => `${genlinkreplacesymbol(stylesrc)}${html}`,\n    tpl\n   );\n  // 为 scripts 打占位标记\n  const gethtmlwithscriptplaceholder = (tpl) =>\n   scripts.reduce(\n    (html, scriptsrc) => `${html}${genscriptreplacesymbol(scriptsrc)}`,\n    tpl\n   );\n\n  return getembedhtml(\n   // 回调给外部定制 template\n   gettemplate(\n    // 给  script 和 styles 打占位标记\n    // 注意，这两种占位都打在 html 的两端\n    gethtmlwithscriptplaceholder(gethtmlwithstyleplaceholder(html))\n   ),\n   styles,\n   { fetch }\n  ).then((embedhtml) => ({\n   template: embedhtml,\n   assetpublicpath: getpublicpath(entry),\n   getexternalscripts: () => getexternalscripts(scripts, fetch),\n   getexternalstylesheets: () => getexternalstylesheets(styles, fetch),\n   execscripts: (proxy, strictglobal, execscriptshooks = {}) => {\n    if (!scripts.length) {\n     return promise.resolve();\n    }\n    return execscripts(scripts[scripts.length - 1], scripts, proxy, {\n     fetch,\n     strictglobal,\n     beforeexec: execscriptshooks.beforeexec,\n     afterexec: execscriptshooks.afterexec,\n    });\n   },\n  }));\n } else {\n  throw new syntaxerror("entry scripts or styles should be array!");\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# html 外部的 style 和 script 会不会生效？\n\n\x3c!-- html 标签外部的样式 --\x3e\n<style>\n  #root {\n    width: 100px;\n    height: 100px;\n    background: red;\n  }\n</style>\n\n<!doctype html>\n<head>\n  <meta charset="utf-8">\n</head>\n<body>\n  <div id="root"></div>\n</body>\n</html>\n\n\x3c!-- html 标签外部的脚本 --\x3e\n<script src="./index.js"><\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n将占位标记打在 html 的外部，构成类似上面的代码，这样的代码样式仍然会生效，脚本也会生效。可以参考这个示例：html 标签外部的样式和脚本示例\n\n\n# importhtml\n\n过程跟 importentry 类似，不在赘述。\n\n// 读取 fetch 的结果为字符串，并且支持自动检测字符编码类型\nexport function readresasstring(response, autodetectcharset) {\n // 未启用自动检测\n if (!autodetectcharset) {\n  return response.text();\n }\n\n // 如果没headers，发生在test环境下的mock数据，为兼容原有测试用例\n if (!response.headers) {\n  return response.text();\n }\n\n // 如果没返回content-type，走默认逻辑\n const contenttype = response.headers.get("content-type");\n if (!contenttype) {\n  return response.text();\n }\n\n // 解析content-type内的charset\n // content-type: text/html; charset=utf-8\n // content-type: multipart/form-data; boundary=something\n // get请求下不会出现第二种content-type\n let charset = "utf-8";\n const parts = contenttype.split(";");\n if (parts.length === 2) {\n  const [, value] = parts[1].split("=");\n  const encoding = value && value.trim();\n  if (encoding) {\n   charset = encoding;\n  }\n }\n\n // 如果还是utf-8，那么走默认，兼容原有逻辑，这段代码删除也应该工作\n if (charset.touppercase() === "utf-8") {\n  return response.text();\n }\n\n // 走流读取，编码可能是gbk，gb2312等，比如sofa 3默认是gbk编码\n return response.blob().then(\n  (file) =>\n   new promise((resolve, reject) => {\n    const reader = new window.filereader();\n    reader.onload = () => {\n     resolve(reader.result);\n    };\n    reader.onerror = reject;\n    reader.readastext(file, charset);\n   })\n );\n}\n\nexport function defaultgetpublicpath(entry) {\n if (typeof entry === "object") {\n  return "/";\n }\n try {\n  // new url(\'https://example.org/foo\', \'https://example.org/\') 和 new url(\'/foo\', \'https://example.org/\') 结果是一样的\n  const { origin, pathname } = new url(entry, location.href);\n  const paths = pathname.split("/");\n  // 移除最后一个元素\n  paths.pop();\n  return `${origin}${paths.join("/")}/`;\n } catch (e) {\n  console.warn(e);\n  return "";\n }\n}\n\nexport default function importhtml(url, opts = {}) {\n let fetch = defaultfetch;\n let autodecoderesponse = false;\n let getpublicpath = defaultgetpublicpath;\n let gettemplate = defaultgettemplate;\n const { postprocesstemplate } = opts;\n\n // compatible with the legacy importhtml api\n if (typeof opts === "function") {\n  fetch = opts;\n } else {\n  // fetch option is availble\n  if (opts.fetch) {\n   // fetch is a funciton\n   if (typeof opts.fetch === "function") {\n    fetch = opts.fetch;\n   } else {\n    // configuration\n    fetch = opts.fetch.fn || defaultfetch;\n    autodecoderesponse = !!opts.fetch.autodecoderesponse;\n   }\n  }\n  getpublicpath =\n   opts.getpublicpath || opts.getdomain || defaultgetpublicpath;\n  gettemplate = opts.gettemplate || defaultgettemplate;\n }\n\n return (\n  // 先从缓存中取，缓存中有直接使用缓存的结果，否则请求模板并解析，并将解析结果缓存\n  embedhtmlcache[url] ||\n  (embedhtmlcache[url] = fetch(url)\n   .then((response) => readresasstring(response, autodecoderesponse))\n   .then((html) => {\n    const assetpublicpath = getpublicpath(url);\n    // 解析模板，获取 template, scripts, entry, styles\n    const { template, scripts, entry, styles } = processtpl(\n     gettemplate(html),\n     assetpublicpath,\n     postprocesstemplate\n    );\n\n    return getembedhtml(template, styles, { fetch }).then((embedhtml) => ({\n     template: embedhtml,\n     assetpublicpath,\n     getexternalscripts: () => getexternalscripts(scripts, fetch),\n     getexternalstylesheets: () => getexternalstylesheets(styles, fetch),\n     execscripts: (proxy, strictglobal, execscriptshooks = {}) => {\n      if (!scripts.length) {\n       return promise.resolve();\n      }\n      return execscripts(entry, scripts, proxy, {\n       fetch,\n       strictglobal,\n       beforeexec: execscriptshooks.beforeexec,\n       afterexec: execscriptshooks.afterexec,\n      });\n     },\n    }));\n   }))\n );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n\n\n\n# getembedhtml\n\n获取优化样式后的模板，将外部样式转换为内部样式以优化性能\n\n/**\n * convert external css link to inline style for performance optimization\n * 获取优化样式后的模板，将外部样式转换为内部样式以优化性能，注意这里不是行内样式\n * ? 为什么可以优化性能？\n * 将 template 中 style 的\n * @param template\n * @param styles\n * @param opts\n * @return embedhtml\n */\nfunction getembedhtml(template, styles, opts = {}) {\n const { fetch = defaultfetch } = opts;\n let embedhtml = template;\n\n return getexternalstylesheets(styles, fetch).then((stylesheets) => {\n  // 获取外部样式并转化为内部样式替换到样式占位标记的位置\n  embedhtml = styles.reduce((html, stylesrc, i) => {\n   html = html.replace(\n    genlinkreplacesymbol(stylesrc),\n    `<style>/* ${stylesrc} */${stylesheets[i]}</style>`\n   );\n   return html;\n  }, embedhtml);\n  return embedhtml;\n });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# getexternalscripts\n\n获取模板中的脚本内容。\n\n// 是否是内部脚本\nconst isinlinecode = (code) => code.startswith("<");\n// 获取内部脚本内部的内容\nexport function getinlinecode(match) {\n const start = match.indexof(">") + 1;\n const end = match.lastindexof("<");\n return match.substring(start, end);\n}\n// ric and shim for browsers settimeout() without it\nexport const requestidlecallback =\n window.requestidlecallback ||\n function requestidlecallback(cb) {\n  // 模拟 requestidlecallback 的返回值\n  return settimeout(() => {\n   cb();\n  }, 1);\n };\n\n// for prefetch\nexport function getexternalscripts(\n scripts,\n fetch = defaultfetch,\n errorcallback = () => {}\n) {\n const fetchscript = (scripturl) =>\n  // 使用缓存机制\n  scriptcache[scripturl] ||\n  (scriptcache[scripturl] = fetch(scripturl)\n   .then((response) => {\n    // usually browser treats 4xx and 5xx response of script loading as an error and will fire a script error event\n    // https://stackoverflow.com/questions/5625420/what-http-headers-responses-trigger-the-onerror-handler-on-a-script-tag/5625603\n    // 400 以上通常是请求错误\n    if (response.status >= 400) {\n     errorcallback();\n     throw new error(\n      `${scripturl} load failed with status ${response.status}`\n     );\n    }\n\n    return response.text();\n   })\n   .catch((e) => {\n    errorcallback();\n    throw e;\n   }));\n\n return promise.all(\n  scripts.map((script) => {\n   if (typeof script === "string") {\n    if (isinlinecode(script)) {\n     // if it is inline script\n     return getinlinecode(script);\n    } else {\n     // 外部脚本发请求获取\n     // external script\n     return fetchscript(script);\n    }\n   } else {\n    // 如果是一个对象，processtpl 解析的结果\n    // use idle time to load async script\n    const { src, async } = script;\n    // 如果是异步的脚本，先返回一个对象 content 在 idle 时加载\n    if (async) {\n     return {\n      src,\n      async: true,\n      content: new promise((resolve, reject) =>\n       // 这里 resolve, reject 这样写是因为可以不传参\n       requestidlecallback(() => fetchscript(src).then(resolve, reject))\n      ),\n     };\n    }\n    // 同步的发请求获取\n    return fetchscript(src);\n   }\n  })\n );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n# getexternalstylesheets\n\n获取模板中的样式表内容，和 getexternalscripts 类似不在赘述。\n\n// for prefetch\nexport function getexternalstylesheets(styles, fetch = defaultfetch) {\n return promise.all(\n  styles.map((stylelink) => {\n   if (isinlinecode(stylelink)) {\n    // if it is inline style\n    return getinlinecode(stylelink);\n   } else {\n    // external styles\n    return (\n     stylecache[stylelink] ||\n     (stylecache[stylelink] = fetch(stylelink).then((response) =>\n      response.text()\n     ))\n    );\n   }\n  })\n );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# execscripts\n\n执行 js 脚本文件，如果有入口脚本文件 (entry)，将 entry 文件执行的结果返回。\n\n\nconst evalcache = {};\n// 在 window 环境下安全的执行代码，并且加入缓存机制\nexport function evalcode(scriptsrc, code) {\n const key = scriptsrc;\n if (!evalcache[key]) {\n  // 将待执行的代码包装成函数\n  const functionwrappedcode = `window.__temp_eval_func__ = function(){${code}}`;\n  // 在安全的 window 环境执行上述代码，将包装的函数挂载到 window.__temp_eval_func__ 上\n  // (0, eval)(\'console.log(this)\') 返回 window\n  (0, eval)(functionwrappedcode);\n  // 将函数加入到缓存中\n  evalcache[key] = window.__temp_eval_func__;\n  // 函数已经执行完毕，因为code是自执行函数，删除临时变量\n  delete window.__temp_eval_func__;\n }\n // 如果命中缓存，从缓存中取出函数并执行\n const evalfunc = evalcache[key];\n evalfunc.call(window);\n}\n\n// 将要执行脚本包装成带对应执行环境的自执行函数\nfunction getexecutablescript(scriptsrc, scripttext, proxy, strictglobal) {\n  // 注释内容，不影响执行结果\n const sourceurl = isinlinecode(scriptsrc)\n  ? ""\n  : `//# sourceurl=${scriptsrc}\\n`;\n\n // 通过这种方式获取全局 window，因为 script 也是在全局作用域下运行的，所以我们通过 window.proxy 绑定时也必须确保绑定到全局 window 上\n // 否则在嵌套场景下， window.proxy 设置的是内层应用的 window，而代码其实是在全局作用域运行的，会导致闭包里的 window.proxy 取的是最外层的微应用的 proxy\n const globalwindow = (0, eval)("window");\n globalwindow.proxy = proxy;\n // todo 通过 strictglobal 方式切换 with 闭包，待 with 方式坑趟平后再合并\n return strictglobal\n  ? `;(function(window, self, globalthis){with(window){;${scripttext}\\n${sourceurl}}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`\n  : `;(function(window, self, globalthis){;${scripttext}\\n${sourceurl}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`;\n}\n\n/**\n * fixme to consistent with browser behavior, we should only provide callback way to invoke success and error event\n * @param entry\n * @param scripts\n * @param proxy\n * @param opts\n * @returns {promise<unknown>}\n */\nexport function execscripts(entry, scripts, proxy = window, opts = {}) {\n const {\n  fetch = defaultfetch,\n  strictglobal = false,\n  success,\n  error = () => {},\n  beforeexec = () => {},\n  afterexec = () => {},\n } = opts;\n\n return getexternalscripts(scripts, fetch, error).then((scriptstext) => {\n  const geval = (scriptsrc, inlinescript) => {、\n      // 执行 beforeexec 钩子\n   const rawcode = beforeexec(inlinescript, scriptsrc) || inlinescript;\n      // 获取包装后要执行的代码（自执行函数）\n   const code = getexecutablescript(scriptsrc, rawcode, proxy, strictglobal);\n      // 执行包装后的代码\n   evalcode(scriptsrc, code);\n      // 执行 afterexec 钩子\n   afterexec(inlinescript, scriptsrc);\n  };\n\n  function exec(scriptsrc, inlinescript, resolve) {\n   // 获取到入口脚本\n   if (scriptsrc === entry) {\n    noteglobalprops(strictglobal ? proxy : window);\n\n    try {\n     // bind window.proxy to change `this` reference in script\n     geval(scriptsrc, inlinescript);\n     const exports =\n      proxy[getglobalprop(strictglobal ? proxy : window)] || {};\n     // resolve 执行入口脚本导出的内容\n     resolve(exports);\n    } catch (e) {\n     // entry error must be thrown to make the promise settled\n     console.error(\n      `[import-html-entry]: error occurs while executing entry script ${scriptsrc}`\n     );\n     throw e;\n    }\n   } else {\n    if (typeof inlinescript === "string") {\n     try {\n      // bind window.proxy to change `this` reference in script\n      // 执行代码\n      geval(scriptsrc, inlinescript);\n     } catch (e) {\n      // consistent with browser behavior, any independent script evaluation error should not block the others\n      thrownonblockingerror(\n       e,\n       `[import-html-entry]: error occurs while executing normal script ${scriptsrc}`\n      );\n     }\n    } else {\n     // external script marked with async\n     // 如果是异步脚本\n     inlinescript.async &&\n      inlinescript?.content\n       .then((downloadedscripttext) =>\n        // 执行 content 中的脚本内容\n        geval(inlinescript.src, downloadedscripttext)\n       )\n       .catch((e) => {\n        thrownonblockingerror(\n         e,\n         `[import-html-entry]: error occurs while executing async script ${inlinescript.src}`\n        );\n       });\n    }\n   }\n  }\n  //  i 表示从下标 i 开始处理\n  function schedule(i, resolvepromise) {\n   if (i < scripts.length) {\n    const scriptsrc = scripts[i];\n    const inlinescript = scriptstext[i];\n    // 执行脚本文件\n    // 因为 entry 只有一个，所以一个 resolvepromise 传入没有问题\n    exec(scriptsrc, inlinescript, resolvepromise);\n    // resolve the promise while the last script executed and entry not provided\n    // 如果没有提供入口脚本，且所有的脚本都执行完了直接 resolve\n    if (!entry && i === scripts.length - 1) {\n     resolvepromise();\n    } else {\n     // 继续执行下一个脚本\n     schedule(i + 1, resolvepromise);\n    }\n   }\n  }\n  // 如果传了 success 就在 success 中处理，否则就在 promise.then 里处理\n  return new promise((resolve) => schedule(0, success || resolve));\n });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n\n\n上述代码还有如下的疑点：\n\nnoteglobalprops 和 getglobalprop 是什么意思？\n\nconst isie11 =\n typeof navigator !== "undefined" &&\n navigator.useragent.indexof("trident") !== -1;\n\n// 性能优化考虑\nfunction shouldskipproperty(global, p) {\n if (!global.hasownproperty(p) || (!isnan(p) && p < global.length))\n  return true;\n\n if (isie11) {\n  // https://github.com/kuitos/import-html-entry/pull/32，最小化 try 范围\n  try {\n   return (\n    global[p] &&\n    typeof window !== "undefined" &&\n    global[p].parent === window\n   );\n  } catch (err) {\n   return true;\n  }\n } else {\n  return false;\n }\n}\n\n// safari unpredictably lists some new globals first or second in object order\nlet firstglobalprop, secondglobalprop, lastglobalprop;\n\nexport function getglobalprop(global) {\n let cnt = 0;\n let lastprop;\n let hasiframe = false;\n\n for (let p in global) {\n  if (shouldskipproperty(global, p)) continue;\n\n  // 遍历 iframe，检查 window 上的属性值是否是 iframe，是则跳过后面的 first 和 second 判断\n  for (let i = 0; i < window.frames.length && !hasiframe; i++) {\n   const frame = window.frames[i];\n   if (frame === global[p]) {\n    hasiframe = true;\n    break;\n   }\n  }\n\n  if (\n   !hasiframe &&\n   ((cnt === 0 && p !== firstglobalprop) ||\n    (cnt === 1 && p !== secondglobalprop))\n  )\n   return p;\n  cnt++;\n  lastprop = p;\n }\n\n if (lastprop !== lastglobalprop) return lastprop;\n}\n\nexport function noteglobalprops(global) {\n // 获取 global 上最后一个属性\n // alternatively object.keys(global).pop()\n // but this may be faster (pending benchmarks)\n firstglobalprop = secondglobalprop = undefined;\n\n for (let p in global) {\n  if (shouldskipproperty(global, p)) continue;\n  if (!firstglobalprop) firstglobalprop = p;\n  else if (!secondglobalprop) secondglobalprop = p;\n  lastglobalprop = p;\n }\n return lastglobalprop;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# processtpl\n\n\n# 参考\n\n * github: import-html-entry',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"开始阅读",frontmatter:{title:"开始阅读",date:"2022-04-14T22:02:21.000Z",permalink:"/pages/ba82e2/",categories:["snabbdom"],tags:[null]},regularPath:"/30.web/60.snabbdom/0.index.html",relativePath:"30.web/60.snabbdom/0.index.md",key:"v-07fff7d7",path:"/pages/ba82e2/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:17},{level:2,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:23},{level:2,title:"阅读方法",slug:"阅读方法",normalizedTitle:"阅读方法",charIndex:29}],readingTime:{text:"1 min read",minutes:.95,time:57e3,words:190},headersStr:"目录 介绍 示例 阅读方法",content:'# 目录\n\n\n\n * 目录\n * 介绍\n * 示例\n * 阅读方法\n\n\n\n\n# 介绍\n\n一个精简化、模块化、功能强大、性能卓越的虚拟 DOM 库。\n\n参考：Github: Snabbdom README\n\n特性:\n\n * Vue 2.x 内部使用的 Virtual DOM 就是改造的 Snabbdom\n * 大约 200 行源码\n * 通过模块可扩展\n * 源码使用 TypeScript 开发\n * 最快的 Virtual DOM 之一\n\n\n# 示例\n\nsnabbdom 使用示例。\n\nimport {\n  init,\n  classModule,\n  propsModule,\n  styleModule,\n  eventListenersModule,\n  h,\n} from "snabbdom";\n\nconst patch = init([\n  // 通过传入模块初始化 patch 函数\n  classModule, // 开启 classes 功能\n  propsModule, // 支持传入 props\n  styleModule, // 支持内联样式同时支持动画\n  eventListenersModule, // 添加事件监听\n]);\n\nconst container = document.getElementById("container");\n\nconst vnode = h("div#container.two.classes", { on: { click: someFn } }, [\n  h("span", { style: { fontWeight: "bold" } }, "This is bold"),\n  " and this is just normal text",\n  h("a", { props: { href: "/foo" } }, "I\'ll take you places!"),\n]);\n// 传入一个空的元素节点 - 将产生副作用（修改该节点）\npatch(container, vnode);\n\nconst newVnode = h(\n  "div#container.two.classes",\n  { on: { click: anotherEventHandler } },\n  [\n    h(\n      "span",\n      { style: { fontWeight: "normal", fontStyle: "italic" } },\n      "This is now italic type"\n    ),\n    " and this is still just normal text",\n    h("a", { props: { href: "/bar" } }, "I\'ll take you places!"),\n  ]\n);\n// 再次调用 `patch`\npatch(vnode, newVnode); // 将旧节点更新为新节点\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 阅读方法\n\n * 根据如上的示例从核心 API 开始阅读。\n * module 和 helper。',normalizedContent:'# 目录\n\n\n\n * 目录\n * 介绍\n * 示例\n * 阅读方法\n\n\n\n\n# 介绍\n\n一个精简化、模块化、功能强大、性能卓越的虚拟 dom 库。\n\n参考：github: snabbdom readme\n\n特性:\n\n * vue 2.x 内部使用的 virtual dom 就是改造的 snabbdom\n * 大约 200 行源码\n * 通过模块可扩展\n * 源码使用 typescript 开发\n * 最快的 virtual dom 之一\n\n\n# 示例\n\nsnabbdom 使用示例。\n\nimport {\n  init,\n  classmodule,\n  propsmodule,\n  stylemodule,\n  eventlistenersmodule,\n  h,\n} from "snabbdom";\n\nconst patch = init([\n  // 通过传入模块初始化 patch 函数\n  classmodule, // 开启 classes 功能\n  propsmodule, // 支持传入 props\n  stylemodule, // 支持内联样式同时支持动画\n  eventlistenersmodule, // 添加事件监听\n]);\n\nconst container = document.getelementbyid("container");\n\nconst vnode = h("div#container.two.classes", { on: { click: somefn } }, [\n  h("span", { style: { fontweight: "bold" } }, "this is bold"),\n  " and this is just normal text",\n  h("a", { props: { href: "/foo" } }, "i\'ll take you places!"),\n]);\n// 传入一个空的元素节点 - 将产生副作用（修改该节点）\npatch(container, vnode);\n\nconst newvnode = h(\n  "div#container.two.classes",\n  { on: { click: anothereventhandler } },\n  [\n    h(\n      "span",\n      { style: { fontweight: "normal", fontstyle: "italic" } },\n      "this is now italic type"\n    ),\n    " and this is still just normal text",\n    h("a", { props: { href: "/bar" } }, "i\'ll take you places!"),\n  ]\n);\n// 再次调用 `patch`\npatch(vnode, newvnode); // 将旧节点更新为新节点\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 阅读方法\n\n * 根据如上的示例从核心 api 开始阅读。\n * module 和 helper。',charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"init",frontmatter:{title:"init",date:"2022-04-14T22:02:21.000Z",permalink:"/pages/cf8075/",categories:["snabbdom","core"],tags:[null]},regularPath:"/30.web/60.snabbdom/10.core/10.init.html",relativePath:"30.web/60.snabbdom/10.core/10.init.md",key:"v-725a2703",path:"/pages/cf8075/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:11}],readingTime:{text:"1 min read",minutes:.065,time:3900.0000000000005,words:13},headersStr:"目录",content:"# init\n\n\n# 目录\n\n\n\n * 目录\n\n",normalizedContent:"# init\n\n\n# 目录\n\n\n\n * 目录\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"h",frontmatter:{title:"h",date:"2022-04-14T22:02:21.000Z",permalink:"/pages/69bbdd/",categories:["snabbdom","core"],tags:[null]},regularPath:"/30.web/60.snabbdom/10.core/20.h.html",relativePath:"30.web/60.snabbdom/10.core/20.h.md",key:"v-ca971886",path:"/pages/69bbdd/",readingTime:{text:"1 min read",minutes:.01,time:600,words:2},headersStr:null,content:"# h",normalizedContent:"# h",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"jsx",frontmatter:{title:"jsx",date:"2022-04-14T22:02:21.000Z",permalink:"/pages/fa7d5d/",categories:["snabbdom","core"],tags:[null]},regularPath:"/30.web/60.snabbdom/10.core/30.jsx.html",relativePath:"30.web/60.snabbdom/10.core/30.jsx.md",key:"v-6892877d",path:"/pages/fa7d5d/",readingTime:{text:"1 min read",minutes:.01,time:600,words:2},headersStr:null,content:"# jsx",normalizedContent:"# jsx",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"vnode",frontmatter:{title:"vnode",date:"2022-04-14T22:02:21.000Z",permalink:"/pages/3f1101/",categories:["snabbdom","core"],tags:[null]},regularPath:"/30.web/60.snabbdom/10.core/40.vnode.html",relativePath:"30.web/60.snabbdom/10.core/40.vnode.md",key:"v-d23fd306",path:"/pages/3f1101/",readingTime:{text:"1 min read",minutes:.01,time:600,words:2},headersStr:null,content:"# vnode",normalizedContent:"# vnode",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"thunk",frontmatter:{title:"thunk",date:"2022-04-14T22:02:21.000Z",permalink:"/pages/d02874/",categories:["snabbdom","core"],tags:[null]},regularPath:"/30.web/60.snabbdom/10.core/50.thunk.html",relativePath:"30.web/60.snabbdom/10.core/50.thunk.md",key:"v-210aaa1d",path:"/pages/d02874/",readingTime:{text:"1 min read",minutes:.01,time:600,words:2},headersStr:null,content:"# thunk",normalizedContent:"# thunk",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"attachto",frontmatter:{title:"attachto",date:"2022-04-14T22:02:21.000Z",permalink:"/pages/903ddd/",categories:["snabbdom","helper"],tags:[null]},regularPath:"/30.web/60.snabbdom/30.helper/10.attachto.html",relativePath:"30.web/60.snabbdom/30.helper/10.attachto.md",key:"v-377700fe",path:"/pages/903ddd/",readingTime:{text:"1 min read",minutes:.01,time:600,words:2},headersStr:null,content:"# attachto",normalizedContent:"# attachto",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"开始阅读",frontmatter:{title:"开始阅读",date:"2022-04-20T11:18:30.000Z",permalink:"/webpack/init/",categories:["more","webpack"],tags:[null]},regularPath:"/30.web/7.webpack/0.index.html",relativePath:"30.web/7.webpack/0.index.md",key:"v-405fbd6a",path:"/webpack/init/",headers:[{level:2,title:"前提",slug:"前提",normalizedTitle:"前提",charIndex:149},{level:2,title:"V5 VS V4",slug:"v5-vs-v4",normalizedTitle:"v5 vs v4",charIndex:301},{level:3,title:"整体方向",slug:"整体方向",normalizedTitle:"整体方向",charIndex:314},{level:3,title:"重大变更",slug:"重大变更",normalizedTitle:"重大变更",charIndex:527},{level:3,title:"重大内部变更",slug:"重大内部变更",normalizedTitle:"重大内部变更",charIndex:1057},{level:2,title:"模块",slug:"模块",normalizedTitle:"模块",charIndex:548},{level:2,title:"构建流程",slug:"构建流程",normalizedTitle:"构建流程",charIndex:1551},{level:2,title:"RoadMap",slug:"roadmap",normalizedTitle:"roadmap",charIndex:1812},{level:2,title:"构建流程 RoadMap",slug:"构建流程-roadmap",normalizedTitle:"构建流程 roadmap",charIndex:1871},{level:2,title:"衍生内容",slug:"衍生内容",normalizedTitle:"衍生内容",charIndex:1958},{level:2,title:"声明",slug:"声明",normalizedTitle:"声明",charIndex:1891},{level:2,title:"参考阅读",slug:"参考阅读",normalizedTitle:"参考阅读",charIndex:2136},{level:2,title:"链接",slug:"链接",normalizedTitle:"链接",charIndex:2295}],excerpt:"<p>webpack 是一个庞大且复杂的系统，其代码文件之多，数量之多，甚至超过了 react 和 vue 这样的框架。对于初学者而言，阅读 webpack 代码最大的阻碍就是  <code>从哪里开始入手？</code>  以及  <code>怎么入手？</code>  的问题。让本系列的文章中，将探讨这样的问题，并尽可能深入的使知识的脉络更加清晰。</p>\n",readingTime:{text:"2 min read",minutes:1.88,time:112800,words:376},headersStr:"前提 V5 VS V4 整体方向 重大变更 重大内部变更 模块 构建流程 RoadMap 构建流程 RoadMap 衍生内容 声明 参考阅读 链接",content:"webpack 是一个庞大且复杂的系统，其代码文件之多，数量之多，甚至超过了 react 和 vue 这样的框架。对于初学者而言，阅读 webpack 代码最大的阻碍就是 从哪里开始入手？ 以及 怎么入手？ 的问题。让本系列的文章中，将探讨这样的问题，并尽可能深入的使知识的脉络更加清晰。\n\n\n# 前提\n\n * 了解 webpack 宏观上的核心原理和概念。建议先阅读【参考】中的资料。实际上阅读完上述的内容而言在一定程度上已经够用了。而本系列也不会在重复上述文章的内容，而是参考这样的脉络以不同的注入点从源码进行深入和扩展。\n * 先阅读 tapable 部分了解其 hook 结构的概念。\n\n\n# V5 VS V4\n\n\n# 整体方向\n\n * 尝试用 持久性缓存 来提高构建性能。\n * 尝试用更好的 算法和默认值 来改进 长期缓存 。\n * 尝试用更好的 Tree Shaking 和代码生成来改善包大小。\n * 尝试改善与网络平台的兼容性。\n * 尝试在不引入任何破坏性变化的情况下，清理那些在实现 v4 功能时处于奇怪状态的内部结构。\n * 试图通过现在引入突破性的变化来为未来的功能做准备，使其能够尽可能长时间地保持在 v5 版本上。\n\n\n# 重大变更\n\n * 不再为 Node.js 模块 自动引用 Polyfills，提高 web 平台的兼容性。\n * 确定的 Chunk、模块 ID 和导出名称\n * 真正的内容哈希\n * 命名代码块 ID\n * 模块联邦\n * JSON 模块\n * import.meta\n * 资源模块\n * 原生 Worker 支持\n * URIs\n * 异步模块\n * 外部资源\n * 经过优化的构建目标 (target)\n * Stats\n * 进度\n * 自动添加唯一命名\n * 自动添加公共路径\n * Typescript 类型\n * 嵌套的 tree-shaking\n * 内部模块 tree-shaking\n * CommonJs Tree Shaking\n * 副作用分析\n * 每个运行时的优化\n * 模块合并\n * 通用 Tree Shaking 改进\n * 开发与生产的一致性问题\n * 改进代码生成\n * 改进 target 配置\n * 代码块拆分与模块大小\n * 持久缓存\n * 编译器闲置和关闭\n * 文件生成\n * 单一文件目标的代码分割\n * 更新了解析器\n * 没有 JS 的代码块\n * 实验特性\n * 最小 Node.js 版本\n\n\n# 重大内部变更\n\n * 新的插件运行顺序：插件在应用配置默认值 之前 就会被应用\n * 运行时模块\n * 序列化：对复杂对象进行序列化\n * 用于缓存的插件\n * 冻结钩子对象\n * Tapable 插件升级\n * Stage 钩子\n * Main/Chunk/ModuleTemplate 废弃：JavascriptModulesPlugin 负责 JS 模板\n * 入口文件描述符\n * 排序与 ID：顺序将不再用于 ID 的生成，ID 生成的完全控制在插件中\n * 模块热替换\n * 工作队列\n * Logging\n * 模块和 chunk 图\n * Init Fragments\n * 模块 Source Types\n * Stats 的插件\n * 全新的监听\n * SizeOnlySource after emit\n * ExportsInfo\n * 代码生成阶段\n\n参考：\n\n * Webpack 5 发布 (2020-10-10) | webpack 中文文档\n\n\n# 模块\n\nwebpack 是个复杂的系统，本系列将 webpack 分成如下几个模块来进行解读：\n\n * 构建流程：分成 init 阶段、make 阶段、seal 阶段、emit 阶段四个部分，分成四个章节进行探讨。loader 系统和插件系统的原理将穿插在本章节讲解。\n * loader 系统：探究 webpack loader 系统，讨论常见资源文件时如何被 loader 解析为 JavaScript 的。\n * plugin 系统：探讨 webpack 的插件系统，讨论内置插件、核心插件的实现原理。\n\n\n# 构建流程\n\n * init 阶段\n * make 阶段\n * seal 阶段\n * emit 阶段\n\n\n# RoadMap\n\n参考：Webpack 5 知识体系 - GitMind\n\n如果上述文件无法访问请参考：\n\n\n\n\n# 构建流程 RoadMap\n\n\n\n\n\n版权声明\n\n以上 RoadMap、构建流程 RoadMap 为原作者为 范文杰 ，请访问原作：分享一份 Webpack 知识图谱\n\n\n# 衍生内容\n\n * 由 Parse 过程衍生的 源码字符串如何生成 AST？AST 如何生成目标产物？ 问题将在 acorn 源码解析、Babel 源码解析、编译原理中探讨。\n * 关于 webpack 源码中设计模式的应用在 Webpack 中的设计模式探讨 中探讨。\n\n\n# 声明\n\n * 由于 webpack 源码量巨大，本文将从简引用代码。\n\n\n# 参考阅读\n\n * [万字总结] 一文吃透 Webpack 核心原理 - 知乎\n * diving-into-webpack/README.md at master · lihongxun945/diving-into-webpack\n * Webpack 案例 —— vue-loader 原理分析 - 掘金\n\n\n# 链接\n\n * webpack 英文文档\n * webpack 中文文档\n * webpack/tapable: Just a little module for plugins.\n * webpack/loader-runner: Runs (webpack) loaders\n * acornjs/acorn: A small, fast, JavaScript-based JavaScript parser",normalizedContent:"webpack 是一个庞大且复杂的系统，其代码文件之多，数量之多，甚至超过了 react 和 vue 这样的框架。对于初学者而言，阅读 webpack 代码最大的阻碍就是 从哪里开始入手？ 以及 怎么入手？ 的问题。让本系列的文章中，将探讨这样的问题，并尽可能深入的使知识的脉络更加清晰。\n\n\n# 前提\n\n * 了解 webpack 宏观上的核心原理和概念。建议先阅读【参考】中的资料。实际上阅读完上述的内容而言在一定程度上已经够用了。而本系列也不会在重复上述文章的内容，而是参考这样的脉络以不同的注入点从源码进行深入和扩展。\n * 先阅读 tapable 部分了解其 hook 结构的概念。\n\n\n# v5 vs v4\n\n\n# 整体方向\n\n * 尝试用 持久性缓存 来提高构建性能。\n * 尝试用更好的 算法和默认值 来改进 长期缓存 。\n * 尝试用更好的 tree shaking 和代码生成来改善包大小。\n * 尝试改善与网络平台的兼容性。\n * 尝试在不引入任何破坏性变化的情况下，清理那些在实现 v4 功能时处于奇怪状态的内部结构。\n * 试图通过现在引入突破性的变化来为未来的功能做准备，使其能够尽可能长时间地保持在 v5 版本上。\n\n\n# 重大变更\n\n * 不再为 node.js 模块 自动引用 polyfills，提高 web 平台的兼容性。\n * 确定的 chunk、模块 id 和导出名称\n * 真正的内容哈希\n * 命名代码块 id\n * 模块联邦\n * json 模块\n * import.meta\n * 资源模块\n * 原生 worker 支持\n * uris\n * 异步模块\n * 外部资源\n * 经过优化的构建目标 (target)\n * stats\n * 进度\n * 自动添加唯一命名\n * 自动添加公共路径\n * typescript 类型\n * 嵌套的 tree-shaking\n * 内部模块 tree-shaking\n * commonjs tree shaking\n * 副作用分析\n * 每个运行时的优化\n * 模块合并\n * 通用 tree shaking 改进\n * 开发与生产的一致性问题\n * 改进代码生成\n * 改进 target 配置\n * 代码块拆分与模块大小\n * 持久缓存\n * 编译器闲置和关闭\n * 文件生成\n * 单一文件目标的代码分割\n * 更新了解析器\n * 没有 js 的代码块\n * 实验特性\n * 最小 node.js 版本\n\n\n# 重大内部变更\n\n * 新的插件运行顺序：插件在应用配置默认值 之前 就会被应用\n * 运行时模块\n * 序列化：对复杂对象进行序列化\n * 用于缓存的插件\n * 冻结钩子对象\n * tapable 插件升级\n * stage 钩子\n * main/chunk/moduletemplate 废弃：javascriptmodulesplugin 负责 js 模板\n * 入口文件描述符\n * 排序与 id：顺序将不再用于 id 的生成，id 生成的完全控制在插件中\n * 模块热替换\n * 工作队列\n * logging\n * 模块和 chunk 图\n * init fragments\n * 模块 source types\n * stats 的插件\n * 全新的监听\n * sizeonlysource after emit\n * exportsinfo\n * 代码生成阶段\n\n参考：\n\n * webpack 5 发布 (2020-10-10) | webpack 中文文档\n\n\n# 模块\n\nwebpack 是个复杂的系统，本系列将 webpack 分成如下几个模块来进行解读：\n\n * 构建流程：分成 init 阶段、make 阶段、seal 阶段、emit 阶段四个部分，分成四个章节进行探讨。loader 系统和插件系统的原理将穿插在本章节讲解。\n * loader 系统：探究 webpack loader 系统，讨论常见资源文件时如何被 loader 解析为 javascript 的。\n * plugin 系统：探讨 webpack 的插件系统，讨论内置插件、核心插件的实现原理。\n\n\n# 构建流程\n\n * init 阶段\n * make 阶段\n * seal 阶段\n * emit 阶段\n\n\n# roadmap\n\n参考：webpack 5 知识体系 - gitmind\n\n如果上述文件无法访问请参考：\n\n\n\n\n# 构建流程 roadmap\n\n\n\n\n\n版权声明\n\n以上 roadmap、构建流程 roadmap 为原作者为 范文杰 ，请访问原作：分享一份 webpack 知识图谱\n\n\n# 衍生内容\n\n * 由 parse 过程衍生的 源码字符串如何生成 ast？ast 如何生成目标产物？ 问题将在 acorn 源码解析、babel 源码解析、编译原理中探讨。\n * 关于 webpack 源码中设计模式的应用在 webpack 中的设计模式探讨 中探讨。\n\n\n# 声明\n\n * 由于 webpack 源码量巨大，本文将从简引用代码。\n\n\n# 参考阅读\n\n * [万字总结] 一文吃透 webpack 核心原理 - 知乎\n * diving-into-webpack/readme.md at master · lihongxun945/diving-into-webpack\n * webpack 案例 —— vue-loader 原理分析 - 掘金\n\n\n# 链接\n\n * webpack 英文文档\n * webpack 中文文档\n * webpack/tapable: just a little module for plugins.\n * webpack/loader-runner: runs (webpack) loaders\n * acornjs/acorn: a small, fast, javascript-based javascript parser",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"本章概要",frontmatter:{title:"本章概要",date:"2022-04-20T14:10:55.000Z",permalink:"/webpack/tapable/index",categories:["webpack","tapable源码"],tags:[null]},regularPath:"/30.web/7.webpack/10.tapable%E6%BA%90%E7%A0%81/0.index.html",relativePath:"30.web/7.webpack/10.tapable源码/0.index.md",key:"v-761f238a",path:"/webpack/tapable/index/",headers:[{level:2,title:"什么是 tapable?",slug:"什么是-tapable",normalizedTitle:"什么是 tapable?",charIndex:218},{level:2,title:"什么是发布订阅模式？",slug:"什么是发布订阅模式",normalizedTitle:"什么是发布订阅模式？",charIndex:313},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:937}],excerpt:"<p>webpack 核心代码只是提供 options、compilation、module、loader-runner（使用 loader-runner 包）、JavascriptParser（使用 acorn 包） 等模块的功能，但是其强大的功能还得得益于其强大的 loader 机制和 plugin 机制，这使得 webpack 拥有功能丰富的生态。</p>\n<p>本章内容探讨 webpack 插件机制的核心包，tapable 的原理。</p>\n",readingTime:{text:"1 min read",minutes:.81,time:48600,words:162},headersStr:"什么是 tapable? 什么是发布订阅模式？ 参考",content:"webpack 核心代码只是提供 options、compilation、module、loader-runner（使用 loader-runner 包）、JavascriptParser（使用 acorn 包） 等模块的功能，但是其强大的功能还得得益于其强大的 loader 机制和 plugin 机制，这使得 webpack 拥有功能丰富的生态。\n\n本章内容探讨 webpack 插件机制的核心包，tapable 的原理。\n\n\n# 什么是 tapable?\n\nTapable 是由 webpack 项目维护的，在 webpack 插件机制中起到重要作用的核心包，它使用 发布订阅模式 实现强大的 Hook 机制。\n\n\n# 什么是发布订阅模式？\n\n::: rem MDN：Publish–subscribe pattern In software architecture, publish–subscribe is a messaging pattern where senders of messages, called publishers, do not program the messages to be sent directly to specific receivers, called subscribers, but instead categorize published messages into classes without knowledge of which subscribers, if any, there may be. Similarly, subscribers express interest in one or more classes and only receive messages that are of interest, without knowledge of which publishers, if any, there are. :::\n\n发布订阅模式有如下几个特点：\n\n * 发布者不直接将消息发送给订阅者。\n * 发布者发送消息而不关心订阅者是谁。\n * 订阅者接受消息而不关心发布者是谁。\n\n参考：\n\n * 理解【观察者模式】和【发布订阅】的区别 - 掘金\n\n发布订阅的应用案例：\n\n * Redux 中的 subscribe 和 dispatch。\n * Vue 响应式原理中 effects、track 和 trigger。\n * Node.js 中的 EventEmitter 模块实现的发布订阅。\n\n\n# 参考\n\n * webpack/tapable: Just a little module for plugins.\n * webpack 核心模块 tapable 用法解析 - _蒋鹏飞 - 博客园\n * tapable 详解_风火一回的博客 - CSDN 博客_tapable\n * [源码解读] Webpack 插件架构深度讲解",normalizedContent:"webpack 核心代码只是提供 options、compilation、module、loader-runner（使用 loader-runner 包）、javascriptparser（使用 acorn 包） 等模块的功能，但是其强大的功能还得得益于其强大的 loader 机制和 plugin 机制，这使得 webpack 拥有功能丰富的生态。\n\n本章内容探讨 webpack 插件机制的核心包，tapable 的原理。\n\n\n# 什么是 tapable?\n\ntapable 是由 webpack 项目维护的，在 webpack 插件机制中起到重要作用的核心包，它使用 发布订阅模式 实现强大的 hook 机制。\n\n\n# 什么是发布订阅模式？\n\n::: rem mdn：publish–subscribe pattern in software architecture, publish–subscribe is a messaging pattern where senders of messages, called publishers, do not program the messages to be sent directly to specific receivers, called subscribers, but instead categorize published messages into classes without knowledge of which subscribers, if any, there may be. similarly, subscribers express interest in one or more classes and only receive messages that are of interest, without knowledge of which publishers, if any, there are. :::\n\n发布订阅模式有如下几个特点：\n\n * 发布者不直接将消息发送给订阅者。\n * 发布者发送消息而不关心订阅者是谁。\n * 订阅者接受消息而不关心发布者是谁。\n\n参考：\n\n * 理解【观察者模式】和【发布订阅】的区别 - 掘金\n\n发布订阅的应用案例：\n\n * redux 中的 subscribe 和 dispatch。\n * vue 响应式原理中 effects、track 和 trigger。\n * node.js 中的 eventemitter 模块实现的发布订阅。\n\n\n# 参考\n\n * webpack/tapable: just a little module for plugins.\n * webpack 核心模块 tapable 用法解析 - _蒋鹏飞 - 博客园\n * tapable 详解_风火一回的博客 - csdn 博客_tapable\n * [源码解读] webpack 插件架构深度讲解",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"Api概述",frontmatter:{title:"Api概述",date:"2022-04-20T14:49:32.000Z",permalink:"/webpack/tapable/api/",categories:["more","webpack","tapable源码"],tags:[null]},regularPath:"/30.web/7.webpack/10.tapable%E6%BA%90%E7%A0%81/10.api.html",relativePath:"30.web/7.webpack/10.tapable源码/10.api.md",key:"v-c3847a42",path:"/webpack/tapable/api/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:67},{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:21},{level:2,title:"API 分类",slug:"api-分类",normalizedTitle:"api 分类",charIndex:88},{level:2,title:"API 概述",slug:"api-概述",normalizedTitle:"api 概述",charIndex:98},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:108}],excerpt:"<TimeToRead />\n<p>本节内容主要探讨 tapable 中的一些概念，Hook 的分类，Hook API 初步认识等内容。本节内容将不涉及源代码。</p>\n",readingTime:{text:"3 min read",minutes:2.135,time:128100,words:427},headersStr:"目录 概念 API 分类 API 概述 参考",content:"本节内容主要探讨 tapable 中的一些概念，Hook 的分类，Hook API 初步认识等内容。本节内容将不涉及源代码。\n\n\n# 目录\n\n\n\n * 目录\n * 概念\n * API 分类\n * API 概述\n * 参考\n\n\n\n\n# 概念\n\n在阅读本章内容中，如下的概念需要我们注意：\n\n参数                                   描述\nHook、钩子                              一个注册 callback 的注册中心，在 webpack 中表现为 new SyncHook()\nCallback、hook、function、回调、tap (名词)   注册在 Hook 上的一个回调，在 webpack 中表现为 plugin\nTap（动词）、注册                           “轻拍” 的意思，Callback 在 Hook 上注册的过程\nCall、调用、执行                           调用 Hook 上的 Callback 的过程\n\n注意：这里舍弃了 发布 、 订阅 、 发布订阅中心 这样的术语，而是使用了 触发 、 注册 、 注册中心 的术语，目前是便于理解。\n\n\n# API 分类\n\n根据回调的行为变现不同，可以将 Hook 分成如下类型：\n\n类型                                                         官方释义                                                           中文释义                                                          备注\nBasic hook (without “Waterfall”, “Bail” or “Loop” in its   This hook simply calls every function it tapped in a row.      顺序调用被注册在 Hook 上的所有 Callback                                   \nname)\nWaterfall                                                  A waterfall hook also calls each tapped function in a row.     顺序执行 Hook 中的 Callback，将上一个 Callback 的返回值作为参数传递给下一个 Callback   Waterfall 是 “瀑布”\n                                                           Unlike the basic hook, it passes a return value from each                                                                    的意思，表示顺序执行各种任务，前一个任务执行完了才会执行下一个回调，而前一个任务的执行结果会作为参数传给下一个任务。\n                                                           function to the next function.\nBail                                                       A bail hook allows exiting early. When any of the tapped       允许提前退出，当任意一个 Callback 返回了结果，Hook 将不再执行后续的 Callback            Bail 是 “保险，保障” 的意思，表示任意一个任务成功处理，就不再执行后续的任务。\n                                                           function returns anything, the bail hook will stop executing\n                                                           the remaining ones.\nLoop                                                       When a plugin in a loop hook returns a non-undefined value     当 Hook 中某个 Callback 返回了 non-undefined 的值将从头开始重新执行直到所有的        Loop 是 “循环 “的意思，表示如果某个任务返回了非 undefined\n                                                           the hook will restart from the first plugin. It will loop      Callback 都返回 undefined ，                                      的结果就从头重复执行此任务队列，直到所有任务返回 undefined 退出循环。\n                                                           until all plugins return undefined.\n\n另外，根据回调是同步的还是异步的，可以将 Hook 分成如下类型：\n\n类型              官方释义                                                          中文释义                                                           备注\nSync            A sync hook can only be tapped with synchronous functions     同步的 Hook 只能注册同步的 Callback，使用 Hook.tap()                        同步的\n                (using myHook.tap()).\nAsyncSeries     An async-series hook can be tapped with synchronous,          async-series 的 Hook 可以注册同步的 Callback、基于回调或者基于 Promise 的        Series 是 “串行” 的意思，表示前一个任务执行完了才会执行下一个任务。\n                callback-based and promise-based functions (using             Callback。使用 Hook.tap() 、 Hook.tapAsync() 、 Hook.tapPromise()\n                myHook.tap(), myHook.tapAsync() and myHook.tapPromise()).     注册 Callback。\n                They call each async method in a row.\nAsyncParallel   An async-parallel hook can also be tapped with synchronous,   async-parallel 的 Hook 也可以注册基于回调或者基于 Promise 的 Callback。使用      Parallel 是 “并行” 的意思，有点类似于 Promise.all，表示这些回调同时并行执行。\n                callback-based and promise-based functions (using             Hook.tap() 、 Hook.tapAsync() 、 Hook.tapPromise() 注册\n                myHook.tap(), myHook.tapAsync() and myHook.tapPromise()).     Callback。但是，所有异步的 Callback 将会并行执行。\n                However, they run each async method in parallel.\n\nAsyncSeries 和 AsyncParallel 只针对异步的 Hook，同步的 Hook 永远都是串行执行的。\n\n\n# API 概述\n\n * SyncHook\n * SyncBailHook\n * SyncWaterfallHook\n * SyncLoopHook\n * AsyncParallelHook\n * AsyncParallelBailHook\n * AsyncSeriesHook\n * AsyncSeriesBailHook\n * AsyncSeriesLoopHook\n * AsyncSeriesWaterfallHook\n * HookMap\n * MultiHook\n\n\n# 参考\n\n * webpack/tapable: Just a little module for plugins.",normalizedContent:"本节内容主要探讨 tapable 中的一些概念，hook 的分类，hook api 初步认识等内容。本节内容将不涉及源代码。\n\n\n# 目录\n\n\n\n * 目录\n * 概念\n * api 分类\n * api 概述\n * 参考\n\n\n\n\n# 概念\n\n在阅读本章内容中，如下的概念需要我们注意：\n\n参数                                   描述\nhook、钩子                              一个注册 callback 的注册中心，在 webpack 中表现为 new synchook()\ncallback、hook、function、回调、tap (名词)   注册在 hook 上的一个回调，在 webpack 中表现为 plugin\ntap（动词）、注册                           “轻拍” 的意思，callback 在 hook 上注册的过程\ncall、调用、执行                           调用 hook 上的 callback 的过程\n\n注意：这里舍弃了 发布 、 订阅 、 发布订阅中心 这样的术语，而是使用了 触发 、 注册 、 注册中心 的术语，目前是便于理解。\n\n\n# api 分类\n\n根据回调的行为变现不同，可以将 hook 分成如下类型：\n\n类型                                                         官方释义                                                           中文释义                                                          备注\nbasic hook (without “waterfall”, “bail” or “loop” in its   this hook simply calls every function it tapped in a row.      顺序调用被注册在 hook 上的所有 callback                                   \nname)\nwaterfall                                                  a waterfall hook also calls each tapped function in a row.     顺序执行 hook 中的 callback，将上一个 callback 的返回值作为参数传递给下一个 callback   waterfall 是 “瀑布”\n                                                           unlike the basic hook, it passes a return value from each                                                                    的意思，表示顺序执行各种任务，前一个任务执行完了才会执行下一个回调，而前一个任务的执行结果会作为参数传给下一个任务。\n                                                           function to the next function.\nbail                                                       a bail hook allows exiting early. when any of the tapped       允许提前退出，当任意一个 callback 返回了结果，hook 将不再执行后续的 callback            bail 是 “保险，保障” 的意思，表示任意一个任务成功处理，就不再执行后续的任务。\n                                                           function returns anything, the bail hook will stop executing\n                                                           the remaining ones.\nloop                                                       when a plugin in a loop hook returns a non-undefined value     当 hook 中某个 callback 返回了 non-undefined 的值将从头开始重新执行直到所有的        loop 是 “循环 “的意思，表示如果某个任务返回了非 undefined\n                                                           the hook will restart from the first plugin. it will loop      callback 都返回 undefined ，                                      的结果就从头重复执行此任务队列，直到所有任务返回 undefined 退出循环。\n                                                           until all plugins return undefined.\n\n另外，根据回调是同步的还是异步的，可以将 hook 分成如下类型：\n\n类型              官方释义                                                          中文释义                                                           备注\nsync            a sync hook can only be tapped with synchronous functions     同步的 hook 只能注册同步的 callback，使用 hook.tap()                        同步的\n                (using myhook.tap()).\nasyncseries     an async-series hook can be tapped with synchronous,          async-series 的 hook 可以注册同步的 callback、基于回调或者基于 promise 的        series 是 “串行” 的意思，表示前一个任务执行完了才会执行下一个任务。\n                callback-based and promise-based functions (using             callback。使用 hook.tap() 、 hook.tapasync() 、 hook.tappromise()\n                myhook.tap(), myhook.tapasync() and myhook.tappromise()).     注册 callback。\n                they call each async method in a row.\nasyncparallel   an async-parallel hook can also be tapped with synchronous,   async-parallel 的 hook 也可以注册基于回调或者基于 promise 的 callback。使用      parallel 是 “并行” 的意思，有点类似于 promise.all，表示这些回调同时并行执行。\n                callback-based and promise-based functions (using             hook.tap() 、 hook.tapasync() 、 hook.tappromise() 注册\n                myhook.tap(), myhook.tapasync() and myhook.tappromise()).     callback。但是，所有异步的 callback 将会并行执行。\n                however, they run each async method in parallel.\n\nasyncseries 和 asyncparallel 只针对异步的 hook，同步的 hook 永远都是串行执行的。\n\n\n# api 概述\n\n * synchook\n * syncbailhook\n * syncwaterfallhook\n * syncloophook\n * asyncparallelhook\n * asyncparallelbailhook\n * asyncserieshook\n * asyncseriesbailhook\n * asyncseriesloophook\n * asyncserieswaterfallhook\n * hookmap\n * multihook\n\n\n# 参考\n\n * webpack/tapable: just a little module for plugins.",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"Hook",frontmatter:{title:"Hook",date:"2022-04-20T15:44:58.000Z",permalink:"/webpack/tapable/hook/",categories:["webpack","tapable源码"],tags:[null]},regularPath:"/30.web/7.webpack/10.tapable%E6%BA%90%E7%A0%81/20.Hook.html",relativePath:"30.web/7.webpack/10.tapable源码/20.Hook.md",key:"v-87d0754a",path:"/webpack/tapable/hook/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:90},{level:2,title:"Hook",slug:"hook",normalizedTitle:"hook",charIndex:34},{level:2,title:"Object.setPrototypeOf()",slug:"object-setprototypeof",normalizedTitle:"object.setprototypeof()",charIndex:113}],excerpt:"<TimeToRead />\n<p>在上节的内容中，我们探讨了 tapable 的 API 概览，包括 Hook 是如何分类的以及有哪些 Hook。这本节中，我们将继续深入源码，探讨 Hook 基类的原理。</p>\n",readingTime:{text:"4 min read",minutes:3.31,time:198600,words:662},headersStr:"目录 Hook Object.setPrototypeOf()",content:'在上节的内容中，我们探讨了 tapable 的 API 概览，包括 Hook 是如何分类的以及有哪些 Hook。这本节中，我们将继续深入源码，探讨 Hook 基类的原理。\n\n\n# 目录\n\n\n\n * 目录\n * Hook\n * Object.setPrototypeOf()\n\n\n\n\n# Hook\n\n源码如下：\n\nconst CALL_DELEGATE = function(...args) {\n  // 注意：这里会将 _createCall 创建的函数缓存到 this.call 上\n  // 所以下文 _resetCompilation 就是清除缓存，重新生成函数\n this.call = this._createCall("sync");\n return this.call(...args);\n};\nconst CALL_ASYNC_DELEGATE = function(...args) {\n this.callAsync = this._createCall("async");\n return this.callAsync(...args);\n};\nconst PROMISE_DELEGATE = function(...args) {\n this.promise = this._createCall("promise");\n return this.promise(...args);\n};\n\nclass Hook {\n constructor(args = [], name = undefined) {\n  this._args = args;\n  this.name = name;\n  this.taps = [];\n  this.interceptors = [];\n  this._call = CALL_DELEGATE;\n  this.call = CALL_DELEGATE;\n  this._callAsync = CALL_ASYNC_DELEGATE;\n  this.callAsync = CALL_ASYNC_DELEGATE;\n  this._promise = PROMISE_DELEGATE;\n  this.promise = PROMISE_DELEGATE;\n  this._x = undefined;\n\n  this.compile = this.compile;\n  this.tap = this.tap;\n  this.tapAsync = this.tapAsync;\n  this.tapPromise = this.tapPromise;\n }\n\n compile(options) {\n  throw new Error("Abstract: should be overridden");\n }\n  // Hook 的调用取决于 _createCall，而 _createCall 依赖于 compile 的实现\n _createCall(type) {\n  return this.compile({\n   taps: this.taps,\n   interceptors: this.interceptors,\n   args: this._args,\n   type: type\n  });\n }\n\n _tap(type, options, fn) {\n    // 参数处理\n  if (typeof options === "string") {\n   options = {\n    name: options.trim()\n   };\n  } else if (typeof options !== "object" || options === null) {\n   throw new Error("Invalid tap options");\n  }\n  if (typeof options.name !== "string" || options.name === "") {\n   throw new Error("Missing name for tap");\n  }\n  if (typeof options.context !== "undefined") {\n   deprecateContext();\n  }\n    // merge options，type 和 fn 合并到 options\n  options = Object.assign({ type, fn }, options);\n    // 触发 register 拦截器\n  options = this._runRegisterInterceptors(options);\n    // 将 Callback 入队列 （taps）\n  this._insert(options);\n }\n\n tap(options, fn) {\n  this._tap("sync", options, fn);\n }\n\n tapAsync(options, fn) {\n  this._tap("async", options, fn);\n }\n\n tapPromise(options, fn) {\n  this._tap("promise", options, fn);\n }\n\n _runRegisterInterceptors(options) {\n  for (const interceptor of this.interceptors) {\n      // 触发 register 拦截器，拦截器的返回值可以更改 options\n   if (interceptor.register) {\n    const newOptions = interceptor.register(options);\n    if (newOptions !== undefined) {\n     options = newOptions;\n    }\n   }\n  }\n  return options;\n }\n\n withOptions(options) {\n  const mergeOptions = opt =>\n   Object.assign({}, options, typeof opt === "string" ? { name: opt } : opt);\n\n  return {\n   name: this.name,\n   tap: (opt, fn) => this.tap(mergeOptions(opt), fn),\n   tapAsync: (opt, fn) => this.tapAsync(mergeOptions(opt), fn),\n   tapPromise: (opt, fn) => this.tapPromise(mergeOptions(opt), fn),\n   intercept: interceptor => this.intercept(interceptor),\n   isUsed: () => this.isUsed(),\n   withOptions: opt => this.withOptions(mergeOptions(opt))\n  };\n }\n\n isUsed() {\n  return this.taps.length > 0 || this.interceptors.length > 0;\n }\n\n intercept(interceptor) {\n  this._resetCompilation();\n  this.interceptors.push(Object.assign({}, interceptor));\n  if (interceptor.register) {\n   for (let i = 0; i < this.taps.length; i++) {\n    this.taps[i] = interceptor.register(this.taps[i]);\n   }\n  }\n }\n  // Hook 有三种调用方法，重置调用方法，重新生成调用函数（_createCall）\n  // 注意：此函数代价很小，因为创建调用函数的成本会分摊在下次调用 Hook 时\n _resetCompilation() {\n  this.call = this._call;\n  this.callAsync = this._callAsync;\n  this.promise = this._promise;\n }\n\n _insert(item) {\n    // 重置调用函数\n  this._resetCompilation();\n  let before;\n    // item.before 是 string 或者 string[]，处理为 Set\n  if (typeof item.before === "string") {\n   before = new Set([item.before]);\n  } else if (Array.isArray(item.before)) {\n   before = new Set(item.before);\n  }\n  let stage = 0;\n  if (typeof item.stage === "number") {\n   stage = item.stage;\n  }\n  let i = this.taps.length;\n    // 从后向前遍历 items\n  while (i > 0) {\n   i--;\n   const x = this.taps[i];\n      // 依次将 item 后移一位，为什么不采用 linked-list？\n      // 因为顺序很重要，插入操作频繁，搜索操作很少，使用 linked-list 可以提高性能\n   this.taps[i + 1] = x;\n   const xStage = x.stage || 0;\n   if (before) {\n        // 使用在队列中最前面的 before 配置\n    if (before.has(x.name)) {\n     before.delete(x.name);\n     continue;\n    }\n    if (before.size > 0) {\n     continue;\n    }\n   }\n   if (xStage > stage) {\n    continue;\n   }\n      // 如果没有传 before 且权重 >= 尾项的权重 ，插入队尾即可，因此将 break 循环，并加入到 i++ 的位置\n   i++;\n   break;\n  }\n    // 因为跳出时item 的权重 >= i 指针指向的 item 的权重，所以 item 应该放在 i 指针后面一位，所以 i++\n  this.taps[i] = item;\n }\n}\n\nObject.setPrototypeOf(Hook.prototype, null);\n\nmodule.exports = Hook;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n\n\n这里如如下几个问题需要注意：\n\n * Hook 终于其调用需要依赖于 compile 来生成调用函数，这个部分还加入了缓存和重置的逻辑。为什么需要重新调用 compile 来处理 Hook 的调用呢？从 _resetCompilation 调用情况可知，在 Tap 或者 intercept 被调用时，即注册 Callback 或者拦截器时会重置调用函数。\n * taps 采用了数组来管理。在插入操作时代价较大，个人认为使用链表最合适，具体使用数组的原因尚不清楚。before 表示插入到谁的前面，如果 before 是一个数组，以在队列最前面的为准；stage 表示权重。这里的算法可以研究下。\n * Hook 的原型被设置为 null。这么做可能是为了表示 Hook 没有继承自任何对象。\n * 这里的 compile 函数使用了空对象模式，详见：空对象模式 - 设计模式\n\n\n# Object.setPrototypeOf()\n\nThe Object.setPrototypeOf() method sets the prototype (i.e., the internal [[Prototype]] property) of a specified object to another object or null. All JavaScript objects inherit properties and methods from a prototype . It is generally considered the proper way to set the prototype of an object.\n\n参考\n\n * What is object null prototype? – QuickAdviser\n * Javascript Object setPrototypeOf() Method - javatpoint\n * Object.setPrototypeOf() - JavaScript | MDN',normalizedContent:'在上节的内容中，我们探讨了 tapable 的 api 概览，包括 hook 是如何分类的以及有哪些 hook。这本节中，我们将继续深入源码，探讨 hook 基类的原理。\n\n\n# 目录\n\n\n\n * 目录\n * hook\n * object.setprototypeof()\n\n\n\n\n# hook\n\n源码如下：\n\nconst call_delegate = function(...args) {\n  // 注意：这里会将 _createcall 创建的函数缓存到 this.call 上\n  // 所以下文 _resetcompilation 就是清除缓存，重新生成函数\n this.call = this._createcall("sync");\n return this.call(...args);\n};\nconst call_async_delegate = function(...args) {\n this.callasync = this._createcall("async");\n return this.callasync(...args);\n};\nconst promise_delegate = function(...args) {\n this.promise = this._createcall("promise");\n return this.promise(...args);\n};\n\nclass hook {\n constructor(args = [], name = undefined) {\n  this._args = args;\n  this.name = name;\n  this.taps = [];\n  this.interceptors = [];\n  this._call = call_delegate;\n  this.call = call_delegate;\n  this._callasync = call_async_delegate;\n  this.callasync = call_async_delegate;\n  this._promise = promise_delegate;\n  this.promise = promise_delegate;\n  this._x = undefined;\n\n  this.compile = this.compile;\n  this.tap = this.tap;\n  this.tapasync = this.tapasync;\n  this.tappromise = this.tappromise;\n }\n\n compile(options) {\n  throw new error("abstract: should be overridden");\n }\n  // hook 的调用取决于 _createcall，而 _createcall 依赖于 compile 的实现\n _createcall(type) {\n  return this.compile({\n   taps: this.taps,\n   interceptors: this.interceptors,\n   args: this._args,\n   type: type\n  });\n }\n\n _tap(type, options, fn) {\n    // 参数处理\n  if (typeof options === "string") {\n   options = {\n    name: options.trim()\n   };\n  } else if (typeof options !== "object" || options === null) {\n   throw new error("invalid tap options");\n  }\n  if (typeof options.name !== "string" || options.name === "") {\n   throw new error("missing name for tap");\n  }\n  if (typeof options.context !== "undefined") {\n   deprecatecontext();\n  }\n    // merge options，type 和 fn 合并到 options\n  options = object.assign({ type, fn }, options);\n    // 触发 register 拦截器\n  options = this._runregisterinterceptors(options);\n    // 将 callback 入队列 （taps）\n  this._insert(options);\n }\n\n tap(options, fn) {\n  this._tap("sync", options, fn);\n }\n\n tapasync(options, fn) {\n  this._tap("async", options, fn);\n }\n\n tappromise(options, fn) {\n  this._tap("promise", options, fn);\n }\n\n _runregisterinterceptors(options) {\n  for (const interceptor of this.interceptors) {\n      // 触发 register 拦截器，拦截器的返回值可以更改 options\n   if (interceptor.register) {\n    const newoptions = interceptor.register(options);\n    if (newoptions !== undefined) {\n     options = newoptions;\n    }\n   }\n  }\n  return options;\n }\n\n withoptions(options) {\n  const mergeoptions = opt =>\n   object.assign({}, options, typeof opt === "string" ? { name: opt } : opt);\n\n  return {\n   name: this.name,\n   tap: (opt, fn) => this.tap(mergeoptions(opt), fn),\n   tapasync: (opt, fn) => this.tapasync(mergeoptions(opt), fn),\n   tappromise: (opt, fn) => this.tappromise(mergeoptions(opt), fn),\n   intercept: interceptor => this.intercept(interceptor),\n   isused: () => this.isused(),\n   withoptions: opt => this.withoptions(mergeoptions(opt))\n  };\n }\n\n isused() {\n  return this.taps.length > 0 || this.interceptors.length > 0;\n }\n\n intercept(interceptor) {\n  this._resetcompilation();\n  this.interceptors.push(object.assign({}, interceptor));\n  if (interceptor.register) {\n   for (let i = 0; i < this.taps.length; i++) {\n    this.taps[i] = interceptor.register(this.taps[i]);\n   }\n  }\n }\n  // hook 有三种调用方法，重置调用方法，重新生成调用函数（_createcall）\n  // 注意：此函数代价很小，因为创建调用函数的成本会分摊在下次调用 hook 时\n _resetcompilation() {\n  this.call = this._call;\n  this.callasync = this._callasync;\n  this.promise = this._promise;\n }\n\n _insert(item) {\n    // 重置调用函数\n  this._resetcompilation();\n  let before;\n    // item.before 是 string 或者 string[]，处理为 set\n  if (typeof item.before === "string") {\n   before = new set([item.before]);\n  } else if (array.isarray(item.before)) {\n   before = new set(item.before);\n  }\n  let stage = 0;\n  if (typeof item.stage === "number") {\n   stage = item.stage;\n  }\n  let i = this.taps.length;\n    // 从后向前遍历 items\n  while (i > 0) {\n   i--;\n   const x = this.taps[i];\n      // 依次将 item 后移一位，为什么不采用 linked-list？\n      // 因为顺序很重要，插入操作频繁，搜索操作很少，使用 linked-list 可以提高性能\n   this.taps[i + 1] = x;\n   const xstage = x.stage || 0;\n   if (before) {\n        // 使用在队列中最前面的 before 配置\n    if (before.has(x.name)) {\n     before.delete(x.name);\n     continue;\n    }\n    if (before.size > 0) {\n     continue;\n    }\n   }\n   if (xstage > stage) {\n    continue;\n   }\n      // 如果没有传 before 且权重 >= 尾项的权重 ，插入队尾即可，因此将 break 循环，并加入到 i++ 的位置\n   i++;\n   break;\n  }\n    // 因为跳出时item 的权重 >= i 指针指向的 item 的权重，所以 item 应该放在 i 指针后面一位，所以 i++\n  this.taps[i] = item;\n }\n}\n\nobject.setprototypeof(hook.prototype, null);\n\nmodule.exports = hook;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n\n\n这里如如下几个问题需要注意：\n\n * hook 终于其调用需要依赖于 compile 来生成调用函数，这个部分还加入了缓存和重置的逻辑。为什么需要重新调用 compile 来处理 hook 的调用呢？从 _resetcompilation 调用情况可知，在 tap 或者 intercept 被调用时，即注册 callback 或者拦截器时会重置调用函数。\n * taps 采用了数组来管理。在插入操作时代价较大，个人认为使用链表最合适，具体使用数组的原因尚不清楚。before 表示插入到谁的前面，如果 before 是一个数组，以在队列最前面的为准；stage 表示权重。这里的算法可以研究下。\n * hook 的原型被设置为 null。这么做可能是为了表示 hook 没有继承自任何对象。\n * 这里的 compile 函数使用了空对象模式，详见：空对象模式 - 设计模式\n\n\n# object.setprototypeof()\n\nthe object.setprototypeof() method sets the prototype (i.e., the internal [[prototype]] property) of a specified object to another object or null. all javascript objects inherit properties and methods from a prototype . it is generally considered the proper way to set the prototype of an object.\n\n参考\n\n * what is object null prototype? – quickadviser\n * javascript object setprototypeof() method - javatpoint\n * object.setprototypeof() - javascript | mdn',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"HookCodeFactory",frontmatter:{title:"HookCodeFactory",date:"2022-04-20T17:46:43.000Z",permalink:"/webpack/tapable/factory/",categories:["webpack","tapable源码"],tags:[null]},regularPath:"/30.web/7.webpack/10.tapable%E6%BA%90%E7%A0%81/30.HookCodeFactory.html",relativePath:"30.web/7.webpack/10.tapable源码/30.HookCodeFactory.md",key:"v-2da3183a",path:"/webpack/tapable/factory/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:177},{level:2,title:"生成函数",slug:"生成函数",normalizedTitle:"生成函数",charIndex:192},{level:2,title:"HookCodeFactory",slug:"hookcodefactory",normalizedTitle:"hookcodefactory",charIndex:133}],excerpt:"<TimeToRead />\n<p>在上一节内容中，我们探讨了 Hook 的基类是如何实现的，这个基类中包含了一些公共方法，还有需要子类覆盖的 compile 方法，在整个 hook 管理的过程中，compile 是最重要和最复杂的内容。在本节内容中，我们将探讨 tapable Hook 中的工厂类 HookCodeFactory 的原理，了解 compile 函数的生成原理。</p>\n",readingTime:{text:"1 min read",minutes:.56,time:33600,words:112},headersStr:"目录 生成函数 HookCodeFactory",content:"在上一节内容中，我们探讨了 Hook 的基类是如何实现的，这个基类中包含了一些公共方法，还有需要子类覆盖的 compile 方法，在整个 hook 管理的过程中，compile 是最重要和最复杂的内容。在本节内容中，我们将探讨 tapable Hook 中的工厂类 HookCodeFactory 的原理，了解 compile 函数的生成原理。\n\n\n# 目录\n\n\n\n * 目录\n * 生成函数\n * HookCodeFactory\n\n\n\n\n# 生成函数\n\n从 HookCodeFactory 名称来看，这是一个生成函数的 “代码工厂”。但从生成函数而言，一般有如下两种方式：\n\n * 使用 eval 执行函数代码字串。\n * 使用 new Function() 生成函数。 new Function() 可以接 n 个参数，最后一个参数作为函数体。\n\n区别：\n\n               作用域     访问变量                                        案例\neval           局部作用域   局部变量（window.eval () 或者 global.eval () 除外）   参考 import-html-entry 原理 一文中 evalCode 的代码\nnew Function   全局作用域   全局变量                                        参考 Vue 中生产渲染函数的代码（_h 函数）\n\n参考：\n\n * eval 与 new Function 的区别 - SegmentFault 思否\n * javascript - Are eval() and new Function() the same thing? - Stack Overflow\n\n\n# HookCodeFactory",normalizedContent:"在上一节内容中，我们探讨了 hook 的基类是如何实现的，这个基类中包含了一些公共方法，还有需要子类覆盖的 compile 方法，在整个 hook 管理的过程中，compile 是最重要和最复杂的内容。在本节内容中，我们将探讨 tapable hook 中的工厂类 hookcodefactory 的原理，了解 compile 函数的生成原理。\n\n\n# 目录\n\n\n\n * 目录\n * 生成函数\n * hookcodefactory\n\n\n\n\n# 生成函数\n\n从 hookcodefactory 名称来看，这是一个生成函数的 “代码工厂”。但从生成函数而言，一般有如下两种方式：\n\n * 使用 eval 执行函数代码字串。\n * 使用 new function() 生成函数。 new function() 可以接 n 个参数，最后一个参数作为函数体。\n\n区别：\n\n               作用域     访问变量                                        案例\neval           局部作用域   局部变量（window.eval () 或者 global.eval () 除外）   参考 import-html-entry 原理 一文中 evalcode 的代码\nnew function   全局作用域   全局变量                                        参考 vue 中生产渲染函数的代码（_h 函数）\n\n参考：\n\n * eval 与 new function 的区别 - segmentfault 思否\n * javascript - are eval() and new function() the same thing? - stack overflow\n\n\n# hookcodefactory",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"Webpack中的设计模式探讨",frontmatter:{title:"Webpack中的设计模式探讨",date:"2022-04-26T11:01:52.000Z",permalink:"/webpack/summary/dp/",categories:["webpack"],tags:["设计模式"]},regularPath:"/30.web/7.webpack/100.%E6%80%BB%E7%BB%93/10.dp.html",relativePath:"30.web/7.webpack/100.总结/10.dp.md",key:"v-53a11582",path:"/webpack/summary/dp/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"Webpack 中的数据结构探讨",frontmatter:{title:"Webpack 中的数据结构探讨",date:"2022-04-26T11:14:17.000Z",permalink:"/webpack/summary/ds/",categories:["webpack","总结"],tags:["数据结构"]},regularPath:"/30.web/7.webpack/100.%E6%80%BB%E7%BB%93/20.ds.html",relativePath:"30.web/7.webpack/100.总结/20.ds.md",key:"v-4c8845fc",path:"/webpack/summary/ds/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"本章概要",frontmatter:{title:"本章概要",date:"2022-04-20T19:34:55.000Z",permalink:"/webpack/init/index/",categories:["more","webpack","init阶段"],tags:[null]},regularPath:"/30.web/7.webpack/20.init%E9%98%B6%E6%AE%B5/0.index.html",relativePath:"30.web/7.webpack/20.init阶段/0.index.md",key:"v-df747cda",path:"/webpack/init/index/",headers:[{level:2,title:"RoadMap",slug:"roadmap",normalizedTitle:"roadmap",charIndex:46},{level:2,title:"引用声明",slug:"引用声明",normalizedTitle:"引用声明",charIndex:60}],excerpt:"<TimeToRead />\n<p>本章内容将探讨 webpack 构建流程中的第一个阶段 init 阶段的实现原理。</p>\n",readingTime:{text:"1 min read",minutes:.135,time:8100.000000000002,words:27},headersStr:"RoadMap 引用声明",content:"本章内容将探讨 webpack 构建流程中的第一个阶段 init 阶段的实现原理。\n\n\n# RoadMap\n\n\n\n\n# 引用声明\n\n * Webpack Init RoadMap 图原作者为 范文杰 ，请访问原作：[万字总结] 一文吃透 Webpack 核心原理 - 知乎",normalizedContent:"本章内容将探讨 webpack 构建流程中的第一个阶段 init 阶段的实现原理。\n\n\n# roadmap\n\n\n\n\n# 引用声明\n\n * webpack init roadmap 图原作者为 范文杰 ，请访问原作：[万字总结] 一文吃透 webpack 核心原理 - 知乎",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"init 阶段：compiler",frontmatter:{title:"init 阶段：compiler",date:"2022-04-21T10:16:49.000Z",permalink:"/webpack/init/compiler/",categories:["webpack","init阶段"],tags:[null]},regularPath:"/30.web/7.webpack/20.init%E9%98%B6%E6%AE%B5/10.compiler.html",relativePath:"30.web/7.webpack/20.init阶段/10.compiler.md",key:"v-c36c87c2",path:"/webpack/init/compiler/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:97},{level:2,title:"webpack",slug:"webpack",normalizedTitle:"webpack",charIndex:6},{level:2,title:"createCompiler",slug:"createcompiler",normalizedTitle:"createcompiler",charIndex:123},{level:2,title:"compiler.run",slug:"compiler-run",normalizedTitle:"compiler.run",charIndex:80},{level:2,title:"compiler.compile",slug:"compiler-compile",normalizedTitle:"compiler.compile",charIndex:157},{level:3,title:"newCompilationParams",slug:"newcompilationparams",normalizedTitle:"newcompilationparams",charIndex:179},{level:3,title:"newCompilation",slug:"newcompilation",normalizedTitle:"newcompilation",charIndex:179},{level:2,title:"compilation.addEntry",slug:"compilation-addentry",normalizedTitle:"compilation.addentry",charIndex:223},{level:2,title:"compiler.Hook",slug:"compiler-hook",normalizedTitle:"compiler.hook",charIndex:247},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:264}],excerpt:"<TimeToRead />\n<p>本节将探讨 webpack 构建流程中 init 阶段的如下工作：</p>\n<ul>\n<li>options 初始化</li>\n<li>compiler 初始化</li>\n<li>编译环境初始化</li>\n<li>compiler.run</li>\n</ul>\n",readingTime:{text:"7 min read",minutes:7.005,time:420300,words:1401},headersStr:"目录 webpack createCompiler compiler.run compiler.compile newCompilationParams newCompilation compilation.addEntry compiler.Hook 参考",content:'本节将探讨 webpack 构建流程中 init 阶段的如下工作：\n\n * options 初始化\n * compiler 初始化\n * 编译环境初始化\n * compiler.run\n\n\n# 目录\n\n\n\n * 目录\n * webpack\n * createCompiler\n * compiler.run\n * compiler.compile\n   * newCompilationParams\n   * newCompilation\n * compilation.addEntry\n * compiler.Hook\n * 参考\n\n\n\n\n# webpack\n\n// lib/webpack.js\nconst webpack = (options, callback) => {\n  const create = () => {\n      // 校验 options\n   if (!asArray(options).every(webpackOptionsSchemaCheck)) {\n    getValidateSchema()(webpackOptionsSchema, options);\n   }\n   let compiler;\n   let watch = false;\n   let watchOptions;\n   //  options 是数组，创建 MultiCompiler\n   if (Array.isArray(options)) {\n    compiler = createMultiCompiler(\n     options,\n    );\n    // 收集 watch 和 watchOptions\n    watch = options.some(options => options.watch);\n    watchOptions = options.map(options => options.watchOptions || {});\n   } else {\n    const webpackOptions = (options);\n    // 创建 compiler\n    compiler = createCompiler(webpackOptions);\n    watch = webpackOptions.watch;\n    watchOptions = webpackOptions.watchOptions || {};\n   }\n   return { compiler, watch, watchOptions };\n  };\n  if (callback) {\n   try {\n    const { compiler, watch, watchOptions } = create();\n    if (watch) {\n      // 配置了 watch，开启 Watching\n     compiler.watch(watchOptions, callback);\n    } else {\n     // 启动 compiler\n     compiler.run((err, stats) => {\n      // compile 完毕，关闭 compiler\n      compiler.close(err2 => {\n       callback(err || err2, stats);\n      });\n     });\n    }\n    return compiler;\n   } catch (err) {\n    process.nextTick(() => callback(err));\n    return null;\n   }\n  } else {\n   const { compiler, watch } = create();\n   //  ......\n   return compiler;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n下面是精简代码：\n\nconst webpack = (options, callback) => {\n // 校验 options\n if (!asArray(options).every(webpackOptionsSchemaCheck)) {\n  getValidateSchema()(webpackOptionsSchema, options);\n }\n\n // 创建 compiler\n const compiler = createCompiler(options);\n\n // 启动 compiler\n compiler.run((err, stats) => {\n  // compile 完毕，关闭 compiler\n  compiler.close((err2) => {\n   callback(err || err2, stats);\n  });\n });\n\n return compiler;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n总结一下核心的作用：\n\n * 校验 options\n * 根据 options 生成并启动 compiler\n\n\n# createCompiler\n\n// lib/webpack.js\nconst createCompiler = rawOptions => {\n  // options 规整化\n const options = getNormalizedWebpackOptions(rawOptions);\n  // merge webpack 基础默认的 options：context、infrastructureLogging\n applyWebpackOptionsBaseDefaults(options);\n  // 新建 Compiler\n const compiler = new Compiler(options.context, options);\n  // ========== 注册插件 ========== //\n  // 注册 NodeEnvironmentPlugin：beforeRun => 初始化 Node 环境 \n new NodeEnvironmentPlugin({\n  infrastructureLogging: options.infrastructureLogging\n }).apply(compiler);\n  // 注册 options.plugins\n if (Array.isArray(options.plugins)) {\n  for (const plugin of options.plugins) {\n   if (typeof plugin === "function") {\n    plugin.call(compiler, compiler);\n   } else {\n    plugin.apply(compiler);\n   }\n  }\n }\n  // merge webpack 默认 options: context、target、devtool等\n applyWebpackOptionsDefaults(options);\n  // 触发 Hook.environment => call\n compiler.hooks.environment.call();\n  // 触发 Hook.afterEnvironment => call\n compiler.hooks.afterEnvironment.call();\n  // WebpackOptionsApply 根据 options 注册内置插件\n new WebpackOptionsApply().process(options, compiler);\n  // 触发 Hook.initialize => call\n compiler.hooks.initialize.call();\n  // 返回 compiler\n return compiler;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n总结核心作用如下：\n\n * options 规整化、merge 默认的 options\n * 创建 compiler 并返回\n * 注册插件 NodeEnvironmentPlugin、options.plugins、基于 options 的内置插件\n * 依次触发 Hook.environment、Hook.afterEnvironment、Hook.initialize\n\n\n# compiler.run\n\nrun(callback) {\n  // 如果 compiler 已经在运行则报错\n  if (this.running) {\n    return callback(new ConcurrentCompilationError());\n  }\n\n  // 仅在出现 err 时执行\n  const finalCallback = (err, stats) => {\n    // 将 compiler 标记为 idle\n    this.idle = true;\n    // 触发 CacheHook.beginIdle => call\n    this.cache.beginIdle();\n    this.idle = true;\n    // 标记 compiler running 为 false\n    this.running = false;\n    if (err) {\n      // 触发 Hook.failed => call\n      this.hooks.failed.call(err);\n    }\n    if (callback !== undefined) callback(err, stats);\n    // 触发 Hook.afterDone => call\n    this.hooks.afterDone.call(stats);\n  };\n\n  // 标记 running 为 true\n  this.running = true;\n\n  const run = () => {\n    // 触发 Hook.beforeRun: callAsync \n    this.hooks.beforeRun.callAsync(this, err => {\n      if (err) return finalCallback(err);\n      // 触发 Hook.run: callAsync\n      this.hooks.run.callAsync(this, err => {\n        if (err) return finalCallback(err);\n        // 尝试从 records 恢复，反序列化\n        this.readRecords(err => {\n          if (err) return finalCallback(err);\n          // 开始 compile\n          this.compile(onCompiled);\n        });\n      });\n    });\n  };\n  // 初始为 false\n  if (this.idle) {\n    // 触发 CacheHook.endIdle\n    this.cache.endIdle(err => {\n      if (err) return finalCallback(err);\n      \n      this.idle = false;\n      run();\n    });\n  } else {\n    run();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n总结一下核心作用：\n\n * 如果 compiler 为 idle 状态，触发 CacheHook.endIdle，并且执行 run。否则直接执行 run。\n * compiler.run 依次触发 Hook.beforeRun、Hook.run。尝试从序列化的 records（compiler 的状态） 中恢复，并且调用 compile，compile 完成后执行 onCompiled。标记 compiler 为 running。\n * 发生错误时执行 finalCallback，调用上层 callback，将 compile 标记为 idle，触发 CacheHook.beginIdle、Hook.failed 和 Hook.afterDone。去除 compiler 的 running 标记。\n\n\n# compiler.compile\n\n// lib/Compiler.js\ncompile(callback) {\n    // 使用缓存的 compilationParams\n  const params = this.newCompilationParams();\n    // 触发 Hook.beforeCompile => callAsync\n  this.hooks.beforeCompile.callAsync(params, err => {\n   if (err) return callback(err);\n      // 触发 Hook.compile => call\n   this.hooks.compile.call(params);\n      // 使用缓存的 compilation 对象\n   const compilation = this.newCompilation(params);\n\n   // 触发 Hook.make => callAsync\n   this.hooks.make.callAsync(compilation, err => {\n    if (err) return callback(err);\n    \n    // 触发 Hook.finishMake => callAsync\n    this.hooks.finishMake.callAsync(compilation, err => {\n     if (err) return callback(err);\n\n     process.nextTick(() => {\n      // compilation.finish\n      compilation.finish(err => {\n       if (err) return callback(err);\n\n       // compilation.seal\n       compilation.seal(err => {\n        if (err) return callback(err);\n\n        // 触发 Hook.afterCompile => callAsync\n        this.hooks.afterCompile.callAsync(compilation, err => {\n         if (err) return callback(err);\n\n         return callback(null, compilation);\n        });\n       });\n      });\n     });\n    });\n   });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\ncompile 的代码高度抽象化，具体的业务逻辑都封装到相应的插件中了。\n\n总结一下核心作用：\n\n * 依次触发 Hook.beforeCompile、Hook.compile、Hook.make、Hook.finishMake、Hook.afterCompile。\n * compilation：创建 compilation 对象、触发 Hook.make、Hook.finishMake、执行 compilation.finish、compilation.seal、触发 Hook.afterCompile。\n\n\n# newCompilationParams\n\n这个函数或创建 normalModuleFactory 和 contextModuleFactory。\n\nnewCompilationParams() {\nconst params = {\n  // new NormalModuleFactory()\n  normalModuleFactory: this.createNormalModuleFactory(),\n  // new ContextModuleFactory()\n  contextModuleFactory: this.createContextModuleFactory()\n};\nreturn params;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# newCompilation\n\n// lib/Compiler.js\ncreateCompilation(params) {\n  // 注意：这里并不会频繁实例化类，而是在 _cleanupLastCompilation 中将 _lastCompilation 清理之后复用\n this._cleanupLastCompilation();\n return (this._lastCompilation = new Compilation(this, params));\n}\nnewCompilation(params) {\n  // 创建 compilation 实例\n const compilation = this.createCompilation(params);\n compilation.name = this.name;\n compilation.records = this.records;\n  // 触发 Hook.thisCompilation => call\n this.hooks.thisCompilation.call(compilation, params);\n  // 触发 Hook.compilation => call\n this.hooks.compilation.call(compilation, params);\n return compilation;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n核心作用如下：\n\n * 创建或者复用 compilation。\n * 依次触发 Hook.thisCompilation、Hook.compilation。\n\n\n# compilation.addEntry\n\n在 createCompiler 中我们了解到 new WebpackOptionsApply().process(options, compiler) 会根据 options 来注册各种不同的插件。\n\n// lib/WebpackOptionsApply.js\nnew EntryOptionPlugin().apply(compiler);\n// 触发 Hook.entryOption => call\ncompiler.hooks.entryOption.call(options.context, options.entry);\n\n\n1\n2\n3\n4\n\n\n我们来探讨下这里注册的 EntryOptionPlugin 插件：\n\n// lib/EntryOptionPlugin.js\nclass EntryOptionPlugin {\n // ......\n apply(compiler) {\n  // 注册 Callback: Hook.entryOption， Hook.entryOption 触发时，将执行 applyEntryOption\n  // Hook.entryOption 在此插件注册完毕后就会被触发\n  compiler.hooks.entryOption.tap("EntryOptionPlugin", (context, entry) => {\n   EntryOptionPlugin.applyEntryOption(compiler, context, entry);\n   return true;\n  });\n }\n\n static applyEntryOption(compiler, context, entry) {\n  // entry 是函数，注册 DynamicEntryPlugin\n  if (typeof entry === "function") {\n   const DynamicEntryPlugin = require("./DynamicEntryPlugin");\n   new DynamicEntryPlugin(context, entry).apply(compiler);\n  } else {\n   // entry 是 object，注册 EntryPlugin\n   const EntryPlugin = require("./EntryPlugin");\n   // 循环 entries 将 entry 生成 options\n   //  entry: {\n   //   b2: {\n   //     dependOn: \'a2\',\n   //     import: \'./src/app.js\',\n   //   },\n   // },\n   for (const name of Object.keys(entry)) {\n    const desc = entry[name];\n    const options = EntryOptionPlugin.entryDescriptionToOptions(\n     compiler,\n     name,\n     desc\n    );\n    // 对于 entry 中每一个入口路径，注册插件 EntryPlugin\n    for (const entry of desc.import) {\n     new EntryPlugin(context, entry, options).apply(compiler);\n    }\n   }\n  }\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n总结一下：\n\n * createCompiler 中注册 WebpackOptionsApply 插件时，会注册 EntryOptionPlugin 插件，在随后的 Hook.entryOption 调用时，为每个 Entry 的 import 都注册了插件 EntryPlugin 。\n * 对每个 Entry.import 所注册的 EntryPlugin 将会初始化打包入口。\n\n接着来探讨下 EntryPlugin 插件：\n\nclass EntryPlugin {\n apply(compiler) {\n  // 注册 Callback：Hook.compilation\n  // Hook.compilation 在  compiler.compile 函数中触发\n  compiler.hooks.compilation.tap(\n   "EntryPlugin",\n   (compilation, { normalModuleFactory }) => {\n    // dependencyFactories 记录某种 Dependency 应用哪种 ModuleFactory\n    // 记录 EntryDependency 使用 normalModuleFactory\n    compilation.dependencyFactories.set(\n     EntryDependency,\n     normalModuleFactory\n    );\n   }\n  );\n\n  const { entry, options, context } = this;\n  // 静态方法创建 EntryDependency\n  const dep = EntryPlugin.createDependency(entry, options);\n  // 注册 Callback： Hook.make => tapAsync\n  // Hook.make 在  compiler.compile 函数中触发\n  compiler.hooks.make.tapAsync("EntryPlugin", (compilation, callback) => {\n   // compilation.addEntry 添加 Entry，目的是创建 EntryDependency\n   compilation.addEntry(context, dep, options, (err) => {\n    callback(err);\n   });\n  });\n }\n\n static createDependency(entry, options) {\n  // 创建 EntryDependency 对象\n  const dep = new EntryDependency(entry);\n  // TODO webpack 6 remove string option\n  dep.loc = { name: typeof options === "object" ? options.name : options };\n  return dep;\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n总结一下：\n\n * 在 Hook.compilation 触发时记录 EntryDependency 使用 normalModuleFactory，创建 EntryDependency，并在 Hook.make 触发时执行 compilation.addEntry 。\n\n\n# compiler.Hook\n\ncompiler 有如下的 Hook。\n\nthis.hooks = Object.freeze({\n  /** @type {SyncHook<[]>} */\n  initialize: new SyncHook([]),\n\n  /** @type {SyncBailHook<[Compilation], boolean>} */\n  shouldEmit: new SyncBailHook(["compilation"]),\n  /** @type {AsyncSeriesHook<[Stats]>} */\n  done: new AsyncSeriesHook(["stats"]),\n  /** @type {SyncHook<[Stats]>} */\n  afterDone: new SyncHook(["stats"]),\n  /** @type {AsyncSeriesHook<[]>} */\n  additionalPass: new AsyncSeriesHook([]),\n  /** @type {AsyncSeriesHook<[Compiler]>} */\n  beforeRun: new AsyncSeriesHook(["compiler"]),\n  /** @type {AsyncSeriesHook<[Compiler]>} */\n  run: new AsyncSeriesHook(["compiler"]),\n  /** @type {AsyncSeriesHook<[Compilation]>} */\n  emit: new AsyncSeriesHook(["compilation"]),\n  /** @type {AsyncSeriesHook<[string, AssetEmittedInfo]>} */\n  assetEmitted: new AsyncSeriesHook(["file", "info"]),\n  /** @type {AsyncSeriesHook<[Compilation]>} */\n  afterEmit: new AsyncSeriesHook(["compilation"]),\n\n  /** @type {SyncHook<[Compilation, CompilationParams]>} */\n  thisCompilation: new SyncHook(["compilation", "params"]),\n  /** @type {SyncHook<[Compilation, CompilationParams]>} */\n  compilation: new SyncHook(["compilation", "params"]),\n  /** @type {SyncHook<[NormalModuleFactory]>} */\n  normalModuleFactory: new SyncHook(["normalModuleFactory"]),\n  /** @type {SyncHook<[ContextModuleFactory]>}  */\n  contextModuleFactory: new SyncHook(["contextModuleFactory"]),\n\n  /** @type {AsyncSeriesHook<[CompilationParams]>} */\n  beforeCompile: new AsyncSeriesHook(["params"]),\n  /** @type {SyncHook<[CompilationParams]>} */\n  compile: new SyncHook(["params"]),\n  /** @type {AsyncParallelHook<[Compilation]>} */\n  make: new AsyncParallelHook(["compilation"]),\n  /** @type {AsyncParallelHook<[Compilation]>} */\n  finishMake: new AsyncSeriesHook(["compilation"]),\n  /** @type {AsyncSeriesHook<[Compilation]>} */\n  afterCompile: new AsyncSeriesHook(["compilation"]),\n\n  /** @type {AsyncSeriesHook<[]>} */\n  readRecords: new AsyncSeriesHook([]),\n  /** @type {AsyncSeriesHook<[]>} */\n  emitRecords: new AsyncSeriesHook([]),\n\n  /** @type {AsyncSeriesHook<[Compiler]>} */\n  watchRun: new AsyncSeriesHook(["compiler"]),\n  /** @type {SyncHook<[Error]>} */\n  failed: new SyncHook(["error"]),\n  /** @type {SyncHook<[string | null, number]>} */\n  invalid: new SyncHook(["filename", "changeTime"]),\n  /** @type {SyncHook<[]>} */\n  watchClose: new SyncHook([]),\n  /** @type {AsyncSeriesHook<[]>} */\n  shutdown: new AsyncSeriesHook([]),\n\n  /** @type {SyncBailHook<[string, string, any[]], true>} */\n  infrastructureLog: new SyncBailHook(["origin", "type", "args"]),\n\n  /** @type {SyncHook<[]>} */\n  environment: new SyncHook([]),\n  /** @type {SyncHook<[]>} */\n  afterEnvironment: new SyncHook([]),\n  /** @type {SyncHook<[Compiler]>} */\n  afterPlugins: new SyncHook(["compiler"]),\n  /** @type {SyncHook<[Compiler]>} */\n  afterResolvers: new SyncHook(["compiler"]),\n  /** @type {SyncBailHook<[string, Entry], boolean>} */\n  entryOption: new SyncBailHook(["context", "entry"])\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n\n注意：Object.freeze 只冻结顶层，Callbacks 并不会被冻结。\n\n\n# 参考\n\n * suguru03/neo-async: Neo-Async is thought to be used as a drop-in replacement for Async, it almost fully covers its functionality and runs faster\n * compiler 钩子 | webpack 中文文档',normalizedContent:'本节将探讨 webpack 构建流程中 init 阶段的如下工作：\n\n * options 初始化\n * compiler 初始化\n * 编译环境初始化\n * compiler.run\n\n\n# 目录\n\n\n\n * 目录\n * webpack\n * createcompiler\n * compiler.run\n * compiler.compile\n   * newcompilationparams\n   * newcompilation\n * compilation.addentry\n * compiler.hook\n * 参考\n\n\n\n\n# webpack\n\n// lib/webpack.js\nconst webpack = (options, callback) => {\n  const create = () => {\n      // 校验 options\n   if (!asarray(options).every(webpackoptionsschemacheck)) {\n    getvalidateschema()(webpackoptionsschema, options);\n   }\n   let compiler;\n   let watch = false;\n   let watchoptions;\n   //  options 是数组，创建 multicompiler\n   if (array.isarray(options)) {\n    compiler = createmulticompiler(\n     options,\n    );\n    // 收集 watch 和 watchoptions\n    watch = options.some(options => options.watch);\n    watchoptions = options.map(options => options.watchoptions || {});\n   } else {\n    const webpackoptions = (options);\n    // 创建 compiler\n    compiler = createcompiler(webpackoptions);\n    watch = webpackoptions.watch;\n    watchoptions = webpackoptions.watchoptions || {};\n   }\n   return { compiler, watch, watchoptions };\n  };\n  if (callback) {\n   try {\n    const { compiler, watch, watchoptions } = create();\n    if (watch) {\n      // 配置了 watch，开启 watching\n     compiler.watch(watchoptions, callback);\n    } else {\n     // 启动 compiler\n     compiler.run((err, stats) => {\n      // compile 完毕，关闭 compiler\n      compiler.close(err2 => {\n       callback(err || err2, stats);\n      });\n     });\n    }\n    return compiler;\n   } catch (err) {\n    process.nexttick(() => callback(err));\n    return null;\n   }\n  } else {\n   const { compiler, watch } = create();\n   //  ......\n   return compiler;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n下面是精简代码：\n\nconst webpack = (options, callback) => {\n // 校验 options\n if (!asarray(options).every(webpackoptionsschemacheck)) {\n  getvalidateschema()(webpackoptionsschema, options);\n }\n\n // 创建 compiler\n const compiler = createcompiler(options);\n\n // 启动 compiler\n compiler.run((err, stats) => {\n  // compile 完毕，关闭 compiler\n  compiler.close((err2) => {\n   callback(err || err2, stats);\n  });\n });\n\n return compiler;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n总结一下核心的作用：\n\n * 校验 options\n * 根据 options 生成并启动 compiler\n\n\n# createcompiler\n\n// lib/webpack.js\nconst createcompiler = rawoptions => {\n  // options 规整化\n const options = getnormalizedwebpackoptions(rawoptions);\n  // merge webpack 基础默认的 options：context、infrastructurelogging\n applywebpackoptionsbasedefaults(options);\n  // 新建 compiler\n const compiler = new compiler(options.context, options);\n  // ========== 注册插件 ========== //\n  // 注册 nodeenvironmentplugin：beforerun => 初始化 node 环境 \n new nodeenvironmentplugin({\n  infrastructurelogging: options.infrastructurelogging\n }).apply(compiler);\n  // 注册 options.plugins\n if (array.isarray(options.plugins)) {\n  for (const plugin of options.plugins) {\n   if (typeof plugin === "function") {\n    plugin.call(compiler, compiler);\n   } else {\n    plugin.apply(compiler);\n   }\n  }\n }\n  // merge webpack 默认 options: context、target、devtool等\n applywebpackoptionsdefaults(options);\n  // 触发 hook.environment => call\n compiler.hooks.environment.call();\n  // 触发 hook.afterenvironment => call\n compiler.hooks.afterenvironment.call();\n  // webpackoptionsapply 根据 options 注册内置插件\n new webpackoptionsapply().process(options, compiler);\n  // 触发 hook.initialize => call\n compiler.hooks.initialize.call();\n  // 返回 compiler\n return compiler;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n总结核心作用如下：\n\n * options 规整化、merge 默认的 options\n * 创建 compiler 并返回\n * 注册插件 nodeenvironmentplugin、options.plugins、基于 options 的内置插件\n * 依次触发 hook.environment、hook.afterenvironment、hook.initialize\n\n\n# compiler.run\n\nrun(callback) {\n  // 如果 compiler 已经在运行则报错\n  if (this.running) {\n    return callback(new concurrentcompilationerror());\n  }\n\n  // 仅在出现 err 时执行\n  const finalcallback = (err, stats) => {\n    // 将 compiler 标记为 idle\n    this.idle = true;\n    // 触发 cachehook.beginidle => call\n    this.cache.beginidle();\n    this.idle = true;\n    // 标记 compiler running 为 false\n    this.running = false;\n    if (err) {\n      // 触发 hook.failed => call\n      this.hooks.failed.call(err);\n    }\n    if (callback !== undefined) callback(err, stats);\n    // 触发 hook.afterdone => call\n    this.hooks.afterdone.call(stats);\n  };\n\n  // 标记 running 为 true\n  this.running = true;\n\n  const run = () => {\n    // 触发 hook.beforerun: callasync \n    this.hooks.beforerun.callasync(this, err => {\n      if (err) return finalcallback(err);\n      // 触发 hook.run: callasync\n      this.hooks.run.callasync(this, err => {\n        if (err) return finalcallback(err);\n        // 尝试从 records 恢复，反序列化\n        this.readrecords(err => {\n          if (err) return finalcallback(err);\n          // 开始 compile\n          this.compile(oncompiled);\n        });\n      });\n    });\n  };\n  // 初始为 false\n  if (this.idle) {\n    // 触发 cachehook.endidle\n    this.cache.endidle(err => {\n      if (err) return finalcallback(err);\n      \n      this.idle = false;\n      run();\n    });\n  } else {\n    run();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n总结一下核心作用：\n\n * 如果 compiler 为 idle 状态，触发 cachehook.endidle，并且执行 run。否则直接执行 run。\n * compiler.run 依次触发 hook.beforerun、hook.run。尝试从序列化的 records（compiler 的状态） 中恢复，并且调用 compile，compile 完成后执行 oncompiled。标记 compiler 为 running。\n * 发生错误时执行 finalcallback，调用上层 callback，将 compile 标记为 idle，触发 cachehook.beginidle、hook.failed 和 hook.afterdone。去除 compiler 的 running 标记。\n\n\n# compiler.compile\n\n// lib/compiler.js\ncompile(callback) {\n    // 使用缓存的 compilationparams\n  const params = this.newcompilationparams();\n    // 触发 hook.beforecompile => callasync\n  this.hooks.beforecompile.callasync(params, err => {\n   if (err) return callback(err);\n      // 触发 hook.compile => call\n   this.hooks.compile.call(params);\n      // 使用缓存的 compilation 对象\n   const compilation = this.newcompilation(params);\n\n   // 触发 hook.make => callasync\n   this.hooks.make.callasync(compilation, err => {\n    if (err) return callback(err);\n    \n    // 触发 hook.finishmake => callasync\n    this.hooks.finishmake.callasync(compilation, err => {\n     if (err) return callback(err);\n\n     process.nexttick(() => {\n      // compilation.finish\n      compilation.finish(err => {\n       if (err) return callback(err);\n\n       // compilation.seal\n       compilation.seal(err => {\n        if (err) return callback(err);\n\n        // 触发 hook.aftercompile => callasync\n        this.hooks.aftercompile.callasync(compilation, err => {\n         if (err) return callback(err);\n\n         return callback(null, compilation);\n        });\n       });\n      });\n     });\n    });\n   });\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\ncompile 的代码高度抽象化，具体的业务逻辑都封装到相应的插件中了。\n\n总结一下核心作用：\n\n * 依次触发 hook.beforecompile、hook.compile、hook.make、hook.finishmake、hook.aftercompile。\n * compilation：创建 compilation 对象、触发 hook.make、hook.finishmake、执行 compilation.finish、compilation.seal、触发 hook.aftercompile。\n\n\n# newcompilationparams\n\n这个函数或创建 normalmodulefactory 和 contextmodulefactory。\n\nnewcompilationparams() {\nconst params = {\n  // new normalmodulefactory()\n  normalmodulefactory: this.createnormalmodulefactory(),\n  // new contextmodulefactory()\n  contextmodulefactory: this.createcontextmodulefactory()\n};\nreturn params;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# newcompilation\n\n// lib/compiler.js\ncreatecompilation(params) {\n  // 注意：这里并不会频繁实例化类，而是在 _cleanuplastcompilation 中将 _lastcompilation 清理之后复用\n this._cleanuplastcompilation();\n return (this._lastcompilation = new compilation(this, params));\n}\nnewcompilation(params) {\n  // 创建 compilation 实例\n const compilation = this.createcompilation(params);\n compilation.name = this.name;\n compilation.records = this.records;\n  // 触发 hook.thiscompilation => call\n this.hooks.thiscompilation.call(compilation, params);\n  // 触发 hook.compilation => call\n this.hooks.compilation.call(compilation, params);\n return compilation;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n核心作用如下：\n\n * 创建或者复用 compilation。\n * 依次触发 hook.thiscompilation、hook.compilation。\n\n\n# compilation.addentry\n\n在 createcompiler 中我们了解到 new webpackoptionsapply().process(options, compiler) 会根据 options 来注册各种不同的插件。\n\n// lib/webpackoptionsapply.js\nnew entryoptionplugin().apply(compiler);\n// 触发 hook.entryoption => call\ncompiler.hooks.entryoption.call(options.context, options.entry);\n\n\n1\n2\n3\n4\n\n\n我们来探讨下这里注册的 entryoptionplugin 插件：\n\n// lib/entryoptionplugin.js\nclass entryoptionplugin {\n // ......\n apply(compiler) {\n  // 注册 callback: hook.entryoption， hook.entryoption 触发时，将执行 applyentryoption\n  // hook.entryoption 在此插件注册完毕后就会被触发\n  compiler.hooks.entryoption.tap("entryoptionplugin", (context, entry) => {\n   entryoptionplugin.applyentryoption(compiler, context, entry);\n   return true;\n  });\n }\n\n static applyentryoption(compiler, context, entry) {\n  // entry 是函数，注册 dynamicentryplugin\n  if (typeof entry === "function") {\n   const dynamicentryplugin = require("./dynamicentryplugin");\n   new dynamicentryplugin(context, entry).apply(compiler);\n  } else {\n   // entry 是 object，注册 entryplugin\n   const entryplugin = require("./entryplugin");\n   // 循环 entries 将 entry 生成 options\n   //  entry: {\n   //   b2: {\n   //     dependon: \'a2\',\n   //     import: \'./src/app.js\',\n   //   },\n   // },\n   for (const name of object.keys(entry)) {\n    const desc = entry[name];\n    const options = entryoptionplugin.entrydescriptiontooptions(\n     compiler,\n     name,\n     desc\n    );\n    // 对于 entry 中每一个入口路径，注册插件 entryplugin\n    for (const entry of desc.import) {\n     new entryplugin(context, entry, options).apply(compiler);\n    }\n   }\n  }\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n总结一下：\n\n * createcompiler 中注册 webpackoptionsapply 插件时，会注册 entryoptionplugin 插件，在随后的 hook.entryoption 调用时，为每个 entry 的 import 都注册了插件 entryplugin 。\n * 对每个 entry.import 所注册的 entryplugin 将会初始化打包入口。\n\n接着来探讨下 entryplugin 插件：\n\nclass entryplugin {\n apply(compiler) {\n  // 注册 callback：hook.compilation\n  // hook.compilation 在  compiler.compile 函数中触发\n  compiler.hooks.compilation.tap(\n   "entryplugin",\n   (compilation, { normalmodulefactory }) => {\n    // dependencyfactories 记录某种 dependency 应用哪种 modulefactory\n    // 记录 entrydependency 使用 normalmodulefactory\n    compilation.dependencyfactories.set(\n     entrydependency,\n     normalmodulefactory\n    );\n   }\n  );\n\n  const { entry, options, context } = this;\n  // 静态方法创建 entrydependency\n  const dep = entryplugin.createdependency(entry, options);\n  // 注册 callback： hook.make => tapasync\n  // hook.make 在  compiler.compile 函数中触发\n  compiler.hooks.make.tapasync("entryplugin", (compilation, callback) => {\n   // compilation.addentry 添加 entry，目的是创建 entrydependency\n   compilation.addentry(context, dep, options, (err) => {\n    callback(err);\n   });\n  });\n }\n\n static createdependency(entry, options) {\n  // 创建 entrydependency 对象\n  const dep = new entrydependency(entry);\n  // todo webpack 6 remove string option\n  dep.loc = { name: typeof options === "object" ? options.name : options };\n  return dep;\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n总结一下：\n\n * 在 hook.compilation 触发时记录 entrydependency 使用 normalmodulefactory，创建 entrydependency，并在 hook.make 触发时执行 compilation.addentry 。\n\n\n# compiler.hook\n\ncompiler 有如下的 hook。\n\nthis.hooks = object.freeze({\n  /** @type {synchook<[]>} */\n  initialize: new synchook([]),\n\n  /** @type {syncbailhook<[compilation], boolean>} */\n  shouldemit: new syncbailhook(["compilation"]),\n  /** @type {asyncserieshook<[stats]>} */\n  done: new asyncserieshook(["stats"]),\n  /** @type {synchook<[stats]>} */\n  afterdone: new synchook(["stats"]),\n  /** @type {asyncserieshook<[]>} */\n  additionalpass: new asyncserieshook([]),\n  /** @type {asyncserieshook<[compiler]>} */\n  beforerun: new asyncserieshook(["compiler"]),\n  /** @type {asyncserieshook<[compiler]>} */\n  run: new asyncserieshook(["compiler"]),\n  /** @type {asyncserieshook<[compilation]>} */\n  emit: new asyncserieshook(["compilation"]),\n  /** @type {asyncserieshook<[string, assetemittedinfo]>} */\n  assetemitted: new asyncserieshook(["file", "info"]),\n  /** @type {asyncserieshook<[compilation]>} */\n  afteremit: new asyncserieshook(["compilation"]),\n\n  /** @type {synchook<[compilation, compilationparams]>} */\n  thiscompilation: new synchook(["compilation", "params"]),\n  /** @type {synchook<[compilation, compilationparams]>} */\n  compilation: new synchook(["compilation", "params"]),\n  /** @type {synchook<[normalmodulefactory]>} */\n  normalmodulefactory: new synchook(["normalmodulefactory"]),\n  /** @type {synchook<[contextmodulefactory]>}  */\n  contextmodulefactory: new synchook(["contextmodulefactory"]),\n\n  /** @type {asyncserieshook<[compilationparams]>} */\n  beforecompile: new asyncserieshook(["params"]),\n  /** @type {synchook<[compilationparams]>} */\n  compile: new synchook(["params"]),\n  /** @type {asyncparallelhook<[compilation]>} */\n  make: new asyncparallelhook(["compilation"]),\n  /** @type {asyncparallelhook<[compilation]>} */\n  finishmake: new asyncserieshook(["compilation"]),\n  /** @type {asyncserieshook<[compilation]>} */\n  aftercompile: new asyncserieshook(["compilation"]),\n\n  /** @type {asyncserieshook<[]>} */\n  readrecords: new asyncserieshook([]),\n  /** @type {asyncserieshook<[]>} */\n  emitrecords: new asyncserieshook([]),\n\n  /** @type {asyncserieshook<[compiler]>} */\n  watchrun: new asyncserieshook(["compiler"]),\n  /** @type {synchook<[error]>} */\n  failed: new synchook(["error"]),\n  /** @type {synchook<[string | null, number]>} */\n  invalid: new synchook(["filename", "changetime"]),\n  /** @type {synchook<[]>} */\n  watchclose: new synchook([]),\n  /** @type {asyncserieshook<[]>} */\n  shutdown: new asyncserieshook([]),\n\n  /** @type {syncbailhook<[string, string, any[]], true>} */\n  infrastructurelog: new syncbailhook(["origin", "type", "args"]),\n\n  /** @type {synchook<[]>} */\n  environment: new synchook([]),\n  /** @type {synchook<[]>} */\n  afterenvironment: new synchook([]),\n  /** @type {synchook<[compiler]>} */\n  afterplugins: new synchook(["compiler"]),\n  /** @type {synchook<[compiler]>} */\n  afterresolvers: new synchook(["compiler"]),\n  /** @type {syncbailhook<[string, entry], boolean>} */\n  entryoption: new syncbailhook(["context", "entry"])\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n\n注意：object.freeze 只冻结顶层，callbacks 并不会被冻结。\n\n\n# 参考\n\n * suguru03/neo-async: neo-async is thought to be used as a drop-in replacement for async, it almost fully covers its functionality and runs faster\n * compiler 钩子 | webpack 中文文档',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"init 阶段：options",frontmatter:{title:"init 阶段：options",date:"2022-04-22T15:26:43.000Z",permalink:"/webpack/init/options/",categories:["webpack","init阶段"],tags:[null]},regularPath:"/30.web/7.webpack/20.init%E9%98%B6%E6%AE%B5/20.options.html",relativePath:"30.web/7.webpack/20.init阶段/20.options.md",key:"v-397f75f5",path:"/webpack/init/options/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:91},{level:2,title:"getNormalizedWebpackOptions",slug:"getnormalizedwebpackoptions",normalizedTitle:"getnormalizedwebpackoptions",charIndex:106},{level:2,title:"顶层 option",slug:"顶层-option",normalizedTitle:"顶层 option",charIndex:137},{level:2,title:"applyWebpackOptionsBaseDefaults 和 applyWebpackOptionsDefaults",slug:"applywebpackoptionsbasedefaults-和-applywebpackoptionsdefaults",normalizedTitle:"applywebpackoptionsbasedefaults 和 applywebpackoptionsdefaults",charIndex:150},{level:2,title:"NodeEnvironmentPlugin",slug:"nodeenvironmentplugin",normalizedTitle:"nodeenvironmentplugin",charIndex:215},{level:2,title:"WebpackOptionsApply",slug:"webpackoptionsapply",normalizedTitle:"webpackoptionsapply",charIndex:240},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:263}],excerpt:"<TimeToRead />\n<p>在上一节中，我们以 compiler 为主线探讨了 webpack 在 init 阶段的核心原理，在本节中我们将对 init 阶段 options 的处理进行更细化的探讨。</p>\n",readingTime:{text:"7 min read",minutes:6.83,time:409800,words:1366},headersStr:"目录 getNormalizedWebpackOptions 顶层 option applyWebpackOptionsBaseDefaults 和 applyWebpackOptionsDefaults NodeEnvironmentPlugin WebpackOptionsApply 参考",content:'在上一节中，我们以 compiler 为主线探讨了 webpack 在 init 阶段的核心原理，在本节中我们将对 init 阶段 options 的处理进行更细化的探讨。\n\n\n# 目录\n\n\n\n * 目录\n * getNormalizedWebpackOptions\n * 顶层 option\n * applyWebpackOptionsBaseDefaults 和 applyWebpackOptionsDefaults\n * NodeEnvironmentPlugin\n * WebpackOptionsApply\n * 参考\n\n\n\n\n# getNormalizedWebpackOptions\n\n// lib/config/normalization.js\nconst getNormalizedWebpackOptions = configs => {\n  // ......\n  return normalizedConfigs;\n};\n\n\n1\n2\n3\n4\n5\n\n\n这部分代码主要是校验和规整（normalize）options，代码很繁琐，甚至 option 都是按照字母顺序排序，与主流程关系不大，此处不再赘述。\n\n不过可以借此机会，熟悉下 webpack 的 顶层options 有哪些？\n\n\n# 顶层 option\n\nwebpack 配置有如下顶层 option。\n\nOPTION                  描述\namd                     设置 require.amd 或 define.amd 的值。设置 amd 为 false 会禁用 webpack 的\n                        AMD 支持。\nbail                    在第一个错误出现时抛出失败结果，而不是容忍它。这将迫使 webpack 退出其打包过程。\ncache                   缓存生成的 webpack 模块和 chunk，来改善 构建速度 。\ncontext                 基础目录，绝对路径，用于从配置中解析入口点 (entry point) 和 加载器 (loader)。默认使用\n                        Node.js 进程的当前工作目录。\ndependencies            一个 name 列表，定义它所依赖的所有兄弟（sibling）配置。需要首先编译依赖的配置。\ndevServer               配置 webpack-dev-server\ndevtool                 此选项控制是否生成，以及如何生成 source map。\nentry                   开始应用程序打包过程的一个或多个起点。如果传入数组，则会处理所有条目。一个需要考虑的规则：每个 HTML\n                        页面都有一个入口起点。单页应用 (SPA)：一个入口起点，多页应用 (MPA)：多个入口起点。\nexperiments             experiments 配置是在 webpack 5 中推出，目的是为了给用户赋能去开启并试用一些实验的特性。\nexternals               防止将某些 import 的包 (package) 打包到 bundle 中，而是在运行时 (runtime)\n                        再去从外部获取这些扩展依赖 (external dependencies)。\nexternalsPresets        为特定的 target 启用 externals 的 preset。\nexternalsType           指定 externals 的默认类型。当 external 被设置为 amd，umd，system 以及 jsonp\n                        时，output.libraryTarget 的值也应相同。\nignoreWarnings          告诉 webpack 忽略掉特定的警告。\ninfrastructureLogging   用于基础设施水平的日志选项。\nloader                  在 loader 上下文 中暴露自定义值。\nmode                    提供 mode 配置选项，告知 webpack 使用相应模式的内置优化。\nmodule                  这些选项决定了如何处理项目中的不同类型的模块。\n                        \nname                    配置的名称。当加载不同的配置时会被使用。\nnode                    这些选项可以配置是否 polyfill 或 mock 某些 Node.js 全局变量。此功能由 webpack 内部的\n                        NodeStuffPlugin 插件提供。\noptimization            从 webpack 4 开始，会根据你选择的 mode 来执行不同的优化， 不过所有的优化还是可以手动配置和重写。\noutput                  output 位于对象最顶级键 (key)，包括了一组选项，指示 webpack\n                        如何去输出、以及在哪里输出你的「bundle、asset 和其他你所打包或使用 webpack 载入的任何内容」。\nparallelism             限制并行处理的模块数量。可以用于调优性能或获取更可靠的性能分析结果。\nperformance             控制 webpack 如何通知「资源 (asset) 和入口起点超过指定文件限制」。\nplugins                 plugins 选项用于以各种方式自定义 webpack 构建过程。webpack 附带了各种内置插件，可以通过\n                        webpack.[plugin-name] 访问这些插件。\nprofile                 捕获一个应用程序 "配置文件"，包括统计和提示，然后可以使用 Analyze 分析工具进行详细分析。\nrecordsInputPath        指定读取最后一条记录的文件的名称。这可以用来重命名一个记录文件。\nrecordsOutputPath       指定记录要写入的位置。\nresolve                 这些选项能设置模块如何被解析。webpack 提供合理的默认值，但是还是可能会修改一些解析的细节。\nresolveLoader           这组选项与上面的 resolve 对象的属性集合相同， 但仅用于解析 webpack 的 loader 包。\nsnapshot                snapshot 配置项决定文件系统是如何创建和无效快照。\nstats                   stats 选项让你更精确地控制 bundle 信息该怎么显示。 如果你不希望使用 quiet 或 noInfo\n                        这样的不显示信息，而是又不想得到全部的信息，只是想要获取某部分 bundle 的信息，使用 stats\n                        选项是比较好的折衷方式。\ntarget                  webpack 能够为多种环境或 target 构建编译。告知 webpack 为目标 (target)\n                        指定一个环境。默认值为 "browserslist"，如果没有找到 browserslist 的配置，则默认为\n                        "web"\nwatch                   启用 Watch 模式。这意味着在初始构建之后，webpack 将继续监听任何已解析文件的更改。\nwatchOptions            一组用来定制 watch 模式的选项\n\n参考：\n\n * Why AMD?\n * Plugins | webpack 中文文档\n\n\n# applyWebpackOptionsBaseDefaults 和 applyWebpackOptionsDefaults\n\n这两个函数为 webpack 默认的 options 合并进应用配置的 options。\n\n以 applyWebpackOptionsDefaults 为例：\n\ncontext/target/devtool/watch/profile/parallelism/recordsInputPath/recordsOutputPath => cache => applySnapshotDefaults => applyModuleDefaults => applyOutputDefaults => applyExternalsPresetsDefaults => applyLoaderDefaults => externalsType => applyNodeDefaults => performance => applyPerformanceDefaults => applyOptimizationDefaults ......\n\n\n1\n\n\n下面开看下几个辅助函数：\n\n// Sets a constant default value when undefined\nconst D = (obj, prop, value) => {\n if (obj[prop] === undefined) {\n  obj[prop] = value;\n }\n};\n// Sets a dynamic default value when undefined, by calling the factory function\nconst F = (obj, prop, factory) => {\n if (obj[prop] === undefined) {\n  obj[prop] = factory();\n }\n};\n// \nconst A = (obj, prop, factory) => {\n const value = obj[prop];\n if (value === undefined) {\n  obj[prop] = factory();\n } else if (Array.isArray(value)) {\n  let newArray = undefined;\n  for (let i = 0; i < value.length; i++) {\n   const item = value[i];\n   if (item === "...") {\n    if (newArray === undefined) {\n     newArray = value.slice(0, i);\n     //  注意：newArray 是应用，赋值之后 newArray 仍然在变化\n     obj[prop] = newArray;\n    }\n    const items = factory();\n    if (items !== undefined) {\n     for (const item of items) {\n      newArray.push(item);\n     }\n    }\n   } else if (newArray !== undefined) {\n    newArray.push(item);\n   }\n  }\n }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# NodeEnvironmentPlugin\n\n此插件初始化 Node 环境，包括日志组件 infrastructureLogger、文件 io 组件 inputFileSystem、文件 watch 组件 watchFileSystem。\n\nclass NodeEnvironmentPlugin {\n apply(compiler) {\n  const { infrastructureLogging } = this.options;\n  // 初始化创建 infrastructureLogger\n  compiler.infrastructureLogger = createConsoleLogger(/** ...... */);\n  // 初始化文件系统相关，inputFileSystem 和 watchFileSystem\n  compiler.inputFileSystem = new CachedInputFileSystem(fs, 60000);\n  const inputFileSystem = compiler.inputFileSystem;\n  compiler.outputFileSystem = fs;\n  compiler.intermediateFileSystem = fs;\n  // this.watcher = new Watchpack(this.watcherOptions);\n  compiler.watchFileSystem = new NodeWatchFileSystem(\n   compiler.inputFileSystem\n  );\n  // 注册 Callback：Hook.beforeRun\n  compiler.hooks.beforeRun.tap("NodeEnvironmentPlugin", (compiler) => {\n   if (compiler.inputFileSystem === inputFileSystem) {\n    compiler.fsStartTime = Date.now();\n    inputFileSystem.purge();\n   }\n  });\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * inputFileSystem 和 watchFileSystem 分别是根据 enhanced-resolve 包和 watchpack 实现的，链接见【参考】。\n\n\n# WebpackOptionsApply\n\n此组件（不具备 apply 方法，应该不视为 webpack 插件） 根据 options 注册内置插件。\n\n代码位置：lib/WebpackOptionsApply.js\n\nOPTION                                插件                                                                                                                                                    作用                                                             备注\nexternals                             ExternalsPlugin                                                                                                                                       从输出的 bundle 中排除依赖                                              CompilerHook.compile => ExternalModuleFactoryPlugin =>\n                                                                                                                                                                                                                                                           NormalModuleFactoryHook.factorize => handleExternals =>\n                                                                                                                                                                                                                                                           handleExternal\nexternalsPresets.node                 NodeTargetPlugin                                                                                                                                      将 node.js 的内置模块视为 external 模块（如 fs，path 或 vm），使用时通过 require    ExternalsPlugin("node-commonjs", builtins)\n                                                                                                                                                                                            () 加载。\nexternalsPresets.electronMain         ElectronTargetPlugin("main")                                                                                                                          将 main 上下文中的 electron 内置模块视为 external 模块（如 app，ipc-main 或      ExternalsPlugin\n                                                                                                                                                                                            shell），使用时通过 require () 加载。\nexternalsPresets.electronPreload      ElectronTargetPlugin("preload")                                                                                                                       将预加载上下文的 electron 内置模块视为 external 模块（如                         ExternalsPlugin\n                                                                                                                                                                                            web-frame，ipc-renderer 或 shell），使用时通过 require () 加载。\nexternalsPresets.electronRenderer     ElectronTargetPlugin("renderer")                                                                                                                      将 renderer 上下文的 electron 内置模块视为 external 模块（如                  ExternalsPlugin\n                                                                                                                                                                                            web-frame、ipc-renderer 或 shell），使用时通过 require () 加载。\nexternalsPresets.electron             ElectronTargetPlugin                                                                                                                                  将 main 和预加载上下文中常见的 electron 内置模块视为 external 模块（如               ExternalsPlugin\n                                                                                                                                                                                            electron，ipc 或 shell），使用时通过 require () 加载。\nexternalsPresets.nwjs                 ExternalsPlugin("node-commonjs", "nw.gui")                                                                                                            将 NW.js 遗留的 nw.gui 模块视为 external 模块，使用时通过 require () 加载。       ExternalsPlugin\nexternalsPresets.webAsync             ExternalsPlugin("import")                                                                                                                             将 \'http (s)😕/...\' 以及\'std:...\' 的引用视为 external 模块，使用时通过 async   ExternalsPlugin\n                                                                                                                                                                                            import () 加载。（注意，此 external 类型为 async 模块，它对执行会产生各种副作用）。\nexternalsPresets.web                  ExternalsPlugin("module")                                                                                                                             将 http (s)😕/... 以及 std:... 视为 external 模块，使用时通过 import        ExternalsPlugin\n                                                                                                                                                                                            加载。（注意，这将改变执行顺序，因为 external 代码会在该块中的其他代码执行前被执行）。\n                                      ChunkPrefetchPreloadPlugin                                                                                                                                                                                           CompilerHook.compilation => ......\noutput.chunkFormat                    ArrayPushCallbackChunkFormatPlugin、CommonJsChunkFormatPlugin、ModuleChunkFormatPlugin                                                                  chunk 的格式（formats 默认包含 \'array-push\'                            \n                                                                                                                                                                                            (web/WebWorker)、\'commonjs\' (node.js)、\'module\' (ESM))\noutput.enabledChunkLoadingTypes       EnableChunkLoadingPlugin                                                                                                                                                                                             \noutput.enabledWasmLoadingTypes        EnableWasmLoadingPlugin                                                                                                                                                                                              \noutput.enabledLibraryTypes            EnableLibraryPlugin                                                                                                                                                                                                  \noutput.pathinfo                       ModuleInfoHeaderPlugin                                                                                                                                                                                               \noutput.clean                          CleanPlugin                                                                                                                                                                                                          \ndevtool                               EvalSourceMapDevToolPlugin、SourceMapDevToolPlugin、EvalDevToolModulePlugin、EvalDevToolModulePlugin                                                                                                                    \n                                                                                                                                                                                                                                                           \n                                      JavascriptModulesPlugin                                                                                                                                                                                              \n                                      JsonModulesPlugin                                                                                                                                                                                                    \n                                      AssetModulesPlugin                                                                                                                                                                                                   \nexperiments.syncWebAssembly           WebAssemblyModulesPlugin                                                                                                                                                                                             \nexperiments.asyncWebAssembly          AsyncWebAssemblyModulesPlugin                                                                                                                                                                                        \nexperiments.css                       CssModulesPlugin                                                                                                                                                                                                     \nexperiments.lazyCompilation           LazyCompilationPlugin                                                                                                                                                                                                \nexperiments.buildHttp                 HttpUriPlugin                                                                                                                                                                                                        \n                                      EntryOptionPlugin                                                                                                                                                                                                    \n                                      RuntimePlugin                                                                                                                                                                                                        \n                                      InferAsyncModulesPlugin                                                                                                                                                                                              \n                                      DataUriPlugin                                                                                                                                                                                                        \n                                      FileUriPlugin                                                                                                                                                                                                        \n                                      CompatibilityPlugin                                                                                                                                   Currently useless. Ensures compatibility with other module     \n                                                                                                                                                                                            loaders.\n                                      HarmonyModulesPlugin                                                                                                                                                                                                 \noptions.amd                           AMDPlugin、RequireJsStuffPlugin                                                                                                                                                                                       \n                                      CommonJsPlugin                                                                                                                                                                                                       \n                                      LoaderPlugin                                                                                                                                                                                                         \n                                      APIPlugin                                                                                                                                                                                                            \n                                      ExportsInfoApiPlugin                                                                                                                                                                                                 \n                                      WebpackIsIncludedPlugin                                                                                                                                                                                              \n                                      ConstPlugin                                                                                                                                                                                                          \n                                      UseStrictPlugin                                                                                                                                                                                                      \n                                      RequireIncludePlugin                                                                                                                                                                                                 \n                                      RequireEnsurePlugin                                                                                                                                                                                                  \n                                      RequireContextPlugin                                                                                                                                                                                                 \n                                      ImportPlugin                                                                                                                                                                                                         \n                                      ImportMetaContextPlugin                                                                                                                                                                                              \n                                      SystemPlugin                                                                                                                                                                                                         \n                                      ImportMetaPlugin                                                                                                                                                                                                     \n                                      URLPlugin                                                                                                                                                                                                            \n                                      SystemPlugin                                                                                                                                                                                                         \n                                      WorkerPlugin                                                                                                                                                                                                         \n                                      DefaultStatsFactoryPlugin                                                                                                                                                                                            \n                                      JavascriptMetaInfoPlugin                                                                                                                                                                                             \noptions.mode                          WarnNoModeSetPlugin                                                                                                                                                                                                  \n                                      EnsureChunkConditionsPlugin                                                                                                                                                                                          \noptimization.removeAvailableModules   RemoveParentModulesPlugin                                                                                                                                                                                            \noptimization.removeEmptyChunks        RemoveEmptyChunksPlugin                                                                                                                                                                                              \noptimization.mergeDuplicateChunks     MergeDuplicateChunksPlugin                                                                                                                                                                                           \noptimization.flagIncludedChunks       FlagIncludedChunksPlugin                                                                                                                                                                                             \noptimization.sideEffects              SideEffectsFlagPlugin                                                                                                                                                                                                \noptimization.providedExports          FlagDependencyExportsPlugin                                                                                                                                                                                          \noptimization.usedExports              FlagDependencyUsagePlugin                                                                                                                                                                                            \noptimization.innerGraph               InnerGraphPlugin                                                                                                                                                                                                     \noptimization.mangleExports            MangleExportsPlugin                                                                                                                                                                                                  \noptimization.concatenateModules       ModuleConcatenationPlugin                                                                                                                                                                                            \noptimization.splitChunks              SplitChunksPlugin                                                                                                                                                                                                    \noptimization.emitOnErrors             NoEmitOnErrorsPlugin                                                                                                                                                                                                 \noptimization.realContentHash          RealContentHashPlugin                                                                                                                                                                                                \noptimization.checkWasmTypes           WasmFinalizeExportsPlugin                                                                                                                                                                                            \noptimization.moduleIds                NaturalModuleIdsPlugin、NamedModuleIdsPlugin、WarnDeprecatedOptionPlugin、HashedModuleIdsPlugin、DeterministicModuleIdsPlugin、OccurrenceModuleIdsPlugin                                                                  \noptimization.chunkIds                 NaturalChunkIdsPlugin、NamedChunkIdsPlugin、DeterministicChunkIdsPlugin、OccurrenceChunkIdsPlugin                                                                                                                       \noptimization.nodeEnv                  DefinePlugin                                                                                                                                          DefinePlugin 允许在 编译时                                           \n                                                                                                                                                                                            将你代码中的变量替换为其他值或表达式。这在需要根据开发模式与生产模式进行不同的操作时，非常有用。\noptimization.performance              SizeLimitsPlugin                                                                                                                                                                                                     \n                                      TemplatedPathPlugin                                                                                                                                                                                                  \n                                      RecordIdsPlugin                                                                                                                                                                                                      \n                                      WarnCaseSensitiveModulesPlugin                                                                                                                                                                                       \n                                      AddManagedPathsPlugin                                                                                                                                                                                                \ncache                                 MemoryWithGcCachePlugin、MemoryCachePlugin、AddBuildDependenciesPlugin、IdleFileCachePlugin、PackFileCacheStrategy                                                                                                       \n                                      ResolverCachePlugin                                                                                                                                                                                                  \nignoreWarnings                        IgnoreWarningsPlugin                                                                                                                                                                                                 \n\n\n# 参考\n\n * webpack/enhanced-resolve: Offers an async require.resolve function. It\'s highly configurable.\n * webpack/watchpack: Wrapper library for directory and file watching.\n * Plugins | webpack 中文文档',normalizedContent:'在上一节中，我们以 compiler 为主线探讨了 webpack 在 init 阶段的核心原理，在本节中我们将对 init 阶段 options 的处理进行更细化的探讨。\n\n\n# 目录\n\n\n\n * 目录\n * getnormalizedwebpackoptions\n * 顶层 option\n * applywebpackoptionsbasedefaults 和 applywebpackoptionsdefaults\n * nodeenvironmentplugin\n * webpackoptionsapply\n * 参考\n\n\n\n\n# getnormalizedwebpackoptions\n\n// lib/config/normalization.js\nconst getnormalizedwebpackoptions = configs => {\n  // ......\n  return normalizedconfigs;\n};\n\n\n1\n2\n3\n4\n5\n\n\n这部分代码主要是校验和规整（normalize）options，代码很繁琐，甚至 option 都是按照字母顺序排序，与主流程关系不大，此处不再赘述。\n\n不过可以借此机会，熟悉下 webpack 的 顶层options 有哪些？\n\n\n# 顶层 option\n\nwebpack 配置有如下顶层 option。\n\noption                  描述\namd                     设置 require.amd 或 define.amd 的值。设置 amd 为 false 会禁用 webpack 的\n                        amd 支持。\nbail                    在第一个错误出现时抛出失败结果，而不是容忍它。这将迫使 webpack 退出其打包过程。\ncache                   缓存生成的 webpack 模块和 chunk，来改善 构建速度 。\ncontext                 基础目录，绝对路径，用于从配置中解析入口点 (entry point) 和 加载器 (loader)。默认使用\n                        node.js 进程的当前工作目录。\ndependencies            一个 name 列表，定义它所依赖的所有兄弟（sibling）配置。需要首先编译依赖的配置。\ndevserver               配置 webpack-dev-server\ndevtool                 此选项控制是否生成，以及如何生成 source map。\nentry                   开始应用程序打包过程的一个或多个起点。如果传入数组，则会处理所有条目。一个需要考虑的规则：每个 html\n                        页面都有一个入口起点。单页应用 (spa)：一个入口起点，多页应用 (mpa)：多个入口起点。\nexperiments             experiments 配置是在 webpack 5 中推出，目的是为了给用户赋能去开启并试用一些实验的特性。\nexternals               防止将某些 import 的包 (package) 打包到 bundle 中，而是在运行时 (runtime)\n                        再去从外部获取这些扩展依赖 (external dependencies)。\nexternalspresets        为特定的 target 启用 externals 的 preset。\nexternalstype           指定 externals 的默认类型。当 external 被设置为 amd，umd，system 以及 jsonp\n                        时，output.librarytarget 的值也应相同。\nignorewarnings          告诉 webpack 忽略掉特定的警告。\ninfrastructurelogging   用于基础设施水平的日志选项。\nloader                  在 loader 上下文 中暴露自定义值。\nmode                    提供 mode 配置选项，告知 webpack 使用相应模式的内置优化。\nmodule                  这些选项决定了如何处理项目中的不同类型的模块。\n                        \nname                    配置的名称。当加载不同的配置时会被使用。\nnode                    这些选项可以配置是否 polyfill 或 mock 某些 node.js 全局变量。此功能由 webpack 内部的\n                        nodestuffplugin 插件提供。\noptimization            从 webpack 4 开始，会根据你选择的 mode 来执行不同的优化， 不过所有的优化还是可以手动配置和重写。\noutput                  output 位于对象最顶级键 (key)，包括了一组选项，指示 webpack\n                        如何去输出、以及在哪里输出你的「bundle、asset 和其他你所打包或使用 webpack 载入的任何内容」。\nparallelism             限制并行处理的模块数量。可以用于调优性能或获取更可靠的性能分析结果。\nperformance             控制 webpack 如何通知「资源 (asset) 和入口起点超过指定文件限制」。\nplugins                 plugins 选项用于以各种方式自定义 webpack 构建过程。webpack 附带了各种内置插件，可以通过\n                        webpack.[plugin-name] 访问这些插件。\nprofile                 捕获一个应用程序 "配置文件"，包括统计和提示，然后可以使用 analyze 分析工具进行详细分析。\nrecordsinputpath        指定读取最后一条记录的文件的名称。这可以用来重命名一个记录文件。\nrecordsoutputpath       指定记录要写入的位置。\nresolve                 这些选项能设置模块如何被解析。webpack 提供合理的默认值，但是还是可能会修改一些解析的细节。\nresolveloader           这组选项与上面的 resolve 对象的属性集合相同， 但仅用于解析 webpack 的 loader 包。\nsnapshot                snapshot 配置项决定文件系统是如何创建和无效快照。\nstats                   stats 选项让你更精确地控制 bundle 信息该怎么显示。 如果你不希望使用 quiet 或 noinfo\n                        这样的不显示信息，而是又不想得到全部的信息，只是想要获取某部分 bundle 的信息，使用 stats\n                        选项是比较好的折衷方式。\ntarget                  webpack 能够为多种环境或 target 构建编译。告知 webpack 为目标 (target)\n                        指定一个环境。默认值为 "browserslist"，如果没有找到 browserslist 的配置，则默认为\n                        "web"\nwatch                   启用 watch 模式。这意味着在初始构建之后，webpack 将继续监听任何已解析文件的更改。\nwatchoptions            一组用来定制 watch 模式的选项\n\n参考：\n\n * why amd?\n * plugins | webpack 中文文档\n\n\n# applywebpackoptionsbasedefaults 和 applywebpackoptionsdefaults\n\n这两个函数为 webpack 默认的 options 合并进应用配置的 options。\n\n以 applywebpackoptionsdefaults 为例：\n\ncontext/target/devtool/watch/profile/parallelism/recordsinputpath/recordsoutputpath => cache => applysnapshotdefaults => applymoduledefaults => applyoutputdefaults => applyexternalspresetsdefaults => applyloaderdefaults => externalstype => applynodedefaults => performance => applyperformancedefaults => applyoptimizationdefaults ......\n\n\n1\n\n\n下面开看下几个辅助函数：\n\n// sets a constant default value when undefined\nconst d = (obj, prop, value) => {\n if (obj[prop] === undefined) {\n  obj[prop] = value;\n }\n};\n// sets a dynamic default value when undefined, by calling the factory function\nconst f = (obj, prop, factory) => {\n if (obj[prop] === undefined) {\n  obj[prop] = factory();\n }\n};\n// \nconst a = (obj, prop, factory) => {\n const value = obj[prop];\n if (value === undefined) {\n  obj[prop] = factory();\n } else if (array.isarray(value)) {\n  let newarray = undefined;\n  for (let i = 0; i < value.length; i++) {\n   const item = value[i];\n   if (item === "...") {\n    if (newarray === undefined) {\n     newarray = value.slice(0, i);\n     //  注意：newarray 是应用，赋值之后 newarray 仍然在变化\n     obj[prop] = newarray;\n    }\n    const items = factory();\n    if (items !== undefined) {\n     for (const item of items) {\n      newarray.push(item);\n     }\n    }\n   } else if (newarray !== undefined) {\n    newarray.push(item);\n   }\n  }\n }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# nodeenvironmentplugin\n\n此插件初始化 node 环境，包括日志组件 infrastructurelogger、文件 io 组件 inputfilesystem、文件 watch 组件 watchfilesystem。\n\nclass nodeenvironmentplugin {\n apply(compiler) {\n  const { infrastructurelogging } = this.options;\n  // 初始化创建 infrastructurelogger\n  compiler.infrastructurelogger = createconsolelogger(/** ...... */);\n  // 初始化文件系统相关，inputfilesystem 和 watchfilesystem\n  compiler.inputfilesystem = new cachedinputfilesystem(fs, 60000);\n  const inputfilesystem = compiler.inputfilesystem;\n  compiler.outputfilesystem = fs;\n  compiler.intermediatefilesystem = fs;\n  // this.watcher = new watchpack(this.watcheroptions);\n  compiler.watchfilesystem = new nodewatchfilesystem(\n   compiler.inputfilesystem\n  );\n  // 注册 callback：hook.beforerun\n  compiler.hooks.beforerun.tap("nodeenvironmentplugin", (compiler) => {\n   if (compiler.inputfilesystem === inputfilesystem) {\n    compiler.fsstarttime = date.now();\n    inputfilesystem.purge();\n   }\n  });\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * inputfilesystem 和 watchfilesystem 分别是根据 enhanced-resolve 包和 watchpack 实现的，链接见【参考】。\n\n\n# webpackoptionsapply\n\n此组件（不具备 apply 方法，应该不视为 webpack 插件） 根据 options 注册内置插件。\n\n代码位置：lib/webpackoptionsapply.js\n\noption                                插件                                                                                                                                                    作用                                                             备注\nexternals                             externalsplugin                                                                                                                                       从输出的 bundle 中排除依赖                                              compilerhook.compile => externalmodulefactoryplugin =>\n                                                                                                                                                                                                                                                           normalmodulefactoryhook.factorize => handleexternals =>\n                                                                                                                                                                                                                                                           handleexternal\nexternalspresets.node                 nodetargetplugin                                                                                                                                      将 node.js 的内置模块视为 external 模块（如 fs，path 或 vm），使用时通过 require    externalsplugin("node-commonjs", builtins)\n                                                                                                                                                                                            () 加载。\nexternalspresets.electronmain         electrontargetplugin("main")                                                                                                                          将 main 上下文中的 electron 内置模块视为 external 模块（如 app，ipc-main 或      externalsplugin\n                                                                                                                                                                                            shell），使用时通过 require () 加载。\nexternalspresets.electronpreload      electrontargetplugin("preload")                                                                                                                       将预加载上下文的 electron 内置模块视为 external 模块（如                         externalsplugin\n                                                                                                                                                                                            web-frame，ipc-renderer 或 shell），使用时通过 require () 加载。\nexternalspresets.electronrenderer     electrontargetplugin("renderer")                                                                                                                      将 renderer 上下文的 electron 内置模块视为 external 模块（如                  externalsplugin\n                                                                                                                                                                                            web-frame、ipc-renderer 或 shell），使用时通过 require () 加载。\nexternalspresets.electron             electrontargetplugin                                                                                                                                  将 main 和预加载上下文中常见的 electron 内置模块视为 external 模块（如               externalsplugin\n                                                                                                                                                                                            electron，ipc 或 shell），使用时通过 require () 加载。\nexternalspresets.nwjs                 externalsplugin("node-commonjs", "nw.gui")                                                                                                            将 nw.js 遗留的 nw.gui 模块视为 external 模块，使用时通过 require () 加载。       externalsplugin\nexternalspresets.webasync             externalsplugin("import")                                                                                                                             将 \'http (s)😕/...\' 以及\'std:...\' 的引用视为 external 模块，使用时通过 async   externalsplugin\n                                                                                                                                                                                            import () 加载。（注意，此 external 类型为 async 模块，它对执行会产生各种副作用）。\nexternalspresets.web                  externalsplugin("module")                                                                                                                             将 http (s)😕/... 以及 std:... 视为 external 模块，使用时通过 import        externalsplugin\n                                                                                                                                                                                            加载。（注意，这将改变执行顺序，因为 external 代码会在该块中的其他代码执行前被执行）。\n                                      chunkprefetchpreloadplugin                                                                                                                                                                                           compilerhook.compilation => ......\noutput.chunkformat                    arraypushcallbackchunkformatplugin、commonjschunkformatplugin、modulechunkformatplugin                                                                  chunk 的格式（formats 默认包含 \'array-push\'                            \n                                                                                                                                                                                            (web/webworker)、\'commonjs\' (node.js)、\'module\' (esm))\noutput.enabledchunkloadingtypes       enablechunkloadingplugin                                                                                                                                                                                             \noutput.enabledwasmloadingtypes        enablewasmloadingplugin                                                                                                                                                                                              \noutput.enabledlibrarytypes            enablelibraryplugin                                                                                                                                                                                                  \noutput.pathinfo                       moduleinfoheaderplugin                                                                                                                                                                                               \noutput.clean                          cleanplugin                                                                                                                                                                                                          \ndevtool                               evalsourcemapdevtoolplugin、sourcemapdevtoolplugin、evaldevtoolmoduleplugin、evaldevtoolmoduleplugin                                                                                                                    \n                                                                                                                                                                                                                                                           \n                                      javascriptmodulesplugin                                                                                                                                                                                              \n                                      jsonmodulesplugin                                                                                                                                                                                                    \n                                      assetmodulesplugin                                                                                                                                                                                                   \nexperiments.syncwebassembly           webassemblymodulesplugin                                                                                                                                                                                             \nexperiments.asyncwebassembly          asyncwebassemblymodulesplugin                                                                                                                                                                                        \nexperiments.css                       cssmodulesplugin                                                                                                                                                                                                     \nexperiments.lazycompilation           lazycompilationplugin                                                                                                                                                                                                \nexperiments.buildhttp                 httpuriplugin                                                                                                                                                                                                        \n                                      entryoptionplugin                                                                                                                                                                                                    \n                                      runtimeplugin                                                                                                                                                                                                        \n                                      inferasyncmodulesplugin                                                                                                                                                                                              \n                                      datauriplugin                                                                                                                                                                                                        \n                                      fileuriplugin                                                                                                                                                                                                        \n                                      compatibilityplugin                                                                                                                                   currently useless. ensures compatibility with other module     \n                                                                                                                                                                                            loaders.\n                                      harmonymodulesplugin                                                                                                                                                                                                 \noptions.amd                           amdplugin、requirejsstuffplugin                                                                                                                                                                                       \n                                      commonjsplugin                                                                                                                                                                                                       \n                                      loaderplugin                                                                                                                                                                                                         \n                                      apiplugin                                                                                                                                                                                                            \n                                      exportsinfoapiplugin                                                                                                                                                                                                 \n                                      webpackisincludedplugin                                                                                                                                                                                              \n                                      constplugin                                                                                                                                                                                                          \n                                      usestrictplugin                                                                                                                                                                                                      \n                                      requireincludeplugin                                                                                                                                                                                                 \n                                      requireensureplugin                                                                                                                                                                                                  \n                                      requirecontextplugin                                                                                                                                                                                                 \n                                      importplugin                                                                                                                                                                                                         \n                                      importmetacontextplugin                                                                                                                                                                                              \n                                      systemplugin                                                                                                                                                                                                         \n                                      importmetaplugin                                                                                                                                                                                                     \n                                      urlplugin                                                                                                                                                                                                            \n                                      systemplugin                                                                                                                                                                                                         \n                                      workerplugin                                                                                                                                                                                                         \n                                      defaultstatsfactoryplugin                                                                                                                                                                                            \n                                      javascriptmetainfoplugin                                                                                                                                                                                             \noptions.mode                          warnnomodesetplugin                                                                                                                                                                                                  \n                                      ensurechunkconditionsplugin                                                                                                                                                                                          \noptimization.removeavailablemodules   removeparentmodulesplugin                                                                                                                                                                                            \noptimization.removeemptychunks        removeemptychunksplugin                                                                                                                                                                                              \noptimization.mergeduplicatechunks     mergeduplicatechunksplugin                                                                                                                                                                                           \noptimization.flagincludedchunks       flagincludedchunksplugin                                                                                                                                                                                             \noptimization.sideeffects              sideeffectsflagplugin                                                                                                                                                                                                \noptimization.providedexports          flagdependencyexportsplugin                                                                                                                                                                                          \noptimization.usedexports              flagdependencyusageplugin                                                                                                                                                                                            \noptimization.innergraph               innergraphplugin                                                                                                                                                                                                     \noptimization.mangleexports            mangleexportsplugin                                                                                                                                                                                                  \noptimization.concatenatemodules       moduleconcatenationplugin                                                                                                                                                                                            \noptimization.splitchunks              splitchunksplugin                                                                                                                                                                                                    \noptimization.emitonerrors             noemitonerrorsplugin                                                                                                                                                                                                 \noptimization.realcontenthash          realcontenthashplugin                                                                                                                                                                                                \noptimization.checkwasmtypes           wasmfinalizeexportsplugin                                                                                                                                                                                            \noptimization.moduleids                naturalmoduleidsplugin、namedmoduleidsplugin、warndeprecatedoptionplugin、hashedmoduleidsplugin、deterministicmoduleidsplugin、occurrencemoduleidsplugin                                                                  \noptimization.chunkids                 naturalchunkidsplugin、namedchunkidsplugin、deterministicchunkidsplugin、occurrencechunkidsplugin                                                                                                                       \noptimization.nodeenv                  defineplugin                                                                                                                                          defineplugin 允许在 编译时                                           \n                                                                                                                                                                                            将你代码中的变量替换为其他值或表达式。这在需要根据开发模式与生产模式进行不同的操作时，非常有用。\noptimization.performance              sizelimitsplugin                                                                                                                                                                                                     \n                                      templatedpathplugin                                                                                                                                                                                                  \n                                      recordidsplugin                                                                                                                                                                                                      \n                                      warncasesensitivemodulesplugin                                                                                                                                                                                       \n                                      addmanagedpathsplugin                                                                                                                                                                                                \ncache                                 memorywithgccacheplugin、memorycacheplugin、addbuilddependenciesplugin、idlefilecacheplugin、packfilecachestrategy                                                                                                       \n                                      resolvercacheplugin                                                                                                                                                                                                  \nignorewarnings                        ignorewarningsplugin                                                                                                                                                                                                 \n\n\n# 参考\n\n * webpack/enhanced-resolve: offers an async require.resolve function. it\'s highly configurable.\n * webpack/watchpack: wrapper library for directory and file watching.\n * plugins | webpack 中文文档',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"本章概要",frontmatter:{title:"本章概要",date:"2022-04-22T15:21:45.000Z",permalink:"/webpack/make/index/",categories:["more","webpack","make阶段"],tags:[null]},regularPath:"/30.web/7.webpack/30.make%E9%98%B6%E6%AE%B5/0.index.html",relativePath:"30.web/7.webpack/30.make阶段/0.index.md",key:"v-b6310e56",path:"/webpack/make/index/",headers:[{level:2,title:"RoadMap",slug:"roadmap",normalizedTitle:"roadmap",charIndex:154},{level:2,title:"引用声明",slug:"引用声明",normalizedTitle:"引用声明",charIndex:168}],excerpt:"<p>在上一章节中我们探讨了 webpack init 阶段的一系列初始化工作，初始化 options、初始化 compiler、初始化编译和环境 (注册插件、触发 Hook)、compiler.run、compiler.compile 等。在本章节中，我们将探讨 webpack make 阶段的原理。</p>\n",readingTime:{text:"1 min read",minutes:.15,time:9e3,words:30},headersStr:"RoadMap 引用声明",content:"在上一章节中我们探讨了 webpack init 阶段的一系列初始化工作，初始化 options、初始化 compiler、初始化编译和环境 (注册插件、触发 Hook)、compiler.run、compiler.compile 等。在本章节中，我们将探讨 webpack make 阶段的原理。\n\n\n# RoadMap\n\n\n\n\n# 引用声明\n\nWebpack Make Roadmap 图原作者为 范文杰 ，请访问原作：[万字总结] 一文吃透 Webpack 核心原理 - 知乎",normalizedContent:"在上一章节中我们探讨了 webpack init 阶段的一系列初始化工作，初始化 options、初始化 compiler、初始化编译和环境 (注册插件、触发 hook)、compiler.run、compiler.compile 等。在本章节中，我们将探讨 webpack make 阶段的原理。\n\n\n# roadmap\n\n\n\n\n# 引用声明\n\nwebpack make roadmap 图原作者为 范文杰 ，请访问原作：[万字总结] 一文吃透 webpack 核心原理 - 知乎",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"make 阶段：compilation",frontmatter:{title:"make 阶段：compilation",date:"2022-04-22T14:39:35.000Z",permalink:"/webpack/make/compilation/",categories:["webpack","init阶段"],tags:[null]},regularPath:"/30.web/7.webpack/30.make%E9%98%B6%E6%AE%B5/10.compilation.html",relativePath:"30.web/7.webpack/30.make阶段/10.compilation.md",key:"v-0d9c3a15",path:"/webpack/make/compilation/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"compilation.addEntry",slug:"compilation-addentry",normalizedTitle:"compilation.addentry",charIndex:17},{level:2,title:"addModuleTree",slug:"addmoduletree",normalizedTitle:"addmoduletree",charIndex:41},{level:2,title:"handleModuleCreation",slug:"handlemodulecreation",normalizedTitle:"handlemodulecreation",charIndex:58},{level:3,title:"factorizeModule",slug:"factorizemodule",normalizedTitle:"factorizemodule",charIndex:84},{level:3,title:"addModule",slug:"addmodule",normalizedTitle:"addmodule",charIndex:41},{level:2,title:"moduleGraph",slug:"modulegraph",normalizedTitle:"modulegraph",charIndex:118},{level:2,title:"AsyncQueue",slug:"asyncqueue",normalizedTitle:"asyncqueue",charIndex:133},{level:2,title:"compilation.Hook",slug:"compilation-hook",normalizedTitle:"compilation.hook",charIndex:147}],excerpt:'<TimeToRead />\n<h2 id="目录"><a class="header-anchor" href="#目录">#</a> 目录</h2>\n<p><div class="table-of-contents"><ul><li><a href="#目录">目录</a></li></ul></div></p>\n<p>我们已经知道在 compiler.compile 中会创建 compilation，并且在 CompilerHook.make 触发时会调用  <code>compilation.addEntry</code> ，此时  <code>EntryDependency</code>  已经被创建。</p>\n<p>当 CompilerHook.make 触发之后，就正式进入了  <code>make</code>  阶段的内容。</p>\n<p>本节将探讨 webpack 构建流程中 make 阶段的如下工作：</p>\n<ul>\n<li>compilation.addEntry</li>\n</ul>\n',readingTime:{text:"8 min read",minutes:7.5,time:45e4,words:1500},headersStr:"目录 compilation.addEntry addModuleTree handleModuleCreation factorizeModule addModule moduleGraph AsyncQueue compilation.Hook",content:'# 目录\n\n\n\n * 目录\n * compilation.addEntry\n * addModuleTree\n * handleModuleCreation\n   * factorizeModule\n   * addModule\n * moduleGraph\n * AsyncQueue\n * compilation.Hook\n\n\n\n我们已经知道在 compiler.compile 中会创建 compilation，并且在 CompilerHook.make 触发时会调用 compilation.addEntry ，此时 EntryDependency 已经被创建。\n\n当 CompilerHook.make 触发之后，就正式进入了 make 阶段的内容。\n\n本节将探讨 webpack 构建流程中 make 阶段的如下工作：\n\n * compilation.addEntry\n\n\n# compilation.addEntry\n\n内部调用 _addEntryItem 。 _addEntryItem 将会被 addEntry 和 addInclude 。\n\n// lib/Compilation.js\n_addEntryItem(context, entry, target, options, callback) {\n  const { name } = options;\n  // 获取 entryData，无 name 则使用 globalEntry\n  let entryData =\n    name !== undefined ? this.entries.get(name) : this.globalEntry;\n  if (entryData === undefined) {\n    // 创建 entryData，包含 dependencies 和 includeDependencies\n    entryData = {\n      dependencies: [],\n      includeDependencies: [],\n      options: {\n        name: undefined,\n        ...options\n      }\n    };\n    // target 为 dependencies 或者 includeDependencies\n    // 将 entry 推入 entryData 中相应类型的依赖列表\n    entryData[target].push(entry);\n    // 将 entryData 缓存到 entries，entries<name, entryData>\n    this.entries.set(name, entryData);\n  } else {\n    entryData[target].push(entry);\n    // 将 options 中的新增属性复制到 entryData.options\n    for (const key of Object.keys(options)) {\n      if (options[key] === undefined) continue;\n      if (entryData.options[key] === options[key]) continue;\n      if (\n        Array.isArray(entryData.options[key]) &&\n        Array.isArray(options[key]) &&\n        arrayEquals(entryData.options[key], options[key])\n      ) {\n        continue;\n      }\n      if (entryData.options[key] === undefined) {\n        entryData.options[key] = options[key];\n      } else {\n        return callback(\n          new WebpackError(\n            `Conflicting entry option ${key} = ${entryData.options[key]} vs ${options[key]}`\n          )\n        );\n      }\n    }\n  }\n  // 触发 CompilationHook.addEntry => call\n  this.hooks.addEntry.call(entry, options);\n  // 调用 compilation.addModuleTree 开始构建 moduleTree\n  this.addModuleTree(\n    {\n      context,\n      dependency: entry,\n      contextInfo: entryData.options.layer\n        ? { issuerLayer: entryData.options.layer }\n        : undefined\n    },\n    // finished callback\n    (err, module) => {\n      if (err) {\n        // 触发 CompilationHook.failedEntry => call\n        this.hooks.failedEntry.call(entry, options, err);\n        return callback(err);\n      }\n      // 触发 CompilationHook.succeedEntry => call\n      this.hooks.succeedEntry.call(entry, options, module);\n      return callback(null, module);\n    }\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n * entries 的结构是 Map<name, {dependencies: [],includeDependencies: []}> , entry 本质是 EntryDependency 对象。\n * 调用 addModuleTree 根据 Dependence 对象创建 Module 对象，并将 Module 添加到 moduleGraph。\n\n\n# addModuleTree\n\n传递 moduleFactory，并调用 handleModuleCreation 创建 Module。\n\n// lib/Compilation.js\naddModuleTree({ context, dependency, contextInfo }, callback) {\n  const Dep = /** @type {DepConstructor} */ (dependency.constructor);\n  // 根据 Dependency 的构造器可以获取到 moduleFactory\n  const moduleFactory = this.dependencyFactories.get(Dep);\n\n  this.handleModuleCreation(\n    {\n      factory: moduleFactory,\n      dependencies: [dependency],\n      originModule: null,\n      contextInfo,\n      context\n    },\n    // ......\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# handleModuleCreation\n\n// lib/Compilation.js\nhandleModuleCreation = () => {\n  // this.moduleGraph = new ModuleGraph();\n  const moduleGraph = this.moduleGraph;\n  // factorizeModule 通过相应的 ModuleFactory 创建 Module\n  this.factorizeModule(\n   {\n    currentProfile,\n    factory,\n    dependencies,\n    factoryResult: true,\n    originModule,\n    contextInfo,\n    context\n   }, (err, factoryResult) => {\n   // 将 Entry 中  fileDependencies、contextDependencies、missingDependencies 收集起来\n  const applyFactoryResultDependencies = () => {\n   const { fileDependencies, contextDependencies, missingDependencies } =\n    factoryResult;\n   if (fileDependencies) {\n    this.fileDependencies.addAll(fileDependencies);\n   }\n   if (contextDependencies) {\n    this.contextDependencies.addAll(contextDependencies);\n   }\n   if (missingDependencies) {\n    this.missingDependencies.addAll(missingDependencies);\n   }\n  };\n\n  // 在任务回调中 获得 Module\n  const newModule = factoryResult.module;\n    // 将 module 加入到 addModuleQueue 队列\n    this.addModule(newModule, (err, module) => {\n      applyFactoryResultDependencies();\n      // 循环 dependencies，将 dependency 设置到 moduleGraph\n      for (let i = 0; i < dependencies.length; i++) {\n       const dependency = dependencies[i];\n       moduleGraph.setResolvedModule(\n        connectOrigin ? originModule : null,\n        dependency,\n        module\n       );\n      }\n      this._handleModuleBuildAndDependencies(\n        originModule,\n        module,\n        recursive,\n        callback\n       );\n    })\n })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n总结如下：\n\n * factorizeModule 通过 ModuleFactory 创建 Module 和 ModuleDependencies。\n * addModule 将 Module 添加到 moduleGraph，同时将 ModuleDependencies 分别添加到 fileDependencies 、 contextDependencies 或者 missingDependencies 。\n\n\n# factorizeModule\n\nfunction (options, callback) {\n  this.factorizeQueue.add(options, callback);\n}\n\n\n1\n2\n3\n\n\nfactorizeModule 将 factorizeModule 的任务加入到 factorizeQueue，其 processor 为 _factorizeModule。\n\n_factorizeModule() {\n  factory.create(/*......*/, (err, result) => {\n    callback(null, factoryResult ? result : result.module);\n  })\n}\n\n\n1\n2\n3\n4\n5\n\n\n_factorizeModule 中的 factory 即为 EntryPlugin (或者其他插件) 为 Dependence 注册的 ModuleFactory ，是创建 Module 的工厂函数。以 normalModuleFactory 为例：\n\ncreate(data, callback) {\n  const resolveData = {\n   contextInfo,\n   resolveOptions,\n   context,\n   request,\n   assertions,\n   dependencies,\n   dependencyType,\n   fileDependencies,\n   missingDependencies,\n   contextDependencies,\n   createData: {},\n   cacheable: true\n  };\n  // 触发 CompilationHook.beforeResolve => callAsync\n  this.hooks.beforeResolve.callAsync(resolveData, (err, result) => {\n    // 触发 CompilationHook.factorize => callAsync\n    this.hooks.factorize.callAsync(resolveData, (err, module) => {}\n  )})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# addModule\n\naddModule 将 module 包装成任务加入 addModuleQueue 队列，processor 是 _addModule 函数。\n\naddModule(module, callback) {\n this.addModuleQueue.add(module, callback);\n}\n_addModule(module, callback) {\n const identifier = module.identifier();\n // 如果 modules 已经在 _modules，直接 callback\n const alreadyAddedModule = this._modules.get(identifier);\n if (alreadyAddedModule) {\n  return callback(null, alreadyAddedModule);\n }\n// ......\n\n // 尝试从缓存中获取相同 identifier 的 module\n this._modulesCache.get(identifier, null, (err, cacheModule) => {\n    // ......\n  // 如果命中缓存，以 cacheModule 为模板进行更新\n  if (cacheModule) {\n   cacheModule.updateCacheModule(module);\n   // 将 cacheModule 作为 module\n   module = cacheModule;\n  }\n  // 将 module 设置到 _modules\n  this._modules.set(identifier, module);\n  // 将 module 加入到 modules，注意 _modules 是 Map，用于查找，modules 是 Set\n  this.modules.add(module);\n  // ......\n  callback(null, module);\n });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n_addModule 将 module 加入到 _modules 和 module 。\n\n\n# moduleGraph\n\n\n# AsyncQueue\n\ncompilation 中的 AsyncQueue，包括 processDependenciesQueue、addModuleQueue、factorizeQueue、buildQueue、rebuildQueue，前四者是父子结构。\n\n/** @type {AsyncQueue<Module, Module, Module>} */\nthis.processDependenciesQueue = new AsyncQueue({\n name: "processDependencies",\n parallelism: options.parallelism || 100,\n processor: this._processModuleDependencies.bind(this),\n});\n/** @type {AsyncQueue<Module, string, Module>} */\nthis.addModuleQueue = new AsyncQueue({\n name: "addModule",\n parent: this.processDependenciesQueue,\n getKey: (module) => module.identifier(),\n processor: this._addModule.bind(this),\n});\n/** @type {AsyncQueue<FactorizeModuleOptions, string, Module | ModuleFactoryResult>} */\nthis.factorizeQueue = new AsyncQueue({\n name: "factorize",\n parent: this.addModuleQueue,\n processor: this._factorizeModule.bind(this),\n});\n/** @type {AsyncQueue<Module, Module, Module>} */\nthis.buildQueue = new AsyncQueue({\n name: "build",\n parent: this.factorizeQueue,\n processor: this._buildModule.bind(this),\n});\n/** @type {AsyncQueue<Module, Module, Module>} */\nthis.rebuildQueue = new AsyncQueue({\n name: "rebuild",\n parallelism: options.parallelism || 100,\n processor: this._rebuildModule.bind(this),\n});\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# compilation.Hook\n\nthis.hooks = Object.freeze({\n  /** @type {SyncHook<[Module]>} */\n  buildModule: new SyncHook(["module"]),\n  /** @type {SyncHook<[Module]>} */\n  rebuildModule: new SyncHook(["module"]),\n  /** @type {SyncHook<[Module, WebpackError]>} */\n  failedModule: new SyncHook(["module", "error"]),\n  /** @type {SyncHook<[Module]>} */\n  succeedModule: new SyncHook(["module"]),\n  /** @type {SyncHook<[Module]>} */\n  stillValidModule: new SyncHook(["module"]),\n\n  /** @type {SyncHook<[Dependency, EntryOptions]>} */\n  addEntry: new SyncHook(["entry", "options"]),\n  /** @type {SyncHook<[Dependency, EntryOptions, Error]>} */\n  failedEntry: new SyncHook(["entry", "options", "error"]),\n  /** @type {SyncHook<[Dependency, EntryOptions, Module]>} */\n  succeedEntry: new SyncHook(["entry", "options", "module"]),\n\n  /** @type {SyncWaterfallHook<[(string[] | ReferencedExport)[], Dependency, RuntimeSpec]>} */\n  dependencyReferencedExports: new SyncWaterfallHook([\n    "referencedExports",\n    "dependency",\n    "runtime"\n  ]),\n\n  /** @type {SyncHook<[ExecuteModuleArgument, ExecuteModuleContext]>} */\n  executeModule: new SyncHook(["options", "context"]),\n  /** @type {AsyncParallelHook<[ExecuteModuleArgument, ExecuteModuleContext]>} */\n  prepareModuleExecution: new AsyncParallelHook(["options", "context"]),\n\n  /** @type {AsyncSeriesHook<[Iterable<Module>]>} */\n  finishModules: new AsyncSeriesHook(["modules"]),\n  /** @type {AsyncSeriesHook<[Module]>} */\n  finishRebuildingModule: new AsyncSeriesHook(["module"]),\n  /** @type {SyncHook<[]>} */\n  unseal: new SyncHook([]),\n  /** @type {SyncHook<[]>} */\n  seal: new SyncHook([]),\n\n  /** @type {SyncHook<[]>} */\n  beforeChunks: new SyncHook([]),\n  /** @type {SyncHook<[Iterable<Chunk>]>} */\n  afterChunks: new SyncHook(["chunks"]),\n\n  /** @type {SyncBailHook<[Iterable<Module>]>} */\n  optimizeDependencies: new SyncBailHook(["modules"]),\n  /** @type {SyncHook<[Iterable<Module>]>} */\n  afterOptimizeDependencies: new SyncHook(["modules"]),\n\n  /** @type {SyncHook<[]>} */\n  optimize: new SyncHook([]),\n  /** @type {SyncBailHook<[Iterable<Module>]>} */\n  optimizeModules: new SyncBailHook(["modules"]),\n  /** @type {SyncHook<[Iterable<Module>]>} */\n  afterOptimizeModules: new SyncHook(["modules"]),\n\n  /** @type {SyncBailHook<[Iterable<Chunk>, ChunkGroup[]]>} */\n  optimizeChunks: new SyncBailHook(["chunks", "chunkGroups"]),\n  /** @type {SyncHook<[Iterable<Chunk>, ChunkGroup[]]>} */\n  afterOptimizeChunks: new SyncHook(["chunks", "chunkGroups"]),\n\n  /** @type {AsyncSeriesHook<[Iterable<Chunk>, Iterable<Module>]>} */\n  optimizeTree: new AsyncSeriesHook(["chunks", "modules"]),\n  /** @type {SyncHook<[Iterable<Chunk>, Iterable<Module>]>} */\n  afterOptimizeTree: new SyncHook(["chunks", "modules"]),\n\n  /** @type {AsyncSeriesBailHook<[Iterable<Chunk>, Iterable<Module>]>} */\n  optimizeChunkModules: new AsyncSeriesBailHook(["chunks", "modules"]),\n  /** @type {SyncHook<[Iterable<Chunk>, Iterable<Module>]>} */\n  afterOptimizeChunkModules: new SyncHook(["chunks", "modules"]),\n  /** @type {SyncBailHook<[], boolean>} */\n  shouldRecord: new SyncBailHook([]),\n\n  /** @type {SyncHook<[Chunk, Set<string>, RuntimeRequirementsContext]>} */\n  additionalChunkRuntimeRequirements: new SyncHook([\n    "chunk",\n    "runtimeRequirements",\n    "context"\n  ]),\n  /** @type {HookMap<SyncBailHook<[Chunk, Set<string>, RuntimeRequirementsContext]>>} */\n  runtimeRequirementInChunk: new HookMap(\n    () => new SyncBailHook(["chunk", "runtimeRequirements", "context"])\n  ),\n  /** @type {SyncHook<[Module, Set<string>, RuntimeRequirementsContext]>} */\n  additionalModuleRuntimeRequirements: new SyncHook([\n    "module",\n    "runtimeRequirements",\n    "context"\n  ]),\n  /** @type {HookMap<SyncBailHook<[Module, Set<string>, RuntimeRequirementsContext]>>} */\n  runtimeRequirementInModule: new HookMap(\n    () => new SyncBailHook(["module", "runtimeRequirements", "context"])\n  ),\n  /** @type {SyncHook<[Chunk, Set<string>, RuntimeRequirementsContext]>} */\n  additionalTreeRuntimeRequirements: new SyncHook([\n    "chunk",\n    "runtimeRequirements",\n    "context"\n  ]),\n  /** @type {HookMap<SyncBailHook<[Chunk, Set<string>, RuntimeRequirementsContext]>>} */\n  runtimeRequirementInTree: new HookMap(\n    () => new SyncBailHook(["chunk", "runtimeRequirements", "context"])\n  ),\n\n  /** @type {SyncHook<[RuntimeModule, Chunk]>} */\n  runtimeModule: new SyncHook(["module", "chunk"]),\n\n  /** @type {SyncHook<[Iterable<Module>, any]>} */\n  reviveModules: new SyncHook(["modules", "records"]),\n  /** @type {SyncHook<[Iterable<Module>]>} */\n  beforeModuleIds: new SyncHook(["modules"]),\n  /** @type {SyncHook<[Iterable<Module>]>} */\n  moduleIds: new SyncHook(["modules"]),\n  /** @type {SyncHook<[Iterable<Module>]>} */\n  optimizeModuleIds: new SyncHook(["modules"]),\n  /** @type {SyncHook<[Iterable<Module>]>} */\n  afterOptimizeModuleIds: new SyncHook(["modules"]),\n\n  /** @type {SyncHook<[Iterable<Chunk>, any]>} */\n  reviveChunks: new SyncHook(["chunks", "records"]),\n  /** @type {SyncHook<[Iterable<Chunk>]>} */\n  beforeChunkIds: new SyncHook(["chunks"]),\n  /** @type {SyncHook<[Iterable<Chunk>]>} */\n  chunkIds: new SyncHook(["chunks"]),\n  /** @type {SyncHook<[Iterable<Chunk>]>} */\n  optimizeChunkIds: new SyncHook(["chunks"]),\n  /** @type {SyncHook<[Iterable<Chunk>]>} */\n  afterOptimizeChunkIds: new SyncHook(["chunks"]),\n\n  /** @type {SyncHook<[Iterable<Module>, any]>} */\n  recordModules: new SyncHook(["modules", "records"]),\n  /** @type {SyncHook<[Iterable<Chunk>, any]>} */\n  recordChunks: new SyncHook(["chunks", "records"]),\n\n  /** @type {SyncHook<[Iterable<Module>]>} */\n  optimizeCodeGeneration: new SyncHook(["modules"]),\n\n  /** @type {SyncHook<[]>} */\n  beforeModuleHash: new SyncHook([]),\n  /** @type {SyncHook<[]>} */\n  afterModuleHash: new SyncHook([]),\n\n  /** @type {SyncHook<[]>} */\n  beforeCodeGeneration: new SyncHook([]),\n  /** @type {SyncHook<[]>} */\n  afterCodeGeneration: new SyncHook([]),\n\n  /** @type {SyncHook<[]>} */\n  beforeRuntimeRequirements: new SyncHook([]),\n  /** @type {SyncHook<[]>} */\n  afterRuntimeRequirements: new SyncHook([]),\n\n  /** @type {SyncHook<[]>} */\n  beforeHash: new SyncHook([]),\n  /** @type {SyncHook<[Chunk]>} */\n  contentHash: new SyncHook(["chunk"]),\n  /** @type {SyncHook<[]>} */\n  afterHash: new SyncHook([]),\n  /** @type {SyncHook<[any]>} */\n  recordHash: new SyncHook(["records"]),\n  /** @type {SyncHook<[Compilation, any]>} */\n  record: new SyncHook(["compilation", "records"]),\n\n  /** @type {SyncHook<[]>} */\n  beforeModuleAssets: new SyncHook([]),\n  /** @type {SyncBailHook<[], boolean>} */\n  shouldGenerateChunkAssets: new SyncBailHook([]),\n  /** @type {SyncHook<[]>} */\n  beforeChunkAssets: new SyncHook([]),\n  /** @type {AsyncSeriesHook<[CompilationAssets]>} */\n  processAdditionalAssets: new AsyncSeriesHook(["assets"]),\n\n  /** @type {SyncBailHook<[], boolean>} */\n  needAdditionalSeal: new SyncBailHook([]),\n  /** @type {AsyncSeriesHook<[]>} */\n  afterSeal: new AsyncSeriesHook([]),\n\n  /** @type {SyncWaterfallHook<[RenderManifestEntry[], RenderManifestOptions]>} */\n  renderManifest: new SyncWaterfallHook(["result", "options"]),\n\n  /** @type {SyncHook<[Hash]>} */\n  fullHash: new SyncHook(["hash"]),\n  /** @type {SyncHook<[Chunk, Hash, ChunkHashContext]>} */\n  chunkHash: new SyncHook(["chunk", "chunkHash", "ChunkHashContext"]),\n\n  /** @type {SyncHook<[Module, string]>} */\n  moduleAsset: new SyncHook(["module", "filename"]),\n  /** @type {SyncHook<[Chunk, string]>} */\n  chunkAsset: new SyncHook(["chunk", "filename"]),\n\n  /** @type {SyncWaterfallHook<[string, object, AssetInfo]>} */\n  assetPath: new SyncWaterfallHook(["path", "options", "assetInfo"]),\n\n  /** @type {SyncBailHook<[], boolean>} */\n  needAdditionalPass: new SyncBailHook([]),\n\n  /** @type {SyncHook<[Compiler, string, number]>} */\n  childCompiler: new SyncHook([\n    "childCompiler",\n    "compilerName",\n    "compilerIndex"\n  ]),\n\n  /** @type {SyncBailHook<[string, LogEntry], true>} */\n  log: new SyncBailHook(["origin", "logEntry"]),\n\n  /** @type {SyncWaterfallHook<[WebpackError[]]>} */\n  processWarnings: new SyncWaterfallHook(["warnings"]),\n  /** @type {SyncWaterfallHook<[WebpackError[]]>} */\n  processErrors: new SyncWaterfallHook(["errors"]),\n\n  /** @type {HookMap<SyncHook<[Partial<NormalizedStatsOptions>, CreateStatsOptionsContext]>>} */\n  statsPreset: new HookMap(() => new SyncHook(["options", "context"])),\n  /** @type {SyncHook<[Partial<NormalizedStatsOptions>, CreateStatsOptionsContext]>} */\n  statsNormalize: new SyncHook(["options", "context"]),\n  /** @type {SyncHook<[StatsFactory, NormalizedStatsOptions]>} */\n  statsFactory: new SyncHook(["statsFactory", "options"]),\n  /** @type {SyncHook<[StatsPrinter, NormalizedStatsOptions]>} */\n  statsPrinter: new SyncHook(["statsPrinter", "options"]),\n\n  get normalModuleLoader() {\n    return getNormalModuleLoader();\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n',normalizedContent:'# 目录\n\n\n\n * 目录\n * compilation.addentry\n * addmoduletree\n * handlemodulecreation\n   * factorizemodule\n   * addmodule\n * modulegraph\n * asyncqueue\n * compilation.hook\n\n\n\n我们已经知道在 compiler.compile 中会创建 compilation，并且在 compilerhook.make 触发时会调用 compilation.addentry ，此时 entrydependency 已经被创建。\n\n当 compilerhook.make 触发之后，就正式进入了 make 阶段的内容。\n\n本节将探讨 webpack 构建流程中 make 阶段的如下工作：\n\n * compilation.addentry\n\n\n# compilation.addentry\n\n内部调用 _addentryitem 。 _addentryitem 将会被 addentry 和 addinclude 。\n\n// lib/compilation.js\n_addentryitem(context, entry, target, options, callback) {\n  const { name } = options;\n  // 获取 entrydata，无 name 则使用 globalentry\n  let entrydata =\n    name !== undefined ? this.entries.get(name) : this.globalentry;\n  if (entrydata === undefined) {\n    // 创建 entrydata，包含 dependencies 和 includedependencies\n    entrydata = {\n      dependencies: [],\n      includedependencies: [],\n      options: {\n        name: undefined,\n        ...options\n      }\n    };\n    // target 为 dependencies 或者 includedependencies\n    // 将 entry 推入 entrydata 中相应类型的依赖列表\n    entrydata[target].push(entry);\n    // 将 entrydata 缓存到 entries，entries<name, entrydata>\n    this.entries.set(name, entrydata);\n  } else {\n    entrydata[target].push(entry);\n    // 将 options 中的新增属性复制到 entrydata.options\n    for (const key of object.keys(options)) {\n      if (options[key] === undefined) continue;\n      if (entrydata.options[key] === options[key]) continue;\n      if (\n        array.isarray(entrydata.options[key]) &&\n        array.isarray(options[key]) &&\n        arrayequals(entrydata.options[key], options[key])\n      ) {\n        continue;\n      }\n      if (entrydata.options[key] === undefined) {\n        entrydata.options[key] = options[key];\n      } else {\n        return callback(\n          new webpackerror(\n            `conflicting entry option ${key} = ${entrydata.options[key]} vs ${options[key]}`\n          )\n        );\n      }\n    }\n  }\n  // 触发 compilationhook.addentry => call\n  this.hooks.addentry.call(entry, options);\n  // 调用 compilation.addmoduletree 开始构建 moduletree\n  this.addmoduletree(\n    {\n      context,\n      dependency: entry,\n      contextinfo: entrydata.options.layer\n        ? { issuerlayer: entrydata.options.layer }\n        : undefined\n    },\n    // finished callback\n    (err, module) => {\n      if (err) {\n        // 触发 compilationhook.failedentry => call\n        this.hooks.failedentry.call(entry, options, err);\n        return callback(err);\n      }\n      // 触发 compilationhook.succeedentry => call\n      this.hooks.succeedentry.call(entry, options, module);\n      return callback(null, module);\n    }\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n * entries 的结构是 map<name, {dependencies: [],includedependencies: []}> , entry 本质是 entrydependency 对象。\n * 调用 addmoduletree 根据 dependence 对象创建 module 对象，并将 module 添加到 modulegraph。\n\n\n# addmoduletree\n\n传递 modulefactory，并调用 handlemodulecreation 创建 module。\n\n// lib/compilation.js\naddmoduletree({ context, dependency, contextinfo }, callback) {\n  const dep = /** @type {depconstructor} */ (dependency.constructor);\n  // 根据 dependency 的构造器可以获取到 modulefactory\n  const modulefactory = this.dependencyfactories.get(dep);\n\n  this.handlemodulecreation(\n    {\n      factory: modulefactory,\n      dependencies: [dependency],\n      originmodule: null,\n      contextinfo,\n      context\n    },\n    // ......\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# handlemodulecreation\n\n// lib/compilation.js\nhandlemodulecreation = () => {\n  // this.modulegraph = new modulegraph();\n  const modulegraph = this.modulegraph;\n  // factorizemodule 通过相应的 modulefactory 创建 module\n  this.factorizemodule(\n   {\n    currentprofile,\n    factory,\n    dependencies,\n    factoryresult: true,\n    originmodule,\n    contextinfo,\n    context\n   }, (err, factoryresult) => {\n   // 将 entry 中  filedependencies、contextdependencies、missingdependencies 收集起来\n  const applyfactoryresultdependencies = () => {\n   const { filedependencies, contextdependencies, missingdependencies } =\n    factoryresult;\n   if (filedependencies) {\n    this.filedependencies.addall(filedependencies);\n   }\n   if (contextdependencies) {\n    this.contextdependencies.addall(contextdependencies);\n   }\n   if (missingdependencies) {\n    this.missingdependencies.addall(missingdependencies);\n   }\n  };\n\n  // 在任务回调中 获得 module\n  const newmodule = factoryresult.module;\n    // 将 module 加入到 addmodulequeue 队列\n    this.addmodule(newmodule, (err, module) => {\n      applyfactoryresultdependencies();\n      // 循环 dependencies，将 dependency 设置到 modulegraph\n      for (let i = 0; i < dependencies.length; i++) {\n       const dependency = dependencies[i];\n       modulegraph.setresolvedmodule(\n        connectorigin ? originmodule : null,\n        dependency,\n        module\n       );\n      }\n      this._handlemodulebuildanddependencies(\n        originmodule,\n        module,\n        recursive,\n        callback\n       );\n    })\n })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n总结如下：\n\n * factorizemodule 通过 modulefactory 创建 module 和 moduledependencies。\n * addmodule 将 module 添加到 modulegraph，同时将 moduledependencies 分别添加到 filedependencies 、 contextdependencies 或者 missingdependencies 。\n\n\n# factorizemodule\n\nfunction (options, callback) {\n  this.factorizequeue.add(options, callback);\n}\n\n\n1\n2\n3\n\n\nfactorizemodule 将 factorizemodule 的任务加入到 factorizequeue，其 processor 为 _factorizemodule。\n\n_factorizemodule() {\n  factory.create(/*......*/, (err, result) => {\n    callback(null, factoryresult ? result : result.module);\n  })\n}\n\n\n1\n2\n3\n4\n5\n\n\n_factorizemodule 中的 factory 即为 entryplugin (或者其他插件) 为 dependence 注册的 modulefactory ，是创建 module 的工厂函数。以 normalmodulefactory 为例：\n\ncreate(data, callback) {\n  const resolvedata = {\n   contextinfo,\n   resolveoptions,\n   context,\n   request,\n   assertions,\n   dependencies,\n   dependencytype,\n   filedependencies,\n   missingdependencies,\n   contextdependencies,\n   createdata: {},\n   cacheable: true\n  };\n  // 触发 compilationhook.beforeresolve => callasync\n  this.hooks.beforeresolve.callasync(resolvedata, (err, result) => {\n    // 触发 compilationhook.factorize => callasync\n    this.hooks.factorize.callasync(resolvedata, (err, module) => {}\n  )})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# addmodule\n\naddmodule 将 module 包装成任务加入 addmodulequeue 队列，processor 是 _addmodule 函数。\n\naddmodule(module, callback) {\n this.addmodulequeue.add(module, callback);\n}\n_addmodule(module, callback) {\n const identifier = module.identifier();\n // 如果 modules 已经在 _modules，直接 callback\n const alreadyaddedmodule = this._modules.get(identifier);\n if (alreadyaddedmodule) {\n  return callback(null, alreadyaddedmodule);\n }\n// ......\n\n // 尝试从缓存中获取相同 identifier 的 module\n this._modulescache.get(identifier, null, (err, cachemodule) => {\n    // ......\n  // 如果命中缓存，以 cachemodule 为模板进行更新\n  if (cachemodule) {\n   cachemodule.updatecachemodule(module);\n   // 将 cachemodule 作为 module\n   module = cachemodule;\n  }\n  // 将 module 设置到 _modules\n  this._modules.set(identifier, module);\n  // 将 module 加入到 modules，注意 _modules 是 map，用于查找，modules 是 set\n  this.modules.add(module);\n  // ......\n  callback(null, module);\n });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n_addmodule 将 module 加入到 _modules 和 module 。\n\n\n# modulegraph\n\n\n# asyncqueue\n\ncompilation 中的 asyncqueue，包括 processdependenciesqueue、addmodulequeue、factorizequeue、buildqueue、rebuildqueue，前四者是父子结构。\n\n/** @type {asyncqueue<module, module, module>} */\nthis.processdependenciesqueue = new asyncqueue({\n name: "processdependencies",\n parallelism: options.parallelism || 100,\n processor: this._processmoduledependencies.bind(this),\n});\n/** @type {asyncqueue<module, string, module>} */\nthis.addmodulequeue = new asyncqueue({\n name: "addmodule",\n parent: this.processdependenciesqueue,\n getkey: (module) => module.identifier(),\n processor: this._addmodule.bind(this),\n});\n/** @type {asyncqueue<factorizemoduleoptions, string, module | modulefactoryresult>} */\nthis.factorizequeue = new asyncqueue({\n name: "factorize",\n parent: this.addmodulequeue,\n processor: this._factorizemodule.bind(this),\n});\n/** @type {asyncqueue<module, module, module>} */\nthis.buildqueue = new asyncqueue({\n name: "build",\n parent: this.factorizequeue,\n processor: this._buildmodule.bind(this),\n});\n/** @type {asyncqueue<module, module, module>} */\nthis.rebuildqueue = new asyncqueue({\n name: "rebuild",\n parallelism: options.parallelism || 100,\n processor: this._rebuildmodule.bind(this),\n});\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# compilation.hook\n\nthis.hooks = object.freeze({\n  /** @type {synchook<[module]>} */\n  buildmodule: new synchook(["module"]),\n  /** @type {synchook<[module]>} */\n  rebuildmodule: new synchook(["module"]),\n  /** @type {synchook<[module, webpackerror]>} */\n  failedmodule: new synchook(["module", "error"]),\n  /** @type {synchook<[module]>} */\n  succeedmodule: new synchook(["module"]),\n  /** @type {synchook<[module]>} */\n  stillvalidmodule: new synchook(["module"]),\n\n  /** @type {synchook<[dependency, entryoptions]>} */\n  addentry: new synchook(["entry", "options"]),\n  /** @type {synchook<[dependency, entryoptions, error]>} */\n  failedentry: new synchook(["entry", "options", "error"]),\n  /** @type {synchook<[dependency, entryoptions, module]>} */\n  succeedentry: new synchook(["entry", "options", "module"]),\n\n  /** @type {syncwaterfallhook<[(string[] | referencedexport)[], dependency, runtimespec]>} */\n  dependencyreferencedexports: new syncwaterfallhook([\n    "referencedexports",\n    "dependency",\n    "runtime"\n  ]),\n\n  /** @type {synchook<[executemoduleargument, executemodulecontext]>} */\n  executemodule: new synchook(["options", "context"]),\n  /** @type {asyncparallelhook<[executemoduleargument, executemodulecontext]>} */\n  preparemoduleexecution: new asyncparallelhook(["options", "context"]),\n\n  /** @type {asyncserieshook<[iterable<module>]>} */\n  finishmodules: new asyncserieshook(["modules"]),\n  /** @type {asyncserieshook<[module]>} */\n  finishrebuildingmodule: new asyncserieshook(["module"]),\n  /** @type {synchook<[]>} */\n  unseal: new synchook([]),\n  /** @type {synchook<[]>} */\n  seal: new synchook([]),\n\n  /** @type {synchook<[]>} */\n  beforechunks: new synchook([]),\n  /** @type {synchook<[iterable<chunk>]>} */\n  afterchunks: new synchook(["chunks"]),\n\n  /** @type {syncbailhook<[iterable<module>]>} */\n  optimizedependencies: new syncbailhook(["modules"]),\n  /** @type {synchook<[iterable<module>]>} */\n  afteroptimizedependencies: new synchook(["modules"]),\n\n  /** @type {synchook<[]>} */\n  optimize: new synchook([]),\n  /** @type {syncbailhook<[iterable<module>]>} */\n  optimizemodules: new syncbailhook(["modules"]),\n  /** @type {synchook<[iterable<module>]>} */\n  afteroptimizemodules: new synchook(["modules"]),\n\n  /** @type {syncbailhook<[iterable<chunk>, chunkgroup[]]>} */\n  optimizechunks: new syncbailhook(["chunks", "chunkgroups"]),\n  /** @type {synchook<[iterable<chunk>, chunkgroup[]]>} */\n  afteroptimizechunks: new synchook(["chunks", "chunkgroups"]),\n\n  /** @type {asyncserieshook<[iterable<chunk>, iterable<module>]>} */\n  optimizetree: new asyncserieshook(["chunks", "modules"]),\n  /** @type {synchook<[iterable<chunk>, iterable<module>]>} */\n  afteroptimizetree: new synchook(["chunks", "modules"]),\n\n  /** @type {asyncseriesbailhook<[iterable<chunk>, iterable<module>]>} */\n  optimizechunkmodules: new asyncseriesbailhook(["chunks", "modules"]),\n  /** @type {synchook<[iterable<chunk>, iterable<module>]>} */\n  afteroptimizechunkmodules: new synchook(["chunks", "modules"]),\n  /** @type {syncbailhook<[], boolean>} */\n  shouldrecord: new syncbailhook([]),\n\n  /** @type {synchook<[chunk, set<string>, runtimerequirementscontext]>} */\n  additionalchunkruntimerequirements: new synchook([\n    "chunk",\n    "runtimerequirements",\n    "context"\n  ]),\n  /** @type {hookmap<syncbailhook<[chunk, set<string>, runtimerequirementscontext]>>} */\n  runtimerequirementinchunk: new hookmap(\n    () => new syncbailhook(["chunk", "runtimerequirements", "context"])\n  ),\n  /** @type {synchook<[module, set<string>, runtimerequirementscontext]>} */\n  additionalmoduleruntimerequirements: new synchook([\n    "module",\n    "runtimerequirements",\n    "context"\n  ]),\n  /** @type {hookmap<syncbailhook<[module, set<string>, runtimerequirementscontext]>>} */\n  runtimerequirementinmodule: new hookmap(\n    () => new syncbailhook(["module", "runtimerequirements", "context"])\n  ),\n  /** @type {synchook<[chunk, set<string>, runtimerequirementscontext]>} */\n  additionaltreeruntimerequirements: new synchook([\n    "chunk",\n    "runtimerequirements",\n    "context"\n  ]),\n  /** @type {hookmap<syncbailhook<[chunk, set<string>, runtimerequirementscontext]>>} */\n  runtimerequirementintree: new hookmap(\n    () => new syncbailhook(["chunk", "runtimerequirements", "context"])\n  ),\n\n  /** @type {synchook<[runtimemodule, chunk]>} */\n  runtimemodule: new synchook(["module", "chunk"]),\n\n  /** @type {synchook<[iterable<module>, any]>} */\n  revivemodules: new synchook(["modules", "records"]),\n  /** @type {synchook<[iterable<module>]>} */\n  beforemoduleids: new synchook(["modules"]),\n  /** @type {synchook<[iterable<module>]>} */\n  moduleids: new synchook(["modules"]),\n  /** @type {synchook<[iterable<module>]>} */\n  optimizemoduleids: new synchook(["modules"]),\n  /** @type {synchook<[iterable<module>]>} */\n  afteroptimizemoduleids: new synchook(["modules"]),\n\n  /** @type {synchook<[iterable<chunk>, any]>} */\n  revivechunks: new synchook(["chunks", "records"]),\n  /** @type {synchook<[iterable<chunk>]>} */\n  beforechunkids: new synchook(["chunks"]),\n  /** @type {synchook<[iterable<chunk>]>} */\n  chunkids: new synchook(["chunks"]),\n  /** @type {synchook<[iterable<chunk>]>} */\n  optimizechunkids: new synchook(["chunks"]),\n  /** @type {synchook<[iterable<chunk>]>} */\n  afteroptimizechunkids: new synchook(["chunks"]),\n\n  /** @type {synchook<[iterable<module>, any]>} */\n  recordmodules: new synchook(["modules", "records"]),\n  /** @type {synchook<[iterable<chunk>, any]>} */\n  recordchunks: new synchook(["chunks", "records"]),\n\n  /** @type {synchook<[iterable<module>]>} */\n  optimizecodegeneration: new synchook(["modules"]),\n\n  /** @type {synchook<[]>} */\n  beforemodulehash: new synchook([]),\n  /** @type {synchook<[]>} */\n  aftermodulehash: new synchook([]),\n\n  /** @type {synchook<[]>} */\n  beforecodegeneration: new synchook([]),\n  /** @type {synchook<[]>} */\n  aftercodegeneration: new synchook([]),\n\n  /** @type {synchook<[]>} */\n  beforeruntimerequirements: new synchook([]),\n  /** @type {synchook<[]>} */\n  afterruntimerequirements: new synchook([]),\n\n  /** @type {synchook<[]>} */\n  beforehash: new synchook([]),\n  /** @type {synchook<[chunk]>} */\n  contenthash: new synchook(["chunk"]),\n  /** @type {synchook<[]>} */\n  afterhash: new synchook([]),\n  /** @type {synchook<[any]>} */\n  recordhash: new synchook(["records"]),\n  /** @type {synchook<[compilation, any]>} */\n  record: new synchook(["compilation", "records"]),\n\n  /** @type {synchook<[]>} */\n  beforemoduleassets: new synchook([]),\n  /** @type {syncbailhook<[], boolean>} */\n  shouldgeneratechunkassets: new syncbailhook([]),\n  /** @type {synchook<[]>} */\n  beforechunkassets: new synchook([]),\n  /** @type {asyncserieshook<[compilationassets]>} */\n  processadditionalassets: new asyncserieshook(["assets"]),\n\n  /** @type {syncbailhook<[], boolean>} */\n  needadditionalseal: new syncbailhook([]),\n  /** @type {asyncserieshook<[]>} */\n  afterseal: new asyncserieshook([]),\n\n  /** @type {syncwaterfallhook<[rendermanifestentry[], rendermanifestoptions]>} */\n  rendermanifest: new syncwaterfallhook(["result", "options"]),\n\n  /** @type {synchook<[hash]>} */\n  fullhash: new synchook(["hash"]),\n  /** @type {synchook<[chunk, hash, chunkhashcontext]>} */\n  chunkhash: new synchook(["chunk", "chunkhash", "chunkhashcontext"]),\n\n  /** @type {synchook<[module, string]>} */\n  moduleasset: new synchook(["module", "filename"]),\n  /** @type {synchook<[chunk, string]>} */\n  chunkasset: new synchook(["chunk", "filename"]),\n\n  /** @type {syncwaterfallhook<[string, object, assetinfo]>} */\n  assetpath: new syncwaterfallhook(["path", "options", "assetinfo"]),\n\n  /** @type {syncbailhook<[], boolean>} */\n  needadditionalpass: new syncbailhook([]),\n\n  /** @type {synchook<[compiler, string, number]>} */\n  childcompiler: new synchook([\n    "childcompiler",\n    "compilername",\n    "compilerindex"\n  ]),\n\n  /** @type {syncbailhook<[string, logentry], true>} */\n  log: new syncbailhook(["origin", "logentry"]),\n\n  /** @type {syncwaterfallhook<[webpackerror[]]>} */\n  processwarnings: new syncwaterfallhook(["warnings"]),\n  /** @type {syncwaterfallhook<[webpackerror[]]>} */\n  processerrors: new syncwaterfallhook(["errors"]),\n\n  /** @type {hookmap<synchook<[partial<normalizedstatsoptions>, createstatsoptionscontext]>>} */\n  statspreset: new hookmap(() => new synchook(["options", "context"])),\n  /** @type {synchook<[partial<normalizedstatsoptions>, createstatsoptionscontext]>} */\n  statsnormalize: new synchook(["options", "context"]),\n  /** @type {synchook<[statsfactory, normalizedstatsoptions]>} */\n  statsfactory: new synchook(["statsfactory", "options"]),\n  /** @type {synchook<[statsprinter, normalizedstatsoptions]>} */\n  statsprinter: new synchook(["statsprinter", "options"]),\n\n  get normalmoduleloader() {\n    return getnormalmoduleloader();\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"make 阶段：module",frontmatter:{title:"make 阶段：module",date:"2022-04-25T15:52:15.000Z",permalink:"/webpack/make/module/",categories:["webpack","make阶段"],tags:[null]},regularPath:"/30.web/7.webpack/30.make%E9%98%B6%E6%AE%B5/20.module.html",relativePath:"30.web/7.webpack/30.make阶段/20.module.md",key:"v-8da47476",path:"/webpack/make/module/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:102},{level:2,title:"_handleModuleBuildAndDependencies",slug:"handlemodulebuildanddependencies",normalizedTitle:"_handlemodulebuildanddependencies",charIndex:117},{level:2,title:"buildModule",slug:"buildmodule",normalizedTitle:"buildmodule",charIndex:154},{level:2,title:"build",slug:"build",normalizedTitle:"build",charIndex:154},{level:3,title:"Build",slug:"build-2",normalizedTitle:"build",charIndex:130},{level:3,title:"Parse",slug:"parse",normalizedTitle:"parse",charIndex:191},{level:2,title:"JavascriptParser",slug:"javascriptparser",normalizedTitle:"javascriptparser",charIndex:200},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:220}],excerpt:"<TimeToRead />\n<p>在上一节中，我们追踪了 compilation.addEntry 函数，围绕着 compilation 探讨了 Module 对象的创建过程。在本节中，我们继续来探讨 module 的打包过程。</p>\n",readingTime:{text:"6 min read",minutes:5.55,time:333e3,words:1110},headersStr:"目录 _handleModuleBuildAndDependencies buildModule build Build Parse JavascriptParser 参考",content:'在上一节中，我们追踪了 compilation.addEntry 函数，围绕着 compilation 探讨了 Module 对象的创建过程。在本节中，我们继续来探讨 module 的打包过程。\n\n\n# 目录\n\n\n\n * 目录\n * _handleModuleBuildAndDependencies\n * buildModule\n * build\n   * Build\n   * Parse\n * JavascriptParser\n * 参考\n\n\n\n\n# _handleModuleBuildAndDependencies\n\nthis.buildModule(module, (err) => {\n // ......\n // Module 已经在 processDependenciesQueue 中处理，直接 callback\n // This avoids deadlocks for circular dependencies\n if (this.processDependenciesQueue.isProcessing(module)) {\n  return callback();\n }\n // 调用 processModuleDependencies 处理模块依赖\n this.processModuleDependencies(module, (err) => {\n  // ......\n  callback(null, module);\n });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这个函数调用 buildModule 打包模块，并且调用 processModuleDependencies 处理模块依赖。\n\n\n# buildModule\n\nbuildModule(module, callback) {\n  this.buildQueue.add(module, callback);\n}\n\n\n1\n2\n3\n\n\nbuildModule 将 module 封装成任务放入 buildQueue 队列，buildQueue 队列的 processor 为 _buildModule 。在 processor 中将处理 module。\n\n下面我们赵忠看下 _buildModule 函数。\n\nfunction _buildModule(module, callback) {\n // 检查 module 是否需要 build\n module.needBuild(\n  {\n   compilation: this,\n   fileSystemInfo: this.fileSystemInfo,\n   valueCacheVersions: this.valueCacheVersions,\n  },\n  (err, needBuild) => {\n   // ......\n\n   if (!needBuild) {\n    // 不需要 build, 触发 CompilationHook.stillValidModule => call\n    this.hooks.stillValidModule.call(module);\n    return callback();\n   }\n   // 触发 CompilationHook.buildModule => call\n   this.hooks.buildModule.call(module);\n   // 将 module 加入到 builtModules\n   // this.builtModules = new WeakSet();\n   this.builtModules.add(module);\n   // 开始 build\n   module.build(\n    this.options,\n    this,\n    this.resolverFactory.get("normal", module.resolveOptions),\n    this.inputFileSystem,\n    (err) => {\n     // ......\n    }\n   );\n  }\n );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n因为每一个 module 对象都拥有自己的 module.needBuild 方法和 module.build 方法，下面以 NormalModule 为例继续探讨。\n\nfunction needBuild(context, callback) {\n const { fileSystemInfo, compilation, valueCacheVersions } = context;\n // build if enforced\n if (this._forceBuild) return callback(null, true);\n\n // always try to build in case of an error\n if (this.error) return callback(null, true);\n // 配置 cacheable 和 snapshot 可以过滤掉部分无效的 build\n // always build when module is not cacheable\n if (!this.buildInfo.cacheable) return callback(null, true);\n\n // build when there is no snapshot to check\n if (!this.buildInfo.snapshot) return callback(null, true);\n\n // build when valueDependencies have changed\n /** @type {Map<string, string | Set<string>>} */\n const valueDependencies = this.buildInfo.valueDependencies;\n if (valueDependencies) {\n  if (!valueCacheVersions) return callback(null, true);\n  // 循环 buildInfo.valueDependencies，检查 context.valueCacheVersions 中依赖是否相同\n  for (const [key, value] of valueDependencies) {\n   if (value === undefined) return callback(null, true);\n   const current = valueCacheVersions.get(key);\n   if (\n    value !== current &&\n    (typeof value === "string" ||\n     typeof current === "string" ||\n     current === undefined ||\n     !isSubset(value, current))\n   ) {\n    return callback(null, true);\n   }\n  }\n }\n\n // check snapshot for validity\n fileSystemInfo.checkSnapshotValid(this.buildInfo.snapshot, (err, valid) => {\n  if (err) return callback(err);\n  if (!valid) return callback(null, true);\n  const hooks = NormalModule.getCompilationHooks(compilation);\n  // 如果 buildInfo.snapshot 是合法的，触发 CompilationHook.needBuild => callAsync\n  hooks.needBuild.callAsync(this, context, (err, needBuild) => {\n   // ......\n   callback(null, !!needBuild);\n  });\n });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\nmodule.needBuild 是对 build 性能很好的优化手段。\n\n\n# build\n\n\n# Build\n\nbuild 内部调用 _doBuild 。现在我们来看下 Build 的过程。\n\n// lib/NormalModule.js\n_doBuild(options, compilation, resolver, fs, hooks, callback) {\n // 创建 loaderContext，提供给 loader 的 context(方法和属性)\n const loaderContext = this._createLoaderContext(\n  resolver,\n  options,\n  compilation,\n  fs,\n  hooks\n );\n // 初始化 fileDependencies、contextDependencies、missingDependencies 容器\n this.buildInfo.fileDependencies = new LazySet();\n this.buildInfo.contextDependencies = new LazySet();\n this.buildInfo.missingDependencies = new LazySet();\n this.buildInfo.cacheable = true;\n\n // 触发 CompilationHook.beforeLoaders => call\n hooks.beforeLoaders.call(this.loaders, this, loaderContext);\n // ......\n if (this.loaders.length > 0) {\n  // 初始化 buildDependencies\n  this.buildInfo.buildDependencies = new LazySet();\n }\n // 调用 loader-runner.runLoaders 加载源文件\n runLoaders(\n  {\n   // resource path\n   resource: this.resource,\n   // module loaders\n   loaders: this.loaders,\n   // module loader context\n   context: loaderContext,\n   // 处理资源的回调\n   processResource: (loaderContext, resourcePath, callback) => {\n    const resource = loaderContext.resource;\n    // 获取 resource 的 scheme\n    const scheme = getScheme(resource);\n    // CompilationHook.readResource 是 HookMap，可使用 .for\n    // 通过不同的 scheme 选择 HookMap 中的 Hook\n    hooks.readResource\n     .for(scheme)\n     // 调用  CompilationHook.readResource.scheme => callAsync\n     .callAsync(loaderContext, (err, result) => {\n      // ......\n      return callback(null, result);\n     });\n   },\n  },\n  (err, result) => {\n   // ......\n   // 收集 fileDependencies，contextDependencies 和 missingDependencies\n   this.buildInfo.fileDependencies.addAll(result.fileDependencies);\n   this.buildInfo.contextDependencies.addAll(result.contextDependencies);\n   this.buildInfo.missingDependencies.addAll(result.missingDependencies);\n   // 缓存 loader\n   for (const loader of this.loaders) {\n    this.buildInfo.buildDependencies.add(loader.loader);\n   }\n   this.buildInfo.cacheable = this.buildInfo.cacheable && result.cacheable;\n   // 处理 loader 返回的结果\n   processResult(err, result.result);\n  }\n );\n}\n\nconst processResult = (err, result) => {\n // ......\n // 获取 source、sourceMap 和 extraInfo\n const source = result[0];\n const sourceMap = result.length >= 1 ? result[1] : null;\n const extraInfo = result.length >= 2 ? result[2] : null;\n\n // ......\n // 创建 RawSource 对象\n this._source = this.createSource(\n  options.context,\n  this.binary ? asBuffer(source) : asString(source),\n  sourceMap,\n  compilation.compiler.root\n );\n // ......\n // 如果 extraInfo 中提供了 AST，则缓存\n this._ast =\n  typeof extraInfo === "object" &&\n  extraInfo !== null &&\n  extraInfo.webpackAST !== undefined\n   ? extraInfo.webpackAST\n   : null;\n return callback();\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n\n\n核心作用如下：\n\n * runLoaders 调用 loader-runner 包的方法处理源文件，将源文件处理为 webpack 识别的 JavaScript 源代码。创建 loaderContext 可传递给 loader 使用。\n * loader 处理的结果包含 Dependencies 和 content。Dependencies 将收集到 fileDependencies，contextDependencies 和 missingDependencies。content 将处理为 RawSource 对象。content 可能为 string 或者 buffer（二进制）。\n\n\n# Parse\n\nbuild(options, compilation, resolver, fs, callback) {\n // ......\n // 调用 _doBuild 完成 Build 工作，在回调中完成 Parse 工作。\n return this._doBuild(options, compilation, resolver, fs, hooks, (err) => {\n  // 触发 CompilationHook.beforeParse => call\n  hooks.beforeParse.call(this);\n  // 如果配置了 module.noParse，退出 parse\n  const noParseRule = options.module && options.module.noParse;\n  if (this.shouldPreventParsing(noParseRule, this.request)) {\n   // We assume that we need module and exports\n   this.buildInfo.parsed = false;\n   this._initBuildHash(compilation);\n   return handleBuildDone();\n  }\n\n  let result;\n  // 获取到源代码(string | buffer)\n  const source = this._source.source();\n  // 使用 Parser parse 源代码为 AST\n  // 注意：result 不是 AST 而是 state，AST 在 JavaScriptParser parse 中 触发 JavaScriptParserHook.finish\n  result = this.parser.parse(this._ast || source, {\n   source,\n   current: this,\n   module: this,\n   compilation: compilation,\n   options: options,\n  });\n  handleParseResult(result);\n });\n}\n\nconst handleParseResult = (result) => {\n // 依赖排序\n this.dependencies.sort(\n  concatComparators(\n   compareSelect((a) => a.loc, compareLocations),\n   keepOriginalOrder(this.dependencies)\n  )\n );\n // 初始化 build hash\n this._initBuildHash(compilation);\n this._lastSuccessfulBuildMeta = this.buildMeta;\n // 完成 build\n return handleBuildDone();\n};\n\nconst handleBuildDone = () => {\n // 触发 CompilationHook.beforeSnapshot => call\n hooks.beforeSnapshot.call(this);\n\n // 获取创建快照的 options\n const snapshotOptions = compilation.options.snapshot.module;\n // 如果没有配置 cacheable 或者 snapshotOptions 直接 callback\n if (!this.buildInfo.cacheable || !snapshotOptions) {\n  return callback();\n }\n // ......\n // 检查依赖\n checkDependencies(this.buildInfo.fileDependencies);\n checkDependencies(this.buildInfo.missingDependencies);\n checkDependencies(this.buildInfo.contextDependencies);\n //  ......\n // 为依赖（file/context/missingDependencies）创建快照，写入 filesystem\n // convert file/context/missingDependencies into filesystem snapshot\n compilation.fileSystemInfo.createSnapshot(\n  startTime,\n  this.buildInfo.fileDependencies,\n  this.buildInfo.contextDependencies,\n  this.buildInfo.missingDependencies,\n  snapshotOptions,\n  (err, snapshot) => {\n   // ......\n   // 清空依赖并缓存快照\n   this.buildInfo.fileDependencies = undefined;\n   this.buildInfo.contextDependencies = undefined;\n   this.buildInfo.missingDependencies = undefined;\n   this.buildInfo.snapshot = snapshot;\n   return callback();\n  }\n );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n总结 build 的核心作用：\n\n * 调用 _doBuild 完成 Build 工作，在回调中完成 Parse 工作。Build 就是使用匹配的 Loader 加载源文件为 source，Parse 就是根据源码生成 AST。\n * 如果配置了 module.noParse，会跳过 Parse 过程。\n * Parser.parse 将 source 转换为 AST。\n * NormalModule 是在 NormalModuleFactory 中创建的，在 compiler.compile 中 newCompilationParams 函数中会创建 normalModuleFactory。NormalModule 在初始化时在 NormalModuleFactoryHook.factorize 触发 NormalModuleFactoryHook.resolve，在回调里执行 getParser。在调用 NormalModuleFactory.create 时即 _factorizeModule 中 factory.create 时触发此钩子。\n * parser 和 generator 是在内置插件 JavascriptModulesPlugin 中加载的，在 CompilerHook.compilation 中 normalModuleFactoryHook.createParser 和 normalModuleFactoryHook.createGenerator 分别创建 JavascriptParser 和 JavascriptGenerator 。参见 lib/javascript/JavascriptModulesPlugin.js 和 lib/NormalModuleFactory.js 。\n\n\n# JavascriptParser\n\n// lib/javascript/JavascriptParser.js\nconst { Parser: AcornParser } = require("acorn");\nconst { importAssertions } = require("acorn-import-assertions");\nconst parser = AcornParser.extend(importAssertions);\n\nparse(source, state) {\n  // ......\n  const ast = JavascriptParser._parse(source, {\n    sourceType: this.sourceType,\n    onComment: comments,\n    onInsertedSemicolon: pos => semicolons.add(pos)\n  });\n  // ......\n  // JavaScriptParserHook.program 为 SyncBailHook \n  if (this.hooks.program.call(ast, comments) === undefined) {\n   // 标记内部标记 isStrict、isAsmJs\n   this.detectMode(ast.body);\n   // preWalk AST\n   this.preWalkStatements(ast.body);\n   // 重置 prevStatement\n   this.prevStatement = undefined;\n   // blockPreWalk\n   this.blockPreWalkStatements(ast.body);\n   // 重置 prevStatement\n   this.prevStatement = undefined;\n   // Walk AST\n   this.walkStatements(ast.body);\n  }\n\n  // 触发 JavaScriptParserHook.finish => call\n  this.hooks.finish.call(ast, comments);\n  return state;\n}\n\n_parse(code, options) {\n // ......\n const ast = parser.parse(code, parserOptions);\n // ......\n return ast;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n通过如上的过程，我们了解到 Module 将会经过 Build 和 Parse 的过程，这两个过程分别将文件加载为源代码、将源代码转换为 AST。Build 的过程是经由 loader-runner 包完成的，而 Parse 包是经由 acorn 包完成的。注意：由代码字符串生成 AST 的具体过程，此处不详细探讨，在 acorn 的源码解析中，我们会详细探讨。\n\n\n# 参考\n\n * xtuc/acorn-import-assertions: Support for import assertions in acorn',normalizedContent:'在上一节中，我们追踪了 compilation.addentry 函数，围绕着 compilation 探讨了 module 对象的创建过程。在本节中，我们继续来探讨 module 的打包过程。\n\n\n# 目录\n\n\n\n * 目录\n * _handlemodulebuildanddependencies\n * buildmodule\n * build\n   * build\n   * parse\n * javascriptparser\n * 参考\n\n\n\n\n# _handlemodulebuildanddependencies\n\nthis.buildmodule(module, (err) => {\n // ......\n // module 已经在 processdependenciesqueue 中处理，直接 callback\n // this avoids deadlocks for circular dependencies\n if (this.processdependenciesqueue.isprocessing(module)) {\n  return callback();\n }\n // 调用 processmoduledependencies 处理模块依赖\n this.processmoduledependencies(module, (err) => {\n  // ......\n  callback(null, module);\n });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这个函数调用 buildmodule 打包模块，并且调用 processmoduledependencies 处理模块依赖。\n\n\n# buildmodule\n\nbuildmodule(module, callback) {\n  this.buildqueue.add(module, callback);\n}\n\n\n1\n2\n3\n\n\nbuildmodule 将 module 封装成任务放入 buildqueue 队列，buildqueue 队列的 processor 为 _buildmodule 。在 processor 中将处理 module。\n\n下面我们赵忠看下 _buildmodule 函数。\n\nfunction _buildmodule(module, callback) {\n // 检查 module 是否需要 build\n module.needbuild(\n  {\n   compilation: this,\n   filesysteminfo: this.filesysteminfo,\n   valuecacheversions: this.valuecacheversions,\n  },\n  (err, needbuild) => {\n   // ......\n\n   if (!needbuild) {\n    // 不需要 build, 触发 compilationhook.stillvalidmodule => call\n    this.hooks.stillvalidmodule.call(module);\n    return callback();\n   }\n   // 触发 compilationhook.buildmodule => call\n   this.hooks.buildmodule.call(module);\n   // 将 module 加入到 builtmodules\n   // this.builtmodules = new weakset();\n   this.builtmodules.add(module);\n   // 开始 build\n   module.build(\n    this.options,\n    this,\n    this.resolverfactory.get("normal", module.resolveoptions),\n    this.inputfilesystem,\n    (err) => {\n     // ......\n    }\n   );\n  }\n );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n因为每一个 module 对象都拥有自己的 module.needbuild 方法和 module.build 方法，下面以 normalmodule 为例继续探讨。\n\nfunction needbuild(context, callback) {\n const { filesysteminfo, compilation, valuecacheversions } = context;\n // build if enforced\n if (this._forcebuild) return callback(null, true);\n\n // always try to build in case of an error\n if (this.error) return callback(null, true);\n // 配置 cacheable 和 snapshot 可以过滤掉部分无效的 build\n // always build when module is not cacheable\n if (!this.buildinfo.cacheable) return callback(null, true);\n\n // build when there is no snapshot to check\n if (!this.buildinfo.snapshot) return callback(null, true);\n\n // build when valuedependencies have changed\n /** @type {map<string, string | set<string>>} */\n const valuedependencies = this.buildinfo.valuedependencies;\n if (valuedependencies) {\n  if (!valuecacheversions) return callback(null, true);\n  // 循环 buildinfo.valuedependencies，检查 context.valuecacheversions 中依赖是否相同\n  for (const [key, value] of valuedependencies) {\n   if (value === undefined) return callback(null, true);\n   const current = valuecacheversions.get(key);\n   if (\n    value !== current &&\n    (typeof value === "string" ||\n     typeof current === "string" ||\n     current === undefined ||\n     !issubset(value, current))\n   ) {\n    return callback(null, true);\n   }\n  }\n }\n\n // check snapshot for validity\n filesysteminfo.checksnapshotvalid(this.buildinfo.snapshot, (err, valid) => {\n  if (err) return callback(err);\n  if (!valid) return callback(null, true);\n  const hooks = normalmodule.getcompilationhooks(compilation);\n  // 如果 buildinfo.snapshot 是合法的，触发 compilationhook.needbuild => callasync\n  hooks.needbuild.callasync(this, context, (err, needbuild) => {\n   // ......\n   callback(null, !!needbuild);\n  });\n });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\nmodule.needbuild 是对 build 性能很好的优化手段。\n\n\n# build\n\n\n# build\n\nbuild 内部调用 _dobuild 。现在我们来看下 build 的过程。\n\n// lib/normalmodule.js\n_dobuild(options, compilation, resolver, fs, hooks, callback) {\n // 创建 loadercontext，提供给 loader 的 context(方法和属性)\n const loadercontext = this._createloadercontext(\n  resolver,\n  options,\n  compilation,\n  fs,\n  hooks\n );\n // 初始化 filedependencies、contextdependencies、missingdependencies 容器\n this.buildinfo.filedependencies = new lazyset();\n this.buildinfo.contextdependencies = new lazyset();\n this.buildinfo.missingdependencies = new lazyset();\n this.buildinfo.cacheable = true;\n\n // 触发 compilationhook.beforeloaders => call\n hooks.beforeloaders.call(this.loaders, this, loadercontext);\n // ......\n if (this.loaders.length > 0) {\n  // 初始化 builddependencies\n  this.buildinfo.builddependencies = new lazyset();\n }\n // 调用 loader-runner.runloaders 加载源文件\n runloaders(\n  {\n   // resource path\n   resource: this.resource,\n   // module loaders\n   loaders: this.loaders,\n   // module loader context\n   context: loadercontext,\n   // 处理资源的回调\n   processresource: (loadercontext, resourcepath, callback) => {\n    const resource = loadercontext.resource;\n    // 获取 resource 的 scheme\n    const scheme = getscheme(resource);\n    // compilationhook.readresource 是 hookmap，可使用 .for\n    // 通过不同的 scheme 选择 hookmap 中的 hook\n    hooks.readresource\n     .for(scheme)\n     // 调用  compilationhook.readresource.scheme => callasync\n     .callasync(loadercontext, (err, result) => {\n      // ......\n      return callback(null, result);\n     });\n   },\n  },\n  (err, result) => {\n   // ......\n   // 收集 filedependencies，contextdependencies 和 missingdependencies\n   this.buildinfo.filedependencies.addall(result.filedependencies);\n   this.buildinfo.contextdependencies.addall(result.contextdependencies);\n   this.buildinfo.missingdependencies.addall(result.missingdependencies);\n   // 缓存 loader\n   for (const loader of this.loaders) {\n    this.buildinfo.builddependencies.add(loader.loader);\n   }\n   this.buildinfo.cacheable = this.buildinfo.cacheable && result.cacheable;\n   // 处理 loader 返回的结果\n   processresult(err, result.result);\n  }\n );\n}\n\nconst processresult = (err, result) => {\n // ......\n // 获取 source、sourcemap 和 extrainfo\n const source = result[0];\n const sourcemap = result.length >= 1 ? result[1] : null;\n const extrainfo = result.length >= 2 ? result[2] : null;\n\n // ......\n // 创建 rawsource 对象\n this._source = this.createsource(\n  options.context,\n  this.binary ? asbuffer(source) : asstring(source),\n  sourcemap,\n  compilation.compiler.root\n );\n // ......\n // 如果 extrainfo 中提供了 ast，则缓存\n this._ast =\n  typeof extrainfo === "object" &&\n  extrainfo !== null &&\n  extrainfo.webpackast !== undefined\n   ? extrainfo.webpackast\n   : null;\n return callback();\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n\n\n核心作用如下：\n\n * runloaders 调用 loader-runner 包的方法处理源文件，将源文件处理为 webpack 识别的 javascript 源代码。创建 loadercontext 可传递给 loader 使用。\n * loader 处理的结果包含 dependencies 和 content。dependencies 将收集到 filedependencies，contextdependencies 和 missingdependencies。content 将处理为 rawsource 对象。content 可能为 string 或者 buffer（二进制）。\n\n\n# parse\n\nbuild(options, compilation, resolver, fs, callback) {\n // ......\n // 调用 _dobuild 完成 build 工作，在回调中完成 parse 工作。\n return this._dobuild(options, compilation, resolver, fs, hooks, (err) => {\n  // 触发 compilationhook.beforeparse => call\n  hooks.beforeparse.call(this);\n  // 如果配置了 module.noparse，退出 parse\n  const noparserule = options.module && options.module.noparse;\n  if (this.shouldpreventparsing(noparserule, this.request)) {\n   // we assume that we need module and exports\n   this.buildinfo.parsed = false;\n   this._initbuildhash(compilation);\n   return handlebuilddone();\n  }\n\n  let result;\n  // 获取到源代码(string | buffer)\n  const source = this._source.source();\n  // 使用 parser parse 源代码为 ast\n  // 注意：result 不是 ast 而是 state，ast 在 javascriptparser parse 中 触发 javascriptparserhook.finish\n  result = this.parser.parse(this._ast || source, {\n   source,\n   current: this,\n   module: this,\n   compilation: compilation,\n   options: options,\n  });\n  handleparseresult(result);\n });\n}\n\nconst handleparseresult = (result) => {\n // 依赖排序\n this.dependencies.sort(\n  concatcomparators(\n   compareselect((a) => a.loc, comparelocations),\n   keeporiginalorder(this.dependencies)\n  )\n );\n // 初始化 build hash\n this._initbuildhash(compilation);\n this._lastsuccessfulbuildmeta = this.buildmeta;\n // 完成 build\n return handlebuilddone();\n};\n\nconst handlebuilddone = () => {\n // 触发 compilationhook.beforesnapshot => call\n hooks.beforesnapshot.call(this);\n\n // 获取创建快照的 options\n const snapshotoptions = compilation.options.snapshot.module;\n // 如果没有配置 cacheable 或者 snapshotoptions 直接 callback\n if (!this.buildinfo.cacheable || !snapshotoptions) {\n  return callback();\n }\n // ......\n // 检查依赖\n checkdependencies(this.buildinfo.filedependencies);\n checkdependencies(this.buildinfo.missingdependencies);\n checkdependencies(this.buildinfo.contextdependencies);\n //  ......\n // 为依赖（file/context/missingdependencies）创建快照，写入 filesystem\n // convert file/context/missingdependencies into filesystem snapshot\n compilation.filesysteminfo.createsnapshot(\n  starttime,\n  this.buildinfo.filedependencies,\n  this.buildinfo.contextdependencies,\n  this.buildinfo.missingdependencies,\n  snapshotoptions,\n  (err, snapshot) => {\n   // ......\n   // 清空依赖并缓存快照\n   this.buildinfo.filedependencies = undefined;\n   this.buildinfo.contextdependencies = undefined;\n   this.buildinfo.missingdependencies = undefined;\n   this.buildinfo.snapshot = snapshot;\n   return callback();\n  }\n );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n总结 build 的核心作用：\n\n * 调用 _dobuild 完成 build 工作，在回调中完成 parse 工作。build 就是使用匹配的 loader 加载源文件为 source，parse 就是根据源码生成 ast。\n * 如果配置了 module.noparse，会跳过 parse 过程。\n * parser.parse 将 source 转换为 ast。\n * normalmodule 是在 normalmodulefactory 中创建的，在 compiler.compile 中 newcompilationparams 函数中会创建 normalmodulefactory。normalmodule 在初始化时在 normalmodulefactoryhook.factorize 触发 normalmodulefactoryhook.resolve，在回调里执行 getparser。在调用 normalmodulefactory.create 时即 _factorizemodule 中 factory.create 时触发此钩子。\n * parser 和 generator 是在内置插件 javascriptmodulesplugin 中加载的，在 compilerhook.compilation 中 normalmodulefactoryhook.createparser 和 normalmodulefactoryhook.creategenerator 分别创建 javascriptparser 和 javascriptgenerator 。参见 lib/javascript/javascriptmodulesplugin.js 和 lib/normalmodulefactory.js 。\n\n\n# javascriptparser\n\n// lib/javascript/javascriptparser.js\nconst { parser: acornparser } = require("acorn");\nconst { importassertions } = require("acorn-import-assertions");\nconst parser = acornparser.extend(importassertions);\n\nparse(source, state) {\n  // ......\n  const ast = javascriptparser._parse(source, {\n    sourcetype: this.sourcetype,\n    oncomment: comments,\n    oninsertedsemicolon: pos => semicolons.add(pos)\n  });\n  // ......\n  // javascriptparserhook.program 为 syncbailhook \n  if (this.hooks.program.call(ast, comments) === undefined) {\n   // 标记内部标记 isstrict、isasmjs\n   this.detectmode(ast.body);\n   // prewalk ast\n   this.prewalkstatements(ast.body);\n   // 重置 prevstatement\n   this.prevstatement = undefined;\n   // blockprewalk\n   this.blockprewalkstatements(ast.body);\n   // 重置 prevstatement\n   this.prevstatement = undefined;\n   // walk ast\n   this.walkstatements(ast.body);\n  }\n\n  // 触发 javascriptparserhook.finish => call\n  this.hooks.finish.call(ast, comments);\n  return state;\n}\n\n_parse(code, options) {\n // ......\n const ast = parser.parse(code, parseroptions);\n // ......\n return ast;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n通过如上的过程，我们了解到 module 将会经过 build 和 parse 的过程，这两个过程分别将文件加载为源代码、将源代码转换为 ast。build 的过程是经由 loader-runner 包完成的，而 parse 包是经由 acorn 包完成的。注意：由代码字符串生成 ast 的具体过程，此处不详细探讨，在 acorn 的源码解析中，我们会详细探讨。\n\n\n# 参考\n\n * xtuc/acorn-import-assertions: support for import assertions in acorn',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"make 阶段：walk",frontmatter:{title:"make 阶段：walk",date:"2022-04-25T19:58:49.000Z",permalink:"/webpack/make/walk/",categories:["webpack","make阶段"],tags:[null]},regularPath:"/30.web/7.webpack/30.make%E9%98%B6%E6%AE%B5/30.walk.html",relativePath:"30.web/7.webpack/30.make阶段/30.walk.md",key:"v-4bc1c689",path:"/webpack/make/walk/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:205},{level:2,title:"ParserHook.program",slug:"parserhook-program",normalizedTitle:"parserhook.program",charIndex:220},{level:2,title:"UseStrictPlugin",slug:"usestrictplugin",normalizedTitle:"usestrictplugin",charIndex:242},{level:2,title:"HarmonyDetectionParserPlugin",slug:"harmonydetectionparserplugin",normalizedTitle:"harmonydetectionparserplugin",charIndex:261},{level:2,title:"preWalkStatements",slug:"prewalkstatements",normalizedTitle:"prewalkstatements",charIndex:293},{level:2,title:"defineVariable",slug:"definevariable",normalizedTitle:"definevariable",charIndex:314},{level:2,title:"blockPreWalkStatements",slug:"blockprewalkstatements",normalizedTitle:"blockprewalkstatements",charIndex:332},{level:2,title:"walkStatements",slug:"walkstatements",normalizedTitle:"walkstatements",charIndex:358},{level:2,title:"HarmonyImportDependencyParserPlugin",slug:"harmonyimportdependencyparserplugin",normalizedTitle:"harmonyimportdependencyparserplugin",charIndex:376},{level:2,title:"HarmonyExportDependencyParserPlugin",slug:"harmonyexportdependencyparserplugin",normalizedTitle:"harmonyexportdependencyparserplugin",charIndex:415},{level:2,title:"import/export",slug:"import-export",normalizedTitle:"import/export",charIndex:454},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:471}],excerpt:"<TimeToRead />\n<p>上一节中，我们探讨了单一 Module 的 Build 和 Parse 过程。webpack 的 make 过程是从 EntryModule 开始的。我们知道，文件系统本身是文件树，ModuleDependence 本身也是 DependenceTree，因此从 EntryModule 开始的 make 过程必然是一个递归的过程。这本节内容中，我们来探讨 ModuleTree 的 make 过程。</p>\n",readingTime:{text:"5 min read",minutes:4.42,time:265200,words:884},headersStr:"目录 ParserHook.program UseStrictPlugin HarmonyDetectionParserPlugin preWalkStatements defineVariable blockPreWalkStatements walkStatements HarmonyImportDependencyParserPlugin HarmonyExportDependencyParserPlugin import/export 总结",content:'上一节中，我们探讨了单一 Module 的 Build 和 Parse 过程。webpack 的 make 过程是从 EntryModule 开始的。我们知道，文件系统本身是文件树，ModuleDependence 本身也是 DependenceTree，因此从 EntryModule 开始的 make 过程必然是一个递归的过程。这本节内容中，我们来探讨 ModuleTree 的 make 过程。\n\n\n# 目录\n\n\n\n * 目录\n * ParserHook.program\n * UseStrictPlugin\n * HarmonyDetectionParserPlugin\n * preWalkStatements\n * defineVariable\n * blockPreWalkStatements\n * walkStatements\n * HarmonyImportDependencyParserPlugin\n * HarmonyExportDependencyParserPlugin\n * import/export\n * 总结\n\n\n\n上一节在 JavascriptParser parser.pase 函数的内容中，我们了解到对 Module 的 AST，有如下的过程：\n\nif (this.hooks.program.call(ast, comments) === undefined) {\n  // preWalk AST\n  this.preWalkStatements(ast.body);\n  // blockPreWalk\n  this.blockPreWalkStatements(ast.body);\n  // Walk AST\n  this.walkStatements(ast.body);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这里针对 ast.body 有 preWalk 和 walk 的过程。所谓 preWalk 就是在 walk 之前的处理工作。walk 的过程就是对 AST 进行遍历查找依赖的过程。\n\n\n# ParserHook.program\n\n这个 Hook 为什么叫 program，事情上 acorn 根据 ESTree 的规范 parse 出来的 AST 顶层对象就叫 Program。如下：\n\n{\n  "type": "Program",\n  "start": 0,\n  "end": 25,\n  "body": [\n    {\n      "type": "FunctionDeclaration",\n      "start": 0,\n      "end": 24,\n      "id": {\n        "type": "Identifier",\n        "start": 9,\n        "end": 18,\n        "name": "printTips"\n      },\n      "expression": false,\n      "generator": false,\n      "async": false,\n      "params": [],\n      "body": {\n        "type": "BlockStatement",\n        "start": 21,\n        "end": 24,\n        "body": []\n      }\n    }\n  ],\n  "sourceType": "module"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n参考：\n\n * AST explorer\n\n既然 ParserHook.program 在此时触发，那么我们就来看下有哪些插件在此注册了 Callback。事实上，这样的插件有：\n\n * CompatibilityPlugin\n * DefinePlugin\n * UseStrictPlugin\n * HarmonyDetectionParserPlugin\n * InnerGraphPlugin\n * SideEffectsFlagPlugin\n\n现在我们只能深入这些插件来查看他们针对 AST 做了哪些事情。现在有一个疑点，在 lib/WebpackOptionsApply.js 中注册这些插件时，只传入了 compiler，那么插件中 parser 是怎么获取的呢？我们能在这些插件中找到这样的代码：\n\nnormalModuleFactory.hooks.parser\n.for("javascript/auto")\n.tap("CompatibilityPlugin", handler);\nnormalModuleFactory.hooks.parser\n.for("javascript/dynamic")\n.tap("CompatibilityPlugin", handler);\nnormalModuleFactory.hooks.parser\n.for("javascript/esm")\n.tap("CompatibilityPlugin", handler);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n原来这些插件是在 NormalModuleFactoryHook.parser 钩子中获得 parser 的，并在 handler 中在向 ParserHook.program 注入处理逻辑。\n\n\n# UseStrictPlugin\n\nparser.hooks.program.tap("UseStrictPlugin", (ast) => {\n const firstNode = ast.body[0];\n // 如果是 use strict\n if (\n  firstNode &&\n  firstNode.type === "ExpressionStatement" &&\n  firstNode.expression.type === "Literal" &&\n  firstNode.expression.value === "use strict"\n ) {\n  // Remove "use strict" expression. It will be added later by the renderer again.\n  // This is necessary in order to not break the strict mode when webpack prepends code.\n  // @see https://github.com/webpack/webpack/issues/1970\n  // 删除 use strict 语句，添加 ConstDependency\n  const dep = new ConstDependency("", firstNode.range);\n  dep.loc = firstNode.loc;\n  parser.state.module.addPresentationalDependency(dep);\n  parser.state.module.buildInfo.strict = true;\n }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# HarmonyDetectionParserPlugin\n\nparser.hooks.program.tap("HarmonyDetectionParserPlugin", (ast) => {\n // 如果 Module 是 javascript/esm，则严格使用 HarmonyCompatibilityDependency\n const isStrictHarmony = parser.state.module.type === "javascript/esm";\n // 如果包含 import/export 语句，也需要使用 HarmonyCompatibilityDependency\n const isHarmony =\n  isStrictHarmony ||\n  ast.body.some(\n   (statement) =>\n    statement.type === "ImportDeclaration" ||\n    statement.type === "ExportDefaultDeclaration" ||\n    statement.type === "ExportNamedDeclaration" ||\n    statement.type === "ExportAllDeclaration"\n  );\n // 添加 HarmonyCompatibilityDependency\n if (isHarmony) {\n  const module = parser.state.module;\n  const compatDep = new HarmonyCompatibilityDependency();\n  compatDep.loc = {\n   start: {\n    line: -1,\n    column: 0,\n   },\n   end: {\n    line: -1,\n    column: 0,\n   },\n   index: -3,\n  };\n  module.addPresentationalDependency(compatDep);\n  // ......\n  parser.scope.isStrict = true;\n }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nParserHook.program 时主要针对 AST 中是否有 \'use strict\' 语句和 import/export 语句，分别向 Module 添加 ConstDependency 和 HarmonyCompatibilityDependency。\n\n\n# preWalkStatements\n\n深度遍历（DFS）AST，触发 ParserHook.preStatement，并修改变量声明语句的 scope。\n\n// Pre walking iterates the scope for variable declarations\npreWalkStatements(statements) {\n  for (let index = 0, len = statements.length; index < len; index++) {\n   const statement = statements[index];\n   this.preWalkStatement(statement);\n  }\n}\n\npreWalkStatement(statement) {\n this.statementPath.push(statement);\n  // 触发 ParserHook.preStatement => call\n if (this.hooks.preStatement.call(statement)) {\n  this.prevStatement = this.statementPath.pop();\n  return;\n }\n switch (statement.type) {\n  case "BlockStatement":\n   this.preWalkBlockStatement(statement);\n   break;\n  case "DoWhileStatement":\n   this.preWalkDoWhileStatement(statement);\n   break;\n  case "ForInStatement":\n   this.preWalkForInStatement(statement);\n   break;\n  case "ForOfStatement":\n   this.preWalkForOfStatement(statement);\n   break;\n  case "ForStatement":\n   this.preWalkForStatement(statement);\n   break;\n  case "FunctionDeclaration":\n   this.preWalkFunctionDeclaration(statement);\n   break;\n  case "IfStatement":\n   this.preWalkIfStatement(statement);\n   break;\n  case "LabeledStatement":\n   this.preWalkLabeledStatement(statement);\n   break;\n  case "SwitchStatement":\n   this.preWalkSwitchStatement(statement);\n   break;\n  case "TryStatement":\n   this.preWalkTryStatement(statement);\n   break;\n  case "VariableDeclaration":\n   this.preWalkVariableDeclaration(statement);\n   break;\n  case "WhileStatement":\n   this.preWalkWhileStatement(statement);\n   break;\n  case "WithStatement":\n   this.preWalkWithStatement(statement);\n   break;\n }\n this.prevStatement = this.statementPath.pop();\n}\n// ......\n\n_preWalkVariableDeclaration(statement, hookMap) {\n for (const declarator of statement.declarations) {\n  switch (declarator.type) {\n   case "VariableDeclarator": {\n    //  触发 ParserHook.preDeclarator => call\n    if (!this.hooks.preDeclarator.call(declarator, statement)) {\n     this.enterPattern(declarator.id, (name, decl) => {\n      let hook = hookMap.get(name);\n      if (hook === undefined || !hook.call(decl)) {\n       hook = this.hooks.varDeclaration.get(name);\n       if (hook === undefined || !hook.call(decl)) {\n        this.defineVariable(name);\n       }\n      }\n     });\n    }\n    break;\n   }\n  }\n }\n}\n\ndefineVariable(name) {\n const oldInfo = this.scope.definitions.get(name);\n // ......\n // 收集变量和 scope 到 this.scope.definitions\n this.scope.definitions.set(name, this.scope);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# defineVariable\n\n\n# blockPreWalkStatements\n\n遍历 AST，触发 ParserHook.blockPreStatement，查找 block 变量声明（import/export），以执行不同的操作。\n\n// Block pre walking iterates the scope for block variable declarations\nblockPreWalkStatements(statements) {\n for (let index = 0, len = statements.length; index < len; index++) {\n  const statement = statements[index];\n  this.blockPreWalkStatement(statement);\n }\n}\n\nblockPreWalkStatement(statement) {\n this.statementPath.push(statement);\n // 触发 ParserHook.blockPreStatement => call\n if (this.hooks.blockPreStatement.call(statement)) {\n  this.prevStatement = this.statementPath.pop();\n  return;\n }\n switch (statement.type) {\n  case "ImportDeclaration":\n   // 触发 ParserHook.import\n   // 触发 ParserHook.importSpecifier\n   this.blockPreWalkImportDeclaration(statement);\n   break;\n  case "ExportAllDeclaration":\n   // 触发 ParserHook.exportImport\n   // 触发 ParserHook.exportImportSpecifier\n   this.blockPreWalkExportAllDeclaration(statement);\n   break;\n  case "ExportDefaultDeclaration":\n   // 触发 ParserHook.exportSpecifier\n   this.blockPreWalkExportDefaultDeclaration(statement);\n   break;\n  case "ExportNamedDeclaration":\n   //  触发 ParserHook.exportImport 或者 ParserHook.export\n   //  触发 ParserHook.exportDeclaration\n   //  触发 ParserHook.exportImportSpecifier 或者 ParserHook.exportSpecifier\n   this.blockPreWalkExportNamedDeclaration(statement);\n   break;\n  case "VariableDeclaration":\n   this.blockPreWalkVariableDeclaration(statement);\n   break;\n  case "ClassDeclaration":\n   this.blockPreWalkClassDeclaration(statement);\n   break;\n }\n this.prevStatement = this.statementPath.pop();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# walkStatements\n\nwalk 阶段很重要的作用就是通过遍历 AST，触发 Parser 上的各种 Hook，因此在 ParserHook 上注册的各种插件就会被触发。在这些插件当中，很重要的就是收集依赖的插件。\n\n这个遍历的过程十分繁琐，下面我们从插件的角度反向探讨 Hook 的触发时机和产生的依赖。\n\n\n# HarmonyImportDependencyParserPlugin\n\n关注 hook 和 parser.state.module.addDependency 的关系。源码位置 lib/dependencies/HarmonyImportDependencyParserPlugin.js 。\n\nPARSERHOOK              ADDDEPENDENCY                               HOOK 触发时机\nimport                  HarmonyImportSideEffectDependency           blockPreWalkStatement => blockPreWalkImportDeclaration\nbinaryExpression        HarmonyEvaluatedImportSpecifierDependency   walkArrayExpression...... => walkExpressions =>\n                                                                    walkExpression => walkBinaryExpression\nexpression              HarmonyImportSpecifierDependency            walkExpressions => walkExpression => walkMetaProperty\nexpressionMemberChain   HarmonyImportSpecifierDependency            walkExpressions => walkExpression => walkMemberExpression\ncallMemberChain         HarmonyImportSpecifierDependency            walkExpressions => walkExpression => walkCallExpression\n\n\n# HarmonyExportDependencyParserPlugin\n\nPARSERHOOK              ADDDEPENDENCY                                HOOK 触发时机\nexportImport            HarmonyImportSideEffectDependency            blockPreWalkStatements => blockPreWalkStatement =>\n                                                                     blockPreWalkExportNamedDeclaration\nexportExpression        HarmonyExportExpressionDependency            walkStatements => walkStatement =>\n                                                                     walkExportDefaultDeclaration\nexportSpecifier         HarmonyExportImportedSpecifierDependency     blockPreWalkStatements => blockPreWalkStatement =>\n                                                                     blockPreWalkExportDefaultDeclaration\nexportImportSpecifier   HarmonyExportImportedSpecifierDependency 或   blockPreWalkStatements => blockPreWalkStatement =>\n                        HarmonyExportImportedSpecifierDependency     blockPreWalkExportAllDeclaration\n\n在代码中搜索 .addDependency(dep) ，如果代码是在 ParserHook 中执行的，就是在处理 Module 依赖的插件。\n\n// lib/DependenciesBlock.js\naddDependency(dependency) {\n this.dependencies.push(dependency);\n}\n\n\n1\n2\n3\n4\n\n\n注意 NormalModule 继承自 Module，Module 继承自 DependenciesBlock。因此 每个 Module 都有一个 dependencies 数组。\n\n\n# import/export\n\n\n# 总结',normalizedContent:'上一节中，我们探讨了单一 module 的 build 和 parse 过程。webpack 的 make 过程是从 entrymodule 开始的。我们知道，文件系统本身是文件树，moduledependence 本身也是 dependencetree，因此从 entrymodule 开始的 make 过程必然是一个递归的过程。这本节内容中，我们来探讨 moduletree 的 make 过程。\n\n\n# 目录\n\n\n\n * 目录\n * parserhook.program\n * usestrictplugin\n * harmonydetectionparserplugin\n * prewalkstatements\n * definevariable\n * blockprewalkstatements\n * walkstatements\n * harmonyimportdependencyparserplugin\n * harmonyexportdependencyparserplugin\n * import/export\n * 总结\n\n\n\n上一节在 javascriptparser parser.pase 函数的内容中，我们了解到对 module 的 ast，有如下的过程：\n\nif (this.hooks.program.call(ast, comments) === undefined) {\n  // prewalk ast\n  this.prewalkstatements(ast.body);\n  // blockprewalk\n  this.blockprewalkstatements(ast.body);\n  // walk ast\n  this.walkstatements(ast.body);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这里针对 ast.body 有 prewalk 和 walk 的过程。所谓 prewalk 就是在 walk 之前的处理工作。walk 的过程就是对 ast 进行遍历查找依赖的过程。\n\n\n# parserhook.program\n\n这个 hook 为什么叫 program，事情上 acorn 根据 estree 的规范 parse 出来的 ast 顶层对象就叫 program。如下：\n\n{\n  "type": "program",\n  "start": 0,\n  "end": 25,\n  "body": [\n    {\n      "type": "functiondeclaration",\n      "start": 0,\n      "end": 24,\n      "id": {\n        "type": "identifier",\n        "start": 9,\n        "end": 18,\n        "name": "printtips"\n      },\n      "expression": false,\n      "generator": false,\n      "async": false,\n      "params": [],\n      "body": {\n        "type": "blockstatement",\n        "start": 21,\n        "end": 24,\n        "body": []\n      }\n    }\n  ],\n  "sourcetype": "module"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n参考：\n\n * ast explorer\n\n既然 parserhook.program 在此时触发，那么我们就来看下有哪些插件在此注册了 callback。事实上，这样的插件有：\n\n * compatibilityplugin\n * defineplugin\n * usestrictplugin\n * harmonydetectionparserplugin\n * innergraphplugin\n * sideeffectsflagplugin\n\n现在我们只能深入这些插件来查看他们针对 ast 做了哪些事情。现在有一个疑点，在 lib/webpackoptionsapply.js 中注册这些插件时，只传入了 compiler，那么插件中 parser 是怎么获取的呢？我们能在这些插件中找到这样的代码：\n\nnormalmodulefactory.hooks.parser\n.for("javascript/auto")\n.tap("compatibilityplugin", handler);\nnormalmodulefactory.hooks.parser\n.for("javascript/dynamic")\n.tap("compatibilityplugin", handler);\nnormalmodulefactory.hooks.parser\n.for("javascript/esm")\n.tap("compatibilityplugin", handler);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n原来这些插件是在 normalmodulefactoryhook.parser 钩子中获得 parser 的，并在 handler 中在向 parserhook.program 注入处理逻辑。\n\n\n# usestrictplugin\n\nparser.hooks.program.tap("usestrictplugin", (ast) => {\n const firstnode = ast.body[0];\n // 如果是 use strict\n if (\n  firstnode &&\n  firstnode.type === "expressionstatement" &&\n  firstnode.expression.type === "literal" &&\n  firstnode.expression.value === "use strict"\n ) {\n  // remove "use strict" expression. it will be added later by the renderer again.\n  // this is necessary in order to not break the strict mode when webpack prepends code.\n  // @see https://github.com/webpack/webpack/issues/1970\n  // 删除 use strict 语句，添加 constdependency\n  const dep = new constdependency("", firstnode.range);\n  dep.loc = firstnode.loc;\n  parser.state.module.addpresentationaldependency(dep);\n  parser.state.module.buildinfo.strict = true;\n }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# harmonydetectionparserplugin\n\nparser.hooks.program.tap("harmonydetectionparserplugin", (ast) => {\n // 如果 module 是 javascript/esm，则严格使用 harmonycompatibilitydependency\n const isstrictharmony = parser.state.module.type === "javascript/esm";\n // 如果包含 import/export 语句，也需要使用 harmonycompatibilitydependency\n const isharmony =\n  isstrictharmony ||\n  ast.body.some(\n   (statement) =>\n    statement.type === "importdeclaration" ||\n    statement.type === "exportdefaultdeclaration" ||\n    statement.type === "exportnameddeclaration" ||\n    statement.type === "exportalldeclaration"\n  );\n // 添加 harmonycompatibilitydependency\n if (isharmony) {\n  const module = parser.state.module;\n  const compatdep = new harmonycompatibilitydependency();\n  compatdep.loc = {\n   start: {\n    line: -1,\n    column: 0,\n   },\n   end: {\n    line: -1,\n    column: 0,\n   },\n   index: -3,\n  };\n  module.addpresentationaldependency(compatdep);\n  // ......\n  parser.scope.isstrict = true;\n }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nparserhook.program 时主要针对 ast 中是否有 \'use strict\' 语句和 import/export 语句，分别向 module 添加 constdependency 和 harmonycompatibilitydependency。\n\n\n# prewalkstatements\n\n深度遍历（dfs）ast，触发 parserhook.prestatement，并修改变量声明语句的 scope。\n\n// pre walking iterates the scope for variable declarations\nprewalkstatements(statements) {\n  for (let index = 0, len = statements.length; index < len; index++) {\n   const statement = statements[index];\n   this.prewalkstatement(statement);\n  }\n}\n\nprewalkstatement(statement) {\n this.statementpath.push(statement);\n  // 触发 parserhook.prestatement => call\n if (this.hooks.prestatement.call(statement)) {\n  this.prevstatement = this.statementpath.pop();\n  return;\n }\n switch (statement.type) {\n  case "blockstatement":\n   this.prewalkblockstatement(statement);\n   break;\n  case "dowhilestatement":\n   this.prewalkdowhilestatement(statement);\n   break;\n  case "forinstatement":\n   this.prewalkforinstatement(statement);\n   break;\n  case "forofstatement":\n   this.prewalkforofstatement(statement);\n   break;\n  case "forstatement":\n   this.prewalkforstatement(statement);\n   break;\n  case "functiondeclaration":\n   this.prewalkfunctiondeclaration(statement);\n   break;\n  case "ifstatement":\n   this.prewalkifstatement(statement);\n   break;\n  case "labeledstatement":\n   this.prewalklabeledstatement(statement);\n   break;\n  case "switchstatement":\n   this.prewalkswitchstatement(statement);\n   break;\n  case "trystatement":\n   this.prewalktrystatement(statement);\n   break;\n  case "variabledeclaration":\n   this.prewalkvariabledeclaration(statement);\n   break;\n  case "whilestatement":\n   this.prewalkwhilestatement(statement);\n   break;\n  case "withstatement":\n   this.prewalkwithstatement(statement);\n   break;\n }\n this.prevstatement = this.statementpath.pop();\n}\n// ......\n\n_prewalkvariabledeclaration(statement, hookmap) {\n for (const declarator of statement.declarations) {\n  switch (declarator.type) {\n   case "variabledeclarator": {\n    //  触发 parserhook.predeclarator => call\n    if (!this.hooks.predeclarator.call(declarator, statement)) {\n     this.enterpattern(declarator.id, (name, decl) => {\n      let hook = hookmap.get(name);\n      if (hook === undefined || !hook.call(decl)) {\n       hook = this.hooks.vardeclaration.get(name);\n       if (hook === undefined || !hook.call(decl)) {\n        this.definevariable(name);\n       }\n      }\n     });\n    }\n    break;\n   }\n  }\n }\n}\n\ndefinevariable(name) {\n const oldinfo = this.scope.definitions.get(name);\n // ......\n // 收集变量和 scope 到 this.scope.definitions\n this.scope.definitions.set(name, this.scope);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# definevariable\n\n\n# blockprewalkstatements\n\n遍历 ast，触发 parserhook.blockprestatement，查找 block 变量声明（import/export），以执行不同的操作。\n\n// block pre walking iterates the scope for block variable declarations\nblockprewalkstatements(statements) {\n for (let index = 0, len = statements.length; index < len; index++) {\n  const statement = statements[index];\n  this.blockprewalkstatement(statement);\n }\n}\n\nblockprewalkstatement(statement) {\n this.statementpath.push(statement);\n // 触发 parserhook.blockprestatement => call\n if (this.hooks.blockprestatement.call(statement)) {\n  this.prevstatement = this.statementpath.pop();\n  return;\n }\n switch (statement.type) {\n  case "importdeclaration":\n   // 触发 parserhook.import\n   // 触发 parserhook.importspecifier\n   this.blockprewalkimportdeclaration(statement);\n   break;\n  case "exportalldeclaration":\n   // 触发 parserhook.exportimport\n   // 触发 parserhook.exportimportspecifier\n   this.blockprewalkexportalldeclaration(statement);\n   break;\n  case "exportdefaultdeclaration":\n   // 触发 parserhook.exportspecifier\n   this.blockprewalkexportdefaultdeclaration(statement);\n   break;\n  case "exportnameddeclaration":\n   //  触发 parserhook.exportimport 或者 parserhook.export\n   //  触发 parserhook.exportdeclaration\n   //  触发 parserhook.exportimportspecifier 或者 parserhook.exportspecifier\n   this.blockprewalkexportnameddeclaration(statement);\n   break;\n  case "variabledeclaration":\n   this.blockprewalkvariabledeclaration(statement);\n   break;\n  case "classdeclaration":\n   this.blockprewalkclassdeclaration(statement);\n   break;\n }\n this.prevstatement = this.statementpath.pop();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# walkstatements\n\nwalk 阶段很重要的作用就是通过遍历 ast，触发 parser 上的各种 hook，因此在 parserhook 上注册的各种插件就会被触发。在这些插件当中，很重要的就是收集依赖的插件。\n\n这个遍历的过程十分繁琐，下面我们从插件的角度反向探讨 hook 的触发时机和产生的依赖。\n\n\n# harmonyimportdependencyparserplugin\n\n关注 hook 和 parser.state.module.adddependency 的关系。源码位置 lib/dependencies/harmonyimportdependencyparserplugin.js 。\n\nparserhook              adddependency                               hook 触发时机\nimport                  harmonyimportsideeffectdependency           blockprewalkstatement => blockprewalkimportdeclaration\nbinaryexpression        harmonyevaluatedimportspecifierdependency   walkarrayexpression...... => walkexpressions =>\n                                                                    walkexpression => walkbinaryexpression\nexpression              harmonyimportspecifierdependency            walkexpressions => walkexpression => walkmetaproperty\nexpressionmemberchain   harmonyimportspecifierdependency            walkexpressions => walkexpression => walkmemberexpression\ncallmemberchain         harmonyimportspecifierdependency            walkexpressions => walkexpression => walkcallexpression\n\n\n# harmonyexportdependencyparserplugin\n\nparserhook              adddependency                                hook 触发时机\nexportimport            harmonyimportsideeffectdependency            blockprewalkstatements => blockprewalkstatement =>\n                                                                     blockprewalkexportnameddeclaration\nexportexpression        harmonyexportexpressiondependency            walkstatements => walkstatement =>\n                                                                     walkexportdefaultdeclaration\nexportspecifier         harmonyexportimportedspecifierdependency     blockprewalkstatements => blockprewalkstatement =>\n                                                                     blockprewalkexportdefaultdeclaration\nexportimportspecifier   harmonyexportimportedspecifierdependency 或   blockprewalkstatements => blockprewalkstatement =>\n                        harmonyexportimportedspecifierdependency     blockprewalkexportalldeclaration\n\n在代码中搜索 .adddependency(dep) ，如果代码是在 parserhook 中执行的，就是在处理 module 依赖的插件。\n\n// lib/dependenciesblock.js\nadddependency(dependency) {\n this.dependencies.push(dependency);\n}\n\n\n1\n2\n3\n4\n\n\n注意 normalmodule 继承自 module，module 继承自 dependenciesblock。因此 每个 module 都有一个 dependencies 数组。\n\n\n# import/export\n\n\n# 总结',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"开始阅读",frontmatter:{title:"开始阅读",date:"2022-04-14T22:02:20.000Z",permalink:"/pages/08c8a2/",categories:["am-editor"],tags:[null]},regularPath:"/30.web/70.am-editor/0.index.html",relativePath:"30.web/70.am-editor/0.index.md",key:"v-7b75117d",path:"/pages/08c8a2/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"index",frontmatter:{title:"index",date:"2022-04-14T22:02:20.000Z",permalink:"/pages/da29c0/",categories:["am-editor","engine"],tags:[null]},regularPath:"/30.web/70.am-editor/10.engine/0.index.html",relativePath:"30.web/70.am-editor/10.engine/0.index.md",key:"v-10d9c13d",path:"/pages/da29c0/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:16},{level:2,title:"EditorInterface",slug:"editorinterface",normalizedTitle:"editorinterface",charIndex:31}],readingTime:{text:"5 min read",minutes:4.64,time:278400,words:928},headersStr:"目录 EditorInterface",content:"# Engine 基础\n\n\n# 目录\n\n\n\n * 目录\n * EditorInterface\n\n\n\n\n# EditorInterface\n\nEditor 大概分为一下部分的内容：\n\n * locale: 语言本地化\n * kind: 类型、编辑模式和预览模式\n * container: 容器\n * command：命令管理\n * request: 网络请求\n * card: 卡片管理\n * plugin: 插件系统\n * node: 节点管理，包括 list、mark node、inline node、block node 等\n * event: 事件系统，包括 Event、event hooks 和 on/off/trigger\n * schema 和 conversion：标签过滤和标签转换\n * clipboard: 剪贴板管理\n * message: 消息管理：包括 messageSuccess、messageError 和 messageConfirm\n\nexport interface EditorInterface {\n /**\n  * 类型\n  */\n readonly kind: 'engine' | 'view';\n /**\n  * 语言\n  */\n language: LanguageInterface;\n /**\n  * 编辑器节点\n  */\n container: NodeInterface;\n /**\n  * 滚动条节点\n  */\n readonly scrollNode: NodeInterface | null;\n /**\n  * 编辑器根节点，默认为编辑器父节点\n  */\n root: NodeInterface;\n /**\n  * 编辑器命令\n  */\n command: CommandInterface;\n /**\n  * 请求\n  */\n request: RequestInterface;\n /**\n  * 卡片\n  */\n card: CardModelInterface;\n /**\n  * 插件\n  */\n plugin: PluginModelInterface;\n /**\n  * 节点管理\n  */\n node: NodeModelInterface;\n /**\n  * 节点id管理器\n  */\n nodeId: NodeIdInterface;\n /**\n  * List 列表标签管理\n  */\n list: ListModelInterface;\n /**\n  * Mark 标签管理\n  */\n mark: MarkModelInterface;\n /**\n  * inline 标签管理\n  */\n inline: InlineModelInterface;\n /**\n  * block 标签管理\n  */\n block: BlockModelInterface;\n /**\n  * 事件\n  */\n event: EventInterface;\n /**\n  * 标签过滤规则\n  */\n schema: SchemaInterface;\n /**\n  * 标签转换规则\n  */\n conversion: ConversionInterface;\n /**\n  * 剪切板\n  */\n clipboard: ClipboardInterface;\n /**\n  * 绑定事件\n  * @param eventType 事件类型\n  * @param listener 事件回调\n  * @param rewrite 是否重写\n  */\n on(eventType: string, listener: EventListener, rewrite?: boolean): void;\n /**\n  * 全选ctrl+a键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:all',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 卡片最小化时触发\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(\n  eventType: 'card:minimize',\n  listener: (card: CardInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 卡片最大化时触发\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(\n  eventType: 'card:maximize',\n  listener: (card: CardInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 解析DOM节点，生成符合标准的 XML 代码之前触发\n  * @param root DOM节点\n  */\n on(\n  eventType: 'parse:value-before',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 解析DOM节点，生成符合标准的 XML，遍历子节点时触发。返回false跳过当前节点\n  * @param node 当前遍历的节点\n  * @param attributes 当前节点已过滤后的属性\n  * @param styles 当前节点已过滤后的样式\n  * @param value 当前已经生成的xml代码\n  */\n on(\n  eventType: 'parse:value',\n  listener: (\n   node: NodeInterface,\n   attributes: { [key: string]: string },\n   styles: { [key: string]: string },\n   value: Array<string>,\n  ) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 解析DOM节点，生成符合标准的 XML。生成xml代码结束后触发\n  * @param value xml代码\n  */\n on(\n  eventType: 'parse:value-after',\n  listener: (value: Array<string>) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 转换为HTML代码之前触发\n  * @param root 需要转换的根节点\n  */\n on(\n  eventType: 'parse:html-before',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 转换为HTML代码\n  * @param root 需要转换的根节点\n  */\n on(\n  eventType: 'parse:html',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 转换为HTML代码之后触发\n  * @param root 需要转换的根节点\n  */\n on(\n  eventType: 'parse:html-after',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 复制DOM节点时触发\n  * @param node 当前遍历的子节点\n  */\n on(\n  eventType: 'copy',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 移除绑定事件\n  * @param eventType 事件类型\n  * @param listener 事件回调\n  */\n off(eventType: string, listener: EventListener): void;\n /**\n  * 全选ctrl+a键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:all',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * 卡片最小化时触发\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n off(\n  eventType: 'card:minimize',\n  listener: (card: CardInterface) => void,\n ): void;\n /**\n  * 卡片最大化时触发\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n off(\n  eventType: 'card:maximize',\n  listener: (card: CardInterface) => void,\n ): void;\n /**\n  * 解析DOM节点，生成符合标准的 XML 代码之前触发\n  * @param root DOM节点\n  */\n off(\n  eventType: 'parse:value-before',\n  listener: (root: NodeInterface) => void,\n ): void;\n /**\n  * 解析DOM节点，生成符合标准的 XML，遍历子节点时触发。返回false跳过当前节点\n  * @param node 当前遍历的节点\n  * @param attributes 当前节点已过滤后的属性\n  * @param styles 当前节点已过滤后的样式\n  * @param value 当前已经生成的xml代码\n  */\n off(\n  eventType: 'parse:value',\n  listener: (\n   node: NodeInterface,\n   attributes: { [key: string]: string },\n   styles: { [key: string]: string },\n   value: Array<string>,\n  ) => boolean | void,\n ): void;\n /**\n  * 解析DOM节点，生成符合标准的 XML。生成xml代码结束后触发\n  * @param value xml代码\n  */\n off(\n  eventType: 'parse:value-after',\n  listener: (value: Array<string>) => void,\n ): void;\n /**\n  * 转换为HTML代码之前触发\n  * @param root 需要转换的根节点\n  */\n off(\n  eventType: 'parse:html-before',\n  listener: (root: NodeInterface) => void,\n ): void;\n /**\n  * 转换为HTML代码\n  * @param root 需要转换的根节点\n  */\n off(eventType: 'parse:html', listener: (root: NodeInterface) => void): void;\n /**\n  * 转换为HTML代码之后触发\n  * @param root 需要转换的根节点\n  */\n off(\n  eventType: 'parse:html-after',\n  listener: (root: NodeInterface) => void,\n ): void;\n /**\n  * 复制DOM节点时触发\n  * @param node 当前遍历的子节点\n  */\n off(eventType: 'copy', listener: (root: NodeInterface) => void): void;\n /**\n  * 触发事件\n  * @param eventType 事件名称\n  * @param args 触发参数\n  */\n trigger(eventType: string, ...args: any): any;\n /**\n  * 全选ctrl+a键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:all', event: KeyboardEvent): boolean | void;\n /**\n  * 卡片最小化时触发\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n trigger(eventType: 'card:minimize', card: CardInterface): void;\n /**\n  * 卡片最大化时触发\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n trigger(eventType: 'card:maximize', card: CardInterface): void;\n /**\n  * 解析DOM节点，生成符合标准的 XML 代码之前触发\n  * @param root DOM节点\n  */\n trigger(eventType: 'parse:value-before', root: NodeInterface): void;\n /**\n  * 解析DOM节点，生成符合标准的 XML，遍历子节点时触发。返回false跳过当前节点\n  * @param node 当前遍历的节点\n  * @param attributes 当前节点已过滤后的属性\n  * @param styles 当前节点已过滤后的样式\n  * @param value 当前已经生成的xml代码\n  */\n trigger(\n  eventType: 'parse:value',\n  node: NodeInterface,\n  attributes: { [key: string]: string },\n  styles: { [key: string]: string },\n  value: Array<string>,\n ): boolean | void;\n /**\n  * 解析DOM节点，生成符合标准的 XML。生成xml代码结束后触发\n  * @param value xml代码\n  */\n trigger(eventType: 'parse:value-after', value: Array<string>): void;\n /**\n  * 转换为HTML代码之前触发\n  * @param root 需要转换的根节点\n  */\n trigger(eventType: 'parse:html-before', root: NodeInterface): void;\n /**\n  * 转换为HTML代码\n  * @param root 需要转换的根节点\n  */\n trigger(eventType: 'parse:html', root: NodeInterface): void;\n /**\n  * 转换为HTML代码之后触发\n  * @param root 需要转换的根节点\n  */\n trigger(eventType: 'parse:html-after', root: NodeInterface): void;\n /**\n  * 复制DOM节点时触发\n  * @param node 当前遍历的子节点\n  */\n trigger(eventType: 'copy', root: NodeInterface): void;\n /**\n  * 显示成功的信息\n  * @param message 信息\n  */\n messageSuccess(message: string): void;\n /**\n  * 显示错误信息\n  * @param error 错误信息\n  */\n messageError(error: string): void;\n /**\n  * 消息确认\n  * @param message 消息\n  */\n messageConfirm(message: string): Promise<boolean>;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n",normalizedContent:"# engine 基础\n\n\n# 目录\n\n\n\n * 目录\n * editorinterface\n\n\n\n\n# editorinterface\n\neditor 大概分为一下部分的内容：\n\n * locale: 语言本地化\n * kind: 类型、编辑模式和预览模式\n * container: 容器\n * command：命令管理\n * request: 网络请求\n * card: 卡片管理\n * plugin: 插件系统\n * node: 节点管理，包括 list、mark node、inline node、block node 等\n * event: 事件系统，包括 event、event hooks 和 on/off/trigger\n * schema 和 conversion：标签过滤和标签转换\n * clipboard: 剪贴板管理\n * message: 消息管理：包括 messagesuccess、messageerror 和 messageconfirm\n\nexport interface editorinterface {\n /**\n  * 类型\n  */\n readonly kind: 'engine' | 'view';\n /**\n  * 语言\n  */\n language: languageinterface;\n /**\n  * 编辑器节点\n  */\n container: nodeinterface;\n /**\n  * 滚动条节点\n  */\n readonly scrollnode: nodeinterface | null;\n /**\n  * 编辑器根节点，默认为编辑器父节点\n  */\n root: nodeinterface;\n /**\n  * 编辑器命令\n  */\n command: commandinterface;\n /**\n  * 请求\n  */\n request: requestinterface;\n /**\n  * 卡片\n  */\n card: cardmodelinterface;\n /**\n  * 插件\n  */\n plugin: pluginmodelinterface;\n /**\n  * 节点管理\n  */\n node: nodemodelinterface;\n /**\n  * 节点id管理器\n  */\n nodeid: nodeidinterface;\n /**\n  * list 列表标签管理\n  */\n list: listmodelinterface;\n /**\n  * mark 标签管理\n  */\n mark: markmodelinterface;\n /**\n  * inline 标签管理\n  */\n inline: inlinemodelinterface;\n /**\n  * block 标签管理\n  */\n block: blockmodelinterface;\n /**\n  * 事件\n  */\n event: eventinterface;\n /**\n  * 标签过滤规则\n  */\n schema: schemainterface;\n /**\n  * 标签转换规则\n  */\n conversion: conversioninterface;\n /**\n  * 剪切板\n  */\n clipboard: clipboardinterface;\n /**\n  * 绑定事件\n  * @param eventtype 事件类型\n  * @param listener 事件回调\n  * @param rewrite 是否重写\n  */\n on(eventtype: string, listener: eventlistener, rewrite?: boolean): void;\n /**\n  * 全选ctrl+a键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:all',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 卡片最小化时触发\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(\n  eventtype: 'card:minimize',\n  listener: (card: cardinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 卡片最大化时触发\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(\n  eventtype: 'card:maximize',\n  listener: (card: cardinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 解析dom节点，生成符合标准的 xml 代码之前触发\n  * @param root dom节点\n  */\n on(\n  eventtype: 'parse:value-before',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 解析dom节点，生成符合标准的 xml，遍历子节点时触发。返回false跳过当前节点\n  * @param node 当前遍历的节点\n  * @param attributes 当前节点已过滤后的属性\n  * @param styles 当前节点已过滤后的样式\n  * @param value 当前已经生成的xml代码\n  */\n on(\n  eventtype: 'parse:value',\n  listener: (\n   node: nodeinterface,\n   attributes: { [key: string]: string },\n   styles: { [key: string]: string },\n   value: array<string>,\n  ) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 解析dom节点，生成符合标准的 xml。生成xml代码结束后触发\n  * @param value xml代码\n  */\n on(\n  eventtype: 'parse:value-after',\n  listener: (value: array<string>) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 转换为html代码之前触发\n  * @param root 需要转换的根节点\n  */\n on(\n  eventtype: 'parse:html-before',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 转换为html代码\n  * @param root 需要转换的根节点\n  */\n on(\n  eventtype: 'parse:html',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 转换为html代码之后触发\n  * @param root 需要转换的根节点\n  */\n on(\n  eventtype: 'parse:html-after',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 复制dom节点时触发\n  * @param node 当前遍历的子节点\n  */\n on(\n  eventtype: 'copy',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 移除绑定事件\n  * @param eventtype 事件类型\n  * @param listener 事件回调\n  */\n off(eventtype: string, listener: eventlistener): void;\n /**\n  * 全选ctrl+a键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:all',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * 卡片最小化时触发\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n off(\n  eventtype: 'card:minimize',\n  listener: (card: cardinterface) => void,\n ): void;\n /**\n  * 卡片最大化时触发\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n off(\n  eventtype: 'card:maximize',\n  listener: (card: cardinterface) => void,\n ): void;\n /**\n  * 解析dom节点，生成符合标准的 xml 代码之前触发\n  * @param root dom节点\n  */\n off(\n  eventtype: 'parse:value-before',\n  listener: (root: nodeinterface) => void,\n ): void;\n /**\n  * 解析dom节点，生成符合标准的 xml，遍历子节点时触发。返回false跳过当前节点\n  * @param node 当前遍历的节点\n  * @param attributes 当前节点已过滤后的属性\n  * @param styles 当前节点已过滤后的样式\n  * @param value 当前已经生成的xml代码\n  */\n off(\n  eventtype: 'parse:value',\n  listener: (\n   node: nodeinterface,\n   attributes: { [key: string]: string },\n   styles: { [key: string]: string },\n   value: array<string>,\n  ) => boolean | void,\n ): void;\n /**\n  * 解析dom节点，生成符合标准的 xml。生成xml代码结束后触发\n  * @param value xml代码\n  */\n off(\n  eventtype: 'parse:value-after',\n  listener: (value: array<string>) => void,\n ): void;\n /**\n  * 转换为html代码之前触发\n  * @param root 需要转换的根节点\n  */\n off(\n  eventtype: 'parse:html-before',\n  listener: (root: nodeinterface) => void,\n ): void;\n /**\n  * 转换为html代码\n  * @param root 需要转换的根节点\n  */\n off(eventtype: 'parse:html', listener: (root: nodeinterface) => void): void;\n /**\n  * 转换为html代码之后触发\n  * @param root 需要转换的根节点\n  */\n off(\n  eventtype: 'parse:html-after',\n  listener: (root: nodeinterface) => void,\n ): void;\n /**\n  * 复制dom节点时触发\n  * @param node 当前遍历的子节点\n  */\n off(eventtype: 'copy', listener: (root: nodeinterface) => void): void;\n /**\n  * 触发事件\n  * @param eventtype 事件名称\n  * @param args 触发参数\n  */\n trigger(eventtype: string, ...args: any): any;\n /**\n  * 全选ctrl+a键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:all', event: keyboardevent): boolean | void;\n /**\n  * 卡片最小化时触发\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n trigger(eventtype: 'card:minimize', card: cardinterface): void;\n /**\n  * 卡片最大化时触发\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n trigger(eventtype: 'card:maximize', card: cardinterface): void;\n /**\n  * 解析dom节点，生成符合标准的 xml 代码之前触发\n  * @param root dom节点\n  */\n trigger(eventtype: 'parse:value-before', root: nodeinterface): void;\n /**\n  * 解析dom节点，生成符合标准的 xml，遍历子节点时触发。返回false跳过当前节点\n  * @param node 当前遍历的节点\n  * @param attributes 当前节点已过滤后的属性\n  * @param styles 当前节点已过滤后的样式\n  * @param value 当前已经生成的xml代码\n  */\n trigger(\n  eventtype: 'parse:value',\n  node: nodeinterface,\n  attributes: { [key: string]: string },\n  styles: { [key: string]: string },\n  value: array<string>,\n ): boolean | void;\n /**\n  * 解析dom节点，生成符合标准的 xml。生成xml代码结束后触发\n  * @param value xml代码\n  */\n trigger(eventtype: 'parse:value-after', value: array<string>): void;\n /**\n  * 转换为html代码之前触发\n  * @param root 需要转换的根节点\n  */\n trigger(eventtype: 'parse:html-before', root: nodeinterface): void;\n /**\n  * 转换为html代码\n  * @param root 需要转换的根节点\n  */\n trigger(eventtype: 'parse:html', root: nodeinterface): void;\n /**\n  * 转换为html代码之后触发\n  * @param root 需要转换的根节点\n  */\n trigger(eventtype: 'parse:html-after', root: nodeinterface): void;\n /**\n  * 复制dom节点时触发\n  * @param node 当前遍历的子节点\n  */\n trigger(eventtype: 'copy', root: nodeinterface): void;\n /**\n  * 显示成功的信息\n  * @param message 信息\n  */\n messagesuccess(message: string): void;\n /**\n  * 显示错误信息\n  * @param error 错误信息\n  */\n messageerror(error: string): void;\n /**\n  * 消息确认\n  * @param message 消息\n  */\n messageconfirm(message: string): promise<boolean>;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"engine-basic",frontmatter:{title:"engine-basic",date:"2022-04-14T22:02:20.000Z",permalink:"/pages/33f539/",categories:["am-editor","engine"],tags:[null]},regularPath:"/30.web/70.am-editor/10.engine/10.engine-basic.html",relativePath:"30.web/70.am-editor/10.engine/10.engine-basic.md",key:"v-778f237d",path:"/pages/33f539/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:19},{level:2,title:"Engine 概览",slug:"engine-概览",normalizedTitle:"engine 概览",charIndex:34},{level:3,title:"EngineOptions",slug:"engineoptions",normalizedTitle:"engineoptions",charIndex:49},{level:3,title:"Engine",slug:"engine",normalizedTitle:"engine",charIndex:2}],readingTime:{text:"17 min read",minutes:17.005,time:1020300,words:3401},headersStr:"目录 Engine 概览 EngineOptions Engine",content:"# Engine Basic\n\n\n# 目录\n\n\n\n * 目录\n * Engine 概览\n   * EngineOptions\n   * Engine\n\n\n\n\n# Engine 概览\n\n\n# EngineOptions\n\n\nexport type EngineOptions = {\n /**\n  * 本地化语言，默认 zh-CN\n  */\n lang?: string;\n /**\n  * 本地化语言\n  */\n locale?: { [key: string]: {} };\n /**\n  * 样式名称\n  */\n className?: string;\n /**\n  * tab 键的索引\n  */\n tabIndex?: number;\n /**\n  * 根节点\n  */\n root?: Node;\n /**\n  * 滚动条节点，查找父级样式 overflow 或者 overflow-y 为 auto 或者 scroll 的节点\n  */\n scrollNode?: Node | (() => Node | null);\n /**\n  * 插件配置\n  */\n plugins?: Array<PluginEntry>;\n /**\n  * 卡片配置\n  */\n cards?: Array<CardEntry>;\n /**\n  * 插件的可选项\n  */\n config?: { [k: string]: PluginOptions };\n /**\n  * 占位内容\n  */\n placeholder?: string;\n /**\n  * 是否只读\n  */\n readonly?: boolean;\n /**\n  * 懒惰渲染卡片（仅限已启用 lazyRender 的卡片），默认为 true\n  */\n lazyRender?: boolean;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# Engine\n\nexport interface Engine {\n /**\n  * 构造函数\n  */\n new (selector: Selector, options?: EngineOptions): EngineInterface;\n}\n\nexport interface EngineInterface extends EditorInterface {\n /**\n  * 选项\n  */\n options: EngineOptions;\n /**\n  * 是否只读\n  */\n readonly: boolean;\n /**\n  * 编辑器更改\n  */\n change: ChangeInterface;\n /**\n  * 按键处理\n  */\n typing: TypingInterface;\n /**\n  * 协同编辑\n  */\n ot: OTInterface;\n\n /**\n  * 历史记录\n  */\n history: HistoryInterface;\n /**\n  * 快捷键\n  */\n hotkey: HotkeyInterface;\n /**\n  * 聚焦到编辑器\n  */\n focus(toStart?: boolean): void;\n /**\n  * 让编辑器失去焦点\n  */\n blur(): void;\n /**\n  * 是否聚焦到编辑器\n  */\n isFocus(): boolean;\n /**\n  * 是否为空内容\n  */\n isEmpty(): boolean;\n /**\n  * 设置滚动节点\n  * @param node 节点\n  */\n setScrollNode(node: HTMLElement): void;\n /**\n  * 获取编辑器值\n  * @param ignoreCursor 是否包含光标位置信息\n  */\n getValue(ignoreCursor?: boolean): string;\n /**\n  * 异步获取编辑器值，将等候插件处理完成后再获取值\n  * 比如插件上传等待中，将等待上传完成后再获取值\n  * @param ignoreCursor 是否包含光标位置信息，默认不包含\n  * @param callback 有插件还有动作未执行完时回调，返回 false 终止获取值，返回 number 设置当前动作等待时间，毫秒\n  */\n getValueAsync(\n  ignoreCursor?: boolean,\n  callback?: (\n   name: string,\n   card?: CardInterface,\n   ...args: any\n  ) => boolean | number | void,\n ): Promise<string>;\n /**\n  * 获取编辑器的html\n  */\n getHtml(): string;\n /**\n  * 设置编辑器值\n  * @param value 值\n  * @param callback 异步渲染卡片后的回调\n  */\n setValue(\n  value: string,\n  callback?: (count: number) => void,\n ): EngineInterface;\n /**\n  * 设置html，会格式化为合法的编辑器值\n  * @param html html\n  * @param callback 异步渲染卡片后的回调\n  */\n setHtml(html: string, callback?: (count: number) => void): EngineInterface;\n /**\n  * 设置json格式值，主要用于协同\n  * @param callback 异步渲染卡片后的回调\n  */\n setJsonValue(\n  value: Array<any>,\n  callback?: (count: number) => void,\n ): EngineInterface;\n /**\n  * 获取JSON格式的值\n  */\n getJsonValue(): string | undefined | (string | {})[];\n /**\n  * 展示 placeholder\n  */\n showPlaceholder(): void;\n /**\n  * 隐藏 placeholder\n  */\n hidePlaceholder(): void;\n /**\n  * 绑定事件\n  * @param eventType 事件类型\n  * @param listener 事件回调\n  * @param rewrite 是否重写\n  */\n on(eventType: string, listener: EventListener, rewrite?: boolean): void;\n /**\n  * 全选ctrl+a键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:all',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 卡片最小化时触发\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(\n  eventType: 'card:minimize',\n  listener: (card: CardInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 卡片最大化时触发\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(\n  eventType: 'card:maximize',\n  listener: (card: CardInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 解析DOM节点，生成符合标准的 XML 代码之前触发\n  * @param root DOM节点\n  */\n on(\n  eventType: 'parse:value-before',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 解析DOM节点，生成符合标准的 XML，遍历子节点时触发。返回false跳过当前节点\n  * @param node 当前遍历的节点\n  * @param attributes 当前节点已过滤后的属性\n  * @param styles 当前节点已过滤后的样式\n  * @param value 当前已经生成的xml代码\n  */\n on(\n  eventType: 'parse:value',\n  listener: (\n   node: NodeInterface,\n   attributes: { [key: string]: string },\n   styles: { [key: string]: string },\n   value: Array<string>,\n  ) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 解析DOM节点，生成符合标准的 XML。生成xml代码结束后触发\n  * @param value xml代码\n  */\n on(\n  eventType: 'parse:value-after',\n  listener: (value: Array<string>) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 转换为HTML代码之前触发\n  * @param root 需要转换的根节点\n  */\n on(\n  eventType: 'parse:html-before',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 转换为HTML代码\n  * @param root 需要转换的根节点\n  */\n on(\n  eventType: 'parse:html',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 转换为HTML代码之后触发\n  * @param root 需要转换的根节点\n  */\n on(\n  eventType: 'parse:html-after',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 当粘贴到编辑器事件发生时触发，返回false，将不在处理粘贴\n  * @param data 粘贴板相关数据\n  * @param source 粘贴的富文本\n  */\n on(\n  eventType: 'paste:event',\n  listener: (\n   data: ClipboardData & { isPasteText: boolean },\n   source: string,\n  ) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 设置本次粘贴所需保留标签的白名单，以及属性\n  * @param schema 标签白名单管理实例\n  */\n on(\n  eventType: 'paste:schema',\n  listener: (schema: SchemaInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 解析粘贴数据，还未生成符合编辑器数据的片段之前触发\n  * @param root 粘贴的DOM节点\n  */\n on(\n  eventType: 'paste:origin',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 解析粘贴数据，生成符合编辑器数据的片段之后扁平化阶段触发\n  * @param node 粘贴片段遍历的子节点\n  */\n on(\n  eventType: 'paste:each',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 解析粘贴数据，生成符合编辑器数据的片段之后扁平化阶段触发\n  * @param node 所有粘贴片段遍历后的根节点\n  */\n on(\n  eventType: 'paste:each-after',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 生成粘贴数据DOM片段后，还未写入到编辑器之前触发\n  * @param fragment 粘贴的片段\n  */\n on(\n  eventType: 'paste:before',\n  listener: (fragment: DocumentFragment) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 插入当前粘贴的片段后触发，此时还未渲染卡片\n  * @param range 当前插入后的光标实例\n  */\n on(\n  eventType: 'paste:insert',\n  listener: (range: RangeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 粘贴完成后触发\n  */\n on(eventType: 'paste:after', listener: () => void, rewrite?: boolean): void;\n /**\n  * 复制DOM节点时触发\n  * @param node 当前遍历的子节点\n  */\n on(\n  eventType: 'copy',\n  listener: (root: NodeInterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * DOM改变触发\n  * @param eventType\n  * @param ops\n  */\n on(\n  eventType: 'ops',\n  listener: (ops: Op[]) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 移除绑定事件\n  * @param eventType 事件类型\n  * @param listener 事件回调\n  */\n off(eventType: string, listener: EventListener): void;\n /**\n  * 全选ctrl+a键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:all',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * 卡片最小化时触发\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n off(\n  eventType: 'card:minimize',\n  listener: (card: CardInterface) => void,\n ): void;\n /**\n  * 卡片最大化时触发\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n off(\n  eventType: 'card:maximize',\n  listener: (card: CardInterface) => void,\n ): void;\n /**\n  * 解析DOM节点，生成符合标准的 XML 代码之前触发\n  * @param root DOM节点\n  */\n off(\n  eventType: 'parse:value-before',\n  listener: (root: NodeInterface) => void,\n ): void;\n /**\n  * 解析DOM节点，生成符合标准的 XML，遍历子节点时触发。返回false跳过当前节点\n  * @param node 当前遍历的节点\n  * @param attributes 当前节点已过滤后的属性\n  * @param styles 当前节点已过滤后的样式\n  * @param value 当前已经生成的xml代码\n  */\n off(\n  eventType: 'parse:value',\n  listener: (\n   node: NodeInterface,\n   attributes: { [key: string]: string },\n   styles: { [key: string]: string },\n   value: Array<string>,\n  ) => boolean | void,\n ): void;\n /**\n  * 解析DOM节点，生成符合标准的 XML。生成xml代码结束后触发\n  * @param value xml代码\n  */\n off(\n  eventType: 'parse:value-after',\n  listener: (value: Array<string>) => void,\n ): void;\n /**\n  * 转换为HTML代码之前触发\n  * @param root 需要转换的根节点\n  */\n off(\n  eventType: 'parse:html-before',\n  listener: (root: NodeInterface) => void,\n ): void;\n /**\n  * 转换为HTML代码\n  * @param root 需要转换的根节点\n  */\n off(eventType: 'parse:html', listener: (root: NodeInterface) => void): void;\n /**\n  * 转换为HTML代码之后触发\n  * @param root 需要转换的根节点\n  */\n off(\n  eventType: 'parse:html-after',\n  listener: (root: NodeInterface) => void,\n ): void;\n /**\n  * 当粘贴到编辑器事件发生时触发，返回false，将不在处理粘贴\n  * @param data 粘贴板相关数据\n  * @param source 粘贴的富文本\n  */\n off(\n  eventType: 'paste:event',\n  listener: (\n   data: ClipboardData & { isPasteText: boolean },\n   source: string,\n  ) => boolean | void,\n ): void;\n /**\n  * 设置本次粘贴所需保留标签的白名单，以及属性\n  * @param schema 标签白名单管理实例\n  */\n off(\n  eventType: 'paste:schema',\n  listener: (schema: SchemaInterface) => void,\n ): void;\n /**\n  * 解析粘贴数据，还未生成符合编辑器数据的片段之前触发\n  * @param root 粘贴的DOM节点\n  */\n off(\n  eventType: 'paste:origin',\n  listener: (root: NodeInterface) => void,\n ): void;\n /**\n  * 解析粘贴数据，生成符合编辑器数据的片段之后扁平化阶段触发\n  * @param node 粘贴片段遍历的子节点\n  */\n off(eventType: 'paste:each', listener: (root: NodeInterface) => void): void;\n /**\n  * 解析粘贴数据，生成符合编辑器数据的片段之后扁平化阶段触发\n  * @param node 所有粘贴片段遍历后的根节点\n  */\n off(\n  eventType: 'paste:each-after',\n  listener: (root: NodeInterface) => void,\n ): void;\n /**\n  * 生成粘贴数据DOM片段后，还未写入到编辑器之前触发\n  * @param fragment 粘贴的片段\n  */\n off(\n  eventType: 'paste:before',\n  listener: (fragment: DocumentFragment) => void,\n ): void;\n /**\n  * 插入当前粘贴的片段后触发，此时还未渲染卡片\n  * @param range 当前插入后的光标实例\n  */\n off(\n  eventType: 'paste:insert',\n  listener: (range: RangeInterface) => void,\n ): void;\n /**\n  * 粘贴完成后触发\n  */\n off(eventType: 'paste:after', listener: () => void): void;\n /**\n  * 复制DOM节点时触发\n  * @param node 当前遍历的子节点\n  */\n off(eventType: 'copy', listener: (root: NodeInterface) => void): void;\n /**\n  * DOM改变触发\n  * @param eventType\n  * @param ops\n  */\n off(eventType: 'ops', listener: (ops: Op[]) => void): void;\n /**\n  * 触发事件\n  * @param eventType 事件名称\n  * @param args 触发参数\n  */\n trigger(eventType: string, ...args: any): any;\n /**\n  * 全选ctrl+a键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:all', event: KeyboardEvent): boolean | void;\n /**\n  * 卡片最小化时触发\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n trigger(eventType: 'card:minimize', card: CardInterface): void;\n /**\n  * 卡片最大化时触发\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n trigger(eventType: 'card:maximize', card: CardInterface): void;\n /**\n  * 解析DOM节点，生成符合标准的 XML 代码之前触发\n  * @param root DOM节点\n  */\n trigger(eventType: 'parse:value-before', root: NodeInterface): void;\n /**\n  * 解析DOM节点，生成符合标准的 XML，遍历子节点时触发。返回false跳过当前节点\n  * @param node 当前遍历的节点\n  * @param attributes 当前节点已过滤后的属性\n  * @param styles 当前节点已过滤后的样式\n  * @param value 当前已经生成的xml代码\n  */\n trigger(\n  eventType: 'parse:value',\n  node: NodeInterface,\n  attributes: { [key: string]: string },\n  styles: { [key: string]: string },\n  value: Array<string>,\n ): boolean | void;\n /**\n  * 解析DOM节点，生成符合标准的 XML。生成xml代码结束后触发\n  * @param value xml代码\n  */\n trigger(eventType: 'parse:value-after', value: Array<string>): void;\n /**\n  * 转换为HTML代码之前触发\n  * @param root 需要转换的根节点\n  */\n trigger(eventType: 'parse:html-before', root: NodeInterface): void;\n /**\n  * 转换为HTML代码\n  * @param root 需要转换的根节点\n  */\n trigger(eventType: 'parse:html', root: NodeInterface): void;\n /**\n  * 转换为HTML代码之后触发\n  * @param root 需要转换的根节点\n  */\n trigger(eventType: 'parse:html-after', root: NodeInterface): void;\n /**\n  * 当粘贴到编辑器事件发生时触发，返回false，将不在处理粘贴\n  * @param data 粘贴板相关数据\n  * @param source 粘贴的富文本\n  */\n trigger(\n  eventType: 'paste:event',\n  data: ClipboardData & { isPasteText: boolean },\n  source: string,\n ): boolean | void;\n /**\n  * 设置本次粘贴所需保留标签的白名单，以及属性\n  * @param schema 标签白名单管理实例\n  */\n trigger(eventType: 'paste:schema', schema: SchemaInterface): void;\n /**\n  * 解析粘贴数据，还未生成符合编辑器数据的片段之前触发\n  * @param root 粘贴的DOM节点\n  */\n trigger(eventType: 'paste:origin', root: NodeInterface): void;\n /**\n  * 解析粘贴数据，生成符合编辑器数据的片段之后扁平化阶段触发\n  * @param node 粘贴片段遍历的子节点\n  */\n trigger(eventType: 'paste:each', root: NodeInterface): void;\n /**\n  * 解析粘贴数据，生成符合编辑器数据的片段之后扁平化阶段触发\n  * @param node 所有粘贴片段遍历后的根节点\n  */\n trigger(eventType: 'paste:each-after', root: NodeInterface): void;\n /**\n  * 生成粘贴数据DOM片段后，还未写入到编辑器之前触发\n  * @param fragment 粘贴的片段\n  */\n trigger(eventType: 'paste:before', fragment: DocumentFragment): void;\n /**\n  * 插入当前粘贴的片段后触发，此时还未渲染卡片\n  * @param range 当前插入后的光标实例\n  */\n trigger(eventType: 'paste:insert', range: RangeInterface): void;\n /**\n  * 粘贴完成后触发\n  */\n trigger(eventType: 'paste:after'): void;\n /**\n  * 复制DOM节点时触发\n  * @param node 当前遍历的子节点\n  */\n trigger(eventType: 'copy', root: NodeInterface): void;\n /**\n  * DOM改变触发\n  * @param eventType\n  * @param ops\n  */\n trigger(eventType: 'ops', ops: Op[]): void;\n /**\n  * 回车键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:enter',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 删除键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:backspace',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * Tab键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:tab',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * Shift-Tab键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:shift-tab',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * @ 符合键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:at',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 空格键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:space',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 反斜杠键按下，唤出Toolbar，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:slash',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 左方向键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:left',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 右方向键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:right',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 上方向键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:up',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 下方向键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keydown:down',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 回车键按下弹起，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keyup:enter',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 删除键按下弹起，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keyup:backspace',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * Tab键按下弹起，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keyup:tab',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 空格键按下弹起，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'keyup:space',\n  listener: (event: KeyboardEvent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 编辑器光标选择变化时触发\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(eventType: 'select', listener: () => void, rewrite?: boolean): void;\n /**\n  * 编辑器值变化时触发\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'change',\n  listener: (value: string, trigger: 'remote' | 'local' | 'both') => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 编辑器值有变化时就触发，与 change 相比，change 需要在组合输入法完成输入后才会触发，在一定时间内如果内容没有改版也不会触发 change\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'realtimeChange',\n  listener: (trigger: 'remote' | 'local') => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 设置编辑器值之前\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(\n  eventType: 'beforeSetValue',\n  listener: (value: string) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 设置编辑器值之后\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'afterSetValue',\n  listener: () => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 编辑器聚焦\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(eventType: 'focus', listener: () => void, rewrite?: boolean): void;\n /**\n  * 编辑器失去焦点\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(eventType: 'blur', listener: () => void, rewrite?: boolean): void;\n /**\n  * 编辑器只读切换时\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(\n  eventType: 'readonly',\n  listener: (readonly: boolean) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 执行命令之前\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(\n  eventType: 'beforeCommandExecute',\n  listener: (name: string, ...args: any) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 执行命令之后\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(\n  eventType: 'afterCommandExecute',\n  listener: (name: string, ...args: any) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 拖动文件到编辑器时触发\n  * @param files 文件集合\n  */\n on(\n  eventType: 'drop:files',\n  listener: (files: Array<File>) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 历史撤销\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'undo',\n  listener: () => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 历史重做\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventType: 'redo',\n  listener: () => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 回车键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:enter',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * 删除键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:backspace',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * Tab键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:tab',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * Shift-Tab键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:shift-tab',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * @ 符合键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:at',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * 空格键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:space',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * 反斜杠键按下，唤出Toolbar，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:slash',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n\n /**\n  * 左方向键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:left',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * 右方向键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:right',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * 上方向键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:up',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * 下方向键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keydown:down',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * 回车键按下弹起，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keyup:enter',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * 删除键按下弹起，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keyup:backspace',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * Tab键按下弹起，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keyup:tab',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * 空格键按下弹起，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'keyup:space',\n  listener: (event: KeyboardEvent) => boolean | void,\n ): void;\n /**\n  * 编辑器光标选择变化时触发\n  * @param eventType\n  * @param listener\n  */\n off(eventType: 'select', listener: () => void): void;\n /**\n  * 编辑器值变化时触发\n  * @param eventType\n  * @param listener\n  */\n off(\n  eventType: 'change',\n  listener: (value: string, trigger: 'remote' | 'local' | 'both') => void,\n ): void;\n /**\n  * 编辑器值有变化时就触发，与 change 相比，change 需要在组合输入法完成输入后才会触发，在一定时间内如果内容没有改版也不会触发 change\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n off(\n  eventType: 'realtimeChange',\n  listener: (trigger: 'remote' | 'local') => void,\n ): void;\n /**\n  * 设置编辑器值之前\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n off(eventType: 'beforeSetValue', listener: (value: string) => void): void;\n /**\n  * 设置编辑器值之后\n  * @param eventType\n  * @param listener\n  */\n off(eventType: 'afterSetValue', listener: () => void): void;\n /**\n  * 编辑器聚焦\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n off(eventType: 'focus', listener: () => void): void;\n /**\n  * 编辑器失去焦点\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n off(eventType: 'blur', listener: () => void): void;\n /**\n  * 编辑器只读切换时\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n off(eventType: 'readonly', listener: (readonly: boolean) => void): void;\n /**\n  * 执行命令之前\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n off(\n  eventType: 'beforeCommandExecute',\n  listener: (name: string, ...args: any) => void,\n ): void;\n /**\n  * 执行命令之后\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n off(\n  eventType: 'afterCommandExecute',\n  listener: (name: string, ...args: any) => void,\n ): void;\n /**\n  * 拖动文件到编辑器时触发\n  * @param files 文件集合\n  */\n off(eventType: 'drop:files', listener: (files: Array<File>) => void): void;\n /**\n  * 历史撤销\n  * @param eventType\n  * @param listener\n  */\n off(eventType: 'undo', listener: () => boolean | void): void;\n /**\n  * 历史重做\n  * @param eventType\n  * @param listener\n  */\n off(eventType: 'redo', listener: () => boolean | void): void;\n /**\n  * 回车键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:enter', event: KeyboardEvent): boolean | void;\n /**\n  * 删除键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n trigger(\n  eventType: 'keydown:backspace',\n  event: KeyboardEvent,\n ): boolean | void;\n /**\n  * Tab键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:tab', event: KeyboardEvent): boolean | void;\n /**\n  * Shift-Tab键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n trigger(\n  eventType: 'keydown:shift-tab',\n  event: KeyboardEvent,\n ): boolean | void;\n /**\n  * @ 符合键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:at', event: KeyboardEvent): boolean | void;\n /**\n  * 空格键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:space', event: KeyboardEvent): boolean | void;\n /**\n  * 反斜杠键按下，唤出Toolbar，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:slash', event: KeyboardEvent): boolean | void;\n /**\n  * 左方向键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:left', event: KeyboardEvent): boolean | void;\n /**\n  * 右方向键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:right', event: KeyboardEvent): boolean | void;\n /**\n  * 上方向键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:up', event: KeyboardEvent): boolean | void;\n /**\n  * 下方向键按下，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keydown:down', event: KeyboardEvent): boolean | void;\n /**\n  * 回车键按下弹起，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keyup:enter', event: KeyboardEvent): boolean | void;\n /**\n  * 删除键按下弹起，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keyup:backspace', event: KeyboardEvent): boolean | void;\n /**\n  * Tab键按下弹起，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keyup:tab', event: KeyboardEvent): boolean | void;\n /**\n  * 空格键按下弹起，返回false，终止处理其它监听\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'keyup:space', event: KeyboardEvent): boolean | void;\n /**\n  * 编辑器光标选择变化时触发\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'select'): void;\n /**\n  * 编辑器值变化时触发\n  * @param eventType\n  * @param listener\n  */\n trigger(\n  eventType: 'change',\n  value: string,\n  trigger: 'remote' | 'local' | 'both',\n ): void;\n /**\n  * 编辑器值有变化时就触发，与 change 相比，change 需要在组合输入法完成输入后才会触发，在一定时间内如果内容没有改版也不会触发 change\n  * @param eventType\n  * @param listener\n  * @param rewrite\n  */\n trigger(\n  eventType: 'realtimeChange',\n  trigger: 'remote' | 'local' | 'both',\n ): void;\n /**\n  * 设置编辑器值之前\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n trigger(eventType: 'beforeSetValue', value: string): void;\n /**\n  * 设置编辑器值之后\n  * @param eventType\n  * @param listener\n  */\n trigger(eventType: 'afterSetValue'): void;\n /**\n  * 编辑器聚焦\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n trigger(eventType: 'focus'): void;\n /**\n  * 编辑器失去焦点\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n trigger(eventType: 'blur'): void;\n /**\n  * 编辑器只读切换时\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n trigger(eventType: 'readonly', readonly: boolean): void;\n /**\n  * 执行命令之前\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n trigger(\n  eventType: 'beforeCommandExecute',\n  name: string,\n  ...args: any\n ): void;\n /**\n  * 执行命令之后\n  * @param eventType\n  * @param listener name:插件名称、args:参数\n  */\n trigger(eventType: 'afterCommandExecute', name: string, ...args: any): void;\n /**\n  * 拖动文件到编辑器时触发\n  * @param files 文件集合\n  */\n trigger(eventType: 'drop:files', files: Array<File>): void;\n /**\n  * 历史撤销\n  * @param eventType\n  */\n trigger(eventType: 'undo'): void;\n /**\n  * 历史重做\n  * @param eventType\n  */\n trigger(eventType: 'redo'): void;\n /**\n  * 销毁\n  */\n destroy(): void;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n726\n727\n728\n729\n730\n731\n732\n733\n734\n735\n736\n737\n738\n739\n740\n741\n742\n743\n744\n745\n746\n747\n748\n749\n750\n751\n752\n753\n754\n755\n756\n757\n758\n759\n760\n761\n762\n763\n764\n765\n766\n767\n768\n769\n770\n771\n772\n773\n774\n775\n776\n777\n778\n779\n780\n781\n782\n783\n784\n785\n786\n787\n788\n789\n790\n791\n792\n793\n794\n795\n796\n797\n798\n799\n800\n801\n802\n803\n804\n805\n806\n807\n808\n809\n810\n811\n812\n813\n814\n815\n816\n817\n818\n819\n820\n821\n822\n823\n824\n825\n826\n827\n828\n829\n830\n831\n832\n833\n834\n835\n836\n837\n838\n839\n840\n841\n842\n843\n844\n845\n846\n847\n848\n849\n850\n851\n852\n853\n854\n855\n856\n857\n858\n859\n860\n861\n862\n863\n864\n865\n866\n867\n868\n869\n870\n871\n872\n873\n874\n875\n876\n877\n878\n879\n880\n881\n882\n883\n884\n885\n886\n887\n888\n889\n890\n891\n892\n893\n894\n895\n896\n897\n898\n899\n900\n901\n902\n903\n904\n905\n906\n907\n908\n909\n910\n911\n912\n913\n914\n915\n916\n917\n918\n919\n920\n921\n922\n923\n924\n925\n926\n927\n928\n929\n930\n931\n932\n933\n934\n935\n936\n937\n938\n939\n940\n941\n942\n943\n944\n945\n946\n947\n948\n949\n950\n951\n952\n953\n954\n955\n956\n957\n958\n959\n960\n961\n962\n963\n964\n965\n966\n967\n968\n969\n970\n971\n972\n973\n974\n975\n976\n977\n978\n979\n980\n981\n982\n983\n984\n985\n986\n987\n988\n989\n990\n991\n992\n993\n994\n995\n996\n997\n998\n999\n1000\n1001\n1002\n1003\n1004\n1005\n1006\n1007\n1008\n1009\n1010\n1011\n1012\n1013\n1014\n1015\n1016\n1017\n1018\n1019\n1020\n1021\n1022\n1023\n1024\n1025\n1026\n1027\n1028\n1029\n1030\n1031\n1032\n1033\n1034\n1035\n1036\n1037\n1038\n1039\n1040\n1041\n1042\n1043\n1044\n1045\n1046\n1047\n1048\n1049\n1050\n1051\n1052\n1053\n1054\n1055\n1056\n1057\n1058\n1059\n1060\n1061\n1062\n1063\n1064\n1065\n1066\n1067\n1068\n1069\n1070\n1071\n1072\n1073\n1074\n1075\n1076\n1077\n1078\n1079\n1080\n1081\n1082\n1083\n1084\n1085\n1086\n1087\n1088\n1089\n1090\n1091\n1092\n1093\n1094\n1095\n1096\n1097\n1098\n1099\n1100\n1101\n1102\n1103\n1104\n1105\n1106\n1107\n1108\n1109\n1110\n1111\n1112\n1113\n1114\n1115\n1116\n1117\n1118\n1119\n1120\n1121\n1122\n1123\n1124\n1125\n1126\n1127\n1128\n1129\n1130\n1131\n1132\n1133\n1134\n1135\n1136\n1137\n1138\n1139\n1140\n1141\n1142\n1143\n1144\n1145\n1146\n1147\n1148\n1149\n1150\n1151\n1152\n1153\n1154\n1155\n1156\n1157\n1158\n1159\n1160\n1161\n1162\n1163\n1164\n1165\n1166\n1167\n1168\n1169\n1170\n1171\n1172\n1173\n1174\n1175\n1176\n1177\n1178\n1179\n1180\n1181\n1182\n1183\n1184\n1185\n1186\n1187\n1188\n1189\n1190\n1191\n1192\n1193\n1194\n1195\n1196\n1197\n1198\n1199\n1200\n1201\n1202\n1203\n1204\n1205\n1206\n1207\n1208\n1209\n1210\n1211\n1212\n1213\n1214\n1215\n1216\n1217\n1218\n1219\n1220\n1221\n1222\n1223\n1224\n1225\n1226\n1227\n1228\n1229\n1230\n1231\n1232\n1233\n1234\n1235\n1236\n1237\n1238\n1239\n1240\n1241\n1242\n1243\n1244\n1245\n1246\n1247\n1248\n1249\n1250\n1251\n1252\n1253\n1254\n1255\n1256\n1257\n1258\n1259\n1260\n1261\n1262\n1263\n1264\n1265\n1266\n1267\n1268\n1269\n1270\n1271\n1272\n1273\n1274\n1275\n1276\n1277\n1278\n1279\n1280\n1281\n1282\n1283\n1284\n1285\n1286\n1287\n1288\n1289\n1290\n1291\n1292\n\n\n总结如下：\n\n 1. 定义 class 的方法\n\n通过定义构造函数的方法定义类。\n\ninterface {new(args: Args): Class}\n\n\n1\n\n 2. Engine Core 大致分为如下部分：\n\n * options: 配置管理\n * readonly：只读模式\n * change：管理编辑器的更改\n * typing：按键管理\n * ot：协同编辑\n * history：历史记录\n * hotkey：快捷键管理\n * event: 事件管理\n * destroy：销毁实例\n * value/html: 内容管理",normalizedContent:"# engine basic\n\n\n# 目录\n\n\n\n * 目录\n * engine 概览\n   * engineoptions\n   * engine\n\n\n\n\n# engine 概览\n\n\n# engineoptions\n\n\nexport type engineoptions = {\n /**\n  * 本地化语言，默认 zh-cn\n  */\n lang?: string;\n /**\n  * 本地化语言\n  */\n locale?: { [key: string]: {} };\n /**\n  * 样式名称\n  */\n classname?: string;\n /**\n  * tab 键的索引\n  */\n tabindex?: number;\n /**\n  * 根节点\n  */\n root?: node;\n /**\n  * 滚动条节点，查找父级样式 overflow 或者 overflow-y 为 auto 或者 scroll 的节点\n  */\n scrollnode?: node | (() => node | null);\n /**\n  * 插件配置\n  */\n plugins?: array<pluginentry>;\n /**\n  * 卡片配置\n  */\n cards?: array<cardentry>;\n /**\n  * 插件的可选项\n  */\n config?: { [k: string]: pluginoptions };\n /**\n  * 占位内容\n  */\n placeholder?: string;\n /**\n  * 是否只读\n  */\n readonly?: boolean;\n /**\n  * 懒惰渲染卡片（仅限已启用 lazyrender 的卡片），默认为 true\n  */\n lazyrender?: boolean;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# engine\n\nexport interface engine {\n /**\n  * 构造函数\n  */\n new (selector: selector, options?: engineoptions): engineinterface;\n}\n\nexport interface engineinterface extends editorinterface {\n /**\n  * 选项\n  */\n options: engineoptions;\n /**\n  * 是否只读\n  */\n readonly: boolean;\n /**\n  * 编辑器更改\n  */\n change: changeinterface;\n /**\n  * 按键处理\n  */\n typing: typinginterface;\n /**\n  * 协同编辑\n  */\n ot: otinterface;\n\n /**\n  * 历史记录\n  */\n history: historyinterface;\n /**\n  * 快捷键\n  */\n hotkey: hotkeyinterface;\n /**\n  * 聚焦到编辑器\n  */\n focus(tostart?: boolean): void;\n /**\n  * 让编辑器失去焦点\n  */\n blur(): void;\n /**\n  * 是否聚焦到编辑器\n  */\n isfocus(): boolean;\n /**\n  * 是否为空内容\n  */\n isempty(): boolean;\n /**\n  * 设置滚动节点\n  * @param node 节点\n  */\n setscrollnode(node: htmlelement): void;\n /**\n  * 获取编辑器值\n  * @param ignorecursor 是否包含光标位置信息\n  */\n getvalue(ignorecursor?: boolean): string;\n /**\n  * 异步获取编辑器值，将等候插件处理完成后再获取值\n  * 比如插件上传等待中，将等待上传完成后再获取值\n  * @param ignorecursor 是否包含光标位置信息，默认不包含\n  * @param callback 有插件还有动作未执行完时回调，返回 false 终止获取值，返回 number 设置当前动作等待时间，毫秒\n  */\n getvalueasync(\n  ignorecursor?: boolean,\n  callback?: (\n   name: string,\n   card?: cardinterface,\n   ...args: any\n  ) => boolean | number | void,\n ): promise<string>;\n /**\n  * 获取编辑器的html\n  */\n gethtml(): string;\n /**\n  * 设置编辑器值\n  * @param value 值\n  * @param callback 异步渲染卡片后的回调\n  */\n setvalue(\n  value: string,\n  callback?: (count: number) => void,\n ): engineinterface;\n /**\n  * 设置html，会格式化为合法的编辑器值\n  * @param html html\n  * @param callback 异步渲染卡片后的回调\n  */\n sethtml(html: string, callback?: (count: number) => void): engineinterface;\n /**\n  * 设置json格式值，主要用于协同\n  * @param callback 异步渲染卡片后的回调\n  */\n setjsonvalue(\n  value: array<any>,\n  callback?: (count: number) => void,\n ): engineinterface;\n /**\n  * 获取json格式的值\n  */\n getjsonvalue(): string | undefined | (string | {})[];\n /**\n  * 展示 placeholder\n  */\n showplaceholder(): void;\n /**\n  * 隐藏 placeholder\n  */\n hideplaceholder(): void;\n /**\n  * 绑定事件\n  * @param eventtype 事件类型\n  * @param listener 事件回调\n  * @param rewrite 是否重写\n  */\n on(eventtype: string, listener: eventlistener, rewrite?: boolean): void;\n /**\n  * 全选ctrl+a键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:all',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 卡片最小化时触发\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(\n  eventtype: 'card:minimize',\n  listener: (card: cardinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 卡片最大化时触发\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(\n  eventtype: 'card:maximize',\n  listener: (card: cardinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 解析dom节点，生成符合标准的 xml 代码之前触发\n  * @param root dom节点\n  */\n on(\n  eventtype: 'parse:value-before',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 解析dom节点，生成符合标准的 xml，遍历子节点时触发。返回false跳过当前节点\n  * @param node 当前遍历的节点\n  * @param attributes 当前节点已过滤后的属性\n  * @param styles 当前节点已过滤后的样式\n  * @param value 当前已经生成的xml代码\n  */\n on(\n  eventtype: 'parse:value',\n  listener: (\n   node: nodeinterface,\n   attributes: { [key: string]: string },\n   styles: { [key: string]: string },\n   value: array<string>,\n  ) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 解析dom节点，生成符合标准的 xml。生成xml代码结束后触发\n  * @param value xml代码\n  */\n on(\n  eventtype: 'parse:value-after',\n  listener: (value: array<string>) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 转换为html代码之前触发\n  * @param root 需要转换的根节点\n  */\n on(\n  eventtype: 'parse:html-before',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 转换为html代码\n  * @param root 需要转换的根节点\n  */\n on(\n  eventtype: 'parse:html',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 转换为html代码之后触发\n  * @param root 需要转换的根节点\n  */\n on(\n  eventtype: 'parse:html-after',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 当粘贴到编辑器事件发生时触发，返回false，将不在处理粘贴\n  * @param data 粘贴板相关数据\n  * @param source 粘贴的富文本\n  */\n on(\n  eventtype: 'paste:event',\n  listener: (\n   data: clipboarddata & { ispastetext: boolean },\n   source: string,\n  ) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 设置本次粘贴所需保留标签的白名单，以及属性\n  * @param schema 标签白名单管理实例\n  */\n on(\n  eventtype: 'paste:schema',\n  listener: (schema: schemainterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 解析粘贴数据，还未生成符合编辑器数据的片段之前触发\n  * @param root 粘贴的dom节点\n  */\n on(\n  eventtype: 'paste:origin',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 解析粘贴数据，生成符合编辑器数据的片段之后扁平化阶段触发\n  * @param node 粘贴片段遍历的子节点\n  */\n on(\n  eventtype: 'paste:each',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 解析粘贴数据，生成符合编辑器数据的片段之后扁平化阶段触发\n  * @param node 所有粘贴片段遍历后的根节点\n  */\n on(\n  eventtype: 'paste:each-after',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 生成粘贴数据dom片段后，还未写入到编辑器之前触发\n  * @param fragment 粘贴的片段\n  */\n on(\n  eventtype: 'paste:before',\n  listener: (fragment: documentfragment) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 插入当前粘贴的片段后触发，此时还未渲染卡片\n  * @param range 当前插入后的光标实例\n  */\n on(\n  eventtype: 'paste:insert',\n  listener: (range: rangeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 粘贴完成后触发\n  */\n on(eventtype: 'paste:after', listener: () => void, rewrite?: boolean): void;\n /**\n  * 复制dom节点时触发\n  * @param node 当前遍历的子节点\n  */\n on(\n  eventtype: 'copy',\n  listener: (root: nodeinterface) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * dom改变触发\n  * @param eventtype\n  * @param ops\n  */\n on(\n  eventtype: 'ops',\n  listener: (ops: op[]) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 移除绑定事件\n  * @param eventtype 事件类型\n  * @param listener 事件回调\n  */\n off(eventtype: string, listener: eventlistener): void;\n /**\n  * 全选ctrl+a键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:all',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * 卡片最小化时触发\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n off(\n  eventtype: 'card:minimize',\n  listener: (card: cardinterface) => void,\n ): void;\n /**\n  * 卡片最大化时触发\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n off(\n  eventtype: 'card:maximize',\n  listener: (card: cardinterface) => void,\n ): void;\n /**\n  * 解析dom节点，生成符合标准的 xml 代码之前触发\n  * @param root dom节点\n  */\n off(\n  eventtype: 'parse:value-before',\n  listener: (root: nodeinterface) => void,\n ): void;\n /**\n  * 解析dom节点，生成符合标准的 xml，遍历子节点时触发。返回false跳过当前节点\n  * @param node 当前遍历的节点\n  * @param attributes 当前节点已过滤后的属性\n  * @param styles 当前节点已过滤后的样式\n  * @param value 当前已经生成的xml代码\n  */\n off(\n  eventtype: 'parse:value',\n  listener: (\n   node: nodeinterface,\n   attributes: { [key: string]: string },\n   styles: { [key: string]: string },\n   value: array<string>,\n  ) => boolean | void,\n ): void;\n /**\n  * 解析dom节点，生成符合标准的 xml。生成xml代码结束后触发\n  * @param value xml代码\n  */\n off(\n  eventtype: 'parse:value-after',\n  listener: (value: array<string>) => void,\n ): void;\n /**\n  * 转换为html代码之前触发\n  * @param root 需要转换的根节点\n  */\n off(\n  eventtype: 'parse:html-before',\n  listener: (root: nodeinterface) => void,\n ): void;\n /**\n  * 转换为html代码\n  * @param root 需要转换的根节点\n  */\n off(eventtype: 'parse:html', listener: (root: nodeinterface) => void): void;\n /**\n  * 转换为html代码之后触发\n  * @param root 需要转换的根节点\n  */\n off(\n  eventtype: 'parse:html-after',\n  listener: (root: nodeinterface) => void,\n ): void;\n /**\n  * 当粘贴到编辑器事件发生时触发，返回false，将不在处理粘贴\n  * @param data 粘贴板相关数据\n  * @param source 粘贴的富文本\n  */\n off(\n  eventtype: 'paste:event',\n  listener: (\n   data: clipboarddata & { ispastetext: boolean },\n   source: string,\n  ) => boolean | void,\n ): void;\n /**\n  * 设置本次粘贴所需保留标签的白名单，以及属性\n  * @param schema 标签白名单管理实例\n  */\n off(\n  eventtype: 'paste:schema',\n  listener: (schema: schemainterface) => void,\n ): void;\n /**\n  * 解析粘贴数据，还未生成符合编辑器数据的片段之前触发\n  * @param root 粘贴的dom节点\n  */\n off(\n  eventtype: 'paste:origin',\n  listener: (root: nodeinterface) => void,\n ): void;\n /**\n  * 解析粘贴数据，生成符合编辑器数据的片段之后扁平化阶段触发\n  * @param node 粘贴片段遍历的子节点\n  */\n off(eventtype: 'paste:each', listener: (root: nodeinterface) => void): void;\n /**\n  * 解析粘贴数据，生成符合编辑器数据的片段之后扁平化阶段触发\n  * @param node 所有粘贴片段遍历后的根节点\n  */\n off(\n  eventtype: 'paste:each-after',\n  listener: (root: nodeinterface) => void,\n ): void;\n /**\n  * 生成粘贴数据dom片段后，还未写入到编辑器之前触发\n  * @param fragment 粘贴的片段\n  */\n off(\n  eventtype: 'paste:before',\n  listener: (fragment: documentfragment) => void,\n ): void;\n /**\n  * 插入当前粘贴的片段后触发，此时还未渲染卡片\n  * @param range 当前插入后的光标实例\n  */\n off(\n  eventtype: 'paste:insert',\n  listener: (range: rangeinterface) => void,\n ): void;\n /**\n  * 粘贴完成后触发\n  */\n off(eventtype: 'paste:after', listener: () => void): void;\n /**\n  * 复制dom节点时触发\n  * @param node 当前遍历的子节点\n  */\n off(eventtype: 'copy', listener: (root: nodeinterface) => void): void;\n /**\n  * dom改变触发\n  * @param eventtype\n  * @param ops\n  */\n off(eventtype: 'ops', listener: (ops: op[]) => void): void;\n /**\n  * 触发事件\n  * @param eventtype 事件名称\n  * @param args 触发参数\n  */\n trigger(eventtype: string, ...args: any): any;\n /**\n  * 全选ctrl+a键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:all', event: keyboardevent): boolean | void;\n /**\n  * 卡片最小化时触发\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n trigger(eventtype: 'card:minimize', card: cardinterface): void;\n /**\n  * 卡片最大化时触发\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n trigger(eventtype: 'card:maximize', card: cardinterface): void;\n /**\n  * 解析dom节点，生成符合标准的 xml 代码之前触发\n  * @param root dom节点\n  */\n trigger(eventtype: 'parse:value-before', root: nodeinterface): void;\n /**\n  * 解析dom节点，生成符合标准的 xml，遍历子节点时触发。返回false跳过当前节点\n  * @param node 当前遍历的节点\n  * @param attributes 当前节点已过滤后的属性\n  * @param styles 当前节点已过滤后的样式\n  * @param value 当前已经生成的xml代码\n  */\n trigger(\n  eventtype: 'parse:value',\n  node: nodeinterface,\n  attributes: { [key: string]: string },\n  styles: { [key: string]: string },\n  value: array<string>,\n ): boolean | void;\n /**\n  * 解析dom节点，生成符合标准的 xml。生成xml代码结束后触发\n  * @param value xml代码\n  */\n trigger(eventtype: 'parse:value-after', value: array<string>): void;\n /**\n  * 转换为html代码之前触发\n  * @param root 需要转换的根节点\n  */\n trigger(eventtype: 'parse:html-before', root: nodeinterface): void;\n /**\n  * 转换为html代码\n  * @param root 需要转换的根节点\n  */\n trigger(eventtype: 'parse:html', root: nodeinterface): void;\n /**\n  * 转换为html代码之后触发\n  * @param root 需要转换的根节点\n  */\n trigger(eventtype: 'parse:html-after', root: nodeinterface): void;\n /**\n  * 当粘贴到编辑器事件发生时触发，返回false，将不在处理粘贴\n  * @param data 粘贴板相关数据\n  * @param source 粘贴的富文本\n  */\n trigger(\n  eventtype: 'paste:event',\n  data: clipboarddata & { ispastetext: boolean },\n  source: string,\n ): boolean | void;\n /**\n  * 设置本次粘贴所需保留标签的白名单，以及属性\n  * @param schema 标签白名单管理实例\n  */\n trigger(eventtype: 'paste:schema', schema: schemainterface): void;\n /**\n  * 解析粘贴数据，还未生成符合编辑器数据的片段之前触发\n  * @param root 粘贴的dom节点\n  */\n trigger(eventtype: 'paste:origin', root: nodeinterface): void;\n /**\n  * 解析粘贴数据，生成符合编辑器数据的片段之后扁平化阶段触发\n  * @param node 粘贴片段遍历的子节点\n  */\n trigger(eventtype: 'paste:each', root: nodeinterface): void;\n /**\n  * 解析粘贴数据，生成符合编辑器数据的片段之后扁平化阶段触发\n  * @param node 所有粘贴片段遍历后的根节点\n  */\n trigger(eventtype: 'paste:each-after', root: nodeinterface): void;\n /**\n  * 生成粘贴数据dom片段后，还未写入到编辑器之前触发\n  * @param fragment 粘贴的片段\n  */\n trigger(eventtype: 'paste:before', fragment: documentfragment): void;\n /**\n  * 插入当前粘贴的片段后触发，此时还未渲染卡片\n  * @param range 当前插入后的光标实例\n  */\n trigger(eventtype: 'paste:insert', range: rangeinterface): void;\n /**\n  * 粘贴完成后触发\n  */\n trigger(eventtype: 'paste:after'): void;\n /**\n  * 复制dom节点时触发\n  * @param node 当前遍历的子节点\n  */\n trigger(eventtype: 'copy', root: nodeinterface): void;\n /**\n  * dom改变触发\n  * @param eventtype\n  * @param ops\n  */\n trigger(eventtype: 'ops', ops: op[]): void;\n /**\n  * 回车键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:enter',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 删除键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:backspace',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * tab键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:tab',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * shift-tab键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:shift-tab',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * @ 符合键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:at',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 空格键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:space',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 反斜杠键按下，唤出toolbar，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:slash',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 左方向键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:left',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 右方向键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:right',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 上方向键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:up',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 下方向键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keydown:down',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 回车键按下弹起，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keyup:enter',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 删除键按下弹起，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keyup:backspace',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * tab键按下弹起，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keyup:tab',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 空格键按下弹起，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'keyup:space',\n  listener: (event: keyboardevent) => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 编辑器光标选择变化时触发\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(eventtype: 'select', listener: () => void, rewrite?: boolean): void;\n /**\n  * 编辑器值变化时触发\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'change',\n  listener: (value: string, trigger: 'remote' | 'local' | 'both') => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 编辑器值有变化时就触发，与 change 相比，change 需要在组合输入法完成输入后才会触发，在一定时间内如果内容没有改版也不会触发 change\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'realtimechange',\n  listener: (trigger: 'remote' | 'local') => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 设置编辑器值之前\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(\n  eventtype: 'beforesetvalue',\n  listener: (value: string) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 设置编辑器值之后\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'aftersetvalue',\n  listener: () => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 编辑器聚焦\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(eventtype: 'focus', listener: () => void, rewrite?: boolean): void;\n /**\n  * 编辑器失去焦点\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(eventtype: 'blur', listener: () => void, rewrite?: boolean): void;\n /**\n  * 编辑器只读切换时\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(\n  eventtype: 'readonly',\n  listener: (readonly: boolean) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 执行命令之前\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(\n  eventtype: 'beforecommandexecute',\n  listener: (name: string, ...args: any) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 执行命令之后\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  * @param rewrite\n  */\n on(\n  eventtype: 'aftercommandexecute',\n  listener: (name: string, ...args: any) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 拖动文件到编辑器时触发\n  * @param files 文件集合\n  */\n on(\n  eventtype: 'drop:files',\n  listener: (files: array<file>) => void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 历史撤销\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'undo',\n  listener: () => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 历史重做\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n on(\n  eventtype: 'redo',\n  listener: () => boolean | void,\n  rewrite?: boolean,\n ): void;\n /**\n  * 回车键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:enter',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * 删除键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:backspace',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * tab键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:tab',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * shift-tab键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:shift-tab',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * @ 符合键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:at',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * 空格键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:space',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * 反斜杠键按下，唤出toolbar，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:slash',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n\n /**\n  * 左方向键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:left',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * 右方向键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:right',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * 上方向键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:up',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * 下方向键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keydown:down',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * 回车键按下弹起，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keyup:enter',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * 删除键按下弹起，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keyup:backspace',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * tab键按下弹起，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keyup:tab',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * 空格键按下弹起，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'keyup:space',\n  listener: (event: keyboardevent) => boolean | void,\n ): void;\n /**\n  * 编辑器光标选择变化时触发\n  * @param eventtype\n  * @param listener\n  */\n off(eventtype: 'select', listener: () => void): void;\n /**\n  * 编辑器值变化时触发\n  * @param eventtype\n  * @param listener\n  */\n off(\n  eventtype: 'change',\n  listener: (value: string, trigger: 'remote' | 'local' | 'both') => void,\n ): void;\n /**\n  * 编辑器值有变化时就触发，与 change 相比，change 需要在组合输入法完成输入后才会触发，在一定时间内如果内容没有改版也不会触发 change\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n off(\n  eventtype: 'realtimechange',\n  listener: (trigger: 'remote' | 'local') => void,\n ): void;\n /**\n  * 设置编辑器值之前\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n off(eventtype: 'beforesetvalue', listener: (value: string) => void): void;\n /**\n  * 设置编辑器值之后\n  * @param eventtype\n  * @param listener\n  */\n off(eventtype: 'aftersetvalue', listener: () => void): void;\n /**\n  * 编辑器聚焦\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n off(eventtype: 'focus', listener: () => void): void;\n /**\n  * 编辑器失去焦点\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n off(eventtype: 'blur', listener: () => void): void;\n /**\n  * 编辑器只读切换时\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n off(eventtype: 'readonly', listener: (readonly: boolean) => void): void;\n /**\n  * 执行命令之前\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n off(\n  eventtype: 'beforecommandexecute',\n  listener: (name: string, ...args: any) => void,\n ): void;\n /**\n  * 执行命令之后\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n off(\n  eventtype: 'aftercommandexecute',\n  listener: (name: string, ...args: any) => void,\n ): void;\n /**\n  * 拖动文件到编辑器时触发\n  * @param files 文件集合\n  */\n off(eventtype: 'drop:files', listener: (files: array<file>) => void): void;\n /**\n  * 历史撤销\n  * @param eventtype\n  * @param listener\n  */\n off(eventtype: 'undo', listener: () => boolean | void): void;\n /**\n  * 历史重做\n  * @param eventtype\n  * @param listener\n  */\n off(eventtype: 'redo', listener: () => boolean | void): void;\n /**\n  * 回车键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:enter', event: keyboardevent): boolean | void;\n /**\n  * 删除键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n trigger(\n  eventtype: 'keydown:backspace',\n  event: keyboardevent,\n ): boolean | void;\n /**\n  * tab键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:tab', event: keyboardevent): boolean | void;\n /**\n  * shift-tab键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n trigger(\n  eventtype: 'keydown:shift-tab',\n  event: keyboardevent,\n ): boolean | void;\n /**\n  * @ 符合键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:at', event: keyboardevent): boolean | void;\n /**\n  * 空格键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:space', event: keyboardevent): boolean | void;\n /**\n  * 反斜杠键按下，唤出toolbar，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:slash', event: keyboardevent): boolean | void;\n /**\n  * 左方向键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:left', event: keyboardevent): boolean | void;\n /**\n  * 右方向键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:right', event: keyboardevent): boolean | void;\n /**\n  * 上方向键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:up', event: keyboardevent): boolean | void;\n /**\n  * 下方向键按下，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keydown:down', event: keyboardevent): boolean | void;\n /**\n  * 回车键按下弹起，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keyup:enter', event: keyboardevent): boolean | void;\n /**\n  * 删除键按下弹起，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keyup:backspace', event: keyboardevent): boolean | void;\n /**\n  * tab键按下弹起，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keyup:tab', event: keyboardevent): boolean | void;\n /**\n  * 空格键按下弹起，返回false，终止处理其它监听\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'keyup:space', event: keyboardevent): boolean | void;\n /**\n  * 编辑器光标选择变化时触发\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'select'): void;\n /**\n  * 编辑器值变化时触发\n  * @param eventtype\n  * @param listener\n  */\n trigger(\n  eventtype: 'change',\n  value: string,\n  trigger: 'remote' | 'local' | 'both',\n ): void;\n /**\n  * 编辑器值有变化时就触发，与 change 相比，change 需要在组合输入法完成输入后才会触发，在一定时间内如果内容没有改版也不会触发 change\n  * @param eventtype\n  * @param listener\n  * @param rewrite\n  */\n trigger(\n  eventtype: 'realtimechange',\n  trigger: 'remote' | 'local' | 'both',\n ): void;\n /**\n  * 设置编辑器值之前\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n trigger(eventtype: 'beforesetvalue', value: string): void;\n /**\n  * 设置编辑器值之后\n  * @param eventtype\n  * @param listener\n  */\n trigger(eventtype: 'aftersetvalue'): void;\n /**\n  * 编辑器聚焦\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n trigger(eventtype: 'focus'): void;\n /**\n  * 编辑器失去焦点\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n trigger(eventtype: 'blur'): void;\n /**\n  * 编辑器只读切换时\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n trigger(eventtype: 'readonly', readonly: boolean): void;\n /**\n  * 执行命令之前\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n trigger(\n  eventtype: 'beforecommandexecute',\n  name: string,\n  ...args: any\n ): void;\n /**\n  * 执行命令之后\n  * @param eventtype\n  * @param listener name:插件名称、args:参数\n  */\n trigger(eventtype: 'aftercommandexecute', name: string, ...args: any): void;\n /**\n  * 拖动文件到编辑器时触发\n  * @param files 文件集合\n  */\n trigger(eventtype: 'drop:files', files: array<file>): void;\n /**\n  * 历史撤销\n  * @param eventtype\n  */\n trigger(eventtype: 'undo'): void;\n /**\n  * 历史重做\n  * @param eventtype\n  */\n trigger(eventtype: 'redo'): void;\n /**\n  * 销毁\n  */\n destroy(): void;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n726\n727\n728\n729\n730\n731\n732\n733\n734\n735\n736\n737\n738\n739\n740\n741\n742\n743\n744\n745\n746\n747\n748\n749\n750\n751\n752\n753\n754\n755\n756\n757\n758\n759\n760\n761\n762\n763\n764\n765\n766\n767\n768\n769\n770\n771\n772\n773\n774\n775\n776\n777\n778\n779\n780\n781\n782\n783\n784\n785\n786\n787\n788\n789\n790\n791\n792\n793\n794\n795\n796\n797\n798\n799\n800\n801\n802\n803\n804\n805\n806\n807\n808\n809\n810\n811\n812\n813\n814\n815\n816\n817\n818\n819\n820\n821\n822\n823\n824\n825\n826\n827\n828\n829\n830\n831\n832\n833\n834\n835\n836\n837\n838\n839\n840\n841\n842\n843\n844\n845\n846\n847\n848\n849\n850\n851\n852\n853\n854\n855\n856\n857\n858\n859\n860\n861\n862\n863\n864\n865\n866\n867\n868\n869\n870\n871\n872\n873\n874\n875\n876\n877\n878\n879\n880\n881\n882\n883\n884\n885\n886\n887\n888\n889\n890\n891\n892\n893\n894\n895\n896\n897\n898\n899\n900\n901\n902\n903\n904\n905\n906\n907\n908\n909\n910\n911\n912\n913\n914\n915\n916\n917\n918\n919\n920\n921\n922\n923\n924\n925\n926\n927\n928\n929\n930\n931\n932\n933\n934\n935\n936\n937\n938\n939\n940\n941\n942\n943\n944\n945\n946\n947\n948\n949\n950\n951\n952\n953\n954\n955\n956\n957\n958\n959\n960\n961\n962\n963\n964\n965\n966\n967\n968\n969\n970\n971\n972\n973\n974\n975\n976\n977\n978\n979\n980\n981\n982\n983\n984\n985\n986\n987\n988\n989\n990\n991\n992\n993\n994\n995\n996\n997\n998\n999\n1000\n1001\n1002\n1003\n1004\n1005\n1006\n1007\n1008\n1009\n1010\n1011\n1012\n1013\n1014\n1015\n1016\n1017\n1018\n1019\n1020\n1021\n1022\n1023\n1024\n1025\n1026\n1027\n1028\n1029\n1030\n1031\n1032\n1033\n1034\n1035\n1036\n1037\n1038\n1039\n1040\n1041\n1042\n1043\n1044\n1045\n1046\n1047\n1048\n1049\n1050\n1051\n1052\n1053\n1054\n1055\n1056\n1057\n1058\n1059\n1060\n1061\n1062\n1063\n1064\n1065\n1066\n1067\n1068\n1069\n1070\n1071\n1072\n1073\n1074\n1075\n1076\n1077\n1078\n1079\n1080\n1081\n1082\n1083\n1084\n1085\n1086\n1087\n1088\n1089\n1090\n1091\n1092\n1093\n1094\n1095\n1096\n1097\n1098\n1099\n1100\n1101\n1102\n1103\n1104\n1105\n1106\n1107\n1108\n1109\n1110\n1111\n1112\n1113\n1114\n1115\n1116\n1117\n1118\n1119\n1120\n1121\n1122\n1123\n1124\n1125\n1126\n1127\n1128\n1129\n1130\n1131\n1132\n1133\n1134\n1135\n1136\n1137\n1138\n1139\n1140\n1141\n1142\n1143\n1144\n1145\n1146\n1147\n1148\n1149\n1150\n1151\n1152\n1153\n1154\n1155\n1156\n1157\n1158\n1159\n1160\n1161\n1162\n1163\n1164\n1165\n1166\n1167\n1168\n1169\n1170\n1171\n1172\n1173\n1174\n1175\n1176\n1177\n1178\n1179\n1180\n1181\n1182\n1183\n1184\n1185\n1186\n1187\n1188\n1189\n1190\n1191\n1192\n1193\n1194\n1195\n1196\n1197\n1198\n1199\n1200\n1201\n1202\n1203\n1204\n1205\n1206\n1207\n1208\n1209\n1210\n1211\n1212\n1213\n1214\n1215\n1216\n1217\n1218\n1219\n1220\n1221\n1222\n1223\n1224\n1225\n1226\n1227\n1228\n1229\n1230\n1231\n1232\n1233\n1234\n1235\n1236\n1237\n1238\n1239\n1240\n1241\n1242\n1243\n1244\n1245\n1246\n1247\n1248\n1249\n1250\n1251\n1252\n1253\n1254\n1255\n1256\n1257\n1258\n1259\n1260\n1261\n1262\n1263\n1264\n1265\n1266\n1267\n1268\n1269\n1270\n1271\n1272\n1273\n1274\n1275\n1276\n1277\n1278\n1279\n1280\n1281\n1282\n1283\n1284\n1285\n1286\n1287\n1288\n1289\n1290\n1291\n1292\n\n\n总结如下：\n\n 1. 定义 class 的方法\n\n通过定义构造函数的方法定义类。\n\ninterface {new(args: args): class}\n\n\n1\n\n 2. engine core 大致分为如下部分：\n\n * options: 配置管理\n * readonly：只读模式\n * change：管理编辑器的更改\n * typing：按键管理\n * ot：协同编辑\n * history：历史记录\n * hotkey：快捷键管理\n * event: 事件管理\n * destroy：销毁实例\n * value/html: 内容管理",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"engine",frontmatter:{title:"engine",date:"2022-04-14T22:02:20.000Z",permalink:"/pages/518dfe/",categories:["am-editor","engine"],tags:[null]},regularPath:"/30.web/70.am-editor/10.engine/20.engine.html",relativePath:"30.web/70.am-editor/10.engine/20.engine.md",key:"v-5b6dcd7d",path:"/pages/518dfe/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:18},{level:2,title:"Engine",slug:"engine",normalizedTitle:"engine",charIndex:2}],readingTime:{text:"6 min read",minutes:5.045,time:302700,words:1009},headersStr:"目录 Engine",content:"# Engine Core\n\n\n# 目录\n\n\n\n * 目录\n * Engine\n\n\n\n\n# Engine\n\nclass Engine implements EngineInterface {\n private _readonly: boolean = false;\n private _container: ContainerInterface;\n readonly kind = 'engine';\n  // 默认配置\n options: EngineOptions = {\n  lang: 'zh-CN',\n  locale: {},\n  plugins: [],\n  cards: [],\n  config: {},\n };\n language: LanguageInterface;\n root: NodeInterface;\n change: ChangeInterface;\n card: CardModelInterface;\n plugin: PluginModelInterface;\n node: NodeModelInterface;\n nodeId: NodeIdInterface;\n list: ListModelInterface;\n mark: MarkModelInterface;\n inline: InlineModelInterface;\n block: BlockModelInterface;\n event: EventInterface;\n typing: TypingInterface;\n ot: OTInterface;\n schema: SchemaInterface;\n conversion: ConversionInterface;\n history: HistoryInterface;\n command: CommandInterface;\n hotkey: HotkeyInterface;\n clipboard: ClipboardInterface;\n request: RequestInterface;\n #_scrollNode: NodeInterface | null = null;\n\n get container(): NodeInterface {\n  return this._container.getNode();\n }\n\n get readonly(): boolean {\n  return this._readonly;\n }\n\n get scrollNode(): NodeInterface | null {\n  if (this.#_scrollNode) return this.#_scrollNode;\n    // 初始化 _scrollNode\n  const { scrollNode } = this.options;\n  let sn = scrollNode\n   ? typeof scrollNode === 'function'\n    ? scrollNode()\n    : scrollNode\n   : null;\n  // 查找父级样式 overflow 或者 overflow-y 为 auto 或者 scroll 的节点\n  const targetValues = ['auto', 'scroll'];\n  let parent = this.container.parent();\n    // 向父级查找 scrollNode\n  while (parent && parent.length > 0 && parent.name !== 'body') {\n   if (\n    targetValues.includes(parent.css('overflow')) ||\n    targetValues.includes(parent.css('overflow-y'))\n   ) {\n    sn = parent.get<HTMLElement>();\n    break;\n   } else {\n    parent = parent.parent();\n   }\n  }\n    // 找不到则为 documentElement\n  if (sn === null) sn = document.documentElement;\n  this.#_scrollNode = sn ? $(sn) : null;\n  return this.#_scrollNode;\n }\n\n set readonly(readonly: boolean) {\n  if (this.readonly === readonly) return;\n    // 设置 readonly：处理快捷键和_container的状态\n  if (readonly) {\n   this.hotkey.disable();\n   this._container.setReadonly(true);\n  } else {\n   this.hotkey.enable();\n   this._container.setReadonly(false);\n  }\n  this._readonly = readonly;\n    // 重新渲染 card\n  this.card.reRender();\n  // 广播readonly事件\n  this.trigger('readonly', readonly);\n }\n\n constructor(selector: Selector, options?: EngineOptions) {\n    // 合并配置\n  this.options = { ...this.options, ...options };\n  // 多语言\n  this.language = new Language(\n   this.options.lang || 'zh-CN',\n   merge(language, options?.locale),\n  );\n  // 事件管理\n  this.event = new Event();\n  // 命令\n  this.command = new Command(this);\n  // 节点规则\n  this.schema = new Schema();\n    // 设置默认的节点规则\n  this.schema.add(schemaDefaultData);\n  // 节点转换规则\n  this.conversion = new Conversion(this);\n    // 设置默认的节点转换规则\n  conversionDefault.forEach((rule) =>\n   this.conversion.add(rule.from, rule.to),\n  );\n  // 历史\n  this.history = new History(this);\n  // 卡片\n  this.card = new CardModel(this, this.options.lazyRender);\n  // 剪贴板\n  this.clipboard = new Clipboard(this);\n  // http请求\n  this.request = new Request();\n  // 插件\n  this.plugin = new Plugin(this);\n  // 节点管理\n  this.node = new NodeModel(this);\n  this.nodeId = new NodeId(this);\n  // 列表\n  this.list = new List(this);\n  // 样式标记\n  this.mark = new Mark(this);\n  // 行内样式\n  this.inline = new Inline(this);\n  // 块级节点\n  this.block = new Block(this);\n  // 编辑器容器\n  this._container = new Container(selector, {\n   engine: this,\n   lang: this.options.lang,\n   className: this.options.className,\n   tabIndex: this.options.tabIndex,\n   placeholder: this.options.placeholder,\n  });\n  // 编辑器父节点\n  this.root = $(\n   this.options.root || this.container.parent() || getDocument().body,\n  );\n    // 设置 root position:relative\n  const rootPosition = this.root.css('position');\n  if (!rootPosition || rootPosition === 'static')\n   this.root.css('position', 'relative');\n  // 实例化容器\n  this._container.init();\n  // 编辑器改变时\n  this.change = new Change(this, {\n   onChange: (value, trigger) =>\n    this.trigger('change', value, trigger),\n   onSelect: () => this.trigger('select'),\n   onRealtimeChange: (trigger) => {\n    if (this.isEmpty()) {\n     this._container.showPlaceholder();\n    } else {\n     this._container.hidePlaceholder();\n    }\n    this.trigger('realtimeChange', trigger);\n   },\n   onSetValue: () => this.trigger('afterSetValue'),\n  });\n  this.change.init();\n  // 事件处理\n  this.typing = new Typing(this);\n  // 只读\n  this._readonly =\n   this.options.readonly === undefined ? false : this.options.readonly;\n  this._container.setReadonly(this._readonly);\n  // 实例化插件\n  this.mark.init();\n  this.inline.init();\n  this.block.init();\n  this.list.init();\n  // 快捷键\n  this.hotkey = new Hotkey(this);\n  this.card.init(this.options.cards || []);\n  this.plugin.init(this.options.plugins || [], this.options.config || {});\n  this.nodeId.init();\n  // 协同\n  this.ot = new OT(this);\n\n  if (this.isEmpty()) {\n   this._container.showPlaceholder();\n  }\n  this.ot.initLocal();\n }\n\n setScrollNode(node?: HTMLElement) {\n  this.#_scrollNode = node ? $(node) : null;\n }\n\n isFocus() {\n  return this._container.isFocus();\n }\n\n isEmpty() {\n  return this.change.isEmpty();\n }\n\n focus(toStart?: boolean) {\n  this.change.range.focus(toStart);\n }\n\n blur() {\n  this.change.range.blur();\n }\n\n on(eventType: string, listener: EventListener, rewrite?: boolean) {\n  this.event.on(eventType, listener, rewrite);\n  return this;\n }\n\n off(eventType: string, listener: EventListener) {\n  this.event.off(eventType, listener);\n  return this;\n }\n\n trigger(eventType: string, ...args: any) {\n  return this.event.trigger(eventType, ...args);\n }\n\n getValue(ignoreCursor: boolean = false) {\n  const value = this.change.getValue({});\n  return ignoreCursor ? Selection.removeTags(value) : value;\n }\n\n async getValueAsync(\n  ignoreCursor: boolean = false,\n  callback?: (\n   name: string,\n   card?: CardInterface,\n   ...args: any\n  ) => boolean | number | void,\n ): Promise<string> {\n  return new Promise(async (resolve, reject) => {\n      // 编辑插件等待插件执行结果\n   const pluginNames = Object.keys(this.plugin.components);\n   for (let i = 0; i < pluginNames.length; i++) {\n    const plugin = this.plugin.components[pluginNames[i]];\n    const result = await new Promise((resolve) => {\n     if (plugin.waiting) {\n      plugin\n       .waiting(callback)\n       .then(() => resolve(true))\n       .catch(resolve);\n     } else resolve(true);\n    });\n    if (typeof result === 'object') {\n     reject(result);\n     return;\n    }\n   }\n   resolve(this.getValue(ignoreCursor));\n  });\n }\n\n getHtml(): string {\n    // 获取 container 节点\n  const node = $(this.container[0].cloneNode(true));\n    // 清除冗余属性\n  node.removeAttributes('contenteditable');\n  node.removeAttributes('tabindex');\n  node.removeAttributes('autocorrect');\n  node.removeAttributes('autocomplete');\n  node.removeAttributes('spellcheck');\n  node.removeAttributes('data-gramm');\n  node.removeAttributes('role');\n  return new Parser(node, this).toHTML();\n }\n\n setValue(value: string, callback?: (count: number) => void) {\n  value = this.trigger('beforeSetValue', value) || value;\n  this.change.setValue(value, undefined, callback);\n  this.normalize();\n    // 为顶级根节点创建 data-id\n  this.nodeId.generateAll(this.container);\n    // 返回 this 支持链式调用\n  return this;\n }\n\n setHtml(html: string, callback?: (count: number) => void) {\n  this.change.setHtml(html, (count) => {\n   this.container.allChildren(true).forEach((child) => {\n    if (this.node.isInline(child)) {\n     this.inline.repairCursor(child);\n    } else if (this.node.isMark(child)) {\n     this.mark.repairCursor(child);\n    }\n    if (callback) callback(count);\n   });\n  });\n  this.nodeId.generateAll(this.container);\n  return this;\n }\n\n setJsonValue(value: Array<any>, callback?: (count: number) => void) {\n  const dom = $(toDOM(value));\n    // 设置 container 的属性\n  const attributes = dom.get<Element>()?.attributes;\n  for (let i = 0; attributes && i < attributes.length; i++) {\n   const { nodeName, nodeValue } = attributes.item(i) || {};\n   if (\n    /^data-selection-/.test(nodeName || '') &&\n    nodeValue !== 'null'\n   ) {\n    this.container.attributes(nodeName, nodeValue!);\n   }\n  }\n    // 设置 container html\n  const html = this.node.html(dom);\n  this.change.setValue(html, undefined, callback);\n    // 节点规范化的处理\n  this.normalize();\n    // 为顶级根节点创建 data-id\n  this.nodeId.generateAll(this.container);\n  return this;\n }\n\n getJsonValue() {\n  return toJSON0(this.container);\n }\n\n private normalize() {\n  let block = $('<p />');\n  // 保证所有行内元素都在段落内\n  let childNodes = this.container.children();\n  childNodes.each((_, index) => {\n   const node = childNodes.eq(index);\n   if (!node) return;\n   if (this.node.isBlock(node)) {\n    if (block.get<HTMLElement>()!.childNodes.length > 0) {\n     node.before(block);\n    }\n    block = $('<p />');\n   } else if (!node.isCursor()) {\n    block.append(node);\n   }\n  });\n\n  if (block.get<HTMLElement>()!.childNodes.length > 0) {\n   this.container.append(block);\n  }\n  // 处理空段落\n  childNodes = this.container.children();\n  childNodes.each((_, index) => {\n   const node = childNodes.eq(index);\n   if (!node) return;\n   this.node.removeMinusStyle(node, 'text-indent');\n   if (this.node.isRootBlock(node)) {\n    const childrenLength =\n     node.get<HTMLElement>()!.childNodes.length;\n    if (childrenLength === 0) {\n     node.append($('<br />'));\n    } else {\n     const child = node.first();\n     if (\n      childrenLength === 1 &&\n      child?.name === 'span' &&\n      [CURSOR, ANCHOR, FOCUS].indexOf(\n       child.attributes(DATA_ELEMENT),\n      ) >= 0\n     ) {\n      node.prepend($('<br />'));\n     }\n    }\n   }\n  });\n }\n\n messageSuccess(message: string) {\n  console.log(`success:${message}`);\n }\n\n messageError(error: string) {\n  console.log(`error:${error}`);\n }\n\n messageConfirm(message: string): Promise<boolean> {\n  console.log(`confirm:${message}`);\n  return Promise.reject(false);\n }\n\n showPlaceholder() {\n  this._container.showPlaceholder();\n }\n\n hidePlaceholder() {\n  this._container.hidePlaceholder();\n }\n\n destroy() {\n  this._container.destroy();\n  this.change.destroy();\n  this.hotkey.destroy();\n  this.card.destroy();\n  if (this.ot) {\n   this.ot.destroy();\n  }\n }\n}\n\nexport default Engine;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n",normalizedContent:"# engine core\n\n\n# 目录\n\n\n\n * 目录\n * engine\n\n\n\n\n# engine\n\nclass engine implements engineinterface {\n private _readonly: boolean = false;\n private _container: containerinterface;\n readonly kind = 'engine';\n  // 默认配置\n options: engineoptions = {\n  lang: 'zh-cn',\n  locale: {},\n  plugins: [],\n  cards: [],\n  config: {},\n };\n language: languageinterface;\n root: nodeinterface;\n change: changeinterface;\n card: cardmodelinterface;\n plugin: pluginmodelinterface;\n node: nodemodelinterface;\n nodeid: nodeidinterface;\n list: listmodelinterface;\n mark: markmodelinterface;\n inline: inlinemodelinterface;\n block: blockmodelinterface;\n event: eventinterface;\n typing: typinginterface;\n ot: otinterface;\n schema: schemainterface;\n conversion: conversioninterface;\n history: historyinterface;\n command: commandinterface;\n hotkey: hotkeyinterface;\n clipboard: clipboardinterface;\n request: requestinterface;\n #_scrollnode: nodeinterface | null = null;\n\n get container(): nodeinterface {\n  return this._container.getnode();\n }\n\n get readonly(): boolean {\n  return this._readonly;\n }\n\n get scrollnode(): nodeinterface | null {\n  if (this.#_scrollnode) return this.#_scrollnode;\n    // 初始化 _scrollnode\n  const { scrollnode } = this.options;\n  let sn = scrollnode\n   ? typeof scrollnode === 'function'\n    ? scrollnode()\n    : scrollnode\n   : null;\n  // 查找父级样式 overflow 或者 overflow-y 为 auto 或者 scroll 的节点\n  const targetvalues = ['auto', 'scroll'];\n  let parent = this.container.parent();\n    // 向父级查找 scrollnode\n  while (parent && parent.length > 0 && parent.name !== 'body') {\n   if (\n    targetvalues.includes(parent.css('overflow')) ||\n    targetvalues.includes(parent.css('overflow-y'))\n   ) {\n    sn = parent.get<htmlelement>();\n    break;\n   } else {\n    parent = parent.parent();\n   }\n  }\n    // 找不到则为 documentelement\n  if (sn === null) sn = document.documentelement;\n  this.#_scrollnode = sn ? $(sn) : null;\n  return this.#_scrollnode;\n }\n\n set readonly(readonly: boolean) {\n  if (this.readonly === readonly) return;\n    // 设置 readonly：处理快捷键和_container的状态\n  if (readonly) {\n   this.hotkey.disable();\n   this._container.setreadonly(true);\n  } else {\n   this.hotkey.enable();\n   this._container.setreadonly(false);\n  }\n  this._readonly = readonly;\n    // 重新渲染 card\n  this.card.rerender();\n  // 广播readonly事件\n  this.trigger('readonly', readonly);\n }\n\n constructor(selector: selector, options?: engineoptions) {\n    // 合并配置\n  this.options = { ...this.options, ...options };\n  // 多语言\n  this.language = new language(\n   this.options.lang || 'zh-cn',\n   merge(language, options?.locale),\n  );\n  // 事件管理\n  this.event = new event();\n  // 命令\n  this.command = new command(this);\n  // 节点规则\n  this.schema = new schema();\n    // 设置默认的节点规则\n  this.schema.add(schemadefaultdata);\n  // 节点转换规则\n  this.conversion = new conversion(this);\n    // 设置默认的节点转换规则\n  conversiondefault.foreach((rule) =>\n   this.conversion.add(rule.from, rule.to),\n  );\n  // 历史\n  this.history = new history(this);\n  // 卡片\n  this.card = new cardmodel(this, this.options.lazyrender);\n  // 剪贴板\n  this.clipboard = new clipboard(this);\n  // http请求\n  this.request = new request();\n  // 插件\n  this.plugin = new plugin(this);\n  // 节点管理\n  this.node = new nodemodel(this);\n  this.nodeid = new nodeid(this);\n  // 列表\n  this.list = new list(this);\n  // 样式标记\n  this.mark = new mark(this);\n  // 行内样式\n  this.inline = new inline(this);\n  // 块级节点\n  this.block = new block(this);\n  // 编辑器容器\n  this._container = new container(selector, {\n   engine: this,\n   lang: this.options.lang,\n   classname: this.options.classname,\n   tabindex: this.options.tabindex,\n   placeholder: this.options.placeholder,\n  });\n  // 编辑器父节点\n  this.root = $(\n   this.options.root || this.container.parent() || getdocument().body,\n  );\n    // 设置 root position:relative\n  const rootposition = this.root.css('position');\n  if (!rootposition || rootposition === 'static')\n   this.root.css('position', 'relative');\n  // 实例化容器\n  this._container.init();\n  // 编辑器改变时\n  this.change = new change(this, {\n   onchange: (value, trigger) =>\n    this.trigger('change', value, trigger),\n   onselect: () => this.trigger('select'),\n   onrealtimechange: (trigger) => {\n    if (this.isempty()) {\n     this._container.showplaceholder();\n    } else {\n     this._container.hideplaceholder();\n    }\n    this.trigger('realtimechange', trigger);\n   },\n   onsetvalue: () => this.trigger('aftersetvalue'),\n  });\n  this.change.init();\n  // 事件处理\n  this.typing = new typing(this);\n  // 只读\n  this._readonly =\n   this.options.readonly === undefined ? false : this.options.readonly;\n  this._container.setreadonly(this._readonly);\n  // 实例化插件\n  this.mark.init();\n  this.inline.init();\n  this.block.init();\n  this.list.init();\n  // 快捷键\n  this.hotkey = new hotkey(this);\n  this.card.init(this.options.cards || []);\n  this.plugin.init(this.options.plugins || [], this.options.config || {});\n  this.nodeid.init();\n  // 协同\n  this.ot = new ot(this);\n\n  if (this.isempty()) {\n   this._container.showplaceholder();\n  }\n  this.ot.initlocal();\n }\n\n setscrollnode(node?: htmlelement) {\n  this.#_scrollnode = node ? $(node) : null;\n }\n\n isfocus() {\n  return this._container.isfocus();\n }\n\n isempty() {\n  return this.change.isempty();\n }\n\n focus(tostart?: boolean) {\n  this.change.range.focus(tostart);\n }\n\n blur() {\n  this.change.range.blur();\n }\n\n on(eventtype: string, listener: eventlistener, rewrite?: boolean) {\n  this.event.on(eventtype, listener, rewrite);\n  return this;\n }\n\n off(eventtype: string, listener: eventlistener) {\n  this.event.off(eventtype, listener);\n  return this;\n }\n\n trigger(eventtype: string, ...args: any) {\n  return this.event.trigger(eventtype, ...args);\n }\n\n getvalue(ignorecursor: boolean = false) {\n  const value = this.change.getvalue({});\n  return ignorecursor ? selection.removetags(value) : value;\n }\n\n async getvalueasync(\n  ignorecursor: boolean = false,\n  callback?: (\n   name: string,\n   card?: cardinterface,\n   ...args: any\n  ) => boolean | number | void,\n ): promise<string> {\n  return new promise(async (resolve, reject) => {\n      // 编辑插件等待插件执行结果\n   const pluginnames = object.keys(this.plugin.components);\n   for (let i = 0; i < pluginnames.length; i++) {\n    const plugin = this.plugin.components[pluginnames[i]];\n    const result = await new promise((resolve) => {\n     if (plugin.waiting) {\n      plugin\n       .waiting(callback)\n       .then(() => resolve(true))\n       .catch(resolve);\n     } else resolve(true);\n    });\n    if (typeof result === 'object') {\n     reject(result);\n     return;\n    }\n   }\n   resolve(this.getvalue(ignorecursor));\n  });\n }\n\n gethtml(): string {\n    // 获取 container 节点\n  const node = $(this.container[0].clonenode(true));\n    // 清除冗余属性\n  node.removeattributes('contenteditable');\n  node.removeattributes('tabindex');\n  node.removeattributes('autocorrect');\n  node.removeattributes('autocomplete');\n  node.removeattributes('spellcheck');\n  node.removeattributes('data-gramm');\n  node.removeattributes('role');\n  return new parser(node, this).tohtml();\n }\n\n setvalue(value: string, callback?: (count: number) => void) {\n  value = this.trigger('beforesetvalue', value) || value;\n  this.change.setvalue(value, undefined, callback);\n  this.normalize();\n    // 为顶级根节点创建 data-id\n  this.nodeid.generateall(this.container);\n    // 返回 this 支持链式调用\n  return this;\n }\n\n sethtml(html: string, callback?: (count: number) => void) {\n  this.change.sethtml(html, (count) => {\n   this.container.allchildren(true).foreach((child) => {\n    if (this.node.isinline(child)) {\n     this.inline.repaircursor(child);\n    } else if (this.node.ismark(child)) {\n     this.mark.repaircursor(child);\n    }\n    if (callback) callback(count);\n   });\n  });\n  this.nodeid.generateall(this.container);\n  return this;\n }\n\n setjsonvalue(value: array<any>, callback?: (count: number) => void) {\n  const dom = $(todom(value));\n    // 设置 container 的属性\n  const attributes = dom.get<element>()?.attributes;\n  for (let i = 0; attributes && i < attributes.length; i++) {\n   const { nodename, nodevalue } = attributes.item(i) || {};\n   if (\n    /^data-selection-/.test(nodename || '') &&\n    nodevalue !== 'null'\n   ) {\n    this.container.attributes(nodename, nodevalue!);\n   }\n  }\n    // 设置 container html\n  const html = this.node.html(dom);\n  this.change.setvalue(html, undefined, callback);\n    // 节点规范化的处理\n  this.normalize();\n    // 为顶级根节点创建 data-id\n  this.nodeid.generateall(this.container);\n  return this;\n }\n\n getjsonvalue() {\n  return tojson0(this.container);\n }\n\n private normalize() {\n  let block = $('<p />');\n  // 保证所有行内元素都在段落内\n  let childnodes = this.container.children();\n  childnodes.each((_, index) => {\n   const node = childnodes.eq(index);\n   if (!node) return;\n   if (this.node.isblock(node)) {\n    if (block.get<htmlelement>()!.childnodes.length > 0) {\n     node.before(block);\n    }\n    block = $('<p />');\n   } else if (!node.iscursor()) {\n    block.append(node);\n   }\n  });\n\n  if (block.get<htmlelement>()!.childnodes.length > 0) {\n   this.container.append(block);\n  }\n  // 处理空段落\n  childnodes = this.container.children();\n  childnodes.each((_, index) => {\n   const node = childnodes.eq(index);\n   if (!node) return;\n   this.node.removeminusstyle(node, 'text-indent');\n   if (this.node.isrootblock(node)) {\n    const childrenlength =\n     node.get<htmlelement>()!.childnodes.length;\n    if (childrenlength === 0) {\n     node.append($('<br />'));\n    } else {\n     const child = node.first();\n     if (\n      childrenlength === 1 &&\n      child?.name === 'span' &&\n      [cursor, anchor, focus].indexof(\n       child.attributes(data_element),\n      ) >= 0\n     ) {\n      node.prepend($('<br />'));\n     }\n    }\n   }\n  });\n }\n\n messagesuccess(message: string) {\n  console.log(`success:${message}`);\n }\n\n messageerror(error: string) {\n  console.log(`error:${error}`);\n }\n\n messageconfirm(message: string): promise<boolean> {\n  console.log(`confirm:${message}`);\n  return promise.reject(false);\n }\n\n showplaceholder() {\n  this._container.showplaceholder();\n }\n\n hideplaceholder() {\n  this._container.hideplaceholder();\n }\n\n destroy() {\n  this._container.destroy();\n  this.change.destroy();\n  this.hotkey.destroy();\n  this.card.destroy();\n  if (this.ot) {\n   this.ot.destroy();\n  }\n }\n}\n\nexport default engine;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"container",frontmatter:{title:"container",date:"2022-04-14T22:02:20.000Z",permalink:"/pages/a35554/",categories:["am-editor","engine"],tags:[null]},regularPath:"/30.web/70.am-editor/10.engine/30.container.html",relativePath:"30.web/70.am-editor/10.engine/30.container.md",key:"v-42d8aff9",path:"/pages/a35554/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:19},{level:2,title:"Container",slug:"container",normalizedTitle:"container",charIndex:2}],readingTime:{text:"3 min read",minutes:2.245,time:134700.00000000003,words:449},headersStr:"目录 Container",content:"# Container 容器\n\n\n# 目录\n\n\n\n * 目录\n * Container\n\n\n\n\n# Container\n\nclass Container {\n  // 容器配置\n private options: Options;\n  // 容器节点\n private node: NodeInterface;\n  // 是否 focus\n private _focused: boolean = false;\n #styleElement?: Element;\n\n constructor(selector: Selector, options: Options) {\n  this.node = $(selector);\n  this.options = options;\n  this._init();\n    // 初始化容器 focus\n  this._focused =\n   document.activeElement !== null &&\n   this.node.equal(document.activeElement);\n }\n\n _init() {\n  const { lang, tabIndex, className } = this.options;\n    // 设置 container 的 data-element 元素类型为 root\n  this.node.attributes(DATA_ELEMENT, ROOT);\n    // 设置 container 的通用属性\n  this.node.attributes({\n   contenteditable: 'true',\n   role: 'textbox',\n   autocorrect: lang === 'en-US' ? 'on' : 'off',\n   autocomplete: 'off',\n   spellcheck: lang === 'en-US' ? 'true' : 'false',\n   'data-gramm': 'false',\n  });\n\n  if (tabIndex !== undefined) {\n   this.node.attributes('tabindex', tabIndex);\n  }\n\n  if (!this.node.hasClass('am-engine')) {\n   this.node.addClass('am-engine');\n  }\n\n  if (isMobile) this.node.addClass('am-engine-mobile');\n\n  // className 支持 array 和 string\n    if (className !== undefined) {\n   (Array.isArray(className)\n    ? className\n    : className.split(/\\s+/)\n   ).forEach((name) => {\n    if (name.trim() !== '') this.node.addClass(name);\n   });\n  }\n }\n\n init() {\n  const { engine } = this.options;\n    // 监听 container 的 input 事件\n  this.node.on('input', (e) => {\n      // 预览模式不作处理\n   if (engine.readonly) {\n    return;\n   }\n\n   // card: card model instance\n      // 不处理卡片中的输入事件\n      if (engine.card.find(e.target)) {\n    return;\n   }\n   const range = engine.change.range.get();\n   range.handleBr(true);\n  });\n  // 编辑器文档尾部始终保持一行\n  this.node.on('click', (event: MouseEvent) => {\n   if (event.target && $(event.target).isEditable()) {\n    // 获取到编辑器内最后一个子节点\n    const block = this.node.last();\n    if (block) {\n     //不是卡片不处理\n     if (!block.isCard()) return;\n     //节点不可见不处理\n     if (\n      (block.get<HTMLElement>()?.offsetTop || 0) +\n       (block.get<Element>()?.clientHeight || 0) >\n      event.offsetY\n     )\n      return;\n    }\n    const node = $('<p><br /></p>');\n    this.node.append(node);\n    const range = engine.change.range.get();\n        // 聚焦光标在最后一行\n    range.select(node, true).collapse(false);\n    engine.change.apply(range);\n   }\n  });\n  let isMousedown = false;\n  this.node.on(isMobile ? 'touchstart' : 'mousedown', () => {\n   isMousedown = true;\n   setTimeout(() => {\n    if (!this._focused) {\n     this._focused = true;\n          // 鼠标按下触发 focus 事件\n     engine.trigger('focus');\n    }\n    isMousedown = false;\n   }, 10);\n  });\n  this.node.on('focus', () => {\n   isMousedown = false;\n   this._focused = true;\n   engine.trigger('focus');\n  });\n  this.node.on('blur', () => {\n   if (isMousedown) return;\n   isMousedown = false;\n   this._focused = false;\n   engine.trigger('blur');\n  });\n }\n\n isFocus() {\n  return this._focused;\n }\n\n getNode() {\n  return this.node;\n }\n\n setReadonly(readonly: boolean) {\n  this.node.attributes('contenteditable', readonly ? 'false' : 'true');\n }\n\n showPlaceholder() {\n  const { placeholder } = this.options;\n  if (placeholder) {\n   if (this.#styleElement && this.#styleElement.parentNode)\n    document.body.removeChild(this.#styleElement);\n   this.#styleElement = document.createElement('style');\n   //const left = this.node.css('padding-left');\n   //const top = this.node.css('padding-top');\n      // 创建 placeholder 伪元素\n   const styleText = document.createTextNode(`.am-engine:before {\n                content: attr(data-placeholder);\n                pointer-events: none;\n                position: absolute;\n                color: #bbbfc4;\n                height: 0;\n            }`);\n   this.#styleElement.appendChild(styleText);\n   document.body.appendChild(this.#styleElement);\n   this.node.attributes({\n    'data-placeholder': placeholder,\n   });\n  } else if (this.#styleElement && this.#styleElement.parentNode)\n   document.body.removeChild(this.#styleElement);\n }\n\n hidePlaceholder() {\n  this.node.removeAttributes('data-placeholder');\n }\n\n destroy() {\n  const { className, engine } = this.options;\n  this.node.removeAttributes(DATA_ELEMENT);\n  this.node.removeAttributes('contenteditable');\n  this.node.removeAttributes('role');\n  this.node.removeAttributes('autocorrect');\n  this.node.removeAttributes('autocomplete');\n  this.node.removeAttributes('spellcheck');\n  this.node.removeAttributes('data-gramm');\n  this.node.removeAttributes('tabindex');\n  this.node.removeAttributes('data-placeholder');\n  if (this.#styleElement) document.body.removeChild(this.#styleElement);\n  if (this.options.className) {\n   (Array.isArray(className)\n    ? className\n    : (className || '').split(/\\s+/)\n   ).forEach((name) => {\n    if (name.trim() !== '') this.node.removeClass(name);\n   });\n  }\n\n  if (engine.card.closest(this.node)) this.node.removeClass('am-engine');\n  this.node.removeAllEvents();\n }\n}\n\nexport default Container;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n",normalizedContent:"# container 容器\n\n\n# 目录\n\n\n\n * 目录\n * container\n\n\n\n\n# container\n\nclass container {\n  // 容器配置\n private options: options;\n  // 容器节点\n private node: nodeinterface;\n  // 是否 focus\n private _focused: boolean = false;\n #styleelement?: element;\n\n constructor(selector: selector, options: options) {\n  this.node = $(selector);\n  this.options = options;\n  this._init();\n    // 初始化容器 focus\n  this._focused =\n   document.activeelement !== null &&\n   this.node.equal(document.activeelement);\n }\n\n _init() {\n  const { lang, tabindex, classname } = this.options;\n    // 设置 container 的 data-element 元素类型为 root\n  this.node.attributes(data_element, root);\n    // 设置 container 的通用属性\n  this.node.attributes({\n   contenteditable: 'true',\n   role: 'textbox',\n   autocorrect: lang === 'en-us' ? 'on' : 'off',\n   autocomplete: 'off',\n   spellcheck: lang === 'en-us' ? 'true' : 'false',\n   'data-gramm': 'false',\n  });\n\n  if (tabindex !== undefined) {\n   this.node.attributes('tabindex', tabindex);\n  }\n\n  if (!this.node.hasclass('am-engine')) {\n   this.node.addclass('am-engine');\n  }\n\n  if (ismobile) this.node.addclass('am-engine-mobile');\n\n  // classname 支持 array 和 string\n    if (classname !== undefined) {\n   (array.isarray(classname)\n    ? classname\n    : classname.split(/\\s+/)\n   ).foreach((name) => {\n    if (name.trim() !== '') this.node.addclass(name);\n   });\n  }\n }\n\n init() {\n  const { engine } = this.options;\n    // 监听 container 的 input 事件\n  this.node.on('input', (e) => {\n      // 预览模式不作处理\n   if (engine.readonly) {\n    return;\n   }\n\n   // card: card model instance\n      // 不处理卡片中的输入事件\n      if (engine.card.find(e.target)) {\n    return;\n   }\n   const range = engine.change.range.get();\n   range.handlebr(true);\n  });\n  // 编辑器文档尾部始终保持一行\n  this.node.on('click', (event: mouseevent) => {\n   if (event.target && $(event.target).iseditable()) {\n    // 获取到编辑器内最后一个子节点\n    const block = this.node.last();\n    if (block) {\n     //不是卡片不处理\n     if (!block.iscard()) return;\n     //节点不可见不处理\n     if (\n      (block.get<htmlelement>()?.offsettop || 0) +\n       (block.get<element>()?.clientheight || 0) >\n      event.offsety\n     )\n      return;\n    }\n    const node = $('<p><br /></p>');\n    this.node.append(node);\n    const range = engine.change.range.get();\n        // 聚焦光标在最后一行\n    range.select(node, true).collapse(false);\n    engine.change.apply(range);\n   }\n  });\n  let ismousedown = false;\n  this.node.on(ismobile ? 'touchstart' : 'mousedown', () => {\n   ismousedown = true;\n   settimeout(() => {\n    if (!this._focused) {\n     this._focused = true;\n          // 鼠标按下触发 focus 事件\n     engine.trigger('focus');\n    }\n    ismousedown = false;\n   }, 10);\n  });\n  this.node.on('focus', () => {\n   ismousedown = false;\n   this._focused = true;\n   engine.trigger('focus');\n  });\n  this.node.on('blur', () => {\n   if (ismousedown) return;\n   ismousedown = false;\n   this._focused = false;\n   engine.trigger('blur');\n  });\n }\n\n isfocus() {\n  return this._focused;\n }\n\n getnode() {\n  return this.node;\n }\n\n setreadonly(readonly: boolean) {\n  this.node.attributes('contenteditable', readonly ? 'false' : 'true');\n }\n\n showplaceholder() {\n  const { placeholder } = this.options;\n  if (placeholder) {\n   if (this.#styleelement && this.#styleelement.parentnode)\n    document.body.removechild(this.#styleelement);\n   this.#styleelement = document.createelement('style');\n   //const left = this.node.css('padding-left');\n   //const top = this.node.css('padding-top');\n      // 创建 placeholder 伪元素\n   const styletext = document.createtextnode(`.am-engine:before {\n                content: attr(data-placeholder);\n                pointer-events: none;\n                position: absolute;\n                color: #bbbfc4;\n                height: 0;\n            }`);\n   this.#styleelement.appendchild(styletext);\n   document.body.appendchild(this.#styleelement);\n   this.node.attributes({\n    'data-placeholder': placeholder,\n   });\n  } else if (this.#styleelement && this.#styleelement.parentnode)\n   document.body.removechild(this.#styleelement);\n }\n\n hideplaceholder() {\n  this.node.removeattributes('data-placeholder');\n }\n\n destroy() {\n  const { classname, engine } = this.options;\n  this.node.removeattributes(data_element);\n  this.node.removeattributes('contenteditable');\n  this.node.removeattributes('role');\n  this.node.removeattributes('autocorrect');\n  this.node.removeattributes('autocomplete');\n  this.node.removeattributes('spellcheck');\n  this.node.removeattributes('data-gramm');\n  this.node.removeattributes('tabindex');\n  this.node.removeattributes('data-placeholder');\n  if (this.#styleelement) document.body.removechild(this.#styleelement);\n  if (this.options.classname) {\n   (array.isarray(classname)\n    ? classname\n    : (classname || '').split(/\\s+/)\n   ).foreach((name) => {\n    if (name.trim() !== '') this.node.removeclass(name);\n   });\n  }\n\n  if (engine.card.closest(this.node)) this.node.removeclass('am-engine');\n  this.node.removeallevents();\n }\n}\n\nexport default container;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"change",frontmatter:{title:"change",date:"2022-04-14T22:02:20.000Z",permalink:"/pages/53c865/",categories:["am-editor","engine"],tags:[null]},regularPath:"/30.web/70.am-editor/10.engine/40.change.html",relativePath:"30.web/70.am-editor/10.engine/40.change.md",key:"v-7c8f5906",path:"/pages/53c865/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:13},{level:2,title:"ChangeEventInterface",slug:"changeeventinterface",normalizedTitle:"changeeventinterface",charIndex:28},{level:2,title:"",slug:"",normalizedTitle:"",charIndex:0}],readingTime:{text:"4 min read",minutes:3.4,time:204e3,words:680},headersStr:"目录 ChangeEventInterface ",content:"# Change\n\n\n# 目录\n\n\n\n * 目录\n * ChangeEventInterface\n * \n\n\n\n\n# ChangeEventInterface\n\n/**\n * Change 事件\n */\nexport interface ChangeEventInterface {\n /**\n  * 是否组合输入中\n  */\n isComposing: boolean;\n /**\n  * 是否选择中\n  */\n isSelecting: boolean;\n /**\n  * 是否在卡片中输入\n  * @param e\n  */\n isCardInput(e: Event): boolean;\n /**\n  * 输入事件\n  * @param callback\n  */\n onInput(callback: (event: InputEvent) => void): void;\n /**\n  * 选择事件\n  * @param callback\n  */\n onSelect(callback: (event: Event) => void): void;\n /**\n  * 粘贴事件\n  * @param callback\n  */\n onPaste(\n  callback: (data: ClipboardData & { isPasteText: boolean }) => void,\n ): void;\n /**\n  * 拖动事件\n  * @param callback\n  */\n onDrop(\n  callback: (params: {\n   event: DragEvent;\n   range?: RangeInterface;\n   card?: CardInterface;\n   files: Array<File | null>;\n  }) => void,\n ): void;\n /**\n  * 绑定事件到 document 中\n  * @param eventType\n  * @param listener\n  * @param index\n  */\n onDocument(\n  eventType: string,\n  listener: EventListener,\n  index?: number,\n ): void;\n /**\n  * 绑定事件到 window 中\n  * @param eventType\n  * @param listener\n  * @param index\n  */\n onWindow(eventType: string, listener: EventListener, index?: number): void;\n /**\n  * 绑定事件到编辑器容器节点中\n  * @param eventType\n  * @param listener\n  * @param index\n  */\n onContainer(\n  eventType: string,\n  listener: EventListener,\n  index?: number,\n ): void;\n /**\n  * 绑定事件到编辑器根节点中\n  * @param eventType\n  * @param listener\n  * @param index\n  */\n onRoot(eventType: string, listener: EventListener, index?: number): void;\n /**\n  * 销毁\n  */\n destroy(): void;\n}\n\nexport type ChangeEventOptions = {\n bindInput?: () => boolean;\n bindSelect?: () => boolean;\n bindPaste?: () => boolean;\n bindDrop?: () => boolean;\n};\n\nexport type ChangeOptions = {\n /**\n  * 值改变事件\n  */\n onChange?: (value: string, trigger: 'remote' | 'local' | 'both') => void;\n /**\n  * 光标选择事件\n  */\n onSelect?: () => void;\n /**\n  * 值实时变化事件\n  */\n onRealtimeChange?: (trigger: 'remote' | 'local') => void;\n /**\n  * 设置值后触发\n  */\n onSetValue?: () => void;\n};\n\nexport interface ChangeConstructor {\n /**\n  * 构造函数\n  */\n new (container: NodeInterface, options: ChangeOptions): ChangeInterface;\n}\nexport interface ChangeRangeInterface {\n /**\n  * 获取当前选区的范围\n  */\n get(): RangeInterface;\n /**\n  * 获取安全可控的光标对象\n  * @param range 默认当前光标\n  */\n toTrusty(range?: RangeInterface): RangeInterface;\n /**\n  * 选中指定的范围\n  * @param range 光标\n  * @param triggerSelect 时候触发onSelect事件\n  */\n select(range: RangeInterface, triggerSelect?: boolean): void;\n /**\n  * 聚焦编辑器\n  * @param toStart true:开始位置,false:结束位置，默认为之前操作位置\n  */\n focus(toStart?: boolean): void;\n /**\n  * 取消焦点\n  */\n blur(): void;\n}\n/**\n * Change 接口\n */\nexport interface ChangeInterface {\n /**\n  * 初始化\n  */\n init(): void;\n /**\n  * 命令执行器的range位置\n  */\n rangePathBeforeCommand?: { start: RangePath; end: RangePath };\n /**\n  * 事件对象\n  */\n event: ChangeEventInterface;\n /**\n  * Range 对象\n  */\n range: ChangeRangeInterface;\n /**\n  * 当前光标位置处的所有 mark 节点\n  */\n marks: Array<NodeInterface>;\n /**\n  * 当前光标位置处的所有 block 节点\n  */\n blocks: Array<NodeInterface>;\n /**\n  * 当前光标位置处的所有 inline 节点\n  */\n inlines: Array<NodeInterface>;\n /**\n  * 编辑器值改变触发\n  */\n onChange: (value: string, trigger: 'remote' | 'local' | 'both') => void;\n /**\n  * 编辑器中光标改变触发\n  */\n onSelect: () => void;\n /**\n  * 设置编辑器值后触发\n  */\n onSetValue: () => void;\n /**\n  * 触发一个编辑器值改变事件\n  * @param isRemote 是否是远程操作\n  * @param node 触发后变更的节点\n  */\n change(isRemote?: boolean, node?: Array<NodeInterface>): void;\n /**\n  * 应用一个具有改变dom结构的操作\n  * @param range 光标\n  */\n apply(range?: RangeInterface): void;\n /**\n  * 把分隔开的文字组合成一个节点\n  */\n combinText(): void;\n /**\n  * 是否在组合输入法中\n  */\n isComposing(): boolean;\n /**\n  *光标是否在选择中\n  */\n isSelecting(): boolean;\n /**\n  * 初始化一个编辑器空值\n  * @param range\n  */\n initValue(range?: RangeInterface): void;\n /**\n  * 给编辑器设置一个值\n  * @param value 值\n  * @param onParse 解析回调\n  * @param callback 渲染完成后回调\n  */\n setValue(\n  value: string,\n  onParse?: (node: NodeInterface) => void,\n  callback?: (count: number) => void,\n ): void;\n /**\n  * 设置html，会格式化为合法的编辑器值\n  * @param html html\n  * @param callback 异步渲染卡片后回调\n  */\n setHtml(html: string, callback?: (count: number) => void): void;\n /**\n  * 获取编辑器值\n  */\n getOriginValue(): string;\n /**\n  * 获取编辑值\n  * @param options\n  */\n getValue(options: { ignoreCursor?: boolean }): string;\n /**\n  * 在执行一个操作前缓存当前光标\n  */\n cacheRangeBeforeCommand(): void;\n /**\n  * 获取当前缓存的光标路径\n  */\n getRangePathBeforeCommand():\n  | { start: RangePath; end: RangePath }\n  | undefined;\n /**\n  * 当前编辑器是否未空值\n  */\n isEmpty(): boolean;\n /**\n  * 插入片段\n  * @param fragment 片段\n  * @param callback 插入后的回调函数\n  * @param followActiveMark 删除后空标签是否跟随当前激活的mark样式\n  */\n insert(\n  fragment: DocumentFragment,\n  range?: RangeInterface,\n  callback?: (range: RangeInterface) => void,\n  followActiveMark?: boolean,\n ): void;\n /**\n  * 删除内容\n  * @param range 光标，默认获取当前光标\n  * @param isDeepMerge 删除后是否合并\n  * @param followActiveMark 删除后空标签是否跟随当前激活的mark样式\n  */\n delete(\n  range?: RangeInterface,\n  isDeepMerge?: boolean,\n  followActiveMark?: boolean,\n ): void;\n /**\n  * 去除当前光标最接近的block节点或传入的节点外层包裹\n  * @param node 节点\n  */\n unwrap(node?: NodeInterface): void;\n /**\n  * 删除当前光标最接近的block节点或传入的节点的前面一个节点后合并\n  * @param node 节点\n  */\n mergeAfterDelete(node?: NodeInterface): void;\n /**\n  * 销毁\n  */\n destroy(): void;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n\n\n\n#",normalizedContent:"# change\n\n\n# 目录\n\n\n\n * 目录\n * changeeventinterface\n * \n\n\n\n\n# changeeventinterface\n\n/**\n * change 事件\n */\nexport interface changeeventinterface {\n /**\n  * 是否组合输入中\n  */\n iscomposing: boolean;\n /**\n  * 是否选择中\n  */\n isselecting: boolean;\n /**\n  * 是否在卡片中输入\n  * @param e\n  */\n iscardinput(e: event): boolean;\n /**\n  * 输入事件\n  * @param callback\n  */\n oninput(callback: (event: inputevent) => void): void;\n /**\n  * 选择事件\n  * @param callback\n  */\n onselect(callback: (event: event) => void): void;\n /**\n  * 粘贴事件\n  * @param callback\n  */\n onpaste(\n  callback: (data: clipboarddata & { ispastetext: boolean }) => void,\n ): void;\n /**\n  * 拖动事件\n  * @param callback\n  */\n ondrop(\n  callback: (params: {\n   event: dragevent;\n   range?: rangeinterface;\n   card?: cardinterface;\n   files: array<file | null>;\n  }) => void,\n ): void;\n /**\n  * 绑定事件到 document 中\n  * @param eventtype\n  * @param listener\n  * @param index\n  */\n ondocument(\n  eventtype: string,\n  listener: eventlistener,\n  index?: number,\n ): void;\n /**\n  * 绑定事件到 window 中\n  * @param eventtype\n  * @param listener\n  * @param index\n  */\n onwindow(eventtype: string, listener: eventlistener, index?: number): void;\n /**\n  * 绑定事件到编辑器容器节点中\n  * @param eventtype\n  * @param listener\n  * @param index\n  */\n oncontainer(\n  eventtype: string,\n  listener: eventlistener,\n  index?: number,\n ): void;\n /**\n  * 绑定事件到编辑器根节点中\n  * @param eventtype\n  * @param listener\n  * @param index\n  */\n onroot(eventtype: string, listener: eventlistener, index?: number): void;\n /**\n  * 销毁\n  */\n destroy(): void;\n}\n\nexport type changeeventoptions = {\n bindinput?: () => boolean;\n bindselect?: () => boolean;\n bindpaste?: () => boolean;\n binddrop?: () => boolean;\n};\n\nexport type changeoptions = {\n /**\n  * 值改变事件\n  */\n onchange?: (value: string, trigger: 'remote' | 'local' | 'both') => void;\n /**\n  * 光标选择事件\n  */\n onselect?: () => void;\n /**\n  * 值实时变化事件\n  */\n onrealtimechange?: (trigger: 'remote' | 'local') => void;\n /**\n  * 设置值后触发\n  */\n onsetvalue?: () => void;\n};\n\nexport interface changeconstructor {\n /**\n  * 构造函数\n  */\n new (container: nodeinterface, options: changeoptions): changeinterface;\n}\nexport interface changerangeinterface {\n /**\n  * 获取当前选区的范围\n  */\n get(): rangeinterface;\n /**\n  * 获取安全可控的光标对象\n  * @param range 默认当前光标\n  */\n totrusty(range?: rangeinterface): rangeinterface;\n /**\n  * 选中指定的范围\n  * @param range 光标\n  * @param triggerselect 时候触发onselect事件\n  */\n select(range: rangeinterface, triggerselect?: boolean): void;\n /**\n  * 聚焦编辑器\n  * @param tostart true:开始位置,false:结束位置，默认为之前操作位置\n  */\n focus(tostart?: boolean): void;\n /**\n  * 取消焦点\n  */\n blur(): void;\n}\n/**\n * change 接口\n */\nexport interface changeinterface {\n /**\n  * 初始化\n  */\n init(): void;\n /**\n  * 命令执行器的range位置\n  */\n rangepathbeforecommand?: { start: rangepath; end: rangepath };\n /**\n  * 事件对象\n  */\n event: changeeventinterface;\n /**\n  * range 对象\n  */\n range: changerangeinterface;\n /**\n  * 当前光标位置处的所有 mark 节点\n  */\n marks: array<nodeinterface>;\n /**\n  * 当前光标位置处的所有 block 节点\n  */\n blocks: array<nodeinterface>;\n /**\n  * 当前光标位置处的所有 inline 节点\n  */\n inlines: array<nodeinterface>;\n /**\n  * 编辑器值改变触发\n  */\n onchange: (value: string, trigger: 'remote' | 'local' | 'both') => void;\n /**\n  * 编辑器中光标改变触发\n  */\n onselect: () => void;\n /**\n  * 设置编辑器值后触发\n  */\n onsetvalue: () => void;\n /**\n  * 触发一个编辑器值改变事件\n  * @param isremote 是否是远程操作\n  * @param node 触发后变更的节点\n  */\n change(isremote?: boolean, node?: array<nodeinterface>): void;\n /**\n  * 应用一个具有改变dom结构的操作\n  * @param range 光标\n  */\n apply(range?: rangeinterface): void;\n /**\n  * 把分隔开的文字组合成一个节点\n  */\n combintext(): void;\n /**\n  * 是否在组合输入法中\n  */\n iscomposing(): boolean;\n /**\n  *光标是否在选择中\n  */\n isselecting(): boolean;\n /**\n  * 初始化一个编辑器空值\n  * @param range\n  */\n initvalue(range?: rangeinterface): void;\n /**\n  * 给编辑器设置一个值\n  * @param value 值\n  * @param onparse 解析回调\n  * @param callback 渲染完成后回调\n  */\n setvalue(\n  value: string,\n  onparse?: (node: nodeinterface) => void,\n  callback?: (count: number) => void,\n ): void;\n /**\n  * 设置html，会格式化为合法的编辑器值\n  * @param html html\n  * @param callback 异步渲染卡片后回调\n  */\n sethtml(html: string, callback?: (count: number) => void): void;\n /**\n  * 获取编辑器值\n  */\n getoriginvalue(): string;\n /**\n  * 获取编辑值\n  * @param options\n  */\n getvalue(options: { ignorecursor?: boolean }): string;\n /**\n  * 在执行一个操作前缓存当前光标\n  */\n cacherangebeforecommand(): void;\n /**\n  * 获取当前缓存的光标路径\n  */\n getrangepathbeforecommand():\n  | { start: rangepath; end: rangepath }\n  | undefined;\n /**\n  * 当前编辑器是否未空值\n  */\n isempty(): boolean;\n /**\n  * 插入片段\n  * @param fragment 片段\n  * @param callback 插入后的回调函数\n  * @param followactivemark 删除后空标签是否跟随当前激活的mark样式\n  */\n insert(\n  fragment: documentfragment,\n  range?: rangeinterface,\n  callback?: (range: rangeinterface) => void,\n  followactivemark?: boolean,\n ): void;\n /**\n  * 删除内容\n  * @param range 光标，默认获取当前光标\n  * @param isdeepmerge 删除后是否合并\n  * @param followactivemark 删除后空标签是否跟随当前激活的mark样式\n  */\n delete(\n  range?: rangeinterface,\n  isdeepmerge?: boolean,\n  followactivemark?: boolean,\n ): void;\n /**\n  * 去除当前光标最接近的block节点或传入的节点外层包裹\n  * @param node 节点\n  */\n unwrap(node?: nodeinterface): void;\n /**\n  * 删除当前光标最接近的block节点或传入的节点的前面一个节点后合并\n  * @param node 节点\n  */\n mergeafterdelete(node?: nodeinterface): void;\n /**\n  * 销毁\n  */\n destroy(): void;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n\n\n\n#",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"range",frontmatter:{title:"range",date:"2022-04-14T22:02:20.000Z",permalink:"/pages/7f2a93/",categories:["am-editor","engine"],tags:[null]},regularPath:"/30.web/70.am-editor/10.engine/50.range.html",relativePath:"30.web/70.am-editor/10.engine/50.range.md",key:"v-55778605",path:"/pages/7f2a93/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:12}],readingTime:{text:"1 min read",minutes:.035,time:2100,words:7},headersStr:"目录",content:"# Range\n\n\n# 目录\n\n\n\n * 目录\n\n",normalizedContent:"# range\n\n\n# 目录\n\n\n\n * 目录\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"开始阅读",frontmatter:{title:"开始阅读",date:"2022-06-23T16:08:30.000Z",permalink:"/axios/index/",categories:["web","axios"],tags:[null]},regularPath:"/30.web/8.axios/0.index.html",relativePath:"30.web/8.axios/0.index.md",key:"v-51bac5f7",path:"/axios/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"本章概要",frontmatter:{title:"本章概要",date:"2022-06-23T16:09:43.000Z",permalink:"/axios/core/index/",categories:["web","axios","core"],tags:[null]},regularPath:"/30.web/8.axios/10.core/0.index.html",relativePath:"30.web/8.axios/10.core/0.index.md",key:"v-f55aa90e",path:"/axios/core/index/",headers:[{level:2,title:"Request Config",slug:"request-config",normalizedTitle:"request config",charIndex:2}],readingTime:{text:"7 min read",minutes:6.88,time:412800,words:1376},headersStr:"Request Config",content:"# Request Config\n\nThese are the available config options for making requests. Only the url is required. Requests will default to GET if method is not specified.\n\n{\n  // `url` is the server URL that will be used for the request\n  url: '/user',\n\n  // `method` is the request method to be used when making the request\n  method: 'get', // default\n\n  // `baseURL` will be prepended to `url` unless `url` is absolute.\n  // It can be convenient to set `baseURL` for an instance of axios to pass relative URLs\n  // to methods of that instance.\n  baseURL: 'https://some-domain.com/api/',\n\n  // `transformRequest` allows changes to the request data before it is sent to the server\n  // This is only applicable for request methods 'PUT', 'POST', 'PATCH' and 'DELETE'\n  // The last function in the array must return a string or an instance of Buffer, ArrayBuffer,\n  // FormData or Stream\n  // You may modify the headers object.\n  transformRequest: [function (data, headers) {\n    // Do whatever you want to transform the data\n\n    return data;\n  }],\n\n  // `transformResponse` allows changes to the response data to be made before\n  // it is passed to then/catch\n  transformResponse: [function (data) {\n    // Do whatever you want to transform the data\n\n    return data;\n  }],\n\n  // `headers` are custom headers to be sent\n  headers: {'X-Requested-With': 'XMLHttpRequest'},\n\n  // `params` are the URL parameters to be sent with the request\n  // Must be a plain object or a URLSearchParams object\n  params: {\n    ID: 12345\n  },\n\n  // `paramsSerializer` is an optional config in charge of serializing `params`\n  paramsSerializer: {\n    indexes: null // array indexes format (null - no brackets, false - empty brackets, true - brackets with indexes)\n  },\n\n  // `data` is the data to be sent as the request body\n  // Only applicable for request methods 'PUT', 'POST', 'DELETE , and 'PATCH'\n  // When no `transformRequest` is set, must be of one of the following types:\n  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams\n  // - Browser only: FormData, File, Blob\n  // - Node only: Stream, Buffer\n  data: {\n    firstName: 'Fred'\n  },\n  \n  // syntax alternative to send data into the body\n  // method post\n  // only the value is sent, not the key\n  data: 'Country=Brasil&City=Belo Horizonte',\n\n  // `timeout` specifies the number of milliseconds before the request times out.\n  // If the request takes longer than `timeout`, the request will be aborted.\n  timeout: 1000, // default is `0` (no timeout)\n\n  // `withCredentials` indicates whether or not cross-site Access-Control requests\n  // should be made using credentials\n  withCredentials: false, // default\n\n  // `adapter` allows custom handling of requests which makes testing easier.\n  // Return a promise and supply a valid response (see lib/adapters/README.md).\n  adapter: function (config) {\n    /* ... */\n  },\n\n  // `auth` indicates that HTTP Basic auth should be used, and supplies credentials.\n  // This will set an `Authorization` header, overwriting any existing\n  // `Authorization` custom headers you have set using `headers`.\n  // Please note that only HTTP Basic auth is configurable through this parameter.\n  // For Bearer tokens and such, use `Authorization` custom headers instead.\n  auth: {\n    username: 'janedoe',\n    password: 's00pers3cret'\n  },\n\n  // `responseType` indicates the type of data that the server will respond with\n  // options are: 'arraybuffer', 'document', 'json', 'text', 'stream'\n  //   browser only: 'blob'\n  responseType: 'json', // default\n\n  // `responseEncoding` indicates encoding to use for decoding responses (Node.js only)\n  // Note: Ignored for `responseType` of 'stream' or client-side requests\n  responseEncoding: 'utf8', // default\n\n  // `xsrfCookieName` is the name of the cookie to use as a value for xsrf token\n  xsrfCookieName: 'XSRF-TOKEN', // default\n\n  // `xsrfHeaderName` is the name of the http header that carries the xsrf token value\n  xsrfHeaderName: 'X-XSRF-TOKEN', // default\n\n  // `onUploadProgress` allows handling of progress events for uploads\n  // browser only\n  onUploadProgress: function (progressEvent) {\n    // Do whatever you want with the native progress event\n  },\n\n  // `onDownloadProgress` allows handling of progress events for downloads\n  // browser only\n  onDownloadProgress: function (progressEvent) {\n    // Do whatever you want with the native progress event\n  },\n\n  // `maxContentLength` defines the max size of the http response content in bytes allowed in node.js\n  maxContentLength: 2000,\n\n  // `maxBodyLength` (Node only option) defines the max size of the http request content in bytes allowed\n  maxBodyLength: 2000,\n\n  // `validateStatus` defines whether to resolve or reject the promise for a given\n  // HTTP response status code. If `validateStatus` returns `true` (or is set to `null`\n  // or `undefined`), the promise will be resolved; otherwise, the promise will be\n  // rejected.\n  validateStatus: function (status) {\n    return status >= 200 && status < 300; // default\n  },\n\n  // `maxRedirects` defines the maximum number of redirects to follow in node.js.\n  // If set to 0, no redirects will be followed.\n  maxRedirects: 21, // default\n\n  // `beforeRedirect` defines a function that will be called before redirect.\n  // Use this to adjust the request options upon redirecting,\n  // to inspect the latest response headers,\n  // or to cancel the request by throwing an error\n  // If maxRedirects is set to 0, `beforeRedirect` is not used.\n  beforeRedirect: (options, { headers }) => {\n    if (options.hostname === \"example.com\") {\n      options.auth = \"user:password\";\n    }\n  },\n\n  // `socketPath` defines a UNIX Socket to be used in node.js.\n  // e.g. '/var/run/docker.sock' to send requests to the docker daemon.\n  // Only either `socketPath` or `proxy` can be specified.\n  // If both are specified, `socketPath` is used.\n  socketPath: null, // default\n\n  // `httpAgent` and `httpsAgent` define a custom agent to be used when performing http\n  // and https requests, respectively, in node.js. This allows options to be added like\n  // `keepAlive` that are not enabled by default.\n  httpAgent: new http.Agent({ keepAlive: true }),\n  httpsAgent: new https.Agent({ keepAlive: true }),\n\n  // `proxy` defines the hostname, port, and protocol of the proxy server.\n  // You can also define your proxy using the conventional `http_proxy` and\n  // `https_proxy` environment variables. If you are using environment variables\n  // for your proxy configuration, you can also define a `no_proxy` environment\n  // variable as a comma-separated list of domains that should not be proxied.\n  // Use `false` to disable proxies, ignoring environment variables.\n  // `auth` indicates that HTTP Basic auth should be used to connect to the proxy, and\n  // supplies credentials.\n  // This will set an `Proxy-Authorization` header, overwriting any existing\n  // `Proxy-Authorization` custom headers you have set using `headers`.\n  // If the proxy server uses HTTPS, then you must set the protocol to `https`. \n  proxy: {\n    protocol: 'https',\n    host: '127.0.0.1',\n    port: 9000,\n    auth: {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  },\n\n  // `cancelToken` specifies a cancel token that can be used to cancel the request\n  // (see Cancellation section below for details)\n  cancelToken: new CancelToken(function (cancel) {\n  }),\n\n  // an alternative way to cancel Axios requests using AbortController\n  signal: new AbortController().signal,\n\n  // `decompress` indicates whether or not the response body should be decompressed \n  // automatically. If set to `true` will also remove the 'content-encoding' header \n  // from the responses objects of all decompressed responses\n  // - Node only (XHR cannot turn off decompression)\n  decompress: true // default\n\n  // `insecureHTTPParser` boolean.\n  // Indicates where to use an insecure HTTP parser that accepts invalid HTTP headers.\n  // This may allow interoperability with non-conformant HTTP implementations.\n  // Using the insecure parser should be avoided.\n  // see options https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_http_request_url_options_callback\n  // see also https://nodejs.org/en/blog/vulnerability/february-2020-security-releases/#strict-http-header-parsing-none\n  insecureHTTPParser: undefined // default\n\n  // transitional options for backward compatibility that may be removed in the newer versions\n  transitional: {\n    // silent JSON parsing mode\n    // `true`  - ignore JSON parsing errors and set response.data to null if parsing failed (old behaviour)\n    // `false` - throw SyntaxError if JSON parsing failed (Note: responseType must be set to 'json')\n    silentJSONParsing: true, // default value for the current Axios version\n\n    // try to parse the response string as JSON even if `responseType` is not 'json'\n    forcedJSONParsing: true,\n    \n    // throw ETIMEDOUT error instead of generic ECONNABORTED on request timeouts\n    clarifyTimeoutError: false,\n  },\n\n  env: {\n    // The FormData class to be used to automatically serialize the payload into a FormData object\n    FormData: window?.FormData || global?.FormData\n  },\n\n  formSerializer: {\n      visitor: (value, key, path, helpers)=> {}; // custom visitor funaction to serrialize form values\n      dots: boolean; // use dots instead of brackets format\n      metaTokens: boolean; // keep special endings like {} in parameter key \n      indexes: boolean; // array indexes format null - no brackets, false - empty brackets, true - brackets with indexes\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n",normalizedContent:"# request config\n\nthese are the available config options for making requests. only the url is required. requests will default to get if method is not specified.\n\n{\n  // `url` is the server url that will be used for the request\n  url: '/user',\n\n  // `method` is the request method to be used when making the request\n  method: 'get', // default\n\n  // `baseurl` will be prepended to `url` unless `url` is absolute.\n  // it can be convenient to set `baseurl` for an instance of axios to pass relative urls\n  // to methods of that instance.\n  baseurl: 'https://some-domain.com/api/',\n\n  // `transformrequest` allows changes to the request data before it is sent to the server\n  // this is only applicable for request methods 'put', 'post', 'patch' and 'delete'\n  // the last function in the array must return a string or an instance of buffer, arraybuffer,\n  // formdata or stream\n  // you may modify the headers object.\n  transformrequest: [function (data, headers) {\n    // do whatever you want to transform the data\n\n    return data;\n  }],\n\n  // `transformresponse` allows changes to the response data to be made before\n  // it is passed to then/catch\n  transformresponse: [function (data) {\n    // do whatever you want to transform the data\n\n    return data;\n  }],\n\n  // `headers` are custom headers to be sent\n  headers: {'x-requested-with': 'xmlhttprequest'},\n\n  // `params` are the url parameters to be sent with the request\n  // must be a plain object or a urlsearchparams object\n  params: {\n    id: 12345\n  },\n\n  // `paramsserializer` is an optional config in charge of serializing `params`\n  paramsserializer: {\n    indexes: null // array indexes format (null - no brackets, false - empty brackets, true - brackets with indexes)\n  },\n\n  // `data` is the data to be sent as the request body\n  // only applicable for request methods 'put', 'post', 'delete , and 'patch'\n  // when no `transformrequest` is set, must be of one of the following types:\n  // - string, plain object, arraybuffer, arraybufferview, urlsearchparams\n  // - browser only: formdata, file, blob\n  // - node only: stream, buffer\n  data: {\n    firstname: 'fred'\n  },\n  \n  // syntax alternative to send data into the body\n  // method post\n  // only the value is sent, not the key\n  data: 'country=brasil&city=belo horizonte',\n\n  // `timeout` specifies the number of milliseconds before the request times out.\n  // if the request takes longer than `timeout`, the request will be aborted.\n  timeout: 1000, // default is `0` (no timeout)\n\n  // `withcredentials` indicates whether or not cross-site access-control requests\n  // should be made using credentials\n  withcredentials: false, // default\n\n  // `adapter` allows custom handling of requests which makes testing easier.\n  // return a promise and supply a valid response (see lib/adapters/readme.md).\n  adapter: function (config) {\n    /* ... */\n  },\n\n  // `auth` indicates that http basic auth should be used, and supplies credentials.\n  // this will set an `authorization` header, overwriting any existing\n  // `authorization` custom headers you have set using `headers`.\n  // please note that only http basic auth is configurable through this parameter.\n  // for bearer tokens and such, use `authorization` custom headers instead.\n  auth: {\n    username: 'janedoe',\n    password: 's00pers3cret'\n  },\n\n  // `responsetype` indicates the type of data that the server will respond with\n  // options are: 'arraybuffer', 'document', 'json', 'text', 'stream'\n  //   browser only: 'blob'\n  responsetype: 'json', // default\n\n  // `responseencoding` indicates encoding to use for decoding responses (node.js only)\n  // note: ignored for `responsetype` of 'stream' or client-side requests\n  responseencoding: 'utf8', // default\n\n  // `xsrfcookiename` is the name of the cookie to use as a value for xsrf token\n  xsrfcookiename: 'xsrf-token', // default\n\n  // `xsrfheadername` is the name of the http header that carries the xsrf token value\n  xsrfheadername: 'x-xsrf-token', // default\n\n  // `onuploadprogress` allows handling of progress events for uploads\n  // browser only\n  onuploadprogress: function (progressevent) {\n    // do whatever you want with the native progress event\n  },\n\n  // `ondownloadprogress` allows handling of progress events for downloads\n  // browser only\n  ondownloadprogress: function (progressevent) {\n    // do whatever you want with the native progress event\n  },\n\n  // `maxcontentlength` defines the max size of the http response content in bytes allowed in node.js\n  maxcontentlength: 2000,\n\n  // `maxbodylength` (node only option) defines the max size of the http request content in bytes allowed\n  maxbodylength: 2000,\n\n  // `validatestatus` defines whether to resolve or reject the promise for a given\n  // http response status code. if `validatestatus` returns `true` (or is set to `null`\n  // or `undefined`), the promise will be resolved; otherwise, the promise will be\n  // rejected.\n  validatestatus: function (status) {\n    return status >= 200 && status < 300; // default\n  },\n\n  // `maxredirects` defines the maximum number of redirects to follow in node.js.\n  // if set to 0, no redirects will be followed.\n  maxredirects: 21, // default\n\n  // `beforeredirect` defines a function that will be called before redirect.\n  // use this to adjust the request options upon redirecting,\n  // to inspect the latest response headers,\n  // or to cancel the request by throwing an error\n  // if maxredirects is set to 0, `beforeredirect` is not used.\n  beforeredirect: (options, { headers }) => {\n    if (options.hostname === \"example.com\") {\n      options.auth = \"user:password\";\n    }\n  },\n\n  // `socketpath` defines a unix socket to be used in node.js.\n  // e.g. '/var/run/docker.sock' to send requests to the docker daemon.\n  // only either `socketpath` or `proxy` can be specified.\n  // if both are specified, `socketpath` is used.\n  socketpath: null, // default\n\n  // `httpagent` and `httpsagent` define a custom agent to be used when performing http\n  // and https requests, respectively, in node.js. this allows options to be added like\n  // `keepalive` that are not enabled by default.\n  httpagent: new http.agent({ keepalive: true }),\n  httpsagent: new https.agent({ keepalive: true }),\n\n  // `proxy` defines the hostname, port, and protocol of the proxy server.\n  // you can also define your proxy using the conventional `http_proxy` and\n  // `https_proxy` environment variables. if you are using environment variables\n  // for your proxy configuration, you can also define a `no_proxy` environment\n  // variable as a comma-separated list of domains that should not be proxied.\n  // use `false` to disable proxies, ignoring environment variables.\n  // `auth` indicates that http basic auth should be used to connect to the proxy, and\n  // supplies credentials.\n  // this will set an `proxy-authorization` header, overwriting any existing\n  // `proxy-authorization` custom headers you have set using `headers`.\n  // if the proxy server uses https, then you must set the protocol to `https`. \n  proxy: {\n    protocol: 'https',\n    host: '127.0.0.1',\n    port: 9000,\n    auth: {\n      username: 'mikeymike',\n      password: 'rapunz3l'\n    }\n  },\n\n  // `canceltoken` specifies a cancel token that can be used to cancel the request\n  // (see cancellation section below for details)\n  canceltoken: new canceltoken(function (cancel) {\n  }),\n\n  // an alternative way to cancel axios requests using abortcontroller\n  signal: new abortcontroller().signal,\n\n  // `decompress` indicates whether or not the response body should be decompressed \n  // automatically. if set to `true` will also remove the 'content-encoding' header \n  // from the responses objects of all decompressed responses\n  // - node only (xhr cannot turn off decompression)\n  decompress: true // default\n\n  // `insecurehttpparser` boolean.\n  // indicates where to use an insecure http parser that accepts invalid http headers.\n  // this may allow interoperability with non-conformant http implementations.\n  // using the insecure parser should be avoided.\n  // see options https://nodejs.org/dist/latest-v12.x/docs/api/http.html#http_http_request_url_options_callback\n  // see also https://nodejs.org/en/blog/vulnerability/february-2020-security-releases/#strict-http-header-parsing-none\n  insecurehttpparser: undefined // default\n\n  // transitional options for backward compatibility that may be removed in the newer versions\n  transitional: {\n    // silent json parsing mode\n    // `true`  - ignore json parsing errors and set response.data to null if parsing failed (old behaviour)\n    // `false` - throw syntaxerror if json parsing failed (note: responsetype must be set to 'json')\n    silentjsonparsing: true, // default value for the current axios version\n\n    // try to parse the response string as json even if `responsetype` is not 'json'\n    forcedjsonparsing: true,\n    \n    // throw etimedout error instead of generic econnaborted on request timeouts\n    clarifytimeouterror: false,\n  },\n\n  env: {\n    // the formdata class to be used to automatically serialize the payload into a formdata object\n    formdata: window?.formdata || global?.formdata\n  },\n\n  formserializer: {\n      visitor: (value, key, path, helpers)=> {}; // custom visitor funaction to serrialize form values\n      dots: boolean; // use dots instead of brackets format\n      metatokens: boolean; // keep special endings like {} in parameter key \n      indexes: boolean; // array indexes format null - no brackets, false - empty brackets, true - brackets with indexes\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n",charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"axios 对象和方法",frontmatter:{title:"axios 对象和方法",date:"2022-06-23T19:53:42.000Z",permalink:"/axios/core/instance/",categories:["web","axios","core"],tags:[null]},regularPath:"/30.web/8.axios/10.core/10.axios.html",relativePath:"30.web/8.axios/10.core/10.axios.md",key:"v-ea939fc6",path:"/axios/core/instance/",headers:[{level:2,title:"Axios 对象",slug:"axios-对象",normalizedTitle:"axios 对象",charIndex:2},{level:2,title:"任务链",slug:"任务链",normalizedTitle:"任务链",charIndex:1072},{level:2,title:"dispatchRequest",slug:"dispatchrequest",normalizedTitle:"dispatchrequest",charIndex:1101}],readingTime:{text:"4 min read",minutes:3.26,time:195600,words:652},headersStr:"Axios 对象 任务链 dispatchRequest",content:'# Axios 对象\n\nAxios 对象通过 ES5 语法构建。\n\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n从 OOP 的角度看，和 ES6 语法相比，类的构造器、实例方法、静态方法写法不同，可以作如下对比：\n\n            ES6               ES5\n构造器         constructor 函数    函数体\n调用福构造器      super()           SuperClass.call(this)\n静态方法、静态属性   static property   Class.property\n实例方法、实例属性   this.property     Class.prototype.property\n实例化         new Class()       new Class()\nthis        指向实例              指向实例\n继承          extends 关键字       原型继承\n\nES5 中类的继承：\n\n/** Inherit the prototype methods from one constructor into another */\nfunction inherits(constructor, superConstructor, props, descriptors) {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  props && Object.assign(constructor.prototype, props);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n如何使用 ES5 语法继承父类？\n\n * 根据父类的原型创建一个原型，并作为子类的原型。\n * 将子类的构造器添加到子类的原型上。\n * 在子类的原型上添加子类额外的实例方法和实例属性。\n\n\n# 任务链\n\n在 axios 中，将 request 拦截器、dispatchRequest (发送请求)、response 拦截器按照 FIFO（先进先出，队列顺序）构成任务链，并且根据任务的同步或者异步，区分为同步任务链和异步任务链来进行处理。这种处理方法，对于程序的可扩展性、灵活性有很大的益处，可谓是眼睛一亮。\n\n事实上，在很多其他类型需要对每个行为进行横向扩展，如拦截、代理、任务链、过滤的情境中，都可以参考这种思想。同时这种链式处理思想在责任链设计模式、代理模式中都或多或少的有所体现，在 single-spa 等源码中也能看到类似的使用方法。另外在 transformData 中也体现了这种思想：\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Number} status HTTP status code\n * @param {Array|Function} fns A single function or Array of functions\n *\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, status, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(context, data, headers, status);\n  });\n\n  return data;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n下面我们来着重看下 Axios.prototype.request 方法的代码：\n\n/**\n * Dispatch a request\n *\n * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n * @param {?Object} config\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nAxios.prototype.request = function request(configOrUrl, config) {\n  // ......\n  config = mergeConfig(this.defaults, config);\n  // ......\n\n  // filter out skipped interceptors\n  var requestInterceptorChain = [];\n  var synchronousRequestInterceptors = true;\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    if (typeof interceptor.runWhen === \'function\' && interceptor.runWhen(config) === false) {\n      return;\n    }\n\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var responseInterceptorChain = [];\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var promise;\n\n  if (!synchronousRequestInterceptors) {\n    var chain = [dispatchRequest, undefined];\n\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\n    chain = chain.concat(responseInterceptorChain);\n\n    promise = Promise.resolve(config);\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n\n  var newConfig = config;\n  while (requestInterceptorChain.length) {\n    var onFulfilled = requestInterceptorChain.shift();\n    var onRejected = requestInterceptorChain.shift();\n    try {\n      newConfig = onFulfilled(newConfig);\n    } catch (error) {\n      onRejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchRequest(newConfig);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  while (responseInterceptorChain.length) {\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n  }\n\n  return promise;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n这里有一下几点技巧值得我们注意：\n\n 1. 任务 request 都需要经过 interceptors.request 、 dispatchRequest 和 interceptors.response 的链式处理，根据 interceptors.request 是否有异步的拦截器，可以将其同步执行或者异步执行。\n 2. 以异步执行为例，整个 chain 中的结构为 requestInterceptorChain + [dispatchRequest, undefined] + responseInterceptorChain ，每个 interceptorChain 中包含 onFulfilled 和 onRejected ，分别用于当前拦截器处理成功的回调和失败的回调。那个为什么 dispatchRequest 后面要加一个 undefined 呢？这是因为 chain 中每次出队列都是两个，因此整个队列在 promise 的驱动下才得以运行。\n 3. Array 的 push、concat、splice、unshift 方法支持传入多个 item 的用法。可以看下如下的类型：\n\ninterface Array<T> {\n  push(...items: T[]): number;\n  concat(...items: ConcatArray<T>[]): T[];\n  concat(...items: (T | ConcatArray<T>)[]): T[];\n  splice(start: number, deleteCount: number, ...items: T[]): T[];\n  unshift(...items: T[]): number;\n  // ......\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# dispatchRequest\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n //  ......\n // Transform request data\n // 利用 transformRequest 对 data 经过处理\n config.data = transformData.call(\n  config,\n  config.data,\n  config.headers,\n  null,\n  config.transformRequest\n );\n // ......\n\n utils.forEach(\n  ["delete", "get", "head", "post", "put", "patch", "common"],\n  function cleanHeaderConfig(method) {\n   delete config.headers[method];\n  }\n );\n\n var adapter = config.adapter || defaults.adapter;\n\n return adapter(config).then(\n  function onAdapterResolution(response) {\n   throwIfCancellationRequested(config);\n\n   // Transform response data\n   response.data = transformData.call(\n    config,\n    response.data,\n    response.headers,\n    response.status,\n    config.transformResponse\n   );\n\n   return response;\n  },\n  function onAdapterRejection(reason) {\n   if (!isCancel(reason)) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    if (reason && reason.response) {\n     reason.response.data = transformData.call(\n      config,\n      reason.response.data,\n      reason.response.headers,\n      reason.response.status,\n      config.transformResponse\n     );\n    }\n   }\n\n   return Promise.reject(reason);\n  }\n );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n这里有几点需要注意：\n\n * 2 个 transformer: transformRequest 和 transformResponse 的 transformer 管道。\n * adapter：发送请求的适配器。因为 axios 要适配各种 runtime，如 web 环境和 Node 环境，并且掩盖各种浏览器的关于发送请求得差异，因此采用适配器来处理请求发送。除此之外，这么做还有另一个好处，那就是提供用于自定义 adapter 的能力，帮助开发者是够适配各种非内置的运行环境中的请求发送的需求。',normalizedContent:'# axios 对象\n\naxios 对象通过 es5 语法构建。\n\nfunction axios(instanceconfig) {\n  this.defaults = instanceconfig;\n  this.interceptors = {\n    request: new interceptormanager(),\n    response: new interceptormanager()\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n从 oop 的角度看，和 es6 语法相比，类的构造器、实例方法、静态方法写法不同，可以作如下对比：\n\n            es6               es5\n构造器         constructor 函数    函数体\n调用福构造器      super()           superclass.call(this)\n静态方法、静态属性   static property   class.property\n实例方法、实例属性   this.property     class.prototype.property\n实例化         new class()       new class()\nthis        指向实例              指向实例\n继承          extends 关键字       原型继承\n\nes5 中类的继承：\n\n/** inherit the prototype methods from one constructor into another */\nfunction inherits(constructor, superconstructor, props, descriptors) {\n  constructor.prototype = object.create(superconstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  props && object.assign(constructor.prototype, props);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n如何使用 es5 语法继承父类？\n\n * 根据父类的原型创建一个原型，并作为子类的原型。\n * 将子类的构造器添加到子类的原型上。\n * 在子类的原型上添加子类额外的实例方法和实例属性。\n\n\n# 任务链\n\n在 axios 中，将 request 拦截器、dispatchrequest (发送请求)、response 拦截器按照 fifo（先进先出，队列顺序）构成任务链，并且根据任务的同步或者异步，区分为同步任务链和异步任务链来进行处理。这种处理方法，对于程序的可扩展性、灵活性有很大的益处，可谓是眼睛一亮。\n\n事实上，在很多其他类型需要对每个行为进行横向扩展，如拦截、代理、任务链、过滤的情境中，都可以参考这种思想。同时这种链式处理思想在责任链设计模式、代理模式中都或多或少的有所体现，在 single-spa 等源码中也能看到类似的使用方法。另外在 transformdata 中也体现了这种思想：\n\n/**\n * transform the data for a request or a response\n *\n * @param {object|string} data the data to be transformed\n * @param {array} headers the headers for the request or response\n * @param {number} status http status code\n * @param {array|function} fns a single function or array of functions\n *\n * @returns {*} the resulting transformed data\n */\nmodule.exports = function transformdata(data, headers, status, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n  utils.foreach(fns, function transform(fn) {\n    data = fn.call(context, data, headers, status);\n  });\n\n  return data;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n下面我们来着重看下 axios.prototype.request 方法的代码：\n\n/**\n * dispatch a request\n *\n * @param {string|object} configorurl the config specific for this request (merged with this.defaults)\n * @param {?object} config\n *\n * @returns {promise} the promise to be fulfilled\n */\naxios.prototype.request = function request(configorurl, config) {\n  // ......\n  config = mergeconfig(this.defaults, config);\n  // ......\n\n  // filter out skipped interceptors\n  var requestinterceptorchain = [];\n  var synchronousrequestinterceptors = true;\n  this.interceptors.request.foreach(function unshiftrequestinterceptors(interceptor) {\n    if (typeof interceptor.runwhen === \'function\' && interceptor.runwhen(config) === false) {\n      return;\n    }\n\n    synchronousrequestinterceptors = synchronousrequestinterceptors && interceptor.synchronous;\n\n    requestinterceptorchain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var responseinterceptorchain = [];\n  this.interceptors.response.foreach(function pushresponseinterceptors(interceptor) {\n    responseinterceptorchain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var promise;\n\n  if (!synchronousrequestinterceptors) {\n    var chain = [dispatchrequest, undefined];\n\n    array.prototype.unshift.apply(chain, requestinterceptorchain);\n    chain = chain.concat(responseinterceptorchain);\n\n    promise = promise.resolve(config);\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n\n  var newconfig = config;\n  while (requestinterceptorchain.length) {\n    var onfulfilled = requestinterceptorchain.shift();\n    var onrejected = requestinterceptorchain.shift();\n    try {\n      newconfig = onfulfilled(newconfig);\n    } catch (error) {\n      onrejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchrequest(newconfig);\n  } catch (error) {\n    return promise.reject(error);\n  }\n\n  while (responseinterceptorchain.length) {\n    promise = promise.then(responseinterceptorchain.shift(), responseinterceptorchain.shift());\n  }\n\n  return promise;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n这里有一下几点技巧值得我们注意：\n\n 1. 任务 request 都需要经过 interceptors.request 、 dispatchrequest 和 interceptors.response 的链式处理，根据 interceptors.request 是否有异步的拦截器，可以将其同步执行或者异步执行。\n 2. 以异步执行为例，整个 chain 中的结构为 requestinterceptorchain + [dispatchrequest, undefined] + responseinterceptorchain ，每个 interceptorchain 中包含 onfulfilled 和 onrejected ，分别用于当前拦截器处理成功的回调和失败的回调。那个为什么 dispatchrequest 后面要加一个 undefined 呢？这是因为 chain 中每次出队列都是两个，因此整个队列在 promise 的驱动下才得以运行。\n 3. array 的 push、concat、splice、unshift 方法支持传入多个 item 的用法。可以看下如下的类型：\n\ninterface array<t> {\n  push(...items: t[]): number;\n  concat(...items: concatarray<t>[]): t[];\n  concat(...items: (t | concatarray<t>)[]): t[];\n  splice(start: number, deletecount: number, ...items: t[]): t[];\n  unshift(...items: t[]): number;\n  // ......\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# dispatchrequest\n\n/**\n * dispatch a request to the server using the configured adapter.\n *\n * @param {object} config the config that is to be used for the request\n *\n * @returns {promise} the promise to be fulfilled\n */\nmodule.exports = function dispatchrequest(config) {\n //  ......\n // transform request data\n // 利用 transformrequest 对 data 经过处理\n config.data = transformdata.call(\n  config,\n  config.data,\n  config.headers,\n  null,\n  config.transformrequest\n );\n // ......\n\n utils.foreach(\n  ["delete", "get", "head", "post", "put", "patch", "common"],\n  function cleanheaderconfig(method) {\n   delete config.headers[method];\n  }\n );\n\n var adapter = config.adapter || defaults.adapter;\n\n return adapter(config).then(\n  function onadapterresolution(response) {\n   throwifcancellationrequested(config);\n\n   // transform response data\n   response.data = transformdata.call(\n    config,\n    response.data,\n    response.headers,\n    response.status,\n    config.transformresponse\n   );\n\n   return response;\n  },\n  function onadapterrejection(reason) {\n   if (!iscancel(reason)) {\n    throwifcancellationrequested(config);\n\n    // transform response data\n    if (reason && reason.response) {\n     reason.response.data = transformdata.call(\n      config,\n      reason.response.data,\n      reason.response.headers,\n      reason.response.status,\n      config.transformresponse\n     );\n    }\n   }\n\n   return promise.reject(reason);\n  }\n );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n这里有几点需要注意：\n\n * 2 个 transformer: transformrequest 和 transformresponse 的 transformer 管道。\n * adapter：发送请求的适配器。因为 axios 要适配各种 runtime，如 web 环境和 node 环境，并且掩盖各种浏览器的关于发送请求得差异，因此采用适配器来处理请求发送。除此之外，这么做还有另一个好处，那就是提供用于自定义 adapter 的能力，帮助开发者是够适配各种非内置的运行环境中的请求发送的需求。',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"interceptor 拦截器",frontmatter:{title:"interceptor 拦截器",date:"2022-06-26T09:56:25.000Z",permalink:"/axios/core/interceptor/",categories:["web","axios","core"],tags:[null]},regularPath:"/30.web/8.axios/10.core/30.interceptor.html",relativePath:"30.web/8.axios/10.core/30.interceptor.md",key:"v-498b6e86",path:"/axios/core/interceptor/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"adapter 适配器",frontmatter:{title:"adapter 适配器",date:"2022-06-26T09:52:24.000Z",permalink:"/axios/core/adapter/",categories:["web","axios","core"],tags:[null]},regularPath:"/30.web/8.axios/10.core/20.adapter.html",relativePath:"30.web/8.axios/10.core/20.adapter.md",key:"v-c9eede46",path:"/axios/core/adapter/",headers:[{level:2,title:"getDefaultAdapter",slug:"getdefaultadapter",normalizedTitle:"getdefaultadapter",charIndex:2},{level:2,title:"XHR Adapter",slug:"xhr-adapter",normalizedTitle:"xhr adapter",charIndex:721},{level:2,title:"HTTP Adapter",slug:"http-adapter",normalizedTitle:"http adapter",charIndex:9408}],readingTime:{text:"5 min read",minutes:4.81,time:288599.99999999994,words:962},headersStr:"getDefaultAdapter XHR Adapter HTTP Adapter",content:'# getDefaultAdapter\n\naxios 如何根据运行环境先选择默认的 adapter 呢？\n\n/**\n * If the browser has an XMLHttpRequest object, use the XHR adapter, otherwise use the HTTP\n * adapter\n *\n * @returns {Function}\n */\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== \'undefined\') {\n    // For browsers use XHR adapter\n    adapter = require(\'../adapters/xhr\');\n  } else if (typeof process !== \'undefined\' && Object.prototype.toString.call(process) === \'[object process]\') {\n    // For node use HTTP adapter\n    adapter = require(\'../adapters/http\');\n  }\n  return adapter;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 如果支持 XMLHttpRequest，就是用 XHR。\n * 不支持 XHR 则使用 nodeJS 的 HTTP 模块。\n * 这两种方式分别用于 web 环境和 nodejs 环境。\n\n\n# XHR Adapter\n\nXHR Adapter 用于 web 环境。\n\nfunction xhrAdapter(config) {\n return new Promise(function dispatchXhrRequest(resolve, reject) {\n  var requestData = config.data;\n  var requestHeaders = config.headers;\n  var responseType = config.responseType;\n  var onCanceled;\n  // 删除取消请求的订阅，cancelToken或者signal是两种取消请求的方式\n  function done() {\n   if (config.cancelToken) {\n    config.cancelToken.unsubscribe(onCanceled);\n   }\n\n   if (config.signal) {\n    config.signal.removeEventListener("abort", onCanceled);\n   }\n  }\n\n  if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {\n   delete requestHeaders["Content-Type"]; // Let the browser set it\n  }\n\n  var request = new XMLHttpRequest();\n\n  // HTTP basic authentication\n  if (config.auth) {\n   var username = config.auth.username || "";\n   var password = config.auth.password\n    ? unescape(encodeURIComponent(config.auth.password))\n    : "";\n   requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);\n  }\n\n  var fullPath = buildFullPath(config.baseURL, config.url);\n\n  request.open(\n   config.method.toUpperCase(),\n   buildURL(fullPath, config.params, config.paramsSerializer),\n   true\n  );\n\n  // Set the request timeout in MS\n  request.timeout = config.timeout;\n\n  function onloadend() {\n   if (!request) {\n    return;\n   }\n   // Prepare the response\n   var responseHeaders =\n    "getAllResponseHeaders" in request\n     ? parseHeaders(request.getAllResponseHeaders())\n     : null;\n   var responseData =\n    !responseType || responseType === "text" || responseType === "json"\n     ? request.responseText\n     : request.response;\n   var response = {\n    data: responseData,\n    status: request.status,\n    statusText: request.statusText,\n    headers: responseHeaders,\n    config: config,\n    request: request,\n   };\n\n   settle(\n    function _resolve(value) {\n     resolve(value);\n     done();\n    },\n    function _reject(err) {\n     reject(err);\n     done();\n    },\n    response\n   );\n\n   // Clean up request\n   request = null;\n  }\n\n  if ("onloadend" in request) {\n   // Use onloadend if available\n   request.onloadend = onloadend;\n  } else {\n   // Listen for ready state to emulate onloadend\n   request.onreadystatechange = function handleLoad() {\n    if (!request || request.readyState !== 4) {\n     return;\n    }\n\n    // The request errored out and we didn\'t get a response, this will be\n    // handled by onerror instead\n    // With one exception: request that using file: protocol, most browsers\n    // will return status as 0 even though it\'s a successful request\n    if (\n     request.status === 0 &&\n     !(request.responseURL && request.responseURL.indexOf("file:") === 0)\n    ) {\n     return;\n    }\n    // readystate handler is calling before onerror or ontimeout handlers,\n    // so we should call onloadend on the next \'tick\'\n    setTimeout(onloadend);\n   };\n  }\n\n  // Handle browser request cancellation (as opposed to a manual cancellation)\n  request.onabort = function handleAbort() {\n   if (!request) {\n    return;\n   }\n\n   reject(\n    new AxiosError(\n     "Request aborted",\n     AxiosError.ECONNABORTED,\n     config,\n     request\n    )\n   );\n\n   // Clean up request\n   request = null;\n  };\n\n  // Handle low level network errors\n  request.onerror = function handleError() {\n   // Real errors are hidden from us by the browser\n   // onerror should only fire if it\'s a network error\n   reject(\n    new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request)\n   );\n\n   // Clean up request\n   request = null;\n  };\n\n  // Handle timeout\n  request.ontimeout = function handleTimeout() {\n   var timeoutErrorMessage = config.timeout\n    ? "timeout of " + config.timeout + "ms exceeded"\n    : "timeout exceeded";\n   var transitional = config.transitional || transitionalDefaults;\n   if (config.timeoutErrorMessage) {\n    timeoutErrorMessage = config.timeoutErrorMessage;\n   }\n   reject(\n    new AxiosError(\n     timeoutErrorMessage,\n     transitional.clarifyTimeoutError\n      ? AxiosError.ETIMEDOUT\n      : AxiosError.ECONNABORTED,\n     config,\n     request\n    )\n   );\n\n   // Clean up request\n   request = null;\n  };\n\n  // Add xsrf header\n  // This is only done if running in a standard browser environment.\n  // Specifically not if we\'re in a web worker, or react-native.\n  if (utils.isStandardBrowserEnv()) {\n   // Add xsrf header\n   var xsrfValue =\n    (config.withCredentials || isURLSameOrigin(fullPath)) &&\n    config.xsrfCookieName\n     ? cookies.read(config.xsrfCookieName)\n     : undefined;\n\n   if (xsrfValue) {\n    requestHeaders[config.xsrfHeaderName] = xsrfValue;\n   }\n  }\n\n  // Add headers to the request\n  if ("setRequestHeader" in request) {\n   utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n    if (\n     typeof requestData === "undefined" &&\n     key.toLowerCase() === "content-type"\n    ) {\n     // Remove Content-Type if data is undefined\n     delete requestHeaders[key];\n    } else {\n     // Otherwise add header to the request\n     request.setRequestHeader(key, val);\n    }\n   });\n  }\n\n  // Add withCredentials to request if needed\n  if (!utils.isUndefined(config.withCredentials)) {\n   request.withCredentials = !!config.withCredentials;\n  }\n\n  // Add responseType to request if needed\n  if (responseType && responseType !== "json") {\n   request.responseType = config.responseType;\n  }\n\n  // Handle progress if needed\n  if (typeof config.onDownloadProgress === "function") {\n   request.addEventListener("progress", config.onDownloadProgress);\n  }\n\n  // Not all browsers support upload events\n  if (typeof config.onUploadProgress === "function" && request.upload) {\n   request.upload.addEventListener("progress", config.onUploadProgress);\n  }\n\n  if (config.cancelToken || config.signal) {\n   // Handle cancellation\n   // eslint-disable-next-line func-names\n   onCanceled = function (cancel) {\n    if (!request) {\n     return;\n    }\n    reject(\n     !cancel || cancel.type ? new CanceledError(null, config, req) : cancel\n    );\n    request.abort();\n    request = null;\n   };\n\n   config.cancelToken && config.cancelToken.subscribe(onCanceled);\n   if (config.signal) {\n    config.signal.aborted\n     ? onCanceled()\n     : config.signal.addEventListener("abort", onCanceled);\n   }\n  }\n\n  if (!requestData) {\n   requestData = null;\n  }\n\n  var protocol = parseProtocol(fullPath);\n\n  if (protocol && platform.protocols.indexOf(protocol) === -1) {\n   reject(\n    new AxiosError(\n     "Unsupported protocol " + protocol + ":",\n     AxiosError.ERR_BAD_REQUEST,\n     config\n    )\n   );\n   return;\n  }\n\n  // Send the request\n  request.send(requestData);\n });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n\n\nxhrAdapter 的处理过程如下：\n\n 1.  创建 XMLHttpRequest 。\n 2.  根据 auth 配置添加 Authorization header。\n 3.  计算发送请求的 url。\n 4.  request.open 配置请求。\n 5.  设置 request.timeout 。\n 6.  注册 onloadend 事件，支持 request.onloadend 则使用 request.onloadend ，使用使用 request.onreadystatechange 监听 request.readyState 为 4。\n 7.  注册 request.onabort 事件，抛出 Request aborted 消息的 AxiosError 。\n 8.  注册 request.onerror 事件，抛出 Network Error 消息的 AxiosError 。\n 9.  注册 request.ontimeout 事件，抛出 timeout exceeded 消息的 AxiosError 。\n 10. 在 web 环境中，如果配置了 xsrfCookieName，则将 xsrfCookieName 设置在 header 上作为预防 xsrf 攻击的 token。\n 11. 处理请求的 headers。\n 12. 处理 request.withCredentials 、 request.responseType 。\n 13. 如果配置了 onDownloadProgress ，则在 request 上监听 progress 事件。\n 14. 如果配置了 cancelToken 或者 signal ，前者在 cancelToken 上订阅 onCanceled ，后者监听 signal 的 abort 事件，触发 onCanceled 回调。 onCanceled 中抛出 CanceledError 错误，并且 request.abort 。\n 15. 检查是否是支持的协议 protocol ，否则抛出 Unsupported protocol 错误的 AxiosError。\n 16. 发送请求 request.send(requestData) 。\n 17. 请求发出后， onloadend 处理 response 对象。通过验证 status 即 validateStatus resolve response 或者 reject 一个 Request failed AxiosError。validateStatus 默认的校验规则是 status >= 200 && status < 300 。\n 18. onloadend 之后调用 done ，做 cleanup 的工作。\n\n\n# HTTP Adapter\n\nHTTP Adapter 用于 NodeJS 环境。',normalizedContent:'# getdefaultadapter\n\naxios 如何根据运行环境先选择默认的 adapter 呢？\n\n/**\n * if the browser has an xmlhttprequest object, use the xhr adapter, otherwise use the http\n * adapter\n *\n * @returns {function}\n */\nfunction getdefaultadapter() {\n  var adapter;\n  if (typeof xmlhttprequest !== \'undefined\') {\n    // for browsers use xhr adapter\n    adapter = require(\'../adapters/xhr\');\n  } else if (typeof process !== \'undefined\' && object.prototype.tostring.call(process) === \'[object process]\') {\n    // for node use http adapter\n    adapter = require(\'../adapters/http\');\n  }\n  return adapter;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 如果支持 xmlhttprequest，就是用 xhr。\n * 不支持 xhr 则使用 nodejs 的 http 模块。\n * 这两种方式分别用于 web 环境和 nodejs 环境。\n\n\n# xhr adapter\n\nxhr adapter 用于 web 环境。\n\nfunction xhradapter(config) {\n return new promise(function dispatchxhrrequest(resolve, reject) {\n  var requestdata = config.data;\n  var requestheaders = config.headers;\n  var responsetype = config.responsetype;\n  var oncanceled;\n  // 删除取消请求的订阅，canceltoken或者signal是两种取消请求的方式\n  function done() {\n   if (config.canceltoken) {\n    config.canceltoken.unsubscribe(oncanceled);\n   }\n\n   if (config.signal) {\n    config.signal.removeeventlistener("abort", oncanceled);\n   }\n  }\n\n  if (utils.isformdata(requestdata) && utils.isstandardbrowserenv()) {\n   delete requestheaders["content-type"]; // let the browser set it\n  }\n\n  var request = new xmlhttprequest();\n\n  // http basic authentication\n  if (config.auth) {\n   var username = config.auth.username || "";\n   var password = config.auth.password\n    ? unescape(encodeuricomponent(config.auth.password))\n    : "";\n   requestheaders.authorization = "basic " + btoa(username + ":" + password);\n  }\n\n  var fullpath = buildfullpath(config.baseurl, config.url);\n\n  request.open(\n   config.method.touppercase(),\n   buildurl(fullpath, config.params, config.paramsserializer),\n   true\n  );\n\n  // set the request timeout in ms\n  request.timeout = config.timeout;\n\n  function onloadend() {\n   if (!request) {\n    return;\n   }\n   // prepare the response\n   var responseheaders =\n    "getallresponseheaders" in request\n     ? parseheaders(request.getallresponseheaders())\n     : null;\n   var responsedata =\n    !responsetype || responsetype === "text" || responsetype === "json"\n     ? request.responsetext\n     : request.response;\n   var response = {\n    data: responsedata,\n    status: request.status,\n    statustext: request.statustext,\n    headers: responseheaders,\n    config: config,\n    request: request,\n   };\n\n   settle(\n    function _resolve(value) {\n     resolve(value);\n     done();\n    },\n    function _reject(err) {\n     reject(err);\n     done();\n    },\n    response\n   );\n\n   // clean up request\n   request = null;\n  }\n\n  if ("onloadend" in request) {\n   // use onloadend if available\n   request.onloadend = onloadend;\n  } else {\n   // listen for ready state to emulate onloadend\n   request.onreadystatechange = function handleload() {\n    if (!request || request.readystate !== 4) {\n     return;\n    }\n\n    // the request errored out and we didn\'t get a response, this will be\n    // handled by onerror instead\n    // with one exception: request that using file: protocol, most browsers\n    // will return status as 0 even though it\'s a successful request\n    if (\n     request.status === 0 &&\n     !(request.responseurl && request.responseurl.indexof("file:") === 0)\n    ) {\n     return;\n    }\n    // readystate handler is calling before onerror or ontimeout handlers,\n    // so we should call onloadend on the next \'tick\'\n    settimeout(onloadend);\n   };\n  }\n\n  // handle browser request cancellation (as opposed to a manual cancellation)\n  request.onabort = function handleabort() {\n   if (!request) {\n    return;\n   }\n\n   reject(\n    new axioserror(\n     "request aborted",\n     axioserror.econnaborted,\n     config,\n     request\n    )\n   );\n\n   // clean up request\n   request = null;\n  };\n\n  // handle low level network errors\n  request.onerror = function handleerror() {\n   // real errors are hidden from us by the browser\n   // onerror should only fire if it\'s a network error\n   reject(\n    new axioserror("network error", axioserror.err_network, config, request)\n   );\n\n   // clean up request\n   request = null;\n  };\n\n  // handle timeout\n  request.ontimeout = function handletimeout() {\n   var timeouterrormessage = config.timeout\n    ? "timeout of " + config.timeout + "ms exceeded"\n    : "timeout exceeded";\n   var transitional = config.transitional || transitionaldefaults;\n   if (config.timeouterrormessage) {\n    timeouterrormessage = config.timeouterrormessage;\n   }\n   reject(\n    new axioserror(\n     timeouterrormessage,\n     transitional.clarifytimeouterror\n      ? axioserror.etimedout\n      : axioserror.econnaborted,\n     config,\n     request\n    )\n   );\n\n   // clean up request\n   request = null;\n  };\n\n  // add xsrf header\n  // this is only done if running in a standard browser environment.\n  // specifically not if we\'re in a web worker, or react-native.\n  if (utils.isstandardbrowserenv()) {\n   // add xsrf header\n   var xsrfvalue =\n    (config.withcredentials || isurlsameorigin(fullpath)) &&\n    config.xsrfcookiename\n     ? cookies.read(config.xsrfcookiename)\n     : undefined;\n\n   if (xsrfvalue) {\n    requestheaders[config.xsrfheadername] = xsrfvalue;\n   }\n  }\n\n  // add headers to the request\n  if ("setrequestheader" in request) {\n   utils.foreach(requestheaders, function setrequestheader(val, key) {\n    if (\n     typeof requestdata === "undefined" &&\n     key.tolowercase() === "content-type"\n    ) {\n     // remove content-type if data is undefined\n     delete requestheaders[key];\n    } else {\n     // otherwise add header to the request\n     request.setrequestheader(key, val);\n    }\n   });\n  }\n\n  // add withcredentials to request if needed\n  if (!utils.isundefined(config.withcredentials)) {\n   request.withcredentials = !!config.withcredentials;\n  }\n\n  // add responsetype to request if needed\n  if (responsetype && responsetype !== "json") {\n   request.responsetype = config.responsetype;\n  }\n\n  // handle progress if needed\n  if (typeof config.ondownloadprogress === "function") {\n   request.addeventlistener("progress", config.ondownloadprogress);\n  }\n\n  // not all browsers support upload events\n  if (typeof config.onuploadprogress === "function" && request.upload) {\n   request.upload.addeventlistener("progress", config.onuploadprogress);\n  }\n\n  if (config.canceltoken || config.signal) {\n   // handle cancellation\n   // eslint-disable-next-line func-names\n   oncanceled = function (cancel) {\n    if (!request) {\n     return;\n    }\n    reject(\n     !cancel || cancel.type ? new cancelederror(null, config, req) : cancel\n    );\n    request.abort();\n    request = null;\n   };\n\n   config.canceltoken && config.canceltoken.subscribe(oncanceled);\n   if (config.signal) {\n    config.signal.aborted\n     ? oncanceled()\n     : config.signal.addeventlistener("abort", oncanceled);\n   }\n  }\n\n  if (!requestdata) {\n   requestdata = null;\n  }\n\n  var protocol = parseprotocol(fullpath);\n\n  if (protocol && platform.protocols.indexof(protocol) === -1) {\n   reject(\n    new axioserror(\n     "unsupported protocol " + protocol + ":",\n     axioserror.err_bad_request,\n     config\n    )\n   );\n   return;\n  }\n\n  // send the request\n  request.send(requestdata);\n });\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n\n\nxhradapter 的处理过程如下：\n\n 1.  创建 xmlhttprequest 。\n 2.  根据 auth 配置添加 authorization header。\n 3.  计算发送请求的 url。\n 4.  request.open 配置请求。\n 5.  设置 request.timeout 。\n 6.  注册 onloadend 事件，支持 request.onloadend 则使用 request.onloadend ，使用使用 request.onreadystatechange 监听 request.readystate 为 4。\n 7.  注册 request.onabort 事件，抛出 request aborted 消息的 axioserror 。\n 8.  注册 request.onerror 事件，抛出 network error 消息的 axioserror 。\n 9.  注册 request.ontimeout 事件，抛出 timeout exceeded 消息的 axioserror 。\n 10. 在 web 环境中，如果配置了 xsrfcookiename，则将 xsrfcookiename 设置在 header 上作为预防 xsrf 攻击的 token。\n 11. 处理请求的 headers。\n 12. 处理 request.withcredentials 、 request.responsetype 。\n 13. 如果配置了 ondownloadprogress ，则在 request 上监听 progress 事件。\n 14. 如果配置了 canceltoken 或者 signal ，前者在 canceltoken 上订阅 oncanceled ，后者监听 signal 的 abort 事件，触发 oncanceled 回调。 oncanceled 中抛出 cancelederror 错误，并且 request.abort 。\n 15. 检查是否是支持的协议 protocol ，否则抛出 unsupported protocol 错误的 axioserror。\n 16. 发送请求 request.send(requestdata) 。\n 17. 请求发出后， onloadend 处理 response 对象。通过验证 status 即 validatestatus resolve response 或者 reject 一个 request failed axioserror。validatestatus 默认的校验规则是 status >= 200 && status < 300 。\n 18. onloadend 之后调用 done ，做 cleanup 的工作。\n\n\n# http adapter\n\nhttp adapter 用于 nodejs 环境。',charsets:{cjk:!0},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"cancel 取消请求",frontmatter:{title:"cancel 取消请求",date:"2022-06-26T09:57:04.000Z",permalink:"/axios/core/cancel/",categories:["web","axios","core"],tags:[null]},regularPath:"/30.web/8.axios/10.core/40.cancel.html",relativePath:"30.web/8.axios/10.core/40.cancel.md",key:"v-3fcd21c9",path:"/axios/core/cancel/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"开始阅读",frontmatter:{title:"开始阅读",date:"2022-04-14T22:02:20.000Z",permalink:"/pages/b58110/",categories:["html2canvas"],tags:[null]},regularPath:"/30.web/80.html2canvas/0.index.html",relativePath:"30.web/80.html2canvas/0.index.md",key:"v-3552c17d",path:"/pages/b58110/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-09-06T14:04:50.000Z",permalink:"/solid/index/",categories:["web","solid"],tags:[null]},regularPath:"/30.web/9.solid/0.index.html",relativePath:"30.web/9.solid/0.index.md",key:"v-dca0dbea",path:"/solid/index/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"什么是 solidjs",slug:"什么是-solidjs",normalizedTitle:"什么是 solidjs",charIndex:17},{level:3,title:"特点",slug:"特点",normalizedTitle:"特点",charIndex:34},{level:3,title:"它既让你感到熟悉又现代",slug:"它既让你感到熟悉又现代",normalizedTitle:"它既让你感到熟悉又现代",charIndex:42},{level:3,title:"满载所有功能",slug:"满载所有功能",normalizedTitle:"满载所有功能",charIndex:59},{level:3,title:"细粒度的响应性意味着你可以事半功倍",slug:"细粒度的响应性意味着你可以事半功倍",normalizedTitle:"细粒度的响应性意味着你可以事半功倍",charIndex:71},{level:3,title:"专注于性能: 无论是客户端还是服务端",slug:"专注于性能-无论是客户端还是服务端",normalizedTitle:"专注于性能：无论是客户端还是服务端",charIndex:866},{level:2,title:"Solid 理念",slug:"solid-理念",normalizedTitle:"solid 理念",charIndex:116},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:128}],readingTime:{text:"1 min read",minutes:.605,time:36300,words:121},headersStr:"目录 什么是 solidjs 特点 它既让你感到熟悉又现代 满载所有功能 细粒度的响应性意味着你可以事半功倍 专注于性能: 无论是客户端还是服务端 Solid 理念 参考",content:"# 目录\n\n\n\n * 目录\n * 什么是 solidjs\n   * 特点\n   * 它既让你感到熟悉又现代\n   * 满载所有功能\n   * 细粒度的响应性意味着你可以事半功倍\n   * 专注于性能: 无论是客户端还是服务端\n * Solid 理念\n * 参考\n\n\n\n\n# 什么是 solidjs\n\n一个用于构建用户界面，简单高效、性能卓越的 JavaScript 库。\n\n\n# 特点\n\n * 性能：始终在 UI 速度和内存利用率基准测试中名列前茅。\n * 强大：可组合的响应式原语与 JSX 的灵活性相结合。\n * 实用：合理且量身定制的 API 使开发变得有趣而简单。\n * 生产力：人体工程化设计和熟悉程度使得构建简单或复杂的东西变得轻而易举。\n\n\n# 它既让你感到熟悉又现代\n\nSolid 站在 React, Knockout 等巨人的肩膀上。如果你之前用 React Hooks 开发过，Solid 应该看起来很自然。事实上，Solid 模型更简单，没有 Hook 规则。每个组件执行一次，随着依赖项的更新，钩子和绑定会多次执行。\n\nSolid 遵循与 React 相同的理念，具有单向数据流、读 / 写隔离和不可变接口。但是放弃了使用虚拟 DOM，使用了完全不同的实现。\n\n\n# 满载所有功能\n\nSolid 支持所有常见的和预期的库功能，并在各个方面进行扩展以增强开发体验。\n\n * Fragments\n * Portals\n * Context\n * Suspense\n * 错误边界\n * 组件懒加载\n * 异步和并发渲染\n * 隐式事件委托\n * 服务端渲染和注水\n * 指令\n * Streaming\n\n\n# 细粒度的响应性意味着你可以事半功倍\n\nSolid 的每个部分都建立在 JSX 视图中 JavaScript 表达式的简单 primitive 之上。\n\nSolid 解锁了对更新内容和时间的完全控制，即使在 DOM 绑定级别也是如此。没有虚拟 DOM 或广泛的差异对比，框架永远不会做额外工作。\n\n\n# 专注于性能：无论是客户端还是服务端\n\n细粒度响应式这一策略在所有显眼的基准测试中大放异彩。虽然性能可能不是你的关注点，但最终会影响到用户体验。Solid 无需额外的开发复杂度就可以获得很好的性能。就是说无需特意调优就可以运行很快。\n\n\n# Solid 理念\n\nSolid 的设计提出了一些可以帮助我们最好地构建网站和应用程序的原则和价值观。当你了解 Solid 背后的哲学时，学习和使用 Solid 会更容易。\n\n * 声明式数据 ：声明式数据是将数据行为的描述与其声明联系起来的实践。这允许我们通过将数据行为的所有方面打包在一个地方来轻松组合。\n\n * 消失的组件 ：在不考虑更新的情况下构建组件已经够难的了。Solid 的组件更新是彼此完全独立的。组件函数被调用一次，然后就不再存在。组件的存在是为了组织你的代码，而不是其他。\n\n * 读/写 分离 ：精确的控制和可预测性有助于打造更好的系统。我们不需要真正的不变性来强制执行单向数据流，只需要能够有意识到哪些消费者可能会写，哪些可能不会。\n\n * 简单胜于容易 ：细粒度响应性教会我们：明确且一致的约定即使需要更多努力也是值得的。且有必要提供最少的工具作为构建的基础。\n\n\n# 参考\n\n * SolidJS · Reactive Javascript Library\n * SolidJS・反应式 JavaScript 库",normalizedContent:"# 目录\n\n\n\n * 目录\n * 什么是 solidjs\n   * 特点\n   * 它既让你感到熟悉又现代\n   * 满载所有功能\n   * 细粒度的响应性意味着你可以事半功倍\n   * 专注于性能: 无论是客户端还是服务端\n * solid 理念\n * 参考\n\n\n\n\n# 什么是 solidjs\n\n一个用于构建用户界面，简单高效、性能卓越的 javascript 库。\n\n\n# 特点\n\n * 性能：始终在 ui 速度和内存利用率基准测试中名列前茅。\n * 强大：可组合的响应式原语与 jsx 的灵活性相结合。\n * 实用：合理且量身定制的 api 使开发变得有趣而简单。\n * 生产力：人体工程化设计和熟悉程度使得构建简单或复杂的东西变得轻而易举。\n\n\n# 它既让你感到熟悉又现代\n\nsolid 站在 react, knockout 等巨人的肩膀上。如果你之前用 react hooks 开发过，solid 应该看起来很自然。事实上，solid 模型更简单，没有 hook 规则。每个组件执行一次，随着依赖项的更新，钩子和绑定会多次执行。\n\nsolid 遵循与 react 相同的理念，具有单向数据流、读 / 写隔离和不可变接口。但是放弃了使用虚拟 dom，使用了完全不同的实现。\n\n\n# 满载所有功能\n\nsolid 支持所有常见的和预期的库功能，并在各个方面进行扩展以增强开发体验。\n\n * fragments\n * portals\n * context\n * suspense\n * 错误边界\n * 组件懒加载\n * 异步和并发渲染\n * 隐式事件委托\n * 服务端渲染和注水\n * 指令\n * streaming\n\n\n# 细粒度的响应性意味着你可以事半功倍\n\nsolid 的每个部分都建立在 jsx 视图中 javascript 表达式的简单 primitive 之上。\n\nsolid 解锁了对更新内容和时间的完全控制，即使在 dom 绑定级别也是如此。没有虚拟 dom 或广泛的差异对比，框架永远不会做额外工作。\n\n\n# 专注于性能：无论是客户端还是服务端\n\n细粒度响应式这一策略在所有显眼的基准测试中大放异彩。虽然性能可能不是你的关注点，但最终会影响到用户体验。solid 无需额外的开发复杂度就可以获得很好的性能。就是说无需特意调优就可以运行很快。\n\n\n# solid 理念\n\nsolid 的设计提出了一些可以帮助我们最好地构建网站和应用程序的原则和价值观。当你了解 solid 背后的哲学时，学习和使用 solid 会更容易。\n\n * 声明式数据 ：声明式数据是将数据行为的描述与其声明联系起来的实践。这允许我们通过将数据行为的所有方面打包在一个地方来轻松组合。\n\n * 消失的组件 ：在不考虑更新的情况下构建组件已经够难的了。solid 的组件更新是彼此完全独立的。组件函数被调用一次，然后就不再存在。组件的存在是为了组织你的代码，而不是其他。\n\n * 读/写 分离 ：精确的控制和可预测性有助于打造更好的系统。我们不需要真正的不变性来强制执行单向数据流，只需要能够有意识到哪些消费者可能会写，哪些可能不会。\n\n * 简单胜于容易 ：细粒度响应性教会我们：明确且一致的约定即使需要更多努力也是值得的。且有必要提供最少的工具作为构建的基础。\n\n\n# 参考\n\n * solidjs · reactive javascript library\n * solidjs・反应式 javascript 库",charsets:{cjk:!0},lastUpdated:"2022/09/14, 18:44:08",lastUpdatedTimestamp:1663152248e3},{title:"计划跟踪",frontmatter:{title:"计划跟踪",date:"2022-09-06T14:49:46.000Z",permalink:"/solid/plan/",categories:["web","solid"],tags:[null]},regularPath:"/30.web/9.solid/1.plan.html",relativePath:"30.web/9.solid/1.plan.md",key:"v-73c1945d",path:"/solid/plan/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"目标",slug:"目标",normalizedTitle:"目标",charIndex:153},{level:2,title:"思路",slug:"思路",normalizedTitle:"思路",charIndex:123},{level:2,title:"Plan计划",slug:"plan计划",normalizedTitle:"plan 计划",charIndex:460},{level:2,title:"改进方向",slug:"改进方向",normalizedTitle:"改进方向",charIndex:509}],readingTime:{text:"1 min read",minutes:.31,time:18600,words:62},headersStr:"前言 目标 思路 Plan计划 改进方向",content:"# 前言\n\n有了 React 源码的阅读经验之后，阅读 SolidJS 源码要轻松很多。我此处所说的经验大概包括：\n\n * 源码源码的方法和技巧，克服难点的耐心和信心，良好的笔记经验。\n * 对框架的某些思想的感悟和敏感度，大致猜测会是怎样的编码思路。\n * 由易至难的阅读经验，阅读思路的提升。\n\n\n# 目标\n\n本次阅读 SolidJS 源码需要达到如下的目标：\n\n * 针对 React 所暴露的问题，考察社区中比较优秀的解决思路和方案。\n * 了解目前前端社区较为优秀和前言的前端框架的设计理念和技术，如去除 VDOM、细粒度更新、重编译轻运行等。\n * 学习响应式编程的理念。\n * 总结和提炼前端框架编写面临的核心问题和总体思路。\n * 学习 SSR 的渲染原理。\n\n\n# 思路\n\n本次阅读将不再遵从 React 类似的渲染流程来看，而是分成前端框架的几个大模块来看：\n\n * 渲染（Render）\n * 响应式（reactivity）\n * 数据流（Data Flow）\n * 服务端渲染（SSR）\n\n\n# Plan 计划\n\nSolidJS 源码精讲：\n\n * 渲染原理之组件结构与 JSX 编译\n\n\n# 改进方向\n\n * 图解\n * 文章太长",normalizedContent:"# 前言\n\n有了 react 源码的阅读经验之后，阅读 solidjs 源码要轻松很多。我此处所说的经验大概包括：\n\n * 源码源码的方法和技巧，克服难点的耐心和信心，良好的笔记经验。\n * 对框架的某些思想的感悟和敏感度，大致猜测会是怎样的编码思路。\n * 由易至难的阅读经验，阅读思路的提升。\n\n\n# 目标\n\n本次阅读 solidjs 源码需要达到如下的目标：\n\n * 针对 react 所暴露的问题，考察社区中比较优秀的解决思路和方案。\n * 了解目前前端社区较为优秀和前言的前端框架的设计理念和技术，如去除 vdom、细粒度更新、重编译轻运行等。\n * 学习响应式编程的理念。\n * 总结和提炼前端框架编写面临的核心问题和总体思路。\n * 学习 ssr 的渲染原理。\n\n\n# 思路\n\n本次阅读将不再遵从 react 类似的渲染流程来看，而是分成前端框架的几个大模块来看：\n\n * 渲染（render）\n * 响应式（reactivity）\n * 数据流（data flow）\n * 服务端渲染（ssr）\n\n\n# plan 计划\n\nsolidjs 源码精讲：\n\n * 渲染原理之组件结构与 jsx 编译\n\n\n# 改进方向\n\n * 图解\n * 文章太长",charsets:{cjk:!0},lastUpdated:"2022/09/14, 18:44:08",lastUpdatedTimestamp:1663152248e3},{title:"渲染原理之组件结构与 JSX 编译",frontmatter:{title:"渲染原理之组件结构与 JSX 编译",date:"2022-09-07T11:08:40.000Z",permalink:"/solid/render/render-by-jsx",categories:["web","solid","渲染"],tags:[null]},regularPath:"/30.web/9.solid/10.%E6%B8%B2%E6%9F%93/10.render-jsx.html",relativePath:"30.web/9.solid/10.渲染/10.render-jsx.md",key:"v-074761b1",path:"/solid/render/render-by-jsx/",headers:[{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2},{level:2,title:"JSX 再认识",slug:"jsx-再认识",normalizedTitle:"jsx 再认识",charIndex:17},{level:3,title:"React 中的 JSX",slug:"react-中的-jsx",normalizedTitle:"react 中的 jsx",charIndex:30},{level:3,title:"SolidJS 中的 JSX",slug:"solidjs-中的-jsx",normalizedTitle:"solidjs 中的 jsx",charIndex:48},{level:3,title:"基于 VDOM 的框架之特性",slug:"基于-vdom-的框架之特性",normalizedTitle:"基于 vdom 的框架之特性",charIndex:68},{level:3,title:"为什么使用 VDOM？",slug:"为什么使用-vdom",normalizedTitle:"为什么使用 vdom？",charIndex:88},{level:3,title:"VDOM 的局限性",slug:"vdom-的局限性",normalizedTitle:"vdom 的局限性",charIndex:105},{level:3,title:"VDOM 造成的富应用化",slug:"vdom-造成的富应用化",normalizedTitle:"vdom 造成的富应用化",charIndex:120},{level:3,title:"SolidJS 的富组件化",slug:"solidjs-的富组件化",normalizedTitle:"solidjs 的富组件化",charIndex:138},{level:3,title:"响应式系统与组件的解耦",slug:"响应式系统与组件的解耦",normalizedTitle:"响应式系统与组件的解耦",charIndex:157}],readingTime:{text:"3 min read",minutes:2.855,time:171300,words:571},headersStr:"目录 JSX 再认识 React 中的 JSX SolidJS 中的 JSX 基于 VDOM 的框架之特性 为什么使用 VDOM？ VDOM 的局限性 VDOM 造成的富应用化 SolidJS 的富组件化 响应式系统与组件的解耦",content:'# 目录\n\n\n\n * 目录\n * JSX 再认识\n   * React 中的 JSX\n   * SolidJS 中的 JSX\n   * 基于 VDOM 的框架之特性\n   * 为什么使用 VDOM？\n   * VDOM 的局限性\n   * VDOM 造成的富应用化\n   * SolidJS 的富组件化\n   * 响应式系统与组件的解耦\n\n\n\n\n# JSX 再认识\n\n\n# React 中的 JSX\n\nSolidJS 和 React 一样也是采用了 JSX 来作为组件的定义语言。JSX 我们都很熟悉了，在 React 之中，JSX 被作为是 ReactElement 的描述，每一个节点被 babel 编译为 createElement 的语法糖，类似于 h 函数。这可能给我们带来了一些固定思维，认为 JSX 就是用来描述节点的树形结构的，其实不然，JSX 作为一种组件的描述语言，它能够为编译工具提供足够的灵活性，也就是说，他也可以达到类似于 SFC 的静态分析的效果。\n\n\n# SolidJS 中的 JSX\n\n我们先来看下 SolidJS 中 JSX 的用法：\n\nimport { render } from "solid-js/web";\nimport { createSignal } from "solid-js";\n\nfunction Counter() {\n  const [count, setCount] = createSignal(0);\n  const increment = () => setCount(count() + 1);\n\n  return (\n    <button type="button" onClick={increment}>\n      {count()}\n    </button>\n  );\n}\n\nrender(() => <Counter />, document.getElementById("app")!);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这是官方的一个案例，参见：Solid Playground，注意 COMPILE MODE 选择 Client side rendering ，即 CSR。\n\n可以看到，SolidJS 可以提供 React 类似的语法。SolidJS 部分灵感来源于 React，但是其原理却与 React 与天壤之别，更进一步说，SolidJS 的响应式系统更接近于 Vue，而其去除 VDOM、细粒度更新的特性则更接近于 Svelte。\n\n现在我们来看下上述的代码在 babel-preset-solid 的编译下的产物（output）:\n\nimport { render, createComponent, delegateEvents, insert, template } from \'solid-js/web\';\nimport { createSignal } from \'solid-js\';\n\nconst _tmpl$ = /*#__PURE__*/template(`<button type="button"></button>`, 2);\n\nfunction Counter() {\n  const [count, setCount] = createSignal(0);\n\n  const increment = () => setCount(count() + 1);\n\n  return (() => {\n    const _el$ = _tmpl$.cloneNode(true);\n\n    _el$.$$click = increment;\n\n    insert(_el$, count);\n\n    return _el$;\n  })();\n}\n\nrender(() => createComponent(Counter, {}), document.getElementById("app"));\n\ndelegateEvents(["click"]);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n最显著的特点是，JSX 并不创建类似于嵌套的 h 函数所构成的 VDOM 产物，而是更接近于一种基于 DOM 模板的静态分析。我们可以将上述的代码块归纳成如下的几个部分：\n\n * DOM 静态模板\n * 响应式系统\n * 事件委托系统\n\nDOM 静态模板即 _tmpl$ ，这是组件初始化时静态的 DOM 节点，通过 document.createElement("template") 的方法创建 DOM 节点，参见：template。处理静态模板是在编译时处理的，并且通过静态提升的方式进行优化。\n\n响应式系统即以 createSignal 为代表的响应式 API 所构成的内容，目的是以发布订阅模式思想为指导以代理方式为方法实现响应式，在 “信号” 发生变化时触发收集到的副作用，并且更新 DOM 节点。\n\n事件委托系统即 delegateEvents ，参见 delegateEvents，目的是通过事件委托的方法提升事件处理的效率，事件则统一委托在 document 上。这一点与 React 类似，不过 React 已经将事件委托节点由 document 改成了 FiberRoot 上，参考：React 17 attaches events to the root DOM container instead of the document node。事件委托在 document 当然会有一些安全隐患，因为 document 是 React 应用所无法完全控制的范围，但是委托到 FiberRoot（即 container）上也会存在一些问题，比如连续的拖拽事件将会出现拖拽对象无法跟随鼠标的情况，在 React 中利用原生 mousemove 实现拖拽功能便会遇到这一问题。\n\n在后文的解析之中我们会详细的探讨这几个部分的内容，但是现在，我们不妨转换视角，思考下为什么 SolidJS 需要这么做，以及这么做能够有什么好处？要分析这个问题，我们先从 VDOM 框架说起，探讨一下基于 VDOM 原理的框架之共同特性。\n\n\n# 基于 VDOM 的框架之特性\n\n基于 VDOM 的框架在组件的编译上会具有一些共性，简述如下：\n\n * 嵌套的 h 函数。\n * render 函数在每次渲染时执行。\n\n所谓 h 函数，即为 “渲染函数”，是指通过数据结构描述的方式获取虚拟节点的函数。如 React 中的 createElement 、vue 中的 _createElementVNode （参见：Vue SFC Playground） 等。\n\n所谓 render 函数，是能够表征组件的视图、事件、状态的函数，通过执行 render 函数，可以获取最新状态的虚拟节点树。如 React 类组件的 Class.render 函数、函数式组件本身，vue 组件的 setup 函数。\n\n我们可以深入地考虑为什么基于 VDOM 的框架会具有这样的特性，其实不难理解：\n\n * 渲染函数为 VNode 的创建提供了便捷性，模板的解析依赖渲染函数。\n * 创建状态和数据随时间变化的组件。VDOM 以及 DIFF 算法的目的就是在状态发生变化时通过对比 VDOM 来更新视图，因此组件必须能够表征出组件最新的状态和视图。\n\n参考：\n\n * 渲染机制 | Vue.js\n * 渲染函数 & JSX | Vue.js\n\n\n# 为什么使用 VDOM？\n\n决定了 SolidJS 的 JSX 解析与 React 大有不同的原因是因为 SolidJS 去除了 VDOM 层，这导致了 SolidJS 中响应式系统的策略的改变。VDOM 的思路来源于 React，目的是提升节点 DIFF 的效率并且降低成本。为什么要使用 VDOM 呢？这就不得不谈到 VDOM 所具有的优势：\n\n * 降低 DIFF 成本。直接 DIFF DOM 节点的成本简直无法想象，而 VDOM 作为 JavaScript 可控的数据结构，则可大大降低 DIFF 的成本。同时，一系列的优化手段也可使 DIFF 成本进一步降低，如更高效的 DIFF 算法，React 的 EffectTag 处理或者 Vue 的模板静态分析、静态提升等手段。\n * 构建节点防腐层。框架不可能只使用 Web 这一种使用场景，在适配各种不同的渲染场景时，VDOM 则可作为防腐层存在，适配不同的节点渲染规则。\n * 声明式的、状态驱动的 UI 开发体验（ declarative, state-driven UI development ）。无论是 React 还是 Vue 都强调自己的这两个特性，当然这与 VDOM 机制不可分离。这使得我们在编写组件时更高效的处理状态的变化和视图的呈现，而不用关注视图更新的时机和原理。\n\n\n# VDOM 的局限性\n\n同时 VDOM 自然也带来了一些局限性，如：\n\n * 大量的 DIFF （包括无效的 DIFF）造成成本的提升。\n * 提升 DIFF 效率的复杂性构成应用的效率瓶颈。\n\n无论是应用级别的 DIFF 还是组件级别的 DIFF，其实都提升了响应式系统的复杂性，因为响应式的更新是离散的、细粒度的，而 VDOM 的方式则无疑将这种更新的影响范围扩散到整个应用或者组件，这种影响范围的放大造成我们想要细粒度的 DOM 更新变得异常复杂。您可以从下图中体会这一点：\n\n参考：\n\n * Svelte Blog: Virtual DOM is pure overhead\n * React vs. Svelte: The War Between Virtual and Real DOM | by Keshav Kumaresan | Bits and Pieces\n * Incremental vs Virtual DOM. Will Incremental DOM Replace Virtual… | by Chameera Dulanga | Bits and Pieces\n\n\n# VDOM 造成的富应用化\n\nVDOM 会使应用变得更 “重”，这在很大程度上是因为 VDOM 的粗粒度所造成的。我们可以进一步思考 VDOM 应用具体会重在哪里：\n\n * VDOM 系统和 DIFF 算法，VDOM 系统包含了渲染函数和模板、VNode 的内存占用、DIFF 算法及其繁琐的优化策略、VNode 转化为 DOM 节点变更的 mutation 操作等。\n * VDOM 的 “庞大的” 运行时。VDOM 思想本质上还是在实践轻编译重运行的理念，因此庞大的 VDOM 系统必然会包含在运行时中，成为线上产品的一大 “负担”。\n\nVDOM 的粗粒度是一种权衡（ tradeoff ），VDOM 获得了更多的节点控制权，却在一定程度上违背了细粒度更新的规则，因为无论 VDOM 系统是应用层面的还是组件层面的，都要为细粒度更新 DOM 的优化而付出巨大的代价。同时，VDOM 也将响应式系统和组件进行了捆绑，因为我们总是认为状态是属于组件的，但是从整个应用的更新来看，响应式系统是完全可以与组件进行解耦的。后文会详述这一问题。\n\n这种让应用程序越来越重的倾向，我称之为 “富应用化”。\n\n\n# SolidJS 的富组件化\n\nSolidJS 去除了 VDOM 系统，这使得离散的、细粒度的状态变化可以直接通过响应式系统与细粒度的 DOM 更新进行对应，无论这种 DOM 更新是可调度的还是无调度的，这在一定程度上解决了 VDOM 所造成的的应用的 overhead 。\n\n我们可以思考去除 VDOM 所带来的直接影响：\n\n * 更轻量的应用运行时，更高效的组件更新效率。去除 VDOM 将直接减少运行时的体积，没有了 DIFF 的过程也将大大提升组件更新的效率。\n * 更轻的框架成本，更少的框架倾入性，可插拔的框架模块。相比于 React，solidjs 要轻量的多，我们可以从源码中直接体会到。没有 VDOM，框架对于节点将减少很多的倾入性，这将使得 DOM 的更新更加贴近于原生的 DOM 操作。框架模块之间可以相互解耦，如响应式系统、事件系统、组件结构等，这将使得框架的可插拔性更好，可以轻易地与其他框架配合使用。\n * “重编译而轻运行” 的趋势。将更多的成本转移到编译时，减轻运行时的负担。\n\n这一切都将导致 SolidJS 的 “富组件化” 的倾向！\n\n所谓 “富组件化”，即是将应用的成本中心由 “应用” 转移到 “组件” 中。我们可以观察上文 SolidJS JSX 的编译结果，以推测去除 VDOM 后的 SolidJS 是如何实现 DOM 的更新的。\n\n毫无疑问，这种因状态更新而更新 DOM 的成本是转移到了组件上。在 SolidJS 中，响应式系统在注入组件时，会将更新 DOM 节点作为副作用的一部分。显然这部分的副作用虽然有着良好的性能，但由于其复杂性，成本也会随着项目的规模增长而变得更大。如果单独从组件的角度来看，组件已经具有了\n\n\n# 响应式系统与组件的解耦\n\n参考：\n\n * Sawtaytoes/reactjs-solidjs-bridge: Render Solid.js components in React.js and visa versa.\n * Solid.js feels like what I always wanted React to be | TypeOfNaN\n * SolidJS: Reactivity to Rendering - JavaScript inDepth',normalizedContent:'# 目录\n\n\n\n * 目录\n * jsx 再认识\n   * react 中的 jsx\n   * solidjs 中的 jsx\n   * 基于 vdom 的框架之特性\n   * 为什么使用 vdom？\n   * vdom 的局限性\n   * vdom 造成的富应用化\n   * solidjs 的富组件化\n   * 响应式系统与组件的解耦\n\n\n\n\n# jsx 再认识\n\n\n# react 中的 jsx\n\nsolidjs 和 react 一样也是采用了 jsx 来作为组件的定义语言。jsx 我们都很熟悉了，在 react 之中，jsx 被作为是 reactelement 的描述，每一个节点被 babel 编译为 createelement 的语法糖，类似于 h 函数。这可能给我们带来了一些固定思维，认为 jsx 就是用来描述节点的树形结构的，其实不然，jsx 作为一种组件的描述语言，它能够为编译工具提供足够的灵活性，也就是说，他也可以达到类似于 sfc 的静态分析的效果。\n\n\n# solidjs 中的 jsx\n\n我们先来看下 solidjs 中 jsx 的用法：\n\nimport { render } from "solid-js/web";\nimport { createsignal } from "solid-js";\n\nfunction counter() {\n  const [count, setcount] = createsignal(0);\n  const increment = () => setcount(count() + 1);\n\n  return (\n    <button type="button" onclick={increment}>\n      {count()}\n    </button>\n  );\n}\n\nrender(() => <counter />, document.getelementbyid("app")!);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这是官方的一个案例，参见：solid playground，注意 compile mode 选择 client side rendering ，即 csr。\n\n可以看到，solidjs 可以提供 react 类似的语法。solidjs 部分灵感来源于 react，但是其原理却与 react 与天壤之别，更进一步说，solidjs 的响应式系统更接近于 vue，而其去除 vdom、细粒度更新的特性则更接近于 svelte。\n\n现在我们来看下上述的代码在 babel-preset-solid 的编译下的产物（output）:\n\nimport { render, createcomponent, delegateevents, insert, template } from \'solid-js/web\';\nimport { createsignal } from \'solid-js\';\n\nconst _tmpl$ = /*#__pure__*/template(`<button type="button"></button>`, 2);\n\nfunction counter() {\n  const [count, setcount] = createsignal(0);\n\n  const increment = () => setcount(count() + 1);\n\n  return (() => {\n    const _el$ = _tmpl$.clonenode(true);\n\n    _el$.$$click = increment;\n\n    insert(_el$, count);\n\n    return _el$;\n  })();\n}\n\nrender(() => createcomponent(counter, {}), document.getelementbyid("app"));\n\ndelegateevents(["click"]);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n最显著的特点是，jsx 并不创建类似于嵌套的 h 函数所构成的 vdom 产物，而是更接近于一种基于 dom 模板的静态分析。我们可以将上述的代码块归纳成如下的几个部分：\n\n * dom 静态模板\n * 响应式系统\n * 事件委托系统\n\ndom 静态模板即 _tmpl$ ，这是组件初始化时静态的 dom 节点，通过 document.createelement("template") 的方法创建 dom 节点，参见：template。处理静态模板是在编译时处理的，并且通过静态提升的方式进行优化。\n\n响应式系统即以 createsignal 为代表的响应式 api 所构成的内容，目的是以发布订阅模式思想为指导以代理方式为方法实现响应式，在 “信号” 发生变化时触发收集到的副作用，并且更新 dom 节点。\n\n事件委托系统即 delegateevents ，参见 delegateevents，目的是通过事件委托的方法提升事件处理的效率，事件则统一委托在 document 上。这一点与 react 类似，不过 react 已经将事件委托节点由 document 改成了 fiberroot 上，参考：react 17 attaches events to the root dom container instead of the document node。事件委托在 document 当然会有一些安全隐患，因为 document 是 react 应用所无法完全控制的范围，但是委托到 fiberroot（即 container）上也会存在一些问题，比如连续的拖拽事件将会出现拖拽对象无法跟随鼠标的情况，在 react 中利用原生 mousemove 实现拖拽功能便会遇到这一问题。\n\n在后文的解析之中我们会详细的探讨这几个部分的内容，但是现在，我们不妨转换视角，思考下为什么 solidjs 需要这么做，以及这么做能够有什么好处？要分析这个问题，我们先从 vdom 框架说起，探讨一下基于 vdom 原理的框架之共同特性。\n\n\n# 基于 vdom 的框架之特性\n\n基于 vdom 的框架在组件的编译上会具有一些共性，简述如下：\n\n * 嵌套的 h 函数。\n * render 函数在每次渲染时执行。\n\n所谓 h 函数，即为 “渲染函数”，是指通过数据结构描述的方式获取虚拟节点的函数。如 react 中的 createelement 、vue 中的 _createelementvnode （参见：vue sfc playground） 等。\n\n所谓 render 函数，是能够表征组件的视图、事件、状态的函数，通过执行 render 函数，可以获取最新状态的虚拟节点树。如 react 类组件的 class.render 函数、函数式组件本身，vue 组件的 setup 函数。\n\n我们可以深入地考虑为什么基于 vdom 的框架会具有这样的特性，其实不难理解：\n\n * 渲染函数为 vnode 的创建提供了便捷性，模板的解析依赖渲染函数。\n * 创建状态和数据随时间变化的组件。vdom 以及 diff 算法的目的就是在状态发生变化时通过对比 vdom 来更新视图，因此组件必须能够表征出组件最新的状态和视图。\n\n参考：\n\n * 渲染机制 | vue.js\n * 渲染函数 & jsx | vue.js\n\n\n# 为什么使用 vdom？\n\n决定了 solidjs 的 jsx 解析与 react 大有不同的原因是因为 solidjs 去除了 vdom 层，这导致了 solidjs 中响应式系统的策略的改变。vdom 的思路来源于 react，目的是提升节点 diff 的效率并且降低成本。为什么要使用 vdom 呢？这就不得不谈到 vdom 所具有的优势：\n\n * 降低 diff 成本。直接 diff dom 节点的成本简直无法想象，而 vdom 作为 javascript 可控的数据结构，则可大大降低 diff 的成本。同时，一系列的优化手段也可使 diff 成本进一步降低，如更高效的 diff 算法，react 的 effecttag 处理或者 vue 的模板静态分析、静态提升等手段。\n * 构建节点防腐层。框架不可能只使用 web 这一种使用场景，在适配各种不同的渲染场景时，vdom 则可作为防腐层存在，适配不同的节点渲染规则。\n * 声明式的、状态驱动的 ui 开发体验（ declarative, state-driven ui development ）。无论是 react 还是 vue 都强调自己的这两个特性，当然这与 vdom 机制不可分离。这使得我们在编写组件时更高效的处理状态的变化和视图的呈现，而不用关注视图更新的时机和原理。\n\n\n# vdom 的局限性\n\n同时 vdom 自然也带来了一些局限性，如：\n\n * 大量的 diff （包括无效的 diff）造成成本的提升。\n * 提升 diff 效率的复杂性构成应用的效率瓶颈。\n\n无论是应用级别的 diff 还是组件级别的 diff，其实都提升了响应式系统的复杂性，因为响应式的更新是离散的、细粒度的，而 vdom 的方式则无疑将这种更新的影响范围扩散到整个应用或者组件，这种影响范围的放大造成我们想要细粒度的 dom 更新变得异常复杂。您可以从下图中体会这一点：\n\n参考：\n\n * svelte blog: virtual dom is pure overhead\n * react vs. svelte: the war between virtual and real dom | by keshav kumaresan | bits and pieces\n * incremental vs virtual dom. will incremental dom replace virtual… | by chameera dulanga | bits and pieces\n\n\n# vdom 造成的富应用化\n\nvdom 会使应用变得更 “重”，这在很大程度上是因为 vdom 的粗粒度所造成的。我们可以进一步思考 vdom 应用具体会重在哪里：\n\n * vdom 系统和 diff 算法，vdom 系统包含了渲染函数和模板、vnode 的内存占用、diff 算法及其繁琐的优化策略、vnode 转化为 dom 节点变更的 mutation 操作等。\n * vdom 的 “庞大的” 运行时。vdom 思想本质上还是在实践轻编译重运行的理念，因此庞大的 vdom 系统必然会包含在运行时中，成为线上产品的一大 “负担”。\n\nvdom 的粗粒度是一种权衡（ tradeoff ），vdom 获得了更多的节点控制权，却在一定程度上违背了细粒度更新的规则，因为无论 vdom 系统是应用层面的还是组件层面的，都要为细粒度更新 dom 的优化而付出巨大的代价。同时，vdom 也将响应式系统和组件进行了捆绑，因为我们总是认为状态是属于组件的，但是从整个应用的更新来看，响应式系统是完全可以与组件进行解耦的。后文会详述这一问题。\n\n这种让应用程序越来越重的倾向，我称之为 “富应用化”。\n\n\n# solidjs 的富组件化\n\nsolidjs 去除了 vdom 系统，这使得离散的、细粒度的状态变化可以直接通过响应式系统与细粒度的 dom 更新进行对应，无论这种 dom 更新是可调度的还是无调度的，这在一定程度上解决了 vdom 所造成的的应用的 overhead 。\n\n我们可以思考去除 vdom 所带来的直接影响：\n\n * 更轻量的应用运行时，更高效的组件更新效率。去除 vdom 将直接减少运行时的体积，没有了 diff 的过程也将大大提升组件更新的效率。\n * 更轻的框架成本，更少的框架倾入性，可插拔的框架模块。相比于 react，solidjs 要轻量的多，我们可以从源码中直接体会到。没有 vdom，框架对于节点将减少很多的倾入性，这将使得 dom 的更新更加贴近于原生的 dom 操作。框架模块之间可以相互解耦，如响应式系统、事件系统、组件结构等，这将使得框架的可插拔性更好，可以轻易地与其他框架配合使用。\n * “重编译而轻运行” 的趋势。将更多的成本转移到编译时，减轻运行时的负担。\n\n这一切都将导致 solidjs 的 “富组件化” 的倾向！\n\n所谓 “富组件化”，即是将应用的成本中心由 “应用” 转移到 “组件” 中。我们可以观察上文 solidjs jsx 的编译结果，以推测去除 vdom 后的 solidjs 是如何实现 dom 的更新的。\n\n毫无疑问，这种因状态更新而更新 dom 的成本是转移到了组件上。在 solidjs 中，响应式系统在注入组件时，会将更新 dom 节点作为副作用的一部分。显然这部分的副作用虽然有着良好的性能，但由于其复杂性，成本也会随着项目的规模增长而变得更大。如果单独从组件的角度来看，组件已经具有了\n\n\n# 响应式系统与组件的解耦\n\n参考：\n\n * sawtaytoes/reactjs-solidjs-bridge: render solid.js components in react.js and visa versa.\n * solid.js feels like what i always wanted react to be | typeofnan\n * solidjs: reactivity to rendering - javascript indepth',charsets:{cjk:!0},lastUpdated:"2022/09/14, 18:44:08",lastUpdatedTimestamp:1663152248e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-04-14T23:36:48.000Z",permalink:"/node/index/",categories:null,tags:[null]},regularPath:"/40.node/0.index.html",relativePath:"40.node/0.index.md",key:"v-82075c46",path:"/node/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"Plan 计划",frontmatter:{title:"Plan 计划",date:"2022-04-16T13:46:07.000Z",permalink:"/node/plan/",categories:["node"],tags:[null]},regularPath:"/40.node/1.plan.html",relativePath:"40.node/1.plan.md",key:"v-cf050632",path:"/node/plan/",headers:[{level:2,title:"Plan",slug:"plan",normalizedTitle:"plan",charIndex:2}],readingTime:{text:"1 min read",minutes:.01,time:600,words:2},headersStr:"Plan",content:"# Plan",normalizedContent:"# plan",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"roadmap",frontmatter:{title:"roadmap",date:"2022-04-29T00:00:20.000Z",permalink:"/node/roadmap/",categories:["node"],tags:[null]},regularPath:"/40.node/2.roadmap.html",relativePath:"40.node/2.roadmap.md",key:"v-bebe86c6",path:"/node/roadmap/",headers:[{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2}],readingTime:{text:"1 min read",minutes:.045,time:2699.9999999999995,words:9},headersStr:"参考",content:"# 参考\n\n * sindresorhus/awesome-nodejs: Delightful Node.js packages and resources",normalizedContent:"# 参考\n\n * sindresorhus/awesome-nodejs: delightful node.js packages and resources",charsets:{cjk:!0},lastUpdated:"2022/04/29, 00:44:35",lastUpdatedTimestamp:1651164275e3},{title:"开始上手",frontmatter:{title:"开始上手",date:"2022-06-24T10:53:28.000Z",permalink:"/topic/index/",categories:["topic"],tags:[null]},regularPath:"/50.topic/0.index.html",relativePath:"50.topic/0.index.md",key:"v-4fe65767",path:"/topic/index/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/25, 18:09:57",lastUpdatedTimestamp:1656151797e3},{title:"开始阅读",frontmatter:{title:"开始阅读",date:"2022-06-24T11:22:51.000Z",permalink:"/topic/js2ts/index/",categories:["topic","ts2js"],tags:[null]},regularPath:"/50.topic/10.fromTs2Js/0.index.html",relativePath:"50.topic/10.fromTs2Js/0.index.md",key:"v-6fba7546",path:"/topic/js2ts/index/",readingTime:{text:"0 min read",minutes:0,time:0,words:0},headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/25, 18:09:57",lastUpdatedTimestamp:1656151797e3},{title:"Awesome NodeJS",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"40.node",imgUrl:"/assets/img/node.png",description:"更多 NodeJS 相关源码精读......"}},title:"Awesome NodeJS",date:"2020-03-11T21:50:53.000Z",permalink:"/node/",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/999.%E7%9B%AE%E5%BD%95/20.node.html",relativePath:"999.目录/20.node.md",key:"v-0790c155",path:"/node/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/29, 00:44:35",lastUpdatedTimestamp:1651164275e3},{title:"Awesome Web",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"30.web",imgUrl:"/assets/img/tech.png",description:"更多 Web 相关源码精读......"}},title:"Awesome Web",date:"2020-03-11T21:50:53.000Z",permalink:"/web/",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/999.%E7%9B%AE%E5%BD%95/10.web.html",relativePath:"999.目录/10.web.md",key:"v-97306cda",path:"/web/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 23:58:26",lastUpdatedTimestamp:1651161506e3},{title:"主题",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"50.topic",imgUrl:"/assets/img/more.png",description:"更多主题......"}},title:"主题",date:"2020-03-11T21:50:53.000Z",permalink:"/topic/",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/999.%E7%9B%AE%E5%BD%95/30.topic.html",relativePath:"999.目录/30.topic.md",key:"v-6cc4c933",path:"/topic/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/06/25, 18:09:57",lastUpdatedTimestamp:1656151797e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-d744eac6",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-2bac39fd",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-39df881d",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"Q&A",frontmatter:{title:"Q&A",date:"2022-01-11T14:03:46.000Z",permalink:"/qa/",categories:[null],tags:[null],sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/Q&A.html",relativePath:"Q&A.md",key:"v-75a63fbd",path:"/qa/",headers:[{level:2,title:"本站的内容顺序是如何排列的？",slug:"本站的内容顺序是如何排列的",normalizedTitle:"本站的内容顺序是如何排列的？",charIndex:2},{level:2,title:"能否自由分享本站的内容？",slug:"能否自由分享本站的内容",normalizedTitle:"能否自由分享本站的内容？",charIndex:21},{level:2,title:"本站的建站技术是什么？",slug:"本站的建站技术是什么",normalizedTitle:"本站的建站技术是什么？",charIndex:38}],readingTime:{text:"1 min read",minutes:.03,time:1799.9999999999998,words:6},headersStr:"本站的内容顺序是如何排列的？ 能否自由分享本站的内容？ 本站的建站技术是什么？",content:"# 本站的内容顺序是如何排列的？\n\n\n# 能否自由分享本站的内容？\n\n\n# 本站的建站技术是什么？",normalizedContent:"# 本站的内容顺序是如何排列的？\n\n\n# 能否自由分享本站的内容？\n\n\n# 本站的建站技术是什么？",charsets:{cjk:!0},lastUpdated:"2022/04/15, 00:23:56",lastUpdatedTimestamp:1649953436e3},{title:"Home",frontmatter:{home:!0,heroText:"Fancy Front End",tagline:"前端源码精读，精读 React、Vue 源码。",actionText:"开始上手 →",actionLink:"/react/index/",bannerBg:"auto",features:[{title:"React",details:"调和、调度器、更新与渲染、hooks原理...",link:"/react/index",imgUrl:"/assets/img/react.svg"},{title:"Vue3",details:"响应式原理、runtime-core、runtime-dom、compiler...",link:"/vue3/index",imgUrl:"/assets/img/vue.svg"},{title:"进阶",details:"更多源码阅读，qiankun、single-spa、vite...",link:"/web/index",imgUrl:"/assets/img/tech.png"}],postList:"detailed"},regularPath:"/",relativePath:"index.md",key:"v-2af0da94",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/01, 10:17:14",lastUpdatedTimestamp:1651371434e3},{title:"导航",frontmatter:{title:"导航",date:"2022-01-11T14:03:46.000Z",permalink:"/nav/",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/%E5%AF%BC%E8%88%AA%E7%AB%99.html",relativePath:"导航站.md",key:"v-7d3a31b9",path:"/nav/",headers:[{level:2,title:"Fancy 系列",slug:"fancy-系列",normalizedTitle:"fancy 系列",charIndex:2},{level:2,title:"关于我",slug:"关于我",normalizedTitle:"关于我",charIndex:15}],readingTime:{text:"1 min read",minutes:.635,time:38100,words:127},headersStr:"Fancy 系列 关于我",content:"# Fancy 系列\n\n\n# 关于我",normalizedContent:"# fancy 系列\n\n\n# 关于我",charsets:{cjk:!0},lastUpdated:"2022/08/01, 20:37:47",lastUpdatedTimestamp:1659357467e3},{title:"关于",frontmatter:{title:"关于",date:"2022-01-11T14:03:46.000Z",permalink:"/about/",categories:[null],tags:[null],sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/%E5%85%B3%E4%BA%8E.html",relativePath:"关于.md",key:"v-d2407716",path:"/about/",headers:[{level:2,title:"建站初衷",slug:"建站初衷",normalizedTitle:"建站初衷",charIndex:2},{level:2,title:"如何使用本站？",slug:"如何使用本站",normalizedTitle:"如何使用本站？",charIndex:11},{level:3,title:"如何读源码？",slug:"如何读源码",normalizedTitle:"如何读源码？",charIndex:23},{level:2,title:"版权声明",slug:"版权声明",normalizedTitle:"版权声明",charIndex:270},{level:2,title:"参与贡献",slug:"参与贡献",normalizedTitle:"参与贡献",charIndex:279},{level:2,title:"关于我",slug:"关于我",normalizedTitle:"关于我",charIndex:288},{level:2,title:"联系我",slug:"联系我",normalizedTitle:"联系我",charIndex:296},{level:2,title:"给我留言",slug:"给我留言",normalizedTitle:"给我留言",charIndex:304},{level:2,title:"最近在做什么？",slug:"最近在做什么",normalizedTitle:"最近在做什么？",charIndex:313}],readingTime:{text:"1 min read",minutes:.11,time:6600,words:22},headersStr:"建站初衷 如何使用本站？ 如何读源码？ 版权声明 参与贡献 关于我 联系我 给我留言 最近在做什么？",content:"# 建站初衷\n\n\n# 如何使用本站？\n\n\n# 如何读源码？\n\n借用我很有感触的两句话：\n\n> 只有自己感悟出来的知识和靠自己总结出来的结论，才真正属于自己。记住，享受当下，当下你学的每一个看似没啥用的知识，都是后面豁然开朗这种感觉的基石。【摘选自闪客新系列！你管这破玩意叫操作系统源码】\n\n源码固然复杂，如果最初就抱着功利心去阅读，就会陷入烦躁和无所适从的死循环，结果要么是阅读的很痛苦，要么是早早的放弃。所以放弃问 我能学到什么? 、 我为什么要学这玩意 诸如此类的问题，在任何学习的场景中，问出这样的问题，你可能已经输了一半。\n\n\n# 版权声明\n\n\n# 参与贡献\n\n\n# 关于我\n\n\n# 联系我\n\n\n# 给我留言\n\n\n# 最近在做什么？",normalizedContent:"# 建站初衷\n\n\n# 如何使用本站？\n\n\n# 如何读源码？\n\n借用我很有感触的两句话：\n\n> 只有自己感悟出来的知识和靠自己总结出来的结论，才真正属于自己。记住，享受当下，当下你学的每一个看似没啥用的知识，都是后面豁然开朗这种感觉的基石。【摘选自闪客新系列！你管这破玩意叫操作系统源码】\n\n源码固然复杂，如果最初就抱着功利心去阅读，就会陷入烦躁和无所适从的死循环，结果要么是阅读的很痛苦，要么是早早的放弃。所以放弃问 我能学到什么? 、 我为什么要学这玩意 诸如此类的问题，在任何学习的场景中，问出这样的问题，你可能已经输了一半。\n\n\n# 版权声明\n\n\n# 参与贡献\n\n\n# 关于我\n\n\n# 联系我\n\n\n# 给我留言\n\n\n# 最近在做什么？",charsets:{cjk:!0},lastUpdated:"2022/04/18, 20:57:27",lastUpdatedTimestamp:1650286647e3},{title:"prefetch",frontmatter:{title:"prefetch",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/core/prefetch/",categories:["qiankun","core"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/10.core/40.prefetch.html",relativePath:"30.web/6.qiankun源码/10.core/40.prefetch.md",key:"v-6196523d",path:"/qiankun/core/prefetch/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3},{title:"Effects",frontmatter:{title:"Effects",date:"2022-04-14T22:02:21.000Z",permalink:"/qiankun/core/effects/",categories:["qiankun","core"],tags:[null]},regularPath:"/30.web/6.qiankun%E6%BA%90%E7%A0%81/10.core/30.effects.html",relativePath:"30.web/6.qiankun源码/10.core/30.effects.md",key:"v-5d5e22bf",path:"/qiankun/core/effects/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/06, 14:25:16",lastUpdatedTimestamp:1662445516e3}],themeConfig:{nav:[{text:"React源码",link:"/react/index/",items:[{text:"开始上手",link:"/react/index/"},{text:"基础",link:"/react/basic/index/"},{text:"调度器（Scheduler）",link:"/react/scheduler/index/"},{text:"更新器（Updater）",link:"/react/updater/index/"},{text:"渲染器（Render）",link:"/react/render/index/"},{text:"更新周期",link:"/react/update/index/"},{text:"hooks 原理",link:"/react/hooks/index/"},{text:"总结",link:"/react/summary/index/"},{text:"📙 React源码漂流记",link:"/react/tour/index/"}]},{text:"Vue3源码",link:"/vue3/index/",items:[{text:"开始上手",link:"/vue3/index/"},{text:"基础",link:"/vue3/basic/index/"},{text:"reactivity",link:"/vue3/reactivity/index/"},{text:"runtime-core",link:"/vue3/runtime-core/index/"},{text:"runtime-dom",link:"/vue3/runtime-dom/index/"}]},{text:"进阶",link:"/web/",items:[{text:"Awesome Web",link:"/web/"},{text:"Awesome NodeJS",link:"/node/"}]},{text:"话题",link:"/topic/"},{text:"更多",link:"/nav/",items:[{text:"导航",link:"/nav/"},{text:"Q&A",link:"/qa/"},{text:"幻灯片",link:"/slides/#/1"},{text:"关于",link:"/about/"}]},{text:"索引",link:"/archives/",items:[{text:"分类",link:"/categories/"},{text:"标签",link:"/tags/"},{text:"归档",link:"/archives/"}]},{text:"博客",link:"https://www.jonsam.site"}],sidebarDepth:1,logo:"/assets/img/logo.png",repo:"jonsam-ng/fancy-front-end",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"编辑",category:!0,tag:!0,archive:!0,categoryText:"随笔",titleBadge:!0,contentBgStyle:6,updateBar:{showToArticle:!0,moreArticle:"/archives"},rightMenuBar:!0,sidebarOpen:!0,pageButton:!0,sidebar:{"/10.react/":[["0.index.md","开始上手","/react/index/"],["1.plan.md","plan 计划","/react/plan/"],{title:"基础",collapsable:!0,children:[["10.基础/0.index.md","开始上手","/react/basic/"],["10.基础/10.chapter.md","章节说明","/react/basic/chapter/"],["10.基础/20.faq.md","F&Q","/react/basic/faq/"],["10.基础/30.ReactChildren.md","ReactChildren","/react/basic/children/"],["10.基础/40.ReactElement.md","ReactElement","/react/basic/element/"]]},{title:"调和（Reconciliation）",collapsable:!0,children:[["20.调和（Reconciliation）/0.index.md","开始上手","/react/reconciliation/index/"],["20.调和（Reconciliation）/10.fiber.md","Fiber 与 Reconciliation","/react/reconciliation/fiber/"],["20.调和（Reconciliation）/20.reactChildFiber.md","ReactChildFiber 的创建","/react/reconciliation/reactChildFiber/"],["20.调和（Reconciliation）/30.expirationTime.md","expirationTime与优先级","/react/reconciliation/expirationTime/"],["20.调和（Reconciliation）/40.scheduleWork.md","scheduleWork与调度过程","/react/reconciliation/scheduleWork/"],["20.调和（Reconciliation）/50.lane.md","Lane 与优先级","/react/reconciliation/lane/"]]},{title:"调度器（Scheduler）",collapsable:!0,children:[["30.调度器（Scheduler）/0.index.md","开始上手","/react/scheduler/index/"],["30.调度器（Scheduler）/10.scheduleCallback.md","scheduleCallback与调度任务","/react/scheduler/scheduleCallback/"],["30.调度器（Scheduler）/20.schedulerHostConfig.md","schedulerHostConfig","/react/scheduler/schedulerHostConfig/"],["30.调度器（Scheduler）/30.scheduler.md","scheduler 顶层 API","/react/scheduler/scheduler/"]]},{title:"更新器（Updater）",collapsable:!0,children:[["40.更新器（Updater）/0.index.md","开始上手","/react/updater/index/"],["40.更新器（Updater）/10.workloop.md","workLoop 和 performUnitOfWork","/react/updater/workloop/"]]},{title:"渲染器（Render）",collapsable:!0,children:[["50.渲染器（Render）/0.index.md","开始上手","/react/render/index/"],["50.渲染器（Render）/10.ReactDOM.md","ReactDOM.render 方法","/react/render/render/"]]},{title:"hooks原理",collapsable:!0,children:[["70.hooks原理/0.index.md","开始上手","/react/hooks/index/"],["70.hooks原理/10.useState.md","useState 和 useReducer","/react/hooks/useState/"],["70.hooks原理/20.useEffect.md","useEffect","/react/hooks/useEffect/"],["70.hooks原理/30.useRef.md","useRef 原理","/react/hooks/useRef/"]]},{title:"总结",collapsable:!0,children:[["80.总结/0.index.md","开始上手","/react/summary/index/"],["80.总结/10.bitOperation.md","位运算初探","/react/summary/bitOperation/"],["80.总结/20.first-render.md","React 首次渲染过程","/react/summary/first-render/"],["80.总结/30.event-listener.md","React 中的事件监听机制","/react/summary/event-listener/"],["80.总结/40.10-min-react.md","30 分钟看懂 React 框架原理","/react/summary/10-min-react/"]]},{title:"React源码漂流记",collapsable:!0,children:[["90.React源码漂流记/0.index.md","开始上手","/react/tour/index/"],["90.React源码漂流记/1.Plan.md","Plan 计划","/react/tour/plan/"],["90.React源码漂流记/2.talk.md","前言","/react/tour/talk/"],["90.React源码漂流记/10.react-basic-element.md","React 源码漂流记：ReactElement 与基础概念","/react/tour/react-basic-element/"],["90.React源码漂流记/20.react-basic-children.md","React 源码漂流记：ReactChildren 与节点操纵","/react/tour/react-basic-children/"],["90.React源码漂流记/30.react-basic-view.md","React 源码漂流记：React 整体结构和理念初认识","/react/tour/react-basic-glimpse/"],["90.React源码漂流记/90.react-reconciliation-1.md","React 源码漂流记：React 调和器核心源码解读（一）","/react/tour/react-reconciliation-1/"],["90.React源码漂流记/100.react-reconciliation-2.md","React 源码漂流记：React 调和器核心源码解读（二）","/react/tour/react-reconciliation-2/"],["90.React源码漂流记/110.react-reconciliation-3.md","React 源码漂流记：React 调和器核心源码解读（三）","/react/tour/react-reconciliation-3/"],["90.React源码漂流记/120.react-reconciliation-4.md","React 源码漂流记：React 调和器核心源码解读（四）","/react/tour/react-reconciliation-4/"],["90.React源码漂流记/130.react-reconciliation-5.md","React 源码漂流记：React 调和器核心源码解读（五）","/react/tour/react-reconciliation-5/"],["90.React源码漂流记/140.react-reconciliation-6.md","React 源码漂流记：React 调和器核心源码解读（六）","/react/tour/react-reconciliation-6/"],["90.React源码漂流记/150.react-reconciliation-7.md","React 源码漂流记：React 调和器核心源码解读（七）","/react/tour/react-reconciliation-7/"],["90.React源码漂流记/160.react-reconciliation-8.md","React 源码漂流记：React 调和器核心源码解读（八）","/react/tour/react-reconciliation-8/"],["90.React源码漂流记/170.react-reconciliation-9.md","React 源码漂流记：React 调和器核心源码解读（九）","/react/tour/react-reconciliation-9/"],["90.React源码漂流记/180.react-reconciliation-10.md","React 源码漂流记：React 调和器核心源码解读（十）","/react/tour/react-reconciliation-10/"],["90.React源码漂流记/300.react-scheduler-1.md","React 源码漂流记：React 调度器核心源码解读（一）","/react/tour/react-scheduler-1/"],["90.React源码漂流记/900.react-docs-reading-1.md","带着原理重读 React 官方文档（一）","/react/tour/dr-1/"],["90.React源码漂流记/910.react-docs-reading-2.md","带着原理重读 React 官方文档（二）","/react/tour/dr-2/"]]}],catalogue:{web:"/web/",node:"/node/",topic:"/topic/"},"/20.vue3/":[["0.index.md","开始上手","/vue3/index/"],["1.plan.md","plan 计划","/vue3/plan/"],{title:"基础",collapsable:!0,children:[["10.基础/0.index.md","开始上手","/vue3/basic/index/"]]},{title:"reactivity",collapsable:!0,children:[["20.reactivity/0.index.md","开始上手","/vue3/reactivity/index/"],["20.reactivity/10.ref.md","Ref","/vue3/reactivity/ref/"],["20.reactivity/20.reactive.md","Reactive","/vue3/basic/reactive/"],["20.reactivity/30.handler.md","Handler","/vue3/basic/handler/"],["20.reactivity/40.effect.md","Effect","/vue3/basic/effect/"],["20.reactivity/50.computed.md","Computed","/vue3/basic/computed/"]]},{title:"runtime-core",collapsable:!0,children:[["30.runtime-core/0.index.md","开始上手","/vue3/runtime-core/index/"]]},{title:"runtime-dom",collapsable:!0,children:[["40.runtime-dom/0.index.md","开始上手","/vue3/runtime-dom/index/"],["40.runtime-dom/10.apiCreateApp.md","apiCreateApp","/vue3/runtime-dom/apiCreateApp/"],["40.runtime-dom/20.apiDefineComponent.md","apiDefineComponent","/vue3/runtime-dom/apiDefineComponent/"],["40.runtime-dom/90.scheduler.md","scheduler","/pages/286896/"]]}],"/30.web/":[["0.index.md","开始上手","/web/index/"],["1.plan.md","Plan 计划","/web/plan/"],{title:"typescript-utility",collapsable:!0,children:[["4.typescript-utility/0.index.md","开始阅读","/ts/index/"],{title:"基础",collapsable:!0,children:[["4.typescript-utility/10.基础/0.index.md","本章概要","/ts/basic/index/"],["4.typescript-utility/10.基础/10.basic-types.md","basic-types 基础类型","/ts/basic/basic-types/"],["4.typescript-utility/10.基础/20.type-manipulation.md","type-manipulation 类型操作","/ts/basic/type-manipulation/"],["4.typescript-utility/10.基础/30.classes.md","classes 类类型","/ts/basic/classes/"],["4.typescript-utility/10.基础/40.reference.md","reference 其他","/ts/basic/reference/"],["4.typescript-utility/10.基础/50.type-zoo.md","type-zoo","/ts/basic/type-zoo/"]]},{title:"类型工具",collapsable:!0,children:[["4.typescript-utility/20.类型工具/0.index.md","本章概要","/ts/utility/index/"],["4.typescript-utility/20.类型工具/10.basic.md","Basic Utility Types","/ts/utility/basic/"],["4.typescript-utility/20.类型工具/20.mapped-types.md","Mapped Types","/ts/utility/mapped/"]]}]},{title:"single-spa源码",collapsable:!0,children:[["5.single-spa源码/0.index.md","开始阅读","/single-spa/index/"],{title:"app与应用管理",collapsable:!0,children:[["5.single-spa源码/10.app与应用管理/0.index.md","本章概要","/single-spa/app/index/"],["5.single-spa源码/10.app与应用管理/10.apps.md","Apps","/single-spa/app/apps/"]]},{title:"lifecycles与生命周期管理",collapsable:!0,children:[["5.single-spa源码/20.lifecycles与生命周期管理/0.index.md","本章概要","/single-spa/lifecycle/index/"],["5.single-spa源码/20.lifecycles与生命周期管理/10.load.md","生命周期：load 和 unload","/single-spa/lifecycle/load/"],["5.single-spa源码/20.lifecycles与生命周期管理/20.bootstrap.md","生命周期：bootstrap","/single-spa/lifecycle/bootstrap/"],["5.single-spa源码/20.lifecycles与生命周期管理/30.mount.md","生命周期：mount 和 unmount","/single-spa/lifecycle/mount/"],["5.single-spa源码/20.lifecycles与生命周期管理/40.update.md","生命周期：update","/single-spa/lifecycle/update/"]]},{title:"navigation与路由管理",collapsable:!0,children:[["5.single-spa源码/30.navigation与路由管理/0.index.md","本章概要","/single-spa/nav/index/"],["5.single-spa源码/30.navigation与路由管理/10.navigation-events.md","navigation-events 路由监听","/single-spa/nav/events/"],["5.single-spa源码/30.navigation与路由管理/20.reroute.md","reroute 根据路由更新应用状态","/single-spa/nav/reroute/"]]},{title:"parcel组件",collapsable:!0,children:[["5.single-spa源码/40.parcel组件/0.index.md","本章概要","/single-spa/nav/parcel/"]]},{title:"其他",collapsable:!0,children:[["5.single-spa源码/50.其他/0.index.md","本章概要","/single-spa/other/index/"],["5.single-spa源码/50.其他/10.customEvent.md","customEvent","/single-spa/other/customEvent/"],["5.single-spa源码/50.其他/20.error.md","错误处理","/single-spa/other/error/"]]},{title:"single-spa-react",collapsable:!0,children:[["5.single-spa源码/60.single-spa-react/0.index.md","本章概要","/single-spa/spa-react/index/"]]}]},{title:"qiankun源码",collapsable:!0,children:[["6.qiankun源码/0.index.md","开始阅读","/qiankun/index/"],{title:"core",collapsable:!0,children:[["6.qiankun源码/10.core/0.index.md","本章概要","/qiankun/core/index/"],["6.qiankun源码/10.core/10.apis.md","核心 API","/qiankun/core/apis/"],["6.qiankun源码/10.core/20.loader.md","loadApp 加载微应用","/qiankun/core/loader/"],["6.qiankun源码/10.core/30.effects.md","Effects","/qiankun/core/effects/"],["6.qiankun源码/10.core/40.prefetch.md","prefetch","/qiankun/core/prefetch/"],["6.qiankun源码/10.core/50.globalState.md","globalState","/qiankun/core/globalState/"],["6.qiankun源码/10.core/60.addon.md","addon","/qiankun/core/addon/"]]},{title:"sandbox",collapsable:!0,children:[["6.qiankun源码/20.sandbox/0.index.md","本章概要","/qiankun/sandbox/index/"],["6.qiankun源码/20.sandbox/10.sandbox.md","createSandboxContainer 创建沙箱","/qiankun/sandbox/sandbox/"],["6.qiankun源码/20.sandbox/20.proxySandbox.md","proxySandbox","/qiankun/sandbox/proxySandbox/"],["6.qiankun源码/20.sandbox/30.snapshotSandbox.md","snapshotSandbox","/qiankun/sandbox/snapshotSandbox/"]]},["6.qiankun源码/999.import-html-entry.md","import-html-entry 原理","/qiankun/import-html-entry/"]]},{title:"webpack",collapsable:!0,children:[["7.webpack/0.index.md","开始阅读","/webpack/init/"],{title:"tapable源码",collapsable:!0,children:[["7.webpack/10.tapable源码/0.index.md","本章概要","/webpack/tapable/index"],["7.webpack/10.tapable源码/10.api.md","Api概述","/webpack/tapable/api/"],["7.webpack/10.tapable源码/20.Hook.md","Hook","/webpack/tapable/hook/"],["7.webpack/10.tapable源码/30.HookCodeFactory.md","HookCodeFactory","/webpack/tapable/factory/"]]},{title:"init阶段",collapsable:!0,children:[["7.webpack/20.init阶段/0.index.md","本章概要","/webpack/init/index/"],["7.webpack/20.init阶段/10.compiler.md","init 阶段：compiler","/webpack/init/compiler/"],["7.webpack/20.init阶段/20.options.md","init 阶段：options","/webpack/init/options/"]]},{title:"make阶段",collapsable:!0,children:[["7.webpack/30.make阶段/0.index.md","本章概要","/webpack/make/index/"],["7.webpack/30.make阶段/10.compilation.md","make 阶段：compilation","/webpack/make/compilation/"],["7.webpack/30.make阶段/20.module.md","make 阶段：module","/webpack/make/module/"],["7.webpack/30.make阶段/30.walk.md","make 阶段：walk","/webpack/make/walk/"]]},{title:"总结",collapsable:!0,children:[["7.webpack/100.总结/10.dp.md","Webpack中的设计模式探讨","/webpack/summary/dp/"],["7.webpack/100.总结/20.ds.md","Webpack 中的数据结构探讨","/webpack/summary/ds/"]]}]},{title:"axios",collapsable:!0,children:[["8.axios/0.index.md","开始阅读","/axios/index/"],{title:"core",collapsable:!0,children:[["8.axios/10.core/0.index.md","本章概要","/axios/core/index/"],["8.axios/10.core/10.axios.md","axios 对象和方法","/axios/core/instance/"],["8.axios/10.core/20.adapter.md","adapter 适配器","/axios/core/adapter/"],["8.axios/10.core/30.interceptor.md","interceptor 拦截器","/axios/core/interceptor/"],["8.axios/10.core/40.cancel.md","cancel 取消请求","/axios/core/cancel/"]]}]},{title:"solid",collapsable:!0,children:[["9.solid/0.index.md","开始上手","/solid/index/"],["9.solid/1.plan.md","计划跟踪","/solid/plan/"],{title:"渲染",collapsable:!0,children:[["9.solid/10.渲染/10.render-jsx.md","渲染原理之组件结构与 JSX 编译","/solid/render/render-by-jsx"]]}]},{title:"vite源码",collapsable:!0,children:[["10.vite源码/0.index.md","开始阅读","/vite/index/"],{title:"基础",collapsable:!0,children:[["10.vite源码/10.基础/0.index.md","本章概要","/vite/basic/index/"]]},{title:"vite",collapsable:!0,children:[["10.vite源码/20.vite/0.index.md","本章概要","/vite/core/index/"],["10.vite源码/20.vite/10.cli.md","cli：vite 的启起点","/vite/core/cli/"],["10.vite源码/20.vite/20.server.md","server： dev server 的创建","/vite/core/server/"]]}]},{title:"jquery源码",collapsable:!0,children:[["50.jquery源码/0.index.md","开始阅读","/jquery/index/"],["50.jquery源码/10.jq-book.md","JQuery 源码分析","/jquery/jq-book/"],["50.jquery源码/20.jq-source.md","JQuery 源码注释","/jquery/jq-source/"],["50.jquery源码/30.extend.md","jQuery 源码问题扩展","/jquery/extend/"]]},{title:"snabbdom",collapsable:!0,children:[["60.snabbdom/0.index.md","开始阅读","/pages/ba82e2/"],{title:"core",collapsable:!0,children:[["60.snabbdom/10.core/10.init.md","init","/pages/cf8075/"],["60.snabbdom/10.core/20.h.md","h","/pages/69bbdd/"],["60.snabbdom/10.core/30.jsx.md","jsx","/pages/fa7d5d/"],["60.snabbdom/10.core/40.vnode.md","vnode","/pages/3f1101/"],["60.snabbdom/10.core/50.thunk.md","thunk","/pages/d02874/"]]},{title:"helper",collapsable:!0,children:[["60.snabbdom/30.helper/10.attachto.md","attachto","/pages/903ddd/"]]}]},{title:"am-editor",collapsable:!0,children:[["70.am-editor/0.index.md","开始阅读","/pages/08c8a2/"],{title:"engine",collapsable:!0,children:[["70.am-editor/10.engine/0.index.md","index","/pages/da29c0/"],["70.am-editor/10.engine/10.engine-basic.md","engine-basic","/pages/33f539/"],["70.am-editor/10.engine/20.engine.md","engine","/pages/518dfe/"],["70.am-editor/10.engine/30.container.md","container","/pages/a35554/"],["70.am-editor/10.engine/40.change.md","change","/pages/53c865/"],["70.am-editor/10.engine/50.range.md","range","/pages/7f2a93/"]]}]},{title:"html2canvas",collapsable:!0,children:[["80.html2canvas/0.index.md","开始阅读","/pages/b58110/"]]},{title:"express",collapsable:!0,children:[["160.express/0.index.md","开始上手","/express/index/"]]},{title:"acorn源码",collapsable:!0,children:[["170.acorn源码/0.index.md","开始上手","/acorn/index/"]]},{title:"immutable.js源码",collapsable:!0,children:[["180.immutable.js源码/0.index.md","开始阅读","/immutable/index/"]]}],"/40.node/":[["0.index.md","开始上手","/node/index/"],["1.plan.md","Plan 计划","/node/plan/"],["2.roadmap.md","roadmap","/node/roadmap/"]],"/50.topic/":[["0.index.md","开始上手","/topic/index/"],{title:"fromTs2Js",collapsable:!0,children:[["10.fromTs2Js/0.index.md","开始阅读","/topic/js2ts/index/"]]}],"/999.目录/":[["10.web.md","Awesome Web","/web/"],["20.node.md","Awesome NodeJS","/node/"],["30.topic.md","主题","/topic/"]]},author:{name:"jonsam",link:"https://github.com/jonsam-ng"},blogger:{avatar:"https://cdn.staticaly.com/gh/jonsam-ng/image-hosting@master/oxygen-space/image.5a0lthv367k0.png",name:"Jonsam NG",slogan:"让有意义的事变得有意思，让有意思的事变得有意义"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:jonsam.ng@foxmail.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/jonsam-ng"},{iconClass:"icon-mao",title:"博客",link:"https://www.jonsam.site"},{iconClass:"icon-shuben",title:"文档",link:"https://docs.jonsam.site"},{iconClass:"icon-code",title:"机器学习",link:"https://ml.jonsam.site"}]},footer:{createYear:2022,copyrightInfo:'Fancy Front End | Made by <a href="https://www.jonsam.site" target="_blank">Jonsam</a> by ❤'},htmlModules:{}},locales:{"/":{lang:"zh-CN",title:"Fancy Front End",description:"前端源码阅读栈，精读 React、Vue3 源码",path:"/"}}};var at=t(52),it=t(51),st=t(106);let lt=!1;var ct={data:()=>({qr:null}),updated(){if(!lt||!this.qr)return;const n=document.querySelector(".nav-links"),e=document.querySelector(".qrcodeBtn");null!=n&&null==e&&this.$nextTick(()=>{const e=document.createElement("DIV");e.className+="nav-item",e.appendChild(this.qr.$el),n.appendChild(e)})},mounted(){if(this.qr||lt)return;lt=!0;const n=new(r.default.extend(st.default));n.$mount(),this.qr=n}};let pt=!1;var dt={mounted(){pt||(window.addEventListener("unload",this.saveLastReading),pt=!0)},methods:{saveLastReading(){localStorage.setItem("lastReading",JSON.stringify({path:this.$route.path,scrollTop:document.documentElement.scrollTop,timestamp:(new Date).getTime()}))}}};let ut=!1;var mt={mounted(){ut||(t.e(189).then(t.t.bind(null,370,7)).then((function(n){r.default.use(n.default,{lang:"zh-CN"})})),ut=!0)}},ht=t(107),ft=t(108),gt=(t(20),t(13));var yt={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:r}}=n;return!(e||!1===t||!0===r)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(gt.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(gt.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(gt.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let r=0,o=n.length;r<o;r++){const{frontmatter:{categories:o,tags:a}}=n[r];"array"===Object(gt.n)(o)&&o.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}),"array"===Object(gt.n)(a)&&a.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};r.default.component(ht.default),r.default.component(ft.default);function bt(n){return n.toString().padStart(2,"0")}t(258);r.default.component("Badges",()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,379))),r.default.component("Bilibili",()=>Promise.resolve().then(t.bind(null,51))),r.default.component("BlockToggle",()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,380))),r.default.component("Card",()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,381))),r.default.component("ClipboardComponent",()=>t.e(14).then(t.bind(null,382))),r.default.component("FontResizer",()=>Promise.all([t.e(0),t.e(7)]).then(t.bind(null,383))),r.default.component("GlobalTip",()=>Promise.all([t.e(0),t.e(8)]).then(t.bind(null,384))),r.default.component("LastReadingPopup",()=>Promise.resolve().then(t.bind(null,52))),r.default.component("Pdf",()=>Promise.all([t.e(0),t.e(3),t.e(9)]).then(t.bind(null,385))),r.default.component("QrCode",()=>Promise.resolve().then(t.bind(null,106))),r.default.component("TimeToRead",()=>Promise.all([t.e(0),t.e(10)]).then(t.bind(null,386))),r.default.component("VideoPlayer",()=>t.e(15).then(t.bind(null,387))),r.default.component("Badge",()=>Promise.all([t.e(0),t.e(12)]).then(t.bind(null,556))),r.default.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,107))),r.default.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,108)));t(259);class vt{constructor(n){Object.defineProperty(this,"registration",{value:n,configurable:!0,writable:!0})}update(){return this.registration.update()}skipWaiting(){const n=this.registration.waiting;return n?(console.log("[vuepress:sw] Doing worker.skipWaiting()."),new Promise((e,t)=>{const r=new MessageChannel;r.port1.onmessage=n=>{console.log("[vuepress:sw] Done worker.skipWaiting()."),n.data.error?t(n.data.error):e(n.data)},n.postMessage({type:"skip-waiting"},[r.port2])})):Promise.resolve()}}var kt=t(15);r.default.component("SWUpdatePopup",()=>Promise.all([t.e(0),t.e(11)]).then(t.bind(null,376)));t(260);var wt=t(105),xt=t.n(wt),Tt=t(32);let Ct,Rt;var Et;"valine"===(Et="gitalk")?t.e(188).then(t.t.bind(null,372,7)).then(n=>Rt=n.default):"gitalk"===Et&&Promise.all([t.e(0),t.e(186)]).then(t.t.bind(null,373,7)).then(()=>t.e(185).then(t.t.bind(null,374,7))).then(n=>Ct=n.default);function St(n,e){const t={};return Reflect.ownKeys(n).forEach(r=>{if("string"==typeof n[r])try{t[r]=xt.a.render(n[r],e)}catch(e){console.warn(`Comment config option error at key named "${r}"`),console.warn("More info: "+e.message),t[r]=n[r]}else t[r]=n[r]}),t}console.log(`How to use "gitalk" in ${Tt.name}@v${Tt.version}:`,Tt.homepage);const Pt={gitalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t);new Ct(St({clientID:"d3180fd85e7addd9c036",clientSecret:"933c6df009c1d8264e247ce9c1a68687dff0b5f6",repo:"fancy-front-end",owner:"jonsam-ng",admin:["jonsam-ng"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},valine:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new Rt({...St({clientID:"d3180fd85e7addd9c036",clientSecret:"933c6df009c1d8264e247ce9c1a68687dff0b5f6",repo:"fancy-front-end",owner:"jonsam-ng",admin:["jonsam-ng"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}}},_t="vuepress-plugin-comment";let It=null;function jt(n){return Pt.gitalk.clear(_t)}function Ot(n){return!1!==n.comment&&!1!==n.comments}function Ft(n){clearTimeout(It);if(document.querySelector("main.page"))return Pt.gitalk.render(n,_t);It=setTimeout(()=>Ft(n),200)}var At={mounted(){It=setTimeout(()=>{const n={to:{},from:{},...this.$frontmatter};jt()&&Ot(n)&&Ft(n)},1e3),this.$router.afterEach((n,e)=>{if(n&&e&&n.path===e.path)return;const t={to:n,from:e,...this.$frontmatter};jt()&&Ot(t)&&Ft(t)})}},Mt=Object(et.a)(At,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,Dt=(t(266),t(267),!0),zt="lazy",qt="200px",Lt=[({Vue:n,options:e,router:t,siteData:r,isServer:o})=>{const{options:a}=t;n.component(at.default.name,at.default),n.component(it.default.name,it.default),n.mixin(dt),n.mixin(ct),n.mixin(mt)},({Vue:n,options:e,router:t,siteData:r})=>{r.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${bt(n.getUTCMonth()+1)}-${bt(n.getUTCDate())} ${bt(n.getUTCHours())}:${bt(n.getUTCMinutes())}:${bt(n.getUTCSeconds())}`}(e)),t?n.author=t:r.themeConfig.author&&(n.author=r.themeConfig.author)}),n.mixin(yt)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},async({router:n,isServer:e})=>{if(!e){const{register:e}=await t.e(187).then(t.bind(null,371));n.onReady(()=>{e("/service-worker.js",{registrationOptions:{},ready(){console.log("[vuepress:sw] Service worker is active."),kt.a.$emit("sw-ready")},cached(n){console.log("[vuepress:sw] Content has been cached for offline use."),kt.a.$emit("sw-cached",new vt(n))},updated(n){console.log("[vuepress:sw] Content updated."),kt.a.$emit("sw-updated",new vt(n))},offline(){console.log("[vuepress:sw] No internet connection found. App is running in offline mode."),kt.a.$emit("sw-offline")},error(n){console.error("[vuepress:sw] Error during service worker registration:",n),kt.a.$emit("sw-error",n),GA_ID&&ga("send","exception",{exDescription:n.message,exFatal:!1})}})})}},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?634139bf8239f41da83be0a03473f9ff";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},({Vue:n})=>{n.component("Comment",Mt)},{},({Vue:n})=>{n.mixin({data:()=>({$io:void 0}),mounted(){const n=document.querySelectorAll("img."+zt);Dt&&"loading"in HTMLImageElement.prototype?n.forEach(n=>{!n.getAttribute("src")&&n.setAttribute("src",n.getAttribute("data-src"))}):(this.setObserver(),n.forEach(n=>{this.$io.observe(n)}))},methods:{setObserver(){this.$io=new IntersectionObserver(n=>{n.forEach(n=>{if(n.isIntersecting){const e=this.getSrc(n.target);e&&(n.target.src=e),this.$io.unobserve(n.target)}})},{rootMargin:qt})},getSrc(n){if(n.dataset)return n.dataset.src;{const e=n.attributes.find(n=>"data-src"===n.nodeName);return e&&e.nodeValue}}}})}],Ut=["SWUpdatePopup","Comment","LastReadingPopup","GlobalTip","BlockToggle"];class Nt extends class{constructor(){this.store=new r.default({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){r.default.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Nt.prototype,{getPageAsyncComponent:Gn.d,getLayoutAsyncComponent:Gn.c,getAsyncComponent:Gn.b,getVueComponent:Gn.e});var Ht={install(n){const e=new Nt;n.$vuepress=e,n.prototype.$vuepress=e}};function Wt(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Bt={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return Object(Gn.h)("pageKey",e),r.default.component(e)||r.default.component(e,Object(Gn.d)(e)),r.default.component(e)?n(e):n("")}},$t={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Vt={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Kt=(t(268),t(269),Object(et.a)(Vt,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Jt={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};r.default.config.productionTip=!1,r.default.use(Kn),r.default.use(Ht),r.default.mixin(function(n,e,t=r.default){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const o=new(n(t.$vuepress.$get("siteData"))),a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(o)),i={};return Object.keys(a).reduce((n,e)=>(e.startsWith("$")&&(n[e]=a[e].get),n),i),{computed:i}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},ot)),r.default.component("Content",Bt),r.default.component("ContentSlotsDistributor",$t),r.default.component("OutboundLink",Kt),r.default.component("ClientOnly",Jt),r.default.component("Layout",Object(Gn.c)("Layout")),r.default.component("NotFound",Object(Gn.c)("NotFound")),r.default.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.7",hash:"bafe71e"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:ot.routerBase||ot.base,t=new Kn({base:e,mode:"history",fallback:!1,routes:rt,scrollBehavior:(n,e,t)=>t||(n.hash?!r.default.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(Wt(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Wt(n,t)?r(t):r()}else r();else{const t=e.path+"/",o=e.path+".html";Wt(n,o)?r(o):Wt(n,t)?r(t):r()}})}(t);const o={};try{await Promise.all(Lt.filter(n=>"function"==typeof n).map(e=>e({Vue:r.default,options:o,router:t,siteData:ot,isServer:n})))}catch(n){console.error(n)}return{app:new r.default(Object.assign(o,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Ut.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);