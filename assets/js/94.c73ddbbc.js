(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{466:function(t,e,s){"use strict";s.r(e);var n=s(2),a=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"utility-types-实用类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#utility-types-实用类型"}},[t._v("#")]),t._v(" Utility Types 实用类型")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("Partial<Type>")])])]),t._v(" "),e("p",[t._v("Constructs a type with all properties of Type set to optional. This utility will return a type that represents all subsets of a given type.\n 构造具有 Type 的所有属性设置为可选的类型。此实用程序将返回表示给定类型的所有子集的类型。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("Required<Type>")])])]),t._v(" "),e("p",[t._v("Constructs a type consisting of all properties of Type set to required. The opposite of Partial.\n 构造一个包含 Type 设置为 required 的所有属性的类型。与 Partial 相反。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("Readonly<Type>")])])]),t._v(" "),e("p",[t._v("Constructs a type with all properties of Type set to readonly, meaning the properties of the constructed type cannot be reassigned.\n 构造具有 Type 的所有属性设置为只读的类型，这意味着不能重新分配构造类型的属性。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("Record<Keys, Type>")])])]),t._v(" "),e("p",[t._v("Constructs an object type whose property keys are Keys and whose property values are Type. This utility can be used to map the properties of a type to another type.\n 构造属性键为 Keys、属性值为 Type 的对象类型。此实用工具可用于将一个类型的属性映射到另一个类型。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("Pick<Type, Keys>")])])]),t._v(" "),e("p",[t._v("Constructs a type by picking the set of properties Keys (string literal or union of string literals) from Type.\n 通过从 Type 中选择一组属性 Keys (字符串文本或字符串文本的并集) 来构造类型。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("Omit<Type, Keys>")])])]),t._v(" "),e("p",[t._v("Constructs a type by picking all properties from Type and then removing Keys (string literal or union of string literals).\n 通过从 Type 中选取所有属性，然后移除 Keys (字符串文字或字符串文字的并集) 来构造类型。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("Exclude<Type, ExcludedUnion>")])])]),t._v(" "),e("p",[t._v("Constructs a type by excluding from Type all "),e("strong",[t._v("union members")]),t._v(" that are assignable to ExcludedUnion.\n 通过从类型中排除可分配给 ExcludedUnion 的所有联合成员来构造类型。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("Extract<Type, Union>")])])]),t._v(" "),e("p",[t._v("Constructs a type by extracting from Type all union members that are assignable to Union.\n 通过从 Type 中提取可分配给 Union 的所有联合成员来构造类型。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("NonNullable<Type>")])])]),t._v(" "),e("p",[t._v("Constructs a type by excluding null and undefined from Type.\n 通过从 Type 中排除 null 和 undefined 来构造类型。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("Parameters<Type>")])])]),t._v(" "),e("p",[t._v("Constructs a tuple type from the types used in the parameters of a function type Type.\n 从函数类型类型的参数中使用的类型构造元组类型。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("ConstructorParameters<Type>")])])]),t._v(" "),e("p",[t._v("Constructs a tuple or array type from the types of a constructor function type. It produces a tuple type with all the parameter types (or the type never if Type is not a function).\n 从构造函数类型的类型构造元组或数组类型。它生成具有所有参数类型的元组类型 (如果 Type 不是函数，则生成 never 类型)。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("ReturnType<Type>")])])]),t._v(" "),e("p",[t._v("Constructs a type consisting of the return type of function Type.\n 构造一个类型，包含函数 Type 的返回类型。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("InstanceType<Type>")])])]),t._v(" "),e("p",[t._v("Constructs a type consisting of the instance type of a constructor function in Type.\n 构造由 Type 中构造函数的实例类型组成的类型。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("ThisParameterType<Type>")])])]),t._v(" "),e("p",[t._v("Extracts the type of the this parameter for a function type, or unknown if the function type has no this parameter.\n 提取函数类型的此参数的类型，如果函数类型没有此参数，则未知。")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("OmitThisParameter<Type>")])])]),t._v(" "),e("p",[t._v("Removes the this parameter from Type. If Type has no explicitly declared this parameter, the result is simply Type. Otherwise, a new function type with no this parameter is created from Type. Generics are erased and only the last overload signature is propagated into the new function type.\n 从 Type 中移除此参数。如果 Type 没有显式声明此参数，则结果只是 Type。否则，将从 Type 创建没有此参数的新函数类型。泛型被擦除，只有最后一个重载签名被传播到新的函数类型中。")]),t._v(" "),e("div",{staticClass:"language-ts line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-ts"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("toHex")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Number"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("toString")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n \n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" fiveToHex"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" OmitThisParameter"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" toHex"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("toHex")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("bind")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n \n"),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("fiveToHex")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br")])]),e("ul",[e("li",[e("code",[t._v("ThisType<Type>")])])]),t._v(" "),e("p",[t._v("This utility does not return a transformed type. Instead, it serves as a marker for a contextual this type. Note that the noImplicitThis flag must be enabled to use this utility.\n 此实用程序不返回转换后的类型。相反，它可以作为这种类型上下文的标记。请注意，必须启用 noImplicitThis 标志才能使用此实用程序。")]),t._v(" "),e("ul",[e("li",[t._v("Intrinsic String Manipulation Types")])]),t._v(" "),e("ol",[e("li",[e("code",[t._v("Uppercase<StringType>")])]),t._v(" "),e("li",[e("code",[t._v("Lowercase<StringType>")])]),t._v(" "),e("li",[e("code",[t._v("Capitalize<StringType>")])]),t._v(" "),e("li",[e("code",[t._v("Uncapitalize<StringType>")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);