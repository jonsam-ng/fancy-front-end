---
title: React 源码漂流记：React 调和器核心源码解读（三）
date: 2022-07-12 12:02:21
permalink: /react/tour/react-reconciliation-3/
categories:
  - react
  - tour
tags:
  - 
---

<Badges :content="[{type: 'tip', text: 'React17'}, {type: 'tip', text: '精简'}]" />

<TimeToRead />

## 目录

[[TOC]]

## 前言

在上一篇文章中，我们探讨了 React 调和器中 `scheduleSyncCallback`、`scheduleCallback` 、`performSyncWorkOnRoot` 和 `performConcurrentWorkOnRoot` 四个核心函数，概括而言，其作用是：同步任务和异步任务的调度和任务回调。在本篇文章中我们就沿着上文中任务回调的入口继续深入，探讨调和器中 `Render` 的过程。

## renderRootSync

这个函数是在同步任务的回调的 Render 阶段调用，目的是对当前的 FiberRoot 进行渲染。

::: warning 注意
这里所谓的渲染，并不是说将 VDOM 转化为 DOM 并绘制到浏览器的过程。需要注意的是，`Render` 过程，即渲染过程实际上是一棵 FiberTree 真正调和的过程。所谓调和，就是新的 FiberTree 替代旧的 FiberTree，成为 currentFiberTree 的过程（FiberTree 的双缓存结构，后文详述）。而真正将 VDOM 转化为 DOM（或者 Render String），则是在 `Commit` 过程完成的。
:::

下面我们来看下源码：

```js
function renderRootSync(root: FiberRoot, lanes: Lanes) {
  const prevExecutionContext = executionContext;
  // executionContext 添加 RenderContext
  executionContext |= RenderContext;
  // 更改当前 dispatcher 为 contextOnlyDispatcher，并且返回原来的 dispatcher
  const prevDispatcher = pushDispatcher();
  // ......
  do {
    try {
      // 启动 workLoop
      workLoopSync();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);
  // ......
  // Render 阶段结束，恢复之后的 dispatcher
  executionContext = prevExecutionContext;
  popDispatcher(prevDispatcher);
  // ......

  // Set this to null to indicate there's no in-progress render.
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;

  return workInProgressRootExitStatus;
}
```

这里有几点核心的内容：

- `workLoopSync` 开启了一个渲染循环，这样一个循环就体现在遍历的思想上，是对 FiberTree 进行一个深度优先遍历（DFS）。我们将在后文进行详细的探讨。
- 返回 `workInProgressRootExitStatus` 是在整个 `src/react/packages/react-reconciler/src/ReactFiberWorkLoop.new.js` 文件中维护的，也就是在整个 `ReactFiberWorkLoop` 中维护的。在 workLoop 的执行过程中，`exitStatus` 总能保持最新的执行状态。
- 在执行到 `renderRootSync` 函数中时，`executionContext` 被更新到 `RenderContext` 状态。这里有位运算的内容，详细可参见[位运算怎么理解？](/react/tour/react-reconciliation-1/#位运算怎么理解)。

另外，还有一些值得注意的问题：

- `pushDispatcher` 和 `popDispatcher` 是在做什么？dispatcher 实际上是和 hook 相关的内容，在 `pushDispatcher` 中将 `ReactCurrentDispatcher.current` 设置为 `ContextOnlyDispatcher`，这种状态下的 hook 在调用时会报错。这是因为 hook 在 `Render` 阶段是不可调用的。我们在 hook 原理相关的章节会详细介绍。
- 在执行完 `Render` 过程之后，`executionContext` 恢复了之前的状态，即 `Batch` 状态。这也是为什么在进行 `Render` 状态和 `Commit` 状态之前都要检查是否不是已经处于这两种状态。

## renderRootConcurrent

这个函数是在异步任务的回调的 `Render` 阶段调用，目的是对当前的 FiberRoot 进行渲染。

```js
function renderRootConcurrent(root: FiberRoot, lanes: Lanes) {
  const prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  const prevDispatcher = pushDispatcher();

  // ......
  do {
    try {
      workLoopConcurrent();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);
  // ......

  popDispatcher(prevDispatcher);
  executionContext = prevExecutionContext;

  // Set this to null to indicate there's no in-progress render.
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;

  // Return the final exit status.
  return workInProgressRootExitStatus;
}
```

总体流程与 `renderRootSync` 一致，只是在 workLoop 函数使用了 `workLoopConcurrent`。不再赘述。

另外，我们来探讨下这里的错误处理机制，即 `handleError`函数。

```js
function handleError(root, thrownValue): void {
  do {
    // 当前的 workInProgress 即为出错的 Fiber
    let erroredWork = workInProgress;
    try {
      // ......
      if (erroredWork === null || erroredWork.return === null) {
        // Expected to be working on a non-root fiber. This is a fatal error
        // because there's no ancestor that can handle it; the root is
        // supposed to capture all errors that weren't caught by an error
        // boundary.
        // 这是一个致命错误，因为这是一个没有父节点的 Fiber。因此，此 Fiber 上出现的错误不可冒泡处理。
        workInProgressRootExitStatus = RootFatalErrored;
        workInProgressRootFatalError = thrownValue;
        workInProgress = null;
        return;
      }
      // ......

      throwException(
        root,
        erroredWork.return,
        erroredWork,
        thrownValue,
        workInProgressRootRenderLanes,
      );
      // 结束 workLoop
      completeUnitOfWork(erroredWork);
    } catch (yetAnotherThrownValue) {
      // ......
    }
    // Return to the normal work loop.
    return;
  } while (true);
}
```

- 如果发生错误的 Fiber 没有父结果则为致命错误，因为无法通过冒泡机制找到捕获错误的目标。
- 如果是普通错误，则结束本次 `unitOfWork`（当前 Fiber 上的调和工作），返回正常的 workLoop 循环之中。

## workLoopSync

```js
// The work loop is an extremely hot path. Tell Closure not to inline it.
/** @noinline */
function workLoopSync() {
  // Already timed out, so perform work without checking if we need to yield.
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
```

## workLoopConcurrent

```js
/** @noinline */
function workLoopConcurrent() {
  // Perform work until Scheduler asks us to yield
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```

## performUnitOfWork

## 问题

## 总结

通过本篇文章的探讨，有如下的重点内容需要重点关注：
