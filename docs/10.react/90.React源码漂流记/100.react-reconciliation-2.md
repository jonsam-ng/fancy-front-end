---
title: React 源码漂流记：React 调和器核心源码解读（二）
date: 2022-04-14 22:02:21
permalink: /react/tour/react-reconciliation-2/
categories:
  - react
  - tour
tags:
  - 
---

<Badges :content="[{type: 'tip', text: 'React17'}, {type: 'tip', text: '精简'}]" />

<TimeToRead />

## 目录

[[TOC]]

## 前言

在上一篇文章中，我们探讨了 `updateContainer`、`scheduleUpdateOnFiber` 和 `ensureRootIsScheduled` 三个核心函数的原理和作用。如果从整个渲染任务周期来看，主要涉及到生产首次渲染任务、任务在容器上的调度、任务基于调度器的分发几个过程。

细心的同学可能已经发现，在 `ensureRootIsScheduled` 中已经涉及到调度器的内容了，即 `scheduleCallback` 向调度器发起的调度请求。但是基于分层阅读的原则，本篇文章将不会讲解调度器的内容，我们只需要了解到**异步任务是在调度器在合适的时间时回调执行**的即可。这样，本文将继续调和器的解读，探讨同步任务和异步任务的调度和 Batch 阶段向 Render 阶段的过渡的过程。

------

在上一篇文章中对 ensureRootIsScheduled 的分析中我们了解到，ensureRootIsScheduled 对同步任务和异步任务分别进行了同步调度和异步调度的分发，分别调用 scheduleSyncCallback 和 scheduleCallback 这两个函数。现在我们就来具体分析这两个函数：

## scheduleSyncCallback

同步调度和异步调度相比有两个明显的不同之处：

1. 同步调度一般不会经过调度器。
2. 同步调度在调度器之外维护同步任务队列。

在下面的探讨中，我们会逐渐体会到这两点不同。

```js
// src/react/packages/react-reconciler/src/ReactFiberSyncTaskQueue.new.js
export function scheduleSyncCallback(callback: SchedulerCallback) {
  // 如果任务队列未初始化则初始化队列，将当前的任务加入同步任务队列
  if (syncQueue === null) {
    syncQueue = [callback];
  } else {
    syncQueue.push(callback);
  }
}
```

scheduleSyncCallback 维护同步任务队列，在微任务的回调中执行 flushSyncCallbacks，此函数将全数消费同步任务队列。

### flushSyncCallbacks

```js
// src/react/packages/react-reconciler/src/ReactFiberSyncTaskQueue.new.js
export function flushSyncCallbacks() {
  // isFlushingSyncQueue 是 syncQueue 的互斥锁，消费 callbacks 是一个互斥操作
  if (!isFlushingSyncQueue && syncQueue !== null) {
    // 关闭互斥锁
    isFlushingSyncQueue = true;
    let i = 0;
    const previousUpdatePriority = getCurrentUpdatePriority();
    try {
      const isSync = true;
      const queue = syncQueue;
      setCurrentUpdatePriority(DiscreteEventPriority);
      // flush syncQueue，每个 callback 可以返回一个新的 callback
      for (; i < queue.length; i++) {
        let callback = queue[i];
        do {
          callback = callback(isSync);
        } while (callback !== null);
      }
      // 重置 syncQueue
      syncQueue = null;
      includesLegacySyncCallbacks = false;
    } catch (error) {
      // If something throws, leave the remaining callbacks on the queue.
      // 如果syncQueue 中某个 Callback 发生了错误，则跳过此项
      if (syncQueue !== null) {
        syncQueue = syncQueue.slice(i + 1);
      }
      // Resume flushing in the next tick
      // 调度在下一个调度中继续执行
      scheduleCallback(ImmediatePriority, flushSyncCallbacks);
      throw error;
    } finally {
      setCurrentUpdatePriority(previousUpdatePriority);
      isFlushingSyncQueue = false;
    }
  }
  return null;
}
```

现在让我们回到上文所讲的同步任务相比于异步任务的区别，从宏观上上看，同步调度这样设计有如下的原因：

1. 同步调度优先级最高，具有充足的原因绕过调度器使任务尽快的得到执行。至于使用微任务或者宏任务和间接达到调度的目的，是为了减小消费同步任务队列时产生的执行代码的压力。同时，同步任务队列在每次执行同步任务时将任务全数消费，也能够间接看出这一点。
2. 同步调度具有较好的容错性，当某一个任务抛出了错误，程序会跳过错误的任务，并且在下一次`ImmediatePriority`优先级的异步调度中继续执行。

## scheduleCallback

这部分会与调度器交互，在 react 中，调度器是一个单独的模块，这里不再展开。现在需要知道的是，调度器会根据各种异步任务的优先级选择高优先级的任务进行回调，回调中执行 performSyncWorkOnRoot。

```js
function scheduleCallback(priorityLevel, callback) {
 // In production, always call Scheduler. This function will be stripped out.
 return Scheduler_scheduleCallback(priorityLevel, callback);
}
```

其中，`Scheduler_scheduleCallback` 是调度器提供的方法。

## performSyncWorkOnRoot

在上文的探讨中，我们知道了同步任务和异步任务是如何通过调度器进行回调来执行任务的，下面我们来看看具体同步任务是如何执行的。

```js
// This is the entry point for synchronous tasks that don't go
// through Scheduler
function performSyncWorkOnRoot(root) {
  // 如果当前是 Render 节点或者 Commit 阶段就报错，因为当前应该处于 Batch 阶段
  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
    throw new Error('Should not already be working.');
  }
  // ......
  // 获取 FiberRoot 上下一次执行的 lanes
  let lanes = getNextLanes(root, NoLanes);
  // 如果 lanes 中没有同步的 lanes
  if (!includesSomeLane(lanes, SyncLane)) {
    // There's no remaining sync work left.
    ensureRootIsScheduled(root, now());
    return null;
  }
  // 同步渲染 FiberRoot，并且返回渲染结果 exitStatus
  let exitStatus = renderRootSync(root, lanes);
  // 如果发生了普通错误，即 RootErrored，获取重试的优先级，并同步重试渲染  50 次
  // ......
  // 如果发生了严重错误，即 RootFatalErrored，抛出错误，将 FiberRoot 标记为 suspend
  // ......

  // We now have a consistent tree. Because this is a sync render, we
  // will commit it even if something suspended.
  // 渲染完毕，标记 finishedWork 和 finishedLanes，并且 Commit 当前的 FiberRoot
  const finishedWork: Fiber = (root.current.alternate: any);
  root.finishedWork = finishedWork;
  root.finishedLanes = lanes;
  commitRoot(root);

  // Before exiting, make sure there's a callback scheduled for the next
  // pending level.
  ensureRootIsScheduled(root, now());

  return null;
}
```

这个函数的主要作用如下：

- 调用 renderRootSync 在 FiberRoot 上进行渲染。根据返回的结果进行错误处理，根据错误的类型选择不同的错误处理策略。
- 标记 finishedWork 和 finishedLanes 用于下次调度。
- 调用 `commitRoot` 在 FiberRoot 上 Commit 此次渲染。
- 调用 `ensureRootIsScheduled` 确保 FiberRoot 

## performConcurrentWorkOnRoot

## 扩展

## 问题

## 总结
